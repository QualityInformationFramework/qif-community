// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_CHARACTERISTICS_HXX
#define CXX___QIFLIBRARY_CHARACTERISTICS_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class CharacteristicBaseType;
    class CharacteristicItemBaseType;
    class CriticalityLevelEnumType;
    class CriticalityAreaEnumType;
    class CriticalityType;
    class CharacteristicBalloonLocationEnumType;
    class CharacteristicBalloonStyleEnumType;
    class CharacteristicBalloonType;
    class CharacteristicDesignatorType;
    class LocationOnDrawingType;
    class CharacteristicDefinitionBaseType;
    class CharacteristicNominalBaseType;
    class CharacteristicMeasurementBaseType;
    class AssociatedTolerancedFeatureSpecificationElementEnumType;
    class ReferenceFeatureAssociationSpecificationElementEnumType;
    class ReferenceFeatureAssociationSpecificationParameterEnumType;
    class SingleNestingIndexFilterSymbolEnumType;
    class SingleNestingIndexFilterType;
    class DualNestingIndexFilterSymbolEnumType;
    class DualNestingIndexFilterType;
    class FilterType;
    class ReferenceFeatureAssociationSpecificationElementType;
    class GeometricCharacteristicDefinitionBaseType;
    class GeometricCharacteristicNominalBaseType;
    class GeometricCharacteristicMeasurementBaseType;
    class GeometricCharacteristicItemBaseType;
    class DimensionalCharacteristicDefinitionBaseType;
    class DimensionalCharacteristicNominalBaseType;
    class DimensionalCharacteristicMeasurementBaseType;
    class DimensionalCharacteristicItemBaseType;
    class CoordinateCharacteristicDefinitionBaseType;
    class CoordinateCharacteristicNominalBaseType;
    class CoordinateCharacteristicMeasurementBaseType;
    class CoordinateCharacteristicItemBaseType;
    class UserDefinedAttributeCharacteristicDefinitionType;
    class UserDefinedAttributeCharacteristicNominalType;
    class UserDefinedAttributeCharacteristicMeasurementType;
    class UserDefinedAttributeCharacteristicItemType;
    class StringValuesType;
    class LinearCharacteristicDefinitionBaseType;
    class UserDefinedLinearCharacteristicDefinitionType;
    class LinearCharacteristicNominalBaseType;
    class UserDefinedLinearCharacteristicNominalType;
    class LinearCharacteristicMeasurementBaseType;
    class UserDefinedLinearCharacteristicMeasurementType;
    class LinearCharacteristicItemBaseType;
    class UserDefinedLinearCharacteristicItemType;
    class AngularCharacteristicDefinitionBaseType;
    class UserDefinedAngularCharacteristicDefinitionType;
    class AngularCharacteristicNominalBaseType;
    class UserDefinedAngularCharacteristicNominalType;
    class AngularCharacteristicMeasurementBaseType;
    class UserDefinedAngularCharacteristicMeasurementType;
    class AngularCharacteristicItemBaseType;
    class UserDefinedAngularCharacteristicItemType;
    class TemperatureCharacteristicDefinitionBaseType;
    class TemperatureCharacteristicNominalBaseType;
    class TemperatureCharacteristicMeasurementBaseType;
    class TemperatureCharacteristicItemBaseType;
    class UserDefinedTemperatureCharacteristicDefinitionType;
    class UserDefinedTemperatureCharacteristicNominalType;
    class UserDefinedTemperatureCharacteristicMeasurementType;
    class UserDefinedTemperatureCharacteristicItemType;
    class AreaCharacteristicDefinitionBaseType;
    class AreaCharacteristicNominalBaseType;
    class AreaCharacteristicMeasurementBaseType;
    class AreaCharacteristicItemBaseType;
    class UserDefinedAreaCharacteristicDefinitionType;
    class UserDefinedAreaCharacteristicNominalType;
    class UserDefinedAreaCharacteristicMeasurementType;
    class UserDefinedAreaCharacteristicItemType;
    class ForceCharacteristicDefinitionBaseType;
    class ForceCharacteristicNominalBaseType;
    class ForceCharacteristicMeasurementBaseType;
    class ForceCharacteristicItemBaseType;
    class UserDefinedForceCharacteristicDefinitionType;
    class UserDefinedForceCharacteristicNominalType;
    class UserDefinedForceCharacteristicMeasurementType;
    class UserDefinedForceCharacteristicItemType;
    class MassCharacteristicDefinitionBaseType;
    class MassCharacteristicNominalBaseType;
    class MassCharacteristicMeasurementBaseType;
    class MassCharacteristicItemBaseType;
    class UserDefinedMassCharacteristicDefinitionType;
    class UserDefinedMassCharacteristicNominalType;
    class UserDefinedMassCharacteristicMeasurementType;
    class UserDefinedMassCharacteristicItemType;
    class PressureCharacteristicDefinitionBaseType;
    class PressureCharacteristicNominalBaseType;
    class PressureCharacteristicMeasurementBaseType;
    class PressureCharacteristicItemBaseType;
    class UserDefinedPressureCharacteristicDefinitionType;
    class UserDefinedPressureCharacteristicNominalType;
    class UserDefinedPressureCharacteristicMeasurementType;
    class UserDefinedPressureCharacteristicItemType;
    class SpeedCharacteristicDefinitionBaseType;
    class SpeedCharacteristicNominalBaseType;
    class SpeedCharacteristicMeasurementBaseType;
    class SpeedCharacteristicItemBaseType;
    class UserDefinedSpeedCharacteristicDefinitionType;
    class UserDefinedSpeedCharacteristicNominalType;
    class UserDefinedSpeedCharacteristicMeasurementType;
    class UserDefinedSpeedCharacteristicItemType;
    class TimeCharacteristicDefinitionBaseType;
    class TimeCharacteristicNominalBaseType;
    class TimeCharacteristicMeasurementBaseType;
    class TimeCharacteristicItemBaseType;
    class UserDefinedTimeCharacteristicDefinitionType;
    class UserDefinedTimeCharacteristicNominalType;
    class UserDefinedTimeCharacteristicMeasurementType;
    class UserDefinedTimeCharacteristicItemType;
    class UserDefinedUnitCharacteristicDefinitionType;
    class UserDefinedUnitCharacteristicNominalType;
    class UserDefinedUnitCharacteristicMeasurementType;
    class UserDefinedUnitCharacteristicItemType;
    class CompositeSegmentDefinitionBaseType;
    class CompositeSegmentMeasurementBaseType;
    class CompositeSegmentPositionDefinitionType;
    class CompositeSegmentPositionMeasurementType;
    class CompositeSegmentProfileDefinitionType;
    class CompositeSegmentProfileMeasurementType;
    class CompositeSegmentSymmetryDefinitionType;
    class CompositeSegmentSymmetryMeasurementType;
    class OriginReferenceType;
    class SurfaceTextureCharacteristicDefinitionType;
    class RoughnessLayEnumType;
    class RoughnessObtentionEnumType;
    class RoughnessApplicabilityEnumType;
    class SurfaceTextureCharacteristicNominalType;
    class SurfaceTextureCharacteristicMeasurementType;
    class SurfaceTextureCharacteristicItemType;
    class OrientationDiametricalZoneType;
    class OrientationPlanarZoneType;
    class OrientationZoneShapeType;
    class OrientationCharacteristicItemBaseType;
    class OrientationCharacteristicDefinitionBaseType;
    class OrientationCharacteristicNominalBaseType;
    class OrientationCharacteristicMeasurementBaseType;
    class AngularityCharacteristicItemType;
    class AngularityCharacteristicDefinitionType;
    class AngularityCharacteristicNominalType;
    class AngularityCharacteristicMeasurementType;
    class PerpendicularityCharacteristicItemType;
    class PerpendicularityCharacteristicDefinitionType;
    class PerpendicularityCharacteristicNominalType;
    class PerpendicularityCharacteristicMeasurementType;
    class ParallelismCharacteristicItemType;
    class ParallelismCharacteristicDefinitionType;
    class ParallelismCharacteristicNominalType;
    class ParallelismCharacteristicMeasurementType;
    class FormCharacteristicDefinitionBaseType;
    class FormCharacteristicNominalBaseType;
    class FormCharacteristicMeasurementBaseType;
    class FormCharacteristicItemBaseType;
    class StraightnessDiametricalZoneType;
    class StraightnessNonDiametricalZoneType;
    class StraightnessZoneShapeType;
    class StraightnessCharacteristicItemType;
    class StraightnessCharacteristicDefinitionType;
    class StraightnessCharacteristicNominalType;
    class StraightnessCharacteristicMeasurementType;
    class FlatnessCharacteristicItemType;
    class FlatnessCharacteristicDefinitionType;
    class FlatnessCharacteristicNominalType;
    class FlatnessCharacteristicMeasurementType;
    class CircularityCharacteristicItemType;
    class CircularityCharacteristicDefinitionType;
    class CircularityCharacteristicNominalType;
    class CircularityCharacteristicMeasurementType;
    class ConicityCharacteristicItemType;
    class ConicityCharacteristicDefinitionType;
    class ConicityCharacteristicNominalType;
    class ConicityCharacteristicMeasurementType;
    class CylindricityCharacteristicItemType;
    class CylindricityCharacteristicDefinitionType;
    class CylindricityCharacteristicNominalType;
    class CylindricityCharacteristicMeasurementType;
    class EllipticityCharacteristicItemType;
    class EllipticityCharacteristicDefinitionType;
    class EllipticityCharacteristicNominalType;
    class EllipticityCharacteristicMeasurementType;
    class SphericityCharacteristicItemType;
    class SphericityCharacteristicDefinitionType;
    class SphericityCharacteristicNominalType;
    class SphericityCharacteristicMeasurementType;
    class ToroidicityCharacteristicItemType;
    class ToroidicityCharacteristicDefinitionType;
    class ToroidicityCharacteristicNominalType;
    class ToroidicityCharacteristicMeasurementType;
    class OtherFormCharacteristicItemType;
    class OtherFormCharacteristicDefinitionType;
    class OtherFormCharacteristicNominalType;
    class OtherFormCharacteristicMeasurementType;
    class LocationCharacteristicItemBaseType;
    class LocationCharacteristicDefinitionBaseType;
    class LocationCharacteristicNominalBaseType;
    class LocationCharacteristicMeasurementBaseType;
    class PositionCharacteristicItemType;
    class PositionSphericalZoneType;
    class PositionDiametricalZoneType;
    class PositionNonDiametricalZoneType;
    class PositionZoneShapeType;
    class PositionCharacteristicDefinitionType;
    class PositionCharacteristicNominalType;
    class PositionCharacteristicMeasurementType;
    class AngleCharacteristicItemType;
    class AngleCharacteristicDefinitionType;
    class AngleCharacteristicNominalType;
    class AngleCharacteristicMeasurementType;
    class AngleFromCharacteristicItemType;
    class AngleFromCharacteristicDefinitionType;
    class AngleFromCharacteristicNominalType;
    class AngleFromCharacteristicMeasurementType;
    class AngleBetweenCharacteristicItemType;
    class AngleBetweenCharacteristicDefinitionType;
    class AngleBetweenCharacteristicNominalType;
    class AngleBetweenCharacteristicMeasurementType;
    class LinearCoordinateCharacteristicItemType;
    class LinearCoordinateCharacteristicDefinitionType;
    class LinearCoordinateCharacteristicNominalType;
    class LinearCoordinateCharacteristicMeasurementType;
    class AngularCoordinateCharacteristicItemType;
    class AngularCoordinateCharacteristicDefinitionType;
    class AngularCoordinateCharacteristicNominalType;
    class AngularCoordinateCharacteristicMeasurementType;
    class CurveLengthCharacteristicItemType;
    class CurveLengthCharacteristicDefinitionType;
    class CurveLengthCharacteristicNominalType;
    class CurveLengthCharacteristicMeasurementType;
    class DiameterCharacteristicItemType;
    class DiameterCharacteristicDefinitionType;
    class DiameterCharacteristicNominalType;
    class DiameterCharacteristicMeasurementType;
    class SphericalDiameterCharacteristicItemType;
    class SphericalDiameterCharacteristicDefinitionType;
    class SphericalDiameterCharacteristicNominalType;
    class SphericalDiameterCharacteristicMeasurementType;
    class LengthCharacteristicItemType;
    class LengthCharacteristicDefinitionType;
    class LengthCharacteristicNominalType;
    class LengthCharacteristicMeasurementType;
    class WidthCharacteristicItemType;
    class WidthCharacteristicDefinitionType;
    class WidthCharacteristicNominalType;
    class WidthCharacteristicMeasurementType;
    class HeightCharacteristicItemType;
    class HeightCharacteristicDefinitionType;
    class HeightCharacteristicNominalType;
    class HeightCharacteristicMeasurementType;
    class DepthCharacteristicItemType;
    class DepthCharacteristicDefinitionType;
    class DepthCharacteristicNominalType;
    class DepthCharacteristicMeasurementType;
    class ThicknessCharacteristicItemType;
    class ThicknessCharacteristicDefinitionType;
    class ThicknessCharacteristicNominalType;
    class ThicknessCharacteristicMeasurementType;
    class SquareCharacteristicItemType;
    class SquareCharacteristicDefinitionType;
    class SquareCharacteristicNominalType;
    class SquareCharacteristicMeasurementType;
    class DistanceFromCharacteristicItemType;
    class DistanceFromCharacteristicDefinitionType;
    class DistanceFromCharacteristicNominalType;
    class DistanceFromCharacteristicMeasurementType;
    class DistanceBetweenCharacteristicItemType;
    class DistanceBetweenCharacteristicDefinitionType;
    class DistanceBetweenCharacteristicNominalType;
    class DistanceBetweenCharacteristicMeasurementType;
    class RadiusCharacteristicItemType;
    class RadiusCharacteristicDefinitionType;
    class RadiusCharacteristicNominalType;
    class RadiusCharacteristicMeasurementType;
    class SphericalRadiusCharacteristicItemType;
    class SphericalRadiusCharacteristicDefinitionType;
    class SphericalRadiusCharacteristicNominalType;
    class SphericalRadiusCharacteristicMeasurementType;
    class ChordCharacteristicItemType;
    class ChordCharacteristicDefinitionType;
    class ChordCharacteristicNominalType;
    class ChordCharacteristicMeasurementType;
    class ConicalTaperCharacteristicItemType;
    class ConicalTaperCharacteristicDefinitionType;
    class ConicalTaperCharacteristicNominalType;
    class ConicalTaperCharacteristicMeasurementType;
    class FlatTaperCharacteristicItemType;
    class FlatTaperCharacteristicDefinitionType;
    class FlatTaperCharacteristicNominalType;
    class FlatTaperCharacteristicMeasurementType;
    class RunoutCharacteristicItemBaseType;
    class RunoutCharacteristicDefinitionBaseType;
    class RunoutCharacteristicNominalBaseType;
    class RunoutCharacteristicMeasurementBaseType;
    class CircularRunoutCharacteristicItemType;
    class CircularRunoutCharacteristicDefinitionType;
    class CircularRunoutCharacteristicNominalType;
    class CircularRunoutCharacteristicMeasurementType;
    class TotalRunoutCharacteristicItemType;
    class TotalRunoutCharacteristicDefinitionType;
    class TotalRunoutCharacteristicNominalType;
    class TotalRunoutCharacteristicMeasurementType;
    class CoaxialityDiametricalZoneType;
    class CoaxialityNonDiametricalZoneType;
    class CoaxialityZoneShapeType;
    class CoaxialityCharacteristicItemType;
    class CoaxialityCharacteristicDefinitionType;
    class CoaxialityCharacteristicNominalType;
    class CoaxialityCharacteristicMeasurementType;
    class ConcentricitySphericalZoneType;
    class ConcentricityDiametricalZoneType;
    class ConcentricityNonDiametricalZoneType;
    class ConcentricityZoneShapeType;
    class ConcentricityCharacteristicItemType;
    class ConcentricityCharacteristicDefinitionType;
    class ConcentricityCharacteristicNominalType;
    class ConcentricityCharacteristicMeasurementType;
    class SymmetryCharacteristicItemType;
    class SymmetryCharacteristicDefinitionType;
    class SymmetryCharacteristicNominalType;
    class SymmetryCharacteristicMeasurementType;
    class ProfileCharacteristicItemBaseType;
    class ProfileCharacteristicDefinitionBaseType;
    class ProfileCharacteristicNominalBaseType;
    class ProfileCharacteristicMeasurementBaseType;
    class LineProfileCharacteristicItemType;
    class LineProfileCharacteristicDefinitionType;
    class LineProfileCharacteristicNominalType;
    class LineProfileCharacteristicMeasurementType;
    class PointProfileCharacteristicItemType;
    class PointProfileCharacteristicDefinitionType;
    class PointProfileCharacteristicNominalType;
    class PointProfileCharacteristicMeasurementType;
    class SurfaceProfileCharacteristicItemType;
    class SurfaceProfileCharacteristicDefinitionType;
    class SurfaceProfileCharacteristicNominalType;
    class SurfaceProfileCharacteristicMeasurementType;
    class SurfaceProfileNonUniformCharacteristicItemType;
    class SurfaceProfileNonUniformCharacteristicDefinitionType;
    class SurfaceProfileNonUniformCharacteristicNominalType;
    class SurfaceProfileNonUniformCharacteristicMeasurementType;
    class MeasuredZoneRadiiType;
    class CharacteristicGroupType;
    class CharacteristicManufacturingProcessGroupType;
    class SimultaneousRequirementEnumType;
    class CompositeSegmentLowerLevelEnumType;
    class SimultaneousRequirementGroupType;
    class SimultaneousRequirementGroupsType;
    class CharacteristicStatusEnumType;
    class CharacteristicStatusType;
    class CharacteristicGroupStatusType;
    class PointDeviationType;
    class PointDeviationsType;
    class ExtentEnumType;
    class ExtentType;
    class PositionCoordinateMethodEnumType;
    class PositionCoordinateMethodType;
    class ThreadCharacteristicItemType;
    class ThreadCharacteristicDefinitionType;
    class ThreadCharacteristicNominalType;
    class ThreadCharacteristicMeasurementType;
    class CharacteristicAspectsListsType;
    class MeasuredCharacteristicsType;
    class CharacteristicItemsType;
    class CharacteristicGroupsType;
    class CharacteristicGroupStatusesType;
    class CharacteristicDefinitionsType;
    class ToleranceDefinitionsType;
    class CharacteristicNominalsType;
    class CharacteristicMeasurementsType;
    class WeldContourSymbolEnumType;
    class WeldFinishingDesignatorEnumType;
    class LocationSignificanceOneSidesEnumType;
    class LocationSignificanceSpotSeamEnumType;
    class LocationSignificanceAllEnumType;
    class NonDestructiveTestingEnumType;
    class WeldingProcessEnumType;
    class WeldingProcessSuffixEnumType;
    class WeldingProcessType;
    class ArrayNonDestructiveTestingType;
    class WeldCharacteristicNominalBaseType;
    class WeldCharacteristicDefinitionBaseType;
    class WeldCharacteristicMeasurementBaseType;
    class WeldFilletCharacteristicMeasurementType;
    class WeldPlugCharacteristicMeasurementType;
    class WeldSlotCharacteristicMeasurementType;
    class WeldSpotCharacteristicMeasurementType;
    class WeldStudCharacteristicMeasurementType;
    class WeldSeamCharacteristicMeasurementType;
    class WeldSurfacingCharacteristicMeasurementType;
    class WeldEdgeCharacteristicMeasurementType;
    class WeldGrooveCharacteristicMeasurementType;
    class WeldSquareCharacteristicMeasurementType;
    class WeldBevelCharacteristicMeasurementType;
    class WeldVCharacteristicMeasurementType;
    class WeldUCharacteristicMeasurementType;
    class WeldJCharacteristicMeasurementType;
    class WeldFlareVCharacteristicMeasurementType;
    class WeldFlareBevelCharacteristicMeasurementType;
    class WeldScarfCharacteristicMeasurementType;
    class WeldCompoundCharacteristicMeasurementType;
    class WeldCharacteristicItemBaseType;
    class WeldGrooveCharacteristicNominalType;
    class WeldFinishingType;
    class WeldOneSideParametersBaseType;
    class WeldOneSideParametersExtendSizeType;
    class WeldOneSideParametersExtendType;
    class WeldGrooveOneSideParametersType;
    class WeldSupplementarySymbolEnumType;
    class WeldGrooveOneSideType;
    class WeldGrooveBothSidesBaseType;
    class WeldGrooveBothSidesExtendedType;
    class WeldSquareCharacteristicNominalType;
    class WeldBevelCharacteristicNominalType;
    class WeldVCharacteristicNominalType;
    class WeldUCharacteristicNominalType;
    class WeldJCharacteristicNominalType;
    class WeldFlareVCharacteristicNominalType;
    class WeldFlareBevelCharacteristicNominalType;
    class WeldScarfCharacteristicNominalType;
    class WeldFilletOneSideInBothSidesType;
    class WeldFilletUnequalLegLengthType;
    class WeldFilletEqualLegLengthType;
    class WeldFilletOneSideType;
    class WeldFilletBothSidesType;
    class WeldCompoundCharacteristicNominalType;
    class WeldFilletCharacteristicNominalType;
    class WeldPlugOneSideParametersType;
    class WeldPlugCharacteristicNominalType;
    class WeldSlotCharacteristicNominalType;
    class WeldSpotOneSideParametersType;
    class WeldSpotCharacteristicNominalType;
    class WeldStudCharacteristicNominalType;
    class WeldSeamCharacteristicNominalType;
    class WeldSurfacingCharacteristicNominalType;
    class WeldEdgeCharacteristicNominalType;
    class WeldFilletCharacteristicDefinitionType;
    class WeldPlugCharacteristicDefinitionType;
    class WeldSlotCharacteristicDefinitionType;
    class WeldSpotCharacteristicDefinitionType;
    class WeldStudCharacteristicDefinitionType;
    class WeldSeamCharacteristicDefinitionType;
    class WeldSurfacingCharacteristicDefinitionType;
    class WeldEdgeCharacteristicDefinitionType;
    class WeldSquareCharacteristicDefinitionType;
    class WeldBevelCharacteristicDefinitionType;
    class WeldVCharacteristicDefinitionType;
    class WeldUCharacteristicDefinitionType;
    class WeldJCharacteristicDefinitionType;
    class WeldFlareVCharacteristicDefinitionType;
    class WeldFlareBevelCharacteristicDefinitionType;
    class WeldScarfCharacteristicDefinitionType;
    class WeldCompoundCharacteristicDefinitionType;
    class WeldFilletCharacteristicItemType;
    class WeldPlugCharacteristicItemType;
    class WeldSlotCharacteristicItemType;
    class WeldSpotCharacteristicItemType;
    class WeldStudCharacteristicItemType;
    class WeldSeamCharacteristicItemType;
    class WeldSurfacingCharacteristicItemType;
    class WeldEdgeCharacteristicItemType;
    class WeldSquareCharacteristicItemType;
    class WeldBevelCharacteristicItemType;
    class WeldVCharacteristicItemType;
    class WeldUCharacteristicItemType;
    class WeldJCharacteristicItemType;
    class WeldFlareVCharacteristicItemType;
    class WeldFlareBevelCharacteristicItemType;
    class WeldScarfCharacteristicItemType;
    class WeldCompoundCharacteristicItemType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/IntermediatesPMI.hxx"

#include "../QIFLibrary/PrimitivesPD.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL CharacteristicBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      CharacteristicBaseType ();

      CharacteristicBaseType (const id_type&);

      CharacteristicBaseType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CharacteristicBaseType (const CharacteristicBaseType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual CharacteristicBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CharacteristicBaseType&
      operator= (const CharacteristicBaseType& x);

      virtual 
      ~CharacteristicBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Description_optional Description_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL CharacteristicItemBaseType: public ::xsd::qif30::CharacteristicBaseType
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // CharacteristicDesignator
      //
      typedef ::xsd::qif30::CharacteristicDesignatorType CharacteristicDesignator_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicDesignator_type > CharacteristicDesignator_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicDesignator_type, wchar_t > CharacteristicDesignator_traits;

      const CharacteristicDesignator_optional&
      CharacteristicDesignator () const;

      CharacteristicDesignator_optional&
      CharacteristicDesignator ();

      void
      CharacteristicDesignator (const CharacteristicDesignator_type& x);

      void
      CharacteristicDesignator (const CharacteristicDesignator_optional& x);

      void
      CharacteristicDesignator (::std::unique_ptr< CharacteristicDesignator_type > p);

      // FeatureItemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FeatureItemIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureItemIds_type > FeatureItemIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureItemIds_type, wchar_t > FeatureItemIds_traits;

      const FeatureItemIds_optional&
      FeatureItemIds () const;

      FeatureItemIds_optional&
      FeatureItemIds ();

      void
      FeatureItemIds (const FeatureItemIds_type& x);

      void
      FeatureItemIds (const FeatureItemIds_optional& x);

      void
      FeatureItemIds (::std::unique_ptr< FeatureItemIds_type > p);

      // SubstituteFeatureAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType SubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithm_type > SubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithm_type, wchar_t > SubstituteFeatureAlgorithm_traits;

      const SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm () const;

      SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm ();

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x);

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x);

      void
      SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > p);

      // NotableEventIds
      //
      typedef ::xsd::qif30::ArrayReferenceType NotableEventIds_type;
      typedef ::xsd::cxx::tree::optional< NotableEventIds_type > NotableEventIds_optional;
      typedef ::xsd::cxx::tree::traits< NotableEventIds_type, wchar_t > NotableEventIds_traits;

      const NotableEventIds_optional&
      NotableEventIds () const;

      NotableEventIds_optional&
      NotableEventIds ();

      void
      NotableEventIds (const NotableEventIds_type& x);

      void
      NotableEventIds (const NotableEventIds_optional& x);

      void
      NotableEventIds (::std::unique_ptr< NotableEventIds_type > p);

      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // CharacteristicNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CharacteristicNominalId_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicNominalId_type, wchar_t > CharacteristicNominalId_traits;

      const CharacteristicNominalId_type&
      CharacteristicNominalId () const;

      CharacteristicNominalId_type&
      CharacteristicNominalId ();

      void
      CharacteristicNominalId (const CharacteristicNominalId_type& x);

      void
      CharacteristicNominalId (::std::unique_ptr< CharacteristicNominalId_type > p);

      // LocationOnDrawing
      //
      typedef ::xsd::qif30::LocationOnDrawingType LocationOnDrawing_type;
      typedef ::xsd::cxx::tree::optional< LocationOnDrawing_type > LocationOnDrawing_optional;
      typedef ::xsd::cxx::tree::traits< LocationOnDrawing_type, wchar_t > LocationOnDrawing_traits;

      const LocationOnDrawing_optional&
      LocationOnDrawing () const;

      LocationOnDrawing_optional&
      LocationOnDrawing ();

      void
      LocationOnDrawing (const LocationOnDrawing_type& x);

      void
      LocationOnDrawing (const LocationOnDrawing_optional& x);

      void
      LocationOnDrawing (::std::unique_ptr< LocationOnDrawing_type > p);

      // VirtualMeasurement
      //
      typedef ::xsd::qif30::VirtualMeasurementType VirtualMeasurement_type;
      typedef ::xsd::cxx::tree::optional< VirtualMeasurement_type > VirtualMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< VirtualMeasurement_type, wchar_t > VirtualMeasurement_traits;

      const VirtualMeasurement_optional&
      VirtualMeasurement () const;

      VirtualMeasurement_optional&
      VirtualMeasurement ();

      void
      VirtualMeasurement (const VirtualMeasurement_type& x);

      void
      VirtualMeasurement (const VirtualMeasurement_optional& x);

      void
      VirtualMeasurement (::std::unique_ptr< VirtualMeasurement_type > p);

      // Constructors.
      //
      CharacteristicItemBaseType ();

      CharacteristicItemBaseType (const id_type&,
                                  const CharacteristicNominalId_type&);

      CharacteristicItemBaseType (const id_type&,
                                  ::std::unique_ptr< CharacteristicNominalId_type >);

      CharacteristicItemBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CharacteristicItemBaseType (const CharacteristicItemBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CharacteristicItemBaseType&
      operator= (const CharacteristicItemBaseType& x);

      virtual 
      ~CharacteristicItemBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Name_optional Name_;
      CharacteristicDesignator_optional CharacteristicDesignator_;
      FeatureItemIds_optional FeatureItemIds_;
      SubstituteFeatureAlgorithm_optional SubstituteFeatureAlgorithm_;
      NotableEventIds_optional NotableEventIds_;
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
      ::xsd::cxx::tree::one< CharacteristicNominalId_type > CharacteristicNominalId_;
      LocationOnDrawing_optional LocationOnDrawing_;
      VirtualMeasurement_optional VirtualMeasurement_;
    };

    class QIF30_SYMBOL_DECL CriticalityLevelEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        MINOR,
        MAJOR,
        CRITICAL,
        KEY,
        UNDEFINED
      };

      CriticalityLevelEnumType ();

      CriticalityLevelEnumType (value v);

      CriticalityLevelEnumType (const wchar_t* v);

      CriticalityLevelEnumType (const ::std::wstring& v);

      CriticalityLevelEnumType (const ::xml_schema::nmtoken& v);

      CriticalityLevelEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CriticalityLevelEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CriticalityLevelEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CriticalityLevelEnumType (const CriticalityLevelEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CriticalityLevelEnumType&
      operator= (const CriticalityLevelEnumType&) = default;
#endif

      virtual CriticalityLevelEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriticalityLevelEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CriticalityLevelEnumType_convert ();
      }

      protected:
      value
      _xsd_CriticalityLevelEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CriticalityLevelEnumType_literals_[5];
      static const value _xsd_CriticalityLevelEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL CriticalityAreaEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        SAFETY,
        MISSION,
        FIT,
        FUNCTION,
        APPEARANCE,
        UNDEFINED
      };

      CriticalityAreaEnumType ();

      CriticalityAreaEnumType (value v);

      CriticalityAreaEnumType (const wchar_t* v);

      CriticalityAreaEnumType (const ::std::wstring& v);

      CriticalityAreaEnumType (const ::xml_schema::nmtoken& v);

      CriticalityAreaEnumType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CriticalityAreaEnumType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CriticalityAreaEnumType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CriticalityAreaEnumType (const CriticalityAreaEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CriticalityAreaEnumType&
      operator= (const CriticalityAreaEnumType&) = default;
#endif

      virtual CriticalityAreaEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriticalityAreaEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CriticalityAreaEnumType_convert ();
      }

      protected:
      value
      _xsd_CriticalityAreaEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CriticalityAreaEnumType_literals_[6];
      static const value _xsd_CriticalityAreaEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL CriticalityType: public ::xml_schema::type
    {
      public:
      // LevelEnum
      //
      typedef ::xsd::qif30::CriticalityLevelEnumType LevelEnum_type;
      typedef ::xsd::cxx::tree::optional< LevelEnum_type > LevelEnum_optional;
      typedef ::xsd::cxx::tree::traits< LevelEnum_type, wchar_t > LevelEnum_traits;

      const LevelEnum_optional&
      LevelEnum () const;

      LevelEnum_optional&
      LevelEnum ();

      void
      LevelEnum (const LevelEnum_type& x);

      void
      LevelEnum (const LevelEnum_optional& x);

      void
      LevelEnum (::std::unique_ptr< LevelEnum_type > p);

      // OtherLevel
      //
      typedef ::xml_schema::string OtherLevel_type;
      typedef ::xsd::cxx::tree::optional< OtherLevel_type > OtherLevel_optional;
      typedef ::xsd::cxx::tree::traits< OtherLevel_type, wchar_t > OtherLevel_traits;

      const OtherLevel_optional&
      OtherLevel () const;

      OtherLevel_optional&
      OtherLevel ();

      void
      OtherLevel (const OtherLevel_type& x);

      void
      OtherLevel (const OtherLevel_optional& x);

      void
      OtherLevel (::std::unique_ptr< OtherLevel_type > p);

      // AreaEnum
      //
      typedef ::xsd::qif30::CriticalityAreaEnumType AreaEnum_type;
      typedef ::xsd::cxx::tree::optional< AreaEnum_type > AreaEnum_optional;
      typedef ::xsd::cxx::tree::traits< AreaEnum_type, wchar_t > AreaEnum_traits;

      const AreaEnum_optional&
      AreaEnum () const;

      AreaEnum_optional&
      AreaEnum ();

      void
      AreaEnum (const AreaEnum_type& x);

      void
      AreaEnum (const AreaEnum_optional& x);

      void
      AreaEnum (::std::unique_ptr< AreaEnum_type > p);

      // OtherArea
      //
      typedef ::xml_schema::string OtherArea_type;
      typedef ::xsd::cxx::tree::optional< OtherArea_type > OtherArea_optional;
      typedef ::xsd::cxx::tree::traits< OtherArea_type, wchar_t > OtherArea_traits;

      const OtherArea_optional&
      OtherArea () const;

      OtherArea_optional&
      OtherArea ();

      void
      OtherArea (const OtherArea_type& x);

      void
      OtherArea (const OtherArea_optional& x);

      void
      OtherArea (::std::unique_ptr< OtherArea_type > p);

      // Constructors.
      //
      CriticalityType ();

      CriticalityType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      CriticalityType (const CriticalityType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual CriticalityType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriticalityType&
      operator= (const CriticalityType& x);

      virtual 
      ~CriticalityType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LevelEnum_optional LevelEnum_;
      OtherLevel_optional OtherLevel_;
      AreaEnum_optional AreaEnum_;
      OtherArea_optional OtherArea_;
    };

    class QIF30_SYMBOL_DECL CharacteristicBalloonLocationEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ABOVE,
        BELOW,
        LEFT,
        RIGHT,
        DEFAULT,
        UNDEFINED
      };

      CharacteristicBalloonLocationEnumType ();

      CharacteristicBalloonLocationEnumType (value v);

      CharacteristicBalloonLocationEnumType (const wchar_t* v);

      CharacteristicBalloonLocationEnumType (const ::std::wstring& v);

      CharacteristicBalloonLocationEnumType (const ::xml_schema::nmtoken& v);

      CharacteristicBalloonLocationEnumType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CharacteristicBalloonLocationEnumType (const xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CharacteristicBalloonLocationEnumType (const ::std::wstring& s,
                                             const xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CharacteristicBalloonLocationEnumType (const CharacteristicBalloonLocationEnumType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CharacteristicBalloonLocationEnumType&
      operator= (const CharacteristicBalloonLocationEnumType&) = default;
#endif

      virtual CharacteristicBalloonLocationEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicBalloonLocationEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CharacteristicBalloonLocationEnumType_convert ();
      }

      protected:
      value
      _xsd_CharacteristicBalloonLocationEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CharacteristicBalloonLocationEnumType_literals_[6];
      static const value _xsd_CharacteristicBalloonLocationEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL CharacteristicBalloonStyleEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        OPEN_CIRCLE,
        BARRED_CIRCLE,
        ELONGATED_CIRCLE,
        SPLIT_CIRCLE,
        PENTAGON,
        HEXAGON,
        OCTAGON,
        RECTANGLE,
        ROUNDED_RECTANGLE,
        ELONGATED_HEXAGON,
        FORWARD_CHEVRON,
        BACKWARD_CHEVRON,
        DEFAULT,
        UNDEFINED
      };

      CharacteristicBalloonStyleEnumType ();

      CharacteristicBalloonStyleEnumType (value v);

      CharacteristicBalloonStyleEnumType (const wchar_t* v);

      CharacteristicBalloonStyleEnumType (const ::std::wstring& v);

      CharacteristicBalloonStyleEnumType (const ::xml_schema::nmtoken& v);

      CharacteristicBalloonStyleEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CharacteristicBalloonStyleEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CharacteristicBalloonStyleEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CharacteristicBalloonStyleEnumType (const CharacteristicBalloonStyleEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CharacteristicBalloonStyleEnumType&
      operator= (const CharacteristicBalloonStyleEnumType&) = default;
#endif

      virtual CharacteristicBalloonStyleEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicBalloonStyleEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CharacteristicBalloonStyleEnumType_convert ();
      }

      protected:
      value
      _xsd_CharacteristicBalloonStyleEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CharacteristicBalloonStyleEnumType_literals_[14];
      static const value _xsd_CharacteristicBalloonStyleEnumType_indexes_[14];
    };

    class QIF30_SYMBOL_DECL CharacteristicBalloonType: public ::xml_schema::type
    {
      public:
      // BalloonLocation
      //
      typedef ::xsd::qif30::CharacteristicBalloonLocationEnumType BalloonLocation_type;
      typedef ::xsd::cxx::tree::traits< BalloonLocation_type, wchar_t > BalloonLocation_traits;

      const BalloonLocation_type&
      BalloonLocation () const;

      BalloonLocation_type&
      BalloonLocation ();

      void
      BalloonLocation (const BalloonLocation_type& x);

      void
      BalloonLocation (::std::unique_ptr< BalloonLocation_type > p);

      // BalloonStyle
      //
      typedef ::xsd::qif30::CharacteristicBalloonStyleEnumType BalloonStyle_type;
      typedef ::xsd::cxx::tree::traits< BalloonStyle_type, wchar_t > BalloonStyle_traits;

      const BalloonStyle_type&
      BalloonStyle () const;

      BalloonStyle_type&
      BalloonStyle ();

      void
      BalloonStyle (const BalloonStyle_type& x);

      void
      BalloonStyle (::std::unique_ptr< BalloonStyle_type > p);

      // Constructors.
      //
      CharacteristicBalloonType ();

      CharacteristicBalloonType (const BalloonLocation_type&,
                                 const BalloonStyle_type&);

      CharacteristicBalloonType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      CharacteristicBalloonType (const CharacteristicBalloonType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual CharacteristicBalloonType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicBalloonType&
      operator= (const CharacteristicBalloonType& x);

      virtual 
      ~CharacteristicBalloonType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BalloonLocation_type > BalloonLocation_;
      ::xsd::cxx::tree::one< BalloonStyle_type > BalloonStyle_;
    };

    class QIF30_SYMBOL_DECL CharacteristicDesignatorType: public ::xml_schema::type
    {
      public:
      // Designator
      //
      typedef ::xml_schema::token Designator_type;
      typedef ::xsd::cxx::tree::traits< Designator_type, wchar_t > Designator_traits;

      const Designator_type&
      Designator () const;

      Designator_type&
      Designator ();

      void
      Designator (const Designator_type& x);

      void
      Designator (::std::unique_ptr< Designator_type > p);

      // UUID
      //
      typedef ::xsd::qif30::QPIdType UUID_type;
      typedef ::xsd::cxx::tree::optional< UUID_type > UUID_optional;
      typedef ::xsd::cxx::tree::traits< UUID_type, wchar_t > UUID_traits;

      const UUID_optional&
      UUID () const;

      UUID_optional&
      UUID ();

      void
      UUID (const UUID_type& x);

      void
      UUID (const UUID_optional& x);

      void
      UUID (::std::unique_ptr< UUID_type > p);

      // Criticality
      //
      typedef ::xsd::qif30::CriticalityType Criticality_type;
      typedef ::xsd::cxx::tree::optional< Criticality_type > Criticality_optional;
      typedef ::xsd::cxx::tree::traits< Criticality_type, wchar_t > Criticality_traits;

      const Criticality_optional&
      Criticality () const;

      Criticality_optional&
      Criticality ();

      void
      Criticality (const Criticality_type& x);

      void
      Criticality (const Criticality_optional& x);

      void
      Criticality (::std::unique_ptr< Criticality_type > p);

      // Balloon
      //
      typedef ::xsd::qif30::CharacteristicBalloonType Balloon_type;
      typedef ::xsd::cxx::tree::optional< Balloon_type > Balloon_optional;
      typedef ::xsd::cxx::tree::traits< Balloon_type, wchar_t > Balloon_traits;

      const Balloon_optional&
      Balloon () const;

      Balloon_optional&
      Balloon ();

      void
      Balloon (const Balloon_type& x);

      void
      Balloon (const Balloon_optional& x);

      void
      Balloon (::std::unique_ptr< Balloon_type > p);

      // Constructors.
      //
      CharacteristicDesignatorType ();

      CharacteristicDesignatorType (const Designator_type&);

      CharacteristicDesignatorType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CharacteristicDesignatorType (const CharacteristicDesignatorType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual CharacteristicDesignatorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicDesignatorType&
      operator= (const CharacteristicDesignatorType& x);

      virtual 
      ~CharacteristicDesignatorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Designator_type > Designator_;
      UUID_optional UUID_;
      Criticality_optional Criticality_;
      Balloon_optional Balloon_;
    };

    class QIF30_SYMBOL_DECL LocationOnDrawingType: public ::xml_schema::type
    {
      public:
      // DrawingId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DrawingId_type;
      typedef ::xsd::cxx::tree::optional< DrawingId_type > DrawingId_optional;
      typedef ::xsd::cxx::tree::traits< DrawingId_type, wchar_t > DrawingId_traits;

      const DrawingId_optional&
      DrawingId () const;

      DrawingId_optional&
      DrawingId ();

      void
      DrawingId (const DrawingId_type& x);

      void
      DrawingId (const DrawingId_optional& x);

      void
      DrawingId (::std::unique_ptr< DrawingId_type > p);

      // SheetNumber
      //
      typedef ::xml_schema::string SheetNumber_type;
      typedef ::xsd::cxx::tree::optional< SheetNumber_type > SheetNumber_optional;
      typedef ::xsd::cxx::tree::traits< SheetNumber_type, wchar_t > SheetNumber_traits;

      const SheetNumber_optional&
      SheetNumber () const;

      SheetNumber_optional&
      SheetNumber ();

      void
      SheetNumber (const SheetNumber_type& x);

      void
      SheetNumber (const SheetNumber_optional& x);

      void
      SheetNumber (::std::unique_ptr< SheetNumber_type > p);

      // DrawingZone
      //
      typedef ::xml_schema::string DrawingZone_type;
      typedef ::xsd::cxx::tree::optional< DrawingZone_type > DrawingZone_optional;
      typedef ::xsd::cxx::tree::traits< DrawingZone_type, wchar_t > DrawingZone_traits;

      const DrawingZone_optional&
      DrawingZone () const;

      DrawingZone_optional&
      DrawingZone ();

      void
      DrawingZone (const DrawingZone_type& x);

      void
      DrawingZone (const DrawingZone_optional& x);

      void
      DrawingZone (::std::unique_ptr< DrawingZone_type > p);

      // ModelId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ModelId_type;
      typedef ::xsd::cxx::tree::optional< ModelId_type > ModelId_optional;
      typedef ::xsd::cxx::tree::traits< ModelId_type, wchar_t > ModelId_traits;

      const ModelId_optional&
      ModelId () const;

      ModelId_optional&
      ModelId ();

      void
      ModelId (const ModelId_type& x);

      void
      ModelId (const ModelId_optional& x);

      void
      ModelId (::std::unique_ptr< ModelId_type > p);

      // View
      //
      typedef ::xml_schema::string View_type;
      typedef ::xsd::cxx::tree::optional< View_type > View_optional;
      typedef ::xsd::cxx::tree::traits< View_type, wchar_t > View_traits;

      const View_optional&
      View () const;

      View_optional&
      View ();

      void
      View (const View_type& x);

      void
      View (const View_optional& x);

      void
      View (::std::unique_ptr< View_type > p);

      // ViewId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ViewId_type;
      typedef ::xsd::cxx::tree::optional< ViewId_type > ViewId_optional;
      typedef ::xsd::cxx::tree::traits< ViewId_type, wchar_t > ViewId_traits;

      const ViewId_optional&
      ViewId () const;

      ViewId_optional&
      ViewId ();

      void
      ViewId (const ViewId_type& x);

      void
      ViewId (const ViewId_optional& x);

      void
      ViewId (::std::unique_ptr< ViewId_type > p);

      // Constructors.
      //
      LocationOnDrawingType ();

      LocationOnDrawingType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      LocationOnDrawingType (const LocationOnDrawingType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual LocationOnDrawingType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocationOnDrawingType&
      operator= (const LocationOnDrawingType& x);

      virtual 
      ~LocationOnDrawingType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DrawingId_optional DrawingId_;
      SheetNumber_optional SheetNumber_;
      DrawingZone_optional DrawingZone_;
      ModelId_optional ModelId_;
      View_optional View_;
      ViewId_optional ViewId_;
    };

    class QIF30_SYMBOL_DECL CharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicBaseType
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // CharacteristicDesignator
      //
      typedef ::xsd::qif30::CharacteristicDesignatorType CharacteristicDesignator_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicDesignator_type > CharacteristicDesignator_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicDesignator_type, wchar_t > CharacteristicDesignator_traits;

      const CharacteristicDesignator_optional&
      CharacteristicDesignator () const;

      CharacteristicDesignator_optional&
      CharacteristicDesignator ();

      void
      CharacteristicDesignator (const CharacteristicDesignator_type& x);

      void
      CharacteristicDesignator (const CharacteristicDesignator_optional& x);

      void
      CharacteristicDesignator (::std::unique_ptr< CharacteristicDesignator_type > p);

      // FreeState
      //
      typedef ::xml_schema::boolean FreeState_type;
      typedef ::xsd::cxx::tree::optional< FreeState_type > FreeState_optional;
      typedef ::xsd::cxx::tree::traits< FreeState_type, wchar_t > FreeState_traits;

      const FreeState_optional&
      FreeState () const;

      FreeState_optional&
      FreeState ();

      void
      FreeState (const FreeState_type& x);

      void
      FreeState (const FreeState_optional& x);

      // StatisticalCharacteristic
      //
      typedef ::xml_schema::boolean StatisticalCharacteristic_type;
      typedef ::xsd::cxx::tree::optional< StatisticalCharacteristic_type > StatisticalCharacteristic_optional;
      typedef ::xsd::cxx::tree::traits< StatisticalCharacteristic_type, wchar_t > StatisticalCharacteristic_traits;

      const StatisticalCharacteristic_optional&
      StatisticalCharacteristic () const;

      StatisticalCharacteristic_optional&
      StatisticalCharacteristic ();

      void
      StatisticalCharacteristic (const StatisticalCharacteristic_type& x);

      void
      StatisticalCharacteristic (const StatisticalCharacteristic_optional& x);

      // CommonZone
      //
      typedef ::xml_schema::boolean CommonZone_type;
      typedef ::xsd::cxx::tree::optional< CommonZone_type > CommonZone_optional;
      typedef ::xsd::cxx::tree::traits< CommonZone_type, wchar_t > CommonZone_traits;

      const CommonZone_optional&
      CommonZone () const;

      CommonZone_optional&
      CommonZone ();

      void
      CommonZone (const CommonZone_type& x);

      void
      CommonZone (const CommonZone_optional& x);

      // CommonTolerance
      //
      typedef ::xml_schema::boolean CommonTolerance_type;
      typedef ::xsd::cxx::tree::optional< CommonTolerance_type > CommonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< CommonTolerance_type, wchar_t > CommonTolerance_traits;

      const CommonTolerance_optional&
      CommonTolerance () const;

      CommonTolerance_optional&
      CommonTolerance ();

      void
      CommonTolerance (const CommonTolerance_type& x);

      void
      CommonTolerance (const CommonTolerance_optional& x);

      // MedianFeature
      //
      typedef ::xml_schema::boolean MedianFeature_type;
      typedef ::xsd::cxx::tree::optional< MedianFeature_type > MedianFeature_optional;
      typedef ::xsd::cxx::tree::traits< MedianFeature_type, wchar_t > MedianFeature_traits;

      const MedianFeature_optional&
      MedianFeature () const;

      MedianFeature_optional&
      MedianFeature ();

      void
      MedianFeature (const MedianFeature_type& x);

      void
      MedianFeature (const MedianFeature_optional& x);

      // EnvelopeRequirement
      //
      typedef ::xml_schema::boolean EnvelopeRequirement_type;
      typedef ::xsd::cxx::tree::optional< EnvelopeRequirement_type > EnvelopeRequirement_optional;
      typedef ::xsd::cxx::tree::traits< EnvelopeRequirement_type, wchar_t > EnvelopeRequirement_traits;

      const EnvelopeRequirement_optional&
      EnvelopeRequirement () const;

      EnvelopeRequirement_optional&
      EnvelopeRequirement ();

      void
      EnvelopeRequirement (const EnvelopeRequirement_type& x);

      void
      EnvelopeRequirement (const EnvelopeRequirement_optional& x);

      // Independency
      //
      typedef ::xml_schema::boolean Independency_type;
      typedef ::xsd::cxx::tree::optional< Independency_type > Independency_optional;
      typedef ::xsd::cxx::tree::traits< Independency_type, wchar_t > Independency_traits;

      const Independency_optional&
      Independency () const;

      Independency_optional&
      Independency ();

      void
      Independency (const Independency_type& x);

      void
      Independency (const Independency_optional& x);

      // UnitedOrContinuousFeature
      //
      typedef ::xml_schema::boolean UnitedOrContinuousFeature_type;
      typedef ::xsd::cxx::tree::optional< UnitedOrContinuousFeature_type > UnitedOrContinuousFeature_optional;
      typedef ::xsd::cxx::tree::traits< UnitedOrContinuousFeature_type, wchar_t > UnitedOrContinuousFeature_traits;

      const UnitedOrContinuousFeature_optional&
      UnitedOrContinuousFeature () const;

      UnitedOrContinuousFeature_optional&
      UnitedOrContinuousFeature ();

      void
      UnitedOrContinuousFeature (const UnitedOrContinuousFeature_type& x);

      void
      UnitedOrContinuousFeature (const UnitedOrContinuousFeature_optional& x);

      // SeparateZone
      //
      typedef ::xml_schema::boolean SeparateZone_type;
      typedef ::xsd::cxx::tree::optional< SeparateZone_type > SeparateZone_optional;
      typedef ::xsd::cxx::tree::traits< SeparateZone_type, wchar_t > SeparateZone_traits;

      const SeparateZone_optional&
      SeparateZone () const;

      SeparateZone_optional&
      SeparateZone ();

      void
      SeparateZone (const SeparateZone_type& x);

      void
      SeparateZone (const SeparateZone_optional& x);

      // Constructors.
      //
      CharacteristicDefinitionBaseType ();

      CharacteristicDefinitionBaseType (const id_type&);

      CharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      CharacteristicDefinitionBaseType (const CharacteristicDefinitionBaseType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual CharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CharacteristicDefinitionBaseType&
      operator= (const CharacteristicDefinitionBaseType& x);

      virtual 
      ~CharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Name_optional Name_;
      CharacteristicDesignator_optional CharacteristicDesignator_;
      FreeState_optional FreeState_;
      StatisticalCharacteristic_optional StatisticalCharacteristic_;
      CommonZone_optional CommonZone_;
      CommonTolerance_optional CommonTolerance_;
      MedianFeature_optional MedianFeature_;
      EnvelopeRequirement_optional EnvelopeRequirement_;
      Independency_optional Independency_;
      UnitedOrContinuousFeature_optional UnitedOrContinuousFeature_;
      SeparateZone_optional SeparateZone_;
    };

    class QIF30_SYMBOL_DECL CharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicBaseType
    {
      public:
      // CharacteristicDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceType CharacteristicDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicDefinitionId_type, wchar_t > CharacteristicDefinitionId_traits;

      const CharacteristicDefinitionId_type&
      CharacteristicDefinitionId () const;

      CharacteristicDefinitionId_type&
      CharacteristicDefinitionId ();

      void
      CharacteristicDefinitionId (const CharacteristicDefinitionId_type& x);

      void
      CharacteristicDefinitionId (::std::unique_ptr< CharacteristicDefinitionId_type > p);

      // FeatureNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType FeatureNominalIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalIds_type > FeatureNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalIds_type, wchar_t > FeatureNominalIds_traits;

      const FeatureNominalIds_optional&
      FeatureNominalIds () const;

      FeatureNominalIds_optional&
      FeatureNominalIds ();

      void
      FeatureNominalIds (const FeatureNominalIds_type& x);

      void
      FeatureNominalIds (const FeatureNominalIds_optional& x);

      void
      FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > p);

      // SubstituteFeatureAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType SubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithm_type > SubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithm_type, wchar_t > SubstituteFeatureAlgorithm_traits;

      const SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm () const;

      SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm ();

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x);

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x);

      void
      SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > p);

      // FeatureZoneIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType FeatureZoneIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureZoneIds_type > FeatureZoneIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureZoneIds_type, wchar_t > FeatureZoneIds_traits;

      const FeatureZoneIds_optional&
      FeatureZoneIds () const;

      FeatureZoneIds_optional&
      FeatureZoneIds ();

      void
      FeatureZoneIds (const FeatureZoneIds_type& x);

      void
      FeatureZoneIds (const FeatureZoneIds_optional& x);

      void
      FeatureZoneIds (::std::unique_ptr< FeatureZoneIds_type > p);

      // EntityInternalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType EntityInternalIds_type;
      typedef ::xsd::cxx::tree::optional< EntityInternalIds_type > EntityInternalIds_optional;
      typedef ::xsd::cxx::tree::traits< EntityInternalIds_type, wchar_t > EntityInternalIds_traits;

      const EntityInternalIds_optional&
      EntityInternalIds () const;

      EntityInternalIds_optional&
      EntityInternalIds ();

      void
      EntityInternalIds (const EntityInternalIds_type& x);

      void
      EntityInternalIds (const EntityInternalIds_optional& x);

      void
      EntityInternalIds (::std::unique_ptr< EntityInternalIds_type > p);

      // EntityExternalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType EntityExternalIds_type;
      typedef ::xsd::cxx::tree::optional< EntityExternalIds_type > EntityExternalIds_optional;
      typedef ::xsd::cxx::tree::traits< EntityExternalIds_type, wchar_t > EntityExternalIds_traits;

      const EntityExternalIds_optional&
      EntityExternalIds () const;

      EntityExternalIds_optional&
      EntityExternalIds ();

      void
      EntityExternalIds (const EntityExternalIds_type& x);

      void
      EntityExternalIds (const EntityExternalIds_optional& x);

      void
      EntityExternalIds (::std::unique_ptr< EntityExternalIds_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // CharacteristicDesignator
      //
      typedef ::xsd::qif30::CharacteristicDesignatorType CharacteristicDesignator_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicDesignator_type > CharacteristicDesignator_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicDesignator_type, wchar_t > CharacteristicDesignator_traits;

      const CharacteristicDesignator_optional&
      CharacteristicDesignator () const;

      CharacteristicDesignator_optional&
      CharacteristicDesignator ();

      void
      CharacteristicDesignator (const CharacteristicDesignator_type& x);

      void
      CharacteristicDesignator (const CharacteristicDesignator_optional& x);

      void
      CharacteristicDesignator (::std::unique_ptr< CharacteristicDesignator_type > p);

      // Constructors.
      //
      CharacteristicNominalBaseType ();

      CharacteristicNominalBaseType (const id_type&,
                                     const CharacteristicDefinitionId_type&);

      CharacteristicNominalBaseType (const id_type&,
                                     ::std::unique_ptr< CharacteristicDefinitionId_type >);

      CharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CharacteristicNominalBaseType (const CharacteristicNominalBaseType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CharacteristicNominalBaseType&
      operator= (const CharacteristicNominalBaseType& x);

      virtual 
      ~CharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CharacteristicDefinitionId_type > CharacteristicDefinitionId_;
      FeatureNominalIds_optional FeatureNominalIds_;
      SubstituteFeatureAlgorithm_optional SubstituteFeatureAlgorithm_;
      FeatureZoneIds_optional FeatureZoneIds_;
      EntityInternalIds_optional EntityInternalIds_;
      EntityExternalIds_optional EntityExternalIds_;
      Name_optional Name_;
      CharacteristicDesignator_optional CharacteristicDesignator_;
    };

    class QIF30_SYMBOL_DECL CharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicBaseType
    {
      public:
      // Status
      //
      typedef ::xsd::qif30::CharacteristicStatusType Status_type;
      typedef ::xsd::cxx::tree::traits< Status_type, wchar_t > Status_traits;

      const Status_type&
      Status () const;

      Status_type&
      Status ();

      void
      Status (const Status_type& x);

      void
      Status (::std::unique_ptr< Status_type > p);

      // CharacteristicItemId
      //
      typedef ::xsd::qif30::QIFReferenceType CharacteristicItemId_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicItemId_type, wchar_t > CharacteristicItemId_traits;

      const CharacteristicItemId_type&
      CharacteristicItemId () const;

      CharacteristicItemId_type&
      CharacteristicItemId ();

      void
      CharacteristicItemId (const CharacteristicItemId_type& x);

      void
      CharacteristicItemId (::std::unique_ptr< CharacteristicItemId_type > p);

      // TimeStamp
      //
      typedef ::xml_schema::date_time TimeStamp_type;
      typedef ::xsd::cxx::tree::optional< TimeStamp_type > TimeStamp_optional;
      typedef ::xsd::cxx::tree::traits< TimeStamp_type, wchar_t > TimeStamp_traits;

      const TimeStamp_optional&
      TimeStamp () const;

      TimeStamp_optional&
      TimeStamp ();

      void
      TimeStamp (const TimeStamp_type& x);

      void
      TimeStamp (const TimeStamp_optional& x);

      void
      TimeStamp (::std::unique_ptr< TimeStamp_type > p);

      // FeatureMeasurementIds
      //
      typedef ::xsd::qif30::ArrayReferenceType FeatureMeasurementIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureMeasurementIds_type > FeatureMeasurementIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureMeasurementIds_type, wchar_t > FeatureMeasurementIds_traits;

      const FeatureMeasurementIds_optional&
      FeatureMeasurementIds () const;

      FeatureMeasurementIds_optional&
      FeatureMeasurementIds ();

      void
      FeatureMeasurementIds (const FeatureMeasurementIds_type& x);

      void
      FeatureMeasurementIds (const FeatureMeasurementIds_optional& x);

      void
      FeatureMeasurementIds (::std::unique_ptr< FeatureMeasurementIds_type > p);

      // SubstituteFeatureAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType SubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithm_type > SubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithm_type, wchar_t > SubstituteFeatureAlgorithm_traits;

      const SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm () const;

      SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm ();

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x);

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x);

      void
      SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > p);

      // ActualComponentId
      //
      typedef ::xsd::qif30::QIFReferenceType ActualComponentId_type;
      typedef ::xsd::cxx::tree::optional< ActualComponentId_type > ActualComponentId_optional;
      typedef ::xsd::cxx::tree::traits< ActualComponentId_type, wchar_t > ActualComponentId_traits;

      const ActualComponentId_optional&
      ActualComponentId () const;

      ActualComponentId_optional&
      ActualComponentId ();

      void
      ActualComponentId (const ActualComponentId_type& x);

      void
      ActualComponentId (const ActualComponentId_optional& x);

      void
      ActualComponentId (::std::unique_ptr< ActualComponentId_type > p);

      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // ManufacturingProcessId
      //
      typedef ::xsd::qif30::QIFReferenceType ManufacturingProcessId_type;
      typedef ::xsd::cxx::tree::optional< ManufacturingProcessId_type > ManufacturingProcessId_optional;
      typedef ::xsd::cxx::tree::traits< ManufacturingProcessId_type, wchar_t > ManufacturingProcessId_traits;

      const ManufacturingProcessId_optional&
      ManufacturingProcessId () const;

      ManufacturingProcessId_optional&
      ManufacturingProcessId ();

      void
      ManufacturingProcessId (const ManufacturingProcessId_type& x);

      void
      ManufacturingProcessId (const ManufacturingProcessId_optional& x);

      void
      ManufacturingProcessId (::std::unique_ptr< ManufacturingProcessId_type > p);

      // NotedEventIds
      //
      typedef ::xsd::qif30::ArrayReferenceType NotedEventIds_type;
      typedef ::xsd::cxx::tree::optional< NotedEventIds_type > NotedEventIds_optional;
      typedef ::xsd::cxx::tree::traits< NotedEventIds_type, wchar_t > NotedEventIds_traits;

      const NotedEventIds_optional&
      NotedEventIds () const;

      NotedEventIds_optional&
      NotedEventIds ();

      void
      NotedEventIds (const NotedEventIds_type& x);

      void
      NotedEventIds (const NotedEventIds_optional& x);

      void
      NotedEventIds (::std::unique_ptr< NotedEventIds_type > p);

      // NonConformanceDesignator
      //
      typedef ::xml_schema::token NonConformanceDesignator_type;
      typedef ::xsd::cxx::tree::optional< NonConformanceDesignator_type > NonConformanceDesignator_optional;
      typedef ::xsd::cxx::tree::traits< NonConformanceDesignator_type, wchar_t > NonConformanceDesignator_traits;

      const NonConformanceDesignator_optional&
      NonConformanceDesignator () const;

      NonConformanceDesignator_optional&
      NonConformanceDesignator ();

      void
      NonConformanceDesignator (const NonConformanceDesignator_type& x);

      void
      NonConformanceDesignator (const NonConformanceDesignator_optional& x);

      void
      NonConformanceDesignator (::std::unique_ptr< NonConformanceDesignator_type > p);

      // Constructors.
      //
      CharacteristicMeasurementBaseType ();

      CharacteristicMeasurementBaseType (const id_type&,
                                         const Status_type&,
                                         const CharacteristicItemId_type&);

      CharacteristicMeasurementBaseType (const id_type&,
                                         ::std::unique_ptr< Status_type >,
                                         ::std::unique_ptr< CharacteristicItemId_type >);

      CharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CharacteristicMeasurementBaseType (const CharacteristicMeasurementBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CharacteristicMeasurementBaseType&
      operator= (const CharacteristicMeasurementBaseType& x);

      virtual 
      ~CharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Status_type > Status_;
      ::xsd::cxx::tree::one< CharacteristicItemId_type > CharacteristicItemId_;
      TimeStamp_optional TimeStamp_;
      FeatureMeasurementIds_optional FeatureMeasurementIds_;
      SubstituteFeatureAlgorithm_optional SubstituteFeatureAlgorithm_;
      ActualComponentId_optional ActualComponentId_;
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
      ManufacturingProcessId_optional ManufacturingProcessId_;
      NotedEventIds_optional NotedEventIds_;
      NonConformanceDesignator_optional NonConformanceDesignator_;
    };

    class QIF30_SYMBOL_DECL AssociatedTolerancedFeatureSpecificationElementEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        C,
        G,
        N,
        T,
        X
      };

      AssociatedTolerancedFeatureSpecificationElementEnumType ();

      AssociatedTolerancedFeatureSpecificationElementEnumType (value v);

      AssociatedTolerancedFeatureSpecificationElementEnumType (const wchar_t* v);

      AssociatedTolerancedFeatureSpecificationElementEnumType (const ::std::wstring& v);

      AssociatedTolerancedFeatureSpecificationElementEnumType (const ::xml_schema::nmtoken& v);

      AssociatedTolerancedFeatureSpecificationElementEnumType (const xercesc::DOMElement& e,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

      AssociatedTolerancedFeatureSpecificationElementEnumType (const xercesc::DOMAttr& a,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

      AssociatedTolerancedFeatureSpecificationElementEnumType (const ::std::wstring& s,
                                                               const xercesc::DOMElement* e,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

      AssociatedTolerancedFeatureSpecificationElementEnumType (const AssociatedTolerancedFeatureSpecificationElementEnumType& x,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      AssociatedTolerancedFeatureSpecificationElementEnumType&
      operator= (const AssociatedTolerancedFeatureSpecificationElementEnumType&) = default;
#endif

      virtual AssociatedTolerancedFeatureSpecificationElementEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AssociatedTolerancedFeatureSpecificationElementEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AssociatedTolerancedFeatureSpecificationElementEnumType_convert ();
      }

      protected:
      value
      _xsd_AssociatedTolerancedFeatureSpecificationElementEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_AssociatedTolerancedFeatureSpecificationElementEnumType_literals_[5];
      static const value _xsd_AssociatedTolerancedFeatureSpecificationElementEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL ReferenceFeatureAssociationSpecificationElementEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        C,
        CE,
        CI,
        G,
        GE,
        GI,
        N,
        X
      };

      ReferenceFeatureAssociationSpecificationElementEnumType ();

      ReferenceFeatureAssociationSpecificationElementEnumType (value v);

      ReferenceFeatureAssociationSpecificationElementEnumType (const wchar_t* v);

      ReferenceFeatureAssociationSpecificationElementEnumType (const ::std::wstring& v);

      ReferenceFeatureAssociationSpecificationElementEnumType (const ::xml_schema::nmtoken& v);

      ReferenceFeatureAssociationSpecificationElementEnumType (const xercesc::DOMElement& e,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

      ReferenceFeatureAssociationSpecificationElementEnumType (const xercesc::DOMAttr& a,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

      ReferenceFeatureAssociationSpecificationElementEnumType (const ::std::wstring& s,
                                                               const xercesc::DOMElement* e,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

      ReferenceFeatureAssociationSpecificationElementEnumType (const ReferenceFeatureAssociationSpecificationElementEnumType& x,
                                                               ::xml_schema::flags f = 0,
                                                               ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ReferenceFeatureAssociationSpecificationElementEnumType&
      operator= (const ReferenceFeatureAssociationSpecificationElementEnumType&) = default;
#endif

      virtual ReferenceFeatureAssociationSpecificationElementEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferenceFeatureAssociationSpecificationElementEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ReferenceFeatureAssociationSpecificationElementEnumType_convert ();
      }

      protected:
      value
      _xsd_ReferenceFeatureAssociationSpecificationElementEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ReferenceFeatureAssociationSpecificationElementEnumType_literals_[8];
      static const value _xsd_ReferenceFeatureAssociationSpecificationElementEnumType_indexes_[8];
    };

    class QIF30_SYMBOL_DECL ReferenceFeatureAssociationSpecificationParameterEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        P,
        V,
        T,
        Q
      };

      ReferenceFeatureAssociationSpecificationParameterEnumType ();

      ReferenceFeatureAssociationSpecificationParameterEnumType (value v);

      ReferenceFeatureAssociationSpecificationParameterEnumType (const wchar_t* v);

      ReferenceFeatureAssociationSpecificationParameterEnumType (const ::std::wstring& v);

      ReferenceFeatureAssociationSpecificationParameterEnumType (const ::xml_schema::nmtoken& v);

      ReferenceFeatureAssociationSpecificationParameterEnumType (const xercesc::DOMElement& e,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

      ReferenceFeatureAssociationSpecificationParameterEnumType (const xercesc::DOMAttr& a,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

      ReferenceFeatureAssociationSpecificationParameterEnumType (const ::std::wstring& s,
                                                                 const xercesc::DOMElement* e,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

      ReferenceFeatureAssociationSpecificationParameterEnumType (const ReferenceFeatureAssociationSpecificationParameterEnumType& x,
                                                                 ::xml_schema::flags f = 0,
                                                                 ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ReferenceFeatureAssociationSpecificationParameterEnumType&
      operator= (const ReferenceFeatureAssociationSpecificationParameterEnumType&) = default;
#endif

      virtual ReferenceFeatureAssociationSpecificationParameterEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferenceFeatureAssociationSpecificationParameterEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ReferenceFeatureAssociationSpecificationParameterEnumType_convert ();
      }

      protected:
      value
      _xsd_ReferenceFeatureAssociationSpecificationParameterEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ReferenceFeatureAssociationSpecificationParameterEnumType_literals_[4];
      static const value _xsd_ReferenceFeatureAssociationSpecificationParameterEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL SingleNestingIndexFilterSymbolEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        AB,
        AD,
        AH,
        CB,
        CD,
        CH,
        H,
        OB,
        OH,
        OS
      };

      SingleNestingIndexFilterSymbolEnumType ();

      SingleNestingIndexFilterSymbolEnumType (value v);

      SingleNestingIndexFilterSymbolEnumType (const wchar_t* v);

      SingleNestingIndexFilterSymbolEnumType (const ::std::wstring& v);

      SingleNestingIndexFilterSymbolEnumType (const ::xml_schema::nmtoken& v);

      SingleNestingIndexFilterSymbolEnumType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      SingleNestingIndexFilterSymbolEnumType (const xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      SingleNestingIndexFilterSymbolEnumType (const ::std::wstring& s,
                                              const xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      SingleNestingIndexFilterSymbolEnumType (const SingleNestingIndexFilterSymbolEnumType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SingleNestingIndexFilterSymbolEnumType&
      operator= (const SingleNestingIndexFilterSymbolEnumType&) = default;
#endif

      virtual SingleNestingIndexFilterSymbolEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SingleNestingIndexFilterSymbolEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SingleNestingIndexFilterSymbolEnumType_convert ();
      }

      protected:
      value
      _xsd_SingleNestingIndexFilterSymbolEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_SingleNestingIndexFilterSymbolEnumType_literals_[10];
      static const value _xsd_SingleNestingIndexFilterSymbolEnumType_indexes_[10];
    };

    class QIF30_SYMBOL_DECL SingleNestingIndexFilterType: public ::xml_schema::type
    {
      public:
      // Symbol
      //
      typedef ::xsd::qif30::SingleNestingIndexFilterSymbolEnumType Symbol_type;
      typedef ::xsd::cxx::tree::traits< Symbol_type, wchar_t > Symbol_traits;

      const Symbol_type&
      Symbol () const;

      Symbol_type&
      Symbol ();

      void
      Symbol (const Symbol_type& x);

      void
      Symbol (::std::unique_ptr< Symbol_type > p);

      // NestingIndex
      //
      typedef ::xsd::qif30::LinearValueType NestingIndex_type;
      typedef ::xsd::cxx::tree::traits< NestingIndex_type, wchar_t > NestingIndex_traits;

      const NestingIndex_type&
      NestingIndex () const;

      NestingIndex_type&
      NestingIndex ();

      void
      NestingIndex (const NestingIndex_type& x);

      void
      NestingIndex (::std::unique_ptr< NestingIndex_type > p);

      // SecondDirectionNestingIndex
      //
      typedef ::xsd::qif30::LinearValueType SecondDirectionNestingIndex_type;
      typedef ::xsd::cxx::tree::optional< SecondDirectionNestingIndex_type > SecondDirectionNestingIndex_optional;
      typedef ::xsd::cxx::tree::traits< SecondDirectionNestingIndex_type, wchar_t > SecondDirectionNestingIndex_traits;

      const SecondDirectionNestingIndex_optional&
      SecondDirectionNestingIndex () const;

      SecondDirectionNestingIndex_optional&
      SecondDirectionNestingIndex ();

      void
      SecondDirectionNestingIndex (const SecondDirectionNestingIndex_type& x);

      void
      SecondDirectionNestingIndex (const SecondDirectionNestingIndex_optional& x);

      void
      SecondDirectionNestingIndex (::std::unique_ptr< SecondDirectionNestingIndex_type > p);

      // Constructors.
      //
      SingleNestingIndexFilterType ();

      SingleNestingIndexFilterType (const Symbol_type&,
                                    const NestingIndex_type&);

      SingleNestingIndexFilterType (const Symbol_type&,
                                    ::std::unique_ptr< NestingIndex_type >);

      SingleNestingIndexFilterType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SingleNestingIndexFilterType (const SingleNestingIndexFilterType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SingleNestingIndexFilterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SingleNestingIndexFilterType&
      operator= (const SingleNestingIndexFilterType& x);

      virtual 
      ~SingleNestingIndexFilterType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Symbol_type > Symbol_;
      ::xsd::cxx::tree::one< NestingIndex_type > NestingIndex_;
      SecondDirectionNestingIndex_optional SecondDirectionNestingIndex_;
    };

    class QIF30_SYMBOL_DECL DualNestingIndexFilterSymbolEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        CW,
        F,
        G,
        RG,
        RS,
        S,
        SW
      };

      DualNestingIndexFilterSymbolEnumType ();

      DualNestingIndexFilterSymbolEnumType (value v);

      DualNestingIndexFilterSymbolEnumType (const wchar_t* v);

      DualNestingIndexFilterSymbolEnumType (const ::std::wstring& v);

      DualNestingIndexFilterSymbolEnumType (const ::xml_schema::nmtoken& v);

      DualNestingIndexFilterSymbolEnumType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      DualNestingIndexFilterSymbolEnumType (const xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      DualNestingIndexFilterSymbolEnumType (const ::std::wstring& s,
                                            const xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      DualNestingIndexFilterSymbolEnumType (const DualNestingIndexFilterSymbolEnumType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DualNestingIndexFilterSymbolEnumType&
      operator= (const DualNestingIndexFilterSymbolEnumType&) = default;
#endif

      virtual DualNestingIndexFilterSymbolEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DualNestingIndexFilterSymbolEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DualNestingIndexFilterSymbolEnumType_convert ();
      }

      protected:
      value
      _xsd_DualNestingIndexFilterSymbolEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DualNestingIndexFilterSymbolEnumType_literals_[7];
      static const value _xsd_DualNestingIndexFilterSymbolEnumType_indexes_[7];
    };

    class QIF30_SYMBOL_DECL DualNestingIndexFilterType: public ::xml_schema::type
    {
      public:
      // Symbol
      //
      typedef ::xsd::qif30::DualNestingIndexFilterSymbolEnumType Symbol_type;
      typedef ::xsd::cxx::tree::traits< Symbol_type, wchar_t > Symbol_traits;

      const Symbol_type&
      Symbol () const;

      Symbol_type&
      Symbol ();

      void
      Symbol (const Symbol_type& x);

      void
      Symbol (::std::unique_ptr< Symbol_type > p);

      // FirstNestingIndex
      //
      typedef ::xsd::qif30::LinearValueType FirstNestingIndex_type;
      typedef ::xsd::cxx::tree::optional< FirstNestingIndex_type > FirstNestingIndex_optional;
      typedef ::xsd::cxx::tree::traits< FirstNestingIndex_type, wchar_t > FirstNestingIndex_traits;

      const FirstNestingIndex_optional&
      FirstNestingIndex () const;

      FirstNestingIndex_optional&
      FirstNestingIndex ();

      void
      FirstNestingIndex (const FirstNestingIndex_type& x);

      void
      FirstNestingIndex (const FirstNestingIndex_optional& x);

      void
      FirstNestingIndex (::std::unique_ptr< FirstNestingIndex_type > p);

      // SecondNestingIndex
      //
      typedef ::xsd::qif30::LinearValueType SecondNestingIndex_type;
      typedef ::xsd::cxx::tree::optional< SecondNestingIndex_type > SecondNestingIndex_optional;
      typedef ::xsd::cxx::tree::traits< SecondNestingIndex_type, wchar_t > SecondNestingIndex_traits;

      const SecondNestingIndex_optional&
      SecondNestingIndex () const;

      SecondNestingIndex_optional&
      SecondNestingIndex ();

      void
      SecondNestingIndex (const SecondNestingIndex_type& x);

      void
      SecondNestingIndex (const SecondNestingIndex_optional& x);

      void
      SecondNestingIndex (::std::unique_ptr< SecondNestingIndex_type > p);

      // SecondDirectionFirstNestingIndex
      //
      typedef ::xsd::qif30::LinearValueType SecondDirectionFirstNestingIndex_type;
      typedef ::xsd::cxx::tree::optional< SecondDirectionFirstNestingIndex_type > SecondDirectionFirstNestingIndex_optional;
      typedef ::xsd::cxx::tree::traits< SecondDirectionFirstNestingIndex_type, wchar_t > SecondDirectionFirstNestingIndex_traits;

      const SecondDirectionFirstNestingIndex_optional&
      SecondDirectionFirstNestingIndex () const;

      SecondDirectionFirstNestingIndex_optional&
      SecondDirectionFirstNestingIndex ();

      void
      SecondDirectionFirstNestingIndex (const SecondDirectionFirstNestingIndex_type& x);

      void
      SecondDirectionFirstNestingIndex (const SecondDirectionFirstNestingIndex_optional& x);

      void
      SecondDirectionFirstNestingIndex (::std::unique_ptr< SecondDirectionFirstNestingIndex_type > p);

      // SecondDirectionSecondNestingIndex
      //
      typedef ::xsd::qif30::LinearValueType SecondDirectionSecondNestingIndex_type;
      typedef ::xsd::cxx::tree::optional< SecondDirectionSecondNestingIndex_type > SecondDirectionSecondNestingIndex_optional;
      typedef ::xsd::cxx::tree::traits< SecondDirectionSecondNestingIndex_type, wchar_t > SecondDirectionSecondNestingIndex_traits;

      const SecondDirectionSecondNestingIndex_optional&
      SecondDirectionSecondNestingIndex () const;

      SecondDirectionSecondNestingIndex_optional&
      SecondDirectionSecondNestingIndex ();

      void
      SecondDirectionSecondNestingIndex (const SecondDirectionSecondNestingIndex_type& x);

      void
      SecondDirectionSecondNestingIndex (const SecondDirectionSecondNestingIndex_optional& x);

      void
      SecondDirectionSecondNestingIndex (::std::unique_ptr< SecondDirectionSecondNestingIndex_type > p);

      // Constructors.
      //
      DualNestingIndexFilterType ();

      DualNestingIndexFilterType (const Symbol_type&);

      DualNestingIndexFilterType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      DualNestingIndexFilterType (const DualNestingIndexFilterType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual DualNestingIndexFilterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DualNestingIndexFilterType&
      operator= (const DualNestingIndexFilterType& x);

      virtual 
      ~DualNestingIndexFilterType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Symbol_type > Symbol_;
      FirstNestingIndex_optional FirstNestingIndex_;
      SecondNestingIndex_optional SecondNestingIndex_;
      SecondDirectionFirstNestingIndex_optional SecondDirectionFirstNestingIndex_;
      SecondDirectionSecondNestingIndex_optional SecondDirectionSecondNestingIndex_;
    };

    class QIF30_SYMBOL_DECL FilterType: public ::xml_schema::type
    {
      public:
      // SingleNestingIndexFilter
      //
      typedef ::xsd::qif30::SingleNestingIndexFilterType SingleNestingIndexFilter_type;
      typedef ::xsd::cxx::tree::optional< SingleNestingIndexFilter_type > SingleNestingIndexFilter_optional;
      typedef ::xsd::cxx::tree::traits< SingleNestingIndexFilter_type, wchar_t > SingleNestingIndexFilter_traits;

      const SingleNestingIndexFilter_optional&
      SingleNestingIndexFilter () const;

      SingleNestingIndexFilter_optional&
      SingleNestingIndexFilter ();

      void
      SingleNestingIndexFilter (const SingleNestingIndexFilter_type& x);

      void
      SingleNestingIndexFilter (const SingleNestingIndexFilter_optional& x);

      void
      SingleNestingIndexFilter (::std::unique_ptr< SingleNestingIndexFilter_type > p);

      // DualNestingIndexFilter
      //
      typedef ::xsd::qif30::DualNestingIndexFilterType DualNestingIndexFilter_type;
      typedef ::xsd::cxx::tree::optional< DualNestingIndexFilter_type > DualNestingIndexFilter_optional;
      typedef ::xsd::cxx::tree::traits< DualNestingIndexFilter_type, wchar_t > DualNestingIndexFilter_traits;

      const DualNestingIndexFilter_optional&
      DualNestingIndexFilter () const;

      DualNestingIndexFilter_optional&
      DualNestingIndexFilter ();

      void
      DualNestingIndexFilter (const DualNestingIndexFilter_type& x);

      void
      DualNestingIndexFilter (const DualNestingIndexFilter_optional& x);

      void
      DualNestingIndexFilter (::std::unique_ptr< DualNestingIndexFilter_type > p);

      // Constructors.
      //
      FilterType ();

      FilterType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      FilterType (const FilterType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual FilterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FilterType&
      operator= (const FilterType& x);

      virtual 
      ~FilterType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SingleNestingIndexFilter_optional SingleNestingIndexFilter_;
      DualNestingIndexFilter_optional DualNestingIndexFilter_;
    };

    class QIF30_SYMBOL_DECL ReferenceFeatureAssociationSpecificationElementType: public ::xml_schema::type
    {
      public:
      // Filter
      //
      typedef ::xsd::qif30::FilterType Filter_type;
      typedef ::xsd::cxx::tree::optional< Filter_type > Filter_optional;
      typedef ::xsd::cxx::tree::traits< Filter_type, wchar_t > Filter_traits;

      const Filter_optional&
      Filter () const;

      Filter_optional&
      Filter ();

      void
      Filter (const Filter_type& x);

      void
      Filter (const Filter_optional& x);

      void
      Filter (::std::unique_ptr< Filter_type > p);

      // Association
      //
      typedef ::xsd::qif30::ReferenceFeatureAssociationSpecificationElementEnumType Association_type;
      typedef ::xsd::cxx::tree::traits< Association_type, wchar_t > Association_traits;

      const Association_type&
      Association () const;

      Association_type&
      Association ();

      void
      Association (const Association_type& x);

      void
      Association (::std::unique_ptr< Association_type > p);

      // Parameter
      //
      typedef ::xsd::qif30::ReferenceFeatureAssociationSpecificationParameterEnumType Parameter_type;
      typedef ::xsd::cxx::tree::traits< Parameter_type, wchar_t > Parameter_traits;

      const Parameter_type&
      Parameter () const;

      Parameter_type&
      Parameter ();

      void
      Parameter (const Parameter_type& x);

      void
      Parameter (::std::unique_ptr< Parameter_type > p);

      // Constructors.
      //
      ReferenceFeatureAssociationSpecificationElementType ();

      ReferenceFeatureAssociationSpecificationElementType (const Association_type&,
                                                           const Parameter_type&);

      ReferenceFeatureAssociationSpecificationElementType (const xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

      ReferenceFeatureAssociationSpecificationElementType (const ReferenceFeatureAssociationSpecificationElementType& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

      virtual ReferenceFeatureAssociationSpecificationElementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferenceFeatureAssociationSpecificationElementType&
      operator= (const ReferenceFeatureAssociationSpecificationElementType& x);

      virtual 
      ~ReferenceFeatureAssociationSpecificationElementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Filter_optional Filter_;
      ::xsd::cxx::tree::one< Association_type > Association_;
      ::xsd::cxx::tree::one< Parameter_type > Parameter_;
    };

    class QIF30_SYMBOL_DECL GeometricCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // AssociatedTolerancedFeatureSpecificationElement
      //
      typedef ::xsd::qif30::AssociatedTolerancedFeatureSpecificationElementEnumType AssociatedTolerancedFeatureSpecificationElement_type;
      typedef ::xsd::cxx::tree::optional< AssociatedTolerancedFeatureSpecificationElement_type > AssociatedTolerancedFeatureSpecificationElement_optional;
      typedef ::xsd::cxx::tree::traits< AssociatedTolerancedFeatureSpecificationElement_type, wchar_t > AssociatedTolerancedFeatureSpecificationElement_traits;

      const AssociatedTolerancedFeatureSpecificationElement_optional&
      AssociatedTolerancedFeatureSpecificationElement () const;

      AssociatedTolerancedFeatureSpecificationElement_optional&
      AssociatedTolerancedFeatureSpecificationElement ();

      void
      AssociatedTolerancedFeatureSpecificationElement (const AssociatedTolerancedFeatureSpecificationElement_type& x);

      void
      AssociatedTolerancedFeatureSpecificationElement (const AssociatedTolerancedFeatureSpecificationElement_optional& x);

      void
      AssociatedTolerancedFeatureSpecificationElement (::std::unique_ptr< AssociatedTolerancedFeatureSpecificationElement_type > p);

      // ReferenceFeatureAssociationSpecificationElement
      //
      typedef ::xsd::qif30::ReferenceFeatureAssociationSpecificationElementType ReferenceFeatureAssociationSpecificationElement_type;
      typedef ::xsd::cxx::tree::optional< ReferenceFeatureAssociationSpecificationElement_type > ReferenceFeatureAssociationSpecificationElement_optional;
      typedef ::xsd::cxx::tree::traits< ReferenceFeatureAssociationSpecificationElement_type, wchar_t > ReferenceFeatureAssociationSpecificationElement_traits;

      const ReferenceFeatureAssociationSpecificationElement_optional&
      ReferenceFeatureAssociationSpecificationElement () const;

      ReferenceFeatureAssociationSpecificationElement_optional&
      ReferenceFeatureAssociationSpecificationElement ();

      void
      ReferenceFeatureAssociationSpecificationElement (const ReferenceFeatureAssociationSpecificationElement_type& x);

      void
      ReferenceFeatureAssociationSpecificationElement (const ReferenceFeatureAssociationSpecificationElement_optional& x);

      void
      ReferenceFeatureAssociationSpecificationElement (::std::unique_ptr< ReferenceFeatureAssociationSpecificationElement_type > p);

      // DirectionFeature
      //
      typedef ::xsd::qif30::DirectionFeatureType DirectionFeature_type;
      typedef ::xsd::cxx::tree::optional< DirectionFeature_type > DirectionFeature_optional;
      typedef ::xsd::cxx::tree::traits< DirectionFeature_type, wchar_t > DirectionFeature_traits;

      const DirectionFeature_optional&
      DirectionFeature () const;

      DirectionFeature_optional&
      DirectionFeature ();

      void
      DirectionFeature (const DirectionFeature_type& x);

      void
      DirectionFeature (const DirectionFeature_optional& x);

      void
      DirectionFeature (::std::unique_ptr< DirectionFeature_type > p);

      // CollectionPlane
      //
      typedef ::xsd::qif30::CollectionPlaneType CollectionPlane_type;
      typedef ::xsd::cxx::tree::optional< CollectionPlane_type > CollectionPlane_optional;
      typedef ::xsd::cxx::tree::traits< CollectionPlane_type, wchar_t > CollectionPlane_traits;

      const CollectionPlane_optional&
      CollectionPlane () const;

      CollectionPlane_optional&
      CollectionPlane ();

      void
      CollectionPlane (const CollectionPlane_type& x);

      void
      CollectionPlane (const CollectionPlane_optional& x);

      void
      CollectionPlane (::std::unique_ptr< CollectionPlane_type > p);

      // IntersectionPlane
      //
      typedef ::xsd::qif30::IntersectionPlaneType IntersectionPlane_type;
      typedef ::xsd::cxx::tree::optional< IntersectionPlane_type > IntersectionPlane_optional;
      typedef ::xsd::cxx::tree::traits< IntersectionPlane_type, wchar_t > IntersectionPlane_traits;

      const IntersectionPlane_optional&
      IntersectionPlane () const;

      IntersectionPlane_optional&
      IntersectionPlane ();

      void
      IntersectionPlane (const IntersectionPlane_type& x);

      void
      IntersectionPlane (const IntersectionPlane_optional& x);

      void
      IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > p);

      // OrientationPlane
      //
      typedef ::xsd::qif30::OrientationPlaneType OrientationPlane_type;
      typedef ::xsd::cxx::tree::optional< OrientationPlane_type > OrientationPlane_optional;
      typedef ::xsd::cxx::tree::traits< OrientationPlane_type, wchar_t > OrientationPlane_traits;

      const OrientationPlane_optional&
      OrientationPlane () const;

      OrientationPlane_optional&
      OrientationPlane ();

      void
      OrientationPlane (const OrientationPlane_type& x);

      void
      OrientationPlane (const OrientationPlane_optional& x);

      void
      OrientationPlane (::std::unique_ptr< OrientationPlane_type > p);

      // Constructors.
      //
      GeometricCharacteristicDefinitionBaseType ();

      GeometricCharacteristicDefinitionBaseType (const id_type&);

      GeometricCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      GeometricCharacteristicDefinitionBaseType (const GeometricCharacteristicDefinitionBaseType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual GeometricCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      GeometricCharacteristicDefinitionBaseType&
      operator= (const GeometricCharacteristicDefinitionBaseType& x);

      virtual 
      ~GeometricCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AssociatedTolerancedFeatureSpecificationElement_optional AssociatedTolerancedFeatureSpecificationElement_;
      ReferenceFeatureAssociationSpecificationElement_optional ReferenceFeatureAssociationSpecificationElement_;
      DirectionFeature_optional DirectionFeature_;
      CollectionPlane_optional CollectionPlane_;
      IntersectionPlane_optional IntersectionPlane_;
      OrientationPlane_optional OrientationPlane_;
    };

    class QIF30_SYMBOL_DECL GeometricCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      GeometricCharacteristicNominalBaseType ();

      GeometricCharacteristicNominalBaseType (const id_type&,
                                              const CharacteristicDefinitionId_type&);

      GeometricCharacteristicNominalBaseType (const id_type&,
                                              ::std::unique_ptr< CharacteristicDefinitionId_type >);

      GeometricCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      GeometricCharacteristicNominalBaseType (const GeometricCharacteristicNominalBaseType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual GeometricCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      GeometricCharacteristicNominalBaseType&
      operator= (const GeometricCharacteristicNominalBaseType&) = default;
#endif

      virtual 
      ~GeometricCharacteristicNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL GeometricCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      GeometricCharacteristicMeasurementBaseType ();

      GeometricCharacteristicMeasurementBaseType (const id_type&,
                                                  const Status_type&,
                                                  const CharacteristicItemId_type&);

      GeometricCharacteristicMeasurementBaseType (const id_type&,
                                                  ::std::unique_ptr< Status_type >,
                                                  ::std::unique_ptr< CharacteristicItemId_type >);

      GeometricCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      GeometricCharacteristicMeasurementBaseType (const GeometricCharacteristicMeasurementBaseType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual GeometricCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      GeometricCharacteristicMeasurementBaseType&
      operator= (const GeometricCharacteristicMeasurementBaseType& x);

      virtual 
      ~GeometricCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL GeometricCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      GeometricCharacteristicItemBaseType ();

      GeometricCharacteristicItemBaseType (const id_type&,
                                           const CharacteristicNominalId_type&);

      GeometricCharacteristicItemBaseType (const id_type&,
                                           ::std::unique_ptr< CharacteristicNominalId_type >);

      GeometricCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      GeometricCharacteristicItemBaseType (const GeometricCharacteristicItemBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual GeometricCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      GeometricCharacteristicItemBaseType&
      operator= (const GeometricCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~GeometricCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL DimensionalCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // DimensionType
      //
      typedef ::xsd::qif30::DimensionModifierEnumType DimensionType_type;
      typedef ::xsd::cxx::tree::optional< DimensionType_type > DimensionType_optional;
      typedef ::xsd::cxx::tree::traits< DimensionType_type, wchar_t > DimensionType_traits;

      const DimensionType_optional&
      DimensionType () const;

      DimensionType_optional&
      DimensionType ();

      void
      DimensionType (const DimensionType_type& x);

      void
      DimensionType (const DimensionType_optional& x);

      void
      DimensionType (::std::unique_ptr< DimensionType_type > p);

      // DimensionModifiers
      //
      typedef ::xsd::qif30::DimensionModifiersType DimensionModifiers_type;
      typedef ::xsd::cxx::tree::optional< DimensionModifiers_type > DimensionModifiers_optional;
      typedef ::xsd::cxx::tree::traits< DimensionModifiers_type, wchar_t > DimensionModifiers_traits;

      const DimensionModifiers_optional&
      DimensionModifiers () const;

      DimensionModifiers_optional&
      DimensionModifiers ();

      void
      DimensionModifiers (const DimensionModifiers_type& x);

      void
      DimensionModifiers (const DimensionModifiers_optional& x);

      void
      DimensionModifiers (::std::unique_ptr< DimensionModifiers_type > p);

      // Constructors.
      //
      DimensionalCharacteristicDefinitionBaseType ();

      DimensionalCharacteristicDefinitionBaseType (const id_type&);

      DimensionalCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      DimensionalCharacteristicDefinitionBaseType (const DimensionalCharacteristicDefinitionBaseType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual DimensionalCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      DimensionalCharacteristicDefinitionBaseType&
      operator= (const DimensionalCharacteristicDefinitionBaseType& x);

      virtual 
      ~DimensionalCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DimensionType_optional DimensionType_;
      DimensionModifiers_optional DimensionModifiers_;
    };

    class QIF30_SYMBOL_DECL DimensionalCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      DimensionalCharacteristicNominalBaseType ();

      DimensionalCharacteristicNominalBaseType (const id_type&,
                                                const CharacteristicDefinitionId_type&);

      DimensionalCharacteristicNominalBaseType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >);

      DimensionalCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      DimensionalCharacteristicNominalBaseType (const DimensionalCharacteristicNominalBaseType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual DimensionalCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      DimensionalCharacteristicNominalBaseType&
      operator= (const DimensionalCharacteristicNominalBaseType&) = default;
#endif

      virtual 
      ~DimensionalCharacteristicNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL DimensionalCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      DimensionalCharacteristicMeasurementBaseType ();

      DimensionalCharacteristicMeasurementBaseType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      DimensionalCharacteristicMeasurementBaseType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      DimensionalCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      DimensionalCharacteristicMeasurementBaseType (const DimensionalCharacteristicMeasurementBaseType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual DimensionalCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      DimensionalCharacteristicMeasurementBaseType&
      operator= (const DimensionalCharacteristicMeasurementBaseType&) = default;
#endif

      virtual 
      ~DimensionalCharacteristicMeasurementBaseType ();
    };

    class QIF30_SYMBOL_DECL DimensionalCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      DimensionalCharacteristicItemBaseType ();

      DimensionalCharacteristicItemBaseType (const id_type&,
                                             const CharacteristicNominalId_type&);

      DimensionalCharacteristicItemBaseType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      DimensionalCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      DimensionalCharacteristicItemBaseType (const DimensionalCharacteristicItemBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual DimensionalCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      DimensionalCharacteristicItemBaseType&
      operator= (const DimensionalCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~DimensionalCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL CoordinateCharacteristicDefinitionBaseType: public ::xsd::qif30::DimensionalCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      CoordinateCharacteristicDefinitionBaseType ();

      CoordinateCharacteristicDefinitionBaseType (const id_type&);

      CoordinateCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      CoordinateCharacteristicDefinitionBaseType (const CoordinateCharacteristicDefinitionBaseType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual CoordinateCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CoordinateCharacteristicDefinitionBaseType&
      operator= (const CoordinateCharacteristicDefinitionBaseType&) = default;
#endif

      virtual 
      ~CoordinateCharacteristicDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL CoordinateCharacteristicNominalBaseType: public ::xsd::qif30::DimensionalCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      CoordinateCharacteristicNominalBaseType ();

      CoordinateCharacteristicNominalBaseType (const id_type&,
                                               const CharacteristicDefinitionId_type&);

      CoordinateCharacteristicNominalBaseType (const id_type&,
                                               ::std::unique_ptr< CharacteristicDefinitionId_type >);

      CoordinateCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CoordinateCharacteristicNominalBaseType (const CoordinateCharacteristicNominalBaseType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CoordinateCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CoordinateCharacteristicNominalBaseType&
      operator= (const CoordinateCharacteristicNominalBaseType&) = default;
#endif

      virtual 
      ~CoordinateCharacteristicNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL CoordinateCharacteristicMeasurementBaseType: public ::xsd::qif30::DimensionalCharacteristicMeasurementBaseType
    {
      public:
      // TypeOfCoordinates
      //
      typedef ::xsd::qif30::TypeOfCoordinatesType TypeOfCoordinates_type;
      typedef ::xsd::cxx::tree::traits< TypeOfCoordinates_type, wchar_t > TypeOfCoordinates_traits;

      const TypeOfCoordinates_type&
      TypeOfCoordinates () const;

      TypeOfCoordinates_type&
      TypeOfCoordinates ();

      void
      TypeOfCoordinates (const TypeOfCoordinates_type& x);

      void
      TypeOfCoordinates (::std::unique_ptr< TypeOfCoordinates_type > p);

      // Constructors.
      //
      CoordinateCharacteristicMeasurementBaseType ();

      CoordinateCharacteristicMeasurementBaseType (const id_type&,
                                                   const Status_type&,
                                                   const CharacteristicItemId_type&,
                                                   const TypeOfCoordinates_type&);

      CoordinateCharacteristicMeasurementBaseType (const id_type&,
                                                   ::std::unique_ptr< Status_type >,
                                                   ::std::unique_ptr< CharacteristicItemId_type >,
                                                   ::std::unique_ptr< TypeOfCoordinates_type >);

      CoordinateCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      CoordinateCharacteristicMeasurementBaseType (const CoordinateCharacteristicMeasurementBaseType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual CoordinateCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CoordinateCharacteristicMeasurementBaseType&
      operator= (const CoordinateCharacteristicMeasurementBaseType& x);

      virtual 
      ~CoordinateCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TypeOfCoordinates_type > TypeOfCoordinates_;
    };

    class QIF30_SYMBOL_DECL CoordinateCharacteristicItemBaseType: public ::xsd::qif30::DimensionalCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      CoordinateCharacteristicItemBaseType ();

      CoordinateCharacteristicItemBaseType (const id_type&,
                                            const CharacteristicNominalId_type&);

      CoordinateCharacteristicItemBaseType (const id_type&,
                                            ::std::unique_ptr< CharacteristicNominalId_type >);

      CoordinateCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CoordinateCharacteristicItemBaseType (const CoordinateCharacteristicItemBaseType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CoordinateCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CoordinateCharacteristicItemBaseType&
      operator= (const CoordinateCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~CoordinateCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedAttributeCharacteristicDefinitionType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedAttributeCharacteristicDefinitionType ();

      UserDefinedAttributeCharacteristicDefinitionType (const id_type&,
                                                        const WhatToMeasure_type&);

      UserDefinedAttributeCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      UserDefinedAttributeCharacteristicDefinitionType (const UserDefinedAttributeCharacteristicDefinitionType& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      virtual UserDefinedAttributeCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAttributeCharacteristicDefinitionType&
      operator= (const UserDefinedAttributeCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedAttributeCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAttributeCharacteristicNominalType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // PassValues
      //
      typedef ::xsd::qif30::StringValuesType PassValues_type;
      typedef ::xsd::cxx::tree::optional< PassValues_type > PassValues_optional;
      typedef ::xsd::cxx::tree::traits< PassValues_type, wchar_t > PassValues_traits;

      const PassValues_optional&
      PassValues () const;

      PassValues_optional&
      PassValues ();

      void
      PassValues (const PassValues_type& x);

      void
      PassValues (const PassValues_optional& x);

      void
      PassValues (::std::unique_ptr< PassValues_type > p);

      // FailValues
      //
      typedef ::xsd::qif30::StringValuesType FailValues_type;
      typedef ::xsd::cxx::tree::optional< FailValues_type > FailValues_optional;
      typedef ::xsd::cxx::tree::traits< FailValues_type, wchar_t > FailValues_traits;

      const FailValues_optional&
      FailValues () const;

      FailValues_optional&
      FailValues ();

      void
      FailValues (const FailValues_type& x);

      void
      FailValues (const FailValues_optional& x);

      void
      FailValues (::std::unique_ptr< FailValues_type > p);

      // Constructors.
      //
      UserDefinedAttributeCharacteristicNominalType ();

      UserDefinedAttributeCharacteristicNominalType (const id_type&,
                                                     const CharacteristicDefinitionId_type&);

      UserDefinedAttributeCharacteristicNominalType (const id_type&,
                                                     ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedAttributeCharacteristicNominalType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      UserDefinedAttributeCharacteristicNominalType (const UserDefinedAttributeCharacteristicNominalType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual UserDefinedAttributeCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAttributeCharacteristicNominalType&
      operator= (const UserDefinedAttributeCharacteristicNominalType& x);

      virtual 
      ~UserDefinedAttributeCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PassValues_optional PassValues_;
      FailValues_optional FailValues_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAttributeCharacteristicMeasurementType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xml_schema::string Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // Constructors.
      //
      UserDefinedAttributeCharacteristicMeasurementType ();

      UserDefinedAttributeCharacteristicMeasurementType (const id_type&,
                                                         const Status_type&,
                                                         const CharacteristicItemId_type&);

      UserDefinedAttributeCharacteristicMeasurementType (const id_type&,
                                                         ::std::unique_ptr< Status_type >,
                                                         ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedAttributeCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      UserDefinedAttributeCharacteristicMeasurementType (const UserDefinedAttributeCharacteristicMeasurementType& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      virtual UserDefinedAttributeCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAttributeCharacteristicMeasurementType&
      operator= (const UserDefinedAttributeCharacteristicMeasurementType& x);

      virtual 
      ~UserDefinedAttributeCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAttributeCharacteristicItemType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedAttributeCharacteristicItemType ();

      UserDefinedAttributeCharacteristicItemType (const id_type&,
                                                  const CharacteristicNominalId_type&);

      UserDefinedAttributeCharacteristicItemType (const id_type&,
                                                  ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedAttributeCharacteristicItemType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      UserDefinedAttributeCharacteristicItemType (const UserDefinedAttributeCharacteristicItemType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual UserDefinedAttributeCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedAttributeCharacteristicItemType&
      operator= (const UserDefinedAttributeCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedAttributeCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL StringValuesType: public ::xml_schema::type
    {
      public:
      // StringValue
      //
      typedef ::xml_schema::string StringValue_type;
      typedef ::xsd::cxx::tree::sequence< StringValue_type > StringValue_sequence;
      typedef xsd::cxx::tree::sequence< StringValue_type >::iterator StringValue_iterator;
      typedef xsd::cxx::tree::sequence< StringValue_type >::const_iterator StringValue_const_iterator;
      typedef ::xsd::cxx::tree::traits< StringValue_type, wchar_t > StringValue_traits;

      const StringValue_sequence&
      StringValue () const;

      StringValue_sequence&
      StringValue ();

      void
      StringValue (const StringValue_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      StringValuesType ();

      StringValuesType (const n_type&);

      StringValuesType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      StringValuesType (const StringValuesType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual StringValuesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StringValuesType&
      operator= (const StringValuesType& x);

      virtual 
      ~StringValuesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StringValue_sequence StringValue_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL LinearCharacteristicDefinitionBaseType: public ::xsd::qif30::DimensionalCharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::LinearToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      LinearCharacteristicDefinitionBaseType ();

      LinearCharacteristicDefinitionBaseType (const id_type&);

      LinearCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      LinearCharacteristicDefinitionBaseType (const LinearCharacteristicDefinitionBaseType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual LinearCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      LinearCharacteristicDefinitionBaseType&
      operator= (const LinearCharacteristicDefinitionBaseType& x);

      virtual 
      ~LinearCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL UserDefinedLinearCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedLinearCharacteristicDefinitionType ();

      UserDefinedLinearCharacteristicDefinitionType (const id_type&,
                                                     const WhatToMeasure_type&);

      UserDefinedLinearCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      UserDefinedLinearCharacteristicDefinitionType (const UserDefinedLinearCharacteristicDefinitionType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual UserDefinedLinearCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedLinearCharacteristicDefinitionType&
      operator= (const UserDefinedLinearCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedLinearCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL LinearCharacteristicNominalBaseType: public ::xsd::qif30::DimensionalCharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::LinearValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // TargetDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType TargetDualValue_type;
      typedef ::xsd::cxx::tree::optional< TargetDualValue_type > TargetDualValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetDualValue_type, wchar_t > TargetDualValue_traits;

      const TargetDualValue_optional&
      TargetDualValue () const;

      TargetDualValue_optional&
      TargetDualValue ();

      void
      TargetDualValue (const TargetDualValue_type& x);

      void
      TargetDualValue (const TargetDualValue_optional& x);

      void
      TargetDualValue (::std::unique_ptr< TargetDualValue_type > p);

      // Constructors.
      //
      LinearCharacteristicNominalBaseType ();

      LinearCharacteristicNominalBaseType (const id_type&,
                                           const CharacteristicDefinitionId_type&);

      LinearCharacteristicNominalBaseType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >);

      LinearCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      LinearCharacteristicNominalBaseType (const LinearCharacteristicNominalBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual LinearCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      LinearCharacteristicNominalBaseType&
      operator= (const LinearCharacteristicNominalBaseType& x);

      virtual 
      ~LinearCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
      TargetDualValue_optional TargetDualValue_;
    };

    class QIF30_SYMBOL_DECL UserDefinedLinearCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedLinearCharacteristicNominalType ();

      UserDefinedLinearCharacteristicNominalType (const id_type&,
                                                  const CharacteristicDefinitionId_type&);

      UserDefinedLinearCharacteristicNominalType (const id_type&,
                                                  ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedLinearCharacteristicNominalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      UserDefinedLinearCharacteristicNominalType (const UserDefinedLinearCharacteristicNominalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual UserDefinedLinearCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedLinearCharacteristicNominalType&
      operator= (const UserDefinedLinearCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedLinearCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL LinearCharacteristicMeasurementBaseType: public ::xsd::qif30::DimensionalCharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      LinearCharacteristicMeasurementBaseType ();

      LinearCharacteristicMeasurementBaseType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&);

      LinearCharacteristicMeasurementBaseType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >);

      LinearCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      LinearCharacteristicMeasurementBaseType (const LinearCharacteristicMeasurementBaseType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual LinearCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      LinearCharacteristicMeasurementBaseType&
      operator= (const LinearCharacteristicMeasurementBaseType& x);

      virtual 
      ~LinearCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL UserDefinedLinearCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedLinearCharacteristicMeasurementType ();

      UserDefinedLinearCharacteristicMeasurementType (const id_type&,
                                                      const Status_type&,
                                                      const CharacteristicItemId_type&);

      UserDefinedLinearCharacteristicMeasurementType (const id_type&,
                                                      ::std::unique_ptr< Status_type >,
                                                      ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedLinearCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      UserDefinedLinearCharacteristicMeasurementType (const UserDefinedLinearCharacteristicMeasurementType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual UserDefinedLinearCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedLinearCharacteristicMeasurementType&
      operator= (const UserDefinedLinearCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedLinearCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL LinearCharacteristicItemBaseType: public ::xsd::qif30::DimensionalCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      LinearCharacteristicItemBaseType ();

      LinearCharacteristicItemBaseType (const id_type&,
                                        const CharacteristicNominalId_type&);

      LinearCharacteristicItemBaseType (const id_type&,
                                        ::std::unique_ptr< CharacteristicNominalId_type >);

      LinearCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      LinearCharacteristicItemBaseType (const LinearCharacteristicItemBaseType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual LinearCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      LinearCharacteristicItemBaseType&
      operator= (const LinearCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~LinearCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedLinearCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedLinearCharacteristicItemType ();

      UserDefinedLinearCharacteristicItemType (const id_type&,
                                               const CharacteristicNominalId_type&);

      UserDefinedLinearCharacteristicItemType (const id_type&,
                                               ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedLinearCharacteristicItemType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      UserDefinedLinearCharacteristicItemType (const UserDefinedLinearCharacteristicItemType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual UserDefinedLinearCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedLinearCharacteristicItemType&
      operator= (const UserDefinedLinearCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedLinearCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL AngularCharacteristicDefinitionBaseType: public ::xsd::qif30::DimensionalCharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::AngularToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      AngularCharacteristicDefinitionBaseType ();

      AngularCharacteristicDefinitionBaseType (const id_type&);

      AngularCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      AngularCharacteristicDefinitionBaseType (const AngularCharacteristicDefinitionBaseType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual AngularCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      AngularCharacteristicDefinitionBaseType&
      operator= (const AngularCharacteristicDefinitionBaseType& x);

      virtual 
      ~AngularCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAngularCharacteristicDefinitionType: public ::xsd::qif30::AngularCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedAngularCharacteristicDefinitionType ();

      UserDefinedAngularCharacteristicDefinitionType (const id_type&,
                                                      const WhatToMeasure_type&);

      UserDefinedAngularCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      UserDefinedAngularCharacteristicDefinitionType (const UserDefinedAngularCharacteristicDefinitionType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual UserDefinedAngularCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAngularCharacteristicDefinitionType&
      operator= (const UserDefinedAngularCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedAngularCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL AngularCharacteristicNominalBaseType: public ::xsd::qif30::DimensionalCharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::AngularValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      AngularCharacteristicNominalBaseType ();

      AngularCharacteristicNominalBaseType (const id_type&,
                                            const CharacteristicDefinitionId_type&);

      AngularCharacteristicNominalBaseType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >);

      AngularCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      AngularCharacteristicNominalBaseType (const AngularCharacteristicNominalBaseType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual AngularCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      AngularCharacteristicNominalBaseType&
      operator= (const AngularCharacteristicNominalBaseType& x);

      virtual 
      ~AngularCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAngularCharacteristicNominalType: public ::xsd::qif30::AngularCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedAngularCharacteristicNominalType ();

      UserDefinedAngularCharacteristicNominalType (const id_type&,
                                                   const CharacteristicDefinitionId_type&);

      UserDefinedAngularCharacteristicNominalType (const id_type&,
                                                   ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedAngularCharacteristicNominalType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      UserDefinedAngularCharacteristicNominalType (const UserDefinedAngularCharacteristicNominalType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual UserDefinedAngularCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedAngularCharacteristicNominalType&
      operator= (const UserDefinedAngularCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedAngularCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL AngularCharacteristicMeasurementBaseType: public ::xsd::qif30::DimensionalCharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredAngularValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredAngularValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredAngularValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      AngularCharacteristicMeasurementBaseType ();

      AngularCharacteristicMeasurementBaseType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      AngularCharacteristicMeasurementBaseType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      AngularCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      AngularCharacteristicMeasurementBaseType (const AngularCharacteristicMeasurementBaseType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual AngularCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      AngularCharacteristicMeasurementBaseType&
      operator= (const AngularCharacteristicMeasurementBaseType& x);

      virtual 
      ~AngularCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAngularCharacteristicMeasurementType: public ::xsd::qif30::AngularCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedAngularCharacteristicMeasurementType ();

      UserDefinedAngularCharacteristicMeasurementType (const id_type&,
                                                       const Status_type&,
                                                       const CharacteristicItemId_type&);

      UserDefinedAngularCharacteristicMeasurementType (const id_type&,
                                                       ::std::unique_ptr< Status_type >,
                                                       ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedAngularCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      UserDefinedAngularCharacteristicMeasurementType (const UserDefinedAngularCharacteristicMeasurementType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual UserDefinedAngularCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedAngularCharacteristicMeasurementType&
      operator= (const UserDefinedAngularCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedAngularCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL AngularCharacteristicItemBaseType: public ::xsd::qif30::DimensionalCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      AngularCharacteristicItemBaseType ();

      AngularCharacteristicItemBaseType (const id_type&,
                                         const CharacteristicNominalId_type&);

      AngularCharacteristicItemBaseType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      AngularCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      AngularCharacteristicItemBaseType (const AngularCharacteristicItemBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual AngularCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      AngularCharacteristicItemBaseType&
      operator= (const AngularCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~AngularCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedAngularCharacteristicItemType: public ::xsd::qif30::AngularCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedAngularCharacteristicItemType ();

      UserDefinedAngularCharacteristicItemType (const id_type&,
                                                const CharacteristicNominalId_type&);

      UserDefinedAngularCharacteristicItemType (const id_type&,
                                                ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedAngularCharacteristicItemType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      UserDefinedAngularCharacteristicItemType (const UserDefinedAngularCharacteristicItemType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual UserDefinedAngularCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedAngularCharacteristicItemType&
      operator= (const UserDefinedAngularCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedAngularCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL TemperatureCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::TemperatureToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      TemperatureCharacteristicDefinitionBaseType ();

      TemperatureCharacteristicDefinitionBaseType (const id_type&);

      TemperatureCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      TemperatureCharacteristicDefinitionBaseType (const TemperatureCharacteristicDefinitionBaseType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual TemperatureCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      TemperatureCharacteristicDefinitionBaseType&
      operator= (const TemperatureCharacteristicDefinitionBaseType& x);

      virtual 
      ~TemperatureCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL TemperatureCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::TemperatureValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      TemperatureCharacteristicNominalBaseType ();

      TemperatureCharacteristicNominalBaseType (const id_type&,
                                                const CharacteristicDefinitionId_type&);

      TemperatureCharacteristicNominalBaseType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >);

      TemperatureCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      TemperatureCharacteristicNominalBaseType (const TemperatureCharacteristicNominalBaseType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual TemperatureCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      TemperatureCharacteristicNominalBaseType&
      operator= (const TemperatureCharacteristicNominalBaseType& x);

      virtual 
      ~TemperatureCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL TemperatureCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredTemperatureValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredTemperatureValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredTemperatureValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      TemperatureCharacteristicMeasurementBaseType ();

      TemperatureCharacteristicMeasurementBaseType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      TemperatureCharacteristicMeasurementBaseType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      TemperatureCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      TemperatureCharacteristicMeasurementBaseType (const TemperatureCharacteristicMeasurementBaseType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual TemperatureCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      TemperatureCharacteristicMeasurementBaseType&
      operator= (const TemperatureCharacteristicMeasurementBaseType& x);

      virtual 
      ~TemperatureCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL TemperatureCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      TemperatureCharacteristicItemBaseType ();

      TemperatureCharacteristicItemBaseType (const id_type&,
                                             const CharacteristicNominalId_type&);

      TemperatureCharacteristicItemBaseType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      TemperatureCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      TemperatureCharacteristicItemBaseType (const TemperatureCharacteristicItemBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual TemperatureCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      TemperatureCharacteristicItemBaseType&
      operator= (const TemperatureCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~TemperatureCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedTemperatureCharacteristicDefinitionType: public ::xsd::qif30::TemperatureCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedTemperatureCharacteristicDefinitionType ();

      UserDefinedTemperatureCharacteristicDefinitionType (const id_type&,
                                                          const WhatToMeasure_type&);

      UserDefinedTemperatureCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      UserDefinedTemperatureCharacteristicDefinitionType (const UserDefinedTemperatureCharacteristicDefinitionType& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      virtual UserDefinedTemperatureCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedTemperatureCharacteristicDefinitionType&
      operator= (const UserDefinedTemperatureCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedTemperatureCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL UserDefinedTemperatureCharacteristicNominalType: public ::xsd::qif30::TemperatureCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedTemperatureCharacteristicNominalType ();

      UserDefinedTemperatureCharacteristicNominalType (const id_type&,
                                                       const CharacteristicDefinitionId_type&);

      UserDefinedTemperatureCharacteristicNominalType (const id_type&,
                                                       ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedTemperatureCharacteristicNominalType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      UserDefinedTemperatureCharacteristicNominalType (const UserDefinedTemperatureCharacteristicNominalType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual UserDefinedTemperatureCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedTemperatureCharacteristicNominalType&
      operator= (const UserDefinedTemperatureCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedTemperatureCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedTemperatureCharacteristicMeasurementType: public ::xsd::qif30::TemperatureCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedTemperatureCharacteristicMeasurementType ();

      UserDefinedTemperatureCharacteristicMeasurementType (const id_type&,
                                                           const Status_type&,
                                                           const CharacteristicItemId_type&);

      UserDefinedTemperatureCharacteristicMeasurementType (const id_type&,
                                                           ::std::unique_ptr< Status_type >,
                                                           ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedTemperatureCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

      UserDefinedTemperatureCharacteristicMeasurementType (const UserDefinedTemperatureCharacteristicMeasurementType& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

      virtual UserDefinedTemperatureCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedTemperatureCharacteristicMeasurementType&
      operator= (const UserDefinedTemperatureCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedTemperatureCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedTemperatureCharacteristicItemType: public ::xsd::qif30::TemperatureCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedTemperatureCharacteristicItemType ();

      UserDefinedTemperatureCharacteristicItemType (const id_type&,
                                                    const CharacteristicNominalId_type&);

      UserDefinedTemperatureCharacteristicItemType (const id_type&,
                                                    ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedTemperatureCharacteristicItemType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedTemperatureCharacteristicItemType (const UserDefinedTemperatureCharacteristicItemType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedTemperatureCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedTemperatureCharacteristicItemType&
      operator= (const UserDefinedTemperatureCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedTemperatureCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL AreaCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::AreaToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      AreaCharacteristicDefinitionBaseType ();

      AreaCharacteristicDefinitionBaseType (const id_type&);

      AreaCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      AreaCharacteristicDefinitionBaseType (const AreaCharacteristicDefinitionBaseType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual AreaCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      AreaCharacteristicDefinitionBaseType&
      operator= (const AreaCharacteristicDefinitionBaseType& x);

      virtual 
      ~AreaCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL AreaCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::AreaValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      AreaCharacteristicNominalBaseType ();

      AreaCharacteristicNominalBaseType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      AreaCharacteristicNominalBaseType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      AreaCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      AreaCharacteristicNominalBaseType (const AreaCharacteristicNominalBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual AreaCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      AreaCharacteristicNominalBaseType&
      operator= (const AreaCharacteristicNominalBaseType& x);

      virtual 
      ~AreaCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL AreaCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredAreaValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredAreaValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredAreaValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      AreaCharacteristicMeasurementBaseType ();

      AreaCharacteristicMeasurementBaseType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      AreaCharacteristicMeasurementBaseType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      AreaCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      AreaCharacteristicMeasurementBaseType (const AreaCharacteristicMeasurementBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual AreaCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      AreaCharacteristicMeasurementBaseType&
      operator= (const AreaCharacteristicMeasurementBaseType& x);

      virtual 
      ~AreaCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL AreaCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      AreaCharacteristicItemBaseType ();

      AreaCharacteristicItemBaseType (const id_type&,
                                      const CharacteristicNominalId_type&);

      AreaCharacteristicItemBaseType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      AreaCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      AreaCharacteristicItemBaseType (const AreaCharacteristicItemBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual AreaCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      AreaCharacteristicItemBaseType&
      operator= (const AreaCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~AreaCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedAreaCharacteristicDefinitionType: public ::xsd::qif30::AreaCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedAreaCharacteristicDefinitionType ();

      UserDefinedAreaCharacteristicDefinitionType (const id_type&,
                                                   const WhatToMeasure_type&);

      UserDefinedAreaCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      UserDefinedAreaCharacteristicDefinitionType (const UserDefinedAreaCharacteristicDefinitionType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual UserDefinedAreaCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAreaCharacteristicDefinitionType&
      operator= (const UserDefinedAreaCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedAreaCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAreaCharacteristicNominalType: public ::xsd::qif30::AreaCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedAreaCharacteristicNominalType ();

      UserDefinedAreaCharacteristicNominalType (const id_type&,
                                                const CharacteristicDefinitionId_type&);

      UserDefinedAreaCharacteristicNominalType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedAreaCharacteristicNominalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      UserDefinedAreaCharacteristicNominalType (const UserDefinedAreaCharacteristicNominalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual UserDefinedAreaCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedAreaCharacteristicNominalType&
      operator= (const UserDefinedAreaCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedAreaCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedAreaCharacteristicMeasurementType: public ::xsd::qif30::AreaCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedAreaCharacteristicMeasurementType ();

      UserDefinedAreaCharacteristicMeasurementType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      UserDefinedAreaCharacteristicMeasurementType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedAreaCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedAreaCharacteristicMeasurementType (const UserDefinedAreaCharacteristicMeasurementType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedAreaCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedAreaCharacteristicMeasurementType&
      operator= (const UserDefinedAreaCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedAreaCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedAreaCharacteristicItemType: public ::xsd::qif30::AreaCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedAreaCharacteristicItemType ();

      UserDefinedAreaCharacteristicItemType (const id_type&,
                                             const CharacteristicNominalId_type&);

      UserDefinedAreaCharacteristicItemType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedAreaCharacteristicItemType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      UserDefinedAreaCharacteristicItemType (const UserDefinedAreaCharacteristicItemType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual UserDefinedAreaCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedAreaCharacteristicItemType&
      operator= (const UserDefinedAreaCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedAreaCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ForceCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::ForceToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      ForceCharacteristicDefinitionBaseType ();

      ForceCharacteristicDefinitionBaseType (const id_type&);

      ForceCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ForceCharacteristicDefinitionBaseType (const ForceCharacteristicDefinitionBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ForceCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ForceCharacteristicDefinitionBaseType&
      operator= (const ForceCharacteristicDefinitionBaseType& x);

      virtual 
      ~ForceCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL ForceCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::ForceValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      ForceCharacteristicNominalBaseType ();

      ForceCharacteristicNominalBaseType (const id_type&,
                                          const CharacteristicDefinitionId_type&);

      ForceCharacteristicNominalBaseType (const id_type&,
                                          ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ForceCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ForceCharacteristicNominalBaseType (const ForceCharacteristicNominalBaseType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ForceCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ForceCharacteristicNominalBaseType&
      operator= (const ForceCharacteristicNominalBaseType& x);

      virtual 
      ~ForceCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL ForceCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredForceValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredForceValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredForceValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      ForceCharacteristicMeasurementBaseType ();

      ForceCharacteristicMeasurementBaseType (const id_type&,
                                              const Status_type&,
                                              const CharacteristicItemId_type&);

      ForceCharacteristicMeasurementBaseType (const id_type&,
                                              ::std::unique_ptr< Status_type >,
                                              ::std::unique_ptr< CharacteristicItemId_type >);

      ForceCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ForceCharacteristicMeasurementBaseType (const ForceCharacteristicMeasurementBaseType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ForceCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ForceCharacteristicMeasurementBaseType&
      operator= (const ForceCharacteristicMeasurementBaseType& x);

      virtual 
      ~ForceCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL ForceCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ForceCharacteristicItemBaseType ();

      ForceCharacteristicItemBaseType (const id_type&,
                                       const CharacteristicNominalId_type&);

      ForceCharacteristicItemBaseType (const id_type&,
                                       ::std::unique_ptr< CharacteristicNominalId_type >);

      ForceCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ForceCharacteristicItemBaseType (const ForceCharacteristicItemBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ForceCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      ForceCharacteristicItemBaseType&
      operator= (const ForceCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~ForceCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedForceCharacteristicDefinitionType: public ::xsd::qif30::ForceCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedForceCharacteristicDefinitionType ();

      UserDefinedForceCharacteristicDefinitionType (const id_type&,
                                                    const WhatToMeasure_type&);

      UserDefinedForceCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedForceCharacteristicDefinitionType (const UserDefinedForceCharacteristicDefinitionType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedForceCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedForceCharacteristicDefinitionType&
      operator= (const UserDefinedForceCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedForceCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL UserDefinedForceCharacteristicNominalType: public ::xsd::qif30::ForceCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedForceCharacteristicNominalType ();

      UserDefinedForceCharacteristicNominalType (const id_type&,
                                                 const CharacteristicDefinitionId_type&);

      UserDefinedForceCharacteristicNominalType (const id_type&,
                                                 ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedForceCharacteristicNominalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      UserDefinedForceCharacteristicNominalType (const UserDefinedForceCharacteristicNominalType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual UserDefinedForceCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedForceCharacteristicNominalType&
      operator= (const UserDefinedForceCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedForceCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedForceCharacteristicMeasurementType: public ::xsd::qif30::ForceCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedForceCharacteristicMeasurementType ();

      UserDefinedForceCharacteristicMeasurementType (const id_type&,
                                                     const Status_type&,
                                                     const CharacteristicItemId_type&);

      UserDefinedForceCharacteristicMeasurementType (const id_type&,
                                                     ::std::unique_ptr< Status_type >,
                                                     ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedForceCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      UserDefinedForceCharacteristicMeasurementType (const UserDefinedForceCharacteristicMeasurementType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual UserDefinedForceCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedForceCharacteristicMeasurementType&
      operator= (const UserDefinedForceCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedForceCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedForceCharacteristicItemType: public ::xsd::qif30::ForceCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedForceCharacteristicItemType ();

      UserDefinedForceCharacteristicItemType (const id_type&,
                                              const CharacteristicNominalId_type&);

      UserDefinedForceCharacteristicItemType (const id_type&,
                                              ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedForceCharacteristicItemType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      UserDefinedForceCharacteristicItemType (const UserDefinedForceCharacteristicItemType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual UserDefinedForceCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedForceCharacteristicItemType&
      operator= (const UserDefinedForceCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedForceCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL MassCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::MassToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      MassCharacteristicDefinitionBaseType ();

      MassCharacteristicDefinitionBaseType (const id_type&);

      MassCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      MassCharacteristicDefinitionBaseType (const MassCharacteristicDefinitionBaseType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual MassCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MassCharacteristicDefinitionBaseType&
      operator= (const MassCharacteristicDefinitionBaseType& x);

      virtual 
      ~MassCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL MassCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::MassValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      MassCharacteristicNominalBaseType ();

      MassCharacteristicNominalBaseType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      MassCharacteristicNominalBaseType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      MassCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      MassCharacteristicNominalBaseType (const MassCharacteristicNominalBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual MassCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MassCharacteristicNominalBaseType&
      operator= (const MassCharacteristicNominalBaseType& x);

      virtual 
      ~MassCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL MassCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredMassValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredMassValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredMassValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      MassCharacteristicMeasurementBaseType ();

      MassCharacteristicMeasurementBaseType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      MassCharacteristicMeasurementBaseType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      MassCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      MassCharacteristicMeasurementBaseType (const MassCharacteristicMeasurementBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual MassCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MassCharacteristicMeasurementBaseType&
      operator= (const MassCharacteristicMeasurementBaseType& x);

      virtual 
      ~MassCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL MassCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      MassCharacteristicItemBaseType ();

      MassCharacteristicItemBaseType (const id_type&,
                                      const CharacteristicNominalId_type&);

      MassCharacteristicItemBaseType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      MassCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      MassCharacteristicItemBaseType (const MassCharacteristicItemBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual MassCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      MassCharacteristicItemBaseType&
      operator= (const MassCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~MassCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedMassCharacteristicDefinitionType: public ::xsd::qif30::MassCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedMassCharacteristicDefinitionType ();

      UserDefinedMassCharacteristicDefinitionType (const id_type&,
                                                   const WhatToMeasure_type&);

      UserDefinedMassCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      UserDefinedMassCharacteristicDefinitionType (const UserDefinedMassCharacteristicDefinitionType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual UserDefinedMassCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedMassCharacteristicDefinitionType&
      operator= (const UserDefinedMassCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedMassCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL UserDefinedMassCharacteristicNominalType: public ::xsd::qif30::MassCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedMassCharacteristicNominalType ();

      UserDefinedMassCharacteristicNominalType (const id_type&,
                                                const CharacteristicDefinitionId_type&);

      UserDefinedMassCharacteristicNominalType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedMassCharacteristicNominalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      UserDefinedMassCharacteristicNominalType (const UserDefinedMassCharacteristicNominalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual UserDefinedMassCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedMassCharacteristicNominalType&
      operator= (const UserDefinedMassCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedMassCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedMassCharacteristicMeasurementType: public ::xsd::qif30::MassCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedMassCharacteristicMeasurementType ();

      UserDefinedMassCharacteristicMeasurementType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      UserDefinedMassCharacteristicMeasurementType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedMassCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedMassCharacteristicMeasurementType (const UserDefinedMassCharacteristicMeasurementType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedMassCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedMassCharacteristicMeasurementType&
      operator= (const UserDefinedMassCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedMassCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedMassCharacteristicItemType: public ::xsd::qif30::MassCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedMassCharacteristicItemType ();

      UserDefinedMassCharacteristicItemType (const id_type&,
                                             const CharacteristicNominalId_type&);

      UserDefinedMassCharacteristicItemType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedMassCharacteristicItemType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      UserDefinedMassCharacteristicItemType (const UserDefinedMassCharacteristicItemType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual UserDefinedMassCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedMassCharacteristicItemType&
      operator= (const UserDefinedMassCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedMassCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL PressureCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::PressureToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      PressureCharacteristicDefinitionBaseType ();

      PressureCharacteristicDefinitionBaseType (const id_type&);

      PressureCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      PressureCharacteristicDefinitionBaseType (const PressureCharacteristicDefinitionBaseType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual PressureCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      PressureCharacteristicDefinitionBaseType&
      operator= (const PressureCharacteristicDefinitionBaseType& x);

      virtual 
      ~PressureCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL PressureCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::PressureValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      PressureCharacteristicNominalBaseType ();

      PressureCharacteristicNominalBaseType (const id_type&,
                                             const CharacteristicDefinitionId_type&);

      PressureCharacteristicNominalBaseType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >);

      PressureCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      PressureCharacteristicNominalBaseType (const PressureCharacteristicNominalBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual PressureCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      PressureCharacteristicNominalBaseType&
      operator= (const PressureCharacteristicNominalBaseType& x);

      virtual 
      ~PressureCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL PressureCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredPressureValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredPressureValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredPressureValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      PressureCharacteristicMeasurementBaseType ();

      PressureCharacteristicMeasurementBaseType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&);

      PressureCharacteristicMeasurementBaseType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >);

      PressureCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PressureCharacteristicMeasurementBaseType (const PressureCharacteristicMeasurementBaseType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual PressureCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      PressureCharacteristicMeasurementBaseType&
      operator= (const PressureCharacteristicMeasurementBaseType& x);

      virtual 
      ~PressureCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL PressureCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      PressureCharacteristicItemBaseType ();

      PressureCharacteristicItemBaseType (const id_type&,
                                          const CharacteristicNominalId_type&);

      PressureCharacteristicItemBaseType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >);

      PressureCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PressureCharacteristicItemBaseType (const PressureCharacteristicItemBaseType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual PressureCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PressureCharacteristicItemBaseType&
      operator= (const PressureCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~PressureCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedPressureCharacteristicDefinitionType: public ::xsd::qif30::PressureCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedPressureCharacteristicDefinitionType ();

      UserDefinedPressureCharacteristicDefinitionType (const id_type&,
                                                       const WhatToMeasure_type&);

      UserDefinedPressureCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      UserDefinedPressureCharacteristicDefinitionType (const UserDefinedPressureCharacteristicDefinitionType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual UserDefinedPressureCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedPressureCharacteristicDefinitionType&
      operator= (const UserDefinedPressureCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedPressureCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL UserDefinedPressureCharacteristicNominalType: public ::xsd::qif30::PressureCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedPressureCharacteristicNominalType ();

      UserDefinedPressureCharacteristicNominalType (const id_type&,
                                                    const CharacteristicDefinitionId_type&);

      UserDefinedPressureCharacteristicNominalType (const id_type&,
                                                    ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedPressureCharacteristicNominalType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedPressureCharacteristicNominalType (const UserDefinedPressureCharacteristicNominalType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedPressureCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedPressureCharacteristicNominalType&
      operator= (const UserDefinedPressureCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedPressureCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedPressureCharacteristicMeasurementType: public ::xsd::qif30::PressureCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedPressureCharacteristicMeasurementType ();

      UserDefinedPressureCharacteristicMeasurementType (const id_type&,
                                                        const Status_type&,
                                                        const CharacteristicItemId_type&);

      UserDefinedPressureCharacteristicMeasurementType (const id_type&,
                                                        ::std::unique_ptr< Status_type >,
                                                        ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedPressureCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      UserDefinedPressureCharacteristicMeasurementType (const UserDefinedPressureCharacteristicMeasurementType& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      virtual UserDefinedPressureCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedPressureCharacteristicMeasurementType&
      operator= (const UserDefinedPressureCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedPressureCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedPressureCharacteristicItemType: public ::xsd::qif30::PressureCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedPressureCharacteristicItemType ();

      UserDefinedPressureCharacteristicItemType (const id_type&,
                                                 const CharacteristicNominalId_type&);

      UserDefinedPressureCharacteristicItemType (const id_type&,
                                                 ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedPressureCharacteristicItemType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      UserDefinedPressureCharacteristicItemType (const UserDefinedPressureCharacteristicItemType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual UserDefinedPressureCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedPressureCharacteristicItemType&
      operator= (const UserDefinedPressureCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedPressureCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL SpeedCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::SpeedToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      SpeedCharacteristicDefinitionBaseType ();

      SpeedCharacteristicDefinitionBaseType (const id_type&);

      SpeedCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      SpeedCharacteristicDefinitionBaseType (const SpeedCharacteristicDefinitionBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual SpeedCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      SpeedCharacteristicDefinitionBaseType&
      operator= (const SpeedCharacteristicDefinitionBaseType& x);

      virtual 
      ~SpeedCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL SpeedCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::SpeedValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      SpeedCharacteristicNominalBaseType ();

      SpeedCharacteristicNominalBaseType (const id_type&,
                                          const CharacteristicDefinitionId_type&);

      SpeedCharacteristicNominalBaseType (const id_type&,
                                          ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SpeedCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SpeedCharacteristicNominalBaseType (const SpeedCharacteristicNominalBaseType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SpeedCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      SpeedCharacteristicNominalBaseType&
      operator= (const SpeedCharacteristicNominalBaseType& x);

      virtual 
      ~SpeedCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL SpeedCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredSpeedValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredSpeedValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredSpeedValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      SpeedCharacteristicMeasurementBaseType ();

      SpeedCharacteristicMeasurementBaseType (const id_type&,
                                              const Status_type&,
                                              const CharacteristicItemId_type&);

      SpeedCharacteristicMeasurementBaseType (const id_type&,
                                              ::std::unique_ptr< Status_type >,
                                              ::std::unique_ptr< CharacteristicItemId_type >);

      SpeedCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      SpeedCharacteristicMeasurementBaseType (const SpeedCharacteristicMeasurementBaseType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual SpeedCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      SpeedCharacteristicMeasurementBaseType&
      operator= (const SpeedCharacteristicMeasurementBaseType& x);

      virtual 
      ~SpeedCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL SpeedCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SpeedCharacteristicItemBaseType ();

      SpeedCharacteristicItemBaseType (const id_type&,
                                       const CharacteristicNominalId_type&);

      SpeedCharacteristicItemBaseType (const id_type&,
                                       ::std::unique_ptr< CharacteristicNominalId_type >);

      SpeedCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SpeedCharacteristicItemBaseType (const SpeedCharacteristicItemBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SpeedCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SpeedCharacteristicItemBaseType&
      operator= (const SpeedCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~SpeedCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedSpeedCharacteristicDefinitionType: public ::xsd::qif30::SpeedCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedSpeedCharacteristicDefinitionType ();

      UserDefinedSpeedCharacteristicDefinitionType (const id_type&,
                                                    const WhatToMeasure_type&);

      UserDefinedSpeedCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedSpeedCharacteristicDefinitionType (const UserDefinedSpeedCharacteristicDefinitionType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedSpeedCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedSpeedCharacteristicDefinitionType&
      operator= (const UserDefinedSpeedCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedSpeedCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL UserDefinedSpeedCharacteristicNominalType: public ::xsd::qif30::SpeedCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedSpeedCharacteristicNominalType ();

      UserDefinedSpeedCharacteristicNominalType (const id_type&,
                                                 const CharacteristicDefinitionId_type&);

      UserDefinedSpeedCharacteristicNominalType (const id_type&,
                                                 ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedSpeedCharacteristicNominalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      UserDefinedSpeedCharacteristicNominalType (const UserDefinedSpeedCharacteristicNominalType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual UserDefinedSpeedCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedSpeedCharacteristicNominalType&
      operator= (const UserDefinedSpeedCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedSpeedCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedSpeedCharacteristicMeasurementType: public ::xsd::qif30::SpeedCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedSpeedCharacteristicMeasurementType ();

      UserDefinedSpeedCharacteristicMeasurementType (const id_type&,
                                                     const Status_type&,
                                                     const CharacteristicItemId_type&);

      UserDefinedSpeedCharacteristicMeasurementType (const id_type&,
                                                     ::std::unique_ptr< Status_type >,
                                                     ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedSpeedCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      UserDefinedSpeedCharacteristicMeasurementType (const UserDefinedSpeedCharacteristicMeasurementType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual UserDefinedSpeedCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedSpeedCharacteristicMeasurementType&
      operator= (const UserDefinedSpeedCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedSpeedCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedSpeedCharacteristicItemType: public ::xsd::qif30::SpeedCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedSpeedCharacteristicItemType ();

      UserDefinedSpeedCharacteristicItemType (const id_type&,
                                              const CharacteristicNominalId_type&);

      UserDefinedSpeedCharacteristicItemType (const id_type&,
                                              ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedSpeedCharacteristicItemType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      UserDefinedSpeedCharacteristicItemType (const UserDefinedSpeedCharacteristicItemType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual UserDefinedSpeedCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedSpeedCharacteristicItemType&
      operator= (const UserDefinedSpeedCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedSpeedCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL TimeCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::TimeToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      TimeCharacteristicDefinitionBaseType ();

      TimeCharacteristicDefinitionBaseType (const id_type&);

      TimeCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      TimeCharacteristicDefinitionBaseType (const TimeCharacteristicDefinitionBaseType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual TimeCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      TimeCharacteristicDefinitionBaseType&
      operator= (const TimeCharacteristicDefinitionBaseType& x);

      virtual 
      ~TimeCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL TimeCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::TimeValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      TimeCharacteristicNominalBaseType ();

      TimeCharacteristicNominalBaseType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      TimeCharacteristicNominalBaseType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      TimeCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      TimeCharacteristicNominalBaseType (const TimeCharacteristicNominalBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual TimeCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      TimeCharacteristicNominalBaseType&
      operator= (const TimeCharacteristicNominalBaseType& x);

      virtual 
      ~TimeCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL TimeCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredTimeValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredTimeValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredTimeValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      TimeCharacteristicMeasurementBaseType ();

      TimeCharacteristicMeasurementBaseType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      TimeCharacteristicMeasurementBaseType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      TimeCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      TimeCharacteristicMeasurementBaseType (const TimeCharacteristicMeasurementBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual TimeCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      TimeCharacteristicMeasurementBaseType&
      operator= (const TimeCharacteristicMeasurementBaseType& x);

      virtual 
      ~TimeCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL TimeCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      TimeCharacteristicItemBaseType ();

      TimeCharacteristicItemBaseType (const id_type&,
                                      const CharacteristicNominalId_type&);

      TimeCharacteristicItemBaseType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      TimeCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      TimeCharacteristicItemBaseType (const TimeCharacteristicItemBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual TimeCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      TimeCharacteristicItemBaseType&
      operator= (const TimeCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~TimeCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedTimeCharacteristicDefinitionType: public ::xsd::qif30::TimeCharacteristicDefinitionBaseType
    {
      public:
      // WhatToMeasure
      //
      typedef ::xml_schema::string WhatToMeasure_type;
      typedef ::xsd::cxx::tree::traits< WhatToMeasure_type, wchar_t > WhatToMeasure_traits;

      const WhatToMeasure_type&
      WhatToMeasure () const;

      WhatToMeasure_type&
      WhatToMeasure ();

      void
      WhatToMeasure (const WhatToMeasure_type& x);

      void
      WhatToMeasure (::std::unique_ptr< WhatToMeasure_type > p);

      // Constructors.
      //
      UserDefinedTimeCharacteristicDefinitionType ();

      UserDefinedTimeCharacteristicDefinitionType (const id_type&,
                                                   const WhatToMeasure_type&);

      UserDefinedTimeCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      UserDefinedTimeCharacteristicDefinitionType (const UserDefinedTimeCharacteristicDefinitionType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual UserDefinedTimeCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedTimeCharacteristicDefinitionType&
      operator= (const UserDefinedTimeCharacteristicDefinitionType& x);

      virtual 
      ~UserDefinedTimeCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatToMeasure_type > WhatToMeasure_;
    };

    class QIF30_SYMBOL_DECL UserDefinedTimeCharacteristicNominalType: public ::xsd::qif30::TimeCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedTimeCharacteristicNominalType ();

      UserDefinedTimeCharacteristicNominalType (const id_type&,
                                                const CharacteristicDefinitionId_type&);

      UserDefinedTimeCharacteristicNominalType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >);

      UserDefinedTimeCharacteristicNominalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      UserDefinedTimeCharacteristicNominalType (const UserDefinedTimeCharacteristicNominalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual UserDefinedTimeCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedTimeCharacteristicNominalType&
      operator= (const UserDefinedTimeCharacteristicNominalType&) = default;
#endif

      virtual 
      ~UserDefinedTimeCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedTimeCharacteristicMeasurementType: public ::xsd::qif30::TimeCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedTimeCharacteristicMeasurementType ();

      UserDefinedTimeCharacteristicMeasurementType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      UserDefinedTimeCharacteristicMeasurementType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedTimeCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedTimeCharacteristicMeasurementType (const UserDefinedTimeCharacteristicMeasurementType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedTimeCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedTimeCharacteristicMeasurementType&
      operator= (const UserDefinedTimeCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~UserDefinedTimeCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedTimeCharacteristicItemType: public ::xsd::qif30::TimeCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedTimeCharacteristicItemType ();

      UserDefinedTimeCharacteristicItemType (const id_type&,
                                             const CharacteristicNominalId_type&);

      UserDefinedTimeCharacteristicItemType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedTimeCharacteristicItemType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      UserDefinedTimeCharacteristicItemType (const UserDefinedTimeCharacteristicItemType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual UserDefinedTimeCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedTimeCharacteristicItemType&
      operator= (const UserDefinedTimeCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedTimeCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedUnitCharacteristicDefinitionType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedUnitCharacteristicDefinitionType ();

      UserDefinedUnitCharacteristicDefinitionType (const id_type&);

      UserDefinedUnitCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      UserDefinedUnitCharacteristicDefinitionType (const UserDefinedUnitCharacteristicDefinitionType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual UserDefinedUnitCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedUnitCharacteristicDefinitionType&
      operator= (const UserDefinedUnitCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~UserDefinedUnitCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL UserDefinedUnitCharacteristicNominalType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType TargetValue_type;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_type&
      TargetValue () const;

      TargetValue_type&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::UserDefinedUnitValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      UserDefinedUnitCharacteristicNominalType ();

      UserDefinedUnitCharacteristicNominalType (const id_type&,
                                                const CharacteristicDefinitionId_type&,
                                                const TargetValue_type&,
                                                const DefinedAsLimit_type&);

      UserDefinedUnitCharacteristicNominalType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                                ::std::unique_ptr< TargetValue_type >,
                                                const DefinedAsLimit_type&);

      UserDefinedUnitCharacteristicNominalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      UserDefinedUnitCharacteristicNominalType (const UserDefinedUnitCharacteristicNominalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual UserDefinedUnitCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitCharacteristicNominalType&
      operator= (const UserDefinedUnitCharacteristicNominalType& x);

      virtual 
      ~UserDefinedUnitCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TargetValue_type > TargetValue_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class QIF30_SYMBOL_DECL UserDefinedUnitCharacteristicMeasurementType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredUserDefinedUnitValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredUserDefinedUnitValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredUserDefinedUnitValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      UserDefinedUnitCharacteristicMeasurementType ();

      UserDefinedUnitCharacteristicMeasurementType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      UserDefinedUnitCharacteristicMeasurementType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      UserDefinedUnitCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedUnitCharacteristicMeasurementType (const UserDefinedUnitCharacteristicMeasurementType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedUnitCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitCharacteristicMeasurementType&
      operator= (const UserDefinedUnitCharacteristicMeasurementType& x);

      virtual 
      ~UserDefinedUnitCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL UserDefinedUnitCharacteristicItemType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      UserDefinedUnitCharacteristicItemType ();

      UserDefinedUnitCharacteristicItemType (const id_type&,
                                             const CharacteristicNominalId_type&);

      UserDefinedUnitCharacteristicItemType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      UserDefinedUnitCharacteristicItemType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      UserDefinedUnitCharacteristicItemType (const UserDefinedUnitCharacteristicItemType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual UserDefinedUnitCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDefinedUnitCharacteristicItemType&
      operator= (const UserDefinedUnitCharacteristicItemType&) = default;
#endif

      virtual 
      ~UserDefinedUnitCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL CompositeSegmentDefinitionBaseType: public ::xml_schema::type
    {
      public:
      // DatumReferenceFrameId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumReferenceFrameId_type;
      typedef ::xsd::cxx::tree::optional< DatumReferenceFrameId_type > DatumReferenceFrameId_optional;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameId_type, wchar_t > DatumReferenceFrameId_traits;

      const DatumReferenceFrameId_optional&
      DatumReferenceFrameId () const;

      DatumReferenceFrameId_optional&
      DatumReferenceFrameId ();

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_type& x);

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_optional& x);

      void
      DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > p);

      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // CharacteristicDesignator
      //
      typedef ::xsd::qif30::CharacteristicDesignatorType CharacteristicDesignator_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicDesignator_type > CharacteristicDesignator_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicDesignator_type, wchar_t > CharacteristicDesignator_traits;

      const CharacteristicDesignator_optional&
      CharacteristicDesignator () const;

      CharacteristicDesignator_optional&
      CharacteristicDesignator ();

      void
      CharacteristicDesignator (const CharacteristicDesignator_type& x);

      void
      CharacteristicDesignator (const CharacteristicDesignator_optional& x);

      void
      CharacteristicDesignator (::std::unique_ptr< CharacteristicDesignator_type > p);

      // Constructors.
      //
      CompositeSegmentDefinitionBaseType ();

      CompositeSegmentDefinitionBaseType (const ToleranceValue_type&);

      CompositeSegmentDefinitionBaseType (::std::unique_ptr< ToleranceValue_type >);

      CompositeSegmentDefinitionBaseType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CompositeSegmentDefinitionBaseType (const CompositeSegmentDefinitionBaseType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual CompositeSegmentDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CompositeSegmentDefinitionBaseType&
      operator= (const CompositeSegmentDefinitionBaseType& x);

      virtual 
      ~CompositeSegmentDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DatumReferenceFrameId_optional DatumReferenceFrameId_;
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      CharacteristicDesignator_optional CharacteristicDesignator_;
    };

    class QIF30_SYMBOL_DECL CompositeSegmentMeasurementBaseType: public ::xml_schema::type
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Status
      //
      typedef ::xsd::qif30::CharacteristicStatusType Status_type;
      typedef ::xsd::cxx::tree::traits< Status_type, wchar_t > Status_traits;

      const Status_type&
      Status () const;

      Status_type&
      Status ();

      void
      Status (const Status_type& x);

      void
      Status (::std::unique_ptr< Status_type > p);

      // DRFTransformActualId
      //
      typedef ::xsd::qif30::QIFReferenceType DRFTransformActualId_type;
      typedef ::xsd::cxx::tree::optional< DRFTransformActualId_type > DRFTransformActualId_optional;
      typedef ::xsd::cxx::tree::traits< DRFTransformActualId_type, wchar_t > DRFTransformActualId_traits;

      const DRFTransformActualId_optional&
      DRFTransformActualId () const;

      DRFTransformActualId_optional&
      DRFTransformActualId ();

      void
      DRFTransformActualId (const DRFTransformActualId_type& x);

      void
      DRFTransformActualId (const DRFTransformActualId_optional& x);

      void
      DRFTransformActualId (::std::unique_ptr< DRFTransformActualId_type > p);

      // ZoneDataSet
      //
      typedef ::xsd::qif30::ZoneDataSetType ZoneDataSet_type;
      typedef ::xsd::cxx::tree::optional< ZoneDataSet_type > ZoneDataSet_optional;
      typedef ::xsd::cxx::tree::traits< ZoneDataSet_type, wchar_t > ZoneDataSet_traits;

      const ZoneDataSet_optional&
      ZoneDataSet () const;

      ZoneDataSet_optional&
      ZoneDataSet ();

      void
      ZoneDataSet (const ZoneDataSet_type& x);

      void
      ZoneDataSet (const ZoneDataSet_optional& x);

      void
      ZoneDataSet (::std::unique_ptr< ZoneDataSet_type > p);

      // Constructors.
      //
      CompositeSegmentMeasurementBaseType ();

      CompositeSegmentMeasurementBaseType (const Status_type&);

      CompositeSegmentMeasurementBaseType (::std::unique_ptr< Status_type >);

      CompositeSegmentMeasurementBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      CompositeSegmentMeasurementBaseType (const CompositeSegmentMeasurementBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual CompositeSegmentMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CompositeSegmentMeasurementBaseType&
      operator= (const CompositeSegmentMeasurementBaseType& x);

      virtual 
      ~CompositeSegmentMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< Status_type > Status_;
      DRFTransformActualId_optional DRFTransformActualId_;
      ZoneDataSet_optional ZoneDataSet_;
    };

    class QIF30_SYMBOL_DECL CompositeSegmentPositionDefinitionType: public ::xsd::qif30::CompositeSegmentDefinitionBaseType
    {
      public:
      // MaterialCondition
      //
      typedef ::xsd::qif30::MaterialModifierEnumType MaterialCondition_type;
      typedef ::xsd::cxx::tree::traits< MaterialCondition_type, wchar_t > MaterialCondition_traits;

      const MaterialCondition_type&
      MaterialCondition () const;

      MaterialCondition_type&
      MaterialCondition ();

      void
      MaterialCondition (const MaterialCondition_type& x);

      void
      MaterialCondition (::std::unique_ptr< MaterialCondition_type > p);

      // ZoneShape
      //
      typedef ::xsd::qif30::PositionZoneShapeType ZoneShape_type;
      typedef ::xsd::cxx::tree::traits< ZoneShape_type, wchar_t > ZoneShape_traits;

      const ZoneShape_type&
      ZoneShape () const;

      ZoneShape_type&
      ZoneShape ();

      void
      ZoneShape (const ZoneShape_type& x);

      void
      ZoneShape (::std::unique_ptr< ZoneShape_type > p);

      // MaximumToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType MaximumToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< MaximumToleranceValue_type > MaximumToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< MaximumToleranceValue_type, wchar_t > MaximumToleranceValue_traits;

      const MaximumToleranceValue_optional&
      MaximumToleranceValue () const;

      MaximumToleranceValue_optional&
      MaximumToleranceValue ();

      void
      MaximumToleranceValue (const MaximumToleranceValue_type& x);

      void
      MaximumToleranceValue (const MaximumToleranceValue_optional& x);

      void
      MaximumToleranceValue (::std::unique_ptr< MaximumToleranceValue_type > p);

      // ProjectedToleranceZone
      //
      typedef ::xsd::qif30::LinearValueType ProjectedToleranceZone_type;
      typedef ::xsd::cxx::tree::optional< ProjectedToleranceZone_type > ProjectedToleranceZone_optional;
      typedef ::xsd::cxx::tree::traits< ProjectedToleranceZone_type, wchar_t > ProjectedToleranceZone_traits;

      const ProjectedToleranceZone_optional&
      ProjectedToleranceZone () const;

      ProjectedToleranceZone_optional&
      ProjectedToleranceZone ();

      void
      ProjectedToleranceZone (const ProjectedToleranceZone_type& x);

      void
      ProjectedToleranceZone (const ProjectedToleranceZone_optional& x);

      void
      ProjectedToleranceZone (::std::unique_ptr< ProjectedToleranceZone_type > p);

      // Constructors.
      //
      CompositeSegmentPositionDefinitionType ();

      CompositeSegmentPositionDefinitionType (const ToleranceValue_type&,
                                              const MaterialCondition_type&,
                                              const ZoneShape_type&);

      CompositeSegmentPositionDefinitionType (::std::unique_ptr< ToleranceValue_type >,
                                              const MaterialCondition_type&,
                                              ::std::unique_ptr< ZoneShape_type >);

      CompositeSegmentPositionDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      CompositeSegmentPositionDefinitionType (const CompositeSegmentPositionDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual CompositeSegmentPositionDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompositeSegmentPositionDefinitionType&
      operator= (const CompositeSegmentPositionDefinitionType& x);

      virtual 
      ~CompositeSegmentPositionDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MaterialCondition_type > MaterialCondition_;
      ::xsd::cxx::tree::one< ZoneShape_type > ZoneShape_;
      MaximumToleranceValue_optional MaximumToleranceValue_;
      ProjectedToleranceZone_optional ProjectedToleranceZone_;
    };

    class QIF30_SYMBOL_DECL CompositeSegmentPositionMeasurementType: public ::xsd::qif30::CompositeSegmentMeasurementBaseType
    {
      public:
      // Constructors.
      //
      CompositeSegmentPositionMeasurementType ();

      CompositeSegmentPositionMeasurementType (const Status_type&);

      CompositeSegmentPositionMeasurementType (::std::unique_ptr< Status_type >);

      CompositeSegmentPositionMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CompositeSegmentPositionMeasurementType (const CompositeSegmentPositionMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CompositeSegmentPositionMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CompositeSegmentPositionMeasurementType&
      operator= (const CompositeSegmentPositionMeasurementType&) = default;
#endif

      virtual 
      ~CompositeSegmentPositionMeasurementType ();
    };

    class QIF30_SYMBOL_DECL CompositeSegmentProfileDefinitionType: public ::xsd::qif30::CompositeSegmentDefinitionBaseType
    {
      public:
      // OuterDisposition
      //
      typedef ::xsd::qif30::LinearValueType OuterDisposition_type;
      typedef ::xsd::cxx::tree::optional< OuterDisposition_type > OuterDisposition_optional;
      typedef ::xsd::cxx::tree::traits< OuterDisposition_type, wchar_t > OuterDisposition_traits;

      const OuterDisposition_optional&
      OuterDisposition () const;

      OuterDisposition_optional&
      OuterDisposition ();

      void
      OuterDisposition (const OuterDisposition_type& x);

      void
      OuterDisposition (const OuterDisposition_optional& x);

      void
      OuterDisposition (::std::unique_ptr< OuterDisposition_type > p);

      // Constructors.
      //
      CompositeSegmentProfileDefinitionType ();

      CompositeSegmentProfileDefinitionType (const ToleranceValue_type&);

      CompositeSegmentProfileDefinitionType (::std::unique_ptr< ToleranceValue_type >);

      CompositeSegmentProfileDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CompositeSegmentProfileDefinitionType (const CompositeSegmentProfileDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual CompositeSegmentProfileDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompositeSegmentProfileDefinitionType&
      operator= (const CompositeSegmentProfileDefinitionType& x);

      virtual 
      ~CompositeSegmentProfileDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      OuterDisposition_optional OuterDisposition_;
    };

    class QIF30_SYMBOL_DECL CompositeSegmentProfileMeasurementType: public ::xsd::qif30::CompositeSegmentMeasurementBaseType
    {
      public:
      // Constructors.
      //
      CompositeSegmentProfileMeasurementType ();

      CompositeSegmentProfileMeasurementType (const Status_type&);

      CompositeSegmentProfileMeasurementType (::std::unique_ptr< Status_type >);

      CompositeSegmentProfileMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      CompositeSegmentProfileMeasurementType (const CompositeSegmentProfileMeasurementType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual CompositeSegmentProfileMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CompositeSegmentProfileMeasurementType&
      operator= (const CompositeSegmentProfileMeasurementType&) = default;
#endif

      virtual 
      ~CompositeSegmentProfileMeasurementType ();
    };

    class QIF30_SYMBOL_DECL CompositeSegmentSymmetryDefinitionType: public ::xsd::qif30::CompositeSegmentDefinitionBaseType
    {
      public:
      // Constructors.
      //
      CompositeSegmentSymmetryDefinitionType ();

      CompositeSegmentSymmetryDefinitionType (const ToleranceValue_type&);

      CompositeSegmentSymmetryDefinitionType (::std::unique_ptr< ToleranceValue_type >);

      CompositeSegmentSymmetryDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      CompositeSegmentSymmetryDefinitionType (const CompositeSegmentSymmetryDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual CompositeSegmentSymmetryDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CompositeSegmentSymmetryDefinitionType&
      operator= (const CompositeSegmentSymmetryDefinitionType&) = default;
#endif

      virtual 
      ~CompositeSegmentSymmetryDefinitionType ();
    };

    class QIF30_SYMBOL_DECL CompositeSegmentSymmetryMeasurementType: public ::xsd::qif30::CompositeSegmentMeasurementBaseType
    {
      public:
      // Constructors.
      //
      CompositeSegmentSymmetryMeasurementType ();

      CompositeSegmentSymmetryMeasurementType (const Status_type&);

      CompositeSegmentSymmetryMeasurementType (::std::unique_ptr< Status_type >);

      CompositeSegmentSymmetryMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CompositeSegmentSymmetryMeasurementType (const CompositeSegmentSymmetryMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CompositeSegmentSymmetryMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CompositeSegmentSymmetryMeasurementType&
      operator= (const CompositeSegmentSymmetryMeasurementType&) = default;
#endif

      virtual 
      ~CompositeSegmentSymmetryMeasurementType ();
    };

    class QIF30_SYMBOL_DECL OriginReferenceType: public ::xml_schema::type
    {
      public:
      // FeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType FeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalId_type > FeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalId_type, wchar_t > FeatureNominalId_traits;

      const FeatureNominalId_optional&
      FeatureNominalId () const;

      FeatureNominalId_optional&
      FeatureNominalId ();

      void
      FeatureNominalId (const FeatureNominalId_type& x);

      void
      FeatureNominalId (const FeatureNominalId_optional& x);

      void
      FeatureNominalId (::std::unique_ptr< FeatureNominalId_type > p);

      // ReferencedComponent
      //
      typedef ::xsd::qif30::ReferencedComponentEnumType ReferencedComponent_type;
      typedef ::xsd::cxx::tree::optional< ReferencedComponent_type > ReferencedComponent_optional;
      typedef ::xsd::cxx::tree::traits< ReferencedComponent_type, wchar_t > ReferencedComponent_traits;

      const ReferencedComponent_optional&
      ReferencedComponent () const;

      ReferencedComponent_optional&
      ReferencedComponent ();

      void
      ReferencedComponent (const ReferencedComponent_type& x);

      void
      ReferencedComponent (const ReferencedComponent_optional& x);

      void
      ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::optional< DatumDefinitionId_type > DatumDefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, wchar_t > DatumDefinitionId_traits;

      const DatumDefinitionId_optional&
      DatumDefinitionId () const;

      DatumDefinitionId_optional&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (const DatumDefinitionId_optional& x);

      void
      DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      OriginReferenceType ();

      OriginReferenceType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      OriginReferenceType (const OriginReferenceType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual OriginReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OriginReferenceType&
      operator= (const OriginReferenceType& x);

      virtual 
      ~OriginReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureNominalId_optional FeatureNominalId_;
      ReferencedComponent_optional ReferencedComponent_;
      DatumDefinitionId_optional DatumDefinitionId_;
    };

    class QIF30_SYMBOL_DECL SurfaceTextureCharacteristicDefinitionType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // RoughnessAverage
      //
      typedef ::xsd::qif30::LinearValueType RoughnessAverage_type;
      typedef ::xsd::cxx::tree::traits< RoughnessAverage_type, wchar_t > RoughnessAverage_traits;

      const RoughnessAverage_type&
      RoughnessAverage () const;

      RoughnessAverage_type&
      RoughnessAverage ();

      void
      RoughnessAverage (const RoughnessAverage_type& x);

      void
      RoughnessAverage (::std::unique_ptr< RoughnessAverage_type > p);

      // Constructors.
      //
      SurfaceTextureCharacteristicDefinitionType ();

      SurfaceTextureCharacteristicDefinitionType (const id_type&,
                                                  const RoughnessAverage_type&);

      SurfaceTextureCharacteristicDefinitionType (const id_type&,
                                                  ::std::unique_ptr< RoughnessAverage_type >);

      SurfaceTextureCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      SurfaceTextureCharacteristicDefinitionType (const SurfaceTextureCharacteristicDefinitionType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual SurfaceTextureCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceTextureCharacteristicDefinitionType&
      operator= (const SurfaceTextureCharacteristicDefinitionType& x);

      virtual 
      ~SurfaceTextureCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< RoughnessAverage_type > RoughnessAverage_;
    };

    class QIF30_SYMBOL_DECL RoughnessLayEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PARALLEL,
        PERPENDICULAR,
        CROSS_HATCH,
        MULTI_DIRECTIONAL,
        CIRCULAR,
        RADIAL,
        PARTICULATE
      };

      RoughnessLayEnumType ();

      RoughnessLayEnumType (value v);

      RoughnessLayEnumType (const wchar_t* v);

      RoughnessLayEnumType (const ::std::wstring& v);

      RoughnessLayEnumType (const ::xml_schema::nmtoken& v);

      RoughnessLayEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      RoughnessLayEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      RoughnessLayEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      RoughnessLayEnumType (const RoughnessLayEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      RoughnessLayEnumType&
      operator= (const RoughnessLayEnumType&) = default;
#endif

      virtual RoughnessLayEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RoughnessLayEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_RoughnessLayEnumType_convert ();
      }

      protected:
      value
      _xsd_RoughnessLayEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_RoughnessLayEnumType_literals_[7];
      static const value _xsd_RoughnessLayEnumType_indexes_[7];
    };

    class QIF30_SYMBOL_DECL RoughnessObtentionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        UNDEFINED,
        UNSUPPORTED,
        MACHINING_MANDATORY,
        MACHINING_FORBIDDEN
      };

      RoughnessObtentionEnumType ();

      RoughnessObtentionEnumType (value v);

      RoughnessObtentionEnumType (const wchar_t* v);

      RoughnessObtentionEnumType (const ::std::wstring& v);

      RoughnessObtentionEnumType (const ::xml_schema::nmtoken& v);

      RoughnessObtentionEnumType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      RoughnessObtentionEnumType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      RoughnessObtentionEnumType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      RoughnessObtentionEnumType (const RoughnessObtentionEnumType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      RoughnessObtentionEnumType&
      operator= (const RoughnessObtentionEnumType&) = default;
#endif

      virtual RoughnessObtentionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RoughnessObtentionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_RoughnessObtentionEnumType_convert ();
      }

      protected:
      value
      _xsd_RoughnessObtentionEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_RoughnessObtentionEnumType_literals_[4];
      static const value _xsd_RoughnessObtentionEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL RoughnessApplicabilityEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        UNSUPPORTED,
        SPECIFIED_SURFACE_ONLY,
        ALL_PART_SURFACES,
        BASIC_SURFACE
      };

      RoughnessApplicabilityEnumType ();

      RoughnessApplicabilityEnumType (value v);

      RoughnessApplicabilityEnumType (const wchar_t* v);

      RoughnessApplicabilityEnumType (const ::std::wstring& v);

      RoughnessApplicabilityEnumType (const ::xml_schema::nmtoken& v);

      RoughnessApplicabilityEnumType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      RoughnessApplicabilityEnumType (const xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      RoughnessApplicabilityEnumType (const ::std::wstring& s,
                                      const xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      RoughnessApplicabilityEnumType (const RoughnessApplicabilityEnumType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      RoughnessApplicabilityEnumType&
      operator= (const RoughnessApplicabilityEnumType&) = default;
#endif

      virtual RoughnessApplicabilityEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RoughnessApplicabilityEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_RoughnessApplicabilityEnumType_convert ();
      }

      protected:
      value
      _xsd_RoughnessApplicabilityEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_RoughnessApplicabilityEnumType_literals_[4];
      static const value _xsd_RoughnessApplicabilityEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL SurfaceTextureCharacteristicNominalType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // Obtention
      //
      typedef ::xsd::qif30::RoughnessObtentionEnumType Obtention_type;
      typedef ::xsd::cxx::tree::optional< Obtention_type > Obtention_optional;
      typedef ::xsd::cxx::tree::traits< Obtention_type, wchar_t > Obtention_traits;

      const Obtention_optional&
      Obtention () const;

      Obtention_optional&
      Obtention ();

      void
      Obtention (const Obtention_type& x);

      void
      Obtention (const Obtention_optional& x);

      void
      Obtention (::std::unique_ptr< Obtention_type > p);

      static const Obtention_type&
      Obtention_default_value ();

      // Applicability
      //
      typedef ::xsd::qif30::RoughnessApplicabilityEnumType Applicability_type;
      typedef ::xsd::cxx::tree::optional< Applicability_type > Applicability_optional;
      typedef ::xsd::cxx::tree::traits< Applicability_type, wchar_t > Applicability_traits;

      const Applicability_optional&
      Applicability () const;

      Applicability_optional&
      Applicability ();

      void
      Applicability (const Applicability_type& x);

      void
      Applicability (const Applicability_optional& x);

      void
      Applicability (::std::unique_ptr< Applicability_type > p);

      static const Applicability_type&
      Applicability_default_value ();

      // MinimumMaterialRemoval
      //
      typedef ::xml_schema::token MinimumMaterialRemoval_type;
      typedef ::xsd::cxx::tree::optional< MinimumMaterialRemoval_type > MinimumMaterialRemoval_optional;
      typedef ::xsd::cxx::tree::traits< MinimumMaterialRemoval_type, wchar_t > MinimumMaterialRemoval_traits;

      const MinimumMaterialRemoval_optional&
      MinimumMaterialRemoval () const;

      MinimumMaterialRemoval_optional&
      MinimumMaterialRemoval ();

      void
      MinimumMaterialRemoval (const MinimumMaterialRemoval_type& x);

      void
      MinimumMaterialRemoval (const MinimumMaterialRemoval_optional& x);

      void
      MinimumMaterialRemoval (::std::unique_ptr< MinimumMaterialRemoval_type > p);

      // ProductionMethod
      //
      typedef ::xml_schema::token ProductionMethod_type;
      typedef ::xsd::cxx::tree::optional< ProductionMethod_type > ProductionMethod_optional;
      typedef ::xsd::cxx::tree::traits< ProductionMethod_type, wchar_t > ProductionMethod_traits;

      const ProductionMethod_optional&
      ProductionMethod () const;

      ProductionMethod_optional&
      ProductionMethod ();

      void
      ProductionMethod (const ProductionMethod_type& x);

      void
      ProductionMethod (const ProductionMethod_optional& x);

      void
      ProductionMethod (::std::unique_ptr< ProductionMethod_type > p);

      // Cutoff
      //
      typedef ::xsd::qif30::LinearValueType Cutoff_type;
      typedef ::xsd::cxx::tree::optional< Cutoff_type > Cutoff_optional;
      typedef ::xsd::cxx::tree::traits< Cutoff_type, wchar_t > Cutoff_traits;

      const Cutoff_optional&
      Cutoff () const;

      Cutoff_optional&
      Cutoff ();

      void
      Cutoff (const Cutoff_type& x);

      void
      Cutoff (const Cutoff_optional& x);

      void
      Cutoff (::std::unique_ptr< Cutoff_type > p);

      // SecondaryRoughnessParameter
      //
      typedef ::xsd::qif30::LinearValueType SecondaryRoughnessParameter_type;
      typedef ::xsd::cxx::tree::optional< SecondaryRoughnessParameter_type > SecondaryRoughnessParameter_optional;
      typedef ::xsd::cxx::tree::traits< SecondaryRoughnessParameter_type, wchar_t > SecondaryRoughnessParameter_traits;

      const SecondaryRoughnessParameter_optional&
      SecondaryRoughnessParameter () const;

      SecondaryRoughnessParameter_optional&
      SecondaryRoughnessParameter ();

      void
      SecondaryRoughnessParameter (const SecondaryRoughnessParameter_type& x);

      void
      SecondaryRoughnessParameter (const SecondaryRoughnessParameter_optional& x);

      void
      SecondaryRoughnessParameter (::std::unique_ptr< SecondaryRoughnessParameter_type > p);

      // DirectionOfLay
      //
      typedef ::xsd::qif30::RoughnessLayEnumType DirectionOfLay_type;
      typedef ::xsd::cxx::tree::optional< DirectionOfLay_type > DirectionOfLay_optional;
      typedef ::xsd::cxx::tree::traits< DirectionOfLay_type, wchar_t > DirectionOfLay_traits;

      const DirectionOfLay_optional&
      DirectionOfLay () const;

      DirectionOfLay_optional&
      DirectionOfLay ();

      void
      DirectionOfLay (const DirectionOfLay_type& x);

      void
      DirectionOfLay (const DirectionOfLay_optional& x);

      void
      DirectionOfLay (::std::unique_ptr< DirectionOfLay_type > p);

      // OtherSurfaceParameter
      //
      typedef ::xml_schema::token OtherSurfaceParameter_type;
      typedef ::xsd::cxx::tree::optional< OtherSurfaceParameter_type > OtherSurfaceParameter_optional;
      typedef ::xsd::cxx::tree::traits< OtherSurfaceParameter_type, wchar_t > OtherSurfaceParameter_traits;

      const OtherSurfaceParameter_optional&
      OtherSurfaceParameter () const;

      OtherSurfaceParameter_optional&
      OtherSurfaceParameter ();

      void
      OtherSurfaceParameter (const OtherSurfaceParameter_type& x);

      void
      OtherSurfaceParameter (const OtherSurfaceParameter_optional& x);

      void
      OtherSurfaceParameter (::std::unique_ptr< OtherSurfaceParameter_type > p);

      // Constructors.
      //
      SurfaceTextureCharacteristicNominalType ();

      SurfaceTextureCharacteristicNominalType (const id_type&,
                                               const CharacteristicDefinitionId_type&);

      SurfaceTextureCharacteristicNominalType (const id_type&,
                                               ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SurfaceTextureCharacteristicNominalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      SurfaceTextureCharacteristicNominalType (const SurfaceTextureCharacteristicNominalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual SurfaceTextureCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceTextureCharacteristicNominalType&
      operator= (const SurfaceTextureCharacteristicNominalType& x);

      virtual 
      ~SurfaceTextureCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Obtention_optional Obtention_;
      static const Obtention_type Obtention_default_value_;
      Applicability_optional Applicability_;
      static const Applicability_type Applicability_default_value_;
      MinimumMaterialRemoval_optional MinimumMaterialRemoval_;
      ProductionMethod_optional ProductionMethod_;
      Cutoff_optional Cutoff_;
      SecondaryRoughnessParameter_optional SecondaryRoughnessParameter_;
      DirectionOfLay_optional DirectionOfLay_;
      OtherSurfaceParameter_optional OtherSurfaceParameter_;
    };

    class QIF30_SYMBOL_DECL SurfaceTextureCharacteristicMeasurementType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // RoughnessAverageValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType RoughnessAverageValue_type;
      typedef ::xsd::cxx::tree::optional< RoughnessAverageValue_type > RoughnessAverageValue_optional;
      typedef ::xsd::cxx::tree::traits< RoughnessAverageValue_type, wchar_t > RoughnessAverageValue_traits;

      const RoughnessAverageValue_optional&
      RoughnessAverageValue () const;

      RoughnessAverageValue_optional&
      RoughnessAverageValue ();

      void
      RoughnessAverageValue (const RoughnessAverageValue_type& x);

      void
      RoughnessAverageValue (const RoughnessAverageValue_optional& x);

      void
      RoughnessAverageValue (::std::unique_ptr< RoughnessAverageValue_type > p);

      // Constructors.
      //
      SurfaceTextureCharacteristicMeasurementType ();

      SurfaceTextureCharacteristicMeasurementType (const id_type&,
                                                   const Status_type&,
                                                   const CharacteristicItemId_type&);

      SurfaceTextureCharacteristicMeasurementType (const id_type&,
                                                   ::std::unique_ptr< Status_type >,
                                                   ::std::unique_ptr< CharacteristicItemId_type >);

      SurfaceTextureCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      SurfaceTextureCharacteristicMeasurementType (const SurfaceTextureCharacteristicMeasurementType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual SurfaceTextureCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceTextureCharacteristicMeasurementType&
      operator= (const SurfaceTextureCharacteristicMeasurementType& x);

      virtual 
      ~SurfaceTextureCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      RoughnessAverageValue_optional RoughnessAverageValue_;
    };

    class QIF30_SYMBOL_DECL SurfaceTextureCharacteristicItemType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SurfaceTextureCharacteristicItemType ();

      SurfaceTextureCharacteristicItemType (const id_type&,
                                            const CharacteristicNominalId_type&);

      SurfaceTextureCharacteristicItemType (const id_type&,
                                            ::std::unique_ptr< CharacteristicNominalId_type >);

      SurfaceTextureCharacteristicItemType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      SurfaceTextureCharacteristicItemType (const SurfaceTextureCharacteristicItemType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual SurfaceTextureCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceTextureCharacteristicItemType&
      operator= (const SurfaceTextureCharacteristicItemType&) = default;
#endif

      virtual 
      ~SurfaceTextureCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL OrientationDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // ZoneOrientationVector
      //
      typedef ::xsd::qif30::UnitVectorType ZoneOrientationVector_type;
      typedef ::xsd::cxx::tree::optional< ZoneOrientationVector_type > ZoneOrientationVector_optional;
      typedef ::xsd::cxx::tree::traits< ZoneOrientationVector_type, wchar_t > ZoneOrientationVector_traits;

      const ZoneOrientationVector_optional&
      ZoneOrientationVector () const;

      ZoneOrientationVector_optional&
      ZoneOrientationVector ();

      void
      ZoneOrientationVector (const ZoneOrientationVector_type& x);

      void
      ZoneOrientationVector (const ZoneOrientationVector_optional& x);

      void
      ZoneOrientationVector (::std::unique_ptr< ZoneOrientationVector_type > p);

      // Constructors.
      //
      OrientationDiametricalZoneType ();

      OrientationDiametricalZoneType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      OrientationDiametricalZoneType (const OrientationDiametricalZoneType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual OrientationDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrientationDiametricalZoneType&
      operator= (const OrientationDiametricalZoneType& x);

      virtual 
      ~OrientationDiametricalZoneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ZoneOrientationVector_optional ZoneOrientationVector_;
    };

    class QIF30_SYMBOL_DECL OrientationPlanarZoneType: public ::xml_schema::type
    {
      public:
      // ZoneOrientationVector
      //
      typedef ::xsd::qif30::UnitVectorType ZoneOrientationVector_type;
      typedef ::xsd::cxx::tree::optional< ZoneOrientationVector_type > ZoneOrientationVector_optional;
      typedef ::xsd::cxx::tree::traits< ZoneOrientationVector_type, wchar_t > ZoneOrientationVector_traits;

      const ZoneOrientationVector_optional&
      ZoneOrientationVector () const;

      ZoneOrientationVector_optional&
      ZoneOrientationVector ();

      void
      ZoneOrientationVector (const ZoneOrientationVector_type& x);

      void
      ZoneOrientationVector (const ZoneOrientationVector_optional& x);

      void
      ZoneOrientationVector (::std::unique_ptr< ZoneOrientationVector_type > p);

      // Constructors.
      //
      OrientationPlanarZoneType ();

      OrientationPlanarZoneType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      OrientationPlanarZoneType (const OrientationPlanarZoneType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual OrientationPlanarZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrientationPlanarZoneType&
      operator= (const OrientationPlanarZoneType& x);

      virtual 
      ~OrientationPlanarZoneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ZoneOrientationVector_optional ZoneOrientationVector_;
    };

    class QIF30_SYMBOL_DECL OrientationZoneShapeType: public ::xml_schema::type
    {
      public:
      // DiametricalZone
      //
      typedef ::xsd::qif30::OrientationDiametricalZoneType DiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< DiametricalZone_type > DiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< DiametricalZone_type, wchar_t > DiametricalZone_traits;

      const DiametricalZone_optional&
      DiametricalZone () const;

      DiametricalZone_optional&
      DiametricalZone ();

      void
      DiametricalZone (const DiametricalZone_type& x);

      void
      DiametricalZone (const DiametricalZone_optional& x);

      void
      DiametricalZone (::std::unique_ptr< DiametricalZone_type > p);

      // PlanarZone
      //
      typedef ::xsd::qif30::OrientationPlanarZoneType PlanarZone_type;
      typedef ::xsd::cxx::tree::optional< PlanarZone_type > PlanarZone_optional;
      typedef ::xsd::cxx::tree::traits< PlanarZone_type, wchar_t > PlanarZone_traits;

      const PlanarZone_optional&
      PlanarZone () const;

      PlanarZone_optional&
      PlanarZone ();

      void
      PlanarZone (const PlanarZone_type& x);

      void
      PlanarZone (const PlanarZone_optional& x);

      void
      PlanarZone (::std::unique_ptr< PlanarZone_type > p);

      // Constructors.
      //
      OrientationZoneShapeType ();

      OrientationZoneShapeType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      OrientationZoneShapeType (const OrientationZoneShapeType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual OrientationZoneShapeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrientationZoneShapeType&
      operator= (const OrientationZoneShapeType& x);

      virtual 
      ~OrientationZoneShapeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DiametricalZone_optional DiametricalZone_;
      PlanarZone_optional PlanarZone_;
    };

    class QIF30_SYMBOL_DECL OrientationCharacteristicItemBaseType: public ::xsd::qif30::GeometricCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      OrientationCharacteristicItemBaseType ();

      OrientationCharacteristicItemBaseType (const id_type&,
                                             const CharacteristicNominalId_type&);

      OrientationCharacteristicItemBaseType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      OrientationCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OrientationCharacteristicItemBaseType (const OrientationCharacteristicItemBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual OrientationCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      OrientationCharacteristicItemBaseType&
      operator= (const OrientationCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~OrientationCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL OrientationCharacteristicDefinitionBaseType: public ::xsd::qif30::GeometricCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // DatumReferenceFrameId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumReferenceFrameId_type;
      typedef ::xsd::cxx::tree::optional< DatumReferenceFrameId_type > DatumReferenceFrameId_optional;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameId_type, wchar_t > DatumReferenceFrameId_traits;

      const DatumReferenceFrameId_optional&
      DatumReferenceFrameId () const;

      DatumReferenceFrameId_optional&
      DatumReferenceFrameId ();

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_type& x);

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_optional& x);

      void
      DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > p);

      // MaterialCondition
      //
      typedef ::xsd::qif30::MaterialModifierEnumType MaterialCondition_type;
      typedef ::xsd::cxx::tree::traits< MaterialCondition_type, wchar_t > MaterialCondition_traits;

      const MaterialCondition_type&
      MaterialCondition () const;

      MaterialCondition_type&
      MaterialCondition ();

      void
      MaterialCondition (const MaterialCondition_type& x);

      void
      MaterialCondition (::std::unique_ptr< MaterialCondition_type > p);

      // SizeCharacteristicDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceType SizeCharacteristicDefinitionId_type;
      typedef ::xsd::cxx::tree::optional< SizeCharacteristicDefinitionId_type > SizeCharacteristicDefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< SizeCharacteristicDefinitionId_type, wchar_t > SizeCharacteristicDefinitionId_traits;

      const SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId () const;

      SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId ();

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_type& x);

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_optional& x);

      void
      SizeCharacteristicDefinitionId (::std::unique_ptr< SizeCharacteristicDefinitionId_type > p);

      // ZoneShape
      //
      typedef ::xsd::qif30::OrientationZoneShapeType ZoneShape_type;
      typedef ::xsd::cxx::tree::traits< ZoneShape_type, wchar_t > ZoneShape_traits;

      const ZoneShape_type&
      ZoneShape () const;

      ZoneShape_type&
      ZoneShape ();

      void
      ZoneShape (const ZoneShape_type& x);

      void
      ZoneShape (::std::unique_ptr< ZoneShape_type > p);

      // TangentPlane
      //
      typedef ::xml_schema::boolean TangentPlane_type;
      typedef ::xsd::cxx::tree::optional< TangentPlane_type > TangentPlane_optional;
      typedef ::xsd::cxx::tree::traits< TangentPlane_type, wchar_t > TangentPlane_traits;

      const TangentPlane_optional&
      TangentPlane () const;

      TangentPlane_optional&
      TangentPlane ();

      void
      TangentPlane (const TangentPlane_type& x);

      void
      TangentPlane (const TangentPlane_optional& x);

      // MaximumToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType MaximumToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< MaximumToleranceValue_type > MaximumToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< MaximumToleranceValue_type, wchar_t > MaximumToleranceValue_traits;

      const MaximumToleranceValue_optional&
      MaximumToleranceValue () const;

      MaximumToleranceValue_optional&
      MaximumToleranceValue ();

      void
      MaximumToleranceValue (const MaximumToleranceValue_type& x);

      void
      MaximumToleranceValue (const MaximumToleranceValue_optional& x);

      void
      MaximumToleranceValue (::std::unique_ptr< MaximumToleranceValue_type > p);

      // ProjectedToleranceZoneValue
      //
      typedef ::xsd::qif30::LinearValueType ProjectedToleranceZoneValue_type;
      typedef ::xsd::cxx::tree::optional< ProjectedToleranceZoneValue_type > ProjectedToleranceZoneValue_optional;
      typedef ::xsd::cxx::tree::traits< ProjectedToleranceZoneValue_type, wchar_t > ProjectedToleranceZoneValue_traits;

      const ProjectedToleranceZoneValue_optional&
      ProjectedToleranceZoneValue () const;

      ProjectedToleranceZoneValue_optional&
      ProjectedToleranceZoneValue ();

      void
      ProjectedToleranceZoneValue (const ProjectedToleranceZoneValue_type& x);

      void
      ProjectedToleranceZoneValue (const ProjectedToleranceZoneValue_optional& x);

      void
      ProjectedToleranceZoneValue (::std::unique_ptr< ProjectedToleranceZoneValue_type > p);

      // EachRadialElement
      //
      typedef ::xml_schema::boolean EachRadialElement_type;
      typedef ::xsd::cxx::tree::optional< EachRadialElement_type > EachRadialElement_optional;
      typedef ::xsd::cxx::tree::traits< EachRadialElement_type, wchar_t > EachRadialElement_traits;

      const EachRadialElement_optional&
      EachRadialElement () const;

      EachRadialElement_optional&
      EachRadialElement ();

      void
      EachRadialElement (const EachRadialElement_type& x);

      void
      EachRadialElement (const EachRadialElement_optional& x);

      // EachElement
      //
      typedef ::xml_schema::boolean EachElement_type;
      typedef ::xsd::cxx::tree::optional< EachElement_type > EachElement_optional;
      typedef ::xsd::cxx::tree::traits< EachElement_type, wchar_t > EachElement_traits;

      const EachElement_optional&
      EachElement () const;

      EachElement_optional&
      EachElement ();

      void
      EachElement (const EachElement_type& x);

      void
      EachElement (const EachElement_optional& x);

      // Constructors.
      //
      OrientationCharacteristicDefinitionBaseType ();

      OrientationCharacteristicDefinitionBaseType (const id_type&,
                                                   const ToleranceValue_type&,
                                                   const MaterialCondition_type&,
                                                   const ZoneShape_type&);

      OrientationCharacteristicDefinitionBaseType (const id_type&,
                                                   ::std::unique_ptr< ToleranceValue_type >,
                                                   const MaterialCondition_type&,
                                                   ::std::unique_ptr< ZoneShape_type >);

      OrientationCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      OrientationCharacteristicDefinitionBaseType (const OrientationCharacteristicDefinitionBaseType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual OrientationCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      OrientationCharacteristicDefinitionBaseType&
      operator= (const OrientationCharacteristicDefinitionBaseType& x);

      virtual 
      ~OrientationCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      DatumReferenceFrameId_optional DatumReferenceFrameId_;
      ::xsd::cxx::tree::one< MaterialCondition_type > MaterialCondition_;
      SizeCharacteristicDefinitionId_optional SizeCharacteristicDefinitionId_;
      ::xsd::cxx::tree::one< ZoneShape_type > ZoneShape_;
      TangentPlane_optional TangentPlane_;
      MaximumToleranceValue_optional MaximumToleranceValue_;
      ProjectedToleranceZoneValue_optional ProjectedToleranceZoneValue_;
      EachRadialElement_optional EachRadialElement_;
      EachElement_optional EachElement_;
    };

    class QIF30_SYMBOL_DECL OrientationCharacteristicNominalBaseType: public ::xsd::qif30::GeometricCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      OrientationCharacteristicNominalBaseType ();

      OrientationCharacteristicNominalBaseType (const id_type&,
                                                const CharacteristicDefinitionId_type&);

      OrientationCharacteristicNominalBaseType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >);

      OrientationCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      OrientationCharacteristicNominalBaseType (const OrientationCharacteristicNominalBaseType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual OrientationCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      OrientationCharacteristicNominalBaseType&
      operator= (const OrientationCharacteristicNominalBaseType&) = default;
#endif

      virtual 
      ~OrientationCharacteristicNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL OrientationCharacteristicMeasurementBaseType: public ::xsd::qif30::GeometricCharacteristicMeasurementBaseType
    {
      public:
      // DatumsOk
      //
      typedef ::xml_schema::boolean DatumsOk_type;
      typedef ::xsd::cxx::tree::optional< DatumsOk_type > DatumsOk_optional;
      typedef ::xsd::cxx::tree::traits< DatumsOk_type, wchar_t > DatumsOk_traits;

      const DatumsOk_optional&
      DatumsOk () const;

      DatumsOk_optional&
      DatumsOk ();

      void
      DatumsOk (const DatumsOk_type& x);

      void
      DatumsOk (const DatumsOk_optional& x);

      // Bonus
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Bonus_type;
      typedef ::xsd::cxx::tree::optional< Bonus_type > Bonus_optional;
      typedef ::xsd::cxx::tree::traits< Bonus_type, wchar_t > Bonus_traits;

      const Bonus_optional&
      Bonus () const;

      Bonus_optional&
      Bonus ();

      void
      Bonus (const Bonus_type& x);

      void
      Bonus (const Bonus_optional& x);

      void
      Bonus (::std::unique_ptr< Bonus_type > p);

      // ReferenceLength
      //
      typedef ::xsd::qif30::LinearValueType ReferenceLength_type;
      typedef ::xsd::cxx::tree::optional< ReferenceLength_type > ReferenceLength_optional;
      typedef ::xsd::cxx::tree::traits< ReferenceLength_type, wchar_t > ReferenceLength_traits;

      const ReferenceLength_optional&
      ReferenceLength () const;

      ReferenceLength_optional&
      ReferenceLength ();

      void
      ReferenceLength (const ReferenceLength_type& x);

      void
      ReferenceLength (const ReferenceLength_optional& x);

      void
      ReferenceLength (::std::unique_ptr< ReferenceLength_type > p);

      // DRFTransformActualId
      //
      typedef ::xsd::qif30::QIFReferenceType DRFTransformActualId_type;
      typedef ::xsd::cxx::tree::optional< DRFTransformActualId_type > DRFTransformActualId_optional;
      typedef ::xsd::cxx::tree::traits< DRFTransformActualId_type, wchar_t > DRFTransformActualId_traits;

      const DRFTransformActualId_optional&
      DRFTransformActualId () const;

      DRFTransformActualId_optional&
      DRFTransformActualId ();

      void
      DRFTransformActualId (const DRFTransformActualId_type& x);

      void
      DRFTransformActualId (const DRFTransformActualId_optional& x);

      void
      DRFTransformActualId (::std::unique_ptr< DRFTransformActualId_type > p);

      // Constructors.
      //
      OrientationCharacteristicMeasurementBaseType ();

      OrientationCharacteristicMeasurementBaseType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      OrientationCharacteristicMeasurementBaseType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      OrientationCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      OrientationCharacteristicMeasurementBaseType (const OrientationCharacteristicMeasurementBaseType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual OrientationCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      OrientationCharacteristicMeasurementBaseType&
      operator= (const OrientationCharacteristicMeasurementBaseType& x);

      virtual 
      ~OrientationCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DatumsOk_optional DatumsOk_;
      Bonus_optional Bonus_;
      ReferenceLength_optional ReferenceLength_;
      DRFTransformActualId_optional DRFTransformActualId_;
    };

    class QIF30_SYMBOL_DECL AngularityCharacteristicItemType: public ::xsd::qif30::OrientationCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      AngularityCharacteristicItemType ();

      AngularityCharacteristicItemType (const id_type&,
                                        const CharacteristicNominalId_type&);

      AngularityCharacteristicItemType (const id_type&,
                                        ::std::unique_ptr< CharacteristicNominalId_type >);

      AngularityCharacteristicItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      AngularityCharacteristicItemType (const AngularityCharacteristicItemType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual AngularityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngularityCharacteristicItemType&
      operator= (const AngularityCharacteristicItemType&) = default;
#endif

      virtual 
      ~AngularityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL AngularityCharacteristicDefinitionType: public ::xsd::qif30::OrientationCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      AngularityCharacteristicDefinitionType ();

      AngularityCharacteristicDefinitionType (const id_type&,
                                              const ToleranceValue_type&,
                                              const MaterialCondition_type&,
                                              const ZoneShape_type&);

      AngularityCharacteristicDefinitionType (const id_type&,
                                              ::std::unique_ptr< ToleranceValue_type >,
                                              const MaterialCondition_type&,
                                              ::std::unique_ptr< ZoneShape_type >);

      AngularityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      AngularityCharacteristicDefinitionType (const AngularityCharacteristicDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual AngularityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngularityCharacteristicDefinitionType&
      operator= (const AngularityCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~AngularityCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL AngularityCharacteristicNominalType: public ::xsd::qif30::OrientationCharacteristicNominalBaseType
    {
      public:
      // Angle
      //
      typedef ::xsd::qif30::AngularValueType Angle_type;
      typedef ::xsd::cxx::tree::optional< Angle_type > Angle_optional;
      typedef ::xsd::cxx::tree::traits< Angle_type, wchar_t > Angle_traits;

      const Angle_optional&
      Angle () const;

      Angle_optional&
      Angle ();

      void
      Angle (const Angle_type& x);

      void
      Angle (const Angle_optional& x);

      void
      Angle (::std::unique_ptr< Angle_type > p);

      // Constructors.
      //
      AngularityCharacteristicNominalType ();

      AngularityCharacteristicNominalType (const id_type&,
                                           const CharacteristicDefinitionId_type&);

      AngularityCharacteristicNominalType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >);

      AngularityCharacteristicNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      AngularityCharacteristicNominalType (const AngularityCharacteristicNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual AngularityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularityCharacteristicNominalType&
      operator= (const AngularityCharacteristicNominalType& x);

      virtual 
      ~AngularityCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Angle_optional Angle_;
    };

    class QIF30_SYMBOL_DECL AngularityCharacteristicMeasurementType: public ::xsd::qif30::OrientationCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      AngularityCharacteristicMeasurementType ();

      AngularityCharacteristicMeasurementType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&);

      AngularityCharacteristicMeasurementType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >);

      AngularityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      AngularityCharacteristicMeasurementType (const AngularityCharacteristicMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual AngularityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngularityCharacteristicMeasurementType&
      operator= (const AngularityCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~AngularityCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL PerpendicularityCharacteristicItemType: public ::xsd::qif30::OrientationCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      PerpendicularityCharacteristicItemType ();

      PerpendicularityCharacteristicItemType (const id_type&,
                                              const CharacteristicNominalId_type&);

      PerpendicularityCharacteristicItemType (const id_type&,
                                              ::std::unique_ptr< CharacteristicNominalId_type >);

      PerpendicularityCharacteristicItemType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      PerpendicularityCharacteristicItemType (const PerpendicularityCharacteristicItemType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual PerpendicularityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PerpendicularityCharacteristicItemType&
      operator= (const PerpendicularityCharacteristicItemType&) = default;
#endif

      virtual 
      ~PerpendicularityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL PerpendicularityCharacteristicDefinitionType: public ::xsd::qif30::OrientationCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      PerpendicularityCharacteristicDefinitionType ();

      PerpendicularityCharacteristicDefinitionType (const id_type&,
                                                    const ToleranceValue_type&,
                                                    const MaterialCondition_type&,
                                                    const ZoneShape_type&);

      PerpendicularityCharacteristicDefinitionType (const id_type&,
                                                    ::std::unique_ptr< ToleranceValue_type >,
                                                    const MaterialCondition_type&,
                                                    ::std::unique_ptr< ZoneShape_type >);

      PerpendicularityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      PerpendicularityCharacteristicDefinitionType (const PerpendicularityCharacteristicDefinitionType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual PerpendicularityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PerpendicularityCharacteristicDefinitionType&
      operator= (const PerpendicularityCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~PerpendicularityCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL PerpendicularityCharacteristicNominalType: public ::xsd::qif30::OrientationCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      PerpendicularityCharacteristicNominalType ();

      PerpendicularityCharacteristicNominalType (const id_type&,
                                                 const CharacteristicDefinitionId_type&);

      PerpendicularityCharacteristicNominalType (const id_type&,
                                                 ::std::unique_ptr< CharacteristicDefinitionId_type >);

      PerpendicularityCharacteristicNominalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PerpendicularityCharacteristicNominalType (const PerpendicularityCharacteristicNominalType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual PerpendicularityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PerpendicularityCharacteristicNominalType&
      operator= (const PerpendicularityCharacteristicNominalType&) = default;
#endif

      virtual 
      ~PerpendicularityCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL PerpendicularityCharacteristicMeasurementType: public ::xsd::qif30::OrientationCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      PerpendicularityCharacteristicMeasurementType ();

      PerpendicularityCharacteristicMeasurementType (const id_type&,
                                                     const Status_type&,
                                                     const CharacteristicItemId_type&);

      PerpendicularityCharacteristicMeasurementType (const id_type&,
                                                     ::std::unique_ptr< Status_type >,
                                                     ::std::unique_ptr< CharacteristicItemId_type >);

      PerpendicularityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      PerpendicularityCharacteristicMeasurementType (const PerpendicularityCharacteristicMeasurementType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual PerpendicularityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PerpendicularityCharacteristicMeasurementType&
      operator= (const PerpendicularityCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~PerpendicularityCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL ParallelismCharacteristicItemType: public ::xsd::qif30::OrientationCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ParallelismCharacteristicItemType ();

      ParallelismCharacteristicItemType (const id_type&,
                                         const CharacteristicNominalId_type&);

      ParallelismCharacteristicItemType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      ParallelismCharacteristicItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ParallelismCharacteristicItemType (const ParallelismCharacteristicItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ParallelismCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ParallelismCharacteristicItemType&
      operator= (const ParallelismCharacteristicItemType&) = default;
#endif

      virtual 
      ~ParallelismCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ParallelismCharacteristicDefinitionType: public ::xsd::qif30::OrientationCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      ParallelismCharacteristicDefinitionType ();

      ParallelismCharacteristicDefinitionType (const id_type&,
                                               const ToleranceValue_type&,
                                               const MaterialCondition_type&,
                                               const ZoneShape_type&);

      ParallelismCharacteristicDefinitionType (const id_type&,
                                               ::std::unique_ptr< ToleranceValue_type >,
                                               const MaterialCondition_type&,
                                               ::std::unique_ptr< ZoneShape_type >);

      ParallelismCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      ParallelismCharacteristicDefinitionType (const ParallelismCharacteristicDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual ParallelismCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ParallelismCharacteristicDefinitionType&
      operator= (const ParallelismCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~ParallelismCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL ParallelismCharacteristicNominalType: public ::xsd::qif30::OrientationCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      ParallelismCharacteristicNominalType ();

      ParallelismCharacteristicNominalType (const id_type&,
                                            const CharacteristicDefinitionId_type&);

      ParallelismCharacteristicNominalType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ParallelismCharacteristicNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ParallelismCharacteristicNominalType (const ParallelismCharacteristicNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ParallelismCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ParallelismCharacteristicNominalType&
      operator= (const ParallelismCharacteristicNominalType&) = default;
#endif

      virtual 
      ~ParallelismCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL ParallelismCharacteristicMeasurementType: public ::xsd::qif30::OrientationCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      ParallelismCharacteristicMeasurementType ();

      ParallelismCharacteristicMeasurementType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      ParallelismCharacteristicMeasurementType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      ParallelismCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ParallelismCharacteristicMeasurementType (const ParallelismCharacteristicMeasurementType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ParallelismCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ParallelismCharacteristicMeasurementType&
      operator= (const ParallelismCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~ParallelismCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL FormCharacteristicDefinitionBaseType: public ::xsd::qif30::GeometricCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      FormCharacteristicDefinitionBaseType ();

      FormCharacteristicDefinitionBaseType (const id_type&);

      FormCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      FormCharacteristicDefinitionBaseType (const FormCharacteristicDefinitionBaseType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual FormCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      FormCharacteristicDefinitionBaseType&
      operator= (const FormCharacteristicDefinitionBaseType&) = default;
#endif

      virtual 
      ~FormCharacteristicDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL FormCharacteristicNominalBaseType: public ::xsd::qif30::GeometricCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      FormCharacteristicNominalBaseType ();

      FormCharacteristicNominalBaseType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      FormCharacteristicNominalBaseType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      FormCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      FormCharacteristicNominalBaseType (const FormCharacteristicNominalBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual FormCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      FormCharacteristicNominalBaseType&
      operator= (const FormCharacteristicNominalBaseType&) = default;
#endif

      virtual 
      ~FormCharacteristicNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL FormCharacteristicMeasurementBaseType: public ::xsd::qif30::GeometricCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      FormCharacteristicMeasurementBaseType ();

      FormCharacteristicMeasurementBaseType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      FormCharacteristicMeasurementBaseType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      FormCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      FormCharacteristicMeasurementBaseType (const FormCharacteristicMeasurementBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual FormCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      FormCharacteristicMeasurementBaseType&
      operator= (const FormCharacteristicMeasurementBaseType&) = default;
#endif

      virtual 
      ~FormCharacteristicMeasurementBaseType ();
    };

    class QIF30_SYMBOL_DECL FormCharacteristicItemBaseType: public ::xsd::qif30::GeometricCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      FormCharacteristicItemBaseType ();

      FormCharacteristicItemBaseType (const id_type&,
                                      const CharacteristicNominalId_type&);

      FormCharacteristicItemBaseType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      FormCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      FormCharacteristicItemBaseType (const FormCharacteristicItemBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual FormCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      FormCharacteristicItemBaseType&
      operator= (const FormCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~FormCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL StraightnessDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      StraightnessDiametricalZoneType ();

      StraightnessDiametricalZoneType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      StraightnessDiametricalZoneType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      StraightnessDiametricalZoneType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      StraightnessDiametricalZoneType (const StraightnessDiametricalZoneType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual StraightnessDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      StraightnessDiametricalZoneType&
      operator= (const StraightnessDiametricalZoneType&) = default;
#endif

      virtual 
      ~StraightnessDiametricalZoneType ();
    };

    class QIF30_SYMBOL_DECL StraightnessNonDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // ZoneOrientationVector
      //
      typedef ::xsd::qif30::UnitVectorType ZoneOrientationVector_type;
      typedef ::xsd::cxx::tree::optional< ZoneOrientationVector_type > ZoneOrientationVector_optional;
      typedef ::xsd::cxx::tree::traits< ZoneOrientationVector_type, wchar_t > ZoneOrientationVector_traits;

      const ZoneOrientationVector_optional&
      ZoneOrientationVector () const;

      ZoneOrientationVector_optional&
      ZoneOrientationVector ();

      void
      ZoneOrientationVector (const ZoneOrientationVector_type& x);

      void
      ZoneOrientationVector (const ZoneOrientationVector_optional& x);

      void
      ZoneOrientationVector (::std::unique_ptr< ZoneOrientationVector_type > p);

      // Constructors.
      //
      StraightnessNonDiametricalZoneType ();

      StraightnessNonDiametricalZoneType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      StraightnessNonDiametricalZoneType (const StraightnessNonDiametricalZoneType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual StraightnessNonDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StraightnessNonDiametricalZoneType&
      operator= (const StraightnessNonDiametricalZoneType& x);

      virtual 
      ~StraightnessNonDiametricalZoneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ZoneOrientationVector_optional ZoneOrientationVector_;
    };

    class QIF30_SYMBOL_DECL StraightnessZoneShapeType: public ::xml_schema::type
    {
      public:
      // DiametricalZone
      //
      typedef ::xsd::qif30::StraightnessDiametricalZoneType DiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< DiametricalZone_type > DiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< DiametricalZone_type, wchar_t > DiametricalZone_traits;

      const DiametricalZone_optional&
      DiametricalZone () const;

      DiametricalZone_optional&
      DiametricalZone ();

      void
      DiametricalZone (const DiametricalZone_type& x);

      void
      DiametricalZone (const DiametricalZone_optional& x);

      void
      DiametricalZone (::std::unique_ptr< DiametricalZone_type > p);

      // NonDiametricalZone
      //
      typedef ::xsd::qif30::StraightnessNonDiametricalZoneType NonDiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< NonDiametricalZone_type > NonDiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< NonDiametricalZone_type, wchar_t > NonDiametricalZone_traits;

      const NonDiametricalZone_optional&
      NonDiametricalZone () const;

      NonDiametricalZone_optional&
      NonDiametricalZone ();

      void
      NonDiametricalZone (const NonDiametricalZone_type& x);

      void
      NonDiametricalZone (const NonDiametricalZone_optional& x);

      void
      NonDiametricalZone (::std::unique_ptr< NonDiametricalZone_type > p);

      // Constructors.
      //
      StraightnessZoneShapeType ();

      StraightnessZoneShapeType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      StraightnessZoneShapeType (const StraightnessZoneShapeType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual StraightnessZoneShapeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StraightnessZoneShapeType&
      operator= (const StraightnessZoneShapeType& x);

      virtual 
      ~StraightnessZoneShapeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DiametricalZone_optional DiametricalZone_;
      NonDiametricalZone_optional NonDiametricalZone_;
    };

    class QIF30_SYMBOL_DECL StraightnessCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      StraightnessCharacteristicItemType ();

      StraightnessCharacteristicItemType (const id_type&,
                                          const CharacteristicNominalId_type&);

      StraightnessCharacteristicItemType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >);

      StraightnessCharacteristicItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      StraightnessCharacteristicItemType (const StraightnessCharacteristicItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual StraightnessCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      StraightnessCharacteristicItemType&
      operator= (const StraightnessCharacteristicItemType&) = default;
#endif

      virtual 
      ~StraightnessCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL StraightnessCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceValue_type > ToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_optional&
      ToleranceValue () const;

      ToleranceValue_optional&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (const ToleranceValue_optional& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // ToleranceZonePerUnitLength
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitLengthType ToleranceZonePerUnitLength_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitLength_type > ToleranceZonePerUnitLength_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitLength_type, wchar_t > ToleranceZonePerUnitLength_traits;

      const ToleranceZonePerUnitLength_optional&
      ToleranceZonePerUnitLength () const;

      ToleranceZonePerUnitLength_optional&
      ToleranceZonePerUnitLength ();

      void
      ToleranceZonePerUnitLength (const ToleranceZonePerUnitLength_type& x);

      void
      ToleranceZonePerUnitLength (const ToleranceZonePerUnitLength_optional& x);

      void
      ToleranceZonePerUnitLength (::std::unique_ptr< ToleranceZonePerUnitLength_type > p);

      // MaterialCondition
      //
      typedef ::xsd::qif30::MaterialModifierEnumType MaterialCondition_type;
      typedef ::xsd::cxx::tree::optional< MaterialCondition_type > MaterialCondition_optional;
      typedef ::xsd::cxx::tree::traits< MaterialCondition_type, wchar_t > MaterialCondition_traits;

      const MaterialCondition_optional&
      MaterialCondition () const;

      MaterialCondition_optional&
      MaterialCondition ();

      void
      MaterialCondition (const MaterialCondition_type& x);

      void
      MaterialCondition (const MaterialCondition_optional& x);

      void
      MaterialCondition (::std::unique_ptr< MaterialCondition_type > p);

      // SizeCharacteristicDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceType SizeCharacteristicDefinitionId_type;
      typedef ::xsd::cxx::tree::optional< SizeCharacteristicDefinitionId_type > SizeCharacteristicDefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< SizeCharacteristicDefinitionId_type, wchar_t > SizeCharacteristicDefinitionId_traits;

      const SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId () const;

      SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId ();

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_type& x);

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_optional& x);

      void
      SizeCharacteristicDefinitionId (::std::unique_ptr< SizeCharacteristicDefinitionId_type > p);

      // ZoneShape
      //
      typedef ::xsd::qif30::StraightnessZoneShapeType ZoneShape_type;
      typedef ::xsd::cxx::tree::traits< ZoneShape_type, wchar_t > ZoneShape_traits;

      const ZoneShape_type&
      ZoneShape () const;

      ZoneShape_type&
      ZoneShape ();

      void
      ZoneShape (const ZoneShape_type& x);

      void
      ZoneShape (::std::unique_ptr< ZoneShape_type > p);

      // MaximumToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType MaximumToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< MaximumToleranceValue_type > MaximumToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< MaximumToleranceValue_type, wchar_t > MaximumToleranceValue_traits;

      const MaximumToleranceValue_optional&
      MaximumToleranceValue () const;

      MaximumToleranceValue_optional&
      MaximumToleranceValue ();

      void
      MaximumToleranceValue (const MaximumToleranceValue_type& x);

      void
      MaximumToleranceValue (const MaximumToleranceValue_optional& x);

      void
      MaximumToleranceValue (::std::unique_ptr< MaximumToleranceValue_type > p);

      // Constructors.
      //
      StraightnessCharacteristicDefinitionType ();

      StraightnessCharacteristicDefinitionType (const id_type&,
                                                const ZoneShape_type&);

      StraightnessCharacteristicDefinitionType (const id_type&,
                                                ::std::unique_ptr< ZoneShape_type >);

      StraightnessCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      StraightnessCharacteristicDefinitionType (const StraightnessCharacteristicDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual StraightnessCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StraightnessCharacteristicDefinitionType&
      operator= (const StraightnessCharacteristicDefinitionType& x);

      virtual 
      ~StraightnessCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ToleranceValue_optional ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      ToleranceZonePerUnitLength_optional ToleranceZonePerUnitLength_;
      MaterialCondition_optional MaterialCondition_;
      SizeCharacteristicDefinitionId_optional SizeCharacteristicDefinitionId_;
      ::xsd::cxx::tree::one< ZoneShape_type > ZoneShape_;
      MaximumToleranceValue_optional MaximumToleranceValue_;
    };

    class QIF30_SYMBOL_DECL StraightnessCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // DirectionCurveId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DirectionCurveId_type;
      typedef ::xsd::cxx::tree::optional< DirectionCurveId_type > DirectionCurveId_optional;
      typedef ::xsd::cxx::tree::traits< DirectionCurveId_type, wchar_t > DirectionCurveId_traits;

      const DirectionCurveId_optional&
      DirectionCurveId () const;

      DirectionCurveId_optional&
      DirectionCurveId ();

      void
      DirectionCurveId (const DirectionCurveId_type& x);

      void
      DirectionCurveId (const DirectionCurveId_optional& x);

      void
      DirectionCurveId (::std::unique_ptr< DirectionCurveId_type > p);

      // Constructors.
      //
      StraightnessCharacteristicNominalType ();

      StraightnessCharacteristicNominalType (const id_type&,
                                             const CharacteristicDefinitionId_type&);

      StraightnessCharacteristicNominalType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >);

      StraightnessCharacteristicNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      StraightnessCharacteristicNominalType (const StraightnessCharacteristicNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual StraightnessCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StraightnessCharacteristicNominalType&
      operator= (const StraightnessCharacteristicNominalType& x);

      virtual 
      ~StraightnessCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DirectionCurveId_optional DirectionCurveId_;
    };

    class QIF30_SYMBOL_DECL StraightnessCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // Bonus
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Bonus_type;
      typedef ::xsd::cxx::tree::optional< Bonus_type > Bonus_optional;
      typedef ::xsd::cxx::tree::traits< Bonus_type, wchar_t > Bonus_traits;

      const Bonus_optional&
      Bonus () const;

      Bonus_optional&
      Bonus ();

      void
      Bonus (const Bonus_type& x);

      void
      Bonus (const Bonus_optional& x);

      void
      Bonus (::std::unique_ptr< Bonus_type > p);

      // MaxStraightness
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxStraightness_type;
      typedef ::xsd::cxx::tree::optional< MaxStraightness_type > MaxStraightness_optional;
      typedef ::xsd::cxx::tree::traits< MaxStraightness_type, wchar_t > MaxStraightness_traits;

      const MaxStraightness_optional&
      MaxStraightness () const;

      MaxStraightness_optional&
      MaxStraightness ();

      void
      MaxStraightness (const MaxStraightness_type& x);

      void
      MaxStraightness (const MaxStraightness_optional& x);

      void
      MaxStraightness (::std::unique_ptr< MaxStraightness_type > p);

      // ZoneOrientation
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType ZoneOrientation_type;
      typedef ::xsd::cxx::tree::optional< ZoneOrientation_type > ZoneOrientation_optional;
      typedef ::xsd::cxx::tree::traits< ZoneOrientation_type, wchar_t > ZoneOrientation_traits;

      const ZoneOrientation_optional&
      ZoneOrientation () const;

      ZoneOrientation_optional&
      ZoneOrientation ();

      void
      ZoneOrientation (const ZoneOrientation_type& x);

      void
      ZoneOrientation (const ZoneOrientation_optional& x);

      void
      ZoneOrientation (::std::unique_ptr< ZoneOrientation_type > p);

      // ZoneLine
      //
      typedef ::xsd::qif30::MeasuredZoneAxisType ZoneLine_type;
      typedef ::xsd::cxx::tree::optional< ZoneLine_type > ZoneLine_optional;
      typedef ::xsd::cxx::tree::traits< ZoneLine_type, wchar_t > ZoneLine_traits;

      const ZoneLine_optional&
      ZoneLine () const;

      ZoneLine_optional&
      ZoneLine ();

      void
      ZoneLine (const ZoneLine_type& x);

      void
      ZoneLine (const ZoneLine_optional& x);

      void
      ZoneLine (::std::unique_ptr< ZoneLine_type > p);

      // Constructors.
      //
      StraightnessCharacteristicMeasurementType ();

      StraightnessCharacteristicMeasurementType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&);

      StraightnessCharacteristicMeasurementType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >);

      StraightnessCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      StraightnessCharacteristicMeasurementType (const StraightnessCharacteristicMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual StraightnessCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StraightnessCharacteristicMeasurementType&
      operator= (const StraightnessCharacteristicMeasurementType& x);

      virtual 
      ~StraightnessCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Bonus_optional Bonus_;
      MaxStraightness_optional MaxStraightness_;
      ZoneOrientation_optional ZoneOrientation_;
      ZoneLine_optional ZoneLine_;
    };

    class QIF30_SYMBOL_DECL FlatnessCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      FlatnessCharacteristicItemType ();

      FlatnessCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      FlatnessCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      FlatnessCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      FlatnessCharacteristicItemType (const FlatnessCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual FlatnessCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FlatnessCharacteristicItemType&
      operator= (const FlatnessCharacteristicItemType&) = default;
#endif

      virtual 
      ~FlatnessCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL FlatnessCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceValue_type > ToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_optional&
      ToleranceValue () const;

      ToleranceValue_optional&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (const ToleranceValue_optional& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // ToleranceZonePerUnitArea
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitAreaType ToleranceZonePerUnitArea_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitArea_type > ToleranceZonePerUnitArea_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitArea_type, wchar_t > ToleranceZonePerUnitArea_traits;

      const ToleranceZonePerUnitArea_optional&
      ToleranceZonePerUnitArea () const;

      ToleranceZonePerUnitArea_optional&
      ToleranceZonePerUnitArea ();

      void
      ToleranceZonePerUnitArea (const ToleranceZonePerUnitArea_type& x);

      void
      ToleranceZonePerUnitArea (const ToleranceZonePerUnitArea_optional& x);

      void
      ToleranceZonePerUnitArea (::std::unique_ptr< ToleranceZonePerUnitArea_type > p);

      // MaterialCondition
      //
      typedef ::xsd::qif30::MaterialModifierEnumType MaterialCondition_type;
      typedef ::xsd::cxx::tree::optional< MaterialCondition_type > MaterialCondition_optional;
      typedef ::xsd::cxx::tree::traits< MaterialCondition_type, wchar_t > MaterialCondition_traits;

      const MaterialCondition_optional&
      MaterialCondition () const;

      MaterialCondition_optional&
      MaterialCondition ();

      void
      MaterialCondition (const MaterialCondition_type& x);

      void
      MaterialCondition (const MaterialCondition_optional& x);

      void
      MaterialCondition (::std::unique_ptr< MaterialCondition_type > p);

      // SizeCharacteristicDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceType SizeCharacteristicDefinitionId_type;
      typedef ::xsd::cxx::tree::optional< SizeCharacteristicDefinitionId_type > SizeCharacteristicDefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< SizeCharacteristicDefinitionId_type, wchar_t > SizeCharacteristicDefinitionId_traits;

      const SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId () const;

      SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId ();

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_type& x);

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_optional& x);

      void
      SizeCharacteristicDefinitionId (::std::unique_ptr< SizeCharacteristicDefinitionId_type > p);

      // MaximumToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType MaximumToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< MaximumToleranceValue_type > MaximumToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< MaximumToleranceValue_type, wchar_t > MaximumToleranceValue_traits;

      const MaximumToleranceValue_optional&
      MaximumToleranceValue () const;

      MaximumToleranceValue_optional&
      MaximumToleranceValue ();

      void
      MaximumToleranceValue (const MaximumToleranceValue_type& x);

      void
      MaximumToleranceValue (const MaximumToleranceValue_optional& x);

      void
      MaximumToleranceValue (::std::unique_ptr< MaximumToleranceValue_type > p);

      // NotConvex
      //
      typedef ::xml_schema::boolean NotConvex_type;
      typedef ::xsd::cxx::tree::optional< NotConvex_type > NotConvex_optional;
      typedef ::xsd::cxx::tree::traits< NotConvex_type, wchar_t > NotConvex_traits;

      const NotConvex_optional&
      NotConvex () const;

      NotConvex_optional&
      NotConvex ();

      void
      NotConvex (const NotConvex_type& x);

      void
      NotConvex (const NotConvex_optional& x);

      // Constructors.
      //
      FlatnessCharacteristicDefinitionType ();

      FlatnessCharacteristicDefinitionType (const id_type&);

      FlatnessCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      FlatnessCharacteristicDefinitionType (const FlatnessCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual FlatnessCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FlatnessCharacteristicDefinitionType&
      operator= (const FlatnessCharacteristicDefinitionType& x);

      virtual 
      ~FlatnessCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ToleranceValue_optional ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      ToleranceZonePerUnitArea_optional ToleranceZonePerUnitArea_;
      MaterialCondition_optional MaterialCondition_;
      SizeCharacteristicDefinitionId_optional SizeCharacteristicDefinitionId_;
      MaximumToleranceValue_optional MaximumToleranceValue_;
      NotConvex_optional NotConvex_;
    };

    class QIF30_SYMBOL_DECL FlatnessCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      FlatnessCharacteristicNominalType ();

      FlatnessCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      FlatnessCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      FlatnessCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      FlatnessCharacteristicNominalType (const FlatnessCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual FlatnessCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FlatnessCharacteristicNominalType&
      operator= (const FlatnessCharacteristicNominalType&) = default;
#endif

      virtual 
      ~FlatnessCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL FlatnessCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // Bonus
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Bonus_type;
      typedef ::xsd::cxx::tree::optional< Bonus_type > Bonus_optional;
      typedef ::xsd::cxx::tree::traits< Bonus_type, wchar_t > Bonus_traits;

      const Bonus_optional&
      Bonus () const;

      Bonus_optional&
      Bonus ();

      void
      Bonus (const Bonus_type& x);

      void
      Bonus (const Bonus_optional& x);

      void
      Bonus (::std::unique_ptr< Bonus_type > p);

      // MaxFlatness
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxFlatness_type;
      typedef ::xsd::cxx::tree::optional< MaxFlatness_type > MaxFlatness_optional;
      typedef ::xsd::cxx::tree::traits< MaxFlatness_type, wchar_t > MaxFlatness_traits;

      const MaxFlatness_optional&
      MaxFlatness () const;

      MaxFlatness_optional&
      MaxFlatness ();

      void
      MaxFlatness (const MaxFlatness_type& x);

      void
      MaxFlatness (const MaxFlatness_optional& x);

      void
      MaxFlatness (::std::unique_ptr< MaxFlatness_type > p);

      // ZonePlane
      //
      typedef ::xsd::qif30::MeasuredPlaneType ZonePlane_type;
      typedef ::xsd::cxx::tree::optional< ZonePlane_type > ZonePlane_optional;
      typedef ::xsd::cxx::tree::traits< ZonePlane_type, wchar_t > ZonePlane_traits;

      const ZonePlane_optional&
      ZonePlane () const;

      ZonePlane_optional&
      ZonePlane ();

      void
      ZonePlane (const ZonePlane_type& x);

      void
      ZonePlane (const ZonePlane_optional& x);

      void
      ZonePlane (::std::unique_ptr< ZonePlane_type > p);

      // Constructors.
      //
      FlatnessCharacteristicMeasurementType ();

      FlatnessCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      FlatnessCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      FlatnessCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      FlatnessCharacteristicMeasurementType (const FlatnessCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual FlatnessCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FlatnessCharacteristicMeasurementType&
      operator= (const FlatnessCharacteristicMeasurementType& x);

      virtual 
      ~FlatnessCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Bonus_optional Bonus_;
      MaxFlatness_optional MaxFlatness_;
      ZonePlane_optional ZonePlane_;
    };

    class QIF30_SYMBOL_DECL CircularityCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      CircularityCharacteristicItemType ();

      CircularityCharacteristicItemType (const id_type&,
                                         const CharacteristicNominalId_type&);

      CircularityCharacteristicItemType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      CircularityCharacteristicItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CircularityCharacteristicItemType (const CircularityCharacteristicItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CircularityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CircularityCharacteristicItemType&
      operator= (const CircularityCharacteristicItemType&) = default;
#endif

      virtual 
      ~CircularityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL CircularityCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceValue_type > ToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_optional&
      ToleranceValue () const;

      ToleranceValue_optional&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (const ToleranceValue_optional& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // ToleranceZonePerUnitAngle
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitAngleType ToleranceZonePerUnitAngle_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitAngle_type > ToleranceZonePerUnitAngle_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitAngle_type, wchar_t > ToleranceZonePerUnitAngle_traits;

      const ToleranceZonePerUnitAngle_optional&
      ToleranceZonePerUnitAngle () const;

      ToleranceZonePerUnitAngle_optional&
      ToleranceZonePerUnitAngle ();

      void
      ToleranceZonePerUnitAngle (const ToleranceZonePerUnitAngle_type& x);

      void
      ToleranceZonePerUnitAngle (const ToleranceZonePerUnitAngle_optional& x);

      void
      ToleranceZonePerUnitAngle (::std::unique_ptr< ToleranceZonePerUnitAngle_type > p);

      // ToleranceZonePerUnitArcLength
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitLengthType ToleranceZonePerUnitArcLength_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitArcLength_type > ToleranceZonePerUnitArcLength_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitArcLength_type, wchar_t > ToleranceZonePerUnitArcLength_traits;

      const ToleranceZonePerUnitArcLength_optional&
      ToleranceZonePerUnitArcLength () const;

      ToleranceZonePerUnitArcLength_optional&
      ToleranceZonePerUnitArcLength ();

      void
      ToleranceZonePerUnitArcLength (const ToleranceZonePerUnitArcLength_type& x);

      void
      ToleranceZonePerUnitArcLength (const ToleranceZonePerUnitArcLength_optional& x);

      void
      ToleranceZonePerUnitArcLength (::std::unique_ptr< ToleranceZonePerUnitArcLength_type > p);

      // Constructors.
      //
      CircularityCharacteristicDefinitionType ();

      CircularityCharacteristicDefinitionType (const id_type&);

      CircularityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CircularityCharacteristicDefinitionType (const CircularityCharacteristicDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CircularityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularityCharacteristicDefinitionType&
      operator= (const CircularityCharacteristicDefinitionType& x);

      virtual 
      ~CircularityCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ToleranceValue_optional ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      ToleranceZonePerUnitAngle_optional ToleranceZonePerUnitAngle_;
      ToleranceZonePerUnitArcLength_optional ToleranceZonePerUnitArcLength_;
    };

    class QIF30_SYMBOL_DECL CircularityCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // ProfileCurveId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ProfileCurveId_type;
      typedef ::xsd::cxx::tree::optional< ProfileCurveId_type > ProfileCurveId_optional;
      typedef ::xsd::cxx::tree::traits< ProfileCurveId_type, wchar_t > ProfileCurveId_traits;

      const ProfileCurveId_optional&
      ProfileCurveId () const;

      ProfileCurveId_optional&
      ProfileCurveId ();

      void
      ProfileCurveId (const ProfileCurveId_type& x);

      void
      ProfileCurveId (const ProfileCurveId_optional& x);

      void
      ProfileCurveId (::std::unique_ptr< ProfileCurveId_type > p);

      // Constructors.
      //
      CircularityCharacteristicNominalType ();

      CircularityCharacteristicNominalType (const id_type&,
                                            const CharacteristicDefinitionId_type&);

      CircularityCharacteristicNominalType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >);

      CircularityCharacteristicNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CircularityCharacteristicNominalType (const CircularityCharacteristicNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CircularityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularityCharacteristicNominalType&
      operator= (const CircularityCharacteristicNominalType& x);

      virtual 
      ~CircularityCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ProfileCurveId_optional ProfileCurveId_;
    };

    class QIF30_SYMBOL_DECL CircularityCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // MaxCircularity
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxCircularity_type;
      typedef ::xsd::cxx::tree::optional< MaxCircularity_type > MaxCircularity_optional;
      typedef ::xsd::cxx::tree::traits< MaxCircularity_type, wchar_t > MaxCircularity_traits;

      const MaxCircularity_optional&
      MaxCircularity () const;

      MaxCircularity_optional&
      MaxCircularity ();

      void
      MaxCircularity (const MaxCircularity_type& x);

      void
      MaxCircularity (const MaxCircularity_optional& x);

      void
      MaxCircularity (::std::unique_ptr< MaxCircularity_type > p);

      // ZoneRadii
      //
      typedef ::xsd::qif30::MeasuredZoneRadiiType ZoneRadii_type;
      typedef ::xsd::cxx::tree::optional< ZoneRadii_type > ZoneRadii_optional;
      typedef ::xsd::cxx::tree::traits< ZoneRadii_type, wchar_t > ZoneRadii_traits;

      const ZoneRadii_optional&
      ZoneRadii () const;

      ZoneRadii_optional&
      ZoneRadii ();

      void
      ZoneRadii (const ZoneRadii_type& x);

      void
      ZoneRadii (const ZoneRadii_optional& x);

      void
      ZoneRadii (::std::unique_ptr< ZoneRadii_type > p);

      // ZonePlane
      //
      typedef ::xsd::qif30::MeasuredPlaneType ZonePlane_type;
      typedef ::xsd::cxx::tree::optional< ZonePlane_type > ZonePlane_optional;
      typedef ::xsd::cxx::tree::traits< ZonePlane_type, wchar_t > ZonePlane_traits;

      const ZonePlane_optional&
      ZonePlane () const;

      ZonePlane_optional&
      ZonePlane ();

      void
      ZonePlane (const ZonePlane_type& x);

      void
      ZonePlane (const ZonePlane_optional& x);

      void
      ZonePlane (::std::unique_ptr< ZonePlane_type > p);

      // Constructors.
      //
      CircularityCharacteristicMeasurementType ();

      CircularityCharacteristicMeasurementType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      CircularityCharacteristicMeasurementType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      CircularityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      CircularityCharacteristicMeasurementType (const CircularityCharacteristicMeasurementType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual CircularityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularityCharacteristicMeasurementType&
      operator= (const CircularityCharacteristicMeasurementType& x);

      virtual 
      ~CircularityCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxCircularity_optional MaxCircularity_;
      ZoneRadii_optional ZoneRadii_;
      ZonePlane_optional ZonePlane_;
    };

    class QIF30_SYMBOL_DECL ConicityCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ConicityCharacteristicItemType ();

      ConicityCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      ConicityCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      ConicityCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ConicityCharacteristicItemType (const ConicityCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ConicityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConicityCharacteristicItemType&
      operator= (const ConicityCharacteristicItemType&) = default;
#endif

      virtual 
      ~ConicityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ConicityCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // Constructors.
      //
      ConicityCharacteristicDefinitionType ();

      ConicityCharacteristicDefinitionType (const id_type&,
                                            const ToleranceValue_type&);

      ConicityCharacteristicDefinitionType (const id_type&,
                                            ::std::unique_ptr< ToleranceValue_type >);

      ConicityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ConicityCharacteristicDefinitionType (const ConicityCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ConicityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicityCharacteristicDefinitionType&
      operator= (const ConicityCharacteristicDefinitionType& x);

      virtual 
      ~ConicityCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
    };

    class QIF30_SYMBOL_DECL ConicityCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      ConicityCharacteristicNominalType ();

      ConicityCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      ConicityCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ConicityCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ConicityCharacteristicNominalType (const ConicityCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ConicityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConicityCharacteristicNominalType&
      operator= (const ConicityCharacteristicNominalType&) = default;
#endif

      virtual 
      ~ConicityCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL ConicityCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      ConicityCharacteristicMeasurementType ();

      ConicityCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      ConicityCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      ConicityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ConicityCharacteristicMeasurementType (const ConicityCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ConicityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConicityCharacteristicMeasurementType&
      operator= (const ConicityCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~ConicityCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL CylindricityCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      CylindricityCharacteristicItemType ();

      CylindricityCharacteristicItemType (const id_type&,
                                          const CharacteristicNominalId_type&);

      CylindricityCharacteristicItemType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >);

      CylindricityCharacteristicItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CylindricityCharacteristicItemType (const CylindricityCharacteristicItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual CylindricityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CylindricityCharacteristicItemType&
      operator= (const CylindricityCharacteristicItemType&) = default;
#endif

      virtual 
      ~CylindricityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL CylindricityCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceValue_type > ToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_optional&
      ToleranceValue () const;

      ToleranceValue_optional&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (const ToleranceValue_optional& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // ToleranceZonePerUnitAngle
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitAngleType ToleranceZonePerUnitAngle_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitAngle_type > ToleranceZonePerUnitAngle_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitAngle_type, wchar_t > ToleranceZonePerUnitAngle_traits;

      const ToleranceZonePerUnitAngle_optional&
      ToleranceZonePerUnitAngle () const;

      ToleranceZonePerUnitAngle_optional&
      ToleranceZonePerUnitAngle ();

      void
      ToleranceZonePerUnitAngle (const ToleranceZonePerUnitAngle_type& x);

      void
      ToleranceZonePerUnitAngle (const ToleranceZonePerUnitAngle_optional& x);

      void
      ToleranceZonePerUnitAngle (::std::unique_ptr< ToleranceZonePerUnitAngle_type > p);

      // ToleranceZonePerUnitArcLength
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitLengthType ToleranceZonePerUnitArcLength_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitArcLength_type > ToleranceZonePerUnitArcLength_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitArcLength_type, wchar_t > ToleranceZonePerUnitArcLength_traits;

      const ToleranceZonePerUnitArcLength_optional&
      ToleranceZonePerUnitArcLength () const;

      ToleranceZonePerUnitArcLength_optional&
      ToleranceZonePerUnitArcLength ();

      void
      ToleranceZonePerUnitArcLength (const ToleranceZonePerUnitArcLength_type& x);

      void
      ToleranceZonePerUnitArcLength (const ToleranceZonePerUnitArcLength_optional& x);

      void
      ToleranceZonePerUnitArcLength (::std::unique_ptr< ToleranceZonePerUnitArcLength_type > p);

      // ToleranceZonePerUnitPolarArea
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitPolarAreaType ToleranceZonePerUnitPolarArea_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitPolarArea_type > ToleranceZonePerUnitPolarArea_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitPolarArea_type, wchar_t > ToleranceZonePerUnitPolarArea_traits;

      const ToleranceZonePerUnitPolarArea_optional&
      ToleranceZonePerUnitPolarArea () const;

      ToleranceZonePerUnitPolarArea_optional&
      ToleranceZonePerUnitPolarArea ();

      void
      ToleranceZonePerUnitPolarArea (const ToleranceZonePerUnitPolarArea_type& x);

      void
      ToleranceZonePerUnitPolarArea (const ToleranceZonePerUnitPolarArea_optional& x);

      void
      ToleranceZonePerUnitPolarArea (::std::unique_ptr< ToleranceZonePerUnitPolarArea_type > p);

      // ToleranceZonePerUnitArea
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitAreaType ToleranceZonePerUnitArea_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitArea_type > ToleranceZonePerUnitArea_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitArea_type, wchar_t > ToleranceZonePerUnitArea_traits;

      const ToleranceZonePerUnitArea_optional&
      ToleranceZonePerUnitArea () const;

      ToleranceZonePerUnitArea_optional&
      ToleranceZonePerUnitArea ();

      void
      ToleranceZonePerUnitArea (const ToleranceZonePerUnitArea_type& x);

      void
      ToleranceZonePerUnitArea (const ToleranceZonePerUnitArea_optional& x);

      void
      ToleranceZonePerUnitArea (::std::unique_ptr< ToleranceZonePerUnitArea_type > p);

      // ToleranceZonePerUnitLength
      //
      typedef ::xsd::qif30::ToleranceZonePerUnitLengthType ToleranceZonePerUnitLength_type;
      typedef ::xsd::cxx::tree::optional< ToleranceZonePerUnitLength_type > ToleranceZonePerUnitLength_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceZonePerUnitLength_type, wchar_t > ToleranceZonePerUnitLength_traits;

      const ToleranceZonePerUnitLength_optional&
      ToleranceZonePerUnitLength () const;

      ToleranceZonePerUnitLength_optional&
      ToleranceZonePerUnitLength ();

      void
      ToleranceZonePerUnitLength (const ToleranceZonePerUnitLength_type& x);

      void
      ToleranceZonePerUnitLength (const ToleranceZonePerUnitLength_optional& x);

      void
      ToleranceZonePerUnitLength (::std::unique_ptr< ToleranceZonePerUnitLength_type > p);

      // Constructors.
      //
      CylindricityCharacteristicDefinitionType ();

      CylindricityCharacteristicDefinitionType (const id_type&);

      CylindricityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      CylindricityCharacteristicDefinitionType (const CylindricityCharacteristicDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual CylindricityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricityCharacteristicDefinitionType&
      operator= (const CylindricityCharacteristicDefinitionType& x);

      virtual 
      ~CylindricityCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ToleranceValue_optional ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      ToleranceZonePerUnitAngle_optional ToleranceZonePerUnitAngle_;
      ToleranceZonePerUnitArcLength_optional ToleranceZonePerUnitArcLength_;
      ToleranceZonePerUnitPolarArea_optional ToleranceZonePerUnitPolarArea_;
      ToleranceZonePerUnitArea_optional ToleranceZonePerUnitArea_;
      ToleranceZonePerUnitLength_optional ToleranceZonePerUnitLength_;
    };

    class QIF30_SYMBOL_DECL CylindricityCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      CylindricityCharacteristicNominalType ();

      CylindricityCharacteristicNominalType (const id_type&,
                                             const CharacteristicDefinitionId_type&);

      CylindricityCharacteristicNominalType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >);

      CylindricityCharacteristicNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CylindricityCharacteristicNominalType (const CylindricityCharacteristicNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual CylindricityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CylindricityCharacteristicNominalType&
      operator= (const CylindricityCharacteristicNominalType&) = default;
#endif

      virtual 
      ~CylindricityCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL CylindricityCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // MaxCylindricity
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxCylindricity_type;
      typedef ::xsd::cxx::tree::optional< MaxCylindricity_type > MaxCylindricity_optional;
      typedef ::xsd::cxx::tree::traits< MaxCylindricity_type, wchar_t > MaxCylindricity_traits;

      const MaxCylindricity_optional&
      MaxCylindricity () const;

      MaxCylindricity_optional&
      MaxCylindricity ();

      void
      MaxCylindricity (const MaxCylindricity_type& x);

      void
      MaxCylindricity (const MaxCylindricity_optional& x);

      void
      MaxCylindricity (::std::unique_ptr< MaxCylindricity_type > p);

      // ZoneRadii
      //
      typedef ::xsd::qif30::MeasuredZoneRadiiType ZoneRadii_type;
      typedef ::xsd::cxx::tree::optional< ZoneRadii_type > ZoneRadii_optional;
      typedef ::xsd::cxx::tree::traits< ZoneRadii_type, wchar_t > ZoneRadii_traits;

      const ZoneRadii_optional&
      ZoneRadii () const;

      ZoneRadii_optional&
      ZoneRadii ();

      void
      ZoneRadii (const ZoneRadii_type& x);

      void
      ZoneRadii (const ZoneRadii_optional& x);

      void
      ZoneRadii (::std::unique_ptr< ZoneRadii_type > p);

      // ZoneAxis
      //
      typedef ::xsd::qif30::MeasuredZoneAxisType ZoneAxis_type;
      typedef ::xsd::cxx::tree::optional< ZoneAxis_type > ZoneAxis_optional;
      typedef ::xsd::cxx::tree::traits< ZoneAxis_type, wchar_t > ZoneAxis_traits;

      const ZoneAxis_optional&
      ZoneAxis () const;

      ZoneAxis_optional&
      ZoneAxis ();

      void
      ZoneAxis (const ZoneAxis_type& x);

      void
      ZoneAxis (const ZoneAxis_optional& x);

      void
      ZoneAxis (::std::unique_ptr< ZoneAxis_type > p);

      // Constructors.
      //
      CylindricityCharacteristicMeasurementType ();

      CylindricityCharacteristicMeasurementType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&);

      CylindricityCharacteristicMeasurementType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >);

      CylindricityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      CylindricityCharacteristicMeasurementType (const CylindricityCharacteristicMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual CylindricityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricityCharacteristicMeasurementType&
      operator= (const CylindricityCharacteristicMeasurementType& x);

      virtual 
      ~CylindricityCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxCylindricity_optional MaxCylindricity_;
      ZoneRadii_optional ZoneRadii_;
      ZoneAxis_optional ZoneAxis_;
    };

    class QIF30_SYMBOL_DECL EllipticityCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      EllipticityCharacteristicItemType ();

      EllipticityCharacteristicItemType (const id_type&,
                                         const CharacteristicNominalId_type&);

      EllipticityCharacteristicItemType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      EllipticityCharacteristicItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      EllipticityCharacteristicItemType (const EllipticityCharacteristicItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual EllipticityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      EllipticityCharacteristicItemType&
      operator= (const EllipticityCharacteristicItemType&) = default;
#endif

      virtual 
      ~EllipticityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL EllipticityCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // Constructors.
      //
      EllipticityCharacteristicDefinitionType ();

      EllipticityCharacteristicDefinitionType (const id_type&,
                                               const ToleranceValue_type&);

      EllipticityCharacteristicDefinitionType (const id_type&,
                                               ::std::unique_ptr< ToleranceValue_type >);

      EllipticityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      EllipticityCharacteristicDefinitionType (const EllipticityCharacteristicDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual EllipticityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticityCharacteristicDefinitionType&
      operator= (const EllipticityCharacteristicDefinitionType& x);

      virtual 
      ~EllipticityCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
    };

    class QIF30_SYMBOL_DECL EllipticityCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      EllipticityCharacteristicNominalType ();

      EllipticityCharacteristicNominalType (const id_type&,
                                            const CharacteristicDefinitionId_type&);

      EllipticityCharacteristicNominalType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >);

      EllipticityCharacteristicNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      EllipticityCharacteristicNominalType (const EllipticityCharacteristicNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual EllipticityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      EllipticityCharacteristicNominalType&
      operator= (const EllipticityCharacteristicNominalType&) = default;
#endif

      virtual 
      ~EllipticityCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL EllipticityCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      EllipticityCharacteristicMeasurementType ();

      EllipticityCharacteristicMeasurementType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      EllipticityCharacteristicMeasurementType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      EllipticityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      EllipticityCharacteristicMeasurementType (const EllipticityCharacteristicMeasurementType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual EllipticityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      EllipticityCharacteristicMeasurementType&
      operator= (const EllipticityCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~EllipticityCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL SphericityCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SphericityCharacteristicItemType ();

      SphericityCharacteristicItemType (const id_type&,
                                        const CharacteristicNominalId_type&);

      SphericityCharacteristicItemType (const id_type&,
                                        ::std::unique_ptr< CharacteristicNominalId_type >);

      SphericityCharacteristicItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      SphericityCharacteristicItemType (const SphericityCharacteristicItemType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual SphericityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericityCharacteristicItemType&
      operator= (const SphericityCharacteristicItemType&) = default;
#endif

      virtual 
      ~SphericityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL SphericityCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // Constructors.
      //
      SphericityCharacteristicDefinitionType ();

      SphericityCharacteristicDefinitionType (const id_type&,
                                              const ToleranceValue_type&);

      SphericityCharacteristicDefinitionType (const id_type&,
                                              ::std::unique_ptr< ToleranceValue_type >);

      SphericityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      SphericityCharacteristicDefinitionType (const SphericityCharacteristicDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual SphericityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericityCharacteristicDefinitionType&
      operator= (const SphericityCharacteristicDefinitionType& x);

      virtual 
      ~SphericityCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
    };

    class QIF30_SYMBOL_DECL SphericityCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      SphericityCharacteristicNominalType ();

      SphericityCharacteristicNominalType (const id_type&,
                                           const CharacteristicDefinitionId_type&);

      SphericityCharacteristicNominalType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SphericityCharacteristicNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      SphericityCharacteristicNominalType (const SphericityCharacteristicNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual SphericityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericityCharacteristicNominalType&
      operator= (const SphericityCharacteristicNominalType&) = default;
#endif

      virtual 
      ~SphericityCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL SphericityCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // ZoneRadii
      //
      typedef ::xsd::qif30::MeasuredZoneRadiiType ZoneRadii_type;
      typedef ::xsd::cxx::tree::optional< ZoneRadii_type > ZoneRadii_optional;
      typedef ::xsd::cxx::tree::traits< ZoneRadii_type, wchar_t > ZoneRadii_traits;

      const ZoneRadii_optional&
      ZoneRadii () const;

      ZoneRadii_optional&
      ZoneRadii ();

      void
      ZoneRadii (const ZoneRadii_type& x);

      void
      ZoneRadii (const ZoneRadii_optional& x);

      void
      ZoneRadii (::std::unique_ptr< ZoneRadii_type > p);

      // ZonePoint
      //
      typedef ::xsd::qif30::MeasuredPointType ZonePoint_type;
      typedef ::xsd::cxx::tree::optional< ZonePoint_type > ZonePoint_optional;
      typedef ::xsd::cxx::tree::traits< ZonePoint_type, wchar_t > ZonePoint_traits;

      const ZonePoint_optional&
      ZonePoint () const;

      ZonePoint_optional&
      ZonePoint ();

      void
      ZonePoint (const ZonePoint_type& x);

      void
      ZonePoint (const ZonePoint_optional& x);

      void
      ZonePoint (::std::unique_ptr< ZonePoint_type > p);

      // Constructors.
      //
      SphericityCharacteristicMeasurementType ();

      SphericityCharacteristicMeasurementType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&);

      SphericityCharacteristicMeasurementType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >);

      SphericityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      SphericityCharacteristicMeasurementType (const SphericityCharacteristicMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual SphericityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericityCharacteristicMeasurementType&
      operator= (const SphericityCharacteristicMeasurementType& x);

      virtual 
      ~SphericityCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ZoneRadii_optional ZoneRadii_;
      ZonePoint_optional ZonePoint_;
    };

    class QIF30_SYMBOL_DECL ToroidicityCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ToroidicityCharacteristicItemType ();

      ToroidicityCharacteristicItemType (const id_type&,
                                         const CharacteristicNominalId_type&);

      ToroidicityCharacteristicItemType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      ToroidicityCharacteristicItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ToroidicityCharacteristicItemType (const ToroidicityCharacteristicItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ToroidicityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ToroidicityCharacteristicItemType&
      operator= (const ToroidicityCharacteristicItemType&) = default;
#endif

      virtual 
      ~ToroidicityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ToroidicityCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // Constructors.
      //
      ToroidicityCharacteristicDefinitionType ();

      ToroidicityCharacteristicDefinitionType (const id_type&,
                                               const ToleranceValue_type&);

      ToroidicityCharacteristicDefinitionType (const id_type&,
                                               ::std::unique_ptr< ToleranceValue_type >);

      ToroidicityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      ToroidicityCharacteristicDefinitionType (const ToroidicityCharacteristicDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual ToroidicityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidicityCharacteristicDefinitionType&
      operator= (const ToroidicityCharacteristicDefinitionType& x);

      virtual 
      ~ToroidicityCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
    };

    class QIF30_SYMBOL_DECL ToroidicityCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      ToroidicityCharacteristicNominalType ();

      ToroidicityCharacteristicNominalType (const id_type&,
                                            const CharacteristicDefinitionId_type&);

      ToroidicityCharacteristicNominalType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ToroidicityCharacteristicNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ToroidicityCharacteristicNominalType (const ToroidicityCharacteristicNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ToroidicityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ToroidicityCharacteristicNominalType&
      operator= (const ToroidicityCharacteristicNominalType&) = default;
#endif

      virtual 
      ~ToroidicityCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL ToroidicityCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      ToroidicityCharacteristicMeasurementType ();

      ToroidicityCharacteristicMeasurementType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      ToroidicityCharacteristicMeasurementType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      ToroidicityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ToroidicityCharacteristicMeasurementType (const ToroidicityCharacteristicMeasurementType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ToroidicityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ToroidicityCharacteristicMeasurementType&
      operator= (const ToroidicityCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~ToroidicityCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL OtherFormCharacteristicItemType: public ::xsd::qif30::FormCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      OtherFormCharacteristicItemType ();

      OtherFormCharacteristicItemType (const id_type&,
                                       const CharacteristicNominalId_type&);

      OtherFormCharacteristicItemType (const id_type&,
                                       ::std::unique_ptr< CharacteristicNominalId_type >);

      OtherFormCharacteristicItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      OtherFormCharacteristicItemType (const OtherFormCharacteristicItemType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual OtherFormCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherFormCharacteristicItemType&
      operator= (const OtherFormCharacteristicItemType&) = default;
#endif

      virtual 
      ~OtherFormCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL OtherFormCharacteristicDefinitionType: public ::xsd::qif30::FormCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // Constructors.
      //
      OtherFormCharacteristicDefinitionType ();

      OtherFormCharacteristicDefinitionType (const id_type&,
                                             const ToleranceValue_type&);

      OtherFormCharacteristicDefinitionType (const id_type&,
                                             ::std::unique_ptr< ToleranceValue_type >);

      OtherFormCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OtherFormCharacteristicDefinitionType (const OtherFormCharacteristicDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual OtherFormCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherFormCharacteristicDefinitionType&
      operator= (const OtherFormCharacteristicDefinitionType& x);

      virtual 
      ~OtherFormCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
    };

    class QIF30_SYMBOL_DECL OtherFormCharacteristicNominalType: public ::xsd::qif30::FormCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      OtherFormCharacteristicNominalType ();

      OtherFormCharacteristicNominalType (const id_type&,
                                          const CharacteristicDefinitionId_type&);

      OtherFormCharacteristicNominalType (const id_type&,
                                          ::std::unique_ptr< CharacteristicDefinitionId_type >);

      OtherFormCharacteristicNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OtherFormCharacteristicNominalType (const OtherFormCharacteristicNominalType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OtherFormCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherFormCharacteristicNominalType&
      operator= (const OtherFormCharacteristicNominalType&) = default;
#endif

      virtual 
      ~OtherFormCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL OtherFormCharacteristicMeasurementType: public ::xsd::qif30::FormCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      OtherFormCharacteristicMeasurementType ();

      OtherFormCharacteristicMeasurementType (const id_type&,
                                              const Status_type&,
                                              const CharacteristicItemId_type&);

      OtherFormCharacteristicMeasurementType (const id_type&,
                                              ::std::unique_ptr< Status_type >,
                                              ::std::unique_ptr< CharacteristicItemId_type >);

      OtherFormCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OtherFormCharacteristicMeasurementType (const OtherFormCharacteristicMeasurementType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual OtherFormCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherFormCharacteristicMeasurementType&
      operator= (const OtherFormCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~OtherFormCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL LocationCharacteristicItemBaseType: public ::xsd::qif30::GeometricCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      LocationCharacteristicItemBaseType ();

      LocationCharacteristicItemBaseType (const id_type&,
                                          const CharacteristicNominalId_type&);

      LocationCharacteristicItemBaseType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >);

      LocationCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      LocationCharacteristicItemBaseType (const LocationCharacteristicItemBaseType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual LocationCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      LocationCharacteristicItemBaseType&
      operator= (const LocationCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~LocationCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL LocationCharacteristicDefinitionBaseType: public ::xsd::qif30::GeometricCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // DatumReferenceFrameId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumReferenceFrameId_type;
      typedef ::xsd::cxx::tree::optional< DatumReferenceFrameId_type > DatumReferenceFrameId_optional;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameId_type, wchar_t > DatumReferenceFrameId_traits;

      const DatumReferenceFrameId_optional&
      DatumReferenceFrameId () const;

      DatumReferenceFrameId_optional&
      DatumReferenceFrameId ();

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_type& x);

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_optional& x);

      void
      DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > p);

      // Constructors.
      //
      LocationCharacteristicDefinitionBaseType ();

      LocationCharacteristicDefinitionBaseType (const id_type&,
                                                const ToleranceValue_type&);

      LocationCharacteristicDefinitionBaseType (const id_type&,
                                                ::std::unique_ptr< ToleranceValue_type >);

      LocationCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      LocationCharacteristicDefinitionBaseType (const LocationCharacteristicDefinitionBaseType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual LocationCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      LocationCharacteristicDefinitionBaseType&
      operator= (const LocationCharacteristicDefinitionBaseType& x);

      virtual 
      ~LocationCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      DatumReferenceFrameId_optional DatumReferenceFrameId_;
    };

    class QIF30_SYMBOL_DECL LocationCharacteristicNominalBaseType: public ::xsd::qif30::GeometricCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      LocationCharacteristicNominalBaseType ();

      LocationCharacteristicNominalBaseType (const id_type&,
                                             const CharacteristicDefinitionId_type&);

      LocationCharacteristicNominalBaseType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >);

      LocationCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      LocationCharacteristicNominalBaseType (const LocationCharacteristicNominalBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual LocationCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      LocationCharacteristicNominalBaseType&
      operator= (const LocationCharacteristicNominalBaseType&) = default;
#endif

      virtual 
      ~LocationCharacteristicNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL LocationCharacteristicMeasurementBaseType: public ::xsd::qif30::GeometricCharacteristicMeasurementBaseType
    {
      public:
      // ZoneDataSet
      //
      typedef ::xsd::qif30::ZoneDataSetType ZoneDataSet_type;
      typedef ::xsd::cxx::tree::optional< ZoneDataSet_type > ZoneDataSet_optional;
      typedef ::xsd::cxx::tree::traits< ZoneDataSet_type, wchar_t > ZoneDataSet_traits;

      const ZoneDataSet_optional&
      ZoneDataSet () const;

      ZoneDataSet_optional&
      ZoneDataSet ();

      void
      ZoneDataSet (const ZoneDataSet_type& x);

      void
      ZoneDataSet (const ZoneDataSet_optional& x);

      void
      ZoneDataSet (::std::unique_ptr< ZoneDataSet_type > p);

      // DatumsOk
      //
      typedef ::xml_schema::boolean DatumsOk_type;
      typedef ::xsd::cxx::tree::optional< DatumsOk_type > DatumsOk_optional;
      typedef ::xsd::cxx::tree::traits< DatumsOk_type, wchar_t > DatumsOk_traits;

      const DatumsOk_optional&
      DatumsOk () const;

      DatumsOk_optional&
      DatumsOk ();

      void
      DatumsOk (const DatumsOk_type& x);

      void
      DatumsOk (const DatumsOk_optional& x);

      // Constructors.
      //
      LocationCharacteristicMeasurementBaseType ();

      LocationCharacteristicMeasurementBaseType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&);

      LocationCharacteristicMeasurementBaseType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >);

      LocationCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      LocationCharacteristicMeasurementBaseType (const LocationCharacteristicMeasurementBaseType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual LocationCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      LocationCharacteristicMeasurementBaseType&
      operator= (const LocationCharacteristicMeasurementBaseType& x);

      virtual 
      ~LocationCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ZoneDataSet_optional ZoneDataSet_;
      DatumsOk_optional DatumsOk_;
    };

    class QIF30_SYMBOL_DECL PositionCharacteristicItemType: public ::xsd::qif30::LocationCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      PositionCharacteristicItemType ();

      PositionCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      PositionCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      PositionCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PositionCharacteristicItemType (const PositionCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PositionCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PositionCharacteristicItemType&
      operator= (const PositionCharacteristicItemType&) = default;
#endif

      virtual 
      ~PositionCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL PositionSphericalZoneType: public ::xml_schema::type
    {
      public:
      // Dimensionality
      //
      typedef ::xsd::qif30::DimensionCountEnumType Dimensionality_type;
      typedef ::xsd::cxx::tree::optional< Dimensionality_type > Dimensionality_optional;
      typedef ::xsd::cxx::tree::traits< Dimensionality_type, wchar_t > Dimensionality_traits;

      const Dimensionality_optional&
      Dimensionality () const;

      Dimensionality_optional&
      Dimensionality ();

      void
      Dimensionality (const Dimensionality_type& x);

      void
      Dimensionality (const Dimensionality_optional& x);

      void
      Dimensionality (::std::unique_ptr< Dimensionality_type > p);

      static const Dimensionality_type&
      Dimensionality_default_value ();

      // Constructors.
      //
      PositionSphericalZoneType ();

      PositionSphericalZoneType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      PositionSphericalZoneType (const PositionSphericalZoneType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual PositionSphericalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionSphericalZoneType&
      operator= (const PositionSphericalZoneType& x);

      virtual 
      ~PositionSphericalZoneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Dimensionality_optional Dimensionality_;
      static const Dimensionality_type Dimensionality_default_value_;
    };

    class QIF30_SYMBOL_DECL PositionDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // Dimensionality
      //
      typedef ::xsd::qif30::DimensionCountEnumType Dimensionality_type;
      typedef ::xsd::cxx::tree::optional< Dimensionality_type > Dimensionality_optional;
      typedef ::xsd::cxx::tree::traits< Dimensionality_type, wchar_t > Dimensionality_traits;

      const Dimensionality_optional&
      Dimensionality () const;

      Dimensionality_optional&
      Dimensionality ();

      void
      Dimensionality (const Dimensionality_type& x);

      void
      Dimensionality (const Dimensionality_optional& x);

      void
      Dimensionality (::std::unique_ptr< Dimensionality_type > p);

      // ZoneOrientationVector
      //
      typedef ::xsd::qif30::UnitVectorType ZoneOrientationVector_type;
      typedef ::xsd::cxx::tree::optional< ZoneOrientationVector_type > ZoneOrientationVector_optional;
      typedef ::xsd::cxx::tree::traits< ZoneOrientationVector_type, wchar_t > ZoneOrientationVector_traits;

      const ZoneOrientationVector_optional&
      ZoneOrientationVector () const;

      ZoneOrientationVector_optional&
      ZoneOrientationVector ();

      void
      ZoneOrientationVector (const ZoneOrientationVector_type& x);

      void
      ZoneOrientationVector (const ZoneOrientationVector_optional& x);

      void
      ZoneOrientationVector (::std::unique_ptr< ZoneOrientationVector_type > p);

      // ElongatedZone
      //
      typedef ::xml_schema::boolean ElongatedZone_type;
      typedef ::xsd::cxx::tree::optional< ElongatedZone_type > ElongatedZone_optional;
      typedef ::xsd::cxx::tree::traits< ElongatedZone_type, wchar_t > ElongatedZone_traits;

      const ElongatedZone_optional&
      ElongatedZone () const;

      ElongatedZone_optional&
      ElongatedZone ();

      void
      ElongatedZone (const ElongatedZone_type& x);

      void
      ElongatedZone (const ElongatedZone_optional& x);

      // Constructors.
      //
      PositionDiametricalZoneType ();

      PositionDiametricalZoneType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PositionDiametricalZoneType (const PositionDiametricalZoneType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PositionDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionDiametricalZoneType&
      operator= (const PositionDiametricalZoneType& x);

      virtual 
      ~PositionDiametricalZoneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Dimensionality_optional Dimensionality_;
      ZoneOrientationVector_optional ZoneOrientationVector_;
      ElongatedZone_optional ElongatedZone_;
    };

    class QIF30_SYMBOL_DECL PositionNonDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // Dimensionality
      //
      typedef ::xsd::qif30::DimensionCountEnumType Dimensionality_type;
      typedef ::xsd::cxx::tree::optional< Dimensionality_type > Dimensionality_optional;
      typedef ::xsd::cxx::tree::traits< Dimensionality_type, wchar_t > Dimensionality_traits;

      const Dimensionality_optional&
      Dimensionality () const;

      Dimensionality_optional&
      Dimensionality ();

      void
      Dimensionality (const Dimensionality_type& x);

      void
      Dimensionality (const Dimensionality_optional& x);

      void
      Dimensionality (::std::unique_ptr< Dimensionality_type > p);

      // ZoneOrientationVector
      //
      typedef ::xsd::qif30::UnitVectorType ZoneOrientationVector_type;
      typedef ::xsd::cxx::tree::optional< ZoneOrientationVector_type > ZoneOrientationVector_optional;
      typedef ::xsd::cxx::tree::traits< ZoneOrientationVector_type, wchar_t > ZoneOrientationVector_traits;

      const ZoneOrientationVector_optional&
      ZoneOrientationVector () const;

      ZoneOrientationVector_optional&
      ZoneOrientationVector ();

      void
      ZoneOrientationVector (const ZoneOrientationVector_type& x);

      void
      ZoneOrientationVector (const ZoneOrientationVector_optional& x);

      void
      ZoneOrientationVector (::std::unique_ptr< ZoneOrientationVector_type > p);

      // BoundaryZone
      //
      typedef ::xml_schema::boolean BoundaryZone_type;
      typedef ::xsd::cxx::tree::optional< BoundaryZone_type > BoundaryZone_optional;
      typedef ::xsd::cxx::tree::traits< BoundaryZone_type, wchar_t > BoundaryZone_traits;

      const BoundaryZone_optional&
      BoundaryZone () const;

      BoundaryZone_optional&
      BoundaryZone ();

      void
      BoundaryZone (const BoundaryZone_type& x);

      void
      BoundaryZone (const BoundaryZone_optional& x);

      // ZoneOrientationEnum
      //
      typedef ::xsd::qif30::ZoneOrientationEnumType ZoneOrientationEnum_type;
      typedef ::xsd::cxx::tree::optional< ZoneOrientationEnum_type > ZoneOrientationEnum_optional;
      typedef ::xsd::cxx::tree::traits< ZoneOrientationEnum_type, wchar_t > ZoneOrientationEnum_traits;

      const ZoneOrientationEnum_optional&
      ZoneOrientationEnum () const;

      ZoneOrientationEnum_optional&
      ZoneOrientationEnum ();

      void
      ZoneOrientationEnum (const ZoneOrientationEnum_type& x);

      void
      ZoneOrientationEnum (const ZoneOrientationEnum_optional& x);

      void
      ZoneOrientationEnum (::std::unique_ptr< ZoneOrientationEnum_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // Constructors.
      //
      PositionNonDiametricalZoneType ();

      PositionNonDiametricalZoneType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PositionNonDiametricalZoneType (const PositionNonDiametricalZoneType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PositionNonDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionNonDiametricalZoneType&
      operator= (const PositionNonDiametricalZoneType& x);

      virtual 
      ~PositionNonDiametricalZoneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Dimensionality_optional Dimensionality_;
      ZoneOrientationVector_optional ZoneOrientationVector_;
      BoundaryZone_optional BoundaryZone_;
      ZoneOrientationEnum_optional ZoneOrientationEnum_;
      CoordinateSystemId_optional CoordinateSystemId_;
    };

    class QIF30_SYMBOL_DECL PositionZoneShapeType: public ::xml_schema::type
    {
      public:
      // SphericalZone
      //
      typedef ::xsd::qif30::PositionSphericalZoneType SphericalZone_type;
      typedef ::xsd::cxx::tree::optional< SphericalZone_type > SphericalZone_optional;
      typedef ::xsd::cxx::tree::traits< SphericalZone_type, wchar_t > SphericalZone_traits;

      const SphericalZone_optional&
      SphericalZone () const;

      SphericalZone_optional&
      SphericalZone ();

      void
      SphericalZone (const SphericalZone_type& x);

      void
      SphericalZone (const SphericalZone_optional& x);

      void
      SphericalZone (::std::unique_ptr< SphericalZone_type > p);

      // DiametricalZone
      //
      typedef ::xsd::qif30::PositionDiametricalZoneType DiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< DiametricalZone_type > DiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< DiametricalZone_type, wchar_t > DiametricalZone_traits;

      const DiametricalZone_optional&
      DiametricalZone () const;

      DiametricalZone_optional&
      DiametricalZone ();

      void
      DiametricalZone (const DiametricalZone_type& x);

      void
      DiametricalZone (const DiametricalZone_optional& x);

      void
      DiametricalZone (::std::unique_ptr< DiametricalZone_type > p);

      // NonDiametricalZone
      //
      typedef ::xsd::qif30::PositionNonDiametricalZoneType NonDiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< NonDiametricalZone_type > NonDiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< NonDiametricalZone_type, wchar_t > NonDiametricalZone_traits;

      const NonDiametricalZone_optional&
      NonDiametricalZone () const;

      NonDiametricalZone_optional&
      NonDiametricalZone ();

      void
      NonDiametricalZone (const NonDiametricalZone_type& x);

      void
      NonDiametricalZone (const NonDiametricalZone_optional& x);

      void
      NonDiametricalZone (::std::unique_ptr< NonDiametricalZone_type > p);

      // Constructors.
      //
      PositionZoneShapeType ();

      PositionZoneShapeType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      PositionZoneShapeType (const PositionZoneShapeType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual PositionZoneShapeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionZoneShapeType&
      operator= (const PositionZoneShapeType& x);

      virtual 
      ~PositionZoneShapeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SphericalZone_optional SphericalZone_;
      DiametricalZone_optional DiametricalZone_;
      NonDiametricalZone_optional NonDiametricalZone_;
    };

    class QIF30_SYMBOL_DECL PositionCharacteristicDefinitionType: public ::xsd::qif30::LocationCharacteristicDefinitionBaseType
    {
      public:
      // MaterialCondition
      //
      typedef ::xsd::qif30::MaterialModifierEnumType MaterialCondition_type;
      typedef ::xsd::cxx::tree::traits< MaterialCondition_type, wchar_t > MaterialCondition_traits;

      const MaterialCondition_type&
      MaterialCondition () const;

      MaterialCondition_type&
      MaterialCondition ();

      void
      MaterialCondition (const MaterialCondition_type& x);

      void
      MaterialCondition (::std::unique_ptr< MaterialCondition_type > p);

      // SizeCharacteristicDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceType SizeCharacteristicDefinitionId_type;
      typedef ::xsd::cxx::tree::optional< SizeCharacteristicDefinitionId_type > SizeCharacteristicDefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< SizeCharacteristicDefinitionId_type, wchar_t > SizeCharacteristicDefinitionId_traits;

      const SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId () const;

      SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId ();

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_type& x);

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_optional& x);

      void
      SizeCharacteristicDefinitionId (::std::unique_ptr< SizeCharacteristicDefinitionId_type > p);

      // ZoneShape
      //
      typedef ::xsd::qif30::PositionZoneShapeType ZoneShape_type;
      typedef ::xsd::cxx::tree::traits< ZoneShape_type, wchar_t > ZoneShape_traits;

      const ZoneShape_type&
      ZoneShape () const;

      ZoneShape_type&
      ZoneShape ();

      void
      ZoneShape (const ZoneShape_type& x);

      void
      ZoneShape (::std::unique_ptr< ZoneShape_type > p);

      // MaximumToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType MaximumToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< MaximumToleranceValue_type > MaximumToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< MaximumToleranceValue_type, wchar_t > MaximumToleranceValue_traits;

      const MaximumToleranceValue_optional&
      MaximumToleranceValue () const;

      MaximumToleranceValue_optional&
      MaximumToleranceValue ();

      void
      MaximumToleranceValue (const MaximumToleranceValue_type& x);

      void
      MaximumToleranceValue (const MaximumToleranceValue_optional& x);

      void
      MaximumToleranceValue (::std::unique_ptr< MaximumToleranceValue_type > p);

      // ProjectedToleranceZoneValue
      //
      typedef ::xsd::qif30::LinearValueType ProjectedToleranceZoneValue_type;
      typedef ::xsd::cxx::tree::optional< ProjectedToleranceZoneValue_type > ProjectedToleranceZoneValue_optional;
      typedef ::xsd::cxx::tree::traits< ProjectedToleranceZoneValue_type, wchar_t > ProjectedToleranceZoneValue_traits;

      const ProjectedToleranceZoneValue_optional&
      ProjectedToleranceZoneValue () const;

      ProjectedToleranceZoneValue_optional&
      ProjectedToleranceZoneValue ();

      void
      ProjectedToleranceZoneValue (const ProjectedToleranceZoneValue_type& x);

      void
      ProjectedToleranceZoneValue (const ProjectedToleranceZoneValue_optional& x);

      void
      ProjectedToleranceZoneValue (::std::unique_ptr< ProjectedToleranceZoneValue_type > p);

      // SecondCompositeSegmentPositionDefinition
      //
      typedef ::xsd::qif30::CompositeSegmentPositionDefinitionType SecondCompositeSegmentPositionDefinition_type;
      typedef ::xsd::cxx::tree::optional< SecondCompositeSegmentPositionDefinition_type > SecondCompositeSegmentPositionDefinition_optional;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentPositionDefinition_type, wchar_t > SecondCompositeSegmentPositionDefinition_traits;

      const SecondCompositeSegmentPositionDefinition_optional&
      SecondCompositeSegmentPositionDefinition () const;

      SecondCompositeSegmentPositionDefinition_optional&
      SecondCompositeSegmentPositionDefinition ();

      void
      SecondCompositeSegmentPositionDefinition (const SecondCompositeSegmentPositionDefinition_type& x);

      void
      SecondCompositeSegmentPositionDefinition (const SecondCompositeSegmentPositionDefinition_optional& x);

      void
      SecondCompositeSegmentPositionDefinition (::std::unique_ptr< SecondCompositeSegmentPositionDefinition_type > p);

      // ThirdCompositeSegmentPositionDefinition
      //
      typedef ::xsd::qif30::CompositeSegmentPositionDefinitionType ThirdCompositeSegmentPositionDefinition_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentPositionDefinition_type > ThirdCompositeSegmentPositionDefinition_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentPositionDefinition_type, wchar_t > ThirdCompositeSegmentPositionDefinition_traits;

      const ThirdCompositeSegmentPositionDefinition_optional&
      ThirdCompositeSegmentPositionDefinition () const;

      ThirdCompositeSegmentPositionDefinition_optional&
      ThirdCompositeSegmentPositionDefinition ();

      void
      ThirdCompositeSegmentPositionDefinition (const ThirdCompositeSegmentPositionDefinition_type& x);

      void
      ThirdCompositeSegmentPositionDefinition (const ThirdCompositeSegmentPositionDefinition_optional& x);

      void
      ThirdCompositeSegmentPositionDefinition (::std::unique_ptr< ThirdCompositeSegmentPositionDefinition_type > p);

      // FourthCompositeSegmentPositionDefinition
      //
      typedef ::xsd::qif30::CompositeSegmentPositionDefinitionType FourthCompositeSegmentPositionDefinition_type;
      typedef ::xsd::cxx::tree::optional< FourthCompositeSegmentPositionDefinition_type > FourthCompositeSegmentPositionDefinition_optional;
      typedef ::xsd::cxx::tree::traits< FourthCompositeSegmentPositionDefinition_type, wchar_t > FourthCompositeSegmentPositionDefinition_traits;

      const FourthCompositeSegmentPositionDefinition_optional&
      FourthCompositeSegmentPositionDefinition () const;

      FourthCompositeSegmentPositionDefinition_optional&
      FourthCompositeSegmentPositionDefinition ();

      void
      FourthCompositeSegmentPositionDefinition (const FourthCompositeSegmentPositionDefinition_type& x);

      void
      FourthCompositeSegmentPositionDefinition (const FourthCompositeSegmentPositionDefinition_optional& x);

      void
      FourthCompositeSegmentPositionDefinition (::std::unique_ptr< FourthCompositeSegmentPositionDefinition_type > p);

      // ToPointToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToPointToleranceValue_type;
      typedef ::xsd::cxx::tree::optional< ToPointToleranceValue_type > ToPointToleranceValue_optional;
      typedef ::xsd::cxx::tree::traits< ToPointToleranceValue_type, wchar_t > ToPointToleranceValue_traits;

      const ToPointToleranceValue_optional&
      ToPointToleranceValue () const;

      ToPointToleranceValue_optional&
      ToPointToleranceValue ();

      void
      ToPointToleranceValue (const ToPointToleranceValue_type& x);

      void
      ToPointToleranceValue (const ToPointToleranceValue_optional& x);

      void
      ToPointToleranceValue (::std::unique_ptr< ToPointToleranceValue_type > p);

      // OrientationOnly
      //
      typedef ::xml_schema::boolean OrientationOnly_type;
      typedef ::xsd::cxx::tree::optional< OrientationOnly_type > OrientationOnly_optional;
      typedef ::xsd::cxx::tree::traits< OrientationOnly_type, wchar_t > OrientationOnly_traits;

      const OrientationOnly_optional&
      OrientationOnly () const;

      OrientationOnly_optional&
      OrientationOnly ();

      void
      OrientationOnly (const OrientationOnly_type& x);

      void
      OrientationOnly (const OrientationOnly_optional& x);

      // Constructors.
      //
      PositionCharacteristicDefinitionType ();

      PositionCharacteristicDefinitionType (const id_type&,
                                            const ToleranceValue_type&,
                                            const MaterialCondition_type&,
                                            const ZoneShape_type&);

      PositionCharacteristicDefinitionType (const id_type&,
                                            ::std::unique_ptr< ToleranceValue_type >,
                                            const MaterialCondition_type&,
                                            ::std::unique_ptr< ZoneShape_type >);

      PositionCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      PositionCharacteristicDefinitionType (const PositionCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual PositionCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionCharacteristicDefinitionType&
      operator= (const PositionCharacteristicDefinitionType& x);

      virtual 
      ~PositionCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MaterialCondition_type > MaterialCondition_;
      SizeCharacteristicDefinitionId_optional SizeCharacteristicDefinitionId_;
      ::xsd::cxx::tree::one< ZoneShape_type > ZoneShape_;
      MaximumToleranceValue_optional MaximumToleranceValue_;
      ProjectedToleranceZoneValue_optional ProjectedToleranceZoneValue_;
      SecondCompositeSegmentPositionDefinition_optional SecondCompositeSegmentPositionDefinition_;
      ThirdCompositeSegmentPositionDefinition_optional ThirdCompositeSegmentPositionDefinition_;
      FourthCompositeSegmentPositionDefinition_optional FourthCompositeSegmentPositionDefinition_;
      ToPointToleranceValue_optional ToPointToleranceValue_;
      OrientationOnly_optional OrientationOnly_;
    };

    class QIF30_SYMBOL_DECL PositionCharacteristicNominalType: public ::xsd::qif30::LocationCharacteristicNominalBaseType
    {
      public:
      // CoordinateMethod
      //
      typedef ::xsd::qif30::PositionCoordinateMethodType CoordinateMethod_type;
      typedef ::xsd::cxx::tree::optional< CoordinateMethod_type > CoordinateMethod_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateMethod_type, wchar_t > CoordinateMethod_traits;

      const CoordinateMethod_optional&
      CoordinateMethod () const;

      CoordinateMethod_optional&
      CoordinateMethod ();

      void
      CoordinateMethod (const CoordinateMethod_type& x);

      void
      CoordinateMethod (const CoordinateMethod_optional& x);

      void
      CoordinateMethod (::std::unique_ptr< CoordinateMethod_type > p);

      // Constructors.
      //
      PositionCharacteristicNominalType ();

      PositionCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      PositionCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      PositionCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      PositionCharacteristicNominalType (const PositionCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual PositionCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionCharacteristicNominalType&
      operator= (const PositionCharacteristicNominalType& x);

      virtual 
      ~PositionCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CoordinateMethod_optional CoordinateMethod_;
    };

    class QIF30_SYMBOL_DECL PositionCharacteristicMeasurementType: public ::xsd::qif30::LocationCharacteristicMeasurementBaseType
    {
      public:
      // Bonus
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Bonus_type;
      typedef ::xsd::cxx::tree::optional< Bonus_type > Bonus_optional;
      typedef ::xsd::cxx::tree::traits< Bonus_type, wchar_t > Bonus_traits;

      const Bonus_optional&
      Bonus () const;

      Bonus_optional&
      Bonus ();

      void
      Bonus (const Bonus_type& x);

      void
      Bonus (const Bonus_optional& x);

      void
      Bonus (::std::unique_ptr< Bonus_type > p);

      // DRFTransformActualId
      //
      typedef ::xsd::qif30::QIFReferenceType DRFTransformActualId_type;
      typedef ::xsd::cxx::tree::optional< DRFTransformActualId_type > DRFTransformActualId_optional;
      typedef ::xsd::cxx::tree::traits< DRFTransformActualId_type, wchar_t > DRFTransformActualId_traits;

      const DRFTransformActualId_optional&
      DRFTransformActualId () const;

      DRFTransformActualId_optional&
      DRFTransformActualId ();

      void
      DRFTransformActualId (const DRFTransformActualId_type& x);

      void
      DRFTransformActualId (const DRFTransformActualId_optional& x);

      void
      DRFTransformActualId (::std::unique_ptr< DRFTransformActualId_type > p);

      // SecondCompositeSegmentPositionMeasurement
      //
      typedef ::xsd::qif30::CompositeSegmentPositionMeasurementType SecondCompositeSegmentPositionMeasurement_type;
      typedef ::xsd::cxx::tree::optional< SecondCompositeSegmentPositionMeasurement_type > SecondCompositeSegmentPositionMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentPositionMeasurement_type, wchar_t > SecondCompositeSegmentPositionMeasurement_traits;

      const SecondCompositeSegmentPositionMeasurement_optional&
      SecondCompositeSegmentPositionMeasurement () const;

      SecondCompositeSegmentPositionMeasurement_optional&
      SecondCompositeSegmentPositionMeasurement ();

      void
      SecondCompositeSegmentPositionMeasurement (const SecondCompositeSegmentPositionMeasurement_type& x);

      void
      SecondCompositeSegmentPositionMeasurement (const SecondCompositeSegmentPositionMeasurement_optional& x);

      void
      SecondCompositeSegmentPositionMeasurement (::std::unique_ptr< SecondCompositeSegmentPositionMeasurement_type > p);

      // ThirdCompositeSegmentPositionMeasurement
      //
      typedef ::xsd::qif30::CompositeSegmentPositionMeasurementType ThirdCompositeSegmentPositionMeasurement_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentPositionMeasurement_type > ThirdCompositeSegmentPositionMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentPositionMeasurement_type, wchar_t > ThirdCompositeSegmentPositionMeasurement_traits;

      const ThirdCompositeSegmentPositionMeasurement_optional&
      ThirdCompositeSegmentPositionMeasurement () const;

      ThirdCompositeSegmentPositionMeasurement_optional&
      ThirdCompositeSegmentPositionMeasurement ();

      void
      ThirdCompositeSegmentPositionMeasurement (const ThirdCompositeSegmentPositionMeasurement_type& x);

      void
      ThirdCompositeSegmentPositionMeasurement (const ThirdCompositeSegmentPositionMeasurement_optional& x);

      void
      ThirdCompositeSegmentPositionMeasurement (::std::unique_ptr< ThirdCompositeSegmentPositionMeasurement_type > p);

      // FourthCompositeSegmentPositionMeasurement
      //
      typedef ::xsd::qif30::CompositeSegmentPositionMeasurementType FourthCompositeSegmentPositionMeasurement_type;
      typedef ::xsd::cxx::tree::optional< FourthCompositeSegmentPositionMeasurement_type > FourthCompositeSegmentPositionMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< FourthCompositeSegmentPositionMeasurement_type, wchar_t > FourthCompositeSegmentPositionMeasurement_traits;

      const FourthCompositeSegmentPositionMeasurement_optional&
      FourthCompositeSegmentPositionMeasurement () const;

      FourthCompositeSegmentPositionMeasurement_optional&
      FourthCompositeSegmentPositionMeasurement ();

      void
      FourthCompositeSegmentPositionMeasurement (const FourthCompositeSegmentPositionMeasurement_type& x);

      void
      FourthCompositeSegmentPositionMeasurement (const FourthCompositeSegmentPositionMeasurement_optional& x);

      void
      FourthCompositeSegmentPositionMeasurement (::std::unique_ptr< FourthCompositeSegmentPositionMeasurement_type > p);

      // Constructors.
      //
      PositionCharacteristicMeasurementType ();

      PositionCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      PositionCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      PositionCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      PositionCharacteristicMeasurementType (const PositionCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual PositionCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionCharacteristicMeasurementType&
      operator= (const PositionCharacteristicMeasurementType& x);

      virtual 
      ~PositionCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Bonus_optional Bonus_;
      DRFTransformActualId_optional DRFTransformActualId_;
      SecondCompositeSegmentPositionMeasurement_optional SecondCompositeSegmentPositionMeasurement_;
      ThirdCompositeSegmentPositionMeasurement_optional ThirdCompositeSegmentPositionMeasurement_;
      FourthCompositeSegmentPositionMeasurement_optional FourthCompositeSegmentPositionMeasurement_;
    };

    class QIF30_SYMBOL_DECL AngleCharacteristicItemType: public ::xsd::qif30::AngularCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      AngleCharacteristicItemType ();

      AngleCharacteristicItemType (const id_type&,
                                   const CharacteristicNominalId_type&);

      AngleCharacteristicItemType (const id_type&,
                                   ::std::unique_ptr< CharacteristicNominalId_type >);

      AngleCharacteristicItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      AngleCharacteristicItemType (const AngleCharacteristicItemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual AngleCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleCharacteristicItemType&
      operator= (const AngleCharacteristicItemType&) = default;
#endif

      virtual 
      ~AngleCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL AngleCharacteristicDefinitionType: public ::xsd::qif30::AngularCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      AngleCharacteristicDefinitionType ();

      AngleCharacteristicDefinitionType (const id_type&);

      AngleCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      AngleCharacteristicDefinitionType (const AngleCharacteristicDefinitionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual AngleCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleCharacteristicDefinitionType&
      operator= (const AngleCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~AngleCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL AngleCharacteristicNominalType: public ::xsd::qif30::AngularCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      AngleCharacteristicNominalType ();

      AngleCharacteristicNominalType (const id_type&,
                                      const CharacteristicDefinitionId_type&);

      AngleCharacteristicNominalType (const id_type&,
                                      ::std::unique_ptr< CharacteristicDefinitionId_type >);

      AngleCharacteristicNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      AngleCharacteristicNominalType (const AngleCharacteristicNominalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual AngleCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleCharacteristicNominalType&
      operator= (const AngleCharacteristicNominalType&) = default;
#endif

      virtual 
      ~AngleCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL AngleCharacteristicMeasurementType: public ::xsd::qif30::AngularCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      AngleCharacteristicMeasurementType ();

      AngleCharacteristicMeasurementType (const id_type&,
                                          const Status_type&,
                                          const CharacteristicItemId_type&);

      AngleCharacteristicMeasurementType (const id_type&,
                                          ::std::unique_ptr< Status_type >,
                                          ::std::unique_ptr< CharacteristicItemId_type >);

      AngleCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngleCharacteristicMeasurementType (const AngleCharacteristicMeasurementType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual AngleCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleCharacteristicMeasurementType&
      operator= (const AngleCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~AngleCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL AngleFromCharacteristicItemType: public ::xsd::qif30::AngularCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      AngleFromCharacteristicItemType ();

      AngleFromCharacteristicItemType (const id_type&,
                                       const CharacteristicNominalId_type&);

      AngleFromCharacteristicItemType (const id_type&,
                                       ::std::unique_ptr< CharacteristicNominalId_type >);

      AngleFromCharacteristicItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      AngleFromCharacteristicItemType (const AngleFromCharacteristicItemType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual AngleFromCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleFromCharacteristicItemType&
      operator= (const AngleFromCharacteristicItemType&) = default;
#endif

      virtual 
      ~AngleFromCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL AngleFromCharacteristicDefinitionType: public ::xsd::qif30::AngularCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      AngleFromCharacteristicDefinitionType ();

      AngleFromCharacteristicDefinitionType (const id_type&);

      AngleFromCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      AngleFromCharacteristicDefinitionType (const AngleFromCharacteristicDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual AngleFromCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleFromCharacteristicDefinitionType&
      operator= (const AngleFromCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~AngleFromCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL AngleFromCharacteristicNominalType: public ::xsd::qif30::AngularCharacteristicNominalBaseType
    {
      public:
      // OriginReference
      //
      typedef ::xsd::qif30::OriginReferenceType OriginReference_type;
      typedef ::xsd::cxx::tree::optional< OriginReference_type > OriginReference_optional;
      typedef ::xsd::cxx::tree::traits< OriginReference_type, wchar_t > OriginReference_traits;

      const OriginReference_optional&
      OriginReference () const;

      OriginReference_optional&
      OriginReference ();

      void
      OriginReference (const OriginReference_type& x);

      void
      OriginReference (const OriginReference_optional& x);

      void
      OriginReference (::std::unique_ptr< OriginReference_type > p);

      // AnalysisVector
      //
      typedef ::xsd::qif30::UnitVectorType AnalysisVector_type;
      typedef ::xsd::cxx::tree::optional< AnalysisVector_type > AnalysisVector_optional;
      typedef ::xsd::cxx::tree::traits< AnalysisVector_type, wchar_t > AnalysisVector_traits;

      const AnalysisVector_optional&
      AnalysisVector () const;

      AnalysisVector_optional&
      AnalysisVector ();

      void
      AnalysisVector (const AnalysisVector_type& x);

      void
      AnalysisVector (const AnalysisVector_optional& x);

      void
      AnalysisVector (::std::unique_ptr< AnalysisVector_type > p);

      // AnalysisMode
      //
      typedef ::xsd::qif30::AngleBetweenAnalysisModeEnumType AnalysisMode_type;
      typedef ::xsd::cxx::tree::traits< AnalysisMode_type, wchar_t > AnalysisMode_traits;

      const AnalysisMode_type&
      AnalysisMode () const;

      AnalysisMode_type&
      AnalysisMode ();

      void
      AnalysisMode (const AnalysisMode_type& x);

      void
      AnalysisMode (::std::unique_ptr< AnalysisMode_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // MeasurementDirective
      //
      typedef ::xsd::qif30::MeasurementDirectiveType MeasurementDirective_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDirective_type > MeasurementDirective_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDirective_type, wchar_t > MeasurementDirective_traits;

      const MeasurementDirective_optional&
      MeasurementDirective () const;

      MeasurementDirective_optional&
      MeasurementDirective ();

      void
      MeasurementDirective (const MeasurementDirective_type& x);

      void
      MeasurementDirective (const MeasurementDirective_optional& x);

      void
      MeasurementDirective (::std::unique_ptr< MeasurementDirective_type > p);

      // Vertex
      //
      typedef ::xsd::qif30::PointType Vertex_type;
      typedef ::xsd::cxx::tree::optional< Vertex_type > Vertex_optional;
      typedef ::xsd::cxx::tree::traits< Vertex_type, wchar_t > Vertex_traits;

      const Vertex_optional&
      Vertex () const;

      Vertex_optional&
      Vertex ();

      void
      Vertex (const Vertex_type& x);

      void
      Vertex (const Vertex_optional& x);

      void
      Vertex (::std::unique_ptr< Vertex_type > p);

      // Constructors.
      //
      AngleFromCharacteristicNominalType ();

      AngleFromCharacteristicNominalType (const id_type&,
                                          const CharacteristicDefinitionId_type&,
                                          const AnalysisMode_type&);

      AngleFromCharacteristicNominalType (const id_type&,
                                          ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                          const AnalysisMode_type&);

      AngleFromCharacteristicNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngleFromCharacteristicNominalType (const AngleFromCharacteristicNominalType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual AngleFromCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleFromCharacteristicNominalType&
      operator= (const AngleFromCharacteristicNominalType& x);

      virtual 
      ~AngleFromCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      OriginReference_optional OriginReference_;
      AnalysisVector_optional AnalysisVector_;
      ::xsd::cxx::tree::one< AnalysisMode_type > AnalysisMode_;
      CoordinateSystemId_optional CoordinateSystemId_;
      MeasurementDirective_optional MeasurementDirective_;
      Vertex_optional Vertex_;
    };

    class QIF30_SYMBOL_DECL AngleFromCharacteristicMeasurementType: public ::xsd::qif30::AngularCharacteristicMeasurementBaseType
    {
      public:
      // AnalysisVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType AnalysisVector_type;
      typedef ::xsd::cxx::tree::optional< AnalysisVector_type > AnalysisVector_optional;
      typedef ::xsd::cxx::tree::traits< AnalysisVector_type, wchar_t > AnalysisVector_traits;

      const AnalysisVector_optional&
      AnalysisVector () const;

      AnalysisVector_optional&
      AnalysisVector ();

      void
      AnalysisVector (const AnalysisVector_type& x);

      void
      AnalysisVector (const AnalysisVector_optional& x);

      void
      AnalysisVector (::std::unique_ptr< AnalysisVector_type > p);

      // Vertex
      //
      typedef ::xsd::qif30::MeasuredPointType Vertex_type;
      typedef ::xsd::cxx::tree::optional< Vertex_type > Vertex_optional;
      typedef ::xsd::cxx::tree::traits< Vertex_type, wchar_t > Vertex_traits;

      const Vertex_optional&
      Vertex () const;

      Vertex_optional&
      Vertex ();

      void
      Vertex (const Vertex_type& x);

      void
      Vertex (const Vertex_optional& x);

      void
      Vertex (::std::unique_ptr< Vertex_type > p);

      // Constructors.
      //
      AngleFromCharacteristicMeasurementType ();

      AngleFromCharacteristicMeasurementType (const id_type&,
                                              const Status_type&,
                                              const CharacteristicItemId_type&);

      AngleFromCharacteristicMeasurementType (const id_type&,
                                              ::std::unique_ptr< Status_type >,
                                              ::std::unique_ptr< CharacteristicItemId_type >);

      AngleFromCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      AngleFromCharacteristicMeasurementType (const AngleFromCharacteristicMeasurementType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual AngleFromCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleFromCharacteristicMeasurementType&
      operator= (const AngleFromCharacteristicMeasurementType& x);

      virtual 
      ~AngleFromCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AnalysisVector_optional AnalysisVector_;
      Vertex_optional Vertex_;
    };

    class QIF30_SYMBOL_DECL AngleBetweenCharacteristicItemType: public ::xsd::qif30::AngularCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      AngleBetweenCharacteristicItemType ();

      AngleBetweenCharacteristicItemType (const id_type&,
                                          const CharacteristicNominalId_type&);

      AngleBetweenCharacteristicItemType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >);

      AngleBetweenCharacteristicItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngleBetweenCharacteristicItemType (const AngleBetweenCharacteristicItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual AngleBetweenCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleBetweenCharacteristicItemType&
      operator= (const AngleBetweenCharacteristicItemType&) = default;
#endif

      virtual 
      ~AngleBetweenCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL AngleBetweenCharacteristicDefinitionType: public ::xsd::qif30::AngularCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      AngleBetweenCharacteristicDefinitionType ();

      AngleBetweenCharacteristicDefinitionType (const id_type&);

      AngleBetweenCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      AngleBetweenCharacteristicDefinitionType (const AngleBetweenCharacteristicDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual AngleBetweenCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleBetweenCharacteristicDefinitionType&
      operator= (const AngleBetweenCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~AngleBetweenCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL AngleBetweenCharacteristicNominalType: public ::xsd::qif30::AngularCharacteristicNominalBaseType
    {
      public:
      // FeatureNominalPairs
      //
      typedef ::xsd::qif30::ArrayPairReferenceFullType FeatureNominalPairs_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalPairs_type > FeatureNominalPairs_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalPairs_type, wchar_t > FeatureNominalPairs_traits;

      const FeatureNominalPairs_optional&
      FeatureNominalPairs () const;

      FeatureNominalPairs_optional&
      FeatureNominalPairs ();

      void
      FeatureNominalPairs (const FeatureNominalPairs_type& x);

      void
      FeatureNominalPairs (const FeatureNominalPairs_optional& x);

      void
      FeatureNominalPairs (::std::unique_ptr< FeatureNominalPairs_type > p);

      // AnalysisVector
      //
      typedef ::xsd::qif30::UnitVectorType AnalysisVector_type;
      typedef ::xsd::cxx::tree::optional< AnalysisVector_type > AnalysisVector_optional;
      typedef ::xsd::cxx::tree::traits< AnalysisVector_type, wchar_t > AnalysisVector_traits;

      const AnalysisVector_optional&
      AnalysisVector () const;

      AnalysisVector_optional&
      AnalysisVector ();

      void
      AnalysisVector (const AnalysisVector_type& x);

      void
      AnalysisVector (const AnalysisVector_optional& x);

      void
      AnalysisVector (::std::unique_ptr< AnalysisVector_type > p);

      // AnalysisMode
      //
      typedef ::xsd::qif30::AngleBetweenAnalysisModeEnumType AnalysisMode_type;
      typedef ::xsd::cxx::tree::traits< AnalysisMode_type, wchar_t > AnalysisMode_traits;

      const AnalysisMode_type&
      AnalysisMode () const;

      AnalysisMode_type&
      AnalysisMode ();

      void
      AnalysisMode (const AnalysisMode_type& x);

      void
      AnalysisMode (::std::unique_ptr< AnalysisMode_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // MeasurementDirective
      //
      typedef ::xsd::qif30::MeasurementDirectiveType MeasurementDirective_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDirective_type > MeasurementDirective_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDirective_type, wchar_t > MeasurementDirective_traits;

      const MeasurementDirective_optional&
      MeasurementDirective () const;

      MeasurementDirective_optional&
      MeasurementDirective ();

      void
      MeasurementDirective (const MeasurementDirective_type& x);

      void
      MeasurementDirective (const MeasurementDirective_optional& x);

      void
      MeasurementDirective (::std::unique_ptr< MeasurementDirective_type > p);

      // Vertex
      //
      typedef ::xsd::qif30::PointType Vertex_type;
      typedef ::xsd::cxx::tree::optional< Vertex_type > Vertex_optional;
      typedef ::xsd::cxx::tree::traits< Vertex_type, wchar_t > Vertex_traits;

      const Vertex_optional&
      Vertex () const;

      Vertex_optional&
      Vertex ();

      void
      Vertex (const Vertex_type& x);

      void
      Vertex (const Vertex_optional& x);

      void
      Vertex (::std::unique_ptr< Vertex_type > p);

      // Constructors.
      //
      AngleBetweenCharacteristicNominalType ();

      AngleBetweenCharacteristicNominalType (const id_type&,
                                             const CharacteristicDefinitionId_type&,
                                             const AnalysisMode_type&);

      AngleBetweenCharacteristicNominalType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                             const AnalysisMode_type&);

      AngleBetweenCharacteristicNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      AngleBetweenCharacteristicNominalType (const AngleBetweenCharacteristicNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual AngleBetweenCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleBetweenCharacteristicNominalType&
      operator= (const AngleBetweenCharacteristicNominalType& x);

      virtual 
      ~AngleBetweenCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureNominalPairs_optional FeatureNominalPairs_;
      AnalysisVector_optional AnalysisVector_;
      ::xsd::cxx::tree::one< AnalysisMode_type > AnalysisMode_;
      CoordinateSystemId_optional CoordinateSystemId_;
      MeasurementDirective_optional MeasurementDirective_;
      Vertex_optional Vertex_;
    };

    class QIF30_SYMBOL_DECL AngleBetweenCharacteristicMeasurementType: public ::xsd::qif30::AngularCharacteristicMeasurementBaseType
    {
      public:
      // AnalysisVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType AnalysisVector_type;
      typedef ::xsd::cxx::tree::optional< AnalysisVector_type > AnalysisVector_optional;
      typedef ::xsd::cxx::tree::traits< AnalysisVector_type, wchar_t > AnalysisVector_traits;

      const AnalysisVector_optional&
      AnalysisVector () const;

      AnalysisVector_optional&
      AnalysisVector ();

      void
      AnalysisVector (const AnalysisVector_type& x);

      void
      AnalysisVector (const AnalysisVector_optional& x);

      void
      AnalysisVector (::std::unique_ptr< AnalysisVector_type > p);

      // Vertex
      //
      typedef ::xsd::qif30::MeasuredPointType Vertex_type;
      typedef ::xsd::cxx::tree::optional< Vertex_type > Vertex_optional;
      typedef ::xsd::cxx::tree::traits< Vertex_type, wchar_t > Vertex_traits;

      const Vertex_optional&
      Vertex () const;

      Vertex_optional&
      Vertex ();

      void
      Vertex (const Vertex_type& x);

      void
      Vertex (const Vertex_optional& x);

      void
      Vertex (::std::unique_ptr< Vertex_type > p);

      // Constructors.
      //
      AngleBetweenCharacteristicMeasurementType ();

      AngleBetweenCharacteristicMeasurementType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&);

      AngleBetweenCharacteristicMeasurementType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >);

      AngleBetweenCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      AngleBetweenCharacteristicMeasurementType (const AngleBetweenCharacteristicMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual AngleBetweenCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleBetweenCharacteristicMeasurementType&
      operator= (const AngleBetweenCharacteristicMeasurementType& x);

      virtual 
      ~AngleBetweenCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AnalysisVector_optional AnalysisVector_;
      Vertex_optional Vertex_;
    };

    class QIF30_SYMBOL_DECL LinearCoordinateCharacteristicItemType: public ::xsd::qif30::CoordinateCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      LinearCoordinateCharacteristicItemType ();

      LinearCoordinateCharacteristicItemType (const id_type&,
                                              const CharacteristicNominalId_type&);

      LinearCoordinateCharacteristicItemType (const id_type&,
                                              ::std::unique_ptr< CharacteristicNominalId_type >);

      LinearCoordinateCharacteristicItemType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      LinearCoordinateCharacteristicItemType (const LinearCoordinateCharacteristicItemType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual LinearCoordinateCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LinearCoordinateCharacteristicItemType&
      operator= (const LinearCoordinateCharacteristicItemType&) = default;
#endif

      virtual 
      ~LinearCoordinateCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL LinearCoordinateCharacteristicDefinitionType: public ::xsd::qif30::CoordinateCharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::LinearToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      LinearCoordinateCharacteristicDefinitionType ();

      LinearCoordinateCharacteristicDefinitionType (const id_type&);

      LinearCoordinateCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      LinearCoordinateCharacteristicDefinitionType (const LinearCoordinateCharacteristicDefinitionType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual LinearCoordinateCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearCoordinateCharacteristicDefinitionType&
      operator= (const LinearCoordinateCharacteristicDefinitionType& x);

      virtual 
      ~LinearCoordinateCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL LinearCoordinateCharacteristicNominalType: public ::xsd::qif30::CoordinateCharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::LinearValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Direction
      //
      typedef ::xsd::qif30::LinearCoordinateDirectionEnumType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // Constructors.
      //
      LinearCoordinateCharacteristicNominalType ();

      LinearCoordinateCharacteristicNominalType (const id_type&,
                                                 const CharacteristicDefinitionId_type&,
                                                 const Direction_type&);

      LinearCoordinateCharacteristicNominalType (const id_type&,
                                                 ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                                 const Direction_type&);

      LinearCoordinateCharacteristicNominalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      LinearCoordinateCharacteristicNominalType (const LinearCoordinateCharacteristicNominalType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual LinearCoordinateCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearCoordinateCharacteristicNominalType&
      operator= (const LinearCoordinateCharacteristicNominalType& x);

      virtual 
      ~LinearCoordinateCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
      ::xsd::cxx::tree::one< Direction_type > Direction_;
      CoordinateSystemId_optional CoordinateSystemId_;
    };

    class QIF30_SYMBOL_DECL LinearCoordinateCharacteristicMeasurementType: public ::xsd::qif30::CoordinateCharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      LinearCoordinateCharacteristicMeasurementType ();

      LinearCoordinateCharacteristicMeasurementType (const id_type&,
                                                     const Status_type&,
                                                     const CharacteristicItemId_type&,
                                                     const TypeOfCoordinates_type&);

      LinearCoordinateCharacteristicMeasurementType (const id_type&,
                                                     ::std::unique_ptr< Status_type >,
                                                     ::std::unique_ptr< CharacteristicItemId_type >,
                                                     ::std::unique_ptr< TypeOfCoordinates_type >);

      LinearCoordinateCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      LinearCoordinateCharacteristicMeasurementType (const LinearCoordinateCharacteristicMeasurementType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual LinearCoordinateCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearCoordinateCharacteristicMeasurementType&
      operator= (const LinearCoordinateCharacteristicMeasurementType& x);

      virtual 
      ~LinearCoordinateCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL AngularCoordinateCharacteristicItemType: public ::xsd::qif30::CoordinateCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      AngularCoordinateCharacteristicItemType ();

      AngularCoordinateCharacteristicItemType (const id_type&,
                                               const CharacteristicNominalId_type&);

      AngularCoordinateCharacteristicItemType (const id_type&,
                                               ::std::unique_ptr< CharacteristicNominalId_type >);

      AngularCoordinateCharacteristicItemType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      AngularCoordinateCharacteristicItemType (const AngularCoordinateCharacteristicItemType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual AngularCoordinateCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngularCoordinateCharacteristicItemType&
      operator= (const AngularCoordinateCharacteristicItemType&) = default;
#endif

      virtual 
      ~AngularCoordinateCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL AngularCoordinateCharacteristicDefinitionType: public ::xsd::qif30::CoordinateCharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::AngularToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      AngularCoordinateCharacteristicDefinitionType ();

      AngularCoordinateCharacteristicDefinitionType (const id_type&);

      AngularCoordinateCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      AngularCoordinateCharacteristicDefinitionType (const AngularCoordinateCharacteristicDefinitionType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual AngularCoordinateCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularCoordinateCharacteristicDefinitionType&
      operator= (const AngularCoordinateCharacteristicDefinitionType& x);

      virtual 
      ~AngularCoordinateCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL AngularCoordinateCharacteristicNominalType: public ::xsd::qif30::CoordinateCharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::AngularValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Direction
      //
      typedef ::xsd::qif30::AngularCoordinateDirectionEnumType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // Constructors.
      //
      AngularCoordinateCharacteristicNominalType ();

      AngularCoordinateCharacteristicNominalType (const id_type&,
                                                  const CharacteristicDefinitionId_type&,
                                                  const Direction_type&);

      AngularCoordinateCharacteristicNominalType (const id_type&,
                                                  ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                                  const Direction_type&);

      AngularCoordinateCharacteristicNominalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      AngularCoordinateCharacteristicNominalType (const AngularCoordinateCharacteristicNominalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual AngularCoordinateCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularCoordinateCharacteristicNominalType&
      operator= (const AngularCoordinateCharacteristicNominalType& x);

      virtual 
      ~AngularCoordinateCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
      ::xsd::cxx::tree::one< Direction_type > Direction_;
      CoordinateSystemId_optional CoordinateSystemId_;
    };

    class QIF30_SYMBOL_DECL AngularCoordinateCharacteristicMeasurementType: public ::xsd::qif30::CoordinateCharacteristicMeasurementBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::MeasuredAngularValueType Value_type;
      typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_optional&
      Value () const;

      Value_optional&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (const Value_optional& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::MeasuredAngularValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MeasuredAngularValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // Constructors.
      //
      AngularCoordinateCharacteristicMeasurementType ();

      AngularCoordinateCharacteristicMeasurementType (const id_type&,
                                                      const Status_type&,
                                                      const CharacteristicItemId_type&,
                                                      const TypeOfCoordinates_type&);

      AngularCoordinateCharacteristicMeasurementType (const id_type&,
                                                      ::std::unique_ptr< Status_type >,
                                                      ::std::unique_ptr< CharacteristicItemId_type >,
                                                      ::std::unique_ptr< TypeOfCoordinates_type >);

      AngularCoordinateCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      AngularCoordinateCharacteristicMeasurementType (const AngularCoordinateCharacteristicMeasurementType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual AngularCoordinateCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularCoordinateCharacteristicMeasurementType&
      operator= (const AngularCoordinateCharacteristicMeasurementType& x);

      virtual 
      ~AngularCoordinateCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Value_optional Value_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
    };

    class QIF30_SYMBOL_DECL CurveLengthCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      CurveLengthCharacteristicItemType ();

      CurveLengthCharacteristicItemType (const id_type&,
                                         const CharacteristicNominalId_type&);

      CurveLengthCharacteristicItemType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      CurveLengthCharacteristicItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CurveLengthCharacteristicItemType (const CurveLengthCharacteristicItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CurveLengthCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CurveLengthCharacteristicItemType&
      operator= (const CurveLengthCharacteristicItemType&) = default;
#endif

      virtual 
      ~CurveLengthCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL CurveLengthCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      CurveLengthCharacteristicDefinitionType ();

      CurveLengthCharacteristicDefinitionType (const id_type&);

      CurveLengthCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CurveLengthCharacteristicDefinitionType (const CurveLengthCharacteristicDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CurveLengthCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CurveLengthCharacteristicDefinitionType&
      operator= (const CurveLengthCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~CurveLengthCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL CurveLengthCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      CurveLengthCharacteristicNominalType ();

      CurveLengthCharacteristicNominalType (const id_type&,
                                            const CharacteristicDefinitionId_type&);

      CurveLengthCharacteristicNominalType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >);

      CurveLengthCharacteristicNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CurveLengthCharacteristicNominalType (const CurveLengthCharacteristicNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CurveLengthCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CurveLengthCharacteristicNominalType&
      operator= (const CurveLengthCharacteristicNominalType&) = default;
#endif

      virtual 
      ~CurveLengthCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL CurveLengthCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      CurveLengthCharacteristicMeasurementType ();

      CurveLengthCharacteristicMeasurementType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      CurveLengthCharacteristicMeasurementType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      CurveLengthCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      CurveLengthCharacteristicMeasurementType (const CurveLengthCharacteristicMeasurementType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual CurveLengthCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CurveLengthCharacteristicMeasurementType&
      operator= (const CurveLengthCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~CurveLengthCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL DiameterCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      DiameterCharacteristicItemType ();

      DiameterCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      DiameterCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      DiameterCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      DiameterCharacteristicItemType (const DiameterCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual DiameterCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DiameterCharacteristicItemType&
      operator= (const DiameterCharacteristicItemType&) = default;
#endif

      virtual 
      ~DiameterCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL DiameterCharacteristicDefinitionType: public ::xsd::qif30::DimensionalCharacteristicDefinitionBaseType
    {
      public:
      // Tolerance
      //
      typedef ::xsd::qif30::LinearToleranceType Tolerance_type;
      typedef ::xsd::cxx::tree::optional< Tolerance_type > Tolerance_optional;
      typedef ::xsd::cxx::tree::traits< Tolerance_type, wchar_t > Tolerance_traits;

      const Tolerance_optional&
      Tolerance () const;

      Tolerance_optional&
      Tolerance ();

      void
      Tolerance (const Tolerance_type& x);

      void
      Tolerance (const Tolerance_optional& x);

      void
      Tolerance (::std::unique_ptr< Tolerance_type > p);

      // LimitsAndFitsSpecification
      //
      typedef ::xsd::qif30::LimitsAndFitsSpecificationType LimitsAndFitsSpecification_type;
      typedef ::xsd::cxx::tree::optional< LimitsAndFitsSpecification_type > LimitsAndFitsSpecification_optional;
      typedef ::xsd::cxx::tree::traits< LimitsAndFitsSpecification_type, wchar_t > LimitsAndFitsSpecification_traits;

      const LimitsAndFitsSpecification_optional&
      LimitsAndFitsSpecification () const;

      LimitsAndFitsSpecification_optional&
      LimitsAndFitsSpecification ();

      void
      LimitsAndFitsSpecification (const LimitsAndFitsSpecification_type& x);

      void
      LimitsAndFitsSpecification (const LimitsAndFitsSpecification_optional& x);

      void
      LimitsAndFitsSpecification (::std::unique_ptr< LimitsAndFitsSpecification_type > p);

      // NonTolerance
      //
      typedef ::xsd::qif30::NonToleranceEnumType NonTolerance_type;
      typedef ::xsd::cxx::tree::optional< NonTolerance_type > NonTolerance_optional;
      typedef ::xsd::cxx::tree::traits< NonTolerance_type, wchar_t > NonTolerance_traits;

      const NonTolerance_optional&
      NonTolerance () const;

      NonTolerance_optional&
      NonTolerance ();

      void
      NonTolerance (const NonTolerance_type& x);

      void
      NonTolerance (const NonTolerance_optional& x);

      void
      NonTolerance (::std::unique_ptr< NonTolerance_type > p);

      // Constructors.
      //
      DiameterCharacteristicDefinitionType ();

      DiameterCharacteristicDefinitionType (const id_type&);

      DiameterCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      DiameterCharacteristicDefinitionType (const DiameterCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual DiameterCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DiameterCharacteristicDefinitionType&
      operator= (const DiameterCharacteristicDefinitionType& x);

      virtual 
      ~DiameterCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Tolerance_optional Tolerance_;
      LimitsAndFitsSpecification_optional LimitsAndFitsSpecification_;
      NonTolerance_optional NonTolerance_;
    };

    class QIF30_SYMBOL_DECL DiameterCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      DiameterCharacteristicNominalType ();

      DiameterCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      DiameterCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      DiameterCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      DiameterCharacteristicNominalType (const DiameterCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual DiameterCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DiameterCharacteristicNominalType&
      operator= (const DiameterCharacteristicNominalType&) = default;
#endif

      virtual 
      ~DiameterCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL DiameterCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      DiameterCharacteristicMeasurementType ();

      DiameterCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      DiameterCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      DiameterCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      DiameterCharacteristicMeasurementType (const DiameterCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual DiameterCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DiameterCharacteristicMeasurementType&
      operator= (const DiameterCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~DiameterCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL SphericalDiameterCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SphericalDiameterCharacteristicItemType ();

      SphericalDiameterCharacteristicItemType (const id_type&,
                                               const CharacteristicNominalId_type&);

      SphericalDiameterCharacteristicItemType (const id_type&,
                                               ::std::unique_ptr< CharacteristicNominalId_type >);

      SphericalDiameterCharacteristicItemType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      SphericalDiameterCharacteristicItemType (const SphericalDiameterCharacteristicItemType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual SphericalDiameterCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalDiameterCharacteristicItemType&
      operator= (const SphericalDiameterCharacteristicItemType&) = default;
#endif

      virtual 
      ~SphericalDiameterCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL SphericalDiameterCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      SphericalDiameterCharacteristicDefinitionType ();

      SphericalDiameterCharacteristicDefinitionType (const id_type&);

      SphericalDiameterCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      SphericalDiameterCharacteristicDefinitionType (const SphericalDiameterCharacteristicDefinitionType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual SphericalDiameterCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalDiameterCharacteristicDefinitionType&
      operator= (const SphericalDiameterCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~SphericalDiameterCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL SphericalDiameterCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      SphericalDiameterCharacteristicNominalType ();

      SphericalDiameterCharacteristicNominalType (const id_type&,
                                                  const CharacteristicDefinitionId_type&);

      SphericalDiameterCharacteristicNominalType (const id_type&,
                                                  ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SphericalDiameterCharacteristicNominalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      SphericalDiameterCharacteristicNominalType (const SphericalDiameterCharacteristicNominalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual SphericalDiameterCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalDiameterCharacteristicNominalType&
      operator= (const SphericalDiameterCharacteristicNominalType&) = default;
#endif

      virtual 
      ~SphericalDiameterCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL SphericalDiameterCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      SphericalDiameterCharacteristicMeasurementType ();

      SphericalDiameterCharacteristicMeasurementType (const id_type&,
                                                      const Status_type&,
                                                      const CharacteristicItemId_type&);

      SphericalDiameterCharacteristicMeasurementType (const id_type&,
                                                      ::std::unique_ptr< Status_type >,
                                                      ::std::unique_ptr< CharacteristicItemId_type >);

      SphericalDiameterCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      SphericalDiameterCharacteristicMeasurementType (const SphericalDiameterCharacteristicMeasurementType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual SphericalDiameterCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalDiameterCharacteristicMeasurementType&
      operator= (const SphericalDiameterCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~SphericalDiameterCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL LengthCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      LengthCharacteristicItemType ();

      LengthCharacteristicItemType (const id_type&,
                                    const CharacteristicNominalId_type&);

      LengthCharacteristicItemType (const id_type&,
                                    ::std::unique_ptr< CharacteristicNominalId_type >);

      LengthCharacteristicItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      LengthCharacteristicItemType (const LengthCharacteristicItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual LengthCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LengthCharacteristicItemType&
      operator= (const LengthCharacteristicItemType&) = default;
#endif

      virtual 
      ~LengthCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL LengthCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      LengthCharacteristicDefinitionType ();

      LengthCharacteristicDefinitionType (const id_type&);

      LengthCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      LengthCharacteristicDefinitionType (const LengthCharacteristicDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual LengthCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LengthCharacteristicDefinitionType&
      operator= (const LengthCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~LengthCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL LengthCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      LengthCharacteristicNominalType ();

      LengthCharacteristicNominalType (const id_type&,
                                       const CharacteristicDefinitionId_type&);

      LengthCharacteristicNominalType (const id_type&,
                                       ::std::unique_ptr< CharacteristicDefinitionId_type >);

      LengthCharacteristicNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      LengthCharacteristicNominalType (const LengthCharacteristicNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual LengthCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LengthCharacteristicNominalType&
      operator= (const LengthCharacteristicNominalType&) = default;
#endif

      virtual 
      ~LengthCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL LengthCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      LengthCharacteristicMeasurementType ();

      LengthCharacteristicMeasurementType (const id_type&,
                                           const Status_type&,
                                           const CharacteristicItemId_type&);

      LengthCharacteristicMeasurementType (const id_type&,
                                           ::std::unique_ptr< Status_type >,
                                           ::std::unique_ptr< CharacteristicItemId_type >);

      LengthCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      LengthCharacteristicMeasurementType (const LengthCharacteristicMeasurementType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual LengthCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LengthCharacteristicMeasurementType&
      operator= (const LengthCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~LengthCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WidthCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WidthCharacteristicItemType ();

      WidthCharacteristicItemType (const id_type&,
                                   const CharacteristicNominalId_type&);

      WidthCharacteristicItemType (const id_type&,
                                   ::std::unique_ptr< CharacteristicNominalId_type >);

      WidthCharacteristicItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      WidthCharacteristicItemType (const WidthCharacteristicItemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual WidthCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WidthCharacteristicItemType&
      operator= (const WidthCharacteristicItemType&) = default;
#endif

      virtual 
      ~WidthCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WidthCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WidthCharacteristicDefinitionType ();

      WidthCharacteristicDefinitionType (const id_type&);

      WidthCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WidthCharacteristicDefinitionType (const WidthCharacteristicDefinitionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WidthCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WidthCharacteristicDefinitionType&
      operator= (const WidthCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WidthCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WidthCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      WidthCharacteristicNominalType ();

      WidthCharacteristicNominalType (const id_type&,
                                      const CharacteristicDefinitionId_type&);

      WidthCharacteristicNominalType (const id_type&,
                                      ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WidthCharacteristicNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WidthCharacteristicNominalType (const WidthCharacteristicNominalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WidthCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WidthCharacteristicNominalType&
      operator= (const WidthCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WidthCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WidthCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      WidthCharacteristicMeasurementType ();

      WidthCharacteristicMeasurementType (const id_type&,
                                          const Status_type&,
                                          const CharacteristicItemId_type&);

      WidthCharacteristicMeasurementType (const id_type&,
                                          ::std::unique_ptr< Status_type >,
                                          ::std::unique_ptr< CharacteristicItemId_type >);

      WidthCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      WidthCharacteristicMeasurementType (const WidthCharacteristicMeasurementType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual WidthCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WidthCharacteristicMeasurementType&
      operator= (const WidthCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WidthCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL HeightCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      HeightCharacteristicItemType ();

      HeightCharacteristicItemType (const id_type&,
                                    const CharacteristicNominalId_type&);

      HeightCharacteristicItemType (const id_type&,
                                    ::std::unique_ptr< CharacteristicNominalId_type >);

      HeightCharacteristicItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      HeightCharacteristicItemType (const HeightCharacteristicItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual HeightCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      HeightCharacteristicItemType&
      operator= (const HeightCharacteristicItemType&) = default;
#endif

      virtual 
      ~HeightCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL HeightCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      HeightCharacteristicDefinitionType ();

      HeightCharacteristicDefinitionType (const id_type&);

      HeightCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      HeightCharacteristicDefinitionType (const HeightCharacteristicDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual HeightCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      HeightCharacteristicDefinitionType&
      operator= (const HeightCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~HeightCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL HeightCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      HeightCharacteristicNominalType ();

      HeightCharacteristicNominalType (const id_type&,
                                       const CharacteristicDefinitionId_type&);

      HeightCharacteristicNominalType (const id_type&,
                                       ::std::unique_ptr< CharacteristicDefinitionId_type >);

      HeightCharacteristicNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      HeightCharacteristicNominalType (const HeightCharacteristicNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual HeightCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      HeightCharacteristicNominalType&
      operator= (const HeightCharacteristicNominalType&) = default;
#endif

      virtual 
      ~HeightCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL HeightCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      HeightCharacteristicMeasurementType ();

      HeightCharacteristicMeasurementType (const id_type&,
                                           const Status_type&,
                                           const CharacteristicItemId_type&);

      HeightCharacteristicMeasurementType (const id_type&,
                                           ::std::unique_ptr< Status_type >,
                                           ::std::unique_ptr< CharacteristicItemId_type >);

      HeightCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      HeightCharacteristicMeasurementType (const HeightCharacteristicMeasurementType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual HeightCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      HeightCharacteristicMeasurementType&
      operator= (const HeightCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~HeightCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL DepthCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      DepthCharacteristicItemType ();

      DepthCharacteristicItemType (const id_type&,
                                   const CharacteristicNominalId_type&);

      DepthCharacteristicItemType (const id_type&,
                                   ::std::unique_ptr< CharacteristicNominalId_type >);

      DepthCharacteristicItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      DepthCharacteristicItemType (const DepthCharacteristicItemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual DepthCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DepthCharacteristicItemType&
      operator= (const DepthCharacteristicItemType&) = default;
#endif

      virtual 
      ~DepthCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL DepthCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      DepthCharacteristicDefinitionType ();

      DepthCharacteristicDefinitionType (const id_type&);

      DepthCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      DepthCharacteristicDefinitionType (const DepthCharacteristicDefinitionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual DepthCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DepthCharacteristicDefinitionType&
      operator= (const DepthCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~DepthCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL DepthCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      DepthCharacteristicNominalType ();

      DepthCharacteristicNominalType (const id_type&,
                                      const CharacteristicDefinitionId_type&);

      DepthCharacteristicNominalType (const id_type&,
                                      ::std::unique_ptr< CharacteristicDefinitionId_type >);

      DepthCharacteristicNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      DepthCharacteristicNominalType (const DepthCharacteristicNominalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual DepthCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DepthCharacteristicNominalType&
      operator= (const DepthCharacteristicNominalType&) = default;
#endif

      virtual 
      ~DepthCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL DepthCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      DepthCharacteristicMeasurementType ();

      DepthCharacteristicMeasurementType (const id_type&,
                                          const Status_type&,
                                          const CharacteristicItemId_type&);

      DepthCharacteristicMeasurementType (const id_type&,
                                          ::std::unique_ptr< Status_type >,
                                          ::std::unique_ptr< CharacteristicItemId_type >);

      DepthCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      DepthCharacteristicMeasurementType (const DepthCharacteristicMeasurementType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual DepthCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DepthCharacteristicMeasurementType&
      operator= (const DepthCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~DepthCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL ThicknessCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ThicknessCharacteristicItemType ();

      ThicknessCharacteristicItemType (const id_type&,
                                       const CharacteristicNominalId_type&);

      ThicknessCharacteristicItemType (const id_type&,
                                       ::std::unique_ptr< CharacteristicNominalId_type >);

      ThicknessCharacteristicItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ThicknessCharacteristicItemType (const ThicknessCharacteristicItemType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ThicknessCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ThicknessCharacteristicItemType&
      operator= (const ThicknessCharacteristicItemType&) = default;
#endif

      virtual 
      ~ThicknessCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ThicknessCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      ThicknessCharacteristicDefinitionType ();

      ThicknessCharacteristicDefinitionType (const id_type&);

      ThicknessCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ThicknessCharacteristicDefinitionType (const ThicknessCharacteristicDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ThicknessCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ThicknessCharacteristicDefinitionType&
      operator= (const ThicknessCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~ThicknessCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL ThicknessCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      ThicknessCharacteristicNominalType ();

      ThicknessCharacteristicNominalType (const id_type&,
                                          const CharacteristicDefinitionId_type&);

      ThicknessCharacteristicNominalType (const id_type&,
                                          ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ThicknessCharacteristicNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ThicknessCharacteristicNominalType (const ThicknessCharacteristicNominalType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ThicknessCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ThicknessCharacteristicNominalType&
      operator= (const ThicknessCharacteristicNominalType&) = default;
#endif

      virtual 
      ~ThicknessCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL ThicknessCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      ThicknessCharacteristicMeasurementType ();

      ThicknessCharacteristicMeasurementType (const id_type&,
                                              const Status_type&,
                                              const CharacteristicItemId_type&);

      ThicknessCharacteristicMeasurementType (const id_type&,
                                              ::std::unique_ptr< Status_type >,
                                              ::std::unique_ptr< CharacteristicItemId_type >);

      ThicknessCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ThicknessCharacteristicMeasurementType (const ThicknessCharacteristicMeasurementType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ThicknessCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ThicknessCharacteristicMeasurementType&
      operator= (const ThicknessCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~ThicknessCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL SquareCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SquareCharacteristicItemType ();

      SquareCharacteristicItemType (const id_type&,
                                    const CharacteristicNominalId_type&);

      SquareCharacteristicItemType (const id_type&,
                                    ::std::unique_ptr< CharacteristicNominalId_type >);

      SquareCharacteristicItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SquareCharacteristicItemType (const SquareCharacteristicItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SquareCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SquareCharacteristicItemType&
      operator= (const SquareCharacteristicItemType&) = default;
#endif

      virtual 
      ~SquareCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL SquareCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      SquareCharacteristicDefinitionType ();

      SquareCharacteristicDefinitionType (const id_type&);

      SquareCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SquareCharacteristicDefinitionType (const SquareCharacteristicDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SquareCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SquareCharacteristicDefinitionType&
      operator= (const SquareCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~SquareCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL SquareCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      SquareCharacteristicNominalType ();

      SquareCharacteristicNominalType (const id_type&,
                                       const CharacteristicDefinitionId_type&);

      SquareCharacteristicNominalType (const id_type&,
                                       ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SquareCharacteristicNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SquareCharacteristicNominalType (const SquareCharacteristicNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SquareCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SquareCharacteristicNominalType&
      operator= (const SquareCharacteristicNominalType&) = default;
#endif

      virtual 
      ~SquareCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL SquareCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      SquareCharacteristicMeasurementType ();

      SquareCharacteristicMeasurementType (const id_type&,
                                           const Status_type&,
                                           const CharacteristicItemId_type&);

      SquareCharacteristicMeasurementType (const id_type&,
                                           ::std::unique_ptr< Status_type >,
                                           ::std::unique_ptr< CharacteristicItemId_type >);

      SquareCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      SquareCharacteristicMeasurementType (const SquareCharacteristicMeasurementType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual SquareCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SquareCharacteristicMeasurementType&
      operator= (const SquareCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~SquareCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL DistanceFromCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      DistanceFromCharacteristicItemType ();

      DistanceFromCharacteristicItemType (const id_type&,
                                          const CharacteristicNominalId_type&);

      DistanceFromCharacteristicItemType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >);

      DistanceFromCharacteristicItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      DistanceFromCharacteristicItemType (const DistanceFromCharacteristicItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual DistanceFromCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DistanceFromCharacteristicItemType&
      operator= (const DistanceFromCharacteristicItemType&) = default;
#endif

      virtual 
      ~DistanceFromCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL DistanceFromCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      DistanceFromCharacteristicDefinitionType ();

      DistanceFromCharacteristicDefinitionType (const id_type&);

      DistanceFromCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      DistanceFromCharacteristicDefinitionType (const DistanceFromCharacteristicDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual DistanceFromCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DistanceFromCharacteristicDefinitionType&
      operator= (const DistanceFromCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~DistanceFromCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL DistanceFromCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // OriginReference
      //
      typedef ::xsd::qif30::OriginReferenceType OriginReference_type;
      typedef ::xsd::cxx::tree::optional< OriginReference_type > OriginReference_optional;
      typedef ::xsd::cxx::tree::traits< OriginReference_type, wchar_t > OriginReference_traits;

      const OriginReference_optional&
      OriginReference () const;

      OriginReference_optional&
      OriginReference ();

      void
      OriginReference (const OriginReference_type& x);

      void
      OriginReference (const OriginReference_optional& x);

      void
      OriginReference (::std::unique_ptr< OriginReference_type > p);

      // AnalysisVector
      //
      typedef ::xsd::qif30::UnitVectorType AnalysisVector_type;
      typedef ::xsd::cxx::tree::optional< AnalysisVector_type > AnalysisVector_optional;
      typedef ::xsd::cxx::tree::traits< AnalysisVector_type, wchar_t > AnalysisVector_traits;

      const AnalysisVector_optional&
      AnalysisVector () const;

      AnalysisVector_optional&
      AnalysisVector ();

      void
      AnalysisVector (const AnalysisVector_type& x);

      void
      AnalysisVector (const AnalysisVector_optional& x);

      void
      AnalysisVector (::std::unique_ptr< AnalysisVector_type > p);

      // AnalysisMode
      //
      typedef ::xsd::qif30::DistanceBetweenAnalysisModeEnumType AnalysisMode_type;
      typedef ::xsd::cxx::tree::traits< AnalysisMode_type, wchar_t > AnalysisMode_traits;

      const AnalysisMode_type&
      AnalysisMode () const;

      AnalysisMode_type&
      AnalysisMode ();

      void
      AnalysisMode (const AnalysisMode_type& x);

      void
      AnalysisMode (::std::unique_ptr< AnalysisMode_type > p);

      // MeasurementDirective
      //
      typedef ::xsd::qif30::MeasurementDirectiveType MeasurementDirective_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDirective_type > MeasurementDirective_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDirective_type, wchar_t > MeasurementDirective_traits;

      const MeasurementDirective_optional&
      MeasurementDirective () const;

      MeasurementDirective_optional&
      MeasurementDirective ();

      void
      MeasurementDirective (const MeasurementDirective_type& x);

      void
      MeasurementDirective (const MeasurementDirective_optional& x);

      void
      MeasurementDirective (::std::unique_ptr< MeasurementDirective_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // Constructors.
      //
      DistanceFromCharacteristicNominalType ();

      DistanceFromCharacteristicNominalType (const id_type&,
                                             const CharacteristicDefinitionId_type&,
                                             const AnalysisMode_type&);

      DistanceFromCharacteristicNominalType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                             const AnalysisMode_type&);

      DistanceFromCharacteristicNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      DistanceFromCharacteristicNominalType (const DistanceFromCharacteristicNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual DistanceFromCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DistanceFromCharacteristicNominalType&
      operator= (const DistanceFromCharacteristicNominalType& x);

      virtual 
      ~DistanceFromCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      OriginReference_optional OriginReference_;
      AnalysisVector_optional AnalysisVector_;
      ::xsd::cxx::tree::one< AnalysisMode_type > AnalysisMode_;
      MeasurementDirective_optional MeasurementDirective_;
      CoordinateSystemId_optional CoordinateSystemId_;
    };

    class QIF30_SYMBOL_DECL DistanceFromCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // AnalysisVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType AnalysisVector_type;
      typedef ::xsd::cxx::tree::optional< AnalysisVector_type > AnalysisVector_optional;
      typedef ::xsd::cxx::tree::traits< AnalysisVector_type, wchar_t > AnalysisVector_traits;

      const AnalysisVector_optional&
      AnalysisVector () const;

      AnalysisVector_optional&
      AnalysisVector ();

      void
      AnalysisVector (const AnalysisVector_type& x);

      void
      AnalysisVector (const AnalysisVector_optional& x);

      void
      AnalysisVector (::std::unique_ptr< AnalysisVector_type > p);

      // Constructors.
      //
      DistanceFromCharacteristicMeasurementType ();

      DistanceFromCharacteristicMeasurementType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&);

      DistanceFromCharacteristicMeasurementType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >);

      DistanceFromCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      DistanceFromCharacteristicMeasurementType (const DistanceFromCharacteristicMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual DistanceFromCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DistanceFromCharacteristicMeasurementType&
      operator= (const DistanceFromCharacteristicMeasurementType& x);

      virtual 
      ~DistanceFromCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AnalysisVector_optional AnalysisVector_;
    };

    class QIF30_SYMBOL_DECL DistanceBetweenCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      DistanceBetweenCharacteristicItemType ();

      DistanceBetweenCharacteristicItemType (const id_type&,
                                             const CharacteristicNominalId_type&);

      DistanceBetweenCharacteristicItemType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      DistanceBetweenCharacteristicItemType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      DistanceBetweenCharacteristicItemType (const DistanceBetweenCharacteristicItemType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual DistanceBetweenCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DistanceBetweenCharacteristicItemType&
      operator= (const DistanceBetweenCharacteristicItemType&) = default;
#endif

      virtual 
      ~DistanceBetweenCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL DistanceBetweenCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      DistanceBetweenCharacteristicDefinitionType ();

      DistanceBetweenCharacteristicDefinitionType (const id_type&);

      DistanceBetweenCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      DistanceBetweenCharacteristicDefinitionType (const DistanceBetweenCharacteristicDefinitionType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual DistanceBetweenCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DistanceBetweenCharacteristicDefinitionType&
      operator= (const DistanceBetweenCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~DistanceBetweenCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL DistanceBetweenCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // FeatureNominalPairs
      //
      typedef ::xsd::qif30::ArrayPairReferenceFullType FeatureNominalPairs_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalPairs_type > FeatureNominalPairs_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalPairs_type, wchar_t > FeatureNominalPairs_traits;

      const FeatureNominalPairs_optional&
      FeatureNominalPairs () const;

      FeatureNominalPairs_optional&
      FeatureNominalPairs ();

      void
      FeatureNominalPairs (const FeatureNominalPairs_type& x);

      void
      FeatureNominalPairs (const FeatureNominalPairs_optional& x);

      void
      FeatureNominalPairs (::std::unique_ptr< FeatureNominalPairs_type > p);

      // AnalysisVector
      //
      typedef ::xsd::qif30::UnitVectorType AnalysisVector_type;
      typedef ::xsd::cxx::tree::optional< AnalysisVector_type > AnalysisVector_optional;
      typedef ::xsd::cxx::tree::traits< AnalysisVector_type, wchar_t > AnalysisVector_traits;

      const AnalysisVector_optional&
      AnalysisVector () const;

      AnalysisVector_optional&
      AnalysisVector ();

      void
      AnalysisVector (const AnalysisVector_type& x);

      void
      AnalysisVector (const AnalysisVector_optional& x);

      void
      AnalysisVector (::std::unique_ptr< AnalysisVector_type > p);

      // AnalysisMode
      //
      typedef ::xsd::qif30::DistanceBetweenAnalysisModeEnumType AnalysisMode_type;
      typedef ::xsd::cxx::tree::traits< AnalysisMode_type, wchar_t > AnalysisMode_traits;

      const AnalysisMode_type&
      AnalysisMode () const;

      AnalysisMode_type&
      AnalysisMode ();

      void
      AnalysisMode (const AnalysisMode_type& x);

      void
      AnalysisMode (::std::unique_ptr< AnalysisMode_type > p);

      // MeasurementDirective
      //
      typedef ::xsd::qif30::MeasurementDirectiveType MeasurementDirective_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDirective_type > MeasurementDirective_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDirective_type, wchar_t > MeasurementDirective_traits;

      const MeasurementDirective_optional&
      MeasurementDirective () const;

      MeasurementDirective_optional&
      MeasurementDirective ();

      void
      MeasurementDirective (const MeasurementDirective_type& x);

      void
      MeasurementDirective (const MeasurementDirective_optional& x);

      void
      MeasurementDirective (::std::unique_ptr< MeasurementDirective_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // Constructors.
      //
      DistanceBetweenCharacteristicNominalType ();

      DistanceBetweenCharacteristicNominalType (const id_type&,
                                                const CharacteristicDefinitionId_type&,
                                                const AnalysisMode_type&);

      DistanceBetweenCharacteristicNominalType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                                const AnalysisMode_type&);

      DistanceBetweenCharacteristicNominalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      DistanceBetweenCharacteristicNominalType (const DistanceBetweenCharacteristicNominalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual DistanceBetweenCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DistanceBetweenCharacteristicNominalType&
      operator= (const DistanceBetweenCharacteristicNominalType& x);

      virtual 
      ~DistanceBetweenCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureNominalPairs_optional FeatureNominalPairs_;
      AnalysisVector_optional AnalysisVector_;
      ::xsd::cxx::tree::one< AnalysisMode_type > AnalysisMode_;
      MeasurementDirective_optional MeasurementDirective_;
      CoordinateSystemId_optional CoordinateSystemId_;
    };

    class QIF30_SYMBOL_DECL DistanceBetweenCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // AnalysisVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType AnalysisVector_type;
      typedef ::xsd::cxx::tree::optional< AnalysisVector_type > AnalysisVector_optional;
      typedef ::xsd::cxx::tree::traits< AnalysisVector_type, wchar_t > AnalysisVector_traits;

      const AnalysisVector_optional&
      AnalysisVector () const;

      AnalysisVector_optional&
      AnalysisVector ();

      void
      AnalysisVector (const AnalysisVector_type& x);

      void
      AnalysisVector (const AnalysisVector_optional& x);

      void
      AnalysisVector (::std::unique_ptr< AnalysisVector_type > p);

      // Constructors.
      //
      DistanceBetweenCharacteristicMeasurementType ();

      DistanceBetweenCharacteristicMeasurementType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      DistanceBetweenCharacteristicMeasurementType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      DistanceBetweenCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      DistanceBetweenCharacteristicMeasurementType (const DistanceBetweenCharacteristicMeasurementType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual DistanceBetweenCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DistanceBetweenCharacteristicMeasurementType&
      operator= (const DistanceBetweenCharacteristicMeasurementType& x);

      virtual 
      ~DistanceBetweenCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AnalysisVector_optional AnalysisVector_;
    };

    class QIF30_SYMBOL_DECL RadiusCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      RadiusCharacteristicItemType ();

      RadiusCharacteristicItemType (const id_type&,
                                    const CharacteristicNominalId_type&);

      RadiusCharacteristicItemType (const id_type&,
                                    ::std::unique_ptr< CharacteristicNominalId_type >);

      RadiusCharacteristicItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      RadiusCharacteristicItemType (const RadiusCharacteristicItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual RadiusCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      RadiusCharacteristicItemType&
      operator= (const RadiusCharacteristicItemType&) = default;
#endif

      virtual 
      ~RadiusCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL RadiusCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // ControlledRadius
      //
      typedef ::xml_schema::boolean ControlledRadius_type;
      typedef ::xsd::cxx::tree::optional< ControlledRadius_type > ControlledRadius_optional;
      typedef ::xsd::cxx::tree::traits< ControlledRadius_type, wchar_t > ControlledRadius_traits;

      const ControlledRadius_optional&
      ControlledRadius () const;

      ControlledRadius_optional&
      ControlledRadius ();

      void
      ControlledRadius (const ControlledRadius_type& x);

      void
      ControlledRadius (const ControlledRadius_optional& x);

      // Constructors.
      //
      RadiusCharacteristicDefinitionType ();

      RadiusCharacteristicDefinitionType (const id_type&);

      RadiusCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      RadiusCharacteristicDefinitionType (const RadiusCharacteristicDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual RadiusCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RadiusCharacteristicDefinitionType&
      operator= (const RadiusCharacteristicDefinitionType& x);

      virtual 
      ~RadiusCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ControlledRadius_optional ControlledRadius_;
    };

    class QIF30_SYMBOL_DECL RadiusCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      RadiusCharacteristicNominalType ();

      RadiusCharacteristicNominalType (const id_type&,
                                       const CharacteristicDefinitionId_type&);

      RadiusCharacteristicNominalType (const id_type&,
                                       ::std::unique_ptr< CharacteristicDefinitionId_type >);

      RadiusCharacteristicNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      RadiusCharacteristicNominalType (const RadiusCharacteristicNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual RadiusCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      RadiusCharacteristicNominalType&
      operator= (const RadiusCharacteristicNominalType&) = default;
#endif

      virtual 
      ~RadiusCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL RadiusCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      RadiusCharacteristicMeasurementType ();

      RadiusCharacteristicMeasurementType (const id_type&,
                                           const Status_type&,
                                           const CharacteristicItemId_type&);

      RadiusCharacteristicMeasurementType (const id_type&,
                                           ::std::unique_ptr< Status_type >,
                                           ::std::unique_ptr< CharacteristicItemId_type >);

      RadiusCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      RadiusCharacteristicMeasurementType (const RadiusCharacteristicMeasurementType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual RadiusCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      RadiusCharacteristicMeasurementType&
      operator= (const RadiusCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~RadiusCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL SphericalRadiusCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SphericalRadiusCharacteristicItemType ();

      SphericalRadiusCharacteristicItemType (const id_type&,
                                             const CharacteristicNominalId_type&);

      SphericalRadiusCharacteristicItemType (const id_type&,
                                             ::std::unique_ptr< CharacteristicNominalId_type >);

      SphericalRadiusCharacteristicItemType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      SphericalRadiusCharacteristicItemType (const SphericalRadiusCharacteristicItemType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual SphericalRadiusCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalRadiusCharacteristicItemType&
      operator= (const SphericalRadiusCharacteristicItemType&) = default;
#endif

      virtual 
      ~SphericalRadiusCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL SphericalRadiusCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      SphericalRadiusCharacteristicDefinitionType ();

      SphericalRadiusCharacteristicDefinitionType (const id_type&);

      SphericalRadiusCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      SphericalRadiusCharacteristicDefinitionType (const SphericalRadiusCharacteristicDefinitionType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual SphericalRadiusCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalRadiusCharacteristicDefinitionType&
      operator= (const SphericalRadiusCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~SphericalRadiusCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL SphericalRadiusCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      SphericalRadiusCharacteristicNominalType ();

      SphericalRadiusCharacteristicNominalType (const id_type&,
                                                const CharacteristicDefinitionId_type&);

      SphericalRadiusCharacteristicNominalType (const id_type&,
                                                ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SphericalRadiusCharacteristicNominalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      SphericalRadiusCharacteristicNominalType (const SphericalRadiusCharacteristicNominalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual SphericalRadiusCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalRadiusCharacteristicNominalType&
      operator= (const SphericalRadiusCharacteristicNominalType&) = default;
#endif

      virtual 
      ~SphericalRadiusCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL SphericalRadiusCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      SphericalRadiusCharacteristicMeasurementType ();

      SphericalRadiusCharacteristicMeasurementType (const id_type&,
                                                    const Status_type&,
                                                    const CharacteristicItemId_type&);

      SphericalRadiusCharacteristicMeasurementType (const id_type&,
                                                    ::std::unique_ptr< Status_type >,
                                                    ::std::unique_ptr< CharacteristicItemId_type >);

      SphericalRadiusCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      SphericalRadiusCharacteristicMeasurementType (const SphericalRadiusCharacteristicMeasurementType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual SphericalRadiusCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalRadiusCharacteristicMeasurementType&
      operator= (const SphericalRadiusCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~SphericalRadiusCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL ChordCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ChordCharacteristicItemType ();

      ChordCharacteristicItemType (const id_type&,
                                   const CharacteristicNominalId_type&);

      ChordCharacteristicItemType (const id_type&,
                                   ::std::unique_ptr< CharacteristicNominalId_type >);

      ChordCharacteristicItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ChordCharacteristicItemType (const ChordCharacteristicItemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ChordCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ChordCharacteristicItemType&
      operator= (const ChordCharacteristicItemType&) = default;
#endif

      virtual 
      ~ChordCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ChordCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      ChordCharacteristicDefinitionType ();

      ChordCharacteristicDefinitionType (const id_type&);

      ChordCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ChordCharacteristicDefinitionType (const ChordCharacteristicDefinitionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ChordCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ChordCharacteristicDefinitionType&
      operator= (const ChordCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~ChordCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL ChordCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      ChordCharacteristicNominalType ();

      ChordCharacteristicNominalType (const id_type&,
                                      const CharacteristicDefinitionId_type&);

      ChordCharacteristicNominalType (const id_type&,
                                      ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ChordCharacteristicNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ChordCharacteristicNominalType (const ChordCharacteristicNominalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ChordCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ChordCharacteristicNominalType&
      operator= (const ChordCharacteristicNominalType&) = default;
#endif

      virtual 
      ~ChordCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL ChordCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      ChordCharacteristicMeasurementType ();

      ChordCharacteristicMeasurementType (const id_type&,
                                          const Status_type&,
                                          const CharacteristicItemId_type&);

      ChordCharacteristicMeasurementType (const id_type&,
                                          ::std::unique_ptr< Status_type >,
                                          ::std::unique_ptr< CharacteristicItemId_type >);

      ChordCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ChordCharacteristicMeasurementType (const ChordCharacteristicMeasurementType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ChordCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ChordCharacteristicMeasurementType&
      operator= (const ChordCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~ChordCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL ConicalTaperCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ConicalTaperCharacteristicItemType ();

      ConicalTaperCharacteristicItemType (const id_type&,
                                          const CharacteristicNominalId_type&);

      ConicalTaperCharacteristicItemType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >);

      ConicalTaperCharacteristicItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ConicalTaperCharacteristicItemType (const ConicalTaperCharacteristicItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ConicalTaperCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConicalTaperCharacteristicItemType&
      operator= (const ConicalTaperCharacteristicItemType&) = default;
#endif

      virtual 
      ~ConicalTaperCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ConicalTaperCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      ConicalTaperCharacteristicDefinitionType ();

      ConicalTaperCharacteristicDefinitionType (const id_type&);

      ConicalTaperCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ConicalTaperCharacteristicDefinitionType (const ConicalTaperCharacteristicDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ConicalTaperCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConicalTaperCharacteristicDefinitionType&
      operator= (const ConicalTaperCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~ConicalTaperCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL ConicalTaperCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Distance
      //
      typedef ::xsd::qif30::LinearValueType Distance_type;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t > Distance_traits;

      const Distance_type&
      Distance () const;

      Distance_type&
      Distance ();

      void
      Distance (const Distance_type& x);

      void
      Distance (::std::unique_ptr< Distance_type > p);

      // Constructors.
      //
      ConicalTaperCharacteristicNominalType ();

      ConicalTaperCharacteristicNominalType (const id_type&,
                                             const CharacteristicDefinitionId_type&,
                                             const Distance_type&);

      ConicalTaperCharacteristicNominalType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                             ::std::unique_ptr< Distance_type >);

      ConicalTaperCharacteristicNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ConicalTaperCharacteristicNominalType (const ConicalTaperCharacteristicNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ConicalTaperCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalTaperCharacteristicNominalType&
      operator= (const ConicalTaperCharacteristicNominalType& x);

      virtual 
      ~ConicalTaperCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Distance_type > Distance_;
    };

    class QIF30_SYMBOL_DECL ConicalTaperCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Distance
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Distance_type;
      typedef ::xsd::cxx::tree::optional< Distance_type > Distance_optional;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t > Distance_traits;

      const Distance_optional&
      Distance () const;

      Distance_optional&
      Distance ();

      void
      Distance (const Distance_type& x);

      void
      Distance (const Distance_optional& x);

      void
      Distance (::std::unique_ptr< Distance_type > p);

      // Constructors.
      //
      ConicalTaperCharacteristicMeasurementType ();

      ConicalTaperCharacteristicMeasurementType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&);

      ConicalTaperCharacteristicMeasurementType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >);

      ConicalTaperCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      ConicalTaperCharacteristicMeasurementType (const ConicalTaperCharacteristicMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual ConicalTaperCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalTaperCharacteristicMeasurementType&
      operator= (const ConicalTaperCharacteristicMeasurementType& x);

      virtual 
      ~ConicalTaperCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Distance_optional Distance_;
    };

    class QIF30_SYMBOL_DECL FlatTaperCharacteristicItemType: public ::xsd::qif30::LinearCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      FlatTaperCharacteristicItemType ();

      FlatTaperCharacteristicItemType (const id_type&,
                                       const CharacteristicNominalId_type&);

      FlatTaperCharacteristicItemType (const id_type&,
                                       ::std::unique_ptr< CharacteristicNominalId_type >);

      FlatTaperCharacteristicItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      FlatTaperCharacteristicItemType (const FlatTaperCharacteristicItemType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual FlatTaperCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FlatTaperCharacteristicItemType&
      operator= (const FlatTaperCharacteristicItemType&) = default;
#endif

      virtual 
      ~FlatTaperCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL FlatTaperCharacteristicDefinitionType: public ::xsd::qif30::LinearCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      FlatTaperCharacteristicDefinitionType ();

      FlatTaperCharacteristicDefinitionType (const id_type&);

      FlatTaperCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      FlatTaperCharacteristicDefinitionType (const FlatTaperCharacteristicDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual FlatTaperCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FlatTaperCharacteristicDefinitionType&
      operator= (const FlatTaperCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~FlatTaperCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL FlatTaperCharacteristicNominalType: public ::xsd::qif30::LinearCharacteristicNominalBaseType
    {
      public:
      // Distance
      //
      typedef ::xsd::qif30::LinearValueType Distance_type;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t > Distance_traits;

      const Distance_type&
      Distance () const;

      Distance_type&
      Distance ();

      void
      Distance (const Distance_type& x);

      void
      Distance (::std::unique_ptr< Distance_type > p);

      // Constructors.
      //
      FlatTaperCharacteristicNominalType ();

      FlatTaperCharacteristicNominalType (const id_type&,
                                          const CharacteristicDefinitionId_type&,
                                          const Distance_type&);

      FlatTaperCharacteristicNominalType (const id_type&,
                                          ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                          ::std::unique_ptr< Distance_type >);

      FlatTaperCharacteristicNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      FlatTaperCharacteristicNominalType (const FlatTaperCharacteristicNominalType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual FlatTaperCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FlatTaperCharacteristicNominalType&
      operator= (const FlatTaperCharacteristicNominalType& x);

      virtual 
      ~FlatTaperCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Distance_type > Distance_;
    };

    class QIF30_SYMBOL_DECL FlatTaperCharacteristicMeasurementType: public ::xsd::qif30::LinearCharacteristicMeasurementBaseType
    {
      public:
      // Distance
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Distance_type;
      typedef ::xsd::cxx::tree::optional< Distance_type > Distance_optional;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t > Distance_traits;

      const Distance_optional&
      Distance () const;

      Distance_optional&
      Distance ();

      void
      Distance (const Distance_type& x);

      void
      Distance (const Distance_optional& x);

      void
      Distance (::std::unique_ptr< Distance_type > p);

      // Constructors.
      //
      FlatTaperCharacteristicMeasurementType ();

      FlatTaperCharacteristicMeasurementType (const id_type&,
                                              const Status_type&,
                                              const CharacteristicItemId_type&);

      FlatTaperCharacteristicMeasurementType (const id_type&,
                                              ::std::unique_ptr< Status_type >,
                                              ::std::unique_ptr< CharacteristicItemId_type >);

      FlatTaperCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      FlatTaperCharacteristicMeasurementType (const FlatTaperCharacteristicMeasurementType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual FlatTaperCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FlatTaperCharacteristicMeasurementType&
      operator= (const FlatTaperCharacteristicMeasurementType& x);

      virtual 
      ~FlatTaperCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Distance_optional Distance_;
    };

    class QIF30_SYMBOL_DECL RunoutCharacteristicItemBaseType: public ::xsd::qif30::GeometricCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      RunoutCharacteristicItemBaseType ();

      RunoutCharacteristicItemBaseType (const id_type&,
                                        const CharacteristicNominalId_type&);

      RunoutCharacteristicItemBaseType (const id_type&,
                                        ::std::unique_ptr< CharacteristicNominalId_type >);

      RunoutCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      RunoutCharacteristicItemBaseType (const RunoutCharacteristicItemBaseType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual RunoutCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      RunoutCharacteristicItemBaseType&
      operator= (const RunoutCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~RunoutCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL RunoutCharacteristicDefinitionBaseType: public ::xsd::qif30::GeometricCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // DatumReferenceFrameId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumReferenceFrameId_type;
      typedef ::xsd::cxx::tree::optional< DatumReferenceFrameId_type > DatumReferenceFrameId_optional;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameId_type, wchar_t > DatumReferenceFrameId_traits;

      const DatumReferenceFrameId_optional&
      DatumReferenceFrameId () const;

      DatumReferenceFrameId_optional&
      DatumReferenceFrameId ();

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_type& x);

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_optional& x);

      void
      DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > p);

      // Constructors.
      //
      RunoutCharacteristicDefinitionBaseType ();

      RunoutCharacteristicDefinitionBaseType (const id_type&,
                                              const ToleranceValue_type&);

      RunoutCharacteristicDefinitionBaseType (const id_type&,
                                              ::std::unique_ptr< ToleranceValue_type >);

      RunoutCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      RunoutCharacteristicDefinitionBaseType (const RunoutCharacteristicDefinitionBaseType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual RunoutCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      RunoutCharacteristicDefinitionBaseType&
      operator= (const RunoutCharacteristicDefinitionBaseType& x);

      virtual 
      ~RunoutCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      DatumReferenceFrameId_optional DatumReferenceFrameId_;
    };

    class QIF30_SYMBOL_DECL RunoutCharacteristicNominalBaseType: public ::xsd::qif30::GeometricCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      RunoutCharacteristicNominalBaseType ();

      RunoutCharacteristicNominalBaseType (const id_type&,
                                           const CharacteristicDefinitionId_type&);

      RunoutCharacteristicNominalBaseType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >);

      RunoutCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      RunoutCharacteristicNominalBaseType (const RunoutCharacteristicNominalBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual RunoutCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      RunoutCharacteristicNominalBaseType&
      operator= (const RunoutCharacteristicNominalBaseType&) = default;
#endif

      virtual 
      ~RunoutCharacteristicNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL RunoutCharacteristicMeasurementBaseType: public ::xsd::qif30::GeometricCharacteristicMeasurementBaseType
    {
      public:
      // DatumsOk
      //
      typedef ::xml_schema::boolean DatumsOk_type;
      typedef ::xsd::cxx::tree::optional< DatumsOk_type > DatumsOk_optional;
      typedef ::xsd::cxx::tree::traits< DatumsOk_type, wchar_t > DatumsOk_traits;

      const DatumsOk_optional&
      DatumsOk () const;

      DatumsOk_optional&
      DatumsOk ();

      void
      DatumsOk (const DatumsOk_type& x);

      void
      DatumsOk (const DatumsOk_optional& x);

      // Constructors.
      //
      RunoutCharacteristicMeasurementBaseType ();

      RunoutCharacteristicMeasurementBaseType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&);

      RunoutCharacteristicMeasurementBaseType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >);

      RunoutCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      RunoutCharacteristicMeasurementBaseType (const RunoutCharacteristicMeasurementBaseType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual RunoutCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      RunoutCharacteristicMeasurementBaseType&
      operator= (const RunoutCharacteristicMeasurementBaseType& x);

      virtual 
      ~RunoutCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DatumsOk_optional DatumsOk_;
    };

    class QIF30_SYMBOL_DECL CircularRunoutCharacteristicItemType: public ::xsd::qif30::RunoutCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      CircularRunoutCharacteristicItemType ();

      CircularRunoutCharacteristicItemType (const id_type&,
                                            const CharacteristicNominalId_type&);

      CircularRunoutCharacteristicItemType (const id_type&,
                                            ::std::unique_ptr< CharacteristicNominalId_type >);

      CircularRunoutCharacteristicItemType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CircularRunoutCharacteristicItemType (const CircularRunoutCharacteristicItemType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CircularRunoutCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CircularRunoutCharacteristicItemType&
      operator= (const CircularRunoutCharacteristicItemType&) = default;
#endif

      virtual 
      ~CircularRunoutCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL CircularRunoutCharacteristicDefinitionType: public ::xsd::qif30::RunoutCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      CircularRunoutCharacteristicDefinitionType ();

      CircularRunoutCharacteristicDefinitionType (const id_type&,
                                                  const ToleranceValue_type&);

      CircularRunoutCharacteristicDefinitionType (const id_type&,
                                                  ::std::unique_ptr< ToleranceValue_type >);

      CircularRunoutCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      CircularRunoutCharacteristicDefinitionType (const CircularRunoutCharacteristicDefinitionType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual CircularRunoutCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CircularRunoutCharacteristicDefinitionType&
      operator= (const CircularRunoutCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~CircularRunoutCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL CircularRunoutCharacteristicNominalType: public ::xsd::qif30::RunoutCharacteristicNominalBaseType
    {
      public:
      // ZoneDirection
      //
      typedef ::xsd::qif30::UnitVectorType ZoneDirection_type;
      typedef ::xsd::cxx::tree::optional< ZoneDirection_type > ZoneDirection_optional;
      typedef ::xsd::cxx::tree::traits< ZoneDirection_type, wchar_t > ZoneDirection_traits;

      const ZoneDirection_optional&
      ZoneDirection () const;

      ZoneDirection_optional&
      ZoneDirection ();

      void
      ZoneDirection (const ZoneDirection_type& x);

      void
      ZoneDirection (const ZoneDirection_optional& x);

      void
      ZoneDirection (::std::unique_ptr< ZoneDirection_type > p);

      // ProfileCurveId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ProfileCurveId_type;
      typedef ::xsd::cxx::tree::optional< ProfileCurveId_type > ProfileCurveId_optional;
      typedef ::xsd::cxx::tree::traits< ProfileCurveId_type, wchar_t > ProfileCurveId_traits;

      const ProfileCurveId_optional&
      ProfileCurveId () const;

      ProfileCurveId_optional&
      ProfileCurveId ();

      void
      ProfileCurveId (const ProfileCurveId_type& x);

      void
      ProfileCurveId (const ProfileCurveId_optional& x);

      void
      ProfileCurveId (::std::unique_ptr< ProfileCurveId_type > p);

      // Constructors.
      //
      CircularRunoutCharacteristicNominalType ();

      CircularRunoutCharacteristicNominalType (const id_type&,
                                               const CharacteristicDefinitionId_type&);

      CircularRunoutCharacteristicNominalType (const id_type&,
                                               ::std::unique_ptr< CharacteristicDefinitionId_type >);

      CircularRunoutCharacteristicNominalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CircularRunoutCharacteristicNominalType (const CircularRunoutCharacteristicNominalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CircularRunoutCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularRunoutCharacteristicNominalType&
      operator= (const CircularRunoutCharacteristicNominalType& x);

      virtual 
      ~CircularRunoutCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ZoneDirection_optional ZoneDirection_;
      ProfileCurveId_optional ProfileCurveId_;
    };

    class QIF30_SYMBOL_DECL CircularRunoutCharacteristicMeasurementType: public ::xsd::qif30::RunoutCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      CircularRunoutCharacteristicMeasurementType ();

      CircularRunoutCharacteristicMeasurementType (const id_type&,
                                                   const Status_type&,
                                                   const CharacteristicItemId_type&);

      CircularRunoutCharacteristicMeasurementType (const id_type&,
                                                   ::std::unique_ptr< Status_type >,
                                                   ::std::unique_ptr< CharacteristicItemId_type >);

      CircularRunoutCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      CircularRunoutCharacteristicMeasurementType (const CircularRunoutCharacteristicMeasurementType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual CircularRunoutCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CircularRunoutCharacteristicMeasurementType&
      operator= (const CircularRunoutCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~CircularRunoutCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL TotalRunoutCharacteristicItemType: public ::xsd::qif30::RunoutCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      TotalRunoutCharacteristicItemType ();

      TotalRunoutCharacteristicItemType (const id_type&,
                                         const CharacteristicNominalId_type&);

      TotalRunoutCharacteristicItemType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      TotalRunoutCharacteristicItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      TotalRunoutCharacteristicItemType (const TotalRunoutCharacteristicItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual TotalRunoutCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      TotalRunoutCharacteristicItemType&
      operator= (const TotalRunoutCharacteristicItemType&) = default;
#endif

      virtual 
      ~TotalRunoutCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL TotalRunoutCharacteristicDefinitionType: public ::xsd::qif30::RunoutCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      TotalRunoutCharacteristicDefinitionType ();

      TotalRunoutCharacteristicDefinitionType (const id_type&,
                                               const ToleranceValue_type&);

      TotalRunoutCharacteristicDefinitionType (const id_type&,
                                               ::std::unique_ptr< ToleranceValue_type >);

      TotalRunoutCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      TotalRunoutCharacteristicDefinitionType (const TotalRunoutCharacteristicDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual TotalRunoutCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      TotalRunoutCharacteristicDefinitionType&
      operator= (const TotalRunoutCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~TotalRunoutCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL TotalRunoutCharacteristicNominalType: public ::xsd::qif30::RunoutCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      TotalRunoutCharacteristicNominalType ();

      TotalRunoutCharacteristicNominalType (const id_type&,
                                            const CharacteristicDefinitionId_type&);

      TotalRunoutCharacteristicNominalType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >);

      TotalRunoutCharacteristicNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      TotalRunoutCharacteristicNominalType (const TotalRunoutCharacteristicNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual TotalRunoutCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      TotalRunoutCharacteristicNominalType&
      operator= (const TotalRunoutCharacteristicNominalType&) = default;
#endif

      virtual 
      ~TotalRunoutCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL TotalRunoutCharacteristicMeasurementType: public ::xsd::qif30::RunoutCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      TotalRunoutCharacteristicMeasurementType ();

      TotalRunoutCharacteristicMeasurementType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      TotalRunoutCharacteristicMeasurementType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      TotalRunoutCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      TotalRunoutCharacteristicMeasurementType (const TotalRunoutCharacteristicMeasurementType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual TotalRunoutCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      TotalRunoutCharacteristicMeasurementType&
      operator= (const TotalRunoutCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~TotalRunoutCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL CoaxialityDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      CoaxialityDiametricalZoneType ();

      CoaxialityDiametricalZoneType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CoaxialityDiametricalZoneType (const xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CoaxialityDiametricalZoneType (const ::std::wstring& s,
                                     const xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CoaxialityDiametricalZoneType (const CoaxialityDiametricalZoneType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CoaxialityDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CoaxialityDiametricalZoneType&
      operator= (const CoaxialityDiametricalZoneType&) = default;
#endif

      virtual 
      ~CoaxialityDiametricalZoneType ();
    };

    class QIF30_SYMBOL_DECL CoaxialityNonDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      CoaxialityNonDiametricalZoneType ();

      CoaxialityNonDiametricalZoneType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      CoaxialityNonDiametricalZoneType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      CoaxialityNonDiametricalZoneType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      CoaxialityNonDiametricalZoneType (const CoaxialityNonDiametricalZoneType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual CoaxialityNonDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CoaxialityNonDiametricalZoneType&
      operator= (const CoaxialityNonDiametricalZoneType&) = default;
#endif

      virtual 
      ~CoaxialityNonDiametricalZoneType ();
    };

    class QIF30_SYMBOL_DECL CoaxialityZoneShapeType: public ::xml_schema::type
    {
      public:
      // DiametricalZone
      //
      typedef ::xsd::qif30::CoaxialityDiametricalZoneType DiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< DiametricalZone_type > DiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< DiametricalZone_type, wchar_t > DiametricalZone_traits;

      const DiametricalZone_optional&
      DiametricalZone () const;

      DiametricalZone_optional&
      DiametricalZone ();

      void
      DiametricalZone (const DiametricalZone_type& x);

      void
      DiametricalZone (const DiametricalZone_optional& x);

      void
      DiametricalZone (::std::unique_ptr< DiametricalZone_type > p);

      // NonDiametricalZone
      //
      typedef ::xsd::qif30::CoaxialityNonDiametricalZoneType NonDiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< NonDiametricalZone_type > NonDiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< NonDiametricalZone_type, wchar_t > NonDiametricalZone_traits;

      const NonDiametricalZone_optional&
      NonDiametricalZone () const;

      NonDiametricalZone_optional&
      NonDiametricalZone ();

      void
      NonDiametricalZone (const NonDiametricalZone_type& x);

      void
      NonDiametricalZone (const NonDiametricalZone_optional& x);

      void
      NonDiametricalZone (::std::unique_ptr< NonDiametricalZone_type > p);

      // Constructors.
      //
      CoaxialityZoneShapeType ();

      CoaxialityZoneShapeType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CoaxialityZoneShapeType (const CoaxialityZoneShapeType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CoaxialityZoneShapeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoaxialityZoneShapeType&
      operator= (const CoaxialityZoneShapeType& x);

      virtual 
      ~CoaxialityZoneShapeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DiametricalZone_optional DiametricalZone_;
      NonDiametricalZone_optional NonDiametricalZone_;
    };

    class QIF30_SYMBOL_DECL CoaxialityCharacteristicItemType: public ::xsd::qif30::LocationCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      CoaxialityCharacteristicItemType ();

      CoaxialityCharacteristicItemType (const id_type&,
                                        const CharacteristicNominalId_type&);

      CoaxialityCharacteristicItemType (const id_type&,
                                        ::std::unique_ptr< CharacteristicNominalId_type >);

      CoaxialityCharacteristicItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      CoaxialityCharacteristicItemType (const CoaxialityCharacteristicItemType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual CoaxialityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CoaxialityCharacteristicItemType&
      operator= (const CoaxialityCharacteristicItemType&) = default;
#endif

      virtual 
      ~CoaxialityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL CoaxialityCharacteristicDefinitionType: public ::xsd::qif30::LocationCharacteristicDefinitionBaseType
    {
      public:
      // ZoneShape
      //
      typedef ::xsd::qif30::CoaxialityZoneShapeType ZoneShape_type;
      typedef ::xsd::cxx::tree::traits< ZoneShape_type, wchar_t > ZoneShape_traits;

      const ZoneShape_type&
      ZoneShape () const;

      ZoneShape_type&
      ZoneShape ();

      void
      ZoneShape (const ZoneShape_type& x);

      void
      ZoneShape (::std::unique_ptr< ZoneShape_type > p);

      // Constructors.
      //
      CoaxialityCharacteristicDefinitionType ();

      CoaxialityCharacteristicDefinitionType (const id_type&,
                                              const ToleranceValue_type&,
                                              const ZoneShape_type&);

      CoaxialityCharacteristicDefinitionType (const id_type&,
                                              ::std::unique_ptr< ToleranceValue_type >,
                                              ::std::unique_ptr< ZoneShape_type >);

      CoaxialityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      CoaxialityCharacteristicDefinitionType (const CoaxialityCharacteristicDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual CoaxialityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoaxialityCharacteristicDefinitionType&
      operator= (const CoaxialityCharacteristicDefinitionType& x);

      virtual 
      ~CoaxialityCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ZoneShape_type > ZoneShape_;
    };

    class QIF30_SYMBOL_DECL CoaxialityCharacteristicNominalType: public ::xsd::qif30::LocationCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      CoaxialityCharacteristicNominalType ();

      CoaxialityCharacteristicNominalType (const id_type&,
                                           const CharacteristicDefinitionId_type&);

      CoaxialityCharacteristicNominalType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >);

      CoaxialityCharacteristicNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      CoaxialityCharacteristicNominalType (const CoaxialityCharacteristicNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual CoaxialityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CoaxialityCharacteristicNominalType&
      operator= (const CoaxialityCharacteristicNominalType&) = default;
#endif

      virtual 
      ~CoaxialityCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL CoaxialityCharacteristicMeasurementType: public ::xsd::qif30::LocationCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      CoaxialityCharacteristicMeasurementType ();

      CoaxialityCharacteristicMeasurementType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&);

      CoaxialityCharacteristicMeasurementType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >);

      CoaxialityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CoaxialityCharacteristicMeasurementType (const CoaxialityCharacteristicMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CoaxialityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CoaxialityCharacteristicMeasurementType&
      operator= (const CoaxialityCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~CoaxialityCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL ConcentricitySphericalZoneType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ConcentricitySphericalZoneType ();

      ConcentricitySphericalZoneType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ConcentricitySphericalZoneType (const xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ConcentricitySphericalZoneType (const ::std::wstring& s,
                                      const xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ConcentricitySphericalZoneType (const ConcentricitySphericalZoneType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ConcentricitySphericalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConcentricitySphericalZoneType&
      operator= (const ConcentricitySphericalZoneType&) = default;
#endif

      virtual 
      ~ConcentricitySphericalZoneType ();
    };

    class QIF30_SYMBOL_DECL ConcentricityDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ConcentricityDiametricalZoneType ();

      ConcentricityDiametricalZoneType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ConcentricityDiametricalZoneType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ConcentricityDiametricalZoneType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ConcentricityDiametricalZoneType (const ConcentricityDiametricalZoneType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual ConcentricityDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConcentricityDiametricalZoneType&
      operator= (const ConcentricityDiametricalZoneType&) = default;
#endif

      virtual 
      ~ConcentricityDiametricalZoneType ();
    };

    class QIF30_SYMBOL_DECL ConcentricityNonDiametricalZoneType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ConcentricityNonDiametricalZoneType ();

      ConcentricityNonDiametricalZoneType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ConcentricityNonDiametricalZoneType (const xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ConcentricityNonDiametricalZoneType (const ::std::wstring& s,
                                           const xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ConcentricityNonDiametricalZoneType (const ConcentricityNonDiametricalZoneType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ConcentricityNonDiametricalZoneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConcentricityNonDiametricalZoneType&
      operator= (const ConcentricityNonDiametricalZoneType&) = default;
#endif

      virtual 
      ~ConcentricityNonDiametricalZoneType ();
    };

    class QIF30_SYMBOL_DECL ConcentricityZoneShapeType: public ::xml_schema::type
    {
      public:
      // SphericalZone
      //
      typedef ::xsd::qif30::ConcentricitySphericalZoneType SphericalZone_type;
      typedef ::xsd::cxx::tree::optional< SphericalZone_type > SphericalZone_optional;
      typedef ::xsd::cxx::tree::traits< SphericalZone_type, wchar_t > SphericalZone_traits;

      const SphericalZone_optional&
      SphericalZone () const;

      SphericalZone_optional&
      SphericalZone ();

      void
      SphericalZone (const SphericalZone_type& x);

      void
      SphericalZone (const SphericalZone_optional& x);

      void
      SphericalZone (::std::unique_ptr< SphericalZone_type > p);

      // DiametricalZone
      //
      typedef ::xsd::qif30::ConcentricityDiametricalZoneType DiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< DiametricalZone_type > DiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< DiametricalZone_type, wchar_t > DiametricalZone_traits;

      const DiametricalZone_optional&
      DiametricalZone () const;

      DiametricalZone_optional&
      DiametricalZone ();

      void
      DiametricalZone (const DiametricalZone_type& x);

      void
      DiametricalZone (const DiametricalZone_optional& x);

      void
      DiametricalZone (::std::unique_ptr< DiametricalZone_type > p);

      // NonDiametricalZone
      //
      typedef ::xsd::qif30::ConcentricityNonDiametricalZoneType NonDiametricalZone_type;
      typedef ::xsd::cxx::tree::optional< NonDiametricalZone_type > NonDiametricalZone_optional;
      typedef ::xsd::cxx::tree::traits< NonDiametricalZone_type, wchar_t > NonDiametricalZone_traits;

      const NonDiametricalZone_optional&
      NonDiametricalZone () const;

      NonDiametricalZone_optional&
      NonDiametricalZone ();

      void
      NonDiametricalZone (const NonDiametricalZone_type& x);

      void
      NonDiametricalZone (const NonDiametricalZone_optional& x);

      void
      NonDiametricalZone (::std::unique_ptr< NonDiametricalZone_type > p);

      // Constructors.
      //
      ConcentricityZoneShapeType ();

      ConcentricityZoneShapeType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ConcentricityZoneShapeType (const ConcentricityZoneShapeType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ConcentricityZoneShapeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConcentricityZoneShapeType&
      operator= (const ConcentricityZoneShapeType& x);

      virtual 
      ~ConcentricityZoneShapeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SphericalZone_optional SphericalZone_;
      DiametricalZone_optional DiametricalZone_;
      NonDiametricalZone_optional NonDiametricalZone_;
    };

    class QIF30_SYMBOL_DECL ConcentricityCharacteristicItemType: public ::xsd::qif30::LocationCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ConcentricityCharacteristicItemType ();

      ConcentricityCharacteristicItemType (const id_type&,
                                           const CharacteristicNominalId_type&);

      ConcentricityCharacteristicItemType (const id_type&,
                                           ::std::unique_ptr< CharacteristicNominalId_type >);

      ConcentricityCharacteristicItemType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ConcentricityCharacteristicItemType (const ConcentricityCharacteristicItemType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ConcentricityCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConcentricityCharacteristicItemType&
      operator= (const ConcentricityCharacteristicItemType&) = default;
#endif

      virtual 
      ~ConcentricityCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ConcentricityCharacteristicDefinitionType: public ::xsd::qif30::LocationCharacteristicDefinitionBaseType
    {
      public:
      // ZoneShape
      //
      typedef ::xsd::qif30::ConcentricityZoneShapeType ZoneShape_type;
      typedef ::xsd::cxx::tree::traits< ZoneShape_type, wchar_t > ZoneShape_traits;

      const ZoneShape_type&
      ZoneShape () const;

      ZoneShape_type&
      ZoneShape ();

      void
      ZoneShape (const ZoneShape_type& x);

      void
      ZoneShape (::std::unique_ptr< ZoneShape_type > p);

      // Constructors.
      //
      ConcentricityCharacteristicDefinitionType ();

      ConcentricityCharacteristicDefinitionType (const id_type&,
                                                 const ToleranceValue_type&,
                                                 const ZoneShape_type&);

      ConcentricityCharacteristicDefinitionType (const id_type&,
                                                 ::std::unique_ptr< ToleranceValue_type >,
                                                 ::std::unique_ptr< ZoneShape_type >);

      ConcentricityCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      ConcentricityCharacteristicDefinitionType (const ConcentricityCharacteristicDefinitionType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual ConcentricityCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConcentricityCharacteristicDefinitionType&
      operator= (const ConcentricityCharacteristicDefinitionType& x);

      virtual 
      ~ConcentricityCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ZoneShape_type > ZoneShape_;
    };

    class QIF30_SYMBOL_DECL ConcentricityCharacteristicNominalType: public ::xsd::qif30::LocationCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      ConcentricityCharacteristicNominalType ();

      ConcentricityCharacteristicNominalType (const id_type&,
                                              const CharacteristicDefinitionId_type&);

      ConcentricityCharacteristicNominalType (const id_type&,
                                              ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ConcentricityCharacteristicNominalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ConcentricityCharacteristicNominalType (const ConcentricityCharacteristicNominalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ConcentricityCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConcentricityCharacteristicNominalType&
      operator= (const ConcentricityCharacteristicNominalType&) = default;
#endif

      virtual 
      ~ConcentricityCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL ConcentricityCharacteristicMeasurementType: public ::xsd::qif30::LocationCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      ConcentricityCharacteristicMeasurementType ();

      ConcentricityCharacteristicMeasurementType (const id_type&,
                                                  const Status_type&,
                                                  const CharacteristicItemId_type&);

      ConcentricityCharacteristicMeasurementType (const id_type&,
                                                  ::std::unique_ptr< Status_type >,
                                                  ::std::unique_ptr< CharacteristicItemId_type >);

      ConcentricityCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      ConcentricityCharacteristicMeasurementType (const ConcentricityCharacteristicMeasurementType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual ConcentricityCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConcentricityCharacteristicMeasurementType&
      operator= (const ConcentricityCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~ConcentricityCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL SymmetryCharacteristicItemType: public ::xsd::qif30::LocationCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SymmetryCharacteristicItemType ();

      SymmetryCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      SymmetryCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      SymmetryCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      SymmetryCharacteristicItemType (const SymmetryCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual SymmetryCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SymmetryCharacteristicItemType&
      operator= (const SymmetryCharacteristicItemType&) = default;
#endif

      virtual 
      ~SymmetryCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL SymmetryCharacteristicDefinitionType: public ::xsd::qif30::LocationCharacteristicDefinitionBaseType
    {
      public:
      // SecondCompositeSegmentSymmetryDefinition
      //
      typedef ::xsd::qif30::CompositeSegmentSymmetryDefinitionType SecondCompositeSegmentSymmetryDefinition_type;
      typedef ::xsd::cxx::tree::optional< SecondCompositeSegmentSymmetryDefinition_type > SecondCompositeSegmentSymmetryDefinition_optional;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentSymmetryDefinition_type, wchar_t > SecondCompositeSegmentSymmetryDefinition_traits;

      const SecondCompositeSegmentSymmetryDefinition_optional&
      SecondCompositeSegmentSymmetryDefinition () const;

      SecondCompositeSegmentSymmetryDefinition_optional&
      SecondCompositeSegmentSymmetryDefinition ();

      void
      SecondCompositeSegmentSymmetryDefinition (const SecondCompositeSegmentSymmetryDefinition_type& x);

      void
      SecondCompositeSegmentSymmetryDefinition (const SecondCompositeSegmentSymmetryDefinition_optional& x);

      void
      SecondCompositeSegmentSymmetryDefinition (::std::unique_ptr< SecondCompositeSegmentSymmetryDefinition_type > p);

      // ThirdCompositeSegmentSymmetryDefinition
      //
      typedef ::xsd::qif30::CompositeSegmentSymmetryDefinitionType ThirdCompositeSegmentSymmetryDefinition_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentSymmetryDefinition_type > ThirdCompositeSegmentSymmetryDefinition_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentSymmetryDefinition_type, wchar_t > ThirdCompositeSegmentSymmetryDefinition_traits;

      const ThirdCompositeSegmentSymmetryDefinition_optional&
      ThirdCompositeSegmentSymmetryDefinition () const;

      ThirdCompositeSegmentSymmetryDefinition_optional&
      ThirdCompositeSegmentSymmetryDefinition ();

      void
      ThirdCompositeSegmentSymmetryDefinition (const ThirdCompositeSegmentSymmetryDefinition_type& x);

      void
      ThirdCompositeSegmentSymmetryDefinition (const ThirdCompositeSegmentSymmetryDefinition_optional& x);

      void
      ThirdCompositeSegmentSymmetryDefinition (::std::unique_ptr< ThirdCompositeSegmentSymmetryDefinition_type > p);

      // Constructors.
      //
      SymmetryCharacteristicDefinitionType ();

      SymmetryCharacteristicDefinitionType (const id_type&,
                                            const ToleranceValue_type&);

      SymmetryCharacteristicDefinitionType (const id_type&,
                                            ::std::unique_ptr< ToleranceValue_type >);

      SymmetryCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      SymmetryCharacteristicDefinitionType (const SymmetryCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual SymmetryCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SymmetryCharacteristicDefinitionType&
      operator= (const SymmetryCharacteristicDefinitionType& x);

      virtual 
      ~SymmetryCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SecondCompositeSegmentSymmetryDefinition_optional SecondCompositeSegmentSymmetryDefinition_;
      ThirdCompositeSegmentSymmetryDefinition_optional ThirdCompositeSegmentSymmetryDefinition_;
    };

    class QIF30_SYMBOL_DECL SymmetryCharacteristicNominalType: public ::xsd::qif30::LocationCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      SymmetryCharacteristicNominalType ();

      SymmetryCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      SymmetryCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SymmetryCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      SymmetryCharacteristicNominalType (const SymmetryCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual SymmetryCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SymmetryCharacteristicNominalType&
      operator= (const SymmetryCharacteristicNominalType&) = default;
#endif

      virtual 
      ~SymmetryCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL SymmetryCharacteristicMeasurementType: public ::xsd::qif30::LocationCharacteristicMeasurementBaseType
    {
      public:
      // SecondCompositeSegmentSymmetryMeasurement
      //
      typedef ::xsd::qif30::CompositeSegmentSymmetryMeasurementType SecondCompositeSegmentSymmetryMeasurement_type;
      typedef ::xsd::cxx::tree::optional< SecondCompositeSegmentSymmetryMeasurement_type > SecondCompositeSegmentSymmetryMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentSymmetryMeasurement_type, wchar_t > SecondCompositeSegmentSymmetryMeasurement_traits;

      const SecondCompositeSegmentSymmetryMeasurement_optional&
      SecondCompositeSegmentSymmetryMeasurement () const;

      SecondCompositeSegmentSymmetryMeasurement_optional&
      SecondCompositeSegmentSymmetryMeasurement ();

      void
      SecondCompositeSegmentSymmetryMeasurement (const SecondCompositeSegmentSymmetryMeasurement_type& x);

      void
      SecondCompositeSegmentSymmetryMeasurement (const SecondCompositeSegmentSymmetryMeasurement_optional& x);

      void
      SecondCompositeSegmentSymmetryMeasurement (::std::unique_ptr< SecondCompositeSegmentSymmetryMeasurement_type > p);

      // ThirdCompositeSegmentSymmetryMeasurement
      //
      typedef ::xsd::qif30::CompositeSegmentSymmetryMeasurementType ThirdCompositeSegmentSymmetryMeasurement_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentSymmetryMeasurement_type > ThirdCompositeSegmentSymmetryMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentSymmetryMeasurement_type, wchar_t > ThirdCompositeSegmentSymmetryMeasurement_traits;

      const ThirdCompositeSegmentSymmetryMeasurement_optional&
      ThirdCompositeSegmentSymmetryMeasurement () const;

      ThirdCompositeSegmentSymmetryMeasurement_optional&
      ThirdCompositeSegmentSymmetryMeasurement ();

      void
      ThirdCompositeSegmentSymmetryMeasurement (const ThirdCompositeSegmentSymmetryMeasurement_type& x);

      void
      ThirdCompositeSegmentSymmetryMeasurement (const ThirdCompositeSegmentSymmetryMeasurement_optional& x);

      void
      ThirdCompositeSegmentSymmetryMeasurement (::std::unique_ptr< ThirdCompositeSegmentSymmetryMeasurement_type > p);

      // Constructors.
      //
      SymmetryCharacteristicMeasurementType ();

      SymmetryCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      SymmetryCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      SymmetryCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      SymmetryCharacteristicMeasurementType (const SymmetryCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual SymmetryCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SymmetryCharacteristicMeasurementType&
      operator= (const SymmetryCharacteristicMeasurementType& x);

      virtual 
      ~SymmetryCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SecondCompositeSegmentSymmetryMeasurement_optional SecondCompositeSegmentSymmetryMeasurement_;
      ThirdCompositeSegmentSymmetryMeasurement_optional ThirdCompositeSegmentSymmetryMeasurement_;
    };

    class QIF30_SYMBOL_DECL ProfileCharacteristicItemBaseType: public ::xsd::qif30::GeometricCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ProfileCharacteristicItemBaseType ();

      ProfileCharacteristicItemBaseType (const id_type&,
                                         const CharacteristicNominalId_type&);

      ProfileCharacteristicItemBaseType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      ProfileCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ProfileCharacteristicItemBaseType (const ProfileCharacteristicItemBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ProfileCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      ProfileCharacteristicItemBaseType&
      operator= (const ProfileCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~ProfileCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL ProfileCharacteristicDefinitionBaseType: public ::xsd::qif30::GeometricCharacteristicDefinitionBaseType
    {
      public:
      // ToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValue_type, wchar_t > ToleranceValue_traits;

      const ToleranceValue_type&
      ToleranceValue () const;

      ToleranceValue_type&
      ToleranceValue ();

      void
      ToleranceValue (const ToleranceValue_type& x);

      void
      ToleranceValue (::std::unique_ptr< ToleranceValue_type > p);

      // ToleranceDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType ToleranceDualValue_type;
      typedef ::xsd::cxx::tree::optional< ToleranceDualValue_type > ToleranceDualValue_optional;
      typedef ::xsd::cxx::tree::traits< ToleranceDualValue_type, wchar_t > ToleranceDualValue_traits;

      const ToleranceDualValue_optional&
      ToleranceDualValue () const;

      ToleranceDualValue_optional&
      ToleranceDualValue ();

      void
      ToleranceDualValue (const ToleranceDualValue_type& x);

      void
      ToleranceDualValue (const ToleranceDualValue_optional& x);

      void
      ToleranceDualValue (::std::unique_ptr< ToleranceDualValue_type > p);

      // OuterDisposition
      //
      typedef ::xsd::qif30::LinearValueType OuterDisposition_type;
      typedef ::xsd::cxx::tree::optional< OuterDisposition_type > OuterDisposition_optional;
      typedef ::xsd::cxx::tree::traits< OuterDisposition_type, wchar_t > OuterDisposition_traits;

      const OuterDisposition_optional&
      OuterDisposition () const;

      OuterDisposition_optional&
      OuterDisposition ();

      void
      OuterDisposition (const OuterDisposition_type& x);

      void
      OuterDisposition (const OuterDisposition_optional& x);

      void
      OuterDisposition (::std::unique_ptr< OuterDisposition_type > p);

      // UnequallyDisposedZone
      //
      typedef ::xsd::qif30::LinearValueType UnequallyDisposedZone_type;
      typedef ::xsd::cxx::tree::optional< UnequallyDisposedZone_type > UnequallyDisposedZone_optional;
      typedef ::xsd::cxx::tree::traits< UnequallyDisposedZone_type, wchar_t > UnequallyDisposedZone_traits;

      const UnequallyDisposedZone_optional&
      UnequallyDisposedZone () const;

      UnequallyDisposedZone_optional&
      UnequallyDisposedZone ();

      void
      UnequallyDisposedZone (const UnequallyDisposedZone_type& x);

      void
      UnequallyDisposedZone (const UnequallyDisposedZone_optional& x);

      void
      UnequallyDisposedZone (::std::unique_ptr< UnequallyDisposedZone_type > p);

      // OffsetZone
      //
      typedef ::xml_schema::boolean OffsetZone_type;
      typedef ::xsd::cxx::tree::optional< OffsetZone_type > OffsetZone_optional;
      typedef ::xsd::cxx::tree::traits< OffsetZone_type, wchar_t > OffsetZone_traits;

      const OffsetZone_optional&
      OffsetZone () const;

      OffsetZone_optional&
      OffsetZone ();

      void
      OffsetZone (const OffsetZone_type& x);

      void
      OffsetZone (const OffsetZone_optional& x);

      // VariableAngle
      //
      typedef ::xml_schema::boolean VariableAngle_type;
      typedef ::xsd::cxx::tree::optional< VariableAngle_type > VariableAngle_optional;
      typedef ::xsd::cxx::tree::traits< VariableAngle_type, wchar_t > VariableAngle_traits;

      const VariableAngle_optional&
      VariableAngle () const;

      VariableAngle_optional&
      VariableAngle ();

      void
      VariableAngle (const VariableAngle_type& x);

      void
      VariableAngle (const VariableAngle_optional& x);

      // SecondCompositeSegmentProfileDefinition
      //
      typedef ::xsd::qif30::CompositeSegmentProfileDefinitionType SecondCompositeSegmentProfileDefinition_type;
      typedef ::xsd::cxx::tree::optional< SecondCompositeSegmentProfileDefinition_type > SecondCompositeSegmentProfileDefinition_optional;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentProfileDefinition_type, wchar_t > SecondCompositeSegmentProfileDefinition_traits;

      const SecondCompositeSegmentProfileDefinition_optional&
      SecondCompositeSegmentProfileDefinition () const;

      SecondCompositeSegmentProfileDefinition_optional&
      SecondCompositeSegmentProfileDefinition ();

      void
      SecondCompositeSegmentProfileDefinition (const SecondCompositeSegmentProfileDefinition_type& x);

      void
      SecondCompositeSegmentProfileDefinition (const SecondCompositeSegmentProfileDefinition_optional& x);

      void
      SecondCompositeSegmentProfileDefinition (::std::unique_ptr< SecondCompositeSegmentProfileDefinition_type > p);

      // ThirdCompositeSegmentProfileDefinition
      //
      typedef ::xsd::qif30::CompositeSegmentProfileDefinitionType ThirdCompositeSegmentProfileDefinition_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentProfileDefinition_type > ThirdCompositeSegmentProfileDefinition_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentProfileDefinition_type, wchar_t > ThirdCompositeSegmentProfileDefinition_traits;

      const ThirdCompositeSegmentProfileDefinition_optional&
      ThirdCompositeSegmentProfileDefinition () const;

      ThirdCompositeSegmentProfileDefinition_optional&
      ThirdCompositeSegmentProfileDefinition ();

      void
      ThirdCompositeSegmentProfileDefinition (const ThirdCompositeSegmentProfileDefinition_type& x);

      void
      ThirdCompositeSegmentProfileDefinition (const ThirdCompositeSegmentProfileDefinition_optional& x);

      void
      ThirdCompositeSegmentProfileDefinition (::std::unique_ptr< ThirdCompositeSegmentProfileDefinition_type > p);

      // FourthCompositeSegmentProfileDefinition
      //
      typedef ::xsd::qif30::CompositeSegmentProfileDefinitionType FourthCompositeSegmentProfileDefinition_type;
      typedef ::xsd::cxx::tree::optional< FourthCompositeSegmentProfileDefinition_type > FourthCompositeSegmentProfileDefinition_optional;
      typedef ::xsd::cxx::tree::traits< FourthCompositeSegmentProfileDefinition_type, wchar_t > FourthCompositeSegmentProfileDefinition_traits;

      const FourthCompositeSegmentProfileDefinition_optional&
      FourthCompositeSegmentProfileDefinition () const;

      FourthCompositeSegmentProfileDefinition_optional&
      FourthCompositeSegmentProfileDefinition ();

      void
      FourthCompositeSegmentProfileDefinition (const FourthCompositeSegmentProfileDefinition_type& x);

      void
      FourthCompositeSegmentProfileDefinition (const FourthCompositeSegmentProfileDefinition_optional& x);

      void
      FourthCompositeSegmentProfileDefinition (::std::unique_ptr< FourthCompositeSegmentProfileDefinition_type > p);

      // DatumReferenceFrameId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumReferenceFrameId_type;
      typedef ::xsd::cxx::tree::optional< DatumReferenceFrameId_type > DatumReferenceFrameId_optional;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameId_type, wchar_t > DatumReferenceFrameId_traits;

      const DatumReferenceFrameId_optional&
      DatumReferenceFrameId () const;

      DatumReferenceFrameId_optional&
      DatumReferenceFrameId ();

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_type& x);

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_optional& x);

      void
      DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > p);

      // OrientationOnly
      //
      typedef ::xml_schema::boolean OrientationOnly_type;
      typedef ::xsd::cxx::tree::optional< OrientationOnly_type > OrientationOnly_optional;
      typedef ::xsd::cxx::tree::traits< OrientationOnly_type, wchar_t > OrientationOnly_traits;

      const OrientationOnly_optional&
      OrientationOnly () const;

      OrientationOnly_optional&
      OrientationOnly ();

      void
      OrientationOnly (const OrientationOnly_type& x);

      void
      OrientationOnly (const OrientationOnly_optional& x);

      // Constructors.
      //
      ProfileCharacteristicDefinitionBaseType ();

      ProfileCharacteristicDefinitionBaseType (const id_type&,
                                               const ToleranceValue_type&);

      ProfileCharacteristicDefinitionBaseType (const id_type&,
                                               ::std::unique_ptr< ToleranceValue_type >);

      ProfileCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      ProfileCharacteristicDefinitionBaseType (const ProfileCharacteristicDefinitionBaseType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual ProfileCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ProfileCharacteristicDefinitionBaseType&
      operator= (const ProfileCharacteristicDefinitionBaseType& x);

      virtual 
      ~ProfileCharacteristicDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValue_type > ToleranceValue_;
      ToleranceDualValue_optional ToleranceDualValue_;
      OuterDisposition_optional OuterDisposition_;
      UnequallyDisposedZone_optional UnequallyDisposedZone_;
      OffsetZone_optional OffsetZone_;
      VariableAngle_optional VariableAngle_;
      SecondCompositeSegmentProfileDefinition_optional SecondCompositeSegmentProfileDefinition_;
      ThirdCompositeSegmentProfileDefinition_optional ThirdCompositeSegmentProfileDefinition_;
      FourthCompositeSegmentProfileDefinition_optional FourthCompositeSegmentProfileDefinition_;
      DatumReferenceFrameId_optional DatumReferenceFrameId_;
      OrientationOnly_optional OrientationOnly_;
    };

    class QIF30_SYMBOL_DECL ProfileCharacteristicNominalBaseType: public ::xsd::qif30::GeometricCharacteristicNominalBaseType
    {
      public:
      // TargetValue
      //
      typedef ::xsd::qif30::LinearValueType TargetValue_type;
      typedef ::xsd::cxx::tree::optional< TargetValue_type > TargetValue_optional;
      typedef ::xsd::cxx::tree::traits< TargetValue_type, wchar_t > TargetValue_traits;

      const TargetValue_optional&
      TargetValue () const;

      TargetValue_optional&
      TargetValue ();

      void
      TargetValue (const TargetValue_type& x);

      void
      TargetValue (const TargetValue_optional& x);

      void
      TargetValue (::std::unique_ptr< TargetValue_type > p);

      // Constructors.
      //
      ProfileCharacteristicNominalBaseType ();

      ProfileCharacteristicNominalBaseType (const id_type&,
                                            const CharacteristicDefinitionId_type&);

      ProfileCharacteristicNominalBaseType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ProfileCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ProfileCharacteristicNominalBaseType (const ProfileCharacteristicNominalBaseType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ProfileCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ProfileCharacteristicNominalBaseType&
      operator= (const ProfileCharacteristicNominalBaseType& x);

      virtual 
      ~ProfileCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TargetValue_optional TargetValue_;
    };

    class QIF30_SYMBOL_DECL ProfileCharacteristicMeasurementBaseType: public ::xsd::qif30::GeometricCharacteristicMeasurementBaseType
    {
      public:
      // WorstPositiveDeviation
      //
      typedef ::xsd::qif30::LinearValueType WorstPositiveDeviation_type;
      typedef ::xsd::cxx::tree::optional< WorstPositiveDeviation_type > WorstPositiveDeviation_optional;
      typedef ::xsd::cxx::tree::traits< WorstPositiveDeviation_type, wchar_t > WorstPositiveDeviation_traits;

      const WorstPositiveDeviation_optional&
      WorstPositiveDeviation () const;

      WorstPositiveDeviation_optional&
      WorstPositiveDeviation ();

      void
      WorstPositiveDeviation (const WorstPositiveDeviation_type& x);

      void
      WorstPositiveDeviation (const WorstPositiveDeviation_optional& x);

      void
      WorstPositiveDeviation (::std::unique_ptr< WorstPositiveDeviation_type > p);

      // WorstNegativeDeviation
      //
      typedef ::xsd::qif30::LinearValueType WorstNegativeDeviation_type;
      typedef ::xsd::cxx::tree::optional< WorstNegativeDeviation_type > WorstNegativeDeviation_optional;
      typedef ::xsd::cxx::tree::traits< WorstNegativeDeviation_type, wchar_t > WorstNegativeDeviation_traits;

      const WorstNegativeDeviation_optional&
      WorstNegativeDeviation () const;

      WorstNegativeDeviation_optional&
      WorstNegativeDeviation ();

      void
      WorstNegativeDeviation (const WorstNegativeDeviation_type& x);

      void
      WorstNegativeDeviation (const WorstNegativeDeviation_optional& x);

      void
      WorstNegativeDeviation (::std::unique_ptr< WorstNegativeDeviation_type > p);

      // PointDeviations
      //
      typedef ::xsd::qif30::PointDeviationsType PointDeviations_type;
      typedef ::xsd::cxx::tree::optional< PointDeviations_type > PointDeviations_optional;
      typedef ::xsd::cxx::tree::traits< PointDeviations_type, wchar_t > PointDeviations_traits;

      const PointDeviations_optional&
      PointDeviations () const;

      PointDeviations_optional&
      PointDeviations ();

      void
      PointDeviations (const PointDeviations_type& x);

      void
      PointDeviations (const PointDeviations_optional& x);

      void
      PointDeviations (::std::unique_ptr< PointDeviations_type > p);

      // DatumsOk
      //
      typedef ::xml_schema::boolean DatumsOk_type;
      typedef ::xsd::cxx::tree::optional< DatumsOk_type > DatumsOk_optional;
      typedef ::xsd::cxx::tree::traits< DatumsOk_type, wchar_t > DatumsOk_traits;

      const DatumsOk_optional&
      DatumsOk () const;

      DatumsOk_optional&
      DatumsOk ();

      void
      DatumsOk (const DatumsOk_type& x);

      void
      DatumsOk (const DatumsOk_optional& x);

      // DRFTransformActualId
      //
      typedef ::xsd::qif30::QIFReferenceType DRFTransformActualId_type;
      typedef ::xsd::cxx::tree::optional< DRFTransformActualId_type > DRFTransformActualId_optional;
      typedef ::xsd::cxx::tree::traits< DRFTransformActualId_type, wchar_t > DRFTransformActualId_traits;

      const DRFTransformActualId_optional&
      DRFTransformActualId () const;

      DRFTransformActualId_optional&
      DRFTransformActualId ();

      void
      DRFTransformActualId (const DRFTransformActualId_type& x);

      void
      DRFTransformActualId (const DRFTransformActualId_optional& x);

      void
      DRFTransformActualId (::std::unique_ptr< DRFTransformActualId_type > p);

      // SecondCompositeSegmentProfileMeasurement
      //
      typedef ::xsd::qif30::CompositeSegmentProfileMeasurementType SecondCompositeSegmentProfileMeasurement_type;
      typedef ::xsd::cxx::tree::optional< SecondCompositeSegmentProfileMeasurement_type > SecondCompositeSegmentProfileMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentProfileMeasurement_type, wchar_t > SecondCompositeSegmentProfileMeasurement_traits;

      const SecondCompositeSegmentProfileMeasurement_optional&
      SecondCompositeSegmentProfileMeasurement () const;

      SecondCompositeSegmentProfileMeasurement_optional&
      SecondCompositeSegmentProfileMeasurement ();

      void
      SecondCompositeSegmentProfileMeasurement (const SecondCompositeSegmentProfileMeasurement_type& x);

      void
      SecondCompositeSegmentProfileMeasurement (const SecondCompositeSegmentProfileMeasurement_optional& x);

      void
      SecondCompositeSegmentProfileMeasurement (::std::unique_ptr< SecondCompositeSegmentProfileMeasurement_type > p);

      // ThirdCompositeSegmentProfileMeasurement
      //
      typedef ::xsd::qif30::CompositeSegmentProfileMeasurementType ThirdCompositeSegmentProfileMeasurement_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentProfileMeasurement_type > ThirdCompositeSegmentProfileMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentProfileMeasurement_type, wchar_t > ThirdCompositeSegmentProfileMeasurement_traits;

      const ThirdCompositeSegmentProfileMeasurement_optional&
      ThirdCompositeSegmentProfileMeasurement () const;

      ThirdCompositeSegmentProfileMeasurement_optional&
      ThirdCompositeSegmentProfileMeasurement ();

      void
      ThirdCompositeSegmentProfileMeasurement (const ThirdCompositeSegmentProfileMeasurement_type& x);

      void
      ThirdCompositeSegmentProfileMeasurement (const ThirdCompositeSegmentProfileMeasurement_optional& x);

      void
      ThirdCompositeSegmentProfileMeasurement (::std::unique_ptr< ThirdCompositeSegmentProfileMeasurement_type > p);

      // FourthCompositeSegmentProfileMeasurement
      //
      typedef ::xsd::qif30::CompositeSegmentProfileMeasurementType FourthCompositeSegmentProfileMeasurement_type;
      typedef ::xsd::cxx::tree::optional< FourthCompositeSegmentProfileMeasurement_type > FourthCompositeSegmentProfileMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< FourthCompositeSegmentProfileMeasurement_type, wchar_t > FourthCompositeSegmentProfileMeasurement_traits;

      const FourthCompositeSegmentProfileMeasurement_optional&
      FourthCompositeSegmentProfileMeasurement () const;

      FourthCompositeSegmentProfileMeasurement_optional&
      FourthCompositeSegmentProfileMeasurement ();

      void
      FourthCompositeSegmentProfileMeasurement (const FourthCompositeSegmentProfileMeasurement_type& x);

      void
      FourthCompositeSegmentProfileMeasurement (const FourthCompositeSegmentProfileMeasurement_optional& x);

      void
      FourthCompositeSegmentProfileMeasurement (::std::unique_ptr< FourthCompositeSegmentProfileMeasurement_type > p);

      // Constructors.
      //
      ProfileCharacteristicMeasurementBaseType ();

      ProfileCharacteristicMeasurementBaseType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      ProfileCharacteristicMeasurementBaseType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      ProfileCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ProfileCharacteristicMeasurementBaseType (const ProfileCharacteristicMeasurementBaseType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ProfileCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ProfileCharacteristicMeasurementBaseType&
      operator= (const ProfileCharacteristicMeasurementBaseType& x);

      virtual 
      ~ProfileCharacteristicMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      WorstPositiveDeviation_optional WorstPositiveDeviation_;
      WorstNegativeDeviation_optional WorstNegativeDeviation_;
      PointDeviations_optional PointDeviations_;
      DatumsOk_optional DatumsOk_;
      DRFTransformActualId_optional DRFTransformActualId_;
      SecondCompositeSegmentProfileMeasurement_optional SecondCompositeSegmentProfileMeasurement_;
      ThirdCompositeSegmentProfileMeasurement_optional ThirdCompositeSegmentProfileMeasurement_;
      FourthCompositeSegmentProfileMeasurement_optional FourthCompositeSegmentProfileMeasurement_;
    };

    class QIF30_SYMBOL_DECL LineProfileCharacteristicItemType: public ::xsd::qif30::ProfileCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      LineProfileCharacteristicItemType ();

      LineProfileCharacteristicItemType (const id_type&,
                                         const CharacteristicNominalId_type&);

      LineProfileCharacteristicItemType (const id_type&,
                                         ::std::unique_ptr< CharacteristicNominalId_type >);

      LineProfileCharacteristicItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LineProfileCharacteristicItemType (const LineProfileCharacteristicItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual LineProfileCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LineProfileCharacteristicItemType&
      operator= (const LineProfileCharacteristicItemType&) = default;
#endif

      virtual 
      ~LineProfileCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL LineProfileCharacteristicDefinitionType: public ::xsd::qif30::ProfileCharacteristicDefinitionBaseType
    {
      public:
      // Extent
      //
      typedef ::xsd::qif30::ExtentType Extent_type;
      typedef ::xsd::cxx::tree::optional< Extent_type > Extent_optional;
      typedef ::xsd::cxx::tree::traits< Extent_type, wchar_t > Extent_traits;

      const Extent_optional&
      Extent () const;

      Extent_optional&
      Extent ();

      void
      Extent (const Extent_type& x);

      void
      Extent (const Extent_optional& x);

      void
      Extent (::std::unique_ptr< Extent_type > p);

      // Constructors.
      //
      LineProfileCharacteristicDefinitionType ();

      LineProfileCharacteristicDefinitionType (const id_type&,
                                               const ToleranceValue_type&);

      LineProfileCharacteristicDefinitionType (const id_type&,
                                               ::std::unique_ptr< ToleranceValue_type >);

      LineProfileCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      LineProfileCharacteristicDefinitionType (const LineProfileCharacteristicDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual LineProfileCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineProfileCharacteristicDefinitionType&
      operator= (const LineProfileCharacteristicDefinitionType& x);

      virtual 
      ~LineProfileCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Extent_optional Extent_;
    };

    class QIF30_SYMBOL_DECL LineProfileCharacteristicNominalType: public ::xsd::qif30::ProfileCharacteristicNominalBaseType
    {
      public:
      // Vector
      //
      typedef ::xsd::qif30::UnitVectorType Vector_type;
      typedef ::xsd::cxx::tree::traits< Vector_type, wchar_t > Vector_traits;

      const Vector_type&
      Vector () const;

      Vector_type&
      Vector ();

      void
      Vector (const Vector_type& x);

      void
      Vector (::std::unique_ptr< Vector_type > p);

      // ProfileCurveId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ProfileCurveId_type;
      typedef ::xsd::cxx::tree::optional< ProfileCurveId_type > ProfileCurveId_optional;
      typedef ::xsd::cxx::tree::traits< ProfileCurveId_type, wchar_t > ProfileCurveId_traits;

      const ProfileCurveId_optional&
      ProfileCurveId () const;

      ProfileCurveId_optional&
      ProfileCurveId ();

      void
      ProfileCurveId (const ProfileCurveId_type& x);

      void
      ProfileCurveId (const ProfileCurveId_optional& x);

      void
      ProfileCurveId (::std::unique_ptr< ProfileCurveId_type > p);

      // Constructors.
      //
      LineProfileCharacteristicNominalType ();

      LineProfileCharacteristicNominalType (const id_type&,
                                            const CharacteristicDefinitionId_type&,
                                            const Vector_type&);

      LineProfileCharacteristicNominalType (const id_type&,
                                            ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                            ::std::unique_ptr< Vector_type >);

      LineProfileCharacteristicNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      LineProfileCharacteristicNominalType (const LineProfileCharacteristicNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual LineProfileCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineProfileCharacteristicNominalType&
      operator= (const LineProfileCharacteristicNominalType& x);

      virtual 
      ~LineProfileCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Vector_type > Vector_;
      ProfileCurveId_optional ProfileCurveId_;
    };

    class QIF30_SYMBOL_DECL LineProfileCharacteristicMeasurementType: public ::xsd::qif30::ProfileCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      LineProfileCharacteristicMeasurementType ();

      LineProfileCharacteristicMeasurementType (const id_type&,
                                                const Status_type&,
                                                const CharacteristicItemId_type&);

      LineProfileCharacteristicMeasurementType (const id_type&,
                                                ::std::unique_ptr< Status_type >,
                                                ::std::unique_ptr< CharacteristicItemId_type >);

      LineProfileCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      LineProfileCharacteristicMeasurementType (const LineProfileCharacteristicMeasurementType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual LineProfileCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LineProfileCharacteristicMeasurementType&
      operator= (const LineProfileCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~LineProfileCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL PointProfileCharacteristicItemType: public ::xsd::qif30::ProfileCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      PointProfileCharacteristicItemType ();

      PointProfileCharacteristicItemType (const id_type&,
                                          const CharacteristicNominalId_type&);

      PointProfileCharacteristicItemType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >);

      PointProfileCharacteristicItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PointProfileCharacteristicItemType (const PointProfileCharacteristicItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual PointProfileCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointProfileCharacteristicItemType&
      operator= (const PointProfileCharacteristicItemType&) = default;
#endif

      virtual 
      ~PointProfileCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL PointProfileCharacteristicDefinitionType: public ::xsd::qif30::ProfileCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      PointProfileCharacteristicDefinitionType ();

      PointProfileCharacteristicDefinitionType (const id_type&,
                                                const ToleranceValue_type&);

      PointProfileCharacteristicDefinitionType (const id_type&,
                                                ::std::unique_ptr< ToleranceValue_type >);

      PointProfileCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      PointProfileCharacteristicDefinitionType (const PointProfileCharacteristicDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual PointProfileCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointProfileCharacteristicDefinitionType&
      operator= (const PointProfileCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~PointProfileCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL PointProfileCharacteristicNominalType: public ::xsd::qif30::ProfileCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      PointProfileCharacteristicNominalType ();

      PointProfileCharacteristicNominalType (const id_type&,
                                             const CharacteristicDefinitionId_type&);

      PointProfileCharacteristicNominalType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >);

      PointProfileCharacteristicNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      PointProfileCharacteristicNominalType (const PointProfileCharacteristicNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual PointProfileCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointProfileCharacteristicNominalType&
      operator= (const PointProfileCharacteristicNominalType&) = default;
#endif

      virtual 
      ~PointProfileCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL PointProfileCharacteristicMeasurementType: public ::xsd::qif30::ProfileCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      PointProfileCharacteristicMeasurementType ();

      PointProfileCharacteristicMeasurementType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&);

      PointProfileCharacteristicMeasurementType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >);

      PointProfileCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PointProfileCharacteristicMeasurementType (const PointProfileCharacteristicMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual PointProfileCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointProfileCharacteristicMeasurementType&
      operator= (const PointProfileCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~PointProfileCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL SurfaceProfileCharacteristicItemType: public ::xsd::qif30::ProfileCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SurfaceProfileCharacteristicItemType ();

      SurfaceProfileCharacteristicItemType (const id_type&,
                                            const CharacteristicNominalId_type&);

      SurfaceProfileCharacteristicItemType (const id_type&,
                                            ::std::unique_ptr< CharacteristicNominalId_type >);

      SurfaceProfileCharacteristicItemType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      SurfaceProfileCharacteristicItemType (const SurfaceProfileCharacteristicItemType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual SurfaceProfileCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceProfileCharacteristicItemType&
      operator= (const SurfaceProfileCharacteristicItemType&) = default;
#endif

      virtual 
      ~SurfaceProfileCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL SurfaceProfileCharacteristicDefinitionType: public ::xsd::qif30::ProfileCharacteristicDefinitionBaseType
    {
      public:
      // Extent
      //
      typedef ::xsd::qif30::ExtentType Extent_type;
      typedef ::xsd::cxx::tree::optional< Extent_type > Extent_optional;
      typedef ::xsd::cxx::tree::traits< Extent_type, wchar_t > Extent_traits;

      const Extent_optional&
      Extent () const;

      Extent_optional&
      Extent ();

      void
      Extent (const Extent_type& x);

      void
      Extent (const Extent_optional& x);

      void
      Extent (::std::unique_ptr< Extent_type > p);

      // Constructors.
      //
      SurfaceProfileCharacteristicDefinitionType ();

      SurfaceProfileCharacteristicDefinitionType (const id_type&,
                                                  const ToleranceValue_type&);

      SurfaceProfileCharacteristicDefinitionType (const id_type&,
                                                  ::std::unique_ptr< ToleranceValue_type >);

      SurfaceProfileCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      SurfaceProfileCharacteristicDefinitionType (const SurfaceProfileCharacteristicDefinitionType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual SurfaceProfileCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceProfileCharacteristicDefinitionType&
      operator= (const SurfaceProfileCharacteristicDefinitionType& x);

      virtual 
      ~SurfaceProfileCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Extent_optional Extent_;
    };

    class QIF30_SYMBOL_DECL SurfaceProfileCharacteristicNominalType: public ::xsd::qif30::ProfileCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      SurfaceProfileCharacteristicNominalType ();

      SurfaceProfileCharacteristicNominalType (const id_type&,
                                               const CharacteristicDefinitionId_type&);

      SurfaceProfileCharacteristicNominalType (const id_type&,
                                               ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SurfaceProfileCharacteristicNominalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      SurfaceProfileCharacteristicNominalType (const SurfaceProfileCharacteristicNominalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual SurfaceProfileCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceProfileCharacteristicNominalType&
      operator= (const SurfaceProfileCharacteristicNominalType&) = default;
#endif

      virtual 
      ~SurfaceProfileCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL SurfaceProfileCharacteristicMeasurementType: public ::xsd::qif30::ProfileCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      SurfaceProfileCharacteristicMeasurementType ();

      SurfaceProfileCharacteristicMeasurementType (const id_type&,
                                                   const Status_type&,
                                                   const CharacteristicItemId_type&);

      SurfaceProfileCharacteristicMeasurementType (const id_type&,
                                                   ::std::unique_ptr< Status_type >,
                                                   ::std::unique_ptr< CharacteristicItemId_type >);

      SurfaceProfileCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      SurfaceProfileCharacteristicMeasurementType (const SurfaceProfileCharacteristicMeasurementType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual SurfaceProfileCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceProfileCharacteristicMeasurementType&
      operator= (const SurfaceProfileCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~SurfaceProfileCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL SurfaceProfileNonUniformCharacteristicItemType: public ::xsd::qif30::ProfileCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      SurfaceProfileNonUniformCharacteristicItemType ();

      SurfaceProfileNonUniformCharacteristicItemType (const id_type&,
                                                      const CharacteristicNominalId_type&);

      SurfaceProfileNonUniformCharacteristicItemType (const id_type&,
                                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      SurfaceProfileNonUniformCharacteristicItemType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      SurfaceProfileNonUniformCharacteristicItemType (const SurfaceProfileNonUniformCharacteristicItemType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual SurfaceProfileNonUniformCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceProfileNonUniformCharacteristicItemType&
      operator= (const SurfaceProfileNonUniformCharacteristicItemType&) = default;
#endif

      virtual 
      ~SurfaceProfileNonUniformCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL SurfaceProfileNonUniformCharacteristicDefinitionType: public ::xsd::qif30::ProfileCharacteristicDefinitionBaseType
    {
      public:
      // ToPointToleranceValue
      //
      typedef ::xsd::qif30::LinearValueType ToPointToleranceValue_type;
      typedef ::xsd::cxx::tree::traits< ToPointToleranceValue_type, wchar_t > ToPointToleranceValue_traits;

      const ToPointToleranceValue_type&
      ToPointToleranceValue () const;

      ToPointToleranceValue_type&
      ToPointToleranceValue ();

      void
      ToPointToleranceValue (const ToPointToleranceValue_type& x);

      void
      ToPointToleranceValue (::std::unique_ptr< ToPointToleranceValue_type > p);

      // ToPointOuterDisposition
      //
      typedef ::xsd::qif30::LinearValueType ToPointOuterDisposition_type;
      typedef ::xsd::cxx::tree::optional< ToPointOuterDisposition_type > ToPointOuterDisposition_optional;
      typedef ::xsd::cxx::tree::traits< ToPointOuterDisposition_type, wchar_t > ToPointOuterDisposition_traits;

      const ToPointOuterDisposition_optional&
      ToPointOuterDisposition () const;

      ToPointOuterDisposition_optional&
      ToPointOuterDisposition ();

      void
      ToPointOuterDisposition (const ToPointOuterDisposition_type& x);

      void
      ToPointOuterDisposition (const ToPointOuterDisposition_optional& x);

      void
      ToPointOuterDisposition (::std::unique_ptr< ToPointOuterDisposition_type > p);

      // ToPointUnequallyDisposedZone
      //
      typedef ::xsd::qif30::LinearValueType ToPointUnequallyDisposedZone_type;
      typedef ::xsd::cxx::tree::optional< ToPointUnequallyDisposedZone_type > ToPointUnequallyDisposedZone_optional;
      typedef ::xsd::cxx::tree::traits< ToPointUnequallyDisposedZone_type, wchar_t > ToPointUnequallyDisposedZone_traits;

      const ToPointUnequallyDisposedZone_optional&
      ToPointUnequallyDisposedZone () const;

      ToPointUnequallyDisposedZone_optional&
      ToPointUnequallyDisposedZone ();

      void
      ToPointUnequallyDisposedZone (const ToPointUnequallyDisposedZone_type& x);

      void
      ToPointUnequallyDisposedZone (const ToPointUnequallyDisposedZone_optional& x);

      void
      ToPointUnequallyDisposedZone (::std::unique_ptr< ToPointUnequallyDisposedZone_type > p);

      // Constructors.
      //
      SurfaceProfileNonUniformCharacteristicDefinitionType ();

      SurfaceProfileNonUniformCharacteristicDefinitionType (const id_type&,
                                                            const ToleranceValue_type&,
                                                            const ToPointToleranceValue_type&);

      SurfaceProfileNonUniformCharacteristicDefinitionType (const id_type&,
                                                            ::std::unique_ptr< ToleranceValue_type >,
                                                            ::std::unique_ptr< ToPointToleranceValue_type >);

      SurfaceProfileNonUniformCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

      SurfaceProfileNonUniformCharacteristicDefinitionType (const SurfaceProfileNonUniformCharacteristicDefinitionType& x,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

      virtual SurfaceProfileNonUniformCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceProfileNonUniformCharacteristicDefinitionType&
      operator= (const SurfaceProfileNonUniformCharacteristicDefinitionType& x);

      virtual 
      ~SurfaceProfileNonUniformCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToPointToleranceValue_type > ToPointToleranceValue_;
      ToPointOuterDisposition_optional ToPointOuterDisposition_;
      ToPointUnequallyDisposedZone_optional ToPointUnequallyDisposedZone_;
    };

    class QIF30_SYMBOL_DECL SurfaceProfileNonUniformCharacteristicNominalType: public ::xsd::qif30::ProfileCharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      SurfaceProfileNonUniformCharacteristicNominalType ();

      SurfaceProfileNonUniformCharacteristicNominalType (const id_type&,
                                                         const CharacteristicDefinitionId_type&);

      SurfaceProfileNonUniformCharacteristicNominalType (const id_type&,
                                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      SurfaceProfileNonUniformCharacteristicNominalType (const xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      SurfaceProfileNonUniformCharacteristicNominalType (const SurfaceProfileNonUniformCharacteristicNominalType& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      virtual SurfaceProfileNonUniformCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceProfileNonUniformCharacteristicNominalType&
      operator= (const SurfaceProfileNonUniformCharacteristicNominalType&) = default;
#endif

      virtual 
      ~SurfaceProfileNonUniformCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL SurfaceProfileNonUniformCharacteristicMeasurementType: public ::xsd::qif30::ProfileCharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      SurfaceProfileNonUniformCharacteristicMeasurementType ();

      SurfaceProfileNonUniformCharacteristicMeasurementType (const id_type&,
                                                             const Status_type&,
                                                             const CharacteristicItemId_type&);

      SurfaceProfileNonUniformCharacteristicMeasurementType (const id_type&,
                                                             ::std::unique_ptr< Status_type >,
                                                             ::std::unique_ptr< CharacteristicItemId_type >);

      SurfaceProfileNonUniformCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                             ::xml_schema::flags f = 0,
                                                             ::xml_schema::container* c = 0);

      SurfaceProfileNonUniformCharacteristicMeasurementType (const SurfaceProfileNonUniformCharacteristicMeasurementType& x,
                                                             ::xml_schema::flags f = 0,
                                                             ::xml_schema::container* c = 0);

      virtual SurfaceProfileNonUniformCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceProfileNonUniformCharacteristicMeasurementType&
      operator= (const SurfaceProfileNonUniformCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~SurfaceProfileNonUniformCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL MeasuredZoneRadiiType: public ::xml_schema::type
    {
      public:
      // MinRadius
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinRadius_type;
      typedef ::xsd::cxx::tree::traits< MinRadius_type, wchar_t > MinRadius_traits;

      const MinRadius_type&
      MinRadius () const;

      MinRadius_type&
      MinRadius ();

      void
      MinRadius (const MinRadius_type& x);

      void
      MinRadius (::std::unique_ptr< MinRadius_type > p);

      // MaxRadius
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MaxRadius_type;
      typedef ::xsd::cxx::tree::traits< MaxRadius_type, wchar_t > MaxRadius_traits;

      const MaxRadius_type&
      MaxRadius () const;

      MaxRadius_type&
      MaxRadius ();

      void
      MaxRadius (const MaxRadius_type& x);

      void
      MaxRadius (::std::unique_ptr< MaxRadius_type > p);

      // Constructors.
      //
      MeasuredZoneRadiiType ();

      MeasuredZoneRadiiType (const MinRadius_type&,
                             const MaxRadius_type&);

      MeasuredZoneRadiiType (::std::unique_ptr< MinRadius_type >,
                             ::std::unique_ptr< MaxRadius_type >);

      MeasuredZoneRadiiType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MeasuredZoneRadiiType (const MeasuredZoneRadiiType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MeasuredZoneRadiiType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredZoneRadiiType&
      operator= (const MeasuredZoneRadiiType& x);

      virtual 
      ~MeasuredZoneRadiiType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MinRadius_type > MinRadius_;
      ::xsd::cxx::tree::one< MaxRadius_type > MaxRadius_;
    };

    class QIF30_SYMBOL_DECL CharacteristicGroupType: public ::xml_schema::type
    {
      public:
      // CharacteristicItemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CharacteristicItemIds_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicItemIds_type, wchar_t > CharacteristicItemIds_traits;

      const CharacteristicItemIds_type&
      CharacteristicItemIds () const;

      CharacteristicItemIds_type&
      CharacteristicItemIds ();

      void
      CharacteristicItemIds (const CharacteristicItemIds_type& x);

      void
      CharacteristicItemIds (::std::unique_ptr< CharacteristicItemIds_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // TransformId
      //
      typedef ::xsd::qif30::QIFReferenceType TransformId_type;
      typedef ::xsd::cxx::tree::optional< TransformId_type > TransformId_optional;
      typedef ::xsd::cxx::tree::traits< TransformId_type, wchar_t > TransformId_traits;

      const TransformId_optional&
      TransformId () const;

      TransformId_optional&
      TransformId ();

      void
      TransformId (const TransformId_type& x);

      void
      TransformId (const TransformId_optional& x);

      void
      TransformId (::std::unique_ptr< TransformId_type > p);

      // Units
      //
      typedef ::xsd::qif30::OtherUnitsType Units_type;
      typedef ::xsd::cxx::tree::optional< Units_type > Units_optional;
      typedef ::xsd::cxx::tree::traits< Units_type, wchar_t > Units_traits;

      const Units_optional&
      Units () const;

      Units_optional&
      Units ();

      void
      Units (const Units_type& x);

      void
      Units (const Units_optional& x);

      void
      Units (::std::unique_ptr< Units_type > p);

      // Scale
      //
      typedef ::xsd::qif30::ScaleType Scale_type;
      typedef ::xsd::cxx::tree::optional< Scale_type > Scale_optional;
      typedef ::xsd::cxx::tree::traits< Scale_type, wchar_t > Scale_traits;

      const Scale_optional&
      Scale () const;

      Scale_optional&
      Scale ();

      void
      Scale (const Scale_type& x);

      void
      Scale (const Scale_optional& x);

      void
      Scale (::std::unique_ptr< Scale_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      CharacteristicGroupType ();

      CharacteristicGroupType (const CharacteristicItemIds_type&,
                               const id_type&);

      CharacteristicGroupType (::std::unique_ptr< CharacteristicItemIds_type >,
                               const id_type&);

      CharacteristicGroupType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CharacteristicGroupType (const CharacteristicGroupType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CharacteristicGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicGroupType&
      operator= (const CharacteristicGroupType& x);

      virtual 
      ~CharacteristicGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CharacteristicItemIds_type > CharacteristicItemIds_;
      Description_optional Description_;
      Name_optional Name_;
      TransformId_optional TransformId_;
      Units_optional Units_;
      Scale_optional Scale_;
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL CharacteristicManufacturingProcessGroupType: public ::xsd::qif30::CharacteristicGroupType
    {
      public:
      // ManufacturingProcessId
      //
      typedef ::xsd::qif30::QIFReferenceType ManufacturingProcessId_type;
      typedef ::xsd::cxx::tree::optional< ManufacturingProcessId_type > ManufacturingProcessId_optional;
      typedef ::xsd::cxx::tree::traits< ManufacturingProcessId_type, wchar_t > ManufacturingProcessId_traits;

      const ManufacturingProcessId_optional&
      ManufacturingProcessId () const;

      ManufacturingProcessId_optional&
      ManufacturingProcessId ();

      void
      ManufacturingProcessId (const ManufacturingProcessId_type& x);

      void
      ManufacturingProcessId (const ManufacturingProcessId_optional& x);

      void
      ManufacturingProcessId (::std::unique_ptr< ManufacturingProcessId_type > p);

      // Constructors.
      //
      CharacteristicManufacturingProcessGroupType ();

      CharacteristicManufacturingProcessGroupType (const CharacteristicItemIds_type&,
                                                   const id_type&);

      CharacteristicManufacturingProcessGroupType (::std::unique_ptr< CharacteristicItemIds_type >,
                                                   const id_type&);

      CharacteristicManufacturingProcessGroupType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      CharacteristicManufacturingProcessGroupType (const CharacteristicManufacturingProcessGroupType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual CharacteristicManufacturingProcessGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicManufacturingProcessGroupType&
      operator= (const CharacteristicManufacturingProcessGroupType& x);

      virtual 
      ~CharacteristicManufacturingProcessGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ManufacturingProcessId_optional ManufacturingProcessId_;
    };

    class QIF30_SYMBOL_DECL SimultaneousRequirementEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        SEP_REQ,
        SIM_REQ
      };

      SimultaneousRequirementEnumType ();

      SimultaneousRequirementEnumType (value v);

      SimultaneousRequirementEnumType (const wchar_t* v);

      SimultaneousRequirementEnumType (const ::std::wstring& v);

      SimultaneousRequirementEnumType (const ::xml_schema::nmtoken& v);

      SimultaneousRequirementEnumType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SimultaneousRequirementEnumType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SimultaneousRequirementEnumType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SimultaneousRequirementEnumType (const SimultaneousRequirementEnumType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SimultaneousRequirementEnumType&
      operator= (const SimultaneousRequirementEnumType&) = default;
#endif

      virtual SimultaneousRequirementEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimultaneousRequirementEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SimultaneousRequirementEnumType_convert ();
      }

      protected:
      value
      _xsd_SimultaneousRequirementEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_SimultaneousRequirementEnumType_literals_[2];
      static const value _xsd_SimultaneousRequirementEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL CompositeSegmentLowerLevelEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        SECOND,
        THIRD,
        FOURTH,
        FIFTH
      };

      CompositeSegmentLowerLevelEnumType ();

      CompositeSegmentLowerLevelEnumType (value v);

      CompositeSegmentLowerLevelEnumType (const wchar_t* v);

      CompositeSegmentLowerLevelEnumType (const ::std::wstring& v);

      CompositeSegmentLowerLevelEnumType (const ::xml_schema::nmtoken& v);

      CompositeSegmentLowerLevelEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CompositeSegmentLowerLevelEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CompositeSegmentLowerLevelEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CompositeSegmentLowerLevelEnumType (const CompositeSegmentLowerLevelEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CompositeSegmentLowerLevelEnumType&
      operator= (const CompositeSegmentLowerLevelEnumType&) = default;
#endif

      virtual CompositeSegmentLowerLevelEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompositeSegmentLowerLevelEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CompositeSegmentLowerLevelEnumType_convert ();
      }

      protected:
      value
      _xsd_CompositeSegmentLowerLevelEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CompositeSegmentLowerLevelEnumType_literals_[4];
      static const value _xsd_CompositeSegmentLowerLevelEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL SimultaneousRequirementGroupType: public ::xml_schema::type
    {
      public:
      // CharacteristicNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CharacteristicNominalIds_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicNominalIds_type, wchar_t > CharacteristicNominalIds_traits;

      const CharacteristicNominalIds_type&
      CharacteristicNominalIds () const;

      CharacteristicNominalIds_type&
      CharacteristicNominalIds ();

      void
      CharacteristicNominalIds (const CharacteristicNominalIds_type& x);

      void
      CharacteristicNominalIds (::std::unique_ptr< CharacteristicNominalIds_type > p);

      // Requirement
      //
      typedef ::xsd::qif30::SimultaneousRequirementEnumType Requirement_type;
      typedef ::xsd::cxx::tree::traits< Requirement_type, wchar_t > Requirement_traits;

      const Requirement_type&
      Requirement () const;

      Requirement_type&
      Requirement ();

      void
      Requirement (const Requirement_type& x);

      void
      Requirement (::std::unique_ptr< Requirement_type > p);

      // CompositeLevel
      //
      typedef ::xsd::qif30::CompositeSegmentLowerLevelEnumType CompositeLevel_type;
      typedef ::xsd::cxx::tree::optional< CompositeLevel_type > CompositeLevel_optional;
      typedef ::xsd::cxx::tree::traits< CompositeLevel_type, wchar_t > CompositeLevel_traits;

      const CompositeLevel_optional&
      CompositeLevel () const;

      CompositeLevel_optional&
      CompositeLevel ();

      void
      CompositeLevel (const CompositeLevel_type& x);

      void
      CompositeLevel (const CompositeLevel_optional& x);

      void
      CompositeLevel (::std::unique_ptr< CompositeLevel_type > p);

      // Constructors.
      //
      SimultaneousRequirementGroupType ();

      SimultaneousRequirementGroupType (const CharacteristicNominalIds_type&,
                                        const Requirement_type&);

      SimultaneousRequirementGroupType (::std::unique_ptr< CharacteristicNominalIds_type >,
                                        const Requirement_type&);

      SimultaneousRequirementGroupType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      SimultaneousRequirementGroupType (const SimultaneousRequirementGroupType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual SimultaneousRequirementGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimultaneousRequirementGroupType&
      operator= (const SimultaneousRequirementGroupType& x);

      virtual 
      ~SimultaneousRequirementGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CharacteristicNominalIds_type > CharacteristicNominalIds_;
      ::xsd::cxx::tree::one< Requirement_type > Requirement_;
      CompositeLevel_optional CompositeLevel_;
    };

    class QIF30_SYMBOL_DECL SimultaneousRequirementGroupsType: public ::xml_schema::type
    {
      public:
      // SimultaneousRequirementGroup
      //
      typedef ::xsd::qif30::SimultaneousRequirementGroupType SimultaneousRequirementGroup_type;
      typedef ::xsd::cxx::tree::sequence< SimultaneousRequirementGroup_type > SimultaneousRequirementGroup_sequence;
      typedef xsd::cxx::tree::sequence< SimultaneousRequirementGroup_type >::iterator SimultaneousRequirementGroup_iterator;
      typedef xsd::cxx::tree::sequence< SimultaneousRequirementGroup_type >::const_iterator SimultaneousRequirementGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< SimultaneousRequirementGroup_type, wchar_t > SimultaneousRequirementGroup_traits;

      const SimultaneousRequirementGroup_sequence&
      SimultaneousRequirementGroup () const;

      SimultaneousRequirementGroup_sequence&
      SimultaneousRequirementGroup ();

      void
      SimultaneousRequirementGroup (const SimultaneousRequirementGroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SimultaneousRequirementGroupsType ();

      SimultaneousRequirementGroupsType (const n_type&);

      SimultaneousRequirementGroupsType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      SimultaneousRequirementGroupsType (const SimultaneousRequirementGroupsType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual SimultaneousRequirementGroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimultaneousRequirementGroupsType&
      operator= (const SimultaneousRequirementGroupsType& x);

      virtual 
      ~SimultaneousRequirementGroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SimultaneousRequirementGroup_sequence SimultaneousRequirementGroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CharacteristicStatusEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PASS,
        FAIL,
        REWORK,
        SYSERROR,
        INDETERMINATE,
        NOT_ANALYZED,
        BASIC_OR_TED,
        UNDEFINED
      };

      CharacteristicStatusEnumType ();

      CharacteristicStatusEnumType (value v);

      CharacteristicStatusEnumType (const wchar_t* v);

      CharacteristicStatusEnumType (const ::std::wstring& v);

      CharacteristicStatusEnumType (const ::xml_schema::nmtoken& v);

      CharacteristicStatusEnumType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CharacteristicStatusEnumType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CharacteristicStatusEnumType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CharacteristicStatusEnumType (const CharacteristicStatusEnumType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CharacteristicStatusEnumType&
      operator= (const CharacteristicStatusEnumType&) = default;
#endif

      virtual CharacteristicStatusEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicStatusEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CharacteristicStatusEnumType_convert ();
      }

      protected:
      value
      _xsd_CharacteristicStatusEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CharacteristicStatusEnumType_literals_[8];
      static const value _xsd_CharacteristicStatusEnumType_indexes_[8];
    };

    class QIF30_SYMBOL_DECL CharacteristicStatusType: public ::xml_schema::type
    {
      public:
      // CharacteristicStatusEnum
      //
      typedef ::xsd::qif30::CharacteristicStatusEnumType CharacteristicStatusEnum_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicStatusEnum_type > CharacteristicStatusEnum_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicStatusEnum_type, wchar_t > CharacteristicStatusEnum_traits;

      const CharacteristicStatusEnum_optional&
      CharacteristicStatusEnum () const;

      CharacteristicStatusEnum_optional&
      CharacteristicStatusEnum ();

      void
      CharacteristicStatusEnum (const CharacteristicStatusEnum_type& x);

      void
      CharacteristicStatusEnum (const CharacteristicStatusEnum_optional& x);

      void
      CharacteristicStatusEnum (::std::unique_ptr< CharacteristicStatusEnum_type > p);

      // OtherCharacteristicStatus
      //
      typedef ::xml_schema::string OtherCharacteristicStatus_type;
      typedef ::xsd::cxx::tree::optional< OtherCharacteristicStatus_type > OtherCharacteristicStatus_optional;
      typedef ::xsd::cxx::tree::traits< OtherCharacteristicStatus_type, wchar_t > OtherCharacteristicStatus_traits;

      const OtherCharacteristicStatus_optional&
      OtherCharacteristicStatus () const;

      OtherCharacteristicStatus_optional&
      OtherCharacteristicStatus ();

      void
      OtherCharacteristicStatus (const OtherCharacteristicStatus_type& x);

      void
      OtherCharacteristicStatus (const OtherCharacteristicStatus_optional& x);

      void
      OtherCharacteristicStatus (::std::unique_ptr< OtherCharacteristicStatus_type > p);

      // Constructors.
      //
      CharacteristicStatusType ();

      CharacteristicStatusType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CharacteristicStatusType (const CharacteristicStatusType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CharacteristicStatusType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicStatusType&
      operator= (const CharacteristicStatusType& x);

      virtual 
      ~CharacteristicStatusType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicStatusEnum_optional CharacteristicStatusEnum_;
      OtherCharacteristicStatus_optional OtherCharacteristicStatus_;
    };

    class QIF30_SYMBOL_DECL CharacteristicGroupStatusType: public ::xml_schema::type
    {
      public:
      // Status
      //
      typedef ::xsd::qif30::CharacteristicStatusType Status_type;
      typedef ::xsd::cxx::tree::traits< Status_type, wchar_t > Status_traits;

      const Status_type&
      Status () const;

      Status_type&
      Status ();

      void
      Status (const Status_type& x);

      void
      Status (::std::unique_ptr< Status_type > p);

      // GroupId
      //
      typedef ::xsd::qif30::QIFReferenceFullType GroupId_type;
      typedef ::xsd::cxx::tree::traits< GroupId_type, wchar_t > GroupId_traits;

      const GroupId_type&
      GroupId () const;

      GroupId_type&
      GroupId ();

      void
      GroupId (const GroupId_type& x);

      void
      GroupId (::std::unique_ptr< GroupId_type > p);

      // Constructors.
      //
      CharacteristicGroupStatusType ();

      CharacteristicGroupStatusType (const Status_type&,
                                     const GroupId_type&);

      CharacteristicGroupStatusType (::std::unique_ptr< Status_type >,
                                     ::std::unique_ptr< GroupId_type >);

      CharacteristicGroupStatusType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CharacteristicGroupStatusType (const CharacteristicGroupStatusType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CharacteristicGroupStatusType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicGroupStatusType&
      operator= (const CharacteristicGroupStatusType& x);

      virtual 
      ~CharacteristicGroupStatusType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Status_type > Status_;
      ::xsd::cxx::tree::one< GroupId_type > GroupId_;
    };

    class QIF30_SYMBOL_DECL PointDeviationType: public ::xml_schema::type
    {
      public:
      // MeasurePointId
      //
      typedef ::xsd::qif30::PointSetReferenceSingleType MeasurePointId_type;
      typedef ::xsd::cxx::tree::traits< MeasurePointId_type, wchar_t > MeasurePointId_traits;

      const MeasurePointId_type&
      MeasurePointId () const;

      MeasurePointId_type&
      MeasurePointId ();

      void
      MeasurePointId (const MeasurePointId_type& x);

      void
      MeasurePointId (::std::unique_ptr< MeasurePointId_type > p);

      // Deviation
      //
      typedef ::xsd::qif30::LinearValueType Deviation_type;
      typedef ::xsd::cxx::tree::traits< Deviation_type, wchar_t > Deviation_traits;

      const Deviation_type&
      Deviation () const;

      Deviation_type&
      Deviation ();

      void
      Deviation (const Deviation_type& x);

      void
      Deviation (::std::unique_ptr< Deviation_type > p);

      // Constructors.
      //
      PointDeviationType ();

      PointDeviationType (const MeasurePointId_type&,
                          const Deviation_type&);

      PointDeviationType (::std::unique_ptr< MeasurePointId_type >,
                          ::std::unique_ptr< Deviation_type >);

      PointDeviationType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PointDeviationType (const PointDeviationType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual PointDeviationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDeviationType&
      operator= (const PointDeviationType& x);

      virtual 
      ~PointDeviationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MeasurePointId_type > MeasurePointId_;
      ::xsd::cxx::tree::one< Deviation_type > Deviation_;
    };

    class QIF30_SYMBOL_DECL PointDeviationsType: public ::xml_schema::type
    {
      public:
      // PointDeviation
      //
      typedef ::xsd::qif30::PointDeviationType PointDeviation_type;
      typedef ::xsd::cxx::tree::sequence< PointDeviation_type > PointDeviation_sequence;
      typedef xsd::cxx::tree::sequence< PointDeviation_type >::iterator PointDeviation_iterator;
      typedef xsd::cxx::tree::sequence< PointDeviation_type >::const_iterator PointDeviation_const_iterator;
      typedef ::xsd::cxx::tree::traits< PointDeviation_type, wchar_t > PointDeviation_traits;

      const PointDeviation_sequence&
      PointDeviation () const;

      PointDeviation_sequence&
      PointDeviation ();

      void
      PointDeviation (const PointDeviation_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PointDeviationsType ();

      PointDeviationsType (const n_type&);

      PointDeviationsType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PointDeviationsType (const PointDeviationsType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual PointDeviationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDeviationsType&
      operator= (const PointDeviationsType& x);

      virtual 
      ~PointDeviationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointDeviation_sequence PointDeviation_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ExtentEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ALL_OVER,
        ALL_AROUND,
        ALL_OVER_THIS_SIDE,
        ALL_AROUND_THIS_SIDE,
        UNDEFINED
      };

      ExtentEnumType ();

      ExtentEnumType (value v);

      ExtentEnumType (const wchar_t* v);

      ExtentEnumType (const ::std::wstring& v);

      ExtentEnumType (const ::xml_schema::nmtoken& v);

      ExtentEnumType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ExtentEnumType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ExtentEnumType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ExtentEnumType (const ExtentEnumType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ExtentEnumType&
      operator= (const ExtentEnumType&) = default;
#endif

      virtual ExtentEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtentEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ExtentEnumType_convert ();
      }

      protected:
      value
      _xsd_ExtentEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ExtentEnumType_literals_[5];
      static const value _xsd_ExtentEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL ExtentType: public ::xml_schema::type
    {
      public:
      // ExtentEnum
      //
      typedef ::xsd::qif30::ExtentEnumType ExtentEnum_type;
      typedef ::xsd::cxx::tree::optional< ExtentEnum_type > ExtentEnum_optional;
      typedef ::xsd::cxx::tree::traits< ExtentEnum_type, wchar_t > ExtentEnum_traits;

      const ExtentEnum_optional&
      ExtentEnum () const;

      ExtentEnum_optional&
      ExtentEnum ();

      void
      ExtentEnum (const ExtentEnum_type& x);

      void
      ExtentEnum (const ExtentEnum_optional& x);

      void
      ExtentEnum (::std::unique_ptr< ExtentEnum_type > p);

      // OtherExtent
      //
      typedef ::xml_schema::string OtherExtent_type;
      typedef ::xsd::cxx::tree::optional< OtherExtent_type > OtherExtent_optional;
      typedef ::xsd::cxx::tree::traits< OtherExtent_type, wchar_t > OtherExtent_traits;

      const OtherExtent_optional&
      OtherExtent () const;

      OtherExtent_optional&
      OtherExtent ();

      void
      OtherExtent (const OtherExtent_type& x);

      void
      OtherExtent (const OtherExtent_optional& x);

      void
      OtherExtent (::std::unique_ptr< OtherExtent_type > p);

      // Constructors.
      //
      ExtentType ();

      ExtentType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ExtentType (const ExtentType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual ExtentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtentType&
      operator= (const ExtentType& x);

      virtual 
      ~ExtentType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ExtentEnum_optional ExtentEnum_;
      OtherExtent_optional OtherExtent_;
    };

    class QIF30_SYMBOL_DECL PositionCoordinateMethodEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        RECTANGULAR,
        POLAR
      };

      PositionCoordinateMethodEnumType ();

      PositionCoordinateMethodEnumType (value v);

      PositionCoordinateMethodEnumType (const wchar_t* v);

      PositionCoordinateMethodEnumType (const ::std::wstring& v);

      PositionCoordinateMethodEnumType (const ::xml_schema::string& v);

      PositionCoordinateMethodEnumType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      PositionCoordinateMethodEnumType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      PositionCoordinateMethodEnumType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      PositionCoordinateMethodEnumType (const PositionCoordinateMethodEnumType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      PositionCoordinateMethodEnumType&
      operator= (const PositionCoordinateMethodEnumType&) = default;
#endif

      virtual PositionCoordinateMethodEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionCoordinateMethodEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PositionCoordinateMethodEnumType_convert ();
      }

      protected:
      value
      _xsd_PositionCoordinateMethodEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_PositionCoordinateMethodEnumType_literals_[2];
      static const value _xsd_PositionCoordinateMethodEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL PositionCoordinateMethodType: public ::xml_schema::type
    {
      public:
      // Method
      //
      typedef ::xsd::qif30::PositionCoordinateMethodEnumType Method_type;
      typedef ::xsd::cxx::tree::traits< Method_type, wchar_t > Method_traits;

      const Method_type&
      Method () const;

      Method_type&
      Method ();

      void
      Method (const Method_type& x);

      void
      Method (::std::unique_ptr< Method_type > p);

      // FeatureZoneIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType FeatureZoneIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureZoneIds_type > FeatureZoneIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureZoneIds_type, wchar_t > FeatureZoneIds_traits;

      const FeatureZoneIds_optional&
      FeatureZoneIds () const;

      FeatureZoneIds_optional&
      FeatureZoneIds ();

      void
      FeatureZoneIds (const FeatureZoneIds_type& x);

      void
      FeatureZoneIds (const FeatureZoneIds_optional& x);

      void
      FeatureZoneIds (::std::unique_ptr< FeatureZoneIds_type > p);

      // Constructors.
      //
      PositionCoordinateMethodType ();

      PositionCoordinateMethodType (const Method_type&);

      PositionCoordinateMethodType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      PositionCoordinateMethodType (const PositionCoordinateMethodType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual PositionCoordinateMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionCoordinateMethodType&
      operator= (const PositionCoordinateMethodType& x);

      virtual 
      ~PositionCoordinateMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Method_type > Method_;
      FeatureZoneIds_optional FeatureZoneIds_;
    };

    class QIF30_SYMBOL_DECL ThreadCharacteristicItemType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      ThreadCharacteristicItemType ();

      ThreadCharacteristicItemType (const id_type&,
                                    const CharacteristicNominalId_type&);

      ThreadCharacteristicItemType (const id_type&,
                                    ::std::unique_ptr< CharacteristicNominalId_type >);

      ThreadCharacteristicItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ThreadCharacteristicItemType (const ThreadCharacteristicItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ThreadCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ThreadCharacteristicItemType&
      operator= (const ThreadCharacteristicItemType&) = default;
#endif

      virtual 
      ~ThreadCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL ThreadCharacteristicDefinitionType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // ThreadSpecificationId
      //
      typedef ::xsd::qif30::QIFReferenceType ThreadSpecificationId_type;
      typedef ::xsd::cxx::tree::traits< ThreadSpecificationId_type, wchar_t > ThreadSpecificationId_traits;

      const ThreadSpecificationId_type&
      ThreadSpecificationId () const;

      ThreadSpecificationId_type&
      ThreadSpecificationId ();

      void
      ThreadSpecificationId (const ThreadSpecificationId_type& x);

      void
      ThreadSpecificationId (::std::unique_ptr< ThreadSpecificationId_type > p);

      // Constructors.
      //
      ThreadCharacteristicDefinitionType ();

      ThreadCharacteristicDefinitionType (const id_type&,
                                          const ThreadSpecificationId_type&);

      ThreadCharacteristicDefinitionType (const id_type&,
                                          ::std::unique_ptr< ThreadSpecificationId_type >);

      ThreadCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ThreadCharacteristicDefinitionType (const ThreadCharacteristicDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ThreadCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadCharacteristicDefinitionType&
      operator= (const ThreadCharacteristicDefinitionType& x);

      virtual 
      ~ThreadCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ThreadSpecificationId_type > ThreadSpecificationId_;
    };

    class QIF30_SYMBOL_DECL ThreadCharacteristicNominalType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // Constructors.
      //
      ThreadCharacteristicNominalType ();

      ThreadCharacteristicNominalType (const id_type&,
                                       const CharacteristicDefinitionId_type&);

      ThreadCharacteristicNominalType (const id_type&,
                                       ::std::unique_ptr< CharacteristicDefinitionId_type >);

      ThreadCharacteristicNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ThreadCharacteristicNominalType (const ThreadCharacteristicNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ThreadCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ThreadCharacteristicNominalType&
      operator= (const ThreadCharacteristicNominalType&) = default;
#endif

      virtual 
      ~ThreadCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL ThreadCharacteristicMeasurementType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // PitchDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType PitchDiameter_type;
      typedef ::xsd::cxx::tree::optional< PitchDiameter_type > PitchDiameter_optional;
      typedef ::xsd::cxx::tree::traits< PitchDiameter_type, wchar_t > PitchDiameter_traits;

      const PitchDiameter_optional&
      PitchDiameter () const;

      PitchDiameter_optional&
      PitchDiameter ();

      void
      PitchDiameter (const PitchDiameter_type& x);

      void
      PitchDiameter (const PitchDiameter_optional& x);

      void
      PitchDiameter (::std::unique_ptr< PitchDiameter_type > p);

      // FunctionalSize
      //
      typedef ::xsd::qif30::MeasuredLinearValueType FunctionalSize_type;
      typedef ::xsd::cxx::tree::optional< FunctionalSize_type > FunctionalSize_optional;
      typedef ::xsd::cxx::tree::traits< FunctionalSize_type, wchar_t > FunctionalSize_traits;

      const FunctionalSize_optional&
      FunctionalSize () const;

      FunctionalSize_optional&
      FunctionalSize ();

      void
      FunctionalSize (const FunctionalSize_type& x);

      void
      FunctionalSize (const FunctionalSize_optional& x);

      void
      FunctionalSize (::std::unique_ptr< FunctionalSize_type > p);

      // Constructors.
      //
      ThreadCharacteristicMeasurementType ();

      ThreadCharacteristicMeasurementType (const id_type&,
                                           const Status_type&,
                                           const CharacteristicItemId_type&);

      ThreadCharacteristicMeasurementType (const id_type&,
                                           ::std::unique_ptr< Status_type >,
                                           ::std::unique_ptr< CharacteristicItemId_type >);

      ThreadCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ThreadCharacteristicMeasurementType (const ThreadCharacteristicMeasurementType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ThreadCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadCharacteristicMeasurementType&
      operator= (const ThreadCharacteristicMeasurementType& x);

      virtual 
      ~ThreadCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PitchDiameter_optional PitchDiameter_;
      FunctionalSize_optional FunctionalSize_;
    };

    class QIF30_SYMBOL_DECL CharacteristicAspectsListsType: public ::xml_schema::type
    {
      public:
      // FormalStandardId
      //
      typedef ::xsd::qif30::QIFReferenceType FormalStandardId_type;
      typedef ::xsd::cxx::tree::traits< FormalStandardId_type, wchar_t > FormalStandardId_traits;

      const FormalStandardId_type&
      FormalStandardId () const;

      FormalStandardId_type&
      FormalStandardId ();

      void
      FormalStandardId (const FormalStandardId_type& x);

      void
      FormalStandardId (::std::unique_ptr< FormalStandardId_type > p);

      // CharacteristicDefinitions
      //
      typedef ::xsd::qif30::CharacteristicDefinitionsType CharacteristicDefinitions_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicDefinitions_type, wchar_t > CharacteristicDefinitions_traits;

      const CharacteristicDefinitions_type&
      CharacteristicDefinitions () const;

      CharacteristicDefinitions_type&
      CharacteristicDefinitions ();

      void
      CharacteristicDefinitions (const CharacteristicDefinitions_type& x);

      void
      CharacteristicDefinitions (::std::unique_ptr< CharacteristicDefinitions_type > p);

      // DefaultCharacteristicDefinitions
      //
      typedef ::xsd::qif30::CharacteristicDefinitionsType DefaultCharacteristicDefinitions_type;
      typedef ::xsd::cxx::tree::optional< DefaultCharacteristicDefinitions_type > DefaultCharacteristicDefinitions_optional;
      typedef ::xsd::cxx::tree::traits< DefaultCharacteristicDefinitions_type, wchar_t > DefaultCharacteristicDefinitions_traits;

      const DefaultCharacteristicDefinitions_optional&
      DefaultCharacteristicDefinitions () const;

      DefaultCharacteristicDefinitions_optional&
      DefaultCharacteristicDefinitions ();

      void
      DefaultCharacteristicDefinitions (const DefaultCharacteristicDefinitions_type& x);

      void
      DefaultCharacteristicDefinitions (const DefaultCharacteristicDefinitions_optional& x);

      void
      DefaultCharacteristicDefinitions (::std::unique_ptr< DefaultCharacteristicDefinitions_type > p);

      // DefaultToleranceDefinitions
      //
      typedef ::xsd::qif30::ToleranceDefinitionsType DefaultToleranceDefinitions_type;
      typedef ::xsd::cxx::tree::optional< DefaultToleranceDefinitions_type > DefaultToleranceDefinitions_optional;
      typedef ::xsd::cxx::tree::traits< DefaultToleranceDefinitions_type, wchar_t > DefaultToleranceDefinitions_traits;

      const DefaultToleranceDefinitions_optional&
      DefaultToleranceDefinitions () const;

      DefaultToleranceDefinitions_optional&
      DefaultToleranceDefinitions ();

      void
      DefaultToleranceDefinitions (const DefaultToleranceDefinitions_type& x);

      void
      DefaultToleranceDefinitions (const DefaultToleranceDefinitions_optional& x);

      void
      DefaultToleranceDefinitions (::std::unique_ptr< DefaultToleranceDefinitions_type > p);

      // CharacteristicNominals
      //
      typedef ::xsd::qif30::CharacteristicNominalsType CharacteristicNominals_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicNominals_type, wchar_t > CharacteristicNominals_traits;

      const CharacteristicNominals_type&
      CharacteristicNominals () const;

      CharacteristicNominals_type&
      CharacteristicNominals ();

      void
      CharacteristicNominals (const CharacteristicNominals_type& x);

      void
      CharacteristicNominals (::std::unique_ptr< CharacteristicNominals_type > p);

      // CharacteristicItems
      //
      typedef ::xsd::qif30::CharacteristicItemsType CharacteristicItems_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicItems_type > CharacteristicItems_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicItems_type, wchar_t > CharacteristicItems_traits;

      const CharacteristicItems_optional&
      CharacteristicItems () const;

      CharacteristicItems_optional&
      CharacteristicItems ();

      void
      CharacteristicItems (const CharacteristicItems_type& x);

      void
      CharacteristicItems (const CharacteristicItems_optional& x);

      void
      CharacteristicItems (::std::unique_ptr< CharacteristicItems_type > p);

      // CharacteristicGroups
      //
      typedef ::xsd::qif30::CharacteristicGroupsType CharacteristicGroups_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicGroups_type > CharacteristicGroups_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicGroups_type, wchar_t > CharacteristicGroups_traits;

      const CharacteristicGroups_optional&
      CharacteristicGroups () const;

      CharacteristicGroups_optional&
      CharacteristicGroups ();

      void
      CharacteristicGroups (const CharacteristicGroups_type& x);

      void
      CharacteristicGroups (const CharacteristicGroups_optional& x);

      void
      CharacteristicGroups (::std::unique_ptr< CharacteristicGroups_type > p);

      // SimultaneousRequirementGroups
      //
      typedef ::xsd::qif30::SimultaneousRequirementGroupsType SimultaneousRequirementGroups_type;
      typedef ::xsd::cxx::tree::optional< SimultaneousRequirementGroups_type > SimultaneousRequirementGroups_optional;
      typedef ::xsd::cxx::tree::traits< SimultaneousRequirementGroups_type, wchar_t > SimultaneousRequirementGroups_traits;

      const SimultaneousRequirementGroups_optional&
      SimultaneousRequirementGroups () const;

      SimultaneousRequirementGroups_optional&
      SimultaneousRequirementGroups ();

      void
      SimultaneousRequirementGroups (const SimultaneousRequirementGroups_type& x);

      void
      SimultaneousRequirementGroups (const SimultaneousRequirementGroups_optional& x);

      void
      SimultaneousRequirementGroups (::std::unique_ptr< SimultaneousRequirementGroups_type > p);

      // Constructors.
      //
      CharacteristicAspectsListsType ();

      CharacteristicAspectsListsType (const FormalStandardId_type&,
                                      const CharacteristicDefinitions_type&,
                                      const CharacteristicNominals_type&);

      CharacteristicAspectsListsType (::std::unique_ptr< FormalStandardId_type >,
                                      ::std::unique_ptr< CharacteristicDefinitions_type >,
                                      ::std::unique_ptr< CharacteristicNominals_type >);

      CharacteristicAspectsListsType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      CharacteristicAspectsListsType (const CharacteristicAspectsListsType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual CharacteristicAspectsListsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicAspectsListsType&
      operator= (const CharacteristicAspectsListsType& x);

      virtual 
      ~CharacteristicAspectsListsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FormalStandardId_type > FormalStandardId_;
      ::xsd::cxx::tree::one< CharacteristicDefinitions_type > CharacteristicDefinitions_;
      DefaultCharacteristicDefinitions_optional DefaultCharacteristicDefinitions_;
      DefaultToleranceDefinitions_optional DefaultToleranceDefinitions_;
      ::xsd::cxx::tree::one< CharacteristicNominals_type > CharacteristicNominals_;
      CharacteristicItems_optional CharacteristicItems_;
      CharacteristicGroups_optional CharacteristicGroups_;
      SimultaneousRequirementGroups_optional SimultaneousRequirementGroups_;
    };

    class QIF30_SYMBOL_DECL MeasuredCharacteristicsType: public ::xml_schema::type
    {
      public:
      // CharacteristicMeasurements
      //
      typedef ::xsd::qif30::CharacteristicMeasurementsType CharacteristicMeasurements_type;
      typedef ::xsd::cxx::tree::traits< CharacteristicMeasurements_type, wchar_t > CharacteristicMeasurements_traits;

      const CharacteristicMeasurements_type&
      CharacteristicMeasurements () const;

      CharacteristicMeasurements_type&
      CharacteristicMeasurements ();

      void
      CharacteristicMeasurements (const CharacteristicMeasurements_type& x);

      void
      CharacteristicMeasurements (::std::unique_ptr< CharacteristicMeasurements_type > p);

      // CharacteristicGroupStatuses
      //
      typedef ::xsd::qif30::CharacteristicGroupStatusesType CharacteristicGroupStatuses_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicGroupStatuses_type > CharacteristicGroupStatuses_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicGroupStatuses_type, wchar_t > CharacteristicGroupStatuses_traits;

      const CharacteristicGroupStatuses_optional&
      CharacteristicGroupStatuses () const;

      CharacteristicGroupStatuses_optional&
      CharacteristicGroupStatuses ();

      void
      CharacteristicGroupStatuses (const CharacteristicGroupStatuses_type& x);

      void
      CharacteristicGroupStatuses (const CharacteristicGroupStatuses_optional& x);

      void
      CharacteristicGroupStatuses (::std::unique_ptr< CharacteristicGroupStatuses_type > p);

      // Constructors.
      //
      MeasuredCharacteristicsType ();

      MeasuredCharacteristicsType (const CharacteristicMeasurements_type&);

      MeasuredCharacteristicsType (::std::unique_ptr< CharacteristicMeasurements_type >);

      MeasuredCharacteristicsType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      MeasuredCharacteristicsType (const MeasuredCharacteristicsType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual MeasuredCharacteristicsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredCharacteristicsType&
      operator= (const MeasuredCharacteristicsType& x);

      virtual 
      ~MeasuredCharacteristicsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CharacteristicMeasurements_type > CharacteristicMeasurements_;
      CharacteristicGroupStatuses_optional CharacteristicGroupStatuses_;
    };

    class QIF30_SYMBOL_DECL CharacteristicItemsType: public ::xml_schema::type
    {
      public:
      // CharacteristicItem
      //
      typedef ::xsd::qif30::CharacteristicItemBaseType CharacteristicItem_type;
      typedef ::xsd::cxx::tree::sequence< CharacteristicItem_type > CharacteristicItem_sequence;
      typedef xsd::cxx::tree::sequence< CharacteristicItem_type >::iterator CharacteristicItem_iterator;
      typedef xsd::cxx::tree::sequence< CharacteristicItem_type >::const_iterator CharacteristicItem_const_iterator;
      typedef ::xsd::cxx::tree::traits< CharacteristicItem_type, wchar_t > CharacteristicItem_traits;

      const CharacteristicItem_sequence&
      CharacteristicItem () const;

      CharacteristicItem_sequence&
      CharacteristicItem ();

      void
      CharacteristicItem (const CharacteristicItem_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CharacteristicItemsType ();

      CharacteristicItemsType (const n_type&);

      CharacteristicItemsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CharacteristicItemsType (const CharacteristicItemsType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CharacteristicItemsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicItemsType&
      operator= (const CharacteristicItemsType& x);

      virtual 
      ~CharacteristicItemsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicItem_sequence CharacteristicItem_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CharacteristicGroupsType: public ::xml_schema::type
    {
      public:
      // CharacteristicGroup
      //
      typedef ::xsd::qif30::CharacteristicGroupType CharacteristicGroup_type;
      typedef ::xsd::cxx::tree::sequence< CharacteristicGroup_type > CharacteristicGroup_sequence;
      typedef xsd::cxx::tree::sequence< CharacteristicGroup_type >::iterator CharacteristicGroup_iterator;
      typedef xsd::cxx::tree::sequence< CharacteristicGroup_type >::const_iterator CharacteristicGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< CharacteristicGroup_type, wchar_t > CharacteristicGroup_traits;

      const CharacteristicGroup_sequence&
      CharacteristicGroup () const;

      CharacteristicGroup_sequence&
      CharacteristicGroup ();

      void
      CharacteristicGroup (const CharacteristicGroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CharacteristicGroupsType ();

      CharacteristicGroupsType (const n_type&);

      CharacteristicGroupsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CharacteristicGroupsType (const CharacteristicGroupsType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CharacteristicGroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicGroupsType&
      operator= (const CharacteristicGroupsType& x);

      virtual 
      ~CharacteristicGroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicGroup_sequence CharacteristicGroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CharacteristicGroupStatusesType: public ::xml_schema::type
    {
      public:
      // CharacteristicGroupStatus
      //
      typedef ::xsd::qif30::CharacteristicGroupStatusType CharacteristicGroupStatus_type;
      typedef ::xsd::cxx::tree::sequence< CharacteristicGroupStatus_type > CharacteristicGroupStatus_sequence;
      typedef xsd::cxx::tree::sequence< CharacteristicGroupStatus_type >::iterator CharacteristicGroupStatus_iterator;
      typedef xsd::cxx::tree::sequence< CharacteristicGroupStatus_type >::const_iterator CharacteristicGroupStatus_const_iterator;
      typedef ::xsd::cxx::tree::traits< CharacteristicGroupStatus_type, wchar_t > CharacteristicGroupStatus_traits;

      const CharacteristicGroupStatus_sequence&
      CharacteristicGroupStatus () const;

      CharacteristicGroupStatus_sequence&
      CharacteristicGroupStatus ();

      void
      CharacteristicGroupStatus (const CharacteristicGroupStatus_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CharacteristicGroupStatusesType ();

      CharacteristicGroupStatusesType (const n_type&);

      CharacteristicGroupStatusesType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CharacteristicGroupStatusesType (const CharacteristicGroupStatusesType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CharacteristicGroupStatusesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicGroupStatusesType&
      operator= (const CharacteristicGroupStatusesType& x);

      virtual 
      ~CharacteristicGroupStatusesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicGroupStatus_sequence CharacteristicGroupStatus_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CharacteristicDefinitionsType: public ::xml_schema::type
    {
      public:
      // CharacteristicDefinition
      //
      typedef ::xsd::qif30::CharacteristicDefinitionBaseType CharacteristicDefinition_type;
      typedef ::xsd::cxx::tree::sequence< CharacteristicDefinition_type > CharacteristicDefinition_sequence;
      typedef xsd::cxx::tree::sequence< CharacteristicDefinition_type >::iterator CharacteristicDefinition_iterator;
      typedef xsd::cxx::tree::sequence< CharacteristicDefinition_type >::const_iterator CharacteristicDefinition_const_iterator;
      typedef ::xsd::cxx::tree::traits< CharacteristicDefinition_type, wchar_t > CharacteristicDefinition_traits;

      const CharacteristicDefinition_sequence&
      CharacteristicDefinition () const;

      CharacteristicDefinition_sequence&
      CharacteristicDefinition ();

      void
      CharacteristicDefinition (const CharacteristicDefinition_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CharacteristicDefinitionsType ();

      CharacteristicDefinitionsType (const n_type&);

      CharacteristicDefinitionsType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CharacteristicDefinitionsType (const CharacteristicDefinitionsType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CharacteristicDefinitionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicDefinitionsType&
      operator= (const CharacteristicDefinitionsType& x);

      virtual 
      ~CharacteristicDefinitionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicDefinition_sequence CharacteristicDefinition_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ToleranceDefinitionsType: public ::xml_schema::type
    {
      public:
      // LinearTolerance
      //
      typedef ::xsd::qif30::LinearToleranceDefinitionType LinearTolerance_type;
      typedef ::xsd::cxx::tree::sequence< LinearTolerance_type > LinearTolerance_sequence;
      typedef xsd::cxx::tree::sequence< LinearTolerance_type >::iterator LinearTolerance_iterator;
      typedef xsd::cxx::tree::sequence< LinearTolerance_type >::const_iterator LinearTolerance_const_iterator;
      typedef ::xsd::cxx::tree::traits< LinearTolerance_type, wchar_t > LinearTolerance_traits;

      const LinearTolerance_sequence&
      LinearTolerance () const;

      LinearTolerance_sequence&
      LinearTolerance ();

      void
      LinearTolerance (const LinearTolerance_sequence& s);

      // AngularTolerance
      //
      typedef ::xsd::qif30::AngularToleranceDefinitionType AngularTolerance_type;
      typedef ::xsd::cxx::tree::sequence< AngularTolerance_type > AngularTolerance_sequence;
      typedef xsd::cxx::tree::sequence< AngularTolerance_type >::iterator AngularTolerance_iterator;
      typedef xsd::cxx::tree::sequence< AngularTolerance_type >::const_iterator AngularTolerance_const_iterator;
      typedef ::xsd::cxx::tree::traits< AngularTolerance_type, wchar_t > AngularTolerance_traits;

      const AngularTolerance_sequence&
      AngularTolerance () const;

      AngularTolerance_sequence&
      AngularTolerance ();

      void
      AngularTolerance (const AngularTolerance_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ToleranceDefinitionsType ();

      ToleranceDefinitionsType (const n_type&);

      ToleranceDefinitionsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ToleranceDefinitionsType (const ToleranceDefinitionsType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ToleranceDefinitionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceDefinitionsType&
      operator= (const ToleranceDefinitionsType& x);

      virtual 
      ~ToleranceDefinitionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearTolerance_sequence LinearTolerance_;
      AngularTolerance_sequence AngularTolerance_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CharacteristicNominalsType: public ::xml_schema::type
    {
      public:
      // CharacteristicNominal
      //
      typedef ::xsd::qif30::CharacteristicNominalBaseType CharacteristicNominal_type;
      typedef ::xsd::cxx::tree::sequence< CharacteristicNominal_type > CharacteristicNominal_sequence;
      typedef xsd::cxx::tree::sequence< CharacteristicNominal_type >::iterator CharacteristicNominal_iterator;
      typedef xsd::cxx::tree::sequence< CharacteristicNominal_type >::const_iterator CharacteristicNominal_const_iterator;
      typedef ::xsd::cxx::tree::traits< CharacteristicNominal_type, wchar_t > CharacteristicNominal_traits;

      const CharacteristicNominal_sequence&
      CharacteristicNominal () const;

      CharacteristicNominal_sequence&
      CharacteristicNominal ();

      void
      CharacteristicNominal (const CharacteristicNominal_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CharacteristicNominalsType ();

      CharacteristicNominalsType (const n_type&);

      CharacteristicNominalsType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CharacteristicNominalsType (const CharacteristicNominalsType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CharacteristicNominalsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicNominalsType&
      operator= (const CharacteristicNominalsType& x);

      virtual 
      ~CharacteristicNominalsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicNominal_sequence CharacteristicNominal_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CharacteristicMeasurementsType: public ::xml_schema::type
    {
      public:
      // CharacteristicMeasurement
      //
      typedef ::xsd::qif30::CharacteristicMeasurementBaseType CharacteristicMeasurement_type;
      typedef ::xsd::cxx::tree::sequence< CharacteristicMeasurement_type > CharacteristicMeasurement_sequence;
      typedef xsd::cxx::tree::sequence< CharacteristicMeasurement_type >::iterator CharacteristicMeasurement_iterator;
      typedef xsd::cxx::tree::sequence< CharacteristicMeasurement_type >::const_iterator CharacteristicMeasurement_const_iterator;
      typedef ::xsd::cxx::tree::traits< CharacteristicMeasurement_type, wchar_t > CharacteristicMeasurement_traits;

      const CharacteristicMeasurement_sequence&
      CharacteristicMeasurement () const;

      CharacteristicMeasurement_sequence&
      CharacteristicMeasurement ();

      void
      CharacteristicMeasurement (const CharacteristicMeasurement_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CharacteristicMeasurementsType ();

      CharacteristicMeasurementsType (const n_type&);

      CharacteristicMeasurementsType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      CharacteristicMeasurementsType (const CharacteristicMeasurementsType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual CharacteristicMeasurementsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicMeasurementsType&
      operator= (const CharacteristicMeasurementsType& x);

      virtual 
      ~CharacteristicMeasurementsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicMeasurement_sequence CharacteristicMeasurement_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL WeldContourSymbolEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        WELD_CONTOUR_FLAT,
        WELD_CONTOUR_FLAT_ANGLED,
        WELD_CONTOUR_CONCAVE,
        WELD_CONTOUR_CONCAVE_ANGLED,
        WELD_CONTOUR_CONVEX,
        WELD_CONTOUR_CONVEX_ANGLED
      };

      WeldContourSymbolEnumType ();

      WeldContourSymbolEnumType (value v);

      WeldContourSymbolEnumType (const wchar_t* v);

      WeldContourSymbolEnumType (const ::std::wstring& v);

      WeldContourSymbolEnumType (const ::xml_schema::string& v);

      WeldContourSymbolEnumType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      WeldContourSymbolEnumType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      WeldContourSymbolEnumType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      WeldContourSymbolEnumType (const WeldContourSymbolEnumType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      WeldContourSymbolEnumType&
      operator= (const WeldContourSymbolEnumType&) = default;
#endif

      virtual WeldContourSymbolEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldContourSymbolEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_WeldContourSymbolEnumType_convert ();
      }

      protected:
      value
      _xsd_WeldContourSymbolEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_WeldContourSymbolEnumType_literals_[6];
      static const value _xsd_WeldContourSymbolEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL WeldFinishingDesignatorEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        MACHINING,
        GRINDING,
        CHIPPING,
        HAMMERING,
        ROLLING,
        UNSPECIFIED
      };

      WeldFinishingDesignatorEnumType ();

      WeldFinishingDesignatorEnumType (value v);

      WeldFinishingDesignatorEnumType (const wchar_t* v);

      WeldFinishingDesignatorEnumType (const ::std::wstring& v);

      WeldFinishingDesignatorEnumType (const ::xml_schema::string& v);

      WeldFinishingDesignatorEnumType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldFinishingDesignatorEnumType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldFinishingDesignatorEnumType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldFinishingDesignatorEnumType (const WeldFinishingDesignatorEnumType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      WeldFinishingDesignatorEnumType&
      operator= (const WeldFinishingDesignatorEnumType&) = default;
#endif

      virtual WeldFinishingDesignatorEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFinishingDesignatorEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_WeldFinishingDesignatorEnumType_convert ();
      }

      protected:
      value
      _xsd_WeldFinishingDesignatorEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_WeldFinishingDesignatorEnumType_literals_[6];
      static const value _xsd_WeldFinishingDesignatorEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL LocationSignificanceOneSidesEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        ARROW_SIDE,
        OTHER_SIDE
      };

      LocationSignificanceOneSidesEnumType ();

      LocationSignificanceOneSidesEnumType (value v);

      LocationSignificanceOneSidesEnumType (const wchar_t* v);

      LocationSignificanceOneSidesEnumType (const ::std::wstring& v);

      LocationSignificanceOneSidesEnumType (const ::xml_schema::string& v);

      LocationSignificanceOneSidesEnumType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      LocationSignificanceOneSidesEnumType (const xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      LocationSignificanceOneSidesEnumType (const ::std::wstring& s,
                                            const xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      LocationSignificanceOneSidesEnumType (const LocationSignificanceOneSidesEnumType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LocationSignificanceOneSidesEnumType&
      operator= (const LocationSignificanceOneSidesEnumType&) = default;
#endif

      virtual LocationSignificanceOneSidesEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocationSignificanceOneSidesEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LocationSignificanceOneSidesEnumType_convert ();
      }

      protected:
      value
      _xsd_LocationSignificanceOneSidesEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LocationSignificanceOneSidesEnumType_literals_[2];
      static const value _xsd_LocationSignificanceOneSidesEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL LocationSignificanceSpotSeamEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        ARROW_SIDE,
        OTHER_SIDE,
        NO_SIDE
      };

      LocationSignificanceSpotSeamEnumType ();

      LocationSignificanceSpotSeamEnumType (value v);

      LocationSignificanceSpotSeamEnumType (const wchar_t* v);

      LocationSignificanceSpotSeamEnumType (const ::std::wstring& v);

      LocationSignificanceSpotSeamEnumType (const ::xml_schema::string& v);

      LocationSignificanceSpotSeamEnumType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      LocationSignificanceSpotSeamEnumType (const xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      LocationSignificanceSpotSeamEnumType (const ::std::wstring& s,
                                            const xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      LocationSignificanceSpotSeamEnumType (const LocationSignificanceSpotSeamEnumType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LocationSignificanceSpotSeamEnumType&
      operator= (const LocationSignificanceSpotSeamEnumType&) = default;
#endif

      virtual LocationSignificanceSpotSeamEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocationSignificanceSpotSeamEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LocationSignificanceSpotSeamEnumType_convert ();
      }

      protected:
      value
      _xsd_LocationSignificanceSpotSeamEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LocationSignificanceSpotSeamEnumType_literals_[3];
      static const value _xsd_LocationSignificanceSpotSeamEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL LocationSignificanceAllEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        ARROW_SIDE,
        OTHER_SIDE,
        BOTH_SIDE
      };

      LocationSignificanceAllEnumType ();

      LocationSignificanceAllEnumType (value v);

      LocationSignificanceAllEnumType (const wchar_t* v);

      LocationSignificanceAllEnumType (const ::std::wstring& v);

      LocationSignificanceAllEnumType (const ::xml_schema::string& v);

      LocationSignificanceAllEnumType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      LocationSignificanceAllEnumType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      LocationSignificanceAllEnumType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      LocationSignificanceAllEnumType (const LocationSignificanceAllEnumType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LocationSignificanceAllEnumType&
      operator= (const LocationSignificanceAllEnumType&) = default;
#endif

      virtual LocationSignificanceAllEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocationSignificanceAllEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LocationSignificanceAllEnumType_convert ();
      }

      protected:
      value
      _xsd_LocationSignificanceAllEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LocationSignificanceAllEnumType_literals_[3];
      static const value _xsd_LocationSignificanceAllEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL NonDestructiveTestingEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        ACOUSTIC_EMISSION,
        ELECTROMAGNETIC,
        LEAK,
        MAGNETIC_PARTICLE,
        NEUTRON_RADIOGRAPHIC,
        PENETRANT,
        PROOF,
        RADIOGRAPHIC,
        ULTRASONIC,
        VISUAL
      };

      NonDestructiveTestingEnumType ();

      NonDestructiveTestingEnumType (value v);

      NonDestructiveTestingEnumType (const wchar_t* v);

      NonDestructiveTestingEnumType (const ::std::wstring& v);

      NonDestructiveTestingEnumType (const ::xml_schema::string& v);

      NonDestructiveTestingEnumType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      NonDestructiveTestingEnumType (const xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      NonDestructiveTestingEnumType (const ::std::wstring& s,
                                     const xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      NonDestructiveTestingEnumType (const NonDestructiveTestingEnumType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      NonDestructiveTestingEnumType&
      operator= (const NonDestructiveTestingEnumType&) = default;
#endif

      virtual NonDestructiveTestingEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NonDestructiveTestingEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_NonDestructiveTestingEnumType_convert ();
      }

      protected:
      value
      _xsd_NonDestructiveTestingEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_NonDestructiveTestingEnumType_literals_[10];
      static const value _xsd_NonDestructiveTestingEnumType_indexes_[10];
    };

    class QIF30_SYMBOL_DECL WeldingProcessEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        ARC_WELDING,
        SHIELDED_METAL_ARC_WELDING,
        FLUX_CORED_ARC_WELDING,
        SUBMERGED_ARC_WELDING,
        GAS_METAL_ARC_WELDING,
        GAS_TUNGSTEN_ARC_WELDING,
        PLASMA_ARC_WELDING,
        RESISTANCE_WELDING,
        RESISTANCE_SPOT_WELDING,
        RESISTANCE_SEAM_WELDING,
        PROJECTION_WELD,
        FLASH_WELDING,
        OXYFUEL_GAS_WELDING,
        OXYACETYLENE_WELDING,
        FRICTION_WELDING,
        FORGE_WELDING,
        THERMIT_WELDING,
        ELECTROSLAG_WELDING,
        STUD_ARC_WELDING,
        BRAZING,
        SOLDERING
      };

      WeldingProcessEnumType ();

      WeldingProcessEnumType (value v);

      WeldingProcessEnumType (const wchar_t* v);

      WeldingProcessEnumType (const ::std::wstring& v);

      WeldingProcessEnumType (const ::xml_schema::string& v);

      WeldingProcessEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      WeldingProcessEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      WeldingProcessEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      WeldingProcessEnumType (const WeldingProcessEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      WeldingProcessEnumType&
      operator= (const WeldingProcessEnumType&) = default;
#endif

      virtual WeldingProcessEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldingProcessEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_WeldingProcessEnumType_convert ();
      }

      protected:
      value
      _xsd_WeldingProcessEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_WeldingProcessEnumType_literals_[21];
      static const value _xsd_WeldingProcessEnumType_indexes_[21];
    };

    class QIF30_SYMBOL_DECL WeldingProcessSuffixEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        MANUAL,
        SEMI_AUTOMATIC,
        ROBOTIC,
        MACHINE
      };

      WeldingProcessSuffixEnumType ();

      WeldingProcessSuffixEnumType (value v);

      WeldingProcessSuffixEnumType (const wchar_t* v);

      WeldingProcessSuffixEnumType (const ::std::wstring& v);

      WeldingProcessSuffixEnumType (const ::xml_schema::string& v);

      WeldingProcessSuffixEnumType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      WeldingProcessSuffixEnumType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      WeldingProcessSuffixEnumType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      WeldingProcessSuffixEnumType (const WeldingProcessSuffixEnumType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      WeldingProcessSuffixEnumType&
      operator= (const WeldingProcessSuffixEnumType&) = default;
#endif

      virtual WeldingProcessSuffixEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldingProcessSuffixEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_WeldingProcessSuffixEnumType_convert ();
      }

      protected:
      value
      _xsd_WeldingProcessSuffixEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_WeldingProcessSuffixEnumType_literals_[4];
      static const value _xsd_WeldingProcessSuffixEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL WeldingProcessType: public ::xml_schema::type
    {
      public:
      // Process
      //
      typedef ::xsd::qif30::WeldingProcessEnumType Process_type;
      typedef ::xsd::cxx::tree::traits< Process_type, wchar_t > Process_traits;

      const Process_type&
      Process () const;

      Process_type&
      Process ();

      void
      Process (const Process_type& x);

      void
      Process (::std::unique_ptr< Process_type > p);

      // Suffix
      //
      typedef ::xsd::qif30::WeldingProcessSuffixEnumType Suffix_type;
      typedef ::xsd::cxx::tree::optional< Suffix_type > Suffix_optional;
      typedef ::xsd::cxx::tree::traits< Suffix_type, wchar_t > Suffix_traits;

      const Suffix_optional&
      Suffix () const;

      Suffix_optional&
      Suffix ();

      void
      Suffix (const Suffix_type& x);

      void
      Suffix (const Suffix_optional& x);

      void
      Suffix (::std::unique_ptr< Suffix_type > p);

      // Constructors.
      //
      WeldingProcessType ();

      WeldingProcessType (const Process_type&);

      WeldingProcessType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      WeldingProcessType (const WeldingProcessType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual WeldingProcessType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldingProcessType&
      operator= (const WeldingProcessType& x);

      virtual 
      ~WeldingProcessType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Process_type > Process_;
      Suffix_optional Suffix_;
    };

    class QIF30_SYMBOL_DECL ArrayNonDestructiveTestingType: public ::xml_schema::type
    {
      public:
      // TypeOfTest
      //
      typedef ::xsd::qif30::NonDestructiveTestingEnumType TypeOfTest_type;
      typedef ::xsd::cxx::tree::sequence< TypeOfTest_type > TypeOfTest_sequence;
      typedef xsd::cxx::tree::sequence< TypeOfTest_type >::iterator TypeOfTest_iterator;
      typedef xsd::cxx::tree::sequence< TypeOfTest_type >::const_iterator TypeOfTest_const_iterator;
      typedef ::xsd::cxx::tree::traits< TypeOfTest_type, wchar_t > TypeOfTest_traits;

      const TypeOfTest_sequence&
      TypeOfTest () const;

      TypeOfTest_sequence&
      TypeOfTest ();

      void
      TypeOfTest (const TypeOfTest_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArrayNonDestructiveTestingType ();

      ArrayNonDestructiveTestingType (const n_type&);

      ArrayNonDestructiveTestingType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ArrayNonDestructiveTestingType (const ArrayNonDestructiveTestingType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ArrayNonDestructiveTestingType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayNonDestructiveTestingType&
      operator= (const ArrayNonDestructiveTestingType& x);

      virtual 
      ~ArrayNonDestructiveTestingType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TypeOfTest_sequence TypeOfTest_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL WeldCharacteristicNominalBaseType: public ::xsd::qif30::CharacteristicNominalBaseType
    {
      public:
      // AllAround
      //
      typedef ::xml_schema::boolean AllAround_type;
      typedef ::xsd::cxx::tree::optional< AllAround_type > AllAround_optional;
      typedef ::xsd::cxx::tree::traits< AllAround_type, wchar_t > AllAround_traits;

      const AllAround_optional&
      AllAround () const;

      AllAround_optional&
      AllAround ();

      void
      AllAround (const AllAround_type& x);

      void
      AllAround (const AllAround_optional& x);

      // Field
      //
      typedef ::xml_schema::boolean Field_type;
      typedef ::xsd::cxx::tree::optional< Field_type > Field_optional;
      typedef ::xsd::cxx::tree::traits< Field_type, wchar_t > Field_traits;

      const Field_optional&
      Field () const;

      Field_optional&
      Field ();

      void
      Field (const Field_type& x);

      void
      Field (const Field_optional& x);

      // Specification
      //
      typedef ::xml_schema::token Specification_type;
      typedef ::xsd::cxx::tree::optional< Specification_type > Specification_optional;
      typedef ::xsd::cxx::tree::traits< Specification_type, wchar_t > Specification_traits;

      const Specification_optional&
      Specification () const;

      Specification_optional&
      Specification ();

      void
      Specification (const Specification_type& x);

      void
      Specification (const Specification_optional& x);

      void
      Specification (::std::unique_ptr< Specification_type > p);

      // WeldingProcess
      //
      typedef ::xsd::qif30::WeldingProcessType WeldingProcess_type;
      typedef ::xsd::cxx::tree::optional< WeldingProcess_type > WeldingProcess_optional;
      typedef ::xsd::cxx::tree::traits< WeldingProcess_type, wchar_t > WeldingProcess_traits;

      const WeldingProcess_optional&
      WeldingProcess () const;

      WeldingProcess_optional&
      WeldingProcess ();

      void
      WeldingProcess (const WeldingProcess_type& x);

      void
      WeldingProcess (const WeldingProcess_optional& x);

      void
      WeldingProcess (::std::unique_ptr< WeldingProcess_type > p);

      // NonDestructiveTesting
      //
      typedef ::xsd::qif30::ArrayNonDestructiveTestingType NonDestructiveTesting_type;
      typedef ::xsd::cxx::tree::optional< NonDestructiveTesting_type > NonDestructiveTesting_optional;
      typedef ::xsd::cxx::tree::traits< NonDestructiveTesting_type, wchar_t > NonDestructiveTesting_traits;

      const NonDestructiveTesting_optional&
      NonDestructiveTesting () const;

      NonDestructiveTesting_optional&
      NonDestructiveTesting ();

      void
      NonDestructiveTesting (const NonDestructiveTesting_type& x);

      void
      NonDestructiveTesting (const NonDestructiveTesting_optional& x);

      void
      NonDestructiveTesting (::std::unique_ptr< NonDestructiveTesting_type > p);

      // Constructors.
      //
      WeldCharacteristicNominalBaseType ();

      WeldCharacteristicNominalBaseType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      WeldCharacteristicNominalBaseType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldCharacteristicNominalBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldCharacteristicNominalBaseType (const WeldCharacteristicNominalBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldCharacteristicNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      WeldCharacteristicNominalBaseType&
      operator= (const WeldCharacteristicNominalBaseType& x);

      virtual 
      ~WeldCharacteristicNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AllAround_optional AllAround_;
      Field_optional Field_;
      Specification_optional Specification_;
      WeldingProcess_optional WeldingProcess_;
      NonDestructiveTesting_optional NonDestructiveTesting_;
    };

    class QIF30_SYMBOL_DECL WeldCharacteristicDefinitionBaseType: public ::xsd::qif30::CharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldCharacteristicDefinitionBaseType ();

      WeldCharacteristicDefinitionBaseType (const id_type&);

      WeldCharacteristicDefinitionBaseType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldCharacteristicDefinitionBaseType (const WeldCharacteristicDefinitionBaseType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldCharacteristicDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      WeldCharacteristicDefinitionBaseType&
      operator= (const WeldCharacteristicDefinitionBaseType&) = default;
#endif

      virtual 
      ~WeldCharacteristicDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL WeldCharacteristicMeasurementBaseType: public ::xsd::qif30::CharacteristicMeasurementBaseType
    {
      public:
      // Constructors.
      //
      WeldCharacteristicMeasurementBaseType ();

      WeldCharacteristicMeasurementBaseType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      WeldCharacteristicMeasurementBaseType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      WeldCharacteristicMeasurementBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldCharacteristicMeasurementBaseType (const WeldCharacteristicMeasurementBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldCharacteristicMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      WeldCharacteristicMeasurementBaseType&
      operator= (const WeldCharacteristicMeasurementBaseType&) = default;
#endif

      virtual 
      ~WeldCharacteristicMeasurementBaseType ();
    };

    class QIF30_SYMBOL_DECL WeldFilletCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceAllEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // BothSides
      //
      typedef ::xsd::qif30::WeldFilletBothSidesType BothSides_type;
      typedef ::xsd::cxx::tree::optional< BothSides_type > BothSides_optional;
      typedef ::xsd::cxx::tree::traits< BothSides_type, wchar_t > BothSides_traits;

      const BothSides_optional&
      BothSides () const;

      BothSides_optional&
      BothSides ();

      void
      BothSides (const BothSides_type& x);

      void
      BothSides (const BothSides_optional& x);

      void
      BothSides (::std::unique_ptr< BothSides_type > p);

      // OneSide
      //
      typedef ::xsd::qif30::WeldFilletOneSideType OneSide_type;
      typedef ::xsd::cxx::tree::optional< OneSide_type > OneSide_optional;
      typedef ::xsd::cxx::tree::traits< OneSide_type, wchar_t > OneSide_traits;

      const OneSide_optional&
      OneSide () const;

      OneSide_optional&
      OneSide ();

      void
      OneSide (const OneSide_type& x);

      void
      OneSide (const OneSide_optional& x);

      void
      OneSide (::std::unique_ptr< OneSide_type > p);

      // Constructors.
      //
      WeldFilletCharacteristicMeasurementType ();

      WeldFilletCharacteristicMeasurementType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&,
                                               const LocationSignificance_type&);

      WeldFilletCharacteristicMeasurementType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >,
                                               const LocationSignificance_type&);

      WeldFilletCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      WeldFilletCharacteristicMeasurementType (const WeldFilletCharacteristicMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual WeldFilletCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFilletCharacteristicMeasurementType&
      operator= (const WeldFilletCharacteristicMeasurementType& x);

      virtual 
      ~WeldFilletCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      BothSides_optional BothSides_;
      OneSide_optional OneSide_;
    };

    class QIF30_SYMBOL_DECL WeldPlugCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceOneSidesEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldPlugOneSideParametersType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Constructors.
      //
      WeldPlugCharacteristicMeasurementType ();

      WeldPlugCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&,
                                             const LocationSignificance_type&);

      WeldPlugCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >,
                                             const LocationSignificance_type&);

      WeldPlugCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldPlugCharacteristicMeasurementType (const WeldPlugCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldPlugCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldPlugCharacteristicMeasurementType&
      operator= (const WeldPlugCharacteristicMeasurementType& x);

      virtual 
      ~WeldPlugCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldSlotCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceOneSidesEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldPlugOneSideParametersType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Constructors.
      //
      WeldSlotCharacteristicMeasurementType ();

      WeldSlotCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&,
                                             const LocationSignificance_type&);

      WeldSlotCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >,
                                             const LocationSignificance_type&);

      WeldSlotCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldSlotCharacteristicMeasurementType (const WeldSlotCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldSlotCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSlotCharacteristicMeasurementType&
      operator= (const WeldSlotCharacteristicMeasurementType& x);

      virtual 
      ~WeldSlotCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldSpotCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceSpotSeamEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldSpotOneSideParametersType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Projection
      //
      typedef ::xml_schema::boolean Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      // Constructors.
      //
      WeldSpotCharacteristicMeasurementType ();

      WeldSpotCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&,
                                             const LocationSignificance_type&);

      WeldSpotCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >,
                                             const LocationSignificance_type&);

      WeldSpotCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldSpotCharacteristicMeasurementType (const WeldSpotCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldSpotCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSpotCharacteristicMeasurementType&
      operator= (const WeldSpotCharacteristicMeasurementType& x);

      virtual 
      ~WeldSpotCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
      Projection_optional Projection_;
    };

    class QIF30_SYMBOL_DECL WeldStudCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // ArrowSideParameters
      //
      typedef ::xsd::qif30::WeldOneSideParametersExtendType ArrowSideParameters_type;
      typedef ::xsd::cxx::tree::optional< ArrowSideParameters_type > ArrowSideParameters_optional;
      typedef ::xsd::cxx::tree::traits< ArrowSideParameters_type, wchar_t > ArrowSideParameters_traits;

      const ArrowSideParameters_optional&
      ArrowSideParameters () const;

      ArrowSideParameters_optional&
      ArrowSideParameters ();

      void
      ArrowSideParameters (const ArrowSideParameters_type& x);

      void
      ArrowSideParameters (const ArrowSideParameters_optional& x);

      void
      ArrowSideParameters (::std::unique_ptr< ArrowSideParameters_type > p);

      // Constructors.
      //
      WeldStudCharacteristicMeasurementType ();

      WeldStudCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&);

      WeldStudCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >);

      WeldStudCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldStudCharacteristicMeasurementType (const WeldStudCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldStudCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldStudCharacteristicMeasurementType&
      operator= (const WeldStudCharacteristicMeasurementType& x);

      virtual 
      ~WeldStudCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ArrowSideParameters_optional ArrowSideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldSeamCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceSpotSeamEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldOneSideParametersExtendType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Constructors.
      //
      WeldSeamCharacteristicMeasurementType ();

      WeldSeamCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&,
                                             const LocationSignificance_type&);

      WeldSeamCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >,
                                             const LocationSignificance_type&);

      WeldSeamCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldSeamCharacteristicMeasurementType (const WeldSeamCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldSeamCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSeamCharacteristicMeasurementType&
      operator= (const WeldSeamCharacteristicMeasurementType& x);

      virtual 
      ~WeldSeamCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldSurfacingCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // ArrowSideParameters
      //
      typedef ::xsd::qif30::WeldOneSideParametersExtendSizeType ArrowSideParameters_type;
      typedef ::xsd::cxx::tree::optional< ArrowSideParameters_type > ArrowSideParameters_optional;
      typedef ::xsd::cxx::tree::traits< ArrowSideParameters_type, wchar_t > ArrowSideParameters_traits;

      const ArrowSideParameters_optional&
      ArrowSideParameters () const;

      ArrowSideParameters_optional&
      ArrowSideParameters ();

      void
      ArrowSideParameters (const ArrowSideParameters_type& x);

      void
      ArrowSideParameters (const ArrowSideParameters_optional& x);

      void
      ArrowSideParameters (::std::unique_ptr< ArrowSideParameters_type > p);

      // Constructors.
      //
      WeldSurfacingCharacteristicMeasurementType ();

      WeldSurfacingCharacteristicMeasurementType (const id_type&,
                                                  const Status_type&,
                                                  const CharacteristicItemId_type&);

      WeldSurfacingCharacteristicMeasurementType (const id_type&,
                                                  ::std::unique_ptr< Status_type >,
                                                  ::std::unique_ptr< CharacteristicItemId_type >);

      WeldSurfacingCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      WeldSurfacingCharacteristicMeasurementType (const WeldSurfacingCharacteristicMeasurementType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual WeldSurfacingCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSurfacingCharacteristicMeasurementType&
      operator= (const WeldSurfacingCharacteristicMeasurementType& x);

      virtual 
      ~WeldSurfacingCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ArrowSideParameters_optional ArrowSideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldEdgeCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceOneSidesEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldOneSideParametersExtendSizeType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Constructors.
      //
      WeldEdgeCharacteristicMeasurementType ();

      WeldEdgeCharacteristicMeasurementType (const id_type&,
                                             const Status_type&,
                                             const CharacteristicItemId_type&,
                                             const LocationSignificance_type&);

      WeldEdgeCharacteristicMeasurementType (const id_type&,
                                             ::std::unique_ptr< Status_type >,
                                             ::std::unique_ptr< CharacteristicItemId_type >,
                                             const LocationSignificance_type&);

      WeldEdgeCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldEdgeCharacteristicMeasurementType (const WeldEdgeCharacteristicMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldEdgeCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldEdgeCharacteristicMeasurementType&
      operator= (const WeldEdgeCharacteristicMeasurementType& x);

      virtual 
      ~WeldEdgeCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldGrooveCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // OneSide
      //
      typedef ::xsd::qif30::WeldGrooveOneSideType OneSide_type;
      typedef ::xsd::cxx::tree::optional< OneSide_type > OneSide_optional;
      typedef ::xsd::cxx::tree::traits< OneSide_type, wchar_t > OneSide_traits;

      const OneSide_optional&
      OneSide () const;

      OneSide_optional&
      OneSide ();

      void
      OneSide (const OneSide_type& x);

      void
      OneSide (const OneSide_optional& x);

      void
      OneSide (::std::unique_ptr< OneSide_type > p);

      // BothSides
      //
      typedef ::xsd::qif30::WeldGrooveBothSidesExtendedType BothSides_type;
      typedef ::xsd::cxx::tree::optional< BothSides_type > BothSides_optional;
      typedef ::xsd::cxx::tree::traits< BothSides_type, wchar_t > BothSides_traits;

      const BothSides_optional&
      BothSides () const;

      BothSides_optional&
      BothSides ();

      void
      BothSides (const BothSides_type& x);

      void
      BothSides (const BothSides_optional& x);

      void
      BothSides (::std::unique_ptr< BothSides_type > p);

      // Constructors.
      //
      WeldGrooveCharacteristicMeasurementType ();

      WeldGrooveCharacteristicMeasurementType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&);

      WeldGrooveCharacteristicMeasurementType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >);

      WeldGrooveCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      WeldGrooveCharacteristicMeasurementType (const WeldGrooveCharacteristicMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual WeldGrooveCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldGrooveCharacteristicMeasurementType&
      operator= (const WeldGrooveCharacteristicMeasurementType& x);

      virtual 
      ~WeldGrooveCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      OneSide_optional OneSide_;
      BothSides_optional BothSides_;
    };

    class QIF30_SYMBOL_DECL WeldSquareCharacteristicMeasurementType: public ::xsd::qif30::WeldGrooveCharacteristicMeasurementType
    {
      public:
      // Constructors.
      //
      WeldSquareCharacteristicMeasurementType ();

      WeldSquareCharacteristicMeasurementType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&);

      WeldSquareCharacteristicMeasurementType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >);

      WeldSquareCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      WeldSquareCharacteristicMeasurementType (const WeldSquareCharacteristicMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual WeldSquareCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSquareCharacteristicMeasurementType&
      operator= (const WeldSquareCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WeldSquareCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WeldBevelCharacteristicMeasurementType: public ::xsd::qif30::WeldGrooveCharacteristicMeasurementType
    {
      public:
      // Constructors.
      //
      WeldBevelCharacteristicMeasurementType ();

      WeldBevelCharacteristicMeasurementType (const id_type&,
                                              const Status_type&,
                                              const CharacteristicItemId_type&);

      WeldBevelCharacteristicMeasurementType (const id_type&,
                                              ::std::unique_ptr< Status_type >,
                                              ::std::unique_ptr< CharacteristicItemId_type >);

      WeldBevelCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      WeldBevelCharacteristicMeasurementType (const WeldBevelCharacteristicMeasurementType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual WeldBevelCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldBevelCharacteristicMeasurementType&
      operator= (const WeldBevelCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WeldBevelCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WeldVCharacteristicMeasurementType: public ::xsd::qif30::WeldGrooveCharacteristicMeasurementType
    {
      public:
      // Constructors.
      //
      WeldVCharacteristicMeasurementType ();

      WeldVCharacteristicMeasurementType (const id_type&,
                                          const Status_type&,
                                          const CharacteristicItemId_type&);

      WeldVCharacteristicMeasurementType (const id_type&,
                                          ::std::unique_ptr< Status_type >,
                                          ::std::unique_ptr< CharacteristicItemId_type >);

      WeldVCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      WeldVCharacteristicMeasurementType (const WeldVCharacteristicMeasurementType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual WeldVCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldVCharacteristicMeasurementType&
      operator= (const WeldVCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WeldVCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WeldUCharacteristicMeasurementType: public ::xsd::qif30::WeldGrooveCharacteristicMeasurementType
    {
      public:
      // Constructors.
      //
      WeldUCharacteristicMeasurementType ();

      WeldUCharacteristicMeasurementType (const id_type&,
                                          const Status_type&,
                                          const CharacteristicItemId_type&);

      WeldUCharacteristicMeasurementType (const id_type&,
                                          ::std::unique_ptr< Status_type >,
                                          ::std::unique_ptr< CharacteristicItemId_type >);

      WeldUCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      WeldUCharacteristicMeasurementType (const WeldUCharacteristicMeasurementType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual WeldUCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldUCharacteristicMeasurementType&
      operator= (const WeldUCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WeldUCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WeldJCharacteristicMeasurementType: public ::xsd::qif30::WeldGrooveCharacteristicMeasurementType
    {
      public:
      // Constructors.
      //
      WeldJCharacteristicMeasurementType ();

      WeldJCharacteristicMeasurementType (const id_type&,
                                          const Status_type&,
                                          const CharacteristicItemId_type&);

      WeldJCharacteristicMeasurementType (const id_type&,
                                          ::std::unique_ptr< Status_type >,
                                          ::std::unique_ptr< CharacteristicItemId_type >);

      WeldJCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      WeldJCharacteristicMeasurementType (const WeldJCharacteristicMeasurementType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual WeldJCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldJCharacteristicMeasurementType&
      operator= (const WeldJCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WeldJCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareVCharacteristicMeasurementType: public ::xsd::qif30::WeldGrooveCharacteristicMeasurementType
    {
      public:
      // Constructors.
      //
      WeldFlareVCharacteristicMeasurementType ();

      WeldFlareVCharacteristicMeasurementType (const id_type&,
                                               const Status_type&,
                                               const CharacteristicItemId_type&);

      WeldFlareVCharacteristicMeasurementType (const id_type&,
                                               ::std::unique_ptr< Status_type >,
                                               ::std::unique_ptr< CharacteristicItemId_type >);

      WeldFlareVCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      WeldFlareVCharacteristicMeasurementType (const WeldFlareVCharacteristicMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual WeldFlareVCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareVCharacteristicMeasurementType&
      operator= (const WeldFlareVCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WeldFlareVCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareBevelCharacteristicMeasurementType: public ::xsd::qif30::WeldGrooveCharacteristicMeasurementType
    {
      public:
      // Constructors.
      //
      WeldFlareBevelCharacteristicMeasurementType ();

      WeldFlareBevelCharacteristicMeasurementType (const id_type&,
                                                   const Status_type&,
                                                   const CharacteristicItemId_type&);

      WeldFlareBevelCharacteristicMeasurementType (const id_type&,
                                                   ::std::unique_ptr< Status_type >,
                                                   ::std::unique_ptr< CharacteristicItemId_type >);

      WeldFlareBevelCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      WeldFlareBevelCharacteristicMeasurementType (const WeldFlareBevelCharacteristicMeasurementType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual WeldFlareBevelCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareBevelCharacteristicMeasurementType&
      operator= (const WeldFlareBevelCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WeldFlareBevelCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WeldScarfCharacteristicMeasurementType: public ::xsd::qif30::WeldGrooveCharacteristicMeasurementType
    {
      public:
      // Constructors.
      //
      WeldScarfCharacteristicMeasurementType ();

      WeldScarfCharacteristicMeasurementType (const id_type&,
                                              const Status_type&,
                                              const CharacteristicItemId_type&);

      WeldScarfCharacteristicMeasurementType (const id_type&,
                                              ::std::unique_ptr< Status_type >,
                                              ::std::unique_ptr< CharacteristicItemId_type >);

      WeldScarfCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      WeldScarfCharacteristicMeasurementType (const WeldScarfCharacteristicMeasurementType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual WeldScarfCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldScarfCharacteristicMeasurementType&
      operator= (const WeldScarfCharacteristicMeasurementType&) = default;
#endif

      virtual 
      ~WeldScarfCharacteristicMeasurementType ();
    };

    class QIF30_SYMBOL_DECL WeldCompoundCharacteristicMeasurementType: public ::xsd::qif30::WeldCharacteristicMeasurementBaseType
    {
      public:
      // WeldCharacteristicMeasurementIds
      //
      typedef ::xsd::qif30::ArrayReferenceType WeldCharacteristicMeasurementIds_type;
      typedef ::xsd::cxx::tree::traits< WeldCharacteristicMeasurementIds_type, wchar_t > WeldCharacteristicMeasurementIds_traits;

      const WeldCharacteristicMeasurementIds_type&
      WeldCharacteristicMeasurementIds () const;

      WeldCharacteristicMeasurementIds_type&
      WeldCharacteristicMeasurementIds ();

      void
      WeldCharacteristicMeasurementIds (const WeldCharacteristicMeasurementIds_type& x);

      void
      WeldCharacteristicMeasurementIds (::std::unique_ptr< WeldCharacteristicMeasurementIds_type > p);

      // Constructors.
      //
      WeldCompoundCharacteristicMeasurementType ();

      WeldCompoundCharacteristicMeasurementType (const id_type&,
                                                 const Status_type&,
                                                 const CharacteristicItemId_type&,
                                                 const WeldCharacteristicMeasurementIds_type&);

      WeldCompoundCharacteristicMeasurementType (const id_type&,
                                                 ::std::unique_ptr< Status_type >,
                                                 ::std::unique_ptr< CharacteristicItemId_type >,
                                                 ::std::unique_ptr< WeldCharacteristicMeasurementIds_type >);

      WeldCompoundCharacteristicMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      WeldCompoundCharacteristicMeasurementType (const WeldCompoundCharacteristicMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual WeldCompoundCharacteristicMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldCompoundCharacteristicMeasurementType&
      operator= (const WeldCompoundCharacteristicMeasurementType& x);

      virtual 
      ~WeldCompoundCharacteristicMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WeldCharacteristicMeasurementIds_type > WeldCharacteristicMeasurementIds_;
    };

    class QIF30_SYMBOL_DECL WeldCharacteristicItemBaseType: public ::xsd::qif30::CharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldCharacteristicItemBaseType ();

      WeldCharacteristicItemBaseType (const id_type&,
                                      const CharacteristicNominalId_type&);

      WeldCharacteristicItemBaseType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldCharacteristicItemBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldCharacteristicItemBaseType (const WeldCharacteristicItemBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldCharacteristicItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      WeldCharacteristicItemBaseType&
      operator= (const WeldCharacteristicItemBaseType&) = default;
#endif

      virtual 
      ~WeldCharacteristicItemBaseType ();
    };

    class QIF30_SYMBOL_DECL WeldGrooveCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // OneSide
      //
      typedef ::xsd::qif30::WeldGrooveOneSideType OneSide_type;
      typedef ::xsd::cxx::tree::optional< OneSide_type > OneSide_optional;
      typedef ::xsd::cxx::tree::traits< OneSide_type, wchar_t > OneSide_traits;

      const OneSide_optional&
      OneSide () const;

      OneSide_optional&
      OneSide ();

      void
      OneSide (const OneSide_type& x);

      void
      OneSide (const OneSide_optional& x);

      void
      OneSide (::std::unique_ptr< OneSide_type > p);

      // BothSides
      //
      typedef ::xsd::qif30::WeldGrooveBothSidesExtendedType BothSides_type;
      typedef ::xsd::cxx::tree::optional< BothSides_type > BothSides_optional;
      typedef ::xsd::cxx::tree::traits< BothSides_type, wchar_t > BothSides_traits;

      const BothSides_optional&
      BothSides () const;

      BothSides_optional&
      BothSides ();

      void
      BothSides (const BothSides_type& x);

      void
      BothSides (const BothSides_optional& x);

      void
      BothSides (::std::unique_ptr< BothSides_type > p);

      // Constructors.
      //
      WeldGrooveCharacteristicNominalType ();

      WeldGrooveCharacteristicNominalType (const id_type&,
                                           const CharacteristicDefinitionId_type&);

      WeldGrooveCharacteristicNominalType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldGrooveCharacteristicNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldGrooveCharacteristicNominalType (const WeldGrooveCharacteristicNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldGrooveCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldGrooveCharacteristicNominalType&
      operator= (const WeldGrooveCharacteristicNominalType& x);

      virtual 
      ~WeldGrooveCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      OneSide_optional OneSide_;
      BothSides_optional BothSides_;
    };

    class QIF30_SYMBOL_DECL WeldFinishingType: public ::xml_schema::type
    {
      public:
      // ContourSymbol
      //
      typedef ::xsd::qif30::WeldContourSymbolEnumType ContourSymbol_type;
      typedef ::xsd::cxx::tree::traits< ContourSymbol_type, wchar_t > ContourSymbol_traits;

      const ContourSymbol_type&
      ContourSymbol () const;

      ContourSymbol_type&
      ContourSymbol ();

      void
      ContourSymbol (const ContourSymbol_type& x);

      void
      ContourSymbol (::std::unique_ptr< ContourSymbol_type > p);

      // FinishingDesignator
      //
      typedef ::xsd::qif30::WeldFinishingDesignatorEnumType FinishingDesignator_type;
      typedef ::xsd::cxx::tree::optional< FinishingDesignator_type > FinishingDesignator_optional;
      typedef ::xsd::cxx::tree::traits< FinishingDesignator_type, wchar_t > FinishingDesignator_traits;

      const FinishingDesignator_optional&
      FinishingDesignator () const;

      FinishingDesignator_optional&
      FinishingDesignator ();

      void
      FinishingDesignator (const FinishingDesignator_type& x);

      void
      FinishingDesignator (const FinishingDesignator_optional& x);

      void
      FinishingDesignator (::std::unique_ptr< FinishingDesignator_type > p);

      // Constructors.
      //
      WeldFinishingType ();

      WeldFinishingType (const ContourSymbol_type&);

      WeldFinishingType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      WeldFinishingType (const WeldFinishingType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual WeldFinishingType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFinishingType&
      operator= (const WeldFinishingType& x);

      virtual 
      ~WeldFinishingType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ContourSymbol_type > ContourSymbol_;
      FinishingDesignator_optional FinishingDesignator_;
    };

    class QIF30_SYMBOL_DECL WeldOneSideParametersBaseType: public ::xml_schema::type
    {
      public:
      // Finishing
      //
      typedef ::xsd::qif30::WeldFinishingType Finishing_type;
      typedef ::xsd::cxx::tree::optional< Finishing_type > Finishing_optional;
      typedef ::xsd::cxx::tree::traits< Finishing_type, wchar_t > Finishing_traits;

      const Finishing_optional&
      Finishing () const;

      Finishing_optional&
      Finishing ();

      void
      Finishing (const Finishing_type& x);

      void
      Finishing (const Finishing_optional& x);

      void
      Finishing (::std::unique_ptr< Finishing_type > p);

      // Constructors.
      //
      WeldOneSideParametersBaseType ();

      WeldOneSideParametersBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      WeldOneSideParametersBaseType (const WeldOneSideParametersBaseType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual WeldOneSideParametersBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldOneSideParametersBaseType&
      operator= (const WeldOneSideParametersBaseType& x);

      virtual 
      ~WeldOneSideParametersBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Finishing_optional Finishing_;
    };

    class QIF30_SYMBOL_DECL WeldOneSideParametersExtendSizeType: public ::xsd::qif30::WeldOneSideParametersBaseType
    {
      public:
      // Size
      //
      typedef ::xsd::qif30::FractionType Size_type;
      typedef ::xsd::cxx::tree::optional< Size_type > Size_optional;
      typedef ::xsd::cxx::tree::traits< Size_type, wchar_t > Size_traits;

      const Size_optional&
      Size () const;

      Size_optional&
      Size ();

      void
      Size (const Size_type& x);

      void
      Size (const Size_optional& x);

      void
      Size (::std::unique_ptr< Size_type > p);

      // Constructors.
      //
      WeldOneSideParametersExtendSizeType ();

      WeldOneSideParametersExtendSizeType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldOneSideParametersExtendSizeType (const WeldOneSideParametersExtendSizeType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldOneSideParametersExtendSizeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldOneSideParametersExtendSizeType&
      operator= (const WeldOneSideParametersExtendSizeType& x);

      virtual 
      ~WeldOneSideParametersExtendSizeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Size_optional Size_;
    };

    class QIF30_SYMBOL_DECL WeldOneSideParametersExtendType: public ::xsd::qif30::WeldOneSideParametersExtendSizeType
    {
      public:
      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Pitch
      //
      typedef ::xsd::qif30::LinearValueType Pitch_type;
      typedef ::xsd::cxx::tree::optional< Pitch_type > Pitch_optional;
      typedef ::xsd::cxx::tree::traits< Pitch_type, wchar_t > Pitch_traits;

      const Pitch_optional&
      Pitch () const;

      Pitch_optional&
      Pitch ();

      void
      Pitch (const Pitch_type& x);

      void
      Pitch (const Pitch_optional& x);

      void
      Pitch (::std::unique_ptr< Pitch_type > p);

      // WeldNumber
      //
      typedef ::xsd::qif30::NaturalType WeldNumber_type;
      typedef ::xsd::cxx::tree::optional< WeldNumber_type > WeldNumber_optional;
      typedef ::xsd::cxx::tree::traits< WeldNumber_type, wchar_t > WeldNumber_traits;

      const WeldNumber_optional&
      WeldNumber () const;

      WeldNumber_optional&
      WeldNumber ();

      void
      WeldNumber (const WeldNumber_type& x);

      void
      WeldNumber (const WeldNumber_optional& x);

      void
      WeldNumber (::std::unique_ptr< WeldNumber_type > p);

      // Constructors.
      //
      WeldOneSideParametersExtendType ();

      WeldOneSideParametersExtendType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldOneSideParametersExtendType (const WeldOneSideParametersExtendType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual WeldOneSideParametersExtendType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldOneSideParametersExtendType&
      operator= (const WeldOneSideParametersExtendType& x);

      virtual 
      ~WeldOneSideParametersExtendType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Length_optional Length_;
      Pitch_optional Pitch_;
      WeldNumber_optional WeldNumber_;
    };

    class QIF30_SYMBOL_DECL WeldGrooveOneSideParametersType: public ::xsd::qif30::WeldOneSideParametersExtendSizeType
    {
      public:
      // Groove
      //
      typedef ::xsd::qif30::FractionType Groove_type;
      typedef ::xsd::cxx::tree::optional< Groove_type > Groove_optional;
      typedef ::xsd::cxx::tree::traits< Groove_type, wchar_t > Groove_traits;

      const Groove_optional&
      Groove () const;

      Groove_optional&
      Groove ();

      void
      Groove (const Groove_type& x);

      void
      Groove (const Groove_optional& x);

      void
      Groove (::std::unique_ptr< Groove_type > p);

      // Angle
      //
      typedef ::xsd::qif30::AngularValueType Angle_type;
      typedef ::xsd::cxx::tree::optional< Angle_type > Angle_optional;
      typedef ::xsd::cxx::tree::traits< Angle_type, wchar_t > Angle_traits;

      const Angle_optional&
      Angle () const;

      Angle_optional&
      Angle ();

      void
      Angle (const Angle_type& x);

      void
      Angle (const Angle_optional& x);

      void
      Angle (::std::unique_ptr< Angle_type > p);

      // RootOpening
      //
      typedef ::xsd::qif30::FractionType RootOpening_type;
      typedef ::xsd::cxx::tree::optional< RootOpening_type > RootOpening_optional;
      typedef ::xsd::cxx::tree::traits< RootOpening_type, wchar_t > RootOpening_traits;

      const RootOpening_optional&
      RootOpening () const;

      RootOpening_optional&
      RootOpening ();

      void
      RootOpening (const RootOpening_type& x);

      void
      RootOpening (const RootOpening_optional& x);

      void
      RootOpening (::std::unique_ptr< RootOpening_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Pitch
      //
      typedef ::xsd::qif30::LinearValueType Pitch_type;
      typedef ::xsd::cxx::tree::optional< Pitch_type > Pitch_optional;
      typedef ::xsd::cxx::tree::traits< Pitch_type, wchar_t > Pitch_traits;

      const Pitch_optional&
      Pitch () const;

      Pitch_optional&
      Pitch ();

      void
      Pitch (const Pitch_type& x);

      void
      Pitch (const Pitch_optional& x);

      void
      Pitch (::std::unique_ptr< Pitch_type > p);

      // Constructors.
      //
      WeldGrooveOneSideParametersType ();

      WeldGrooveOneSideParametersType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldGrooveOneSideParametersType (const WeldGrooveOneSideParametersType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual WeldGrooveOneSideParametersType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldGrooveOneSideParametersType&
      operator= (const WeldGrooveOneSideParametersType& x);

      virtual 
      ~WeldGrooveOneSideParametersType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Groove_optional Groove_;
      Angle_optional Angle_;
      RootOpening_optional RootOpening_;
      Length_optional Length_;
      Pitch_optional Pitch_;
    };

    class QIF30_SYMBOL_DECL WeldSupplementarySymbolEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        BACK_WELD,
        MELT_THROUGH,
        CONSUMABLE_INSERT,
        REMOVABLE_BACKING
      };

      WeldSupplementarySymbolEnumType ();

      WeldSupplementarySymbolEnumType (value v);

      WeldSupplementarySymbolEnumType (const wchar_t* v);

      WeldSupplementarySymbolEnumType (const ::std::wstring& v);

      WeldSupplementarySymbolEnumType (const ::xml_schema::string& v);

      WeldSupplementarySymbolEnumType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldSupplementarySymbolEnumType (const xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldSupplementarySymbolEnumType (const ::std::wstring& s,
                                       const xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldSupplementarySymbolEnumType (const WeldSupplementarySymbolEnumType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      WeldSupplementarySymbolEnumType&
      operator= (const WeldSupplementarySymbolEnumType&) = default;
#endif

      virtual WeldSupplementarySymbolEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSupplementarySymbolEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_WeldSupplementarySymbolEnumType_convert ();
      }

      protected:
      value
      _xsd_WeldSupplementarySymbolEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_WeldSupplementarySymbolEnumType_literals_[4];
      static const value _xsd_WeldSupplementarySymbolEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL WeldGrooveOneSideType: public ::xml_schema::type
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceOneSidesEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldGrooveOneSideParametersType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // SupplementarySymbol
      //
      typedef ::xsd::qif30::WeldSupplementarySymbolEnumType SupplementarySymbol_type;
      typedef ::xsd::cxx::tree::optional< SupplementarySymbol_type > SupplementarySymbol_optional;
      typedef ::xsd::cxx::tree::traits< SupplementarySymbol_type, wchar_t > SupplementarySymbol_traits;

      const SupplementarySymbol_optional&
      SupplementarySymbol () const;

      SupplementarySymbol_optional&
      SupplementarySymbol ();

      void
      SupplementarySymbol (const SupplementarySymbol_type& x);

      void
      SupplementarySymbol (const SupplementarySymbol_optional& x);

      void
      SupplementarySymbol (::std::unique_ptr< SupplementarySymbol_type > p);

      // Constructors.
      //
      WeldGrooveOneSideType ();

      WeldGrooveOneSideType (const LocationSignificance_type&);

      WeldGrooveOneSideType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      WeldGrooveOneSideType (const WeldGrooveOneSideType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual WeldGrooveOneSideType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldGrooveOneSideType&
      operator= (const WeldGrooveOneSideType& x);

      virtual 
      ~WeldGrooveOneSideType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
      SupplementarySymbol_optional SupplementarySymbol_;
    };

    class QIF30_SYMBOL_DECL WeldGrooveBothSidesBaseType: public ::xml_schema::type
    {
      public:
      // ArrowSideParameters
      //
      typedef ::xsd::qif30::WeldGrooveOneSideParametersType ArrowSideParameters_type;
      typedef ::xsd::cxx::tree::optional< ArrowSideParameters_type > ArrowSideParameters_optional;
      typedef ::xsd::cxx::tree::traits< ArrowSideParameters_type, wchar_t > ArrowSideParameters_traits;

      const ArrowSideParameters_optional&
      ArrowSideParameters () const;

      ArrowSideParameters_optional&
      ArrowSideParameters ();

      void
      ArrowSideParameters (const ArrowSideParameters_type& x);

      void
      ArrowSideParameters (const ArrowSideParameters_optional& x);

      void
      ArrowSideParameters (::std::unique_ptr< ArrowSideParameters_type > p);

      // OtherSideParameters
      //
      typedef ::xsd::qif30::WeldGrooveOneSideParametersType OtherSideParameters_type;
      typedef ::xsd::cxx::tree::optional< OtherSideParameters_type > OtherSideParameters_optional;
      typedef ::xsd::cxx::tree::traits< OtherSideParameters_type, wchar_t > OtherSideParameters_traits;

      const OtherSideParameters_optional&
      OtherSideParameters () const;

      OtherSideParameters_optional&
      OtherSideParameters ();

      void
      OtherSideParameters (const OtherSideParameters_type& x);

      void
      OtherSideParameters (const OtherSideParameters_optional& x);

      void
      OtherSideParameters (::std::unique_ptr< OtherSideParameters_type > p);

      // Constructors.
      //
      WeldGrooveBothSidesBaseType ();

      WeldGrooveBothSidesBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      WeldGrooveBothSidesBaseType (const WeldGrooveBothSidesBaseType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual WeldGrooveBothSidesBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldGrooveBothSidesBaseType&
      operator= (const WeldGrooveBothSidesBaseType& x);

      virtual 
      ~WeldGrooveBothSidesBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ArrowSideParameters_optional ArrowSideParameters_;
      OtherSideParameters_optional OtherSideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldGrooveBothSidesExtendedType: public ::xsd::qif30::WeldGrooveBothSidesBaseType
    {
      public:
      // Spacer
      //
      typedef ::xml_schema::boolean Spacer_type;
      typedef ::xsd::cxx::tree::optional< Spacer_type > Spacer_optional;
      typedef ::xsd::cxx::tree::traits< Spacer_type, wchar_t > Spacer_traits;

      const Spacer_optional&
      Spacer () const;

      Spacer_optional&
      Spacer ();

      void
      Spacer (const Spacer_type& x);

      void
      Spacer (const Spacer_optional& x);

      // Constructors.
      //
      WeldGrooveBothSidesExtendedType ();

      WeldGrooveBothSidesExtendedType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldGrooveBothSidesExtendedType (const WeldGrooveBothSidesExtendedType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual WeldGrooveBothSidesExtendedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldGrooveBothSidesExtendedType&
      operator= (const WeldGrooveBothSidesExtendedType& x);

      virtual 
      ~WeldGrooveBothSidesExtendedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Spacer_optional Spacer_;
    };

    class QIF30_SYMBOL_DECL WeldSquareCharacteristicNominalType: public ::xsd::qif30::WeldGrooveCharacteristicNominalType
    {
      public:
      // Constructors.
      //
      WeldSquareCharacteristicNominalType ();

      WeldSquareCharacteristicNominalType (const id_type&,
                                           const CharacteristicDefinitionId_type&);

      WeldSquareCharacteristicNominalType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldSquareCharacteristicNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldSquareCharacteristicNominalType (const WeldSquareCharacteristicNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldSquareCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSquareCharacteristicNominalType&
      operator= (const WeldSquareCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WeldSquareCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WeldBevelCharacteristicNominalType: public ::xsd::qif30::WeldGrooveCharacteristicNominalType
    {
      public:
      // Constructors.
      //
      WeldBevelCharacteristicNominalType ();

      WeldBevelCharacteristicNominalType (const id_type&,
                                          const CharacteristicDefinitionId_type&);

      WeldBevelCharacteristicNominalType (const id_type&,
                                          ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldBevelCharacteristicNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      WeldBevelCharacteristicNominalType (const WeldBevelCharacteristicNominalType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual WeldBevelCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldBevelCharacteristicNominalType&
      operator= (const WeldBevelCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WeldBevelCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WeldVCharacteristicNominalType: public ::xsd::qif30::WeldGrooveCharacteristicNominalType
    {
      public:
      // Constructors.
      //
      WeldVCharacteristicNominalType ();

      WeldVCharacteristicNominalType (const id_type&,
                                      const CharacteristicDefinitionId_type&);

      WeldVCharacteristicNominalType (const id_type&,
                                      ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldVCharacteristicNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldVCharacteristicNominalType (const WeldVCharacteristicNominalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldVCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldVCharacteristicNominalType&
      operator= (const WeldVCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WeldVCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WeldUCharacteristicNominalType: public ::xsd::qif30::WeldGrooveCharacteristicNominalType
    {
      public:
      // Constructors.
      //
      WeldUCharacteristicNominalType ();

      WeldUCharacteristicNominalType (const id_type&,
                                      const CharacteristicDefinitionId_type&);

      WeldUCharacteristicNominalType (const id_type&,
                                      ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldUCharacteristicNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldUCharacteristicNominalType (const WeldUCharacteristicNominalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldUCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldUCharacteristicNominalType&
      operator= (const WeldUCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WeldUCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WeldJCharacteristicNominalType: public ::xsd::qif30::WeldGrooveCharacteristicNominalType
    {
      public:
      // Constructors.
      //
      WeldJCharacteristicNominalType ();

      WeldJCharacteristicNominalType (const id_type&,
                                      const CharacteristicDefinitionId_type&);

      WeldJCharacteristicNominalType (const id_type&,
                                      ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldJCharacteristicNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldJCharacteristicNominalType (const WeldJCharacteristicNominalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldJCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldJCharacteristicNominalType&
      operator= (const WeldJCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WeldJCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareVCharacteristicNominalType: public ::xsd::qif30::WeldGrooveCharacteristicNominalType
    {
      public:
      // Constructors.
      //
      WeldFlareVCharacteristicNominalType ();

      WeldFlareVCharacteristicNominalType (const id_type&,
                                           const CharacteristicDefinitionId_type&);

      WeldFlareVCharacteristicNominalType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldFlareVCharacteristicNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldFlareVCharacteristicNominalType (const WeldFlareVCharacteristicNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldFlareVCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareVCharacteristicNominalType&
      operator= (const WeldFlareVCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WeldFlareVCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareBevelCharacteristicNominalType: public ::xsd::qif30::WeldGrooveCharacteristicNominalType
    {
      public:
      // Constructors.
      //
      WeldFlareBevelCharacteristicNominalType ();

      WeldFlareBevelCharacteristicNominalType (const id_type&,
                                               const CharacteristicDefinitionId_type&);

      WeldFlareBevelCharacteristicNominalType (const id_type&,
                                               ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldFlareBevelCharacteristicNominalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      WeldFlareBevelCharacteristicNominalType (const WeldFlareBevelCharacteristicNominalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual WeldFlareBevelCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareBevelCharacteristicNominalType&
      operator= (const WeldFlareBevelCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WeldFlareBevelCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WeldScarfCharacteristicNominalType: public ::xsd::qif30::WeldGrooveCharacteristicNominalType
    {
      public:
      // Constructors.
      //
      WeldScarfCharacteristicNominalType ();

      WeldScarfCharacteristicNominalType (const id_type&,
                                          const CharacteristicDefinitionId_type&);

      WeldScarfCharacteristicNominalType (const id_type&,
                                          ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldScarfCharacteristicNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      WeldScarfCharacteristicNominalType (const WeldScarfCharacteristicNominalType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual WeldScarfCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldScarfCharacteristicNominalType&
      operator= (const WeldScarfCharacteristicNominalType&) = default;
#endif

      virtual 
      ~WeldScarfCharacteristicNominalType ();
    };

    class QIF30_SYMBOL_DECL WeldFilletOneSideInBothSidesType: public ::xsd::qif30::WeldOneSideParametersExtendSizeType
    {
      public:
      // LengthOfEachWeld
      //
      typedef ::xsd::qif30::LinearValueType LengthOfEachWeld_type;
      typedef ::xsd::cxx::tree::optional< LengthOfEachWeld_type > LengthOfEachWeld_optional;
      typedef ::xsd::cxx::tree::traits< LengthOfEachWeld_type, wchar_t > LengthOfEachWeld_traits;

      const LengthOfEachWeld_optional&
      LengthOfEachWeld () const;

      LengthOfEachWeld_optional&
      LengthOfEachWeld ();

      void
      LengthOfEachWeld (const LengthOfEachWeld_type& x);

      void
      LengthOfEachWeld (const LengthOfEachWeld_optional& x);

      void
      LengthOfEachWeld (::std::unique_ptr< LengthOfEachWeld_type > p);

      // Pitch
      //
      typedef ::xsd::qif30::LinearValueType Pitch_type;
      typedef ::xsd::cxx::tree::optional< Pitch_type > Pitch_optional;
      typedef ::xsd::cxx::tree::traits< Pitch_type, wchar_t > Pitch_traits;

      const Pitch_optional&
      Pitch () const;

      Pitch_optional&
      Pitch ();

      void
      Pitch (const Pitch_type& x);

      void
      Pitch (const Pitch_optional& x);

      void
      Pitch (::std::unique_ptr< Pitch_type > p);

      // Constructors.
      //
      WeldFilletOneSideInBothSidesType ();

      WeldFilletOneSideInBothSidesType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      WeldFilletOneSideInBothSidesType (const WeldFilletOneSideInBothSidesType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual WeldFilletOneSideInBothSidesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFilletOneSideInBothSidesType&
      operator= (const WeldFilletOneSideInBothSidesType& x);

      virtual 
      ~WeldFilletOneSideInBothSidesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LengthOfEachWeld_optional LengthOfEachWeld_;
      Pitch_optional Pitch_;
    };

    class QIF30_SYMBOL_DECL WeldFilletUnequalLegLengthType: public ::xml_schema::type
    {
      public:
      // FirstLegLength
      //
      typedef ::xsd::qif30::FractionType FirstLegLength_type;
      typedef ::xsd::cxx::tree::traits< FirstLegLength_type, wchar_t > FirstLegLength_traits;

      const FirstLegLength_type&
      FirstLegLength () const;

      FirstLegLength_type&
      FirstLegLength ();

      void
      FirstLegLength (const FirstLegLength_type& x);

      void
      FirstLegLength (::std::unique_ptr< FirstLegLength_type > p);

      // SecondLegLength
      //
      typedef ::xsd::qif30::FractionType SecondLegLength_type;
      typedef ::xsd::cxx::tree::traits< SecondLegLength_type, wchar_t > SecondLegLength_traits;

      const SecondLegLength_type&
      SecondLegLength () const;

      SecondLegLength_type&
      SecondLegLength ();

      void
      SecondLegLength (const SecondLegLength_type& x);

      void
      SecondLegLength (::std::unique_ptr< SecondLegLength_type > p);

      // Constructors.
      //
      WeldFilletUnequalLegLengthType ();

      WeldFilletUnequalLegLengthType (const FirstLegLength_type&,
                                      const SecondLegLength_type&);

      WeldFilletUnequalLegLengthType (::std::unique_ptr< FirstLegLength_type >,
                                      ::std::unique_ptr< SecondLegLength_type >);

      WeldFilletUnequalLegLengthType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldFilletUnequalLegLengthType (const WeldFilletUnequalLegLengthType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldFilletUnequalLegLengthType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFilletUnequalLegLengthType&
      operator= (const WeldFilletUnequalLegLengthType& x);

      virtual 
      ~WeldFilletUnequalLegLengthType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FirstLegLength_type > FirstLegLength_;
      ::xsd::cxx::tree::one< SecondLegLength_type > SecondLegLength_;
    };

    class QIF30_SYMBOL_DECL WeldFilletEqualLegLengthType: public ::xml_schema::type
    {
      public:
      // Size
      //
      typedef ::xsd::qif30::FractionType Size_type;
      typedef ::xsd::cxx::tree::optional< Size_type > Size_optional;
      typedef ::xsd::cxx::tree::traits< Size_type, wchar_t > Size_traits;

      const Size_optional&
      Size () const;

      Size_optional&
      Size ();

      void
      Size (const Size_type& x);

      void
      Size (const Size_optional& x);

      void
      Size (::std::unique_ptr< Size_type > p);

      // LengthOfEachWeld
      //
      typedef ::xsd::qif30::LinearValueType LengthOfEachWeld_type;
      typedef ::xsd::cxx::tree::optional< LengthOfEachWeld_type > LengthOfEachWeld_optional;
      typedef ::xsd::cxx::tree::traits< LengthOfEachWeld_type, wchar_t > LengthOfEachWeld_traits;

      const LengthOfEachWeld_optional&
      LengthOfEachWeld () const;

      LengthOfEachWeld_optional&
      LengthOfEachWeld ();

      void
      LengthOfEachWeld (const LengthOfEachWeld_type& x);

      void
      LengthOfEachWeld (const LengthOfEachWeld_optional& x);

      void
      LengthOfEachWeld (::std::unique_ptr< LengthOfEachWeld_type > p);

      // Pitch
      //
      typedef ::xsd::qif30::LinearValueType Pitch_type;
      typedef ::xsd::cxx::tree::optional< Pitch_type > Pitch_optional;
      typedef ::xsd::cxx::tree::traits< Pitch_type, wchar_t > Pitch_traits;

      const Pitch_optional&
      Pitch () const;

      Pitch_optional&
      Pitch ();

      void
      Pitch (const Pitch_type& x);

      void
      Pitch (const Pitch_optional& x);

      void
      Pitch (::std::unique_ptr< Pitch_type > p);

      // Constructors.
      //
      WeldFilletEqualLegLengthType ();

      WeldFilletEqualLegLengthType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      WeldFilletEqualLegLengthType (const WeldFilletEqualLegLengthType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual WeldFilletEqualLegLengthType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFilletEqualLegLengthType&
      operator= (const WeldFilletEqualLegLengthType& x);

      virtual 
      ~WeldFilletEqualLegLengthType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Size_optional Size_;
      LengthOfEachWeld_optional LengthOfEachWeld_;
      Pitch_optional Pitch_;
    };

    class QIF30_SYMBOL_DECL WeldFilletOneSideType: public ::xsd::qif30::WeldOneSideParametersBaseType
    {
      public:
      // EqualLegLength
      //
      typedef ::xsd::qif30::WeldFilletEqualLegLengthType EqualLegLength_type;
      typedef ::xsd::cxx::tree::optional< EqualLegLength_type > EqualLegLength_optional;
      typedef ::xsd::cxx::tree::traits< EqualLegLength_type, wchar_t > EqualLegLength_traits;

      const EqualLegLength_optional&
      EqualLegLength () const;

      EqualLegLength_optional&
      EqualLegLength ();

      void
      EqualLegLength (const EqualLegLength_type& x);

      void
      EqualLegLength (const EqualLegLength_optional& x);

      void
      EqualLegLength (::std::unique_ptr< EqualLegLength_type > p);

      // UnEqualLegLength
      //
      typedef ::xsd::qif30::WeldFilletUnequalLegLengthType UnEqualLegLength_type;
      typedef ::xsd::cxx::tree::optional< UnEqualLegLength_type > UnEqualLegLength_optional;
      typedef ::xsd::cxx::tree::traits< UnEqualLegLength_type, wchar_t > UnEqualLegLength_traits;

      const UnEqualLegLength_optional&
      UnEqualLegLength () const;

      UnEqualLegLength_optional&
      UnEqualLegLength ();

      void
      UnEqualLegLength (const UnEqualLegLength_type& x);

      void
      UnEqualLegLength (const UnEqualLegLength_optional& x);

      void
      UnEqualLegLength (::std::unique_ptr< UnEqualLegLength_type > p);

      // Constructors.
      //
      WeldFilletOneSideType ();

      WeldFilletOneSideType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      WeldFilletOneSideType (const WeldFilletOneSideType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual WeldFilletOneSideType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFilletOneSideType&
      operator= (const WeldFilletOneSideType& x);

      virtual 
      ~WeldFilletOneSideType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      EqualLegLength_optional EqualLegLength_;
      UnEqualLegLength_optional UnEqualLegLength_;
    };

    class QIF30_SYMBOL_DECL WeldFilletBothSidesType: public ::xml_schema::type
    {
      public:
      // ArrowSide
      //
      typedef ::xsd::qif30::WeldFilletOneSideInBothSidesType ArrowSide_type;
      typedef ::xsd::cxx::tree::optional< ArrowSide_type > ArrowSide_optional;
      typedef ::xsd::cxx::tree::traits< ArrowSide_type, wchar_t > ArrowSide_traits;

      const ArrowSide_optional&
      ArrowSide () const;

      ArrowSide_optional&
      ArrowSide ();

      void
      ArrowSide (const ArrowSide_type& x);

      void
      ArrowSide (const ArrowSide_optional& x);

      void
      ArrowSide (::std::unique_ptr< ArrowSide_type > p);

      // OtherSide
      //
      typedef ::xsd::qif30::WeldFilletOneSideInBothSidesType OtherSide_type;
      typedef ::xsd::cxx::tree::optional< OtherSide_type > OtherSide_optional;
      typedef ::xsd::cxx::tree::traits< OtherSide_type, wchar_t > OtherSide_traits;

      const OtherSide_optional&
      OtherSide () const;

      OtherSide_optional&
      OtherSide ();

      void
      OtherSide (const OtherSide_type& x);

      void
      OtherSide (const OtherSide_optional& x);

      void
      OtherSide (::std::unique_ptr< OtherSide_type > p);

      // Staggered
      //
      typedef ::xml_schema::boolean Staggered_type;
      typedef ::xsd::cxx::tree::optional< Staggered_type > Staggered_optional;
      typedef ::xsd::cxx::tree::traits< Staggered_type, wchar_t > Staggered_traits;

      const Staggered_optional&
      Staggered () const;

      Staggered_optional&
      Staggered ();

      void
      Staggered (const Staggered_type& x);

      void
      Staggered (const Staggered_optional& x);

      // Constructors.
      //
      WeldFilletBothSidesType ();

      WeldFilletBothSidesType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      WeldFilletBothSidesType (const WeldFilletBothSidesType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual WeldFilletBothSidesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFilletBothSidesType&
      operator= (const WeldFilletBothSidesType& x);

      virtual 
      ~WeldFilletBothSidesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ArrowSide_optional ArrowSide_;
      OtherSide_optional OtherSide_;
      Staggered_optional Staggered_;
    };

    class QIF30_SYMBOL_DECL WeldCompoundCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // WeldCharacteristicNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType WeldCharacteristicNominalIds_type;
      typedef ::xsd::cxx::tree::traits< WeldCharacteristicNominalIds_type, wchar_t > WeldCharacteristicNominalIds_traits;

      const WeldCharacteristicNominalIds_type&
      WeldCharacteristicNominalIds () const;

      WeldCharacteristicNominalIds_type&
      WeldCharacteristicNominalIds ();

      void
      WeldCharacteristicNominalIds (const WeldCharacteristicNominalIds_type& x);

      void
      WeldCharacteristicNominalIds (::std::unique_ptr< WeldCharacteristicNominalIds_type > p);

      // Constructors.
      //
      WeldCompoundCharacteristicNominalType ();

      WeldCompoundCharacteristicNominalType (const id_type&,
                                             const CharacteristicDefinitionId_type&,
                                             const WeldCharacteristicNominalIds_type&);

      WeldCompoundCharacteristicNominalType (const id_type&,
                                             ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                             ::std::unique_ptr< WeldCharacteristicNominalIds_type >);

      WeldCompoundCharacteristicNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldCompoundCharacteristicNominalType (const WeldCompoundCharacteristicNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldCompoundCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldCompoundCharacteristicNominalType&
      operator= (const WeldCompoundCharacteristicNominalType& x);

      virtual 
      ~WeldCompoundCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WeldCharacteristicNominalIds_type > WeldCharacteristicNominalIds_;
    };

    class QIF30_SYMBOL_DECL WeldFilletCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceAllEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // BothSides
      //
      typedef ::xsd::qif30::WeldFilletBothSidesType BothSides_type;
      typedef ::xsd::cxx::tree::optional< BothSides_type > BothSides_optional;
      typedef ::xsd::cxx::tree::traits< BothSides_type, wchar_t > BothSides_traits;

      const BothSides_optional&
      BothSides () const;

      BothSides_optional&
      BothSides ();

      void
      BothSides (const BothSides_type& x);

      void
      BothSides (const BothSides_optional& x);

      void
      BothSides (::std::unique_ptr< BothSides_type > p);

      // OneSide
      //
      typedef ::xsd::qif30::WeldFilletOneSideType OneSide_type;
      typedef ::xsd::cxx::tree::optional< OneSide_type > OneSide_optional;
      typedef ::xsd::cxx::tree::traits< OneSide_type, wchar_t > OneSide_traits;

      const OneSide_optional&
      OneSide () const;

      OneSide_optional&
      OneSide ();

      void
      OneSide (const OneSide_type& x);

      void
      OneSide (const OneSide_optional& x);

      void
      OneSide (::std::unique_ptr< OneSide_type > p);

      // Constructors.
      //
      WeldFilletCharacteristicNominalType ();

      WeldFilletCharacteristicNominalType (const id_type&,
                                           const CharacteristicDefinitionId_type&,
                                           const LocationSignificance_type&);

      WeldFilletCharacteristicNominalType (const id_type&,
                                           ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                           const LocationSignificance_type&);

      WeldFilletCharacteristicNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldFilletCharacteristicNominalType (const WeldFilletCharacteristicNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldFilletCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldFilletCharacteristicNominalType&
      operator= (const WeldFilletCharacteristicNominalType& x);

      virtual 
      ~WeldFilletCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      BothSides_optional BothSides_;
      OneSide_optional OneSide_;
    };

    class QIF30_SYMBOL_DECL WeldPlugOneSideParametersType: public ::xsd::qif30::WeldOneSideParametersExtendType
    {
      public:
      // Angle
      //
      typedef ::xsd::qif30::AngularValueType Angle_type;
      typedef ::xsd::cxx::tree::optional< Angle_type > Angle_optional;
      typedef ::xsd::cxx::tree::traits< Angle_type, wchar_t > Angle_traits;

      const Angle_optional&
      Angle () const;

      Angle_optional&
      Angle ();

      void
      Angle (const Angle_type& x);

      void
      Angle (const Angle_optional& x);

      void
      Angle (::std::unique_ptr< Angle_type > p);

      // Depth
      //
      typedef ::xsd::qif30::FractionType Depth_type;
      typedef ::xsd::cxx::tree::optional< Depth_type > Depth_optional;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_optional&
      Depth () const;

      Depth_optional&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (const Depth_optional& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Constructors.
      //
      WeldPlugOneSideParametersType ();

      WeldPlugOneSideParametersType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      WeldPlugOneSideParametersType (const WeldPlugOneSideParametersType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual WeldPlugOneSideParametersType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldPlugOneSideParametersType&
      operator= (const WeldPlugOneSideParametersType& x);

      virtual 
      ~WeldPlugOneSideParametersType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Angle_optional Angle_;
      Depth_optional Depth_;
    };

    class QIF30_SYMBOL_DECL WeldPlugCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceOneSidesEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldPlugOneSideParametersType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Constructors.
      //
      WeldPlugCharacteristicNominalType ();

      WeldPlugCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&,
                                         const LocationSignificance_type&);

      WeldPlugCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                         const LocationSignificance_type&);

      WeldPlugCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldPlugCharacteristicNominalType (const WeldPlugCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldPlugCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldPlugCharacteristicNominalType&
      operator= (const WeldPlugCharacteristicNominalType& x);

      virtual 
      ~WeldPlugCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldSlotCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceOneSidesEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldPlugOneSideParametersType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Constructors.
      //
      WeldSlotCharacteristicNominalType ();

      WeldSlotCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&,
                                         const LocationSignificance_type&);

      WeldSlotCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                         const LocationSignificance_type&);

      WeldSlotCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldSlotCharacteristicNominalType (const WeldSlotCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldSlotCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSlotCharacteristicNominalType&
      operator= (const WeldSlotCharacteristicNominalType& x);

      virtual 
      ~WeldSlotCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldSpotOneSideParametersType: public ::xsd::qif30::WeldOneSideParametersExtendSizeType
    {
      public:
      // Pitch
      //
      typedef ::xsd::qif30::LinearValueType Pitch_type;
      typedef ::xsd::cxx::tree::optional< Pitch_type > Pitch_optional;
      typedef ::xsd::cxx::tree::traits< Pitch_type, wchar_t > Pitch_traits;

      const Pitch_optional&
      Pitch () const;

      Pitch_optional&
      Pitch ();

      void
      Pitch (const Pitch_type& x);

      void
      Pitch (const Pitch_optional& x);

      void
      Pitch (::std::unique_ptr< Pitch_type > p);

      // WeldNumber
      //
      typedef ::xsd::qif30::NaturalType WeldNumber_type;
      typedef ::xsd::cxx::tree::optional< WeldNumber_type > WeldNumber_optional;
      typedef ::xsd::cxx::tree::traits< WeldNumber_type, wchar_t > WeldNumber_traits;

      const WeldNumber_optional&
      WeldNumber () const;

      WeldNumber_optional&
      WeldNumber ();

      void
      WeldNumber (const WeldNumber_type& x);

      void
      WeldNumber (const WeldNumber_optional& x);

      void
      WeldNumber (::std::unique_ptr< WeldNumber_type > p);

      // Constructors.
      //
      WeldSpotOneSideParametersType ();

      WeldSpotOneSideParametersType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      WeldSpotOneSideParametersType (const WeldSpotOneSideParametersType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual WeldSpotOneSideParametersType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSpotOneSideParametersType&
      operator= (const WeldSpotOneSideParametersType& x);

      virtual 
      ~WeldSpotOneSideParametersType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Pitch_optional Pitch_;
      WeldNumber_optional WeldNumber_;
    };

    class QIF30_SYMBOL_DECL WeldSpotCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceSpotSeamEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldSpotOneSideParametersType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Projection
      //
      typedef ::xml_schema::boolean Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      // Constructors.
      //
      WeldSpotCharacteristicNominalType ();

      WeldSpotCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&,
                                         const LocationSignificance_type&);

      WeldSpotCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                         const LocationSignificance_type&);

      WeldSpotCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldSpotCharacteristicNominalType (const WeldSpotCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldSpotCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSpotCharacteristicNominalType&
      operator= (const WeldSpotCharacteristicNominalType& x);

      virtual 
      ~WeldSpotCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
      Projection_optional Projection_;
    };

    class QIF30_SYMBOL_DECL WeldStudCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // ArrowSideParameters
      //
      typedef ::xsd::qif30::WeldOneSideParametersExtendType ArrowSideParameters_type;
      typedef ::xsd::cxx::tree::optional< ArrowSideParameters_type > ArrowSideParameters_optional;
      typedef ::xsd::cxx::tree::traits< ArrowSideParameters_type, wchar_t > ArrowSideParameters_traits;

      const ArrowSideParameters_optional&
      ArrowSideParameters () const;

      ArrowSideParameters_optional&
      ArrowSideParameters ();

      void
      ArrowSideParameters (const ArrowSideParameters_type& x);

      void
      ArrowSideParameters (const ArrowSideParameters_optional& x);

      void
      ArrowSideParameters (::std::unique_ptr< ArrowSideParameters_type > p);

      // Constructors.
      //
      WeldStudCharacteristicNominalType ();

      WeldStudCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&);

      WeldStudCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldStudCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldStudCharacteristicNominalType (const WeldStudCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldStudCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldStudCharacteristicNominalType&
      operator= (const WeldStudCharacteristicNominalType& x);

      virtual 
      ~WeldStudCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ArrowSideParameters_optional ArrowSideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldSeamCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceSpotSeamEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldOneSideParametersExtendType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Constructors.
      //
      WeldSeamCharacteristicNominalType ();

      WeldSeamCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&,
                                         const LocationSignificance_type&);

      WeldSeamCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                         const LocationSignificance_type&);

      WeldSeamCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldSeamCharacteristicNominalType (const WeldSeamCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldSeamCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSeamCharacteristicNominalType&
      operator= (const WeldSeamCharacteristicNominalType& x);

      virtual 
      ~WeldSeamCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldSurfacingCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // ArrowSideParameters
      //
      typedef ::xsd::qif30::WeldOneSideParametersExtendSizeType ArrowSideParameters_type;
      typedef ::xsd::cxx::tree::optional< ArrowSideParameters_type > ArrowSideParameters_optional;
      typedef ::xsd::cxx::tree::traits< ArrowSideParameters_type, wchar_t > ArrowSideParameters_traits;

      const ArrowSideParameters_optional&
      ArrowSideParameters () const;

      ArrowSideParameters_optional&
      ArrowSideParameters ();

      void
      ArrowSideParameters (const ArrowSideParameters_type& x);

      void
      ArrowSideParameters (const ArrowSideParameters_optional& x);

      void
      ArrowSideParameters (::std::unique_ptr< ArrowSideParameters_type > p);

      // Constructors.
      //
      WeldSurfacingCharacteristicNominalType ();

      WeldSurfacingCharacteristicNominalType (const id_type&,
                                              const CharacteristicDefinitionId_type&);

      WeldSurfacingCharacteristicNominalType (const id_type&,
                                              ::std::unique_ptr< CharacteristicDefinitionId_type >);

      WeldSurfacingCharacteristicNominalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      WeldSurfacingCharacteristicNominalType (const WeldSurfacingCharacteristicNominalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual WeldSurfacingCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSurfacingCharacteristicNominalType&
      operator= (const WeldSurfacingCharacteristicNominalType& x);

      virtual 
      ~WeldSurfacingCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ArrowSideParameters_optional ArrowSideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldEdgeCharacteristicNominalType: public ::xsd::qif30::WeldCharacteristicNominalBaseType
    {
      public:
      // LocationSignificance
      //
      typedef ::xsd::qif30::LocationSignificanceOneSidesEnumType LocationSignificance_type;
      typedef ::xsd::cxx::tree::traits< LocationSignificance_type, wchar_t > LocationSignificance_traits;

      const LocationSignificance_type&
      LocationSignificance () const;

      LocationSignificance_type&
      LocationSignificance ();

      void
      LocationSignificance (const LocationSignificance_type& x);

      void
      LocationSignificance (::std::unique_ptr< LocationSignificance_type > p);

      // SideParameters
      //
      typedef ::xsd::qif30::WeldOneSideParametersExtendSizeType SideParameters_type;
      typedef ::xsd::cxx::tree::optional< SideParameters_type > SideParameters_optional;
      typedef ::xsd::cxx::tree::traits< SideParameters_type, wchar_t > SideParameters_traits;

      const SideParameters_optional&
      SideParameters () const;

      SideParameters_optional&
      SideParameters ();

      void
      SideParameters (const SideParameters_type& x);

      void
      SideParameters (const SideParameters_optional& x);

      void
      SideParameters (::std::unique_ptr< SideParameters_type > p);

      // Constructors.
      //
      WeldEdgeCharacteristicNominalType ();

      WeldEdgeCharacteristicNominalType (const id_type&,
                                         const CharacteristicDefinitionId_type&,
                                         const LocationSignificance_type&);

      WeldEdgeCharacteristicNominalType (const id_type&,
                                         ::std::unique_ptr< CharacteristicDefinitionId_type >,
                                         const LocationSignificance_type&);

      WeldEdgeCharacteristicNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldEdgeCharacteristicNominalType (const WeldEdgeCharacteristicNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldEdgeCharacteristicNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldEdgeCharacteristicNominalType&
      operator= (const WeldEdgeCharacteristicNominalType& x);

      virtual 
      ~WeldEdgeCharacteristicNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationSignificance_type > LocationSignificance_;
      SideParameters_optional SideParameters_;
    };

    class QIF30_SYMBOL_DECL WeldFilletCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldFilletCharacteristicDefinitionType ();

      WeldFilletCharacteristicDefinitionType (const id_type&);

      WeldFilletCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      WeldFilletCharacteristicDefinitionType (const WeldFilletCharacteristicDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual WeldFilletCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFilletCharacteristicDefinitionType&
      operator= (const WeldFilletCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldFilletCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldPlugCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldPlugCharacteristicDefinitionType ();

      WeldPlugCharacteristicDefinitionType (const id_type&);

      WeldPlugCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldPlugCharacteristicDefinitionType (const WeldPlugCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldPlugCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldPlugCharacteristicDefinitionType&
      operator= (const WeldPlugCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldPlugCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldSlotCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldSlotCharacteristicDefinitionType ();

      WeldSlotCharacteristicDefinitionType (const id_type&);

      WeldSlotCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldSlotCharacteristicDefinitionType (const WeldSlotCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldSlotCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSlotCharacteristicDefinitionType&
      operator= (const WeldSlotCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldSlotCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldSpotCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldSpotCharacteristicDefinitionType ();

      WeldSpotCharacteristicDefinitionType (const id_type&);

      WeldSpotCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldSpotCharacteristicDefinitionType (const WeldSpotCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldSpotCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSpotCharacteristicDefinitionType&
      operator= (const WeldSpotCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldSpotCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldStudCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldStudCharacteristicDefinitionType ();

      WeldStudCharacteristicDefinitionType (const id_type&);

      WeldStudCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldStudCharacteristicDefinitionType (const WeldStudCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldStudCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldStudCharacteristicDefinitionType&
      operator= (const WeldStudCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldStudCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldSeamCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldSeamCharacteristicDefinitionType ();

      WeldSeamCharacteristicDefinitionType (const id_type&);

      WeldSeamCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldSeamCharacteristicDefinitionType (const WeldSeamCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldSeamCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSeamCharacteristicDefinitionType&
      operator= (const WeldSeamCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldSeamCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldSurfacingCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldSurfacingCharacteristicDefinitionType ();

      WeldSurfacingCharacteristicDefinitionType (const id_type&);

      WeldSurfacingCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      WeldSurfacingCharacteristicDefinitionType (const WeldSurfacingCharacteristicDefinitionType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual WeldSurfacingCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSurfacingCharacteristicDefinitionType&
      operator= (const WeldSurfacingCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldSurfacingCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldEdgeCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldEdgeCharacteristicDefinitionType ();

      WeldEdgeCharacteristicDefinitionType (const id_type&);

      WeldEdgeCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldEdgeCharacteristicDefinitionType (const WeldEdgeCharacteristicDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldEdgeCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldEdgeCharacteristicDefinitionType&
      operator= (const WeldEdgeCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldEdgeCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldSquareCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldSquareCharacteristicDefinitionType ();

      WeldSquareCharacteristicDefinitionType (const id_type&);

      WeldSquareCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      WeldSquareCharacteristicDefinitionType (const WeldSquareCharacteristicDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual WeldSquareCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSquareCharacteristicDefinitionType&
      operator= (const WeldSquareCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldSquareCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldBevelCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldBevelCharacteristicDefinitionType ();

      WeldBevelCharacteristicDefinitionType (const id_type&);

      WeldBevelCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldBevelCharacteristicDefinitionType (const WeldBevelCharacteristicDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldBevelCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldBevelCharacteristicDefinitionType&
      operator= (const WeldBevelCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldBevelCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldVCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldVCharacteristicDefinitionType ();

      WeldVCharacteristicDefinitionType (const id_type&);

      WeldVCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldVCharacteristicDefinitionType (const WeldVCharacteristicDefinitionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldVCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldVCharacteristicDefinitionType&
      operator= (const WeldVCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldVCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldUCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldUCharacteristicDefinitionType ();

      WeldUCharacteristicDefinitionType (const id_type&);

      WeldUCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldUCharacteristicDefinitionType (const WeldUCharacteristicDefinitionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldUCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldUCharacteristicDefinitionType&
      operator= (const WeldUCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldUCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldJCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldJCharacteristicDefinitionType ();

      WeldJCharacteristicDefinitionType (const id_type&);

      WeldJCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      WeldJCharacteristicDefinitionType (const WeldJCharacteristicDefinitionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual WeldJCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldJCharacteristicDefinitionType&
      operator= (const WeldJCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldJCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareVCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldFlareVCharacteristicDefinitionType ();

      WeldFlareVCharacteristicDefinitionType (const id_type&);

      WeldFlareVCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      WeldFlareVCharacteristicDefinitionType (const WeldFlareVCharacteristicDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual WeldFlareVCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareVCharacteristicDefinitionType&
      operator= (const WeldFlareVCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldFlareVCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareBevelCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldFlareBevelCharacteristicDefinitionType ();

      WeldFlareBevelCharacteristicDefinitionType (const id_type&);

      WeldFlareBevelCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      WeldFlareBevelCharacteristicDefinitionType (const WeldFlareBevelCharacteristicDefinitionType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual WeldFlareBevelCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareBevelCharacteristicDefinitionType&
      operator= (const WeldFlareBevelCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldFlareBevelCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldScarfCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // Constructors.
      //
      WeldScarfCharacteristicDefinitionType ();

      WeldScarfCharacteristicDefinitionType (const id_type&);

      WeldScarfCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldScarfCharacteristicDefinitionType (const WeldScarfCharacteristicDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldScarfCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldScarfCharacteristicDefinitionType&
      operator= (const WeldScarfCharacteristicDefinitionType&) = default;
#endif

      virtual 
      ~WeldScarfCharacteristicDefinitionType ();
    };

    class QIF30_SYMBOL_DECL WeldCompoundCharacteristicDefinitionType: public ::xsd::qif30::WeldCharacteristicDefinitionBaseType
    {
      public:
      // WeldCharacteristicDefinitionIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType WeldCharacteristicDefinitionIds_type;
      typedef ::xsd::cxx::tree::traits< WeldCharacteristicDefinitionIds_type, wchar_t > WeldCharacteristicDefinitionIds_traits;

      const WeldCharacteristicDefinitionIds_type&
      WeldCharacteristicDefinitionIds () const;

      WeldCharacteristicDefinitionIds_type&
      WeldCharacteristicDefinitionIds ();

      void
      WeldCharacteristicDefinitionIds (const WeldCharacteristicDefinitionIds_type& x);

      void
      WeldCharacteristicDefinitionIds (::std::unique_ptr< WeldCharacteristicDefinitionIds_type > p);

      // Constructors.
      //
      WeldCompoundCharacteristicDefinitionType ();

      WeldCompoundCharacteristicDefinitionType (const id_type&,
                                                const WeldCharacteristicDefinitionIds_type&);

      WeldCompoundCharacteristicDefinitionType (const id_type&,
                                                ::std::unique_ptr< WeldCharacteristicDefinitionIds_type >);

      WeldCompoundCharacteristicDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      WeldCompoundCharacteristicDefinitionType (const WeldCompoundCharacteristicDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual WeldCompoundCharacteristicDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldCompoundCharacteristicDefinitionType&
      operator= (const WeldCompoundCharacteristicDefinitionType& x);

      virtual 
      ~WeldCompoundCharacteristicDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WeldCharacteristicDefinitionIds_type > WeldCharacteristicDefinitionIds_;
    };

    class QIF30_SYMBOL_DECL WeldFilletCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldFilletCharacteristicItemType ();

      WeldFilletCharacteristicItemType (const id_type&,
                                        const CharacteristicNominalId_type&);

      WeldFilletCharacteristicItemType (const id_type&,
                                        ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldFilletCharacteristicItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      WeldFilletCharacteristicItemType (const WeldFilletCharacteristicItemType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual WeldFilletCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFilletCharacteristicItemType&
      operator= (const WeldFilletCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldFilletCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldPlugCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldPlugCharacteristicItemType ();

      WeldPlugCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      WeldPlugCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldPlugCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldPlugCharacteristicItemType (const WeldPlugCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldPlugCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldPlugCharacteristicItemType&
      operator= (const WeldPlugCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldPlugCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldSlotCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldSlotCharacteristicItemType ();

      WeldSlotCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      WeldSlotCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldSlotCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldSlotCharacteristicItemType (const WeldSlotCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldSlotCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSlotCharacteristicItemType&
      operator= (const WeldSlotCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldSlotCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldSpotCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldSpotCharacteristicItemType ();

      WeldSpotCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      WeldSpotCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldSpotCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldSpotCharacteristicItemType (const WeldSpotCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldSpotCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSpotCharacteristicItemType&
      operator= (const WeldSpotCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldSpotCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldStudCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldStudCharacteristicItemType ();

      WeldStudCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      WeldStudCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldStudCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldStudCharacteristicItemType (const WeldStudCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldStudCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldStudCharacteristicItemType&
      operator= (const WeldStudCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldStudCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldSeamCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldSeamCharacteristicItemType ();

      WeldSeamCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      WeldSeamCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldSeamCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldSeamCharacteristicItemType (const WeldSeamCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldSeamCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSeamCharacteristicItemType&
      operator= (const WeldSeamCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldSeamCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldSurfacingCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldSurfacingCharacteristicItemType ();

      WeldSurfacingCharacteristicItemType (const id_type&,
                                           const CharacteristicNominalId_type&);

      WeldSurfacingCharacteristicItemType (const id_type&,
                                           ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldSurfacingCharacteristicItemType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldSurfacingCharacteristicItemType (const WeldSurfacingCharacteristicItemType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldSurfacingCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSurfacingCharacteristicItemType&
      operator= (const WeldSurfacingCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldSurfacingCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldEdgeCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldEdgeCharacteristicItemType ();

      WeldEdgeCharacteristicItemType (const id_type&,
                                      const CharacteristicNominalId_type&);

      WeldEdgeCharacteristicItemType (const id_type&,
                                      ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldEdgeCharacteristicItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      WeldEdgeCharacteristicItemType (const WeldEdgeCharacteristicItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual WeldEdgeCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldEdgeCharacteristicItemType&
      operator= (const WeldEdgeCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldEdgeCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldSquareCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldSquareCharacteristicItemType ();

      WeldSquareCharacteristicItemType (const id_type&,
                                        const CharacteristicNominalId_type&);

      WeldSquareCharacteristicItemType (const id_type&,
                                        ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldSquareCharacteristicItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      WeldSquareCharacteristicItemType (const WeldSquareCharacteristicItemType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual WeldSquareCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSquareCharacteristicItemType&
      operator= (const WeldSquareCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldSquareCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldBevelCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldBevelCharacteristicItemType ();

      WeldBevelCharacteristicItemType (const id_type&,
                                       const CharacteristicNominalId_type&);

      WeldBevelCharacteristicItemType (const id_type&,
                                       ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldBevelCharacteristicItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldBevelCharacteristicItemType (const WeldBevelCharacteristicItemType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual WeldBevelCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldBevelCharacteristicItemType&
      operator= (const WeldBevelCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldBevelCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldVCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldVCharacteristicItemType ();

      WeldVCharacteristicItemType (const id_type&,
                                   const CharacteristicNominalId_type&);

      WeldVCharacteristicItemType (const id_type&,
                                   ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldVCharacteristicItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      WeldVCharacteristicItemType (const WeldVCharacteristicItemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual WeldVCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldVCharacteristicItemType&
      operator= (const WeldVCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldVCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldUCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldUCharacteristicItemType ();

      WeldUCharacteristicItemType (const id_type&,
                                   const CharacteristicNominalId_type&);

      WeldUCharacteristicItemType (const id_type&,
                                   ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldUCharacteristicItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      WeldUCharacteristicItemType (const WeldUCharacteristicItemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual WeldUCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldUCharacteristicItemType&
      operator= (const WeldUCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldUCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldJCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldJCharacteristicItemType ();

      WeldJCharacteristicItemType (const id_type&,
                                   const CharacteristicNominalId_type&);

      WeldJCharacteristicItemType (const id_type&,
                                   ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldJCharacteristicItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      WeldJCharacteristicItemType (const WeldJCharacteristicItemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual WeldJCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldJCharacteristicItemType&
      operator= (const WeldJCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldJCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareVCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldFlareVCharacteristicItemType ();

      WeldFlareVCharacteristicItemType (const id_type&,
                                        const CharacteristicNominalId_type&);

      WeldFlareVCharacteristicItemType (const id_type&,
                                        ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldFlareVCharacteristicItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      WeldFlareVCharacteristicItemType (const WeldFlareVCharacteristicItemType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual WeldFlareVCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareVCharacteristicItemType&
      operator= (const WeldFlareVCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldFlareVCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareBevelCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldFlareBevelCharacteristicItemType ();

      WeldFlareBevelCharacteristicItemType (const id_type&,
                                            const CharacteristicNominalId_type&);

      WeldFlareBevelCharacteristicItemType (const id_type&,
                                            ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldFlareBevelCharacteristicItemType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldFlareBevelCharacteristicItemType (const WeldFlareBevelCharacteristicItemType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldFlareBevelCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareBevelCharacteristicItemType&
      operator= (const WeldFlareBevelCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldFlareBevelCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldScarfCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // Constructors.
      //
      WeldScarfCharacteristicItemType ();

      WeldScarfCharacteristicItemType (const id_type&,
                                       const CharacteristicNominalId_type&);

      WeldScarfCharacteristicItemType (const id_type&,
                                       ::std::unique_ptr< CharacteristicNominalId_type >);

      WeldScarfCharacteristicItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      WeldScarfCharacteristicItemType (const WeldScarfCharacteristicItemType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual WeldScarfCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldScarfCharacteristicItemType&
      operator= (const WeldScarfCharacteristicItemType&) = default;
#endif

      virtual 
      ~WeldScarfCharacteristicItemType ();
    };

    class QIF30_SYMBOL_DECL WeldCompoundCharacteristicItemType: public ::xsd::qif30::WeldCharacteristicItemBaseType
    {
      public:
      // WeldCharacteristicItemIds
      //
      typedef ::xsd::qif30::ArrayReferenceType WeldCharacteristicItemIds_type;
      typedef ::xsd::cxx::tree::traits< WeldCharacteristicItemIds_type, wchar_t > WeldCharacteristicItemIds_traits;

      const WeldCharacteristicItemIds_type&
      WeldCharacteristicItemIds () const;

      WeldCharacteristicItemIds_type&
      WeldCharacteristicItemIds ();

      void
      WeldCharacteristicItemIds (const WeldCharacteristicItemIds_type& x);

      void
      WeldCharacteristicItemIds (::std::unique_ptr< WeldCharacteristicItemIds_type > p);

      // Constructors.
      //
      WeldCompoundCharacteristicItemType ();

      WeldCompoundCharacteristicItemType (const id_type&,
                                          const CharacteristicNominalId_type&,
                                          const WeldCharacteristicItemIds_type&);

      WeldCompoundCharacteristicItemType (const id_type&,
                                          ::std::unique_ptr< CharacteristicNominalId_type >,
                                          ::std::unique_ptr< WeldCharacteristicItemIds_type >);

      WeldCompoundCharacteristicItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      WeldCompoundCharacteristicItemType (const WeldCompoundCharacteristicItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual WeldCompoundCharacteristicItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldCompoundCharacteristicItemType&
      operator= (const WeldCompoundCharacteristicItemType& x);

      virtual 
      ~WeldCompoundCharacteristicItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WeldCharacteristicItemIds_type > WeldCharacteristicItemIds_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriticalityLevelEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CriticalityLevelEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CriticalityLevelEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriticalityAreaEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CriticalityAreaEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CriticalityAreaEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriticalityType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicBalloonLocationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CharacteristicBalloonLocationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CharacteristicBalloonLocationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicBalloonStyleEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CharacteristicBalloonStyleEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CharacteristicBalloonStyleEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicBalloonType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicDesignatorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationOnDrawingType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AssociatedTolerancedFeatureSpecificationElementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const AssociatedTolerancedFeatureSpecificationElementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const AssociatedTolerancedFeatureSpecificationElementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ReferenceFeatureAssociationSpecificationElementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ReferenceFeatureAssociationSpecificationElementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ReferenceFeatureAssociationSpecificationElementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ReferenceFeatureAssociationSpecificationParameterEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ReferenceFeatureAssociationSpecificationParameterEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ReferenceFeatureAssociationSpecificationParameterEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SingleNestingIndexFilterSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SingleNestingIndexFilterSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SingleNestingIndexFilterSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SingleNestingIndexFilterType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DualNestingIndexFilterSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DualNestingIndexFilterSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DualNestingIndexFilterSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DualNestingIndexFilterType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FilterType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ReferenceFeatureAssociationSpecificationElementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GeometricCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GeometricCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GeometricCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GeometricCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DimensionalCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DimensionalCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DimensionalCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DimensionalCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAttributeCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAttributeCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAttributeCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAttributeCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StringValuesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedLinearCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedLinearCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedLinearCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedLinearCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAngularCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAngularCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAngularCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAngularCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTemperatureCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTemperatureCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTemperatureCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTemperatureCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AreaCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AreaCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AreaCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AreaCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAreaCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAreaCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAreaCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAreaCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ForceCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ForceCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ForceCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ForceCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedForceCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedForceCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedForceCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedForceCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MassCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MassCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MassCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MassCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedMassCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedMassCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedMassCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedMassCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PressureCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PressureCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PressureCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PressureCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedPressureCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedPressureCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedPressureCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedPressureCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpeedCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpeedCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpeedCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpeedCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedSpeedCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedSpeedCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedSpeedCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedSpeedCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TimeCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TimeCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TimeCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TimeCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTimeCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTimeCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTimeCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTimeCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedUnitCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedUnitCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedUnitCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedUnitCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentPositionDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentPositionMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentProfileDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentProfileMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentSymmetryDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentSymmetryMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OriginReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceTextureCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RoughnessLayEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const RoughnessLayEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const RoughnessLayEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RoughnessObtentionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const RoughnessObtentionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const RoughnessObtentionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RoughnessApplicabilityEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const RoughnessApplicabilityEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const RoughnessApplicabilityEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceTextureCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceTextureCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceTextureCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationPlanarZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationZoneShapeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PerpendicularityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PerpendicularityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PerpendicularityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PerpendicularityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ParallelismCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ParallelismCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ParallelismCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ParallelismCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FormCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FormCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FormCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FormCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StraightnessDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const StraightnessDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const StraightnessDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StraightnessNonDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StraightnessZoneShapeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StraightnessCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StraightnessCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StraightnessCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StraightnessCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatnessCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatnessCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatnessCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatnessCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidicityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidicityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidicityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidicityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherFormCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherFormCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherFormCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherFormCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionSphericalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionNonDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionZoneShapeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleFromCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleFromCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleFromCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleFromCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleBetweenCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleBetweenCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleBetweenCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleBetweenCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCoordinateCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCoordinateCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCoordinateCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCoordinateCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCoordinateCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCoordinateCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCoordinateCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCoordinateCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveLengthCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveLengthCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveLengthCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveLengthCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DiameterCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DiameterCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DiameterCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DiameterCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalDiameterCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalDiameterCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalDiameterCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalDiameterCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LengthCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LengthCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LengthCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LengthCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WidthCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WidthCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WidthCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WidthCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HeightCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HeightCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HeightCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HeightCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DepthCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DepthCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DepthCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DepthCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThicknessCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThicknessCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThicknessCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThicknessCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SquareCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SquareCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SquareCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SquareCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceFromCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceFromCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceFromCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceFromCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceBetweenCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceBetweenCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceBetweenCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceBetweenCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RadiusCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RadiusCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RadiusCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RadiusCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalRadiusCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalRadiusCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalRadiusCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalRadiusCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ChordCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ChordCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ChordCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ChordCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalTaperCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalTaperCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalTaperCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalTaperCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatTaperCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatTaperCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatTaperCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatTaperCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RunoutCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RunoutCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RunoutCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RunoutCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularRunoutCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularRunoutCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularRunoutCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularRunoutCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TotalRunoutCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TotalRunoutCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TotalRunoutCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TotalRunoutCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoaxialityDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CoaxialityDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CoaxialityDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoaxialityNonDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CoaxialityNonDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CoaxialityNonDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoaxialityZoneShapeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoaxialityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoaxialityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoaxialityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoaxialityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricitySphericalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ConcentricitySphericalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ConcentricitySphericalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricityDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ConcentricityDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ConcentricityDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricityNonDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ConcentricityNonDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ConcentricityNonDiametricalZoneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricityZoneShapeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricityCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricityCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricityCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricityCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SymmetryCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SymmetryCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SymmetryCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SymmetryCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProfileCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProfileCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProfileCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProfileCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineProfileCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineProfileCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineProfileCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineProfileCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointProfileCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointProfileCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointProfileCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointProfileCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileNonUniformCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileNonUniformCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileNonUniformCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileNonUniformCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredZoneRadiiType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicManufacturingProcessGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimultaneousRequirementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SimultaneousRequirementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SimultaneousRequirementEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentLowerLevelEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CompositeSegmentLowerLevelEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CompositeSegmentLowerLevelEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimultaneousRequirementGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimultaneousRequirementGroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CharacteristicStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CharacteristicStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicStatusType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicGroupStatusType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDeviationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDeviationsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ExtentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ExtentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtentType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionCoordinateMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PositionCoordinateMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PositionCoordinateMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionCoordinateMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicAspectsListsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredCharacteristicsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicItemsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicGroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicGroupStatusesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicDefinitionsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToleranceDefinitionsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicNominalsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicMeasurementsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldContourSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const WeldContourSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const WeldContourSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFinishingDesignatorEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const WeldFinishingDesignatorEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const WeldFinishingDesignatorEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationSignificanceOneSidesEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LocationSignificanceOneSidesEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LocationSignificanceOneSidesEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationSignificanceSpotSeamEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LocationSignificanceSpotSeamEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LocationSignificanceSpotSeamEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationSignificanceAllEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LocationSignificanceAllEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LocationSignificanceAllEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NonDestructiveTestingEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const NonDestructiveTestingEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const NonDestructiveTestingEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldingProcessEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const WeldingProcessEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const WeldingProcessEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldingProcessSuffixEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const WeldingProcessSuffixEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const WeldingProcessSuffixEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldingProcessType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayNonDestructiveTestingType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCharacteristicNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCharacteristicDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCharacteristicMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldPlugCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSlotCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSpotCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldStudCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSeamCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSurfacingCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldEdgeCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldGrooveCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSquareCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldBevelCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldVCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldUCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldJCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareVCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareBevelCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldScarfCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCompoundCharacteristicMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCharacteristicItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldGrooveCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFinishingType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldOneSideParametersBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldOneSideParametersExtendSizeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldOneSideParametersExtendType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldGrooveOneSideParametersType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSupplementarySymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const WeldSupplementarySymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const WeldSupplementarySymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldGrooveOneSideType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldGrooveBothSidesBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldGrooveBothSidesExtendedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSquareCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldBevelCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldVCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldUCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldJCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareVCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareBevelCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldScarfCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletOneSideInBothSidesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletUnequalLegLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletEqualLegLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletOneSideType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletBothSidesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCompoundCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldPlugOneSideParametersType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldPlugCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSlotCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSpotOneSideParametersType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSpotCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldStudCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSeamCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSurfacingCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldEdgeCharacteristicNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldPlugCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSlotCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSpotCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldStudCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSeamCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSurfacingCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldEdgeCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSquareCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldBevelCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldVCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldUCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldJCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareVCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareBevelCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldScarfCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCompoundCharacteristicDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldPlugCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSlotCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSpotCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldStudCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSeamCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSurfacingCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldEdgeCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSquareCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldBevelCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldVCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldUCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldJCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareVCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareBevelCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldScarfCharacteristicItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCompoundCharacteristicItemType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_CHARACTERISTICS_HXX
