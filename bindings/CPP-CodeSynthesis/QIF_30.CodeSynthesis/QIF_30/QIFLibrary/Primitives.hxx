// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_PRIMITIVES_HXX
#define CXX___QIFLIBRARY_PRIMITIVES_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class BinaryDataType;
    class ListIntType;
    class I2Type;
    class I3Type;
    class ListDoubleType;
    class ListBooleanType;
    class ListDateTimeType;
    class ListTokenType;
    class D3Type;
    class D2Type;
    class DoublePositiveType;
    class Point2dSimpleType;
    class UnitVector2dSimpleType;
    class ParameterRangeType;
    class PointSimpleType;
    class VectorSimpleType;
    class UnitVectorSimpleType;
    class ValidityEnumType;
    class PointType;
    class VectorType;
    class UnitVectorType;
    class ArrayPoint2dType;
    class ArrayPointType;
    class ArrayUnitVectorType;
    class PolyLineType;
    class PlaneType;
    class PlaneXType;
    class AxisType;
    class TransformRotationType;
    class CoordinateSystemCoreType;
    class TransformMatrixType;
    class LineSegmentType;
    class LineSegment2dType;
    class LatitudeLongitudeSweepType;
    class OrientedLatitudeLongitudeSweepType;
    class SweepType;
    class AngleRangeType;
    class QIFIdAndReferenceBaseType;
    class QIFIdType;
    class QIFReferenceBaseType;
    class QIFReferenceSimpleType;
    class QIFReferenceType;
    class ListQIFReferenceSimpleType;
    class ListQIFReferenceType;
    class ListQIFReferenceFullType;
    class ArrayBinaryQIFReferenceType;
    class ArrayBinaryQIFReferenceFullType;
    class QIFReferenceActiveType;
    class QIFReferenceFullType;
    class ElementReferenceType;
    class ElementReferenceFullType;
    class D4Type;
    class NaturalType;
    class ListNaturalType;
    class Natural2Type;
    class ArrayNaturalType;
    class FractionType;
    class ArrayReferenceType;
    class ArrayReferenceActiveType;
    class ArrayReferenceFullType;
    class QIFFeaturePairType;
    class ArrayPairReferenceFullType;
    class ListUnsignedByteType;
    class QPIdType;
    class QPIdReferenceType;
    class QPIdFullReferenceType;
    class ArrayQPIdFullReferenceType;
    class ArrayUnsignedByteType;
    class ArrayIntType;
    class ArrayI2Type;
    class ArrayI3Type;
    class ArrayDoubleType;
    class ArrayBinaryType;
    class AttributesType;
    class AttributeBaseType;
    class AttributeBoolType;
    class AttributeStrType;
    class AttributeTimeType;
    class AttributeQPIdType;
    class AttributeI1Type;
    class AttributeI2Type;
    class AttributeI3Type;
    class AttributeD1Type;
    class AttributeD2Type;
    class AttributeD3Type;
    class AttributeUserType;
    class UserDataXMLType;
    class ValidationPointsType;
    class BoundingBoxAxisAlignedType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL BinaryDataType: public ::xml_schema::base64_binary
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // Constructors.
      //
      BinaryDataType ();

      BinaryDataType (const count_type&);

      BinaryDataType (const ::xml_schema::base64_binary&,
                      const count_type&);

      BinaryDataType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      BinaryDataType (const BinaryDataType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual BinaryDataType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BinaryDataType&
      operator= (const BinaryDataType& x);

      virtual 
      ~BinaryDataType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class QIF30_SYMBOL_DECL ListIntType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t >
    {
      public:
      ListIntType ();

      ListIntType (size_type n, const ::xml_schema::integer& x);

      template < typename I >
      ListIntType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t > (begin, end, this)
      {
      }

      ListIntType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ListIntType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ListIntType (const ::std::wstring& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ListIntType (const ListIntType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ListIntType&
      operator= (const ListIntType&) = default;
#endif

      virtual ListIntType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListIntType ();
    };

    class QIF30_SYMBOL_DECL I2Type: public ::xsd::qif30::ListIntType
    {
      public:
      // Constructors.
      //
      I2Type ();

      I2Type (const ::xsd::qif30::ListIntType&);

      I2Type (const xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I2Type (const xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I2Type (const ::std::wstring& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I2Type (const I2Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual I2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      I2Type&
      operator= (const I2Type&) = default;
#endif

      virtual 
      ~I2Type ();
    };

    class QIF30_SYMBOL_DECL I3Type: public ::xsd::qif30::ListIntType
    {
      public:
      // Constructors.
      //
      I3Type ();

      I3Type (const ::xsd::qif30::ListIntType&);

      I3Type (const xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I3Type (const xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I3Type (const ::std::wstring& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I3Type (const I3Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual I3Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      I3Type&
      operator= (const I3Type&) = default;
#endif

      virtual 
      ~I3Type ();
    };

    class QIF30_SYMBOL_DECL ListDoubleType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ >
    {
      public:
      ListDoubleType ();

      ListDoubleType (size_type n, const ::xml_schema::double_& x);

      template < typename I >
      ListDoubleType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ > (begin, end, this)
      {
      }

      ListDoubleType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ListDoubleType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ListDoubleType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ListDoubleType (const ListDoubleType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ListDoubleType&
      operator= (const ListDoubleType&) = default;
#endif

      virtual ListDoubleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListDoubleType ();
    };

    class QIF30_SYMBOL_DECL ListBooleanType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t >
    {
      public:
      ListBooleanType ();

      ListBooleanType (size_type n, const ::xml_schema::boolean& x);

      template < typename I >
      ListBooleanType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t > (begin, end, this)
      {
      }

      ListBooleanType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListBooleanType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListBooleanType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListBooleanType (const ListBooleanType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ListBooleanType&
      operator= (const ListBooleanType&) = default;
#endif

      virtual ListBooleanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListBooleanType ();
    };

    class QIF30_SYMBOL_DECL ListDateTimeType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t >
    {
      public:
      ListDateTimeType ();

      ListDateTimeType (size_type n, const ::xml_schema::date_time& x);

      template < typename I >
      ListDateTimeType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t > (begin, end, this)
      {
      }

      ListDateTimeType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ListDateTimeType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ListDateTimeType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ListDateTimeType (const ListDateTimeType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ListDateTimeType&
      operator= (const ListDateTimeType&) = default;
#endif

      virtual ListDateTimeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListDateTimeType ();
    };

    class QIF30_SYMBOL_DECL ListTokenType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t >
    {
      public:
      ListTokenType ();

      ListTokenType (size_type n, const ::xml_schema::nmtoken& x);

      template < typename I >
      ListTokenType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t > (begin, end, this)
      {
      }

      ListTokenType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ListTokenType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ListTokenType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ListTokenType (const ListTokenType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ListTokenType&
      operator= (const ListTokenType&) = default;
#endif

      virtual ListTokenType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListTokenType ();
    };

    class QIF30_SYMBOL_DECL D3Type: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      D3Type ();

      D3Type (const ::xsd::qif30::ListDoubleType&);

      D3Type (const xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D3Type (const xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D3Type (const ::std::wstring& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D3Type (const D3Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual D3Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      D3Type&
      operator= (const D3Type&) = default;
#endif

      virtual 
      ~D3Type ();
    };

    class QIF30_SYMBOL_DECL D2Type: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      D2Type ();

      D2Type (const ::xsd::qif30::ListDoubleType&);

      D2Type (const xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D2Type (const xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D2Type (const ::std::wstring& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D2Type (const D2Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual D2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      D2Type&
      operator= (const D2Type&) = default;
#endif

      virtual 
      ~D2Type ();
    };

    class QIF30_SYMBOL_DECL DoublePositiveType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
    {
      public:
      // Constructors.
      //
      DoublePositiveType ();

      DoublePositiveType (const ::xml_schema::double_&);

      DoublePositiveType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DoublePositiveType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DoublePositiveType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DoublePositiveType (const DoublePositiveType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual DoublePositiveType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DoublePositiveType&
      operator= (const DoublePositiveType&) = default;
#endif

      virtual 
      ~DoublePositiveType ();
    };

    class QIF30_SYMBOL_DECL Point2dSimpleType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      Point2dSimpleType ();

      Point2dSimpleType (const ::xsd::qif30::ListDoubleType&);

      Point2dSimpleType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Point2dSimpleType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Point2dSimpleType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Point2dSimpleType (const Point2dSimpleType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual Point2dSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      Point2dSimpleType&
      operator= (const Point2dSimpleType&) = default;
#endif

      virtual 
      ~Point2dSimpleType ();
    };

    class QIF30_SYMBOL_DECL UnitVector2dSimpleType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      UnitVector2dSimpleType ();

      UnitVector2dSimpleType (const ::xsd::qif30::ListDoubleType&);

      UnitVector2dSimpleType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      UnitVector2dSimpleType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      UnitVector2dSimpleType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      UnitVector2dSimpleType (const UnitVector2dSimpleType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual UnitVector2dSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UnitVector2dSimpleType&
      operator= (const UnitVector2dSimpleType&) = default;
#endif

      virtual 
      ~UnitVector2dSimpleType ();
    };

    class QIF30_SYMBOL_DECL ParameterRangeType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      ParameterRangeType ();

      ParameterRangeType (const ::xsd::qif30::ListDoubleType&);

      ParameterRangeType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ParameterRangeType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ParameterRangeType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ParameterRangeType (const ParameterRangeType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ParameterRangeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ParameterRangeType&
      operator= (const ParameterRangeType&) = default;
#endif

      virtual 
      ~ParameterRangeType ();
    };

    class QIF30_SYMBOL_DECL PointSimpleType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      PointSimpleType ();

      PointSimpleType (const ::xsd::qif30::ListDoubleType&);

      PointSimpleType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PointSimpleType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PointSimpleType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PointSimpleType (const PointSimpleType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual PointSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointSimpleType&
      operator= (const PointSimpleType&) = default;
#endif

      virtual 
      ~PointSimpleType ();
    };

    class QIF30_SYMBOL_DECL VectorSimpleType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      VectorSimpleType ();

      VectorSimpleType (const ::xsd::qif30::ListDoubleType&);

      VectorSimpleType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      VectorSimpleType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      VectorSimpleType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      VectorSimpleType (const VectorSimpleType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual VectorSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      VectorSimpleType&
      operator= (const VectorSimpleType&) = default;
#endif

      virtual 
      ~VectorSimpleType ();
    };

    class QIF30_SYMBOL_DECL UnitVectorSimpleType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      UnitVectorSimpleType ();

      UnitVectorSimpleType (const ::xsd::qif30::ListDoubleType&);

      UnitVectorSimpleType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UnitVectorSimpleType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UnitVectorSimpleType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UnitVectorSimpleType (const UnitVectorSimpleType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual UnitVectorSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UnitVectorSimpleType&
      operator= (const UnitVectorSimpleType&) = default;
#endif

      virtual 
      ~UnitVectorSimpleType ();
    };

    class QIF30_SYMBOL_DECL ValidityEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        REPORTED,
        DUMMY,
        MOOT,
        DERIVED,
        SET
      };

      ValidityEnumType ();

      ValidityEnumType (value v);

      ValidityEnumType (const wchar_t* v);

      ValidityEnumType (const ::std::wstring& v);

      ValidityEnumType (const ::xml_schema::nmtoken& v);

      ValidityEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ValidityEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ValidityEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ValidityEnumType (const ValidityEnumType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ValidityEnumType&
      operator= (const ValidityEnumType&) = default;
#endif

      virtual ValidityEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidityEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ValidityEnumType_convert ();
      }

      protected:
      value
      _xsd_ValidityEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ValidityEnumType_literals_[5];
      static const value _xsd_ValidityEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL PointType: public ::xsd::qif30::PointSimpleType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // Constructors.
      //
      PointType ();

      PointType (const ::xsd::qif30::ListDoubleType&);

      PointType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      PointType (const PointType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual PointType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointType&
      operator= (const PointType& x);

      virtual 
      ~PointType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class QIF30_SYMBOL_DECL VectorType: public ::xsd::qif30::VectorSimpleType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // Constructors.
      //
      VectorType ();

      VectorType (const ::xsd::qif30::ListDoubleType&);

      VectorType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      VectorType (const VectorType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual VectorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VectorType&
      operator= (const VectorType& x);

      virtual 
      ~VectorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class QIF30_SYMBOL_DECL UnitVectorType: public ::xsd::qif30::UnitVectorSimpleType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // Constructors.
      //
      UnitVectorType ();

      UnitVectorType (const ::xsd::qif30::ListDoubleType&);

      UnitVectorType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      UnitVectorType (const UnitVectorType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual UnitVectorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UnitVectorType&
      operator= (const UnitVectorType& x);

      virtual 
      ~UnitVectorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class QIF30_SYMBOL_DECL ArrayPoint2dType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // Constructors.
      //
      ArrayPoint2dType ();

      ArrayPoint2dType (const count_type&);

      ArrayPoint2dType (const ::xsd::qif30::ListDoubleType&,
                        const count_type&);

      ArrayPoint2dType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ArrayPoint2dType (const ArrayPoint2dType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ArrayPoint2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayPoint2dType&
      operator= (const ArrayPoint2dType& x);

      virtual 
      ~ArrayPoint2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class QIF30_SYMBOL_DECL ArrayPointType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // Constructors.
      //
      ArrayPointType ();

      ArrayPointType (const count_type&);

      ArrayPointType (const ::xsd::qif30::ListDoubleType&,
                      const count_type&);

      ArrayPointType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ArrayPointType (const ArrayPointType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ArrayPointType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayPointType&
      operator= (const ArrayPointType& x);

      virtual 
      ~ArrayPointType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class QIF30_SYMBOL_DECL ArrayUnitVectorType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // Constructors.
      //
      ArrayUnitVectorType ();

      ArrayUnitVectorType (const count_type&);

      ArrayUnitVectorType (const ::xsd::qif30::ListDoubleType&,
                           const count_type&);

      ArrayUnitVectorType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ArrayUnitVectorType (const ArrayUnitVectorType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ArrayUnitVectorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayUnitVectorType&
      operator= (const ArrayUnitVectorType& x);

      virtual 
      ~ArrayUnitVectorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class QIF30_SYMBOL_DECL PolyLineType: public ::xsd::qif30::ArrayPointType
    {
      public:
      // Constructors.
      //
      PolyLineType ();

      PolyLineType (const count_type&);

      PolyLineType (const ::xsd::qif30::ListDoubleType&,
                    const count_type&);

      PolyLineType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      PolyLineType (const PolyLineType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual PolyLineType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PolyLineType&
      operator= (const PolyLineType&) = default;
#endif

      virtual 
      ~PolyLineType ();
    };

    class QIF30_SYMBOL_DECL PlaneType: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::PointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::unique_ptr< Point_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructors.
      //
      PlaneType ();

      PlaneType (const Point_type&,
                 const Normal_type&);

      PlaneType (::std::unique_ptr< Point_type >,
                 ::std::unique_ptr< Normal_type >);

      PlaneType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      PlaneType (const PlaneType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual PlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneType&
      operator= (const PlaneType& x);

      virtual 
      ~PlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
    };

    class QIF30_SYMBOL_DECL PlaneXType: public ::xsd::qif30::PlaneType
    {
      public:
      // Direction
      //
      typedef ::xsd::qif30::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // Constructors.
      //
      PlaneXType ();

      PlaneXType (const Point_type&,
                  const Normal_type&,
                  const Direction_type&);

      PlaneXType (::std::unique_ptr< Point_type >,
                  ::std::unique_ptr< Normal_type >,
                  ::std::unique_ptr< Direction_type >);

      PlaneXType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      PlaneXType (const PlaneXType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual PlaneXType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneXType&
      operator= (const PlaneXType& x);

      virtual 
      ~PlaneXType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Direction_type > Direction_;
    };

    class QIF30_SYMBOL_DECL AxisType: public ::xml_schema::type
    {
      public:
      // AxisPoint
      //
      typedef ::xsd::qif30::PointType AxisPoint_type;
      typedef ::xsd::cxx::tree::traits< AxisPoint_type, wchar_t > AxisPoint_traits;

      const AxisPoint_type&
      AxisPoint () const;

      AxisPoint_type&
      AxisPoint ();

      void
      AxisPoint (const AxisPoint_type& x);

      void
      AxisPoint (::std::unique_ptr< AxisPoint_type > p);

      // Direction
      //
      typedef ::xsd::qif30::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // Constructors.
      //
      AxisType ();

      AxisType (const AxisPoint_type&,
                const Direction_type&);

      AxisType (::std::unique_ptr< AxisPoint_type >,
                ::std::unique_ptr< Direction_type >);

      AxisType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      AxisType (const AxisType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual AxisType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AxisType&
      operator= (const AxisType& x);

      virtual 
      ~AxisType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AxisPoint_type > AxisPoint_;
      ::xsd::cxx::tree::one< Direction_type > Direction_;
    };

    class QIF30_SYMBOL_DECL TransformRotationType: public ::xml_schema::type
    {
      public:
      // XDirection
      //
      typedef ::xsd::qif30::UnitVectorSimpleType XDirection_type;
      typedef ::xsd::cxx::tree::traits< XDirection_type, wchar_t > XDirection_traits;

      const XDirection_type&
      XDirection () const;

      XDirection_type&
      XDirection ();

      void
      XDirection (const XDirection_type& x);

      void
      XDirection (::std::unique_ptr< XDirection_type > p);

      // YDirection
      //
      typedef ::xsd::qif30::UnitVectorSimpleType YDirection_type;
      typedef ::xsd::cxx::tree::traits< YDirection_type, wchar_t > YDirection_traits;

      const YDirection_type&
      YDirection () const;

      YDirection_type&
      YDirection ();

      void
      YDirection (const YDirection_type& x);

      void
      YDirection (::std::unique_ptr< YDirection_type > p);

      // ZDirection
      //
      typedef ::xsd::qif30::UnitVectorSimpleType ZDirection_type;
      typedef ::xsd::cxx::tree::traits< ZDirection_type, wchar_t > ZDirection_traits;

      const ZDirection_type&
      ZDirection () const;

      ZDirection_type&
      ZDirection ();

      void
      ZDirection (const ZDirection_type& x);

      void
      ZDirection (::std::unique_ptr< ZDirection_type > p);

      // Constructors.
      //
      TransformRotationType ();

      TransformRotationType (const XDirection_type&,
                             const YDirection_type&,
                             const ZDirection_type&);

      TransformRotationType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      TransformRotationType (const TransformRotationType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual TransformRotationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformRotationType&
      operator= (const TransformRotationType& x);

      virtual 
      ~TransformRotationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XDirection_type > XDirection_;
      ::xsd::cxx::tree::one< YDirection_type > YDirection_;
      ::xsd::cxx::tree::one< ZDirection_type > ZDirection_;
    };

    class QIF30_SYMBOL_DECL CoordinateSystemCoreType: public ::xml_schema::type
    {
      public:
      // Rotation
      //
      typedef ::xsd::qif30::TransformRotationType Rotation_type;
      typedef ::xsd::cxx::tree::optional< Rotation_type > Rotation_optional;
      typedef ::xsd::cxx::tree::traits< Rotation_type, wchar_t > Rotation_traits;

      const Rotation_optional&
      Rotation () const;

      Rotation_optional&
      Rotation ();

      void
      Rotation (const Rotation_type& x);

      void
      Rotation (const Rotation_optional& x);

      void
      Rotation (::std::unique_ptr< Rotation_type > p);

      // Origin
      //
      typedef ::xsd::qif30::PointSimpleType Origin_type;
      typedef ::xsd::cxx::tree::optional< Origin_type > Origin_optional;
      typedef ::xsd::cxx::tree::traits< Origin_type, wchar_t > Origin_traits;

      const Origin_optional&
      Origin () const;

      Origin_optional&
      Origin ();

      void
      Origin (const Origin_type& x);

      void
      Origin (const Origin_optional& x);

      void
      Origin (::std::unique_ptr< Origin_type > p);

      // Constructors.
      //
      CoordinateSystemCoreType ();

      CoordinateSystemCoreType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CoordinateSystemCoreType (const CoordinateSystemCoreType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CoordinateSystemCoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemCoreType&
      operator= (const CoordinateSystemCoreType& x);

      virtual 
      ~CoordinateSystemCoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Rotation_optional Rotation_;
      Origin_optional Origin_;
    };

    class QIF30_SYMBOL_DECL TransformMatrixType: public ::xsd::qif30::CoordinateSystemCoreType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // Constructors.
      //
      TransformMatrixType ();

      TransformMatrixType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      TransformMatrixType (const TransformMatrixType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual TransformMatrixType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformMatrixType&
      operator= (const TransformMatrixType& x);

      virtual 
      ~TransformMatrixType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class QIF30_SYMBOL_DECL LineSegmentType: public ::xml_schema::type
    {
      public:
      // StartPoint
      //
      typedef ::xsd::qif30::PointSimpleType StartPoint_type;
      typedef ::xsd::cxx::tree::traits< StartPoint_type, wchar_t > StartPoint_traits;

      const StartPoint_type&
      StartPoint () const;

      StartPoint_type&
      StartPoint ();

      void
      StartPoint (const StartPoint_type& x);

      void
      StartPoint (::std::unique_ptr< StartPoint_type > p);

      // EndPoint
      //
      typedef ::xsd::qif30::PointSimpleType EndPoint_type;
      typedef ::xsd::cxx::tree::traits< EndPoint_type, wchar_t > EndPoint_traits;

      const EndPoint_type&
      EndPoint () const;

      EndPoint_type&
      EndPoint ();

      void
      EndPoint (const EndPoint_type& x);

      void
      EndPoint (::std::unique_ptr< EndPoint_type > p);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // Constructors.
      //
      LineSegmentType ();

      LineSegmentType (const StartPoint_type&,
                       const EndPoint_type&);

      LineSegmentType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LineSegmentType (const LineSegmentType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LineSegmentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineSegmentType&
      operator= (const LineSegmentType& x);

      virtual 
      ~LineSegmentType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< StartPoint_type > StartPoint_;
      ::xsd::cxx::tree::one< EndPoint_type > EndPoint_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class QIF30_SYMBOL_DECL LineSegment2dType: public ::xml_schema::type
    {
      public:
      // StartPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType StartPoint_type;
      typedef ::xsd::cxx::tree::traits< StartPoint_type, wchar_t > StartPoint_traits;

      const StartPoint_type&
      StartPoint () const;

      StartPoint_type&
      StartPoint ();

      void
      StartPoint (const StartPoint_type& x);

      void
      StartPoint (::std::unique_ptr< StartPoint_type > p);

      // EndPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType EndPoint_type;
      typedef ::xsd::cxx::tree::traits< EndPoint_type, wchar_t > EndPoint_traits;

      const EndPoint_type&
      EndPoint () const;

      EndPoint_type&
      EndPoint ();

      void
      EndPoint (const EndPoint_type& x);

      void
      EndPoint (::std::unique_ptr< EndPoint_type > p);

      // Constructors.
      //
      LineSegment2dType ();

      LineSegment2dType (const StartPoint_type&,
                         const EndPoint_type&);

      LineSegment2dType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      LineSegment2dType (const LineSegment2dType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual LineSegment2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineSegment2dType&
      operator= (const LineSegment2dType& x);

      virtual 
      ~LineSegment2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< StartPoint_type > StartPoint_;
      ::xsd::cxx::tree::one< EndPoint_type > EndPoint_;
    };

    class QIF30_SYMBOL_DECL LatitudeLongitudeSweepType: public ::xml_schema::type
    {
      public:
      // DirMeridianPrime
      //
      typedef ::xsd::qif30::UnitVectorType DirMeridianPrime_type;
      typedef ::xsd::cxx::tree::traits< DirMeridianPrime_type, wchar_t > DirMeridianPrime_traits;

      const DirMeridianPrime_type&
      DirMeridianPrime () const;

      DirMeridianPrime_type&
      DirMeridianPrime ();

      void
      DirMeridianPrime (const DirMeridianPrime_type& x);

      void
      DirMeridianPrime (::std::unique_ptr< DirMeridianPrime_type > p);

      // DomainLatitude
      //
      typedef ::xsd::qif30::AngleRangeType DomainLatitude_type;
      typedef ::xsd::cxx::tree::traits< DomainLatitude_type, wchar_t > DomainLatitude_traits;

      const DomainLatitude_type&
      DomainLatitude () const;

      DomainLatitude_type&
      DomainLatitude ();

      void
      DomainLatitude (const DomainLatitude_type& x);

      void
      DomainLatitude (::std::unique_ptr< DomainLatitude_type > p);

      // DomainLongitude
      //
      typedef ::xsd::qif30::AngleRangeType DomainLongitude_type;
      typedef ::xsd::cxx::tree::traits< DomainLongitude_type, wchar_t > DomainLongitude_traits;

      const DomainLongitude_type&
      DomainLongitude () const;

      DomainLongitude_type&
      DomainLongitude ();

      void
      DomainLongitude (const DomainLongitude_type& x);

      void
      DomainLongitude (::std::unique_ptr< DomainLongitude_type > p);

      // Constructors.
      //
      LatitudeLongitudeSweepType ();

      LatitudeLongitudeSweepType (const DirMeridianPrime_type&,
                                  const DomainLatitude_type&,
                                  const DomainLongitude_type&);

      LatitudeLongitudeSweepType (::std::unique_ptr< DirMeridianPrime_type >,
                                  ::std::unique_ptr< DomainLatitude_type >,
                                  ::std::unique_ptr< DomainLongitude_type >);

      LatitudeLongitudeSweepType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      LatitudeLongitudeSweepType (const LatitudeLongitudeSweepType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual LatitudeLongitudeSweepType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LatitudeLongitudeSweepType&
      operator= (const LatitudeLongitudeSweepType& x);

      virtual 
      ~LatitudeLongitudeSweepType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DirMeridianPrime_type > DirMeridianPrime_;
      ::xsd::cxx::tree::one< DomainLatitude_type > DomainLatitude_;
      ::xsd::cxx::tree::one< DomainLongitude_type > DomainLongitude_;
    };

    class QIF30_SYMBOL_DECL OrientedLatitudeLongitudeSweepType: public ::xsd::qif30::LatitudeLongitudeSweepType
    {
      public:
      // DirNorthPole
      //
      typedef ::xsd::qif30::UnitVectorType DirNorthPole_type;
      typedef ::xsd::cxx::tree::traits< DirNorthPole_type, wchar_t > DirNorthPole_traits;

      const DirNorthPole_type&
      DirNorthPole () const;

      DirNorthPole_type&
      DirNorthPole ();

      void
      DirNorthPole (const DirNorthPole_type& x);

      void
      DirNorthPole (::std::unique_ptr< DirNorthPole_type > p);

      // Constructors.
      //
      OrientedLatitudeLongitudeSweepType ();

      OrientedLatitudeLongitudeSweepType (const DirMeridianPrime_type&,
                                          const DomainLatitude_type&,
                                          const DomainLongitude_type&,
                                          const DirNorthPole_type&);

      OrientedLatitudeLongitudeSweepType (::std::unique_ptr< DirMeridianPrime_type >,
                                          ::std::unique_ptr< DomainLatitude_type >,
                                          ::std::unique_ptr< DomainLongitude_type >,
                                          ::std::unique_ptr< DirNorthPole_type >);

      OrientedLatitudeLongitudeSweepType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OrientedLatitudeLongitudeSweepType (const OrientedLatitudeLongitudeSweepType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OrientedLatitudeLongitudeSweepType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrientedLatitudeLongitudeSweepType&
      operator= (const OrientedLatitudeLongitudeSweepType& x);

      virtual 
      ~OrientedLatitudeLongitudeSweepType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DirNorthPole_type > DirNorthPole_;
    };

    class QIF30_SYMBOL_DECL SweepType: public ::xml_schema::type
    {
      public:
      // DirBeg
      //
      typedef ::xsd::qif30::UnitVectorType DirBeg_type;
      typedef ::xsd::cxx::tree::traits< DirBeg_type, wchar_t > DirBeg_traits;

      const DirBeg_type&
      DirBeg () const;

      DirBeg_type&
      DirBeg ();

      void
      DirBeg (const DirBeg_type& x);

      void
      DirBeg (::std::unique_ptr< DirBeg_type > p);

      // DomainAngle
      //
      typedef ::xsd::qif30::AngleRangeType DomainAngle_type;
      typedef ::xsd::cxx::tree::traits< DomainAngle_type, wchar_t > DomainAngle_traits;

      const DomainAngle_type&
      DomainAngle () const;

      DomainAngle_type&
      DomainAngle ();

      void
      DomainAngle (const DomainAngle_type& x);

      void
      DomainAngle (::std::unique_ptr< DomainAngle_type > p);

      // Constructors.
      //
      SweepType ();

      SweepType (const DirBeg_type&,
                 const DomainAngle_type&);

      SweepType (::std::unique_ptr< DirBeg_type >,
                 ::std::unique_ptr< DomainAngle_type >);

      SweepType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      SweepType (const SweepType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual SweepType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SweepType&
      operator= (const SweepType& x);

      virtual 
      ~SweepType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DirBeg_type > DirBeg_;
      ::xsd::cxx::tree::one< DomainAngle_type > DomainAngle_;
    };

    class QIF30_SYMBOL_DECL AngleRangeType: public ::xsd::qif30::D2Type
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, wchar_t > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::unique_ptr< angularUnit_type > p);

      // Constructors.
      //
      AngleRangeType ();

      AngleRangeType (const ::xsd::qif30::ListDoubleType&);

      AngleRangeType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      AngleRangeType (const AngleRangeType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual AngleRangeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleRangeType&
      operator= (const AngleRangeType& x);

      virtual 
      ~AngleRangeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class QIF30_SYMBOL_DECL QIFIdAndReferenceBaseType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      QIFIdAndReferenceBaseType ();

      QIFIdAndReferenceBaseType (const ::xml_schema::unsigned_int&);

      QIFIdAndReferenceBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      QIFIdAndReferenceBaseType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      QIFIdAndReferenceBaseType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      QIFIdAndReferenceBaseType (const QIFIdAndReferenceBaseType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual QIFIdAndReferenceBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      QIFIdAndReferenceBaseType&
      operator= (const QIFIdAndReferenceBaseType&) = default;
#endif

      virtual 
      ~QIFIdAndReferenceBaseType ();
    };

    class QIF30_SYMBOL_DECL QIFIdType: public ::xsd::qif30::QIFIdAndReferenceBaseType
    {
      public:
      // Constructors.
      //
      QIFIdType ();

      QIFIdType (const ::xml_schema::unsigned_int&);

      QIFIdType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      QIFIdType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      QIFIdType (const ::std::wstring& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      QIFIdType (const QIFIdType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual QIFIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      QIFIdType&
      operator= (const QIFIdType&) = default;
#endif

      virtual 
      ~QIFIdType ();
    };

    class QIF30_SYMBOL_DECL QIFReferenceBaseType: public ::xsd::qif30::QIFIdAndReferenceBaseType
    {
      public:
      // Constructors.
      //
      QIFReferenceBaseType ();

      QIFReferenceBaseType (const ::xml_schema::unsigned_int&);

      QIFReferenceBaseType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      QIFReferenceBaseType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      QIFReferenceBaseType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      QIFReferenceBaseType (const QIFReferenceBaseType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual QIFReferenceBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      QIFReferenceBaseType&
      operator= (const QIFReferenceBaseType&) = default;
#endif

      virtual 
      ~QIFReferenceBaseType ();
    };

    class QIF30_SYMBOL_DECL QIFReferenceSimpleType: public ::xsd::qif30::QIFReferenceBaseType
    {
      public:
      // Constructors.
      //
      QIFReferenceSimpleType ();

      QIFReferenceSimpleType (const ::xml_schema::unsigned_int&);

      QIFReferenceSimpleType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      QIFReferenceSimpleType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      QIFReferenceSimpleType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      QIFReferenceSimpleType (const QIFReferenceSimpleType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual QIFReferenceSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      QIFReferenceSimpleType&
      operator= (const QIFReferenceSimpleType&) = default;
#endif

      virtual 
      ~QIFReferenceSimpleType ();
    };

    class QIF30_SYMBOL_DECL QIFReferenceType: public ::xsd::qif30::QIFReferenceBaseType
    {
      public:
      // xId
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType xId_type;
      typedef ::xsd::cxx::tree::optional< xId_type > xId_optional;
      typedef ::xsd::cxx::tree::traits< xId_type, wchar_t > xId_traits;

      const xId_optional&
      xId () const;

      xId_optional&
      xId ();

      void
      xId (const xId_type& x);

      void
      xId (const xId_optional& x);

      void
      xId (::std::unique_ptr< xId_type > p);

      // Constructors.
      //
      QIFReferenceType ();

      QIFReferenceType (const ::xml_schema::unsigned_int&);

      QIFReferenceType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      QIFReferenceType (const QIFReferenceType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual QIFReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFReferenceType&
      operator= (const QIFReferenceType& x);

      virtual 
      ~QIFReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      xId_optional xId_;
    };

    class QIF30_SYMBOL_DECL ListQIFReferenceSimpleType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t >
    {
      public:
      ListQIFReferenceSimpleType ();

      ListQIFReferenceSimpleType (size_type n, const ::xsd::qif30::QIFReferenceSimpleType& x);

      template < typename I >
      ListQIFReferenceSimpleType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t > (begin, end, this)
      {
      }

      ListQIFReferenceSimpleType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ListQIFReferenceSimpleType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ListQIFReferenceSimpleType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ListQIFReferenceSimpleType (const ListQIFReferenceSimpleType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ListQIFReferenceSimpleType&
      operator= (const ListQIFReferenceSimpleType&) = default;
#endif

      virtual ListQIFReferenceSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListQIFReferenceSimpleType ();
    };

    class QIF30_SYMBOL_DECL ListQIFReferenceType: public ::xml_schema::type
    {
      public:
      // Ids
      //
      typedef ::xsd::qif30::ListQIFReferenceSimpleType Ids_type;
      typedef ::xsd::cxx::tree::optional< Ids_type > Ids_optional;
      typedef ::xsd::cxx::tree::traits< Ids_type, wchar_t > Ids_traits;

      const Ids_optional&
      Ids () const;

      Ids_optional&
      Ids ();

      void
      Ids (const Ids_type& x);

      void
      Ids (const Ids_optional& x);

      void
      Ids (::std::unique_ptr< Ids_type > p);

      // Id
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // XIds
      //
      typedef ::xsd::qif30::ListQIFReferenceSimpleType XIds_type;
      typedef ::xsd::cxx::tree::optional< XIds_type > XIds_optional;
      typedef ::xsd::cxx::tree::traits< XIds_type, wchar_t > XIds_traits;

      const XIds_optional&
      XIds () const;

      XIds_optional&
      XIds ();

      void
      XIds (const XIds_type& x);

      void
      XIds (const XIds_optional& x);

      void
      XIds (::std::unique_ptr< XIds_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ListQIFReferenceType ();

      ListQIFReferenceType (const n_type&);

      ListQIFReferenceType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ListQIFReferenceType (const ListQIFReferenceType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ListQIFReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ListQIFReferenceType&
      operator= (const ListQIFReferenceType& x);

      virtual 
      ~ListQIFReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Ids_optional Ids_;
      Id_optional Id_;
      XIds_optional XIds_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ListQIFReferenceFullType: public ::xsd::qif30::ListQIFReferenceType
    {
      public:
      // asmPathId
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType asmPathId_type;
      typedef ::xsd::cxx::tree::optional< asmPathId_type > asmPathId_optional;
      typedef ::xsd::cxx::tree::traits< asmPathId_type, wchar_t > asmPathId_traits;

      const asmPathId_optional&
      asmPathId () const;

      asmPathId_optional&
      asmPathId ();

      void
      asmPathId (const asmPathId_type& x);

      void
      asmPathId (const asmPathId_optional& x);

      void
      asmPathId (::std::unique_ptr< asmPathId_type > p);

      // asmPathXId
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType asmPathXId_type;
      typedef ::xsd::cxx::tree::optional< asmPathXId_type > asmPathXId_optional;
      typedef ::xsd::cxx::tree::traits< asmPathXId_type, wchar_t > asmPathXId_traits;

      const asmPathXId_optional&
      asmPathXId () const;

      asmPathXId_optional&
      asmPathXId ();

      void
      asmPathXId (const asmPathXId_type& x);

      void
      asmPathXId (const asmPathXId_optional& x);

      void
      asmPathXId (::std::unique_ptr< asmPathXId_type > p);

      // Constructors.
      //
      ListQIFReferenceFullType ();

      ListQIFReferenceFullType (const n_type&);

      ListQIFReferenceFullType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ListQIFReferenceFullType (const ListQIFReferenceFullType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ListQIFReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ListQIFReferenceFullType&
      operator= (const ListQIFReferenceFullType& x);

      virtual 
      ~ListQIFReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      asmPathId_optional asmPathId_;
      asmPathXId_optional asmPathXId_;
    };

    class QIF30_SYMBOL_DECL ArrayBinaryQIFReferenceType: public ::xml_schema::type
    {
      public:
      // Ids
      //
      typedef ::xsd::qif30::ArrayBinaryType Ids_type;
      typedef ::xsd::cxx::tree::optional< Ids_type > Ids_optional;
      typedef ::xsd::cxx::tree::traits< Ids_type, wchar_t > Ids_traits;

      const Ids_optional&
      Ids () const;

      Ids_optional&
      Ids ();

      void
      Ids (const Ids_type& x);

      void
      Ids (const Ids_optional& x);

      void
      Ids (::std::unique_ptr< Ids_type > p);

      // Id
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // XIds
      //
      typedef ::xsd::qif30::ArrayBinaryType XIds_type;
      typedef ::xsd::cxx::tree::optional< XIds_type > XIds_optional;
      typedef ::xsd::cxx::tree::traits< XIds_type, wchar_t > XIds_traits;

      const XIds_optional&
      XIds () const;

      XIds_optional&
      XIds ();

      void
      XIds (const XIds_type& x);

      void
      XIds (const XIds_optional& x);

      void
      XIds (::std::unique_ptr< XIds_type > p);

      // Constructors.
      //
      ArrayBinaryQIFReferenceType ();

      ArrayBinaryQIFReferenceType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ArrayBinaryQIFReferenceType (const ArrayBinaryQIFReferenceType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ArrayBinaryQIFReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayBinaryQIFReferenceType&
      operator= (const ArrayBinaryQIFReferenceType& x);

      virtual 
      ~ArrayBinaryQIFReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Ids_optional Ids_;
      Id_optional Id_;
      XIds_optional XIds_;
    };

    class QIF30_SYMBOL_DECL ArrayBinaryQIFReferenceFullType: public ::xsd::qif30::ArrayBinaryQIFReferenceType
    {
      public:
      // asmPathId
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType asmPathId_type;
      typedef ::xsd::cxx::tree::optional< asmPathId_type > asmPathId_optional;
      typedef ::xsd::cxx::tree::traits< asmPathId_type, wchar_t > asmPathId_traits;

      const asmPathId_optional&
      asmPathId () const;

      asmPathId_optional&
      asmPathId ();

      void
      asmPathId (const asmPathId_type& x);

      void
      asmPathId (const asmPathId_optional& x);

      void
      asmPathId (::std::unique_ptr< asmPathId_type > p);

      // asmPathXId
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType asmPathXId_type;
      typedef ::xsd::cxx::tree::optional< asmPathXId_type > asmPathXId_optional;
      typedef ::xsd::cxx::tree::traits< asmPathXId_type, wchar_t > asmPathXId_traits;

      const asmPathXId_optional&
      asmPathXId () const;

      asmPathXId_optional&
      asmPathXId ();

      void
      asmPathXId (const asmPathXId_type& x);

      void
      asmPathXId (const asmPathXId_optional& x);

      void
      asmPathXId (::std::unique_ptr< asmPathXId_type > p);

      // Constructors.
      //
      ArrayBinaryQIFReferenceFullType ();

      ArrayBinaryQIFReferenceFullType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ArrayBinaryQIFReferenceFullType (const ArrayBinaryQIFReferenceFullType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ArrayBinaryQIFReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayBinaryQIFReferenceFullType&
      operator= (const ArrayBinaryQIFReferenceFullType& x);

      virtual 
      ~ArrayBinaryQIFReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      asmPathId_optional asmPathId_;
      asmPathXId_optional asmPathXId_;
    };

    class QIF30_SYMBOL_DECL QIFReferenceActiveType: public ::xsd::qif30::QIFReferenceType
    {
      public:
      // active
      //
      typedef ::xml_schema::boolean active_type;
      typedef ::xsd::cxx::tree::traits< active_type, wchar_t > active_traits;

      const active_type&
      active () const;

      active_type&
      active ();

      void
      active (const active_type& x);

      static active_type
      active_default_value ();

      // Constructors.
      //
      QIFReferenceActiveType ();

      QIFReferenceActiveType (const ::xml_schema::unsigned_int&);

      QIFReferenceActiveType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      QIFReferenceActiveType (const QIFReferenceActiveType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual QIFReferenceActiveType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFReferenceActiveType&
      operator= (const QIFReferenceActiveType& x);

      virtual 
      ~QIFReferenceActiveType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< active_type > active_;
    };

    class QIF30_SYMBOL_DECL QIFReferenceFullType: public ::xsd::qif30::QIFReferenceType
    {
      public:
      // asmPathId
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType asmPathId_type;
      typedef ::xsd::cxx::tree::optional< asmPathId_type > asmPathId_optional;
      typedef ::xsd::cxx::tree::traits< asmPathId_type, wchar_t > asmPathId_traits;

      const asmPathId_optional&
      asmPathId () const;

      asmPathId_optional&
      asmPathId ();

      void
      asmPathId (const asmPathId_type& x);

      void
      asmPathId (const asmPathId_optional& x);

      void
      asmPathId (::std::unique_ptr< asmPathId_type > p);

      // asmPathXId
      //
      typedef ::xsd::qif30::QIFReferenceSimpleType asmPathXId_type;
      typedef ::xsd::cxx::tree::optional< asmPathXId_type > asmPathXId_optional;
      typedef ::xsd::cxx::tree::traits< asmPathXId_type, wchar_t > asmPathXId_traits;

      const asmPathXId_optional&
      asmPathXId () const;

      asmPathXId_optional&
      asmPathXId ();

      void
      asmPathXId (const asmPathXId_type& x);

      void
      asmPathXId (const asmPathXId_optional& x);

      void
      asmPathXId (::std::unique_ptr< asmPathXId_type > p);

      // Constructors.
      //
      QIFReferenceFullType ();

      QIFReferenceFullType (const ::xml_schema::unsigned_int&);

      QIFReferenceFullType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      QIFReferenceFullType (const QIFReferenceFullType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual QIFReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFReferenceFullType&
      operator= (const QIFReferenceFullType& x);

      virtual 
      ~QIFReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      asmPathId_optional asmPathId_;
      asmPathXId_optional asmPathXId_;
    };

    class QIF30_SYMBOL_DECL ElementReferenceType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif30::QIFReferenceType Id_type;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_type&
      Id () const;

      Id_type&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      ElementReferenceType ();

      ElementReferenceType (const Id_type&);

      ElementReferenceType (::std::unique_ptr< Id_type >);

      ElementReferenceType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ElementReferenceType (const ElementReferenceType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ElementReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElementReferenceType&
      operator= (const ElementReferenceType& x);

      virtual 
      ~ElementReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Id_type > Id_;
    };

    class QIF30_SYMBOL_DECL ElementReferenceFullType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif30::QIFReferenceFullType Id_type;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_type&
      Id () const;

      Id_type&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      ElementReferenceFullType ();

      ElementReferenceFullType (const Id_type&);

      ElementReferenceFullType (::std::unique_ptr< Id_type >);

      ElementReferenceFullType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ElementReferenceFullType (const ElementReferenceFullType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ElementReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElementReferenceFullType&
      operator= (const ElementReferenceFullType& x);

      virtual 
      ~ElementReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Id_type > Id_;
    };

    class QIF30_SYMBOL_DECL D4Type: public ::xsd::qif30::ListDoubleType
    {
      public:
      // Constructors.
      //
      D4Type ();

      D4Type (const ::xsd::qif30::ListDoubleType&);

      D4Type (const xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D4Type (const xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D4Type (const ::std::wstring& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D4Type (const D4Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual D4Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      D4Type&
      operator= (const D4Type&) = default;
#endif

      virtual 
      ~D4Type ();
    };

    class QIF30_SYMBOL_DECL NaturalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      NaturalType ();

      NaturalType (const ::xml_schema::unsigned_int&);

      NaturalType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NaturalType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NaturalType (const ::std::wstring& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NaturalType (const NaturalType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual NaturalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      NaturalType&
      operator= (const NaturalType&) = default;
#endif

      virtual 
      ~NaturalType ();
    };

    class QIF30_SYMBOL_DECL ListNaturalType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t >
    {
      public:
      ListNaturalType ();

      ListNaturalType (size_type n, const ::xsd::qif30::NaturalType& x);

      template < typename I >
      ListNaturalType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t > (begin, end, this)
      {
      }

      ListNaturalType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListNaturalType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListNaturalType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListNaturalType (const ListNaturalType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ListNaturalType&
      operator= (const ListNaturalType&) = default;
#endif

      virtual ListNaturalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListNaturalType ();
    };

    class QIF30_SYMBOL_DECL Natural2Type: public ::xsd::qif30::ListNaturalType
    {
      public:
      // Constructors.
      //
      Natural2Type ();

      Natural2Type (const ::xsd::qif30::ListNaturalType&);

      Natural2Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      Natural2Type (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      Natural2Type (const ::std::wstring& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      Natural2Type (const Natural2Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual Natural2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      Natural2Type&
      operator= (const Natural2Type&) = default;
#endif

      virtual 
      ~Natural2Type ();
    };

    class QIF30_SYMBOL_DECL ArrayNaturalType: public ::xsd::qif30::ListNaturalType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // Constructors.
      //
      ArrayNaturalType ();

      ArrayNaturalType (const count_type&);

      ArrayNaturalType (const ::xsd::qif30::ListNaturalType&,
                        const count_type&);

      ArrayNaturalType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ArrayNaturalType (const ArrayNaturalType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ArrayNaturalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayNaturalType&
      operator= (const ArrayNaturalType& x);

      virtual 
      ~ArrayNaturalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class QIF30_SYMBOL_DECL FractionType: public ::xml_schema::type
    {
      public:
      // Numerator
      //
      typedef ::xsd::qif30::NaturalType Numerator_type;
      typedef ::xsd::cxx::tree::traits< Numerator_type, wchar_t > Numerator_traits;

      const Numerator_type&
      Numerator () const;

      Numerator_type&
      Numerator ();

      void
      Numerator (const Numerator_type& x);

      void
      Numerator (::std::unique_ptr< Numerator_type > p);

      // Denominator
      //
      typedef ::xsd::qif30::NaturalType Denominator_type;
      typedef ::xsd::cxx::tree::traits< Denominator_type, wchar_t > Denominator_traits;

      const Denominator_type&
      Denominator () const;

      Denominator_type&
      Denominator ();

      void
      Denominator (const Denominator_type& x);

      void
      Denominator (::std::unique_ptr< Denominator_type > p);

      // Constructors.
      //
      FractionType ();

      FractionType (const Numerator_type&,
                    const Denominator_type&);

      FractionType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      FractionType (const FractionType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual FractionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FractionType&
      operator= (const FractionType& x);

      virtual 
      ~FractionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Numerator_type > Numerator_;
      ::xsd::cxx::tree::one< Denominator_type > Denominator_;
    };

    class QIF30_SYMBOL_DECL ArrayReferenceType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif30::QIFReferenceType Id_type;
      typedef ::xsd::cxx::tree::sequence< Id_type > Id_sequence;
      typedef xsd::cxx::tree::sequence< Id_type >::iterator Id_iterator;
      typedef xsd::cxx::tree::sequence< Id_type >::const_iterator Id_const_iterator;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_sequence&
      Id () const;

      Id_sequence&
      Id ();

      void
      Id (const Id_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArrayReferenceType ();

      ArrayReferenceType (const n_type&);

      ArrayReferenceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ArrayReferenceType (const ArrayReferenceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ArrayReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayReferenceType&
      operator= (const ArrayReferenceType& x);

      virtual 
      ~ArrayReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Id_sequence Id_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ArrayReferenceActiveType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif30::QIFReferenceActiveType Id_type;
      typedef ::xsd::cxx::tree::sequence< Id_type > Id_sequence;
      typedef xsd::cxx::tree::sequence< Id_type >::iterator Id_iterator;
      typedef xsd::cxx::tree::sequence< Id_type >::const_iterator Id_const_iterator;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_sequence&
      Id () const;

      Id_sequence&
      Id ();

      void
      Id (const Id_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArrayReferenceActiveType ();

      ArrayReferenceActiveType (const n_type&);

      ArrayReferenceActiveType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ArrayReferenceActiveType (const ArrayReferenceActiveType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ArrayReferenceActiveType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayReferenceActiveType&
      operator= (const ArrayReferenceActiveType& x);

      virtual 
      ~ArrayReferenceActiveType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Id_sequence Id_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ArrayReferenceFullType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif30::QIFReferenceFullType Id_type;
      typedef ::xsd::cxx::tree::sequence< Id_type > Id_sequence;
      typedef xsd::cxx::tree::sequence< Id_type >::iterator Id_iterator;
      typedef xsd::cxx::tree::sequence< Id_type >::const_iterator Id_const_iterator;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_sequence&
      Id () const;

      Id_sequence&
      Id ();

      void
      Id (const Id_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArrayReferenceFullType ();

      ArrayReferenceFullType (const n_type&);

      ArrayReferenceFullType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ArrayReferenceFullType (const ArrayReferenceFullType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ArrayReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayReferenceFullType&
      operator= (const ArrayReferenceFullType& x);

      virtual 
      ~ArrayReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Id_sequence Id_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL QIFFeaturePairType: public ::xml_schema::type
    {
      public:
      // FirstFeature
      //
      typedef ::xsd::qif30::QIFReferenceFullType FirstFeature_type;
      typedef ::xsd::cxx::tree::traits< FirstFeature_type, wchar_t > FirstFeature_traits;

      const FirstFeature_type&
      FirstFeature () const;

      FirstFeature_type&
      FirstFeature ();

      void
      FirstFeature (const FirstFeature_type& x);

      void
      FirstFeature (::std::unique_ptr< FirstFeature_type > p);

      // SecondFeature
      //
      typedef ::xsd::qif30::QIFReferenceFullType SecondFeature_type;
      typedef ::xsd::cxx::tree::traits< SecondFeature_type, wchar_t > SecondFeature_traits;

      const SecondFeature_type&
      SecondFeature () const;

      SecondFeature_type&
      SecondFeature ();

      void
      SecondFeature (const SecondFeature_type& x);

      void
      SecondFeature (::std::unique_ptr< SecondFeature_type > p);

      // FirstFeatureZone
      //
      typedef ::xsd::qif30::QIFReferenceFullType FirstFeatureZone_type;
      typedef ::xsd::cxx::tree::optional< FirstFeatureZone_type > FirstFeatureZone_optional;
      typedef ::xsd::cxx::tree::traits< FirstFeatureZone_type, wchar_t > FirstFeatureZone_traits;

      const FirstFeatureZone_optional&
      FirstFeatureZone () const;

      FirstFeatureZone_optional&
      FirstFeatureZone ();

      void
      FirstFeatureZone (const FirstFeatureZone_type& x);

      void
      FirstFeatureZone (const FirstFeatureZone_optional& x);

      void
      FirstFeatureZone (::std::unique_ptr< FirstFeatureZone_type > p);

      // SecondFeatureZone
      //
      typedef ::xsd::qif30::QIFReferenceFullType SecondFeatureZone_type;
      typedef ::xsd::cxx::tree::optional< SecondFeatureZone_type > SecondFeatureZone_optional;
      typedef ::xsd::cxx::tree::traits< SecondFeatureZone_type, wchar_t > SecondFeatureZone_traits;

      const SecondFeatureZone_optional&
      SecondFeatureZone () const;

      SecondFeatureZone_optional&
      SecondFeatureZone ();

      void
      SecondFeatureZone (const SecondFeatureZone_type& x);

      void
      SecondFeatureZone (const SecondFeatureZone_optional& x);

      void
      SecondFeatureZone (::std::unique_ptr< SecondFeatureZone_type > p);

      // Constructors.
      //
      QIFFeaturePairType ();

      QIFFeaturePairType (const FirstFeature_type&,
                          const SecondFeature_type&);

      QIFFeaturePairType (::std::unique_ptr< FirstFeature_type >,
                          ::std::unique_ptr< SecondFeature_type >);

      QIFFeaturePairType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      QIFFeaturePairType (const QIFFeaturePairType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual QIFFeaturePairType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFFeaturePairType&
      operator= (const QIFFeaturePairType& x);

      virtual 
      ~QIFFeaturePairType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FirstFeature_type > FirstFeature_;
      ::xsd::cxx::tree::one< SecondFeature_type > SecondFeature_;
      FirstFeatureZone_optional FirstFeatureZone_;
      SecondFeatureZone_optional SecondFeatureZone_;
    };

    class QIF30_SYMBOL_DECL ArrayPairReferenceFullType: public ::xml_schema::type
    {
      public:
      // FeaturePair
      //
      typedef ::xsd::qif30::QIFFeaturePairType FeaturePair_type;
      typedef ::xsd::cxx::tree::sequence< FeaturePair_type > FeaturePair_sequence;
      typedef xsd::cxx::tree::sequence< FeaturePair_type >::iterator FeaturePair_iterator;
      typedef xsd::cxx::tree::sequence< FeaturePair_type >::const_iterator FeaturePair_const_iterator;
      typedef ::xsd::cxx::tree::traits< FeaturePair_type, wchar_t > FeaturePair_traits;

      const FeaturePair_sequence&
      FeaturePair () const;

      FeaturePair_sequence&
      FeaturePair ();

      void
      FeaturePair (const FeaturePair_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArrayPairReferenceFullType ();

      ArrayPairReferenceFullType (const n_type&);

      ArrayPairReferenceFullType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ArrayPairReferenceFullType (const ArrayPairReferenceFullType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ArrayPairReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayPairReferenceFullType&
      operator= (const ArrayPairReferenceFullType& x);

      virtual 
      ~ArrayPairReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeaturePair_sequence FeaturePair_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ListUnsignedByteType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t >
    {
      public:
      ListUnsignedByteType ();

      ListUnsignedByteType (size_type n, const ::xml_schema::unsigned_byte& x);

      template < typename I >
      ListUnsignedByteType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t > (begin, end, this)
      {
      }

      ListUnsignedByteType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ListUnsignedByteType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ListUnsignedByteType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ListUnsignedByteType (const ListUnsignedByteType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ListUnsignedByteType&
      operator= (const ListUnsignedByteType&) = default;
#endif

      virtual ListUnsignedByteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListUnsignedByteType ();
    };

    class QIF30_SYMBOL_DECL QPIdType: public ::xml_schema::token
    {
      public:
      // Constructors.
      //
      QPIdType ();

      QPIdType (const wchar_t*);

      QPIdType (const ::std::wstring&);

      QPIdType (const ::xml_schema::token&);

      QPIdType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      QPIdType (const xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      QPIdType (const ::std::wstring& s,
                const xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      QPIdType (const QPIdType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual QPIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      QPIdType&
      operator= (const QPIdType&) = default;
#endif

      virtual 
      ~QPIdType ();
    };

    class QIF30_SYMBOL_DECL QPIdReferenceType: public ::xml_schema::token
    {
      public:
      // Constructors.
      //
      QPIdReferenceType ();

      QPIdReferenceType (const wchar_t*);

      QPIdReferenceType (const ::std::wstring&);

      QPIdReferenceType (const ::xml_schema::token&);

      QPIdReferenceType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      QPIdReferenceType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      QPIdReferenceType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      QPIdReferenceType (const QPIdReferenceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual QPIdReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      QPIdReferenceType&
      operator= (const QPIdReferenceType&) = default;
#endif

      virtual 
      ~QPIdReferenceType ();
    };

    class QIF30_SYMBOL_DECL QPIdFullReferenceType: public ::xml_schema::type
    {
      public:
      // ItemQPId
      //
      typedef ::xsd::qif30::QPIdReferenceType ItemQPId_type;
      typedef ::xsd::cxx::tree::traits< ItemQPId_type, wchar_t > ItemQPId_traits;

      const ItemQPId_type&
      ItemQPId () const;

      ItemQPId_type&
      ItemQPId ();

      void
      ItemQPId (const ItemQPId_type& x);

      void
      ItemQPId (::std::unique_ptr< ItemQPId_type > p);

      // DocumentQPId
      //
      typedef ::xsd::qif30::QPIdReferenceType DocumentQPId_type;
      typedef ::xsd::cxx::tree::sequence< DocumentQPId_type > DocumentQPId_sequence;
      typedef xsd::cxx::tree::sequence< DocumentQPId_type >::iterator DocumentQPId_iterator;
      typedef xsd::cxx::tree::sequence< DocumentQPId_type >::const_iterator DocumentQPId_const_iterator;
      typedef ::xsd::cxx::tree::traits< DocumentQPId_type, wchar_t > DocumentQPId_traits;

      const DocumentQPId_sequence&
      DocumentQPId () const;

      DocumentQPId_sequence&
      DocumentQPId ();

      void
      DocumentQPId (const DocumentQPId_sequence& s);

      // Constructors.
      //
      QPIdFullReferenceType ();

      QPIdFullReferenceType (const ItemQPId_type&);

      QPIdFullReferenceType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      QPIdFullReferenceType (const QPIdFullReferenceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual QPIdFullReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QPIdFullReferenceType&
      operator= (const QPIdFullReferenceType& x);

      virtual 
      ~QPIdFullReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ItemQPId_type > ItemQPId_;
      DocumentQPId_sequence DocumentQPId_;
    };

    class QIF30_SYMBOL_DECL ArrayQPIdFullReferenceType: public ::xml_schema::type
    {
      public:
      // QPId
      //
      typedef ::xsd::qif30::QPIdFullReferenceType QPId_type;
      typedef ::xsd::cxx::tree::sequence< QPId_type > QPId_sequence;
      typedef xsd::cxx::tree::sequence< QPId_type >::iterator QPId_iterator;
      typedef xsd::cxx::tree::sequence< QPId_type >::const_iterator QPId_const_iterator;
      typedef ::xsd::cxx::tree::traits< QPId_type, wchar_t > QPId_traits;

      const QPId_sequence&
      QPId () const;

      QPId_sequence&
      QPId ();

      void
      QPId (const QPId_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArrayQPIdFullReferenceType ();

      ArrayQPIdFullReferenceType (const n_type&);

      ArrayQPIdFullReferenceType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ArrayQPIdFullReferenceType (const ArrayQPIdFullReferenceType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ArrayQPIdFullReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayQPIdFullReferenceType&
      operator= (const ArrayQPIdFullReferenceType& x);

      virtual 
      ~ArrayQPIdFullReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      QPId_sequence QPId_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ArrayUnsignedByteType: public ::xsd::qif30::ListUnsignedByteType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // Constructors.
      //
      ArrayUnsignedByteType ();

      ArrayUnsignedByteType (const count_type&);

      ArrayUnsignedByteType (const ::xsd::qif30::ListUnsignedByteType&,
                             const count_type&);

      ArrayUnsignedByteType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ArrayUnsignedByteType (const ArrayUnsignedByteType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual ArrayUnsignedByteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayUnsignedByteType&
      operator= (const ArrayUnsignedByteType& x);

      virtual 
      ~ArrayUnsignedByteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class QIF30_SYMBOL_DECL ArrayIntType: public ::xsd::qif30::ListIntType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // Constructors.
      //
      ArrayIntType ();

      ArrayIntType (const count_type&);

      ArrayIntType (const ::xsd::qif30::ListIntType&,
                    const count_type&);

      ArrayIntType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ArrayIntType (const ArrayIntType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ArrayIntType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayIntType&
      operator= (const ArrayIntType& x);

      virtual 
      ~ArrayIntType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class QIF30_SYMBOL_DECL ArrayI2Type: public ::xsd::qif30::ListIntType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // Constructors.
      //
      ArrayI2Type ();

      ArrayI2Type (const count_type&);

      ArrayI2Type (const ::xsd::qif30::ListIntType&,
                   const count_type&);

      ArrayI2Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ArrayI2Type (const ArrayI2Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ArrayI2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayI2Type&
      operator= (const ArrayI2Type& x);

      virtual 
      ~ArrayI2Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class QIF30_SYMBOL_DECL ArrayI3Type: public ::xsd::qif30::ListIntType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // Constructors.
      //
      ArrayI3Type ();

      ArrayI3Type (const count_type&);

      ArrayI3Type (const ::xsd::qif30::ListIntType&,
                   const count_type&);

      ArrayI3Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ArrayI3Type (const ArrayI3Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ArrayI3Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayI3Type&
      operator= (const ArrayI3Type& x);

      virtual 
      ~ArrayI3Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class QIF30_SYMBOL_DECL ArrayDoubleType: public ::xsd::qif30::ListDoubleType
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // Constructors.
      //
      ArrayDoubleType ();

      ArrayDoubleType (const count_type&);

      ArrayDoubleType (const ::xsd::qif30::ListDoubleType&,
                       const count_type&);

      ArrayDoubleType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ArrayDoubleType (const ArrayDoubleType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ArrayDoubleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayDoubleType&
      operator= (const ArrayDoubleType& x);

      virtual 
      ~ArrayDoubleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
    };

    class QIF30_SYMBOL_DECL ArrayBinaryType: public ::xml_schema::base64_binary
    {
      public:
      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // sizeElement
      //
      typedef ::xml_schema::unsigned_int sizeElement_type;
      typedef ::xsd::cxx::tree::traits< sizeElement_type, wchar_t > sizeElement_traits;

      const sizeElement_type&
      sizeElement () const;

      sizeElement_type&
      sizeElement ();

      void
      sizeElement (const sizeElement_type& x);

      // Constructors.
      //
      ArrayBinaryType ();

      ArrayBinaryType (const count_type&,
                       const sizeElement_type&);

      ArrayBinaryType (const ::xml_schema::base64_binary&,
                       const count_type&,
                       const sizeElement_type&);

      ArrayBinaryType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ArrayBinaryType (const ArrayBinaryType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ArrayBinaryType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayBinaryType&
      operator= (const ArrayBinaryType& x);

      virtual 
      ~ArrayBinaryType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< count_type > count_;
      ::xsd::cxx::tree::one< sizeElement_type > sizeElement_;
    };

    class QIF30_SYMBOL_DECL AttributesType: public ::xml_schema::type
    {
      public:
      // Attribute
      //
      typedef ::xsd::qif30::AttributeBaseType Attribute_type;
      typedef ::xsd::cxx::tree::sequence< Attribute_type > Attribute_sequence;
      typedef xsd::cxx::tree::sequence< Attribute_type >::iterator Attribute_iterator;
      typedef xsd::cxx::tree::sequence< Attribute_type >::const_iterator Attribute_const_iterator;
      typedef ::xsd::cxx::tree::traits< Attribute_type, wchar_t > Attribute_traits;

      const Attribute_sequence&
      Attribute () const;

      Attribute_sequence&
      Attribute ();

      void
      Attribute (const Attribute_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AttributesType ();

      AttributesType (const n_type&);

      AttributesType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      AttributesType (const AttributesType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual AttributesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributesType&
      operator= (const AttributesType& x);

      virtual 
      ~AttributesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attribute_sequence Attribute_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AttributeBaseType: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, wchar_t > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::unique_ptr< name_type > p);

      // Constructors.
      //
      AttributeBaseType ();

      AttributeBaseType (const name_type&);

      AttributeBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeBaseType (const AttributeBaseType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      AttributeBaseType&
      operator= (const AttributeBaseType& x);

      virtual 
      ~AttributeBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
    };

    class QIF30_SYMBOL_DECL AttributeBoolType: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::boolean value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      // Constructors.
      //
      AttributeBoolType ();

      AttributeBoolType (const name_type&,
                         const value_type&);

      AttributeBoolType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeBoolType (const AttributeBoolType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeBoolType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeBoolType&
      operator= (const AttributeBoolType& x);

      virtual 
      ~AttributeBoolType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeStrType: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::string value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::unique_ptr< value_type > p);

      // Constructors.
      //
      AttributeStrType ();

      AttributeStrType (const name_type&,
                        const value_type&);

      AttributeStrType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      AttributeStrType (const AttributeStrType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual AttributeStrType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeStrType&
      operator= (const AttributeStrType& x);

      virtual 
      ~AttributeStrType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeTimeType: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::date_time value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::unique_ptr< value_type > p);

      // Constructors.
      //
      AttributeTimeType ();

      AttributeTimeType (const name_type&,
                         const value_type&);

      AttributeTimeType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeTimeType (const AttributeTimeType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeTimeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeTimeType&
      operator= (const AttributeTimeType& x);

      virtual 
      ~AttributeTimeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeQPIdType: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // Value
      //
      typedef ::xsd::qif30::QPIdType Value_type;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_type&
      Value () const;

      Value_type&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // Constructors.
      //
      AttributeQPIdType ();

      AttributeQPIdType (const name_type&,
                         const Value_type&);

      AttributeQPIdType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeQPIdType (const AttributeQPIdType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeQPIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeQPIdType&
      operator= (const AttributeQPIdType& x);

      virtual 
      ~AttributeQPIdType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Value_type > Value_;
    };

    class QIF30_SYMBOL_DECL AttributeI1Type: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::integer value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      // Constructors.
      //
      AttributeI1Type ();

      AttributeI1Type (const name_type&,
                       const value_type&);

      AttributeI1Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeI1Type (const AttributeI1Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeI1Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeI1Type&
      operator= (const AttributeI1Type& x);

      virtual 
      ~AttributeI1Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeI2Type: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xsd::qif30::I2Type value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::unique_ptr< value_type > p);

      // Constructors.
      //
      AttributeI2Type ();

      AttributeI2Type (const name_type&,
                       const value_type&);

      AttributeI2Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeI2Type (const AttributeI2Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeI2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeI2Type&
      operator= (const AttributeI2Type& x);

      virtual 
      ~AttributeI2Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeI3Type: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xsd::qif30::I3Type value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::unique_ptr< value_type > p);

      // Constructors.
      //
      AttributeI3Type ();

      AttributeI3Type (const name_type&,
                       const value_type&);

      AttributeI3Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeI3Type (const AttributeI3Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeI3Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeI3Type&
      operator= (const AttributeI3Type& x);

      virtual 
      ~AttributeI3Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeD1Type: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::double_ value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      // Constructors.
      //
      AttributeD1Type ();

      AttributeD1Type (const name_type&,
                       const value_type&);

      AttributeD1Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeD1Type (const AttributeD1Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeD1Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeD1Type&
      operator= (const AttributeD1Type& x);

      virtual 
      ~AttributeD1Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeD2Type: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xsd::qif30::D2Type value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::unique_ptr< value_type > p);

      // Constructors.
      //
      AttributeD2Type ();

      AttributeD2Type (const name_type&,
                       const value_type&);

      AttributeD2Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeD2Type (const AttributeD2Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeD2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeD2Type&
      operator= (const AttributeD2Type& x);

      virtual 
      ~AttributeD2Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeD3Type: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xsd::qif30::D3Type value_type;
      typedef ::xsd::cxx::tree::traits< value_type, wchar_t > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::unique_ptr< value_type > p);

      // Constructors.
      //
      AttributeD3Type ();

      AttributeD3Type (const name_type&,
                       const value_type&);

      AttributeD3Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeD3Type (const AttributeD3Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeD3Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeD3Type&
      operator= (const AttributeD3Type& x);

      virtual 
      ~AttributeD3Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class QIF30_SYMBOL_DECL AttributeUserType: public ::xsd::qif30::AttributeBaseType
    {
      public:
      // UserDataXML
      //
      typedef ::xsd::qif30::UserDataXMLType UserDataXML_type;
      typedef ::xsd::cxx::tree::optional< UserDataXML_type > UserDataXML_optional;
      typedef ::xsd::cxx::tree::traits< UserDataXML_type, wchar_t > UserDataXML_traits;

      const UserDataXML_optional&
      UserDataXML () const;

      UserDataXML_optional&
      UserDataXML ();

      void
      UserDataXML (const UserDataXML_type& x);

      void
      UserDataXML (const UserDataXML_optional& x);

      void
      UserDataXML (::std::unique_ptr< UserDataXML_type > p);

      // UserDataBinary
      //
      typedef ::xsd::qif30::BinaryDataType UserDataBinary_type;
      typedef ::xsd::cxx::tree::optional< UserDataBinary_type > UserDataBinary_optional;
      typedef ::xsd::cxx::tree::traits< UserDataBinary_type, wchar_t > UserDataBinary_traits;

      const UserDataBinary_optional&
      UserDataBinary () const;

      UserDataBinary_optional&
      UserDataBinary ();

      void
      UserDataBinary (const UserDataBinary_type& x);

      void
      UserDataBinary (const UserDataBinary_optional& x);

      void
      UserDataBinary (::std::unique_ptr< UserDataBinary_type > p);

      // nameUserAttribute
      //
      typedef ::xml_schema::string nameUserAttribute_type;
      typedef ::xsd::cxx::tree::traits< nameUserAttribute_type, wchar_t > nameUserAttribute_traits;

      const nameUserAttribute_type&
      nameUserAttribute () const;

      nameUserAttribute_type&
      nameUserAttribute ();

      void
      nameUserAttribute (const nameUserAttribute_type& x);

      void
      nameUserAttribute (::std::unique_ptr< nameUserAttribute_type > p);

      // Constructors.
      //
      AttributeUserType ();

      AttributeUserType (const name_type&,
                         const nameUserAttribute_type&);

      AttributeUserType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeUserType (const AttributeUserType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeUserType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeUserType&
      operator= (const AttributeUserType& x);

      virtual 
      ~AttributeUserType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      UserDataXML_optional UserDataXML_;
      UserDataBinary_optional UserDataBinary_;
      ::xsd::cxx::tree::one< nameUserAttribute_type > nameUserAttribute_;
    };

    class QIF30_SYMBOL_DECL UserDataXMLType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      UserDataXMLType ();

      UserDataXMLType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      UserDataXMLType (const UserDataXMLType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual UserDataXMLType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      UserDataXMLType&
      operator= (const UserDataXMLType&) = default;
#endif

      virtual 
      ~UserDataXMLType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
    };

    class QIF30_SYMBOL_DECL ValidationPointsType: public ::xml_schema::type
    {
      public:
      // Points
      //
      typedef ::xsd::qif30::ArrayPointType Points_type;
      typedef ::xsd::cxx::tree::optional< Points_type > Points_optional;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_optional&
      Points () const;

      Points_optional&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (const Points_optional& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // PointsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType PointsBinary_type;
      typedef ::xsd::cxx::tree::optional< PointsBinary_type > PointsBinary_optional;
      typedef ::xsd::cxx::tree::traits< PointsBinary_type, wchar_t > PointsBinary_traits;

      const PointsBinary_optional&
      PointsBinary () const;

      PointsBinary_optional&
      PointsBinary ();

      void
      PointsBinary (const PointsBinary_type& x);

      void
      PointsBinary (const PointsBinary_optional& x);

      void
      PointsBinary (::std::unique_ptr< PointsBinary_type > p);

      // Directions
      //
      typedef ::xsd::qif30::ArrayUnitVectorType Directions_type;
      typedef ::xsd::cxx::tree::optional< Directions_type > Directions_optional;
      typedef ::xsd::cxx::tree::traits< Directions_type, wchar_t > Directions_traits;

      const Directions_optional&
      Directions () const;

      Directions_optional&
      Directions ();

      void
      Directions (const Directions_type& x);

      void
      Directions (const Directions_optional& x);

      void
      Directions (::std::unique_ptr< Directions_type > p);

      // DirectionsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType DirectionsBinary_type;
      typedef ::xsd::cxx::tree::optional< DirectionsBinary_type > DirectionsBinary_optional;
      typedef ::xsd::cxx::tree::traits< DirectionsBinary_type, wchar_t > DirectionsBinary_traits;

      const DirectionsBinary_optional&
      DirectionsBinary () const;

      DirectionsBinary_optional&
      DirectionsBinary ();

      void
      DirectionsBinary (const DirectionsBinary_type& x);

      void
      DirectionsBinary (const DirectionsBinary_optional& x);

      void
      DirectionsBinary (::std::unique_ptr< DirectionsBinary_type > p);

      // Constructors.
      //
      ValidationPointsType ();

      ValidationPointsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ValidationPointsType (const ValidationPointsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ValidationPointsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidationPointsType&
      operator= (const ValidationPointsType& x);

      virtual 
      ~ValidationPointsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Points_optional Points_;
      PointsBinary_optional PointsBinary_;
      Directions_optional Directions_;
      DirectionsBinary_optional DirectionsBinary_;
    };

    class QIF30_SYMBOL_DECL BoundingBoxAxisAlignedType: public ::xml_schema::type
    {
      public:
      // PointMin
      //
      typedef ::xsd::qif30::PointSimpleType PointMin_type;
      typedef ::xsd::cxx::tree::traits< PointMin_type, wchar_t > PointMin_traits;

      const PointMin_type&
      PointMin () const;

      PointMin_type&
      PointMin ();

      void
      PointMin (const PointMin_type& x);

      void
      PointMin (::std::unique_ptr< PointMin_type > p);

      // PointMax
      //
      typedef ::xsd::qif30::PointSimpleType PointMax_type;
      typedef ::xsd::cxx::tree::traits< PointMax_type, wchar_t > PointMax_traits;

      const PointMax_type&
      PointMax () const;

      PointMax_type&
      PointMax ();

      void
      PointMax (const PointMax_type& x);

      void
      PointMax (::std::unique_ptr< PointMax_type > p);

      // Constructors.
      //
      BoundingBoxAxisAlignedType ();

      BoundingBoxAxisAlignedType (const PointMin_type&,
                                  const PointMax_type&);

      BoundingBoxAxisAlignedType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      BoundingBoxAxisAlignedType (const BoundingBoxAxisAlignedType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual BoundingBoxAxisAlignedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BoundingBoxAxisAlignedType&
      operator= (const BoundingBoxAxisAlignedType& x);

      virtual 
      ~BoundingBoxAxisAlignedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PointMin_type > PointMin_;
      ::xsd::cxx::tree::one< PointMax_type > PointMax_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BinaryDataType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListIntType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ListIntType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ListIntType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const I2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const I2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const I2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const I3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const I3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const I3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListDoubleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ListDoubleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ListDoubleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListBooleanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ListBooleanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ListBooleanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListDateTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ListDateTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ListDateTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListTokenType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ListTokenType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ListTokenType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const D3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const D3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const D3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const D2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const D2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const D2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DoublePositiveType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DoublePositiveType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DoublePositiveType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Point2dSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const Point2dSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const Point2dSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UnitVector2dSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const UnitVector2dSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const UnitVector2dSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ParameterRangeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ParameterRangeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ParameterRangeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PointSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PointSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VectorSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const VectorSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const VectorSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UnitVectorSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const UnitVectorSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const UnitVectorSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ValidityEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ValidityEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ValidityEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VectorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UnitVectorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayPoint2dType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayPointType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayUnitVectorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PolyLineType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneXType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AxisType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TransformRotationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateSystemCoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TransformMatrixType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineSegmentType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineSegment2dType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LatitudeLongitudeSweepType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientedLatitudeLongitudeSweepType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SweepType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleRangeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFIdAndReferenceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const QIFIdAndReferenceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const QIFIdAndReferenceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const QIFIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const QIFIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFReferenceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const QIFReferenceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const QIFReferenceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFReferenceSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const QIFReferenceSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const QIFReferenceSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListQIFReferenceSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ListQIFReferenceSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ListQIFReferenceSimpleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListQIFReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListQIFReferenceFullType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayBinaryQIFReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayBinaryQIFReferenceFullType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFReferenceActiveType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFReferenceFullType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElementReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElementReferenceFullType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const D4Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const D4Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const D4Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NaturalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const NaturalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const NaturalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListNaturalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ListNaturalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ListNaturalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Natural2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const Natural2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const Natural2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayNaturalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FractionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayReferenceActiveType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayReferenceFullType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QIFFeaturePairType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayPairReferenceFullType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ListUnsignedByteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ListUnsignedByteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ListUnsignedByteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QPIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const QPIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const QPIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QPIdReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const QPIdReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const QPIdReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const QPIdFullReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayQPIdFullReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayUnsignedByteType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayIntType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayI2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayI3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayDoubleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayBinaryType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeBoolType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeStrType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeQPIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeI1Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeI2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeI3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeD1Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeD2Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeD3Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AttributeUserType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDataXMLType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ValidationPointsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BoundingBoxAxisAlignedType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_PRIMITIVES_HXX
