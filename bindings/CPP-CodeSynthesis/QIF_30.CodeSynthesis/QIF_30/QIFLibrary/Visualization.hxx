// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_VISUALIZATION_HXX
#define CXX___QIFLIBRARY_VISUALIZATION_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class VisualizationSetType;
    class FontsType;
    class AlignmentEnumType;
    class FontType;
    class PMIDisplaySetType;
    class PMIDisplayType;
    class PlanePMIDisplayType;
    class Polylines2dType;
    class Polyline2dType;
    class Areas2dType;
    class Area2dType;
    class Loops2dType;
    class Triangulation2dType;
    class GraphicsType;
    class LeaderType;
    class LeaderExtendType;
    class LeaderDoubleHeadType;
    class LeaderDoubleHeadExtendType;
    class LeaderCircularType;
    class LeaderDoubleHeadCircularType;
    class TextsType;
    class FramesType;
    class TextType;
    class WitnessLinesType;
    class FrameBaseType;
    class FrameRectangularType;
    class FrameCircularType;
    class FrameFlagType;
    class FrameIrregularFormType;
    class FrameWeldSymbolTailType;
    class WeldMainSymbolEnumType;
    class OriginType;
    class WeldMainSymbolType;
    class WeldSupplementarySymbolType;
    class WeldContourSymbolType;
    class FrameWeldSymbolType;
    class FrameTriangleType;
    class FramePentagonalType;
    class FrameOctagonalType;
    class FrameHexagonalType;
    class LeaderHeadFormEnumType;
    class LeaderHeadFormType;
    class LeaderModifierEnumType;
    class ViewSetType;
    class CameraType;
    class CameraFormEnumType;
    class SavedViewType;
    class ZoneSectionType;
    class LogicalOperationType;
    class LogicalOperationsType;
    class LogicalOperationEnumType;
    class ZoneSectionPlanesType;
    class ZoneSectionPlaneType;
    class SectionGroupsType;
    class SectionGroupType;
    class SectionPathsType;
    class SectionLoopsType;
    class SectionAreasType;
    class SectionAreaType;
    class SectionEdgesType;
    class SectionPathType;
    class HatchPatternsType;
    class HatchStyleType;
    class HatchStyleFormEnumType;
    class HatchPatternType;
    class DisplayStyleType;
    class DisplayStyleGroupsType;
    class DisplayStyleModeType;
    class DisplayStyleGroupType;
    class DisplayStyleFormEnumType;
    class ExplodedViewType;
    class ExplodedViewMoveGroupsType;
    class ExplodedViewMoveGroupType;
    class ExplodedViewTranslateType;
    class ExplodedViewRotateType;
    class SimplifiedRepresentationFormEnumType;
    class SimplifiedRepresentationType;
    class SimplifiedRepresentationGroupsType;
    class SimplifiedRepresentationGroupType;
    class AnnotationViewType;
    class CameraSetType;
    class SavedViewSetType;
    class AnnotationViewSetType;
    class DisplayStyleSetType;
    class ExplodedViewSetType;
    class SimplifiedRepresentationSetType;
    class ZoneSectionSetType;
    class HatchStyleSetType;
    class TrailingZeroDisplayType;
    class TrailingZeroDimensionalCharacteristicDisplayGroupsType;
    class TrailingZeroDimensionalCharacteristicDisplayGroupType;
    class TrailingZeroGeometricCharacteristicDisplayGroupsType;
    class TrailingZeroGeometricCharacteristicDisplayGroupType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/PrimitivesPD.hxx"

#include "../QIFLibrary/Characteristics.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL VisualizationSetType: public ::xml_schema::type
    {
      public:
      // Fonts
      //
      typedef ::xsd::qif30::FontsType Fonts_type;
      typedef ::xsd::cxx::tree::traits< Fonts_type, wchar_t > Fonts_traits;

      const Fonts_type&
      Fonts () const;

      Fonts_type&
      Fonts ();

      void
      Fonts (const Fonts_type& x);

      void
      Fonts (::std::unique_ptr< Fonts_type > p);

      // TrailingZeroDisplay
      //
      typedef ::xsd::qif30::TrailingZeroDisplayType TrailingZeroDisplay_type;
      typedef ::xsd::cxx::tree::optional< TrailingZeroDisplay_type > TrailingZeroDisplay_optional;
      typedef ::xsd::cxx::tree::traits< TrailingZeroDisplay_type, wchar_t > TrailingZeroDisplay_traits;

      const TrailingZeroDisplay_optional&
      TrailingZeroDisplay () const;

      TrailingZeroDisplay_optional&
      TrailingZeroDisplay ();

      void
      TrailingZeroDisplay (const TrailingZeroDisplay_type& x);

      void
      TrailingZeroDisplay (const TrailingZeroDisplay_optional& x);

      void
      TrailingZeroDisplay (::std::unique_ptr< TrailingZeroDisplay_type > p);

      // PMIDisplaySet
      //
      typedef ::xsd::qif30::PMIDisplaySetType PMIDisplaySet_type;
      typedef ::xsd::cxx::tree::traits< PMIDisplaySet_type, wchar_t > PMIDisplaySet_traits;

      const PMIDisplaySet_type&
      PMIDisplaySet () const;

      PMIDisplaySet_type&
      PMIDisplaySet ();

      void
      PMIDisplaySet (const PMIDisplaySet_type& x);

      void
      PMIDisplaySet (::std::unique_ptr< PMIDisplaySet_type > p);

      // Constructors.
      //
      VisualizationSetType ();

      VisualizationSetType (const Fonts_type&,
                            const PMIDisplaySet_type&);

      VisualizationSetType (::std::unique_ptr< Fonts_type >,
                            ::std::unique_ptr< PMIDisplaySet_type >);

      VisualizationSetType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      VisualizationSetType (const VisualizationSetType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual VisualizationSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VisualizationSetType&
      operator= (const VisualizationSetType& x);

      virtual 
      ~VisualizationSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Fonts_type > Fonts_;
      TrailingZeroDisplay_optional TrailingZeroDisplay_;
      ::xsd::cxx::tree::one< PMIDisplaySet_type > PMIDisplaySet_;
    };

    class QIF30_SYMBOL_DECL FontsType: public ::xml_schema::type
    {
      public:
      // Font
      //
      typedef ::xsd::qif30::FontType Font_type;
      typedef ::xsd::cxx::tree::sequence< Font_type > Font_sequence;
      typedef xsd::cxx::tree::sequence< Font_type >::iterator Font_iterator;
      typedef xsd::cxx::tree::sequence< Font_type >::const_iterator Font_const_iterator;
      typedef ::xsd::cxx::tree::traits< Font_type, wchar_t > Font_traits;

      const Font_sequence&
      Font () const;

      Font_sequence&
      Font ();

      void
      Font (const Font_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FontsType ();

      FontsType (const n_type&);

      FontsType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      FontsType (const FontsType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual FontsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FontsType&
      operator= (const FontsType& x);

      virtual 
      ~FontsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Font_sequence Font_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AlignmentEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        ALIGNMENT_LEFT,
        ALIGNMENT_RIGHT,
        ALIGNMENT_CENTER
      };

      AlignmentEnumType ();

      AlignmentEnumType (value v);

      AlignmentEnumType (const wchar_t* v);

      AlignmentEnumType (const ::std::wstring& v);

      AlignmentEnumType (const ::xml_schema::string& v);

      AlignmentEnumType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AlignmentEnumType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AlignmentEnumType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AlignmentEnumType (const AlignmentEnumType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      AlignmentEnumType&
      operator= (const AlignmentEnumType&) = default;
#endif

      virtual AlignmentEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AlignmentEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AlignmentEnumType_convert ();
      }

      protected:
      value
      _xsd_AlignmentEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_AlignmentEnumType_literals_[3];
      static const value _xsd_AlignmentEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL FontType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Size
      //
      typedef ::xsd::qif30::NaturalType Size_type;
      typedef ::xsd::cxx::tree::traits< Size_type, wchar_t > Size_traits;

      const Size_type&
      Size () const;

      Size_type&
      Size ();

      void
      Size (const Size_type& x);

      void
      Size (::std::unique_ptr< Size_type > p);

      // Alignment
      //
      typedef ::xsd::qif30::AlignmentEnumType Alignment_type;
      typedef ::xsd::cxx::tree::optional< Alignment_type > Alignment_optional;
      typedef ::xsd::cxx::tree::traits< Alignment_type, wchar_t > Alignment_traits;

      const Alignment_optional&
      Alignment () const;

      Alignment_optional&
      Alignment ();

      void
      Alignment (const Alignment_type& x);

      void
      Alignment (const Alignment_optional& x);

      void
      Alignment (::std::unique_ptr< Alignment_type > p);

      // index
      //
      typedef ::xml_schema::unsigned_int index_type;
      typedef ::xsd::cxx::tree::traits< index_type, wchar_t > index_traits;

      const index_type&
      index () const;

      index_type&
      index ();

      void
      index (const index_type& x);

      // bold
      //
      typedef ::xml_schema::boolean bold_type;
      typedef ::xsd::cxx::tree::traits< bold_type, wchar_t > bold_traits;

      const bold_type&
      bold () const;

      bold_type&
      bold ();

      void
      bold (const bold_type& x);

      static bold_type
      bold_default_value ();

      // italic
      //
      typedef ::xml_schema::boolean italic_type;
      typedef ::xsd::cxx::tree::traits< italic_type, wchar_t > italic_traits;

      const italic_type&
      italic () const;

      italic_type&
      italic ();

      void
      italic (const italic_type& x);

      static italic_type
      italic_default_value ();

      // underline
      //
      typedef ::xml_schema::boolean underline_type;
      typedef ::xsd::cxx::tree::traits< underline_type, wchar_t > underline_traits;

      const underline_type&
      underline () const;

      underline_type&
      underline ();

      void
      underline (const underline_type& x);

      static underline_type
      underline_default_value ();

      // Constructors.
      //
      FontType ();

      FontType (const Name_type&,
                const Size_type&,
                const index_type&);

      FontType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      FontType (const FontType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual FontType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FontType&
      operator= (const FontType& x);

      virtual 
      ~FontType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< Name_type > Name_;
      ::xsd::cxx::tree::one< Size_type > Size_;
      Alignment_optional Alignment_;
      ::xsd::cxx::tree::one< index_type > index_;
      ::xsd::cxx::tree::one< bold_type > bold_;
      ::xsd::cxx::tree::one< italic_type > italic_;
      ::xsd::cxx::tree::one< underline_type > underline_;
    };

    class QIF30_SYMBOL_DECL PMIDisplaySetType: public ::xml_schema::type
    {
      public:
      // PMIDisplay
      //
      typedef ::xsd::qif30::PMIDisplayType PMIDisplay_type;
      typedef ::xsd::cxx::tree::sequence< PMIDisplay_type > PMIDisplay_sequence;
      typedef xsd::cxx::tree::sequence< PMIDisplay_type >::iterator PMIDisplay_iterator;
      typedef xsd::cxx::tree::sequence< PMIDisplay_type >::const_iterator PMIDisplay_const_iterator;
      typedef ::xsd::cxx::tree::traits< PMIDisplay_type, wchar_t > PMIDisplay_traits;

      const PMIDisplay_sequence&
      PMIDisplay () const;

      PMIDisplay_sequence&
      PMIDisplay ();

      void
      PMIDisplay (const PMIDisplay_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PMIDisplaySetType ();

      PMIDisplaySetType (const n_type&);

      PMIDisplaySetType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PMIDisplaySetType (const PMIDisplaySetType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PMIDisplaySetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PMIDisplaySetType&
      operator= (const PMIDisplaySetType& x);

      virtual 
      ~PMIDisplaySetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PMIDisplay_sequence PMIDisplay_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PMIDisplayType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Color
      //
      typedef ::xsd::qif30::ColorType Color_type;
      typedef ::xsd::cxx::tree::optional< Color_type > Color_optional;
      typedef ::xsd::cxx::tree::traits< Color_type, wchar_t > Color_traits;

      const Color_optional&
      Color () const;

      Color_optional&
      Color ();

      void
      Color (const Color_type& x);

      void
      Color (const Color_optional& x);

      void
      Color (::std::unique_ptr< Color_type > p);

      // Plane
      //
      typedef ::xsd::qif30::PlanePMIDisplayType Plane_type;
      typedef ::xsd::cxx::tree::optional< Plane_type > Plane_optional;
      typedef ::xsd::cxx::tree::traits< Plane_type, wchar_t > Plane_traits;

      const Plane_optional&
      Plane () const;

      Plane_optional&
      Plane ();

      void
      Plane (const Plane_type& x);

      void
      Plane (const Plane_optional& x);

      void
      Plane (::std::unique_ptr< Plane_type > p);

      // Texts
      //
      typedef ::xsd::qif30::TextsType Texts_type;
      typedef ::xsd::cxx::tree::optional< Texts_type > Texts_optional;
      typedef ::xsd::cxx::tree::traits< Texts_type, wchar_t > Texts_traits;

      const Texts_optional&
      Texts () const;

      Texts_optional&
      Texts ();

      void
      Texts (const Texts_type& x);

      void
      Texts (const Texts_optional& x);

      void
      Texts (::std::unique_ptr< Texts_type > p);

      // Leader
      //
      typedef ::xsd::qif30::LeaderType Leader_type;
      typedef ::xsd::cxx::tree::sequence< Leader_type > Leader_sequence;
      typedef xsd::cxx::tree::sequence< Leader_type >::iterator Leader_iterator;
      typedef xsd::cxx::tree::sequence< Leader_type >::const_iterator Leader_const_iterator;
      typedef ::xsd::cxx::tree::traits< Leader_type, wchar_t > Leader_traits;

      const Leader_sequence&
      Leader () const;

      Leader_sequence&
      Leader ();

      void
      Leader (const Leader_sequence& s);

      // WitnessLines
      //
      typedef ::xsd::qif30::WitnessLinesType WitnessLines_type;
      typedef ::xsd::cxx::tree::optional< WitnessLines_type > WitnessLines_optional;
      typedef ::xsd::cxx::tree::traits< WitnessLines_type, wchar_t > WitnessLines_traits;

      const WitnessLines_optional&
      WitnessLines () const;

      WitnessLines_optional&
      WitnessLines ();

      void
      WitnessLines (const WitnessLines_type& x);

      void
      WitnessLines (const WitnessLines_optional& x);

      void
      WitnessLines (::std::unique_ptr< WitnessLines_type > p);

      // Frames
      //
      typedef ::xsd::qif30::FramesType Frames_type;
      typedef ::xsd::cxx::tree::optional< Frames_type > Frames_optional;
      typedef ::xsd::cxx::tree::traits< Frames_type, wchar_t > Frames_traits;

      const Frames_optional&
      Frames () const;

      Frames_optional&
      Frames ();

      void
      Frames (const Frames_type& x);

      void
      Frames (const Frames_optional& x);

      void
      Frames (::std::unique_ptr< Frames_type > p);

      // Graphics
      //
      typedef ::xsd::qif30::GraphicsType Graphics_type;
      typedef ::xsd::cxx::tree::optional< Graphics_type > Graphics_optional;
      typedef ::xsd::cxx::tree::traits< Graphics_type, wchar_t > Graphics_traits;

      const Graphics_optional&
      Graphics () const;

      Graphics_optional&
      Graphics ();

      void
      Graphics (const Graphics_type& x);

      void
      Graphics (const Graphics_optional& x);

      void
      Graphics (::std::unique_ptr< Graphics_type > p);

      // Reference
      //
      typedef ::xsd::qif30::ElementReferenceFullType Reference_type;
      typedef ::xsd::cxx::tree::traits< Reference_type, wchar_t > Reference_traits;

      const Reference_type&
      Reference () const;

      Reference_type&
      Reference ();

      void
      Reference (const Reference_type& x);

      void
      Reference (::std::unique_ptr< Reference_type > p);

      // GroupID
      //
      typedef ::xsd::qif30::I2Type GroupID_type;
      typedef ::xsd::cxx::tree::optional< GroupID_type > GroupID_optional;
      typedef ::xsd::cxx::tree::traits< GroupID_type, wchar_t > GroupID_traits;

      const GroupID_optional&
      GroupID () const;

      GroupID_optional&
      GroupID ();

      void
      GroupID (const GroupID_type& x);

      void
      GroupID (const GroupID_optional& x);

      void
      GroupID (::std::unique_ptr< GroupID_type > p);

      // Constructors.
      //
      PMIDisplayType ();

      PMIDisplayType (const Reference_type&);

      PMIDisplayType (::std::unique_ptr< Reference_type >);

      PMIDisplayType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      PMIDisplayType (const PMIDisplayType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual PMIDisplayType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PMIDisplayType&
      operator= (const PMIDisplayType& x);

      virtual 
      ~PMIDisplayType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Color_optional Color_;
      Plane_optional Plane_;
      Texts_optional Texts_;
      Leader_sequence Leader_;
      WitnessLines_optional WitnessLines_;
      Frames_optional Frames_;
      Graphics_optional Graphics_;
      ::xsd::cxx::tree::one< Reference_type > Reference_;
      GroupID_optional GroupID_;
    };

    class QIF30_SYMBOL_DECL PlanePMIDisplayType: public ::xml_schema::type
    {
      public:
      // AnnotationViewId
      //
      typedef ::xsd::qif30::ElementReferenceType AnnotationViewId_type;
      typedef ::xsd::cxx::tree::traits< AnnotationViewId_type, wchar_t > AnnotationViewId_traits;

      const AnnotationViewId_type&
      AnnotationViewId () const;

      AnnotationViewId_type&
      AnnotationViewId ();

      void
      AnnotationViewId (const AnnotationViewId_type& x);

      void
      AnnotationViewId (::std::unique_ptr< AnnotationViewId_type > p);

      // Origin
      //
      typedef ::xsd::qif30::PointType Origin_type;
      typedef ::xsd::cxx::tree::optional< Origin_type > Origin_optional;
      typedef ::xsd::cxx::tree::traits< Origin_type, wchar_t > Origin_traits;

      const Origin_optional&
      Origin () const;

      Origin_optional&
      Origin ();

      void
      Origin (const Origin_type& x);

      void
      Origin (const Origin_optional& x);

      void
      Origin (::std::unique_ptr< Origin_type > p);

      // Direction
      //
      typedef ::xsd::qif30::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::optional< Direction_type > Direction_optional;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_optional&
      Direction () const;

      Direction_optional&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (const Direction_optional& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // Constructors.
      //
      PlanePMIDisplayType ();

      PlanePMIDisplayType (const AnnotationViewId_type&);

      PlanePMIDisplayType (::std::unique_ptr< AnnotationViewId_type >);

      PlanePMIDisplayType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PlanePMIDisplayType (const PlanePMIDisplayType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual PlanePMIDisplayType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlanePMIDisplayType&
      operator= (const PlanePMIDisplayType& x);

      virtual 
      ~PlanePMIDisplayType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AnnotationViewId_type > AnnotationViewId_;
      Origin_optional Origin_;
      Direction_optional Direction_;
    };

    class QIF30_SYMBOL_DECL Polylines2dType: public ::xml_schema::type
    {
      public:
      // Polyline
      //
      typedef ::xsd::qif30::Polyline2dType Polyline_type;
      typedef ::xsd::cxx::tree::sequence< Polyline_type > Polyline_sequence;
      typedef xsd::cxx::tree::sequence< Polyline_type >::iterator Polyline_iterator;
      typedef xsd::cxx::tree::sequence< Polyline_type >::const_iterator Polyline_const_iterator;
      typedef ::xsd::cxx::tree::traits< Polyline_type, wchar_t > Polyline_traits;

      const Polyline_sequence&
      Polyline () const;

      Polyline_sequence&
      Polyline ();

      void
      Polyline (const Polyline_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      Polylines2dType ();

      Polylines2dType (const n_type&);

      Polylines2dType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Polylines2dType (const Polylines2dType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Polylines2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Polylines2dType&
      operator= (const Polylines2dType& x);

      virtual 
      ~Polylines2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Polyline_sequence Polyline_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL Polyline2dType: public ::xml_schema::type
    {
      public:
      // Points
      //
      typedef ::xsd::qif30::ArrayPoint2dType Points_type;
      typedef ::xsd::cxx::tree::optional< Points_type > Points_optional;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_optional&
      Points () const;

      Points_optional&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (const Points_optional& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // PointsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType PointsBinary_type;
      typedef ::xsd::cxx::tree::optional< PointsBinary_type > PointsBinary_optional;
      typedef ::xsd::cxx::tree::traits< PointsBinary_type, wchar_t > PointsBinary_traits;

      const PointsBinary_optional&
      PointsBinary () const;

      PointsBinary_optional&
      PointsBinary ();

      void
      PointsBinary (const PointsBinary_type& x);

      void
      PointsBinary (const PointsBinary_optional& x);

      void
      PointsBinary (::std::unique_ptr< PointsBinary_type > p);

      // color
      //
      typedef ::xsd::qif30::ColorType color_type;
      typedef ::xsd::cxx::tree::optional< color_type > color_optional;
      typedef ::xsd::cxx::tree::traits< color_type, wchar_t > color_traits;

      const color_optional&
      color () const;

      color_optional&
      color ();

      void
      color (const color_type& x);

      void
      color (const color_optional& x);

      void
      color (::std::unique_ptr< color_type > p);

      // Constructors.
      //
      Polyline2dType ();

      Polyline2dType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      Polyline2dType (const Polyline2dType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual Polyline2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Polyline2dType&
      operator= (const Polyline2dType& x);

      virtual 
      ~Polyline2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Points_optional Points_;
      PointsBinary_optional PointsBinary_;
      color_optional color_;
    };

    class QIF30_SYMBOL_DECL Areas2dType: public ::xml_schema::type
    {
      public:
      // Area
      //
      typedef ::xsd::qif30::Area2dType Area_type;
      typedef ::xsd::cxx::tree::sequence< Area_type > Area_sequence;
      typedef xsd::cxx::tree::sequence< Area_type >::iterator Area_iterator;
      typedef xsd::cxx::tree::sequence< Area_type >::const_iterator Area_const_iterator;
      typedef ::xsd::cxx::tree::traits< Area_type, wchar_t > Area_traits;

      const Area_sequence&
      Area () const;

      Area_sequence&
      Area ();

      void
      Area (const Area_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      Areas2dType ();

      Areas2dType (const n_type&);

      Areas2dType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      Areas2dType (const Areas2dType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual Areas2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Areas2dType&
      operator= (const Areas2dType& x);

      virtual 
      ~Areas2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Area_sequence Area_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL Area2dType: public ::xml_schema::type
    {
      public:
      // Loops
      //
      typedef ::xsd::qif30::Loops2dType Loops_type;
      typedef ::xsd::cxx::tree::optional< Loops_type > Loops_optional;
      typedef ::xsd::cxx::tree::traits< Loops_type, wchar_t > Loops_traits;

      const Loops_optional&
      Loops () const;

      Loops_optional&
      Loops ();

      void
      Loops (const Loops_type& x);

      void
      Loops (const Loops_optional& x);

      void
      Loops (::std::unique_ptr< Loops_type > p);

      // Triangulation
      //
      typedef ::xsd::qif30::Triangulation2dType Triangulation_type;
      typedef ::xsd::cxx::tree::optional< Triangulation_type > Triangulation_optional;
      typedef ::xsd::cxx::tree::traits< Triangulation_type, wchar_t > Triangulation_traits;

      const Triangulation_optional&
      Triangulation () const;

      Triangulation_optional&
      Triangulation ();

      void
      Triangulation (const Triangulation_type& x);

      void
      Triangulation (const Triangulation_optional& x);

      void
      Triangulation (::std::unique_ptr< Triangulation_type > p);

      // Constructors.
      //
      Area2dType ();

      Area2dType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      Area2dType (const Area2dType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual Area2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Area2dType&
      operator= (const Area2dType& x);

      virtual 
      ~Area2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Loops_optional Loops_;
      Triangulation_optional Triangulation_;
    };

    class QIF30_SYMBOL_DECL Loops2dType: public ::xml_schema::type
    {
      public:
      // Loop
      //
      typedef ::xsd::qif30::Polyline2dType Loop_type;
      typedef ::xsd::cxx::tree::sequence< Loop_type > Loop_sequence;
      typedef xsd::cxx::tree::sequence< Loop_type >::iterator Loop_iterator;
      typedef xsd::cxx::tree::sequence< Loop_type >::const_iterator Loop_const_iterator;
      typedef ::xsd::cxx::tree::traits< Loop_type, wchar_t > Loop_traits;

      const Loop_sequence&
      Loop () const;

      Loop_sequence&
      Loop ();

      void
      Loop (const Loop_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      Loops2dType ();

      Loops2dType (const n_type&);

      Loops2dType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      Loops2dType (const Loops2dType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual Loops2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Loops2dType&
      operator= (const Loops2dType& x);

      virtual 
      ~Loops2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Loop_sequence Loop_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL Triangulation2dType: public ::xml_schema::type
    {
      public:
      // Vertices
      //
      typedef ::xsd::qif30::ArrayPoint2dType Vertices_type;
      typedef ::xsd::cxx::tree::optional< Vertices_type > Vertices_optional;
      typedef ::xsd::cxx::tree::traits< Vertices_type, wchar_t > Vertices_traits;

      const Vertices_optional&
      Vertices () const;

      Vertices_optional&
      Vertices ();

      void
      Vertices (const Vertices_type& x);

      void
      Vertices (const Vertices_optional& x);

      void
      Vertices (::std::unique_ptr< Vertices_type > p);

      // VerticesBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType VerticesBinary_type;
      typedef ::xsd::cxx::tree::optional< VerticesBinary_type > VerticesBinary_optional;
      typedef ::xsd::cxx::tree::traits< VerticesBinary_type, wchar_t > VerticesBinary_traits;

      const VerticesBinary_optional&
      VerticesBinary () const;

      VerticesBinary_optional&
      VerticesBinary ();

      void
      VerticesBinary (const VerticesBinary_type& x);

      void
      VerticesBinary (const VerticesBinary_optional& x);

      void
      VerticesBinary (::std::unique_ptr< VerticesBinary_type > p);

      // Triangles
      //
      typedef ::xsd::qif30::ArrayI3Type Triangles_type;
      typedef ::xsd::cxx::tree::optional< Triangles_type > Triangles_optional;
      typedef ::xsd::cxx::tree::traits< Triangles_type, wchar_t > Triangles_traits;

      const Triangles_optional&
      Triangles () const;

      Triangles_optional&
      Triangles ();

      void
      Triangles (const Triangles_type& x);

      void
      Triangles (const Triangles_optional& x);

      void
      Triangles (::std::unique_ptr< Triangles_type > p);

      // TrianglesBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType TrianglesBinary_type;
      typedef ::xsd::cxx::tree::optional< TrianglesBinary_type > TrianglesBinary_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesBinary_type, wchar_t > TrianglesBinary_traits;

      const TrianglesBinary_optional&
      TrianglesBinary () const;

      TrianglesBinary_optional&
      TrianglesBinary ();

      void
      TrianglesBinary (const TrianglesBinary_type& x);

      void
      TrianglesBinary (const TrianglesBinary_optional& x);

      void
      TrianglesBinary (::std::unique_ptr< TrianglesBinary_type > p);

      // TrianglesColor
      //
      typedef ::xsd::qif30::ArrayUnsignedByteType TrianglesColor_type;
      typedef ::xsd::cxx::tree::optional< TrianglesColor_type > TrianglesColor_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesColor_type, wchar_t > TrianglesColor_traits;

      const TrianglesColor_optional&
      TrianglesColor () const;

      TrianglesColor_optional&
      TrianglesColor ();

      void
      TrianglesColor (const TrianglesColor_type& x);

      void
      TrianglesColor (const TrianglesColor_optional& x);

      void
      TrianglesColor (::std::unique_ptr< TrianglesColor_type > p);

      // TrianglesColorBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType TrianglesColorBinary_type;
      typedef ::xsd::cxx::tree::optional< TrianglesColorBinary_type > TrianglesColorBinary_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesColorBinary_type, wchar_t > TrianglesColorBinary_traits;

      const TrianglesColorBinary_optional&
      TrianglesColorBinary () const;

      TrianglesColorBinary_optional&
      TrianglesColorBinary ();

      void
      TrianglesColorBinary (const TrianglesColorBinary_type& x);

      void
      TrianglesColorBinary (const TrianglesColorBinary_optional& x);

      void
      TrianglesColorBinary (::std::unique_ptr< TrianglesColorBinary_type > p);

      // Constructors.
      //
      Triangulation2dType ();

      Triangulation2dType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      Triangulation2dType (const Triangulation2dType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual Triangulation2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Triangulation2dType&
      operator= (const Triangulation2dType& x);

      virtual 
      ~Triangulation2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Vertices_optional Vertices_;
      VerticesBinary_optional VerticesBinary_;
      Triangles_optional Triangles_;
      TrianglesBinary_optional TrianglesBinary_;
      TrianglesColor_optional TrianglesColor_;
      TrianglesColorBinary_optional TrianglesColorBinary_;
    };

    class QIF30_SYMBOL_DECL GraphicsType: public ::xml_schema::type
    {
      public:
      // Polylines
      //
      typedef ::xsd::qif30::Polylines2dType Polylines_type;
      typedef ::xsd::cxx::tree::optional< Polylines_type > Polylines_optional;
      typedef ::xsd::cxx::tree::traits< Polylines_type, wchar_t > Polylines_traits;

      const Polylines_optional&
      Polylines () const;

      Polylines_optional&
      Polylines ();

      void
      Polylines (const Polylines_type& x);

      void
      Polylines (const Polylines_optional& x);

      void
      Polylines (::std::unique_ptr< Polylines_type > p);

      // Areas
      //
      typedef ::xsd::qif30::Areas2dType Areas_type;
      typedef ::xsd::cxx::tree::optional< Areas_type > Areas_optional;
      typedef ::xsd::cxx::tree::traits< Areas_type, wchar_t > Areas_traits;

      const Areas_optional&
      Areas () const;

      Areas_optional&
      Areas ();

      void
      Areas (const Areas_type& x);

      void
      Areas (const Areas_optional& x);

      void
      Areas (::std::unique_ptr< Areas_type > p);

      // Constructors.
      //
      GraphicsType ();

      GraphicsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      GraphicsType (const GraphicsType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual GraphicsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GraphicsType&
      operator= (const GraphicsType& x);

      virtual 
      ~GraphicsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Polylines_optional Polylines_;
      Areas_optional Areas_;
    };

    class QIF30_SYMBOL_DECL LeaderType: public ::xsd::qif30::LineSegment2dType
    {
      public:
      // HeadForm
      //
      typedef ::xsd::qif30::LeaderHeadFormType HeadForm_type;
      typedef ::xsd::cxx::tree::traits< HeadForm_type, wchar_t > HeadForm_traits;

      const HeadForm_type&
      HeadForm () const;

      HeadForm_type&
      HeadForm ();

      void
      HeadForm (const HeadForm_type& x);

      void
      HeadForm (::std::unique_ptr< HeadForm_type > p);

      // HeadHeight
      //
      typedef ::xml_schema::double_ HeadHeight_type;
      typedef ::xsd::cxx::tree::traits< HeadHeight_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > HeadHeight_traits;

      const HeadHeight_type&
      HeadHeight () const;

      HeadHeight_type&
      HeadHeight ();

      void
      HeadHeight (const HeadHeight_type& x);

      // Constructors.
      //
      LeaderType ();

      LeaderType (const StartPoint_type&,
                  const EndPoint_type&,
                  const HeadForm_type&,
                  const HeadHeight_type&);

      LeaderType (const StartPoint_type&,
                  const EndPoint_type&,
                  ::std::unique_ptr< HeadForm_type >,
                  const HeadHeight_type&);

      LeaderType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      LeaderType (const LeaderType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual LeaderType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderType&
      operator= (const LeaderType& x);

      virtual 
      ~LeaderType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< HeadForm_type > HeadForm_;
      ::xsd::cxx::tree::one< HeadHeight_type > HeadHeight_;
    };

    class QIF30_SYMBOL_DECL LeaderExtendType: public ::xsd::qif30::LeaderType
    {
      public:
      // PointExtension
      //
      typedef ::xsd::qif30::Point2dSimpleType PointExtension_type;
      typedef ::xsd::cxx::tree::traits< PointExtension_type, wchar_t > PointExtension_traits;

      const PointExtension_type&
      PointExtension () const;

      PointExtension_type&
      PointExtension ();

      void
      PointExtension (const PointExtension_type& x);

      void
      PointExtension (::std::unique_ptr< PointExtension_type > p);

      // Modifier
      //
      typedef ::xsd::qif30::LeaderModifierEnumType Modifier_type;
      typedef ::xsd::cxx::tree::optional< Modifier_type > Modifier_optional;
      typedef ::xsd::cxx::tree::traits< Modifier_type, wchar_t > Modifier_traits;

      const Modifier_optional&
      Modifier () const;

      Modifier_optional&
      Modifier ();

      void
      Modifier (const Modifier_type& x);

      void
      Modifier (const Modifier_optional& x);

      void
      Modifier (::std::unique_ptr< Modifier_type > p);

      // Constructors.
      //
      LeaderExtendType ();

      LeaderExtendType (const StartPoint_type&,
                        const EndPoint_type&,
                        const HeadForm_type&,
                        const HeadHeight_type&,
                        const PointExtension_type&);

      LeaderExtendType (const StartPoint_type&,
                        const EndPoint_type&,
                        ::std::unique_ptr< HeadForm_type >,
                        const HeadHeight_type&,
                        const PointExtension_type&);

      LeaderExtendType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      LeaderExtendType (const LeaderExtendType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual LeaderExtendType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderExtendType&
      operator= (const LeaderExtendType& x);

      virtual 
      ~LeaderExtendType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PointExtension_type > PointExtension_;
      Modifier_optional Modifier_;
    };

    class QIF30_SYMBOL_DECL LeaderDoubleHeadType: public ::xsd::qif30::LeaderType
    {
      public:
      // HeadForm2
      //
      typedef ::xsd::qif30::LeaderHeadFormEnumType HeadForm2_type;
      typedef ::xsd::cxx::tree::traits< HeadForm2_type, wchar_t > HeadForm2_traits;

      const HeadForm2_type&
      HeadForm2 () const;

      HeadForm2_type&
      HeadForm2 ();

      void
      HeadForm2 (const HeadForm2_type& x);

      void
      HeadForm2 (::std::unique_ptr< HeadForm2_type > p);

      // PointConnection
      //
      typedef ::xsd::qif30::Point2dSimpleType PointConnection_type;
      typedef ::xsd::cxx::tree::traits< PointConnection_type, wchar_t > PointConnection_traits;

      const PointConnection_type&
      PointConnection () const;

      PointConnection_type&
      PointConnection ();

      void
      PointConnection (const PointConnection_type& x);

      void
      PointConnection (::std::unique_ptr< PointConnection_type > p);

      // Constructors.
      //
      LeaderDoubleHeadType ();

      LeaderDoubleHeadType (const StartPoint_type&,
                            const EndPoint_type&,
                            const HeadForm_type&,
                            const HeadHeight_type&,
                            const HeadForm2_type&,
                            const PointConnection_type&);

      LeaderDoubleHeadType (const StartPoint_type&,
                            const EndPoint_type&,
                            ::std::unique_ptr< HeadForm_type >,
                            const HeadHeight_type&,
                            const HeadForm2_type&,
                            const PointConnection_type&);

      LeaderDoubleHeadType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      LeaderDoubleHeadType (const LeaderDoubleHeadType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual LeaderDoubleHeadType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderDoubleHeadType&
      operator= (const LeaderDoubleHeadType& x);

      virtual 
      ~LeaderDoubleHeadType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< HeadForm2_type > HeadForm2_;
      ::xsd::cxx::tree::one< PointConnection_type > PointConnection_;
    };

    class QIF30_SYMBOL_DECL LeaderDoubleHeadExtendType: public ::xsd::qif30::LeaderDoubleHeadType
    {
      public:
      // PointExtension
      //
      typedef ::xsd::qif30::Point2dSimpleType PointExtension_type;
      typedef ::xsd::cxx::tree::traits< PointExtension_type, wchar_t > PointExtension_traits;

      const PointExtension_type&
      PointExtension () const;

      PointExtension_type&
      PointExtension ();

      void
      PointExtension (const PointExtension_type& x);

      void
      PointExtension (::std::unique_ptr< PointExtension_type > p);

      // Constructors.
      //
      LeaderDoubleHeadExtendType ();

      LeaderDoubleHeadExtendType (const StartPoint_type&,
                                  const EndPoint_type&,
                                  const HeadForm_type&,
                                  const HeadHeight_type&,
                                  const HeadForm2_type&,
                                  const PointConnection_type&,
                                  const PointExtension_type&);

      LeaderDoubleHeadExtendType (const StartPoint_type&,
                                  const EndPoint_type&,
                                  ::std::unique_ptr< HeadForm_type >,
                                  const HeadHeight_type&,
                                  const HeadForm2_type&,
                                  const PointConnection_type&,
                                  const PointExtension_type&);

      LeaderDoubleHeadExtendType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      LeaderDoubleHeadExtendType (const LeaderDoubleHeadExtendType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual LeaderDoubleHeadExtendType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderDoubleHeadExtendType&
      operator= (const LeaderDoubleHeadExtendType& x);

      virtual 
      ~LeaderDoubleHeadExtendType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PointExtension_type > PointExtension_;
    };

    class QIF30_SYMBOL_DECL LeaderCircularType: public ::xsd::qif30::LeaderType
    {
      public:
      // Center
      //
      typedef ::xsd::qif30::Point2dSimpleType Center_type;
      typedef ::xsd::cxx::tree::traits< Center_type, wchar_t > Center_traits;

      const Center_type&
      Center () const;

      Center_type&
      Center ();

      void
      Center (const Center_type& x);

      void
      Center (::std::unique_ptr< Center_type > p);

      // Constructors.
      //
      LeaderCircularType ();

      LeaderCircularType (const StartPoint_type&,
                          const EndPoint_type&,
                          const HeadForm_type&,
                          const HeadHeight_type&,
                          const Center_type&);

      LeaderCircularType (const StartPoint_type&,
                          const EndPoint_type&,
                          ::std::unique_ptr< HeadForm_type >,
                          const HeadHeight_type&,
                          const Center_type&);

      LeaderCircularType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      LeaderCircularType (const LeaderCircularType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual LeaderCircularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderCircularType&
      operator= (const LeaderCircularType& x);

      virtual 
      ~LeaderCircularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Center_type > Center_;
    };

    class QIF30_SYMBOL_DECL LeaderDoubleHeadCircularType: public ::xsd::qif30::LeaderDoubleHeadType
    {
      public:
      // Center
      //
      typedef ::xsd::qif30::Point2dSimpleType Center_type;
      typedef ::xsd::cxx::tree::traits< Center_type, wchar_t > Center_traits;

      const Center_type&
      Center () const;

      Center_type&
      Center ();

      void
      Center (const Center_type& x);

      void
      Center (::std::unique_ptr< Center_type > p);

      // Constructors.
      //
      LeaderDoubleHeadCircularType ();

      LeaderDoubleHeadCircularType (const StartPoint_type&,
                                    const EndPoint_type&,
                                    const HeadForm_type&,
                                    const HeadHeight_type&,
                                    const HeadForm2_type&,
                                    const PointConnection_type&,
                                    const Center_type&);

      LeaderDoubleHeadCircularType (const StartPoint_type&,
                                    const EndPoint_type&,
                                    ::std::unique_ptr< HeadForm_type >,
                                    const HeadHeight_type&,
                                    const HeadForm2_type&,
                                    const PointConnection_type&,
                                    const Center_type&);

      LeaderDoubleHeadCircularType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      LeaderDoubleHeadCircularType (const LeaderDoubleHeadCircularType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual LeaderDoubleHeadCircularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderDoubleHeadCircularType&
      operator= (const LeaderDoubleHeadCircularType& x);

      virtual 
      ~LeaderDoubleHeadCircularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Center_type > Center_;
    };

    class QIF30_SYMBOL_DECL TextsType: public ::xml_schema::type
    {
      public:
      // Text
      //
      typedef ::xsd::qif30::TextType Text_type;
      typedef ::xsd::cxx::tree::sequence< Text_type > Text_sequence;
      typedef xsd::cxx::tree::sequence< Text_type >::iterator Text_iterator;
      typedef xsd::cxx::tree::sequence< Text_type >::const_iterator Text_const_iterator;
      typedef ::xsd::cxx::tree::traits< Text_type, wchar_t > Text_traits;

      const Text_sequence&
      Text () const;

      Text_sequence&
      Text ();

      void
      Text (const Text_sequence& s);

      // fontIndex
      //
      typedef ::xml_schema::unsigned_int fontIndex_type;
      typedef ::xsd::cxx::tree::traits< fontIndex_type, wchar_t > fontIndex_traits;

      const fontIndex_type&
      fontIndex () const;

      fontIndex_type&
      fontIndex ();

      void
      fontIndex (const fontIndex_type& x);

      // lineHeight
      //
      typedef ::xml_schema::double_ lineHeight_type;
      typedef ::xsd::cxx::tree::optional< lineHeight_type > lineHeight_optional;
      typedef ::xsd::cxx::tree::traits< lineHeight_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > lineHeight_traits;

      const lineHeight_optional&
      lineHeight () const;

      lineHeight_optional&
      lineHeight ();

      void
      lineHeight (const lineHeight_type& x);

      void
      lineHeight (const lineHeight_optional& x);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      TextsType ();

      TextsType (const fontIndex_type&,
                 const n_type&);

      TextsType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      TextsType (const TextsType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual TextsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TextsType&
      operator= (const TextsType& x);

      virtual 
      ~TextsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Text_sequence Text_;
      ::xsd::cxx::tree::one< fontIndex_type > fontIndex_;
      lineHeight_optional lineHeight_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FramesType: public ::xml_schema::type
    {
      public:
      // Frame
      //
      typedef ::xsd::qif30::FrameBaseType Frame_type;
      typedef ::xsd::cxx::tree::sequence< Frame_type > Frame_sequence;
      typedef xsd::cxx::tree::sequence< Frame_type >::iterator Frame_iterator;
      typedef xsd::cxx::tree::sequence< Frame_type >::const_iterator Frame_const_iterator;
      typedef ::xsd::cxx::tree::traits< Frame_type, wchar_t > Frame_traits;

      const Frame_sequence&
      Frame () const;

      Frame_sequence&
      Frame ();

      void
      Frame (const Frame_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FramesType ();

      FramesType (const n_type&);

      FramesType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      FramesType (const FramesType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual FramesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FramesType&
      operator= (const FramesType& x);

      virtual 
      ~FramesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Frame_sequence Frame_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL TextType: public ::xml_schema::type
    {
      public:
      // Data
      //
      typedef ::xml_schema::string Data_type;
      typedef ::xsd::cxx::tree::traits< Data_type, wchar_t > Data_traits;

      const Data_type&
      Data () const;

      Data_type&
      Data ();

      void
      Data (const Data_type& x);

      void
      Data (::std::unique_ptr< Data_type > p);

      // XY
      //
      typedef ::xsd::qif30::Point2dSimpleType XY_type;
      typedef ::xsd::cxx::tree::traits< XY_type, wchar_t > XY_traits;

      const XY_type&
      XY () const;

      XY_type&
      XY ();

      void
      XY (const XY_type& x);

      void
      XY (::std::unique_ptr< XY_type > p);

      // Constructors.
      //
      TextType ();

      TextType (const Data_type&,
                const XY_type&);

      TextType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      TextType (const TextType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual TextType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TextType&
      operator= (const TextType& x);

      virtual 
      ~TextType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Data_type > Data_;
      ::xsd::cxx::tree::one< XY_type > XY_;
    };

    class QIF30_SYMBOL_DECL WitnessLinesType: public ::xml_schema::type
    {
      public:
      // Segment1
      //
      typedef ::xsd::qif30::LineSegment2dType Segment1_type;
      typedef ::xsd::cxx::tree::optional< Segment1_type > Segment1_optional;
      typedef ::xsd::cxx::tree::traits< Segment1_type, wchar_t > Segment1_traits;

      const Segment1_optional&
      Segment1 () const;

      Segment1_optional&
      Segment1 ();

      void
      Segment1 (const Segment1_type& x);

      void
      Segment1 (const Segment1_optional& x);

      void
      Segment1 (::std::unique_ptr< Segment1_type > p);

      // ZextensionPoint1
      //
      typedef ::xsd::qif30::PointSimpleType ZextensionPoint1_type;
      typedef ::xsd::cxx::tree::optional< ZextensionPoint1_type > ZextensionPoint1_optional;
      typedef ::xsd::cxx::tree::traits< ZextensionPoint1_type, wchar_t > ZextensionPoint1_traits;

      const ZextensionPoint1_optional&
      ZextensionPoint1 () const;

      ZextensionPoint1_optional&
      ZextensionPoint1 ();

      void
      ZextensionPoint1 (const ZextensionPoint1_type& x);

      void
      ZextensionPoint1 (const ZextensionPoint1_optional& x);

      void
      ZextensionPoint1 (::std::unique_ptr< ZextensionPoint1_type > p);

      // Segment2
      //
      typedef ::xsd::qif30::LineSegment2dType Segment2_type;
      typedef ::xsd::cxx::tree::optional< Segment2_type > Segment2_optional;
      typedef ::xsd::cxx::tree::traits< Segment2_type, wchar_t > Segment2_traits;

      const Segment2_optional&
      Segment2 () const;

      Segment2_optional&
      Segment2 ();

      void
      Segment2 (const Segment2_type& x);

      void
      Segment2 (const Segment2_optional& x);

      void
      Segment2 (::std::unique_ptr< Segment2_type > p);

      // ZextensionPoint2
      //
      typedef ::xsd::qif30::PointSimpleType ZextensionPoint2_type;
      typedef ::xsd::cxx::tree::optional< ZextensionPoint2_type > ZextensionPoint2_optional;
      typedef ::xsd::cxx::tree::traits< ZextensionPoint2_type, wchar_t > ZextensionPoint2_traits;

      const ZextensionPoint2_optional&
      ZextensionPoint2 () const;

      ZextensionPoint2_optional&
      ZextensionPoint2 ();

      void
      ZextensionPoint2 (const ZextensionPoint2_type& x);

      void
      ZextensionPoint2 (const ZextensionPoint2_optional& x);

      void
      ZextensionPoint2 (::std::unique_ptr< ZextensionPoint2_type > p);

      // BeginPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType BeginPoint_type;
      typedef ::xsd::cxx::tree::optional< BeginPoint_type > BeginPoint_optional;
      typedef ::xsd::cxx::tree::traits< BeginPoint_type, wchar_t > BeginPoint_traits;

      const BeginPoint_optional&
      BeginPoint () const;

      BeginPoint_optional&
      BeginPoint ();

      void
      BeginPoint (const BeginPoint_type& x);

      void
      BeginPoint (const BeginPoint_optional& x);

      void
      BeginPoint (::std::unique_ptr< BeginPoint_type > p);

      // EndPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType EndPoint_type;
      typedef ::xsd::cxx::tree::optional< EndPoint_type > EndPoint_optional;
      typedef ::xsd::cxx::tree::traits< EndPoint_type, wchar_t > EndPoint_traits;

      const EndPoint_optional&
      EndPoint () const;

      EndPoint_optional&
      EndPoint ();

      void
      EndPoint (const EndPoint_type& x);

      void
      EndPoint (const EndPoint_optional& x);

      void
      EndPoint (::std::unique_ptr< EndPoint_type > p);

      // CircleCenter
      //
      typedef ::xsd::qif30::Point2dSimpleType CircleCenter_type;
      typedef ::xsd::cxx::tree::optional< CircleCenter_type > CircleCenter_optional;
      typedef ::xsd::cxx::tree::traits< CircleCenter_type, wchar_t > CircleCenter_traits;

      const CircleCenter_optional&
      CircleCenter () const;

      CircleCenter_optional&
      CircleCenter ();

      void
      CircleCenter (const CircleCenter_type& x);

      void
      CircleCenter (const CircleCenter_optional& x);

      void
      CircleCenter (::std::unique_ptr< CircleCenter_type > p);

      // CircleRadius
      //
      typedef ::xsd::qif30::DoublePositiveType CircleRadius_type;
      typedef ::xsd::cxx::tree::optional< CircleRadius_type > CircleRadius_optional;
      typedef ::xsd::cxx::tree::traits< CircleRadius_type, wchar_t > CircleRadius_traits;

      const CircleRadius_optional&
      CircleRadius () const;

      CircleRadius_optional&
      CircleRadius ();

      void
      CircleRadius (const CircleRadius_type& x);

      void
      CircleRadius (const CircleRadius_optional& x);

      void
      CircleRadius (::std::unique_ptr< CircleRadius_type > p);

      // width
      //
      typedef ::xml_schema::double_ width_type;
      typedef ::xsd::cxx::tree::traits< width_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > width_traits;

      const width_type&
      width () const;

      width_type&
      width ();

      void
      width (const width_type& x);

      // Constructors.
      //
      WitnessLinesType ();

      WitnessLinesType (const width_type&);

      WitnessLinesType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      WitnessLinesType (const WitnessLinesType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual WitnessLinesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WitnessLinesType&
      operator= (const WitnessLinesType& x);

      virtual 
      ~WitnessLinesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Segment1_optional Segment1_;
      ZextensionPoint1_optional ZextensionPoint1_;
      Segment2_optional Segment2_;
      ZextensionPoint2_optional ZextensionPoint2_;
      BeginPoint_optional BeginPoint_;
      EndPoint_optional EndPoint_;
      CircleCenter_optional CircleCenter_;
      CircleRadius_optional CircleRadius_;
      ::xsd::cxx::tree::one< width_type > width_;
    };

    class QIF30_SYMBOL_DECL FrameBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      FrameBaseType ();

      FrameBaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      FrameBaseType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      FrameBaseType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      FrameBaseType (const FrameBaseType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual FrameBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      FrameBaseType&
      operator= (const FrameBaseType&) = default;
#endif

      virtual 
      ~FrameBaseType ();
    };

    class QIF30_SYMBOL_DECL FrameRectangularType: public ::xsd::qif30::FrameBaseType
    {
      public:
      // XY
      //
      typedef ::xsd::qif30::Point2dSimpleType XY_type;
      typedef ::xsd::cxx::tree::traits< XY_type, wchar_t > XY_traits;

      const XY_type&
      XY () const;

      XY_type&
      XY ();

      void
      XY (const XY_type& x);

      void
      XY (::std::unique_ptr< XY_type > p);

      // Width
      //
      typedef ::xml_schema::double_ Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      // Height
      //
      typedef ::xml_schema::double_ Height_type;
      typedef ::xsd::cxx::tree::traits< Height_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Height_traits;

      const Height_type&
      Height () const;

      Height_type&
      Height ();

      void
      Height (const Height_type& x);

      // Constructors.
      //
      FrameRectangularType ();

      FrameRectangularType (const XY_type&,
                            const Width_type&,
                            const Height_type&);

      FrameRectangularType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      FrameRectangularType (const FrameRectangularType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual FrameRectangularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameRectangularType&
      operator= (const FrameRectangularType& x);

      virtual 
      ~FrameRectangularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XY_type > XY_;
      ::xsd::cxx::tree::one< Width_type > Width_;
      ::xsd::cxx::tree::one< Height_type > Height_;
    };

    class QIF30_SYMBOL_DECL FrameCircularType: public ::xsd::qif30::FrameBaseType
    {
      public:
      // XY
      //
      typedef ::xsd::qif30::Point2dSimpleType XY_type;
      typedef ::xsd::cxx::tree::traits< XY_type, wchar_t > XY_traits;

      const XY_type&
      XY () const;

      XY_type&
      XY ();

      void
      XY (const XY_type& x);

      void
      XY (::std::unique_ptr< XY_type > p);

      // Radius
      //
      typedef ::xml_schema::double_ Radius_type;
      typedef ::xsd::cxx::tree::traits< Radius_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Radius_traits;

      const Radius_type&
      Radius () const;

      Radius_type&
      Radius ();

      void
      Radius (const Radius_type& x);

      // crossed
      //
      typedef ::xml_schema::boolean crossed_type;
      typedef ::xsd::cxx::tree::traits< crossed_type, wchar_t > crossed_traits;

      const crossed_type&
      crossed () const;

      crossed_type&
      crossed ();

      void
      crossed (const crossed_type& x);

      static crossed_type
      crossed_default_value ();

      // Constructors.
      //
      FrameCircularType ();

      FrameCircularType (const XY_type&,
                         const Radius_type&);

      FrameCircularType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      FrameCircularType (const FrameCircularType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual FrameCircularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameCircularType&
      operator= (const FrameCircularType& x);

      virtual 
      ~FrameCircularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XY_type > XY_;
      ::xsd::cxx::tree::one< Radius_type > Radius_;
      ::xsd::cxx::tree::one< crossed_type > crossed_;
    };

    class QIF30_SYMBOL_DECL FrameFlagType: public ::xsd::qif30::FrameRectangularType
    {
      public:
      // right
      //
      typedef ::xml_schema::boolean right_type;
      typedef ::xsd::cxx::tree::traits< right_type, wchar_t > right_traits;

      const right_type&
      right () const;

      right_type&
      right ();

      void
      right (const right_type& x);

      static right_type
      right_default_value ();

      // Constructors.
      //
      FrameFlagType ();

      FrameFlagType (const XY_type&,
                     const Width_type&,
                     const Height_type&);

      FrameFlagType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      FrameFlagType (const FrameFlagType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual FrameFlagType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameFlagType&
      operator= (const FrameFlagType& x);

      virtual 
      ~FrameFlagType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< right_type > right_;
    };

    class QIF30_SYMBOL_DECL FrameIrregularFormType: public ::xsd::qif30::FrameBaseType
    {
      public:
      // Points
      //
      typedef ::xsd::qif30::ArrayPoint2dType Points_type;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_type&
      Points () const;

      Points_type&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // Constructors.
      //
      FrameIrregularFormType ();

      FrameIrregularFormType (const Points_type&);

      FrameIrregularFormType (::std::unique_ptr< Points_type >);

      FrameIrregularFormType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      FrameIrregularFormType (const FrameIrregularFormType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual FrameIrregularFormType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameIrregularFormType&
      operator= (const FrameIrregularFormType& x);

      virtual 
      ~FrameIrregularFormType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Points_type > Points_;
    };

    class QIF30_SYMBOL_DECL FrameWeldSymbolTailType: public ::xml_schema::type
    {
      public:
      // UpperPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType UpperPoint_type;
      typedef ::xsd::cxx::tree::traits< UpperPoint_type, wchar_t > UpperPoint_traits;

      const UpperPoint_type&
      UpperPoint () const;

      UpperPoint_type&
      UpperPoint ();

      void
      UpperPoint (const UpperPoint_type& x);

      void
      UpperPoint (::std::unique_ptr< UpperPoint_type > p);

      // LowerPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType LowerPoint_type;
      typedef ::xsd::cxx::tree::traits< LowerPoint_type, wchar_t > LowerPoint_traits;

      const LowerPoint_type&
      LowerPoint () const;

      LowerPoint_type&
      LowerPoint ();

      void
      LowerPoint (const LowerPoint_type& x);

      void
      LowerPoint (::std::unique_ptr< LowerPoint_type > p);

      // Constructors.
      //
      FrameWeldSymbolTailType ();

      FrameWeldSymbolTailType (const UpperPoint_type&,
                               const LowerPoint_type&);

      FrameWeldSymbolTailType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      FrameWeldSymbolTailType (const FrameWeldSymbolTailType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual FrameWeldSymbolTailType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameWeldSymbolTailType&
      operator= (const FrameWeldSymbolTailType& x);

      virtual 
      ~FrameWeldSymbolTailType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< UpperPoint_type > UpperPoint_;
      ::xsd::cxx::tree::one< LowerPoint_type > LowerPoint_;
    };

    class QIF30_SYMBOL_DECL WeldMainSymbolEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        WELD_FILLET_ARROW_SIDE,
        WELD_FILLET_OTHER_SIDE,
        WELD_FILLET_BOTH,
        WELD_SPOT_ARROW_SIDE,
        WELD_SPOT_OTHER_SIDE,
        WELD_SPOT_NO_SIDE,
        WELD_STUD_ARROW_SIDE,
        WELD_SEAM_ARROW_SIDE,
        WELD_SEAM_OTHER_SIDE,
        WELD_SEAM_NO_SIDE,
        WELD_SURFACING_ARROW_SIDE,
        WELD_EDGE_ARROW_SIDE,
        WELD_EDGE_OTHER_SIDE,
        WELD_SQUARE_ARROW_SIDE,
        WELD_SQUARE_OTHER_SIDE,
        WELD_SQUARE_BOTH,
        WELD_V_ARROW_SIDE,
        WELD_V_OTHER_SIDE,
        WELD_V_BOTH,
        WELD_BEVEL_ARROW_SIDE,
        WELD_BEVEL_OTHER_SIDE,
        WELD_BEVEL_BOTH,
        WELD_U_ARROW_SIDE,
        WELD_U_OTHER_SIDE,
        WELD_U_BOTH,
        WELD_J_ARROW_SIDE,
        WELD_J_OTHER_SIDE,
        WELD_J_BOTH,
        WELD_FLARE_V_ARROW_SIDE,
        WELD_FLARE_V_OTHER_SIDE,
        WELD_FLARE_V_BOTH,
        WELD_FLARE_BEVEL_ARROW_SIDE,
        WELD_FLARE_BEVEL_OTHER_SIDE,
        WELD_FLARE_BEVEL_BOTH,
        WELD_SCARF_V_ARROW_SIDE,
        WELD_SCARF_V_OTHER_SIDE,
        WELD_SCARF_V_BOTH,
        WELD_V_SPACER,
        WELD_BEVEL_SPACER,
        WELD_U_SPACER,
        WELD_J_SPACER,
        WELD_FLARE_V_SPACER,
        WELD_FLARE_BEVEL_SPACER,
        BACK_WELD,
        MELT_THROUGH,
        CONSUMABLE_INSERT,
        REMOVABLE_BACKING
      };

      WeldMainSymbolEnumType ();

      WeldMainSymbolEnumType (value v);

      WeldMainSymbolEnumType (const wchar_t* v);

      WeldMainSymbolEnumType (const ::std::wstring& v);

      WeldMainSymbolEnumType (const ::xml_schema::string& v);

      WeldMainSymbolEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      WeldMainSymbolEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      WeldMainSymbolEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      WeldMainSymbolEnumType (const WeldMainSymbolEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      WeldMainSymbolEnumType&
      operator= (const WeldMainSymbolEnumType&) = default;
#endif

      virtual WeldMainSymbolEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldMainSymbolEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_WeldMainSymbolEnumType_convert ();
      }

      protected:
      value
      _xsd_WeldMainSymbolEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_WeldMainSymbolEnumType_literals_[47];
      static const value _xsd_WeldMainSymbolEnumType_indexes_[47];
    };

    class QIF30_SYMBOL_DECL OriginType: public ::xml_schema::type
    {
      public:
      // Origin
      //
      typedef ::xsd::qif30::Point2dSimpleType Origin_type;
      typedef ::xsd::cxx::tree::traits< Origin_type, wchar_t > Origin_traits;

      const Origin_type&
      Origin () const;

      Origin_type&
      Origin ();

      void
      Origin (const Origin_type& x);

      void
      Origin (::std::unique_ptr< Origin_type > p);

      // Constructors.
      //
      OriginType ();

      OriginType (const Origin_type&);

      OriginType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      OriginType (const OriginType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual OriginType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      OriginType&
      operator= (const OriginType& x);

      virtual 
      ~OriginType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Origin_type > Origin_;
    };

    class QIF30_SYMBOL_DECL WeldMainSymbolType: public ::xsd::qif30::OriginType
    {
      public:
      // Symbol
      //
      typedef ::xsd::qif30::WeldMainSymbolEnumType Symbol_type;
      typedef ::xsd::cxx::tree::traits< Symbol_type, wchar_t > Symbol_traits;

      const Symbol_type&
      Symbol () const;

      Symbol_type&
      Symbol ();

      void
      Symbol (const Symbol_type& x);

      void
      Symbol (::std::unique_ptr< Symbol_type > p);

      // Constructors.
      //
      WeldMainSymbolType ();

      WeldMainSymbolType (const Origin_type&,
                          const Symbol_type&);

      WeldMainSymbolType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      WeldMainSymbolType (const WeldMainSymbolType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual WeldMainSymbolType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldMainSymbolType&
      operator= (const WeldMainSymbolType& x);

      virtual 
      ~WeldMainSymbolType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Symbol_type > Symbol_;
    };

    class QIF30_SYMBOL_DECL WeldSupplementarySymbolType: public ::xsd::qif30::OriginType
    {
      public:
      // Symbol
      //
      typedef ::xsd::qif30::WeldSupplementarySymbolEnumType Symbol_type;
      typedef ::xsd::cxx::tree::traits< Symbol_type, wchar_t > Symbol_traits;

      const Symbol_type&
      Symbol () const;

      Symbol_type&
      Symbol ();

      void
      Symbol (const Symbol_type& x);

      void
      Symbol (::std::unique_ptr< Symbol_type > p);

      // Constructors.
      //
      WeldSupplementarySymbolType ();

      WeldSupplementarySymbolType (const Origin_type&,
                                   const Symbol_type&);

      WeldSupplementarySymbolType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      WeldSupplementarySymbolType (const WeldSupplementarySymbolType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual WeldSupplementarySymbolType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldSupplementarySymbolType&
      operator= (const WeldSupplementarySymbolType& x);

      virtual 
      ~WeldSupplementarySymbolType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Symbol_type > Symbol_;
    };

    class QIF30_SYMBOL_DECL WeldContourSymbolType: public ::xsd::qif30::OriginType
    {
      public:
      // Symbol
      //
      typedef ::xsd::qif30::WeldContourSymbolEnumType Symbol_type;
      typedef ::xsd::cxx::tree::traits< Symbol_type, wchar_t > Symbol_traits;

      const Symbol_type&
      Symbol () const;

      Symbol_type&
      Symbol ();

      void
      Symbol (const Symbol_type& x);

      void
      Symbol (::std::unique_ptr< Symbol_type > p);

      // Constructors.
      //
      WeldContourSymbolType ();

      WeldContourSymbolType (const Origin_type&,
                             const Symbol_type&);

      WeldContourSymbolType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      WeldContourSymbolType (const WeldContourSymbolType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual WeldContourSymbolType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WeldContourSymbolType&
      operator= (const WeldContourSymbolType& x);

      virtual 
      ~WeldContourSymbolType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Symbol_type > Symbol_;
    };

    class QIF30_SYMBOL_DECL FrameWeldSymbolType: public ::xsd::qif30::FrameBaseType
    {
      public:
      // ReferenceLineBeginPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType ReferenceLineBeginPoint_type;
      typedef ::xsd::cxx::tree::traits< ReferenceLineBeginPoint_type, wchar_t > ReferenceLineBeginPoint_traits;

      const ReferenceLineBeginPoint_type&
      ReferenceLineBeginPoint () const;

      ReferenceLineBeginPoint_type&
      ReferenceLineBeginPoint ();

      void
      ReferenceLineBeginPoint (const ReferenceLineBeginPoint_type& x);

      void
      ReferenceLineBeginPoint (::std::unique_ptr< ReferenceLineBeginPoint_type > p);

      // ReferenceLineEndPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType ReferenceLineEndPoint_type;
      typedef ::xsd::cxx::tree::traits< ReferenceLineEndPoint_type, wchar_t > ReferenceLineEndPoint_traits;

      const ReferenceLineEndPoint_type&
      ReferenceLineEndPoint () const;

      ReferenceLineEndPoint_type&
      ReferenceLineEndPoint ();

      void
      ReferenceLineEndPoint (const ReferenceLineEndPoint_type& x);

      void
      ReferenceLineEndPoint (::std::unique_ptr< ReferenceLineEndPoint_type > p);

      // Tail
      //
      typedef ::xsd::qif30::FrameWeldSymbolTailType Tail_type;
      typedef ::xsd::cxx::tree::optional< Tail_type > Tail_optional;
      typedef ::xsd::cxx::tree::traits< Tail_type, wchar_t > Tail_traits;

      const Tail_optional&
      Tail () const;

      Tail_optional&
      Tail ();

      void
      Tail (const Tail_type& x);

      void
      Tail (const Tail_optional& x);

      void
      Tail (::std::unique_ptr< Tail_type > p);

      // MainSymbol
      //
      typedef ::xsd::qif30::WeldMainSymbolType MainSymbol_type;
      typedef ::xsd::cxx::tree::optional< MainSymbol_type > MainSymbol_optional;
      typedef ::xsd::cxx::tree::traits< MainSymbol_type, wchar_t > MainSymbol_traits;

      const MainSymbol_optional&
      MainSymbol () const;

      MainSymbol_optional&
      MainSymbol ();

      void
      MainSymbol (const MainSymbol_type& x);

      void
      MainSymbol (const MainSymbol_optional& x);

      void
      MainSymbol (::std::unique_ptr< MainSymbol_type > p);

      // SupplementarySymbol
      //
      typedef ::xsd::qif30::WeldSupplementarySymbolType SupplementarySymbol_type;
      typedef ::xsd::cxx::tree::optional< SupplementarySymbol_type > SupplementarySymbol_optional;
      typedef ::xsd::cxx::tree::traits< SupplementarySymbol_type, wchar_t > SupplementarySymbol_traits;

      const SupplementarySymbol_optional&
      SupplementarySymbol () const;

      SupplementarySymbol_optional&
      SupplementarySymbol ();

      void
      SupplementarySymbol (const SupplementarySymbol_type& x);

      void
      SupplementarySymbol (const SupplementarySymbol_optional& x);

      void
      SupplementarySymbol (::std::unique_ptr< SupplementarySymbol_type > p);

      // ArrowSideContourSymbol
      //
      typedef ::xsd::qif30::WeldContourSymbolType ArrowSideContourSymbol_type;
      typedef ::xsd::cxx::tree::optional< ArrowSideContourSymbol_type > ArrowSideContourSymbol_optional;
      typedef ::xsd::cxx::tree::traits< ArrowSideContourSymbol_type, wchar_t > ArrowSideContourSymbol_traits;

      const ArrowSideContourSymbol_optional&
      ArrowSideContourSymbol () const;

      ArrowSideContourSymbol_optional&
      ArrowSideContourSymbol ();

      void
      ArrowSideContourSymbol (const ArrowSideContourSymbol_type& x);

      void
      ArrowSideContourSymbol (const ArrowSideContourSymbol_optional& x);

      void
      ArrowSideContourSymbol (::std::unique_ptr< ArrowSideContourSymbol_type > p);

      // OtherSideContourSymbol
      //
      typedef ::xsd::qif30::WeldContourSymbolType OtherSideContourSymbol_type;
      typedef ::xsd::cxx::tree::optional< OtherSideContourSymbol_type > OtherSideContourSymbol_optional;
      typedef ::xsd::cxx::tree::traits< OtherSideContourSymbol_type, wchar_t > OtherSideContourSymbol_traits;

      const OtherSideContourSymbol_optional&
      OtherSideContourSymbol () const;

      OtherSideContourSymbol_optional&
      OtherSideContourSymbol ();

      void
      OtherSideContourSymbol (const OtherSideContourSymbol_type& x);

      void
      OtherSideContourSymbol (const OtherSideContourSymbol_optional& x);

      void
      OtherSideContourSymbol (::std::unique_ptr< OtherSideContourSymbol_type > p);

      // Constructors.
      //
      FrameWeldSymbolType ();

      FrameWeldSymbolType (const ReferenceLineBeginPoint_type&,
                           const ReferenceLineEndPoint_type&);

      FrameWeldSymbolType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FrameWeldSymbolType (const FrameWeldSymbolType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual FrameWeldSymbolType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameWeldSymbolType&
      operator= (const FrameWeldSymbolType& x);

      virtual 
      ~FrameWeldSymbolType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ReferenceLineBeginPoint_type > ReferenceLineBeginPoint_;
      ::xsd::cxx::tree::one< ReferenceLineEndPoint_type > ReferenceLineEndPoint_;
      Tail_optional Tail_;
      MainSymbol_optional MainSymbol_;
      SupplementarySymbol_optional SupplementarySymbol_;
      ArrowSideContourSymbol_optional ArrowSideContourSymbol_;
      OtherSideContourSymbol_optional OtherSideContourSymbol_;
    };

    class QIF30_SYMBOL_DECL FrameTriangleType: public ::xsd::qif30::FrameBaseType
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::Point2dSimpleType Point_type;
      typedef ::xsd::cxx::tree::sequence< Point_type > Point_sequence;
      typedef xsd::cxx::tree::sequence< Point_type >::iterator Point_iterator;
      typedef xsd::cxx::tree::sequence< Point_type >::const_iterator Point_const_iterator;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_sequence&
      Point () const;

      Point_sequence&
      Point ();

      void
      Point (const Point_sequence& s);

      // Constructors.
      //
      FrameTriangleType ();

      FrameTriangleType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      FrameTriangleType (const FrameTriangleType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual FrameTriangleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameTriangleType&
      operator= (const FrameTriangleType& x);

      virtual 
      ~FrameTriangleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Point_sequence Point_;
    };

    class QIF30_SYMBOL_DECL FramePentagonalType: public ::xsd::qif30::FrameBaseType
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::Point2dSimpleType Point_type;
      typedef ::xsd::cxx::tree::sequence< Point_type > Point_sequence;
      typedef xsd::cxx::tree::sequence< Point_type >::iterator Point_iterator;
      typedef xsd::cxx::tree::sequence< Point_type >::const_iterator Point_const_iterator;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_sequence&
      Point () const;

      Point_sequence&
      Point ();

      void
      Point (const Point_sequence& s);

      // Constructors.
      //
      FramePentagonalType ();

      FramePentagonalType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FramePentagonalType (const FramePentagonalType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual FramePentagonalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FramePentagonalType&
      operator= (const FramePentagonalType& x);

      virtual 
      ~FramePentagonalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Point_sequence Point_;
    };

    class QIF30_SYMBOL_DECL FrameOctagonalType: public ::xsd::qif30::FrameBaseType
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::Point2dSimpleType Point_type;
      typedef ::xsd::cxx::tree::sequence< Point_type > Point_sequence;
      typedef xsd::cxx::tree::sequence< Point_type >::iterator Point_iterator;
      typedef xsd::cxx::tree::sequence< Point_type >::const_iterator Point_const_iterator;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_sequence&
      Point () const;

      Point_sequence&
      Point ();

      void
      Point (const Point_sequence& s);

      // Constructors.
      //
      FrameOctagonalType ();

      FrameOctagonalType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FrameOctagonalType (const FrameOctagonalType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual FrameOctagonalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameOctagonalType&
      operator= (const FrameOctagonalType& x);

      virtual 
      ~FrameOctagonalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Point_sequence Point_;
    };

    class QIF30_SYMBOL_DECL FrameHexagonalType: public ::xsd::qif30::FrameBaseType
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::Point2dSimpleType Point_type;
      typedef ::xsd::cxx::tree::sequence< Point_type > Point_sequence;
      typedef xsd::cxx::tree::sequence< Point_type >::iterator Point_iterator;
      typedef xsd::cxx::tree::sequence< Point_type >::const_iterator Point_const_iterator;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_sequence&
      Point () const;

      Point_sequence&
      Point ();

      void
      Point (const Point_sequence& s);

      // Constructors.
      //
      FrameHexagonalType ();

      FrameHexagonalType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FrameHexagonalType (const FrameHexagonalType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual FrameHexagonalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FrameHexagonalType&
      operator= (const FrameHexagonalType& x);

      virtual 
      ~FrameHexagonalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Point_sequence Point_;
    };

    class QIF30_SYMBOL_DECL LeaderHeadFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        NONE,
        ARROW_OPEN,
        ARROW_UNFILLED,
        ARROW_BLANKED,
        ARROW_FILLED,
        TRIANGLE_BLANKED,
        TRIANGLE_FILLED,
        DOT_BLANKED,
        DOT_FILLED,
        BOX_BLANKED,
        BOX_FILLED,
        DIMENSION_ORIGIN,
        SYMBOL_SLASH,
        SYMBOL_INTEGRAL,
        SYMBOL_CROSS
      };

      LeaderHeadFormEnumType ();

      LeaderHeadFormEnumType (value v);

      LeaderHeadFormEnumType (const wchar_t* v);

      LeaderHeadFormEnumType (const ::std::wstring& v);

      LeaderHeadFormEnumType (const ::xml_schema::string& v);

      LeaderHeadFormEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LeaderHeadFormEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LeaderHeadFormEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LeaderHeadFormEnumType (const LeaderHeadFormEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LeaderHeadFormEnumType&
      operator= (const LeaderHeadFormEnumType&) = default;
#endif

      virtual LeaderHeadFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderHeadFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LeaderHeadFormEnumType_convert ();
      }

      protected:
      value
      _xsd_LeaderHeadFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LeaderHeadFormEnumType_literals_[15];
      static const value _xsd_LeaderHeadFormEnumType_indexes_[15];
    };

    class QIF30_SYMBOL_DECL LeaderHeadFormType: public ::xsd::qif30::LeaderHeadFormEnumType
    {
      public:
      // normal
      //
      typedef ::xsd::qif30::D3Type normal_type;
      typedef ::xsd::cxx::tree::optional< normal_type > normal_optional;
      typedef ::xsd::cxx::tree::traits< normal_type, wchar_t > normal_traits;

      const normal_optional&
      normal () const;

      normal_optional&
      normal ();

      void
      normal (const normal_type& x);

      void
      normal (const normal_optional& x);

      void
      normal (::std::unique_ptr< normal_type > p);

      // Constructors.
      //
      LeaderHeadFormType ();

      LeaderHeadFormType (::xsd::qif30::LeaderHeadFormEnumType::value);

      LeaderHeadFormType (const wchar_t*);

      LeaderHeadFormType (const ::std::wstring&);

      LeaderHeadFormType (const ::xsd::qif30::LeaderHeadFormEnumType&);

      LeaderHeadFormType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      LeaderHeadFormType (const LeaderHeadFormType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual LeaderHeadFormType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderHeadFormType&
      operator= (const LeaderHeadFormType& x);

      virtual 
      ~LeaderHeadFormType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      normal_optional normal_;
    };

    class QIF30_SYMBOL_DECL LeaderModifierEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        ALL_AROUND,
        ALL_OVER,
        FLAG,
        ALL_AROUND_FLAG
      };

      LeaderModifierEnumType ();

      LeaderModifierEnumType (value v);

      LeaderModifierEnumType (const wchar_t* v);

      LeaderModifierEnumType (const ::std::wstring& v);

      LeaderModifierEnumType (const ::xml_schema::string& v);

      LeaderModifierEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LeaderModifierEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LeaderModifierEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LeaderModifierEnumType (const LeaderModifierEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LeaderModifierEnumType&
      operator= (const LeaderModifierEnumType&) = default;
#endif

      virtual LeaderModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LeaderModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LeaderModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_LeaderModifierEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LeaderModifierEnumType_literals_[4];
      static const value _xsd_LeaderModifierEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL ViewSetType: public ::xml_schema::type
    {
      public:
      // CameraSet
      //
      typedef ::xsd::qif30::CameraSetType CameraSet_type;
      typedef ::xsd::cxx::tree::optional< CameraSet_type > CameraSet_optional;
      typedef ::xsd::cxx::tree::traits< CameraSet_type, wchar_t > CameraSet_traits;

      const CameraSet_optional&
      CameraSet () const;

      CameraSet_optional&
      CameraSet ();

      void
      CameraSet (const CameraSet_type& x);

      void
      CameraSet (const CameraSet_optional& x);

      void
      CameraSet (::std::unique_ptr< CameraSet_type > p);

      // SavedViewSet
      //
      typedef ::xsd::qif30::SavedViewSetType SavedViewSet_type;
      typedef ::xsd::cxx::tree::optional< SavedViewSet_type > SavedViewSet_optional;
      typedef ::xsd::cxx::tree::traits< SavedViewSet_type, wchar_t > SavedViewSet_traits;

      const SavedViewSet_optional&
      SavedViewSet () const;

      SavedViewSet_optional&
      SavedViewSet ();

      void
      SavedViewSet (const SavedViewSet_type& x);

      void
      SavedViewSet (const SavedViewSet_optional& x);

      void
      SavedViewSet (::std::unique_ptr< SavedViewSet_type > p);

      // AnnotationViewSet
      //
      typedef ::xsd::qif30::AnnotationViewSetType AnnotationViewSet_type;
      typedef ::xsd::cxx::tree::optional< AnnotationViewSet_type > AnnotationViewSet_optional;
      typedef ::xsd::cxx::tree::traits< AnnotationViewSet_type, wchar_t > AnnotationViewSet_traits;

      const AnnotationViewSet_optional&
      AnnotationViewSet () const;

      AnnotationViewSet_optional&
      AnnotationViewSet ();

      void
      AnnotationViewSet (const AnnotationViewSet_type& x);

      void
      AnnotationViewSet (const AnnotationViewSet_optional& x);

      void
      AnnotationViewSet (::std::unique_ptr< AnnotationViewSet_type > p);

      // SimplifiedRepresentationSet
      //
      typedef ::xsd::qif30::SimplifiedRepresentationSetType SimplifiedRepresentationSet_type;
      typedef ::xsd::cxx::tree::optional< SimplifiedRepresentationSet_type > SimplifiedRepresentationSet_optional;
      typedef ::xsd::cxx::tree::traits< SimplifiedRepresentationSet_type, wchar_t > SimplifiedRepresentationSet_traits;

      const SimplifiedRepresentationSet_optional&
      SimplifiedRepresentationSet () const;

      SimplifiedRepresentationSet_optional&
      SimplifiedRepresentationSet ();

      void
      SimplifiedRepresentationSet (const SimplifiedRepresentationSet_type& x);

      void
      SimplifiedRepresentationSet (const SimplifiedRepresentationSet_optional& x);

      void
      SimplifiedRepresentationSet (::std::unique_ptr< SimplifiedRepresentationSet_type > p);

      // ExplodedViewSet
      //
      typedef ::xsd::qif30::ExplodedViewSetType ExplodedViewSet_type;
      typedef ::xsd::cxx::tree::optional< ExplodedViewSet_type > ExplodedViewSet_optional;
      typedef ::xsd::cxx::tree::traits< ExplodedViewSet_type, wchar_t > ExplodedViewSet_traits;

      const ExplodedViewSet_optional&
      ExplodedViewSet () const;

      ExplodedViewSet_optional&
      ExplodedViewSet ();

      void
      ExplodedViewSet (const ExplodedViewSet_type& x);

      void
      ExplodedViewSet (const ExplodedViewSet_optional& x);

      void
      ExplodedViewSet (::std::unique_ptr< ExplodedViewSet_type > p);

      // DisplayStyleSet
      //
      typedef ::xsd::qif30::DisplayStyleSetType DisplayStyleSet_type;
      typedef ::xsd::cxx::tree::optional< DisplayStyleSet_type > DisplayStyleSet_optional;
      typedef ::xsd::cxx::tree::traits< DisplayStyleSet_type, wchar_t > DisplayStyleSet_traits;

      const DisplayStyleSet_optional&
      DisplayStyleSet () const;

      DisplayStyleSet_optional&
      DisplayStyleSet ();

      void
      DisplayStyleSet (const DisplayStyleSet_type& x);

      void
      DisplayStyleSet (const DisplayStyleSet_optional& x);

      void
      DisplayStyleSet (::std::unique_ptr< DisplayStyleSet_type > p);

      // ZoneSectionSet
      //
      typedef ::xsd::qif30::ZoneSectionSetType ZoneSectionSet_type;
      typedef ::xsd::cxx::tree::optional< ZoneSectionSet_type > ZoneSectionSet_optional;
      typedef ::xsd::cxx::tree::traits< ZoneSectionSet_type, wchar_t > ZoneSectionSet_traits;

      const ZoneSectionSet_optional&
      ZoneSectionSet () const;

      ZoneSectionSet_optional&
      ZoneSectionSet ();

      void
      ZoneSectionSet (const ZoneSectionSet_type& x);

      void
      ZoneSectionSet (const ZoneSectionSet_optional& x);

      void
      ZoneSectionSet (::std::unique_ptr< ZoneSectionSet_type > p);

      // HatchStyleSet
      //
      typedef ::xsd::qif30::HatchStyleSetType HatchStyleSet_type;
      typedef ::xsd::cxx::tree::optional< HatchStyleSet_type > HatchStyleSet_optional;
      typedef ::xsd::cxx::tree::traits< HatchStyleSet_type, wchar_t > HatchStyleSet_traits;

      const HatchStyleSet_optional&
      HatchStyleSet () const;

      HatchStyleSet_optional&
      HatchStyleSet ();

      void
      HatchStyleSet (const HatchStyleSet_type& x);

      void
      HatchStyleSet (const HatchStyleSet_optional& x);

      void
      HatchStyleSet (::std::unique_ptr< HatchStyleSet_type > p);

      // Constructors.
      //
      ViewSetType ();

      ViewSetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ViewSetType (const ViewSetType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ViewSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ViewSetType&
      operator= (const ViewSetType& x);

      virtual 
      ~ViewSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CameraSet_optional CameraSet_;
      SavedViewSet_optional SavedViewSet_;
      AnnotationViewSet_optional AnnotationViewSet_;
      SimplifiedRepresentationSet_optional SimplifiedRepresentationSet_;
      ExplodedViewSet_optional ExplodedViewSet_;
      DisplayStyleSet_optional DisplayStyleSet_;
      ZoneSectionSet_optional ZoneSectionSet_;
      HatchStyleSet_optional HatchStyleSet_;
    };

    class QIF30_SYMBOL_DECL CameraType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // ViewPlaneOrigin
      //
      typedef ::xsd::qif30::PointSimpleType ViewPlaneOrigin_type;
      typedef ::xsd::cxx::tree::traits< ViewPlaneOrigin_type, wchar_t > ViewPlaneOrigin_traits;

      const ViewPlaneOrigin_type&
      ViewPlaneOrigin () const;

      ViewPlaneOrigin_type&
      ViewPlaneOrigin ();

      void
      ViewPlaneOrigin (const ViewPlaneOrigin_type& x);

      void
      ViewPlaneOrigin (::std::unique_ptr< ViewPlaneOrigin_type > p);

      // Orientation
      //
      typedef ::xsd::qif30::QuaternionType Orientation_type;
      typedef ::xsd::cxx::tree::traits< Orientation_type, wchar_t > Orientation_traits;

      const Orientation_type&
      Orientation () const;

      Orientation_type&
      Orientation ();

      void
      Orientation (const Orientation_type& x);

      void
      Orientation (::std::unique_ptr< Orientation_type > p);

      // Ratio
      //
      typedef ::xml_schema::double_ Ratio_type;
      typedef ::xsd::cxx::tree::traits< Ratio_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Ratio_traits;

      const Ratio_type&
      Ratio () const;

      Ratio_type&
      Ratio ();

      void
      Ratio (const Ratio_type& x);

      // Near
      //
      typedef ::xsd::qif30::LinearValueType Near_type;
      typedef ::xsd::cxx::tree::traits< Near_type, wchar_t > Near_traits;

      const Near_type&
      Near () const;

      Near_type&
      Near ();

      void
      Near (const Near_type& x);

      void
      Near (::std::unique_ptr< Near_type > p);

      // Far
      //
      typedef ::xsd::qif30::LinearValueType Far_type;
      typedef ::xsd::cxx::tree::traits< Far_type, wchar_t > Far_traits;

      const Far_type&
      Far () const;

      Far_type&
      Far ();

      void
      Far (const Far_type& x);

      void
      Far (::std::unique_ptr< Far_type > p);

      // Height
      //
      typedef ::xml_schema::double_ Height_type;
      typedef ::xsd::cxx::tree::traits< Height_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Height_traits;

      const Height_type&
      Height () const;

      Height_type&
      Height ();

      void
      Height (const Height_type& x);

      // form
      //
      typedef ::xsd::qif30::CameraFormEnumType form_type;
      typedef ::xsd::cxx::tree::traits< form_type, wchar_t > form_traits;

      const form_type&
      form () const;

      form_type&
      form ();

      void
      form (const form_type& x);

      void
      form (::std::unique_ptr< form_type > p);

      static const form_type&
      form_default_value ();

      // Constructors.
      //
      CameraType ();

      CameraType (const id_type&,
                  const ViewPlaneOrigin_type&,
                  const Orientation_type&,
                  const Ratio_type&,
                  const Near_type&,
                  const Far_type&,
                  const Height_type&);

      CameraType (const id_type&,
                  const ViewPlaneOrigin_type&,
                  ::std::unique_ptr< Orientation_type >,
                  const Ratio_type&,
                  ::std::unique_ptr< Near_type >,
                  ::std::unique_ptr< Far_type >,
                  const Height_type&);

      CameraType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      CameraType (const CameraType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual CameraType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CameraType&
      operator= (const CameraType& x);

      virtual 
      ~CameraType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ViewPlaneOrigin_type > ViewPlaneOrigin_;
      ::xsd::cxx::tree::one< Orientation_type > Orientation_;
      ::xsd::cxx::tree::one< Ratio_type > Ratio_;
      ::xsd::cxx::tree::one< Near_type > Near_;
      ::xsd::cxx::tree::one< Far_type > Far_;
      ::xsd::cxx::tree::one< Height_type > Height_;
      ::xsd::cxx::tree::one< form_type > form_;
      static const form_type form_default_value_;
    };

    class QIF30_SYMBOL_DECL CameraFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        ORTHOGRAPHIC,
        PERSPECTIVE
      };

      CameraFormEnumType ();

      CameraFormEnumType (value v);

      CameraFormEnumType (const wchar_t* v);

      CameraFormEnumType (const ::std::wstring& v);

      CameraFormEnumType (const ::xml_schema::string& v);

      CameraFormEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CameraFormEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CameraFormEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CameraFormEnumType (const CameraFormEnumType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CameraFormEnumType&
      operator= (const CameraFormEnumType&) = default;
#endif

      virtual CameraFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CameraFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CameraFormEnumType_convert ();
      }

      protected:
      value
      _xsd_CameraFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CameraFormEnumType_literals_[2];
      static const value _xsd_CameraFormEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL SavedViewType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // ActiveView
      //
      typedef ::xml_schema::boolean ActiveView_type;
      typedef ::xsd::cxx::tree::optional< ActiveView_type > ActiveView_optional;
      typedef ::xsd::cxx::tree::traits< ActiveView_type, wchar_t > ActiveView_traits;

      const ActiveView_optional&
      ActiveView () const;

      ActiveView_optional&
      ActiveView ();

      void
      ActiveView (const ActiveView_type& x);

      void
      ActiveView (const ActiveView_optional& x);

      static ActiveView_type
      ActiveView_default_value ();

      // AnnotationVisibleIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType AnnotationVisibleIds_type;
      typedef ::xsd::cxx::tree::optional< AnnotationVisibleIds_type > AnnotationVisibleIds_optional;
      typedef ::xsd::cxx::tree::traits< AnnotationVisibleIds_type, wchar_t > AnnotationVisibleIds_traits;

      const AnnotationVisibleIds_optional&
      AnnotationVisibleIds () const;

      AnnotationVisibleIds_optional&
      AnnotationVisibleIds ();

      void
      AnnotationVisibleIds (const AnnotationVisibleIds_type& x);

      void
      AnnotationVisibleIds (const AnnotationVisibleIds_optional& x);

      void
      AnnotationVisibleIds (::std::unique_ptr< AnnotationVisibleIds_type > p);

      // AnnotationHiddenIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType AnnotationHiddenIds_type;
      typedef ::xsd::cxx::tree::optional< AnnotationHiddenIds_type > AnnotationHiddenIds_optional;
      typedef ::xsd::cxx::tree::traits< AnnotationHiddenIds_type, wchar_t > AnnotationHiddenIds_traits;

      const AnnotationHiddenIds_optional&
      AnnotationHiddenIds () const;

      AnnotationHiddenIds_optional&
      AnnotationHiddenIds ();

      void
      AnnotationHiddenIds (const AnnotationHiddenIds_type& x);

      void
      AnnotationHiddenIds (const AnnotationHiddenIds_optional& x);

      void
      AnnotationHiddenIds (::std::unique_ptr< AnnotationHiddenIds_type > p);

      // BodyIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType BodyIds_type;
      typedef ::xsd::cxx::tree::optional< BodyIds_type > BodyIds_optional;
      typedef ::xsd::cxx::tree::traits< BodyIds_type, wchar_t > BodyIds_traits;

      const BodyIds_optional&
      BodyIds () const;

      BodyIds_optional&
      BodyIds ();

      void
      BodyIds (const BodyIds_type& x);

      void
      BodyIds (const BodyIds_optional& x);

      void
      BodyIds (::std::unique_ptr< BodyIds_type > p);

      // ComponentIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType ComponentIds_type;
      typedef ::xsd::cxx::tree::optional< ComponentIds_type > ComponentIds_optional;
      typedef ::xsd::cxx::tree::traits< ComponentIds_type, wchar_t > ComponentIds_traits;

      const ComponentIds_optional&
      ComponentIds () const;

      ComponentIds_optional&
      ComponentIds ();

      void
      ComponentIds (const ComponentIds_type& x);

      void
      ComponentIds (const ComponentIds_optional& x);

      void
      ComponentIds (::std::unique_ptr< ComponentIds_type > p);

      // SimplifiedRepresentationId
      //
      typedef ::xsd::qif30::QIFReferenceActiveType SimplifiedRepresentationId_type;
      typedef ::xsd::cxx::tree::optional< SimplifiedRepresentationId_type > SimplifiedRepresentationId_optional;
      typedef ::xsd::cxx::tree::traits< SimplifiedRepresentationId_type, wchar_t > SimplifiedRepresentationId_traits;

      const SimplifiedRepresentationId_optional&
      SimplifiedRepresentationId () const;

      SimplifiedRepresentationId_optional&
      SimplifiedRepresentationId ();

      void
      SimplifiedRepresentationId (const SimplifiedRepresentationId_type& x);

      void
      SimplifiedRepresentationId (const SimplifiedRepresentationId_optional& x);

      void
      SimplifiedRepresentationId (::std::unique_ptr< SimplifiedRepresentationId_type > p);

      // ExplodedViewId
      //
      typedef ::xsd::qif30::QIFReferenceActiveType ExplodedViewId_type;
      typedef ::xsd::cxx::tree::optional< ExplodedViewId_type > ExplodedViewId_optional;
      typedef ::xsd::cxx::tree::traits< ExplodedViewId_type, wchar_t > ExplodedViewId_traits;

      const ExplodedViewId_optional&
      ExplodedViewId () const;

      ExplodedViewId_optional&
      ExplodedViewId ();

      void
      ExplodedViewId (const ExplodedViewId_type& x);

      void
      ExplodedViewId (const ExplodedViewId_optional& x);

      void
      ExplodedViewId (::std::unique_ptr< ExplodedViewId_type > p);

      // DisplayStyleId
      //
      typedef ::xsd::qif30::QIFReferenceActiveType DisplayStyleId_type;
      typedef ::xsd::cxx::tree::optional< DisplayStyleId_type > DisplayStyleId_optional;
      typedef ::xsd::cxx::tree::traits< DisplayStyleId_type, wchar_t > DisplayStyleId_traits;

      const DisplayStyleId_optional&
      DisplayStyleId () const;

      DisplayStyleId_optional&
      DisplayStyleId ();

      void
      DisplayStyleId (const DisplayStyleId_type& x);

      void
      DisplayStyleId (const DisplayStyleId_optional& x);

      void
      DisplayStyleId (::std::unique_ptr< DisplayStyleId_type > p);

      // ZoneSectionId
      //
      typedef ::xsd::qif30::QIFReferenceActiveType ZoneSectionId_type;
      typedef ::xsd::cxx::tree::optional< ZoneSectionId_type > ZoneSectionId_optional;
      typedef ::xsd::cxx::tree::traits< ZoneSectionId_type, wchar_t > ZoneSectionId_traits;

      const ZoneSectionId_optional&
      ZoneSectionId () const;

      ZoneSectionId_optional&
      ZoneSectionId ();

      void
      ZoneSectionId (const ZoneSectionId_type& x);

      void
      ZoneSectionId (const ZoneSectionId_optional& x);

      void
      ZoneSectionId (::std::unique_ptr< ZoneSectionId_type > p);

      // CameraIds
      //
      typedef ::xsd::qif30::ArrayReferenceActiveType CameraIds_type;
      typedef ::xsd::cxx::tree::optional< CameraIds_type > CameraIds_optional;
      typedef ::xsd::cxx::tree::traits< CameraIds_type, wchar_t > CameraIds_traits;

      const CameraIds_optional&
      CameraIds () const;

      CameraIds_optional&
      CameraIds ();

      void
      CameraIds (const CameraIds_type& x);

      void
      CameraIds (const CameraIds_optional& x);

      void
      CameraIds (::std::unique_ptr< CameraIds_type > p);

      // Constructors.
      //
      SavedViewType ();

      SavedViewType (const id_type&);

      SavedViewType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      SavedViewType (const SavedViewType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual SavedViewType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SavedViewType&
      operator= (const SavedViewType& x);

      virtual 
      ~SavedViewType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ActiveView_optional ActiveView_;
      AnnotationVisibleIds_optional AnnotationVisibleIds_;
      AnnotationHiddenIds_optional AnnotationHiddenIds_;
      BodyIds_optional BodyIds_;
      ComponentIds_optional ComponentIds_;
      SimplifiedRepresentationId_optional SimplifiedRepresentationId_;
      ExplodedViewId_optional ExplodedViewId_;
      DisplayStyleId_optional DisplayStyleId_;
      ZoneSectionId_optional ZoneSectionId_;
      CameraIds_optional CameraIds_;
    };

    class QIF30_SYMBOL_DECL ZoneSectionType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // SectionPlanes
      //
      typedef ::xsd::qif30::ZoneSectionPlanesType SectionPlanes_type;
      typedef ::xsd::cxx::tree::traits< SectionPlanes_type, wchar_t > SectionPlanes_traits;

      const SectionPlanes_type&
      SectionPlanes () const;

      SectionPlanes_type&
      SectionPlanes ();

      void
      SectionPlanes (const SectionPlanes_type& x);

      void
      SectionPlanes (::std::unique_ptr< SectionPlanes_type > p);

      // LogicalOperations
      //
      typedef ::xsd::qif30::LogicalOperationsType LogicalOperations_type;
      typedef ::xsd::cxx::tree::optional< LogicalOperations_type > LogicalOperations_optional;
      typedef ::xsd::cxx::tree::traits< LogicalOperations_type, wchar_t > LogicalOperations_traits;

      const LogicalOperations_optional&
      LogicalOperations () const;

      LogicalOperations_optional&
      LogicalOperations ();

      void
      LogicalOperations (const LogicalOperations_type& x);

      void
      LogicalOperations (const LogicalOperations_optional& x);

      void
      LogicalOperations (::std::unique_ptr< LogicalOperations_type > p);

      // hatching
      //
      typedef ::xml_schema::boolean hatching_type;
      typedef ::xsd::cxx::tree::traits< hatching_type, wchar_t > hatching_traits;

      const hatching_type&
      hatching () const;

      hatching_type&
      hatching ();

      void
      hatching (const hatching_type& x);

      static hatching_type
      hatching_default_value ();

      // Constructors.
      //
      ZoneSectionType ();

      ZoneSectionType (const id_type&,
                       const SectionPlanes_type&);

      ZoneSectionType (const id_type&,
                       ::std::unique_ptr< SectionPlanes_type >);

      ZoneSectionType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ZoneSectionType (const ZoneSectionType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ZoneSectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ZoneSectionType&
      operator= (const ZoneSectionType& x);

      virtual 
      ~ZoneSectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SectionPlanes_type > SectionPlanes_;
      LogicalOperations_optional LogicalOperations_;
      ::xsd::cxx::tree::one< hatching_type > hatching_;
    };

    class QIF30_SYMBOL_DECL LogicalOperationType: public ::xml_schema::type
    {
      public:
      // Action
      //
      typedef ::xsd::qif30::LogicalOperationEnumType Action_type;
      typedef ::xsd::cxx::tree::traits< Action_type, wchar_t > Action_traits;

      const Action_type&
      Action () const;

      Action_type&
      Action ();

      void
      Action (const Action_type& x);

      void
      Action (::std::unique_ptr< Action_type > p);

      // SectionPlane
      //
      typedef ::xml_schema::unsigned_int SectionPlane_type;
      typedef ::xsd::cxx::tree::sequence< SectionPlane_type > SectionPlane_sequence;
      typedef xsd::cxx::tree::sequence< SectionPlane_type >::iterator SectionPlane_iterator;
      typedef xsd::cxx::tree::sequence< SectionPlane_type >::const_iterator SectionPlane_const_iterator;
      typedef ::xsd::cxx::tree::traits< SectionPlane_type, wchar_t > SectionPlane_traits;

      const SectionPlane_sequence&
      SectionPlane () const;

      SectionPlane_sequence&
      SectionPlane ();

      void
      SectionPlane (const SectionPlane_sequence& s);

      // LogicalOperationResult
      //
      typedef ::xml_schema::unsigned_int LogicalOperationResult_type;
      typedef ::xsd::cxx::tree::sequence< LogicalOperationResult_type > LogicalOperationResult_sequence;
      typedef xsd::cxx::tree::sequence< LogicalOperationResult_type >::iterator LogicalOperationResult_iterator;
      typedef xsd::cxx::tree::sequence< LogicalOperationResult_type >::const_iterator LogicalOperationResult_const_iterator;
      typedef ::xsd::cxx::tree::traits< LogicalOperationResult_type, wchar_t > LogicalOperationResult_traits;

      const LogicalOperationResult_sequence&
      LogicalOperationResult () const;

      LogicalOperationResult_sequence&
      LogicalOperationResult ();

      void
      LogicalOperationResult (const LogicalOperationResult_sequence& s);

      // index
      //
      typedef ::xml_schema::unsigned_int index_type;
      typedef ::xsd::cxx::tree::traits< index_type, wchar_t > index_traits;

      const index_type&
      index () const;

      index_type&
      index ();

      void
      index (const index_type& x);

      // Constructors.
      //
      LogicalOperationType ();

      LogicalOperationType (const Action_type&,
                            const index_type&);

      LogicalOperationType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      LogicalOperationType (const LogicalOperationType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual LogicalOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LogicalOperationType&
      operator= (const LogicalOperationType& x);

      virtual 
      ~LogicalOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Action_type > Action_;
      SectionPlane_sequence SectionPlane_;
      LogicalOperationResult_sequence LogicalOperationResult_;
      ::xsd::cxx::tree::one< index_type > index_;
    };

    class QIF30_SYMBOL_DECL LogicalOperationsType: public ::xml_schema::type
    {
      public:
      // LogicalOperation
      //
      typedef ::xsd::qif30::LogicalOperationType LogicalOperation_type;
      typedef ::xsd::cxx::tree::sequence< LogicalOperation_type > LogicalOperation_sequence;
      typedef xsd::cxx::tree::sequence< LogicalOperation_type >::iterator LogicalOperation_iterator;
      typedef xsd::cxx::tree::sequence< LogicalOperation_type >::const_iterator LogicalOperation_const_iterator;
      typedef ::xsd::cxx::tree::traits< LogicalOperation_type, wchar_t > LogicalOperation_traits;

      const LogicalOperation_sequence&
      LogicalOperation () const;

      LogicalOperation_sequence&
      LogicalOperation ();

      void
      LogicalOperation (const LogicalOperation_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      LogicalOperationsType ();

      LogicalOperationsType (const n_type&);

      LogicalOperationsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      LogicalOperationsType (const LogicalOperationsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual LogicalOperationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LogicalOperationsType&
      operator= (const LogicalOperationsType& x);

      virtual 
      ~LogicalOperationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LogicalOperation_sequence LogicalOperation_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL LogicalOperationEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        LOGICAL_AND,
        LOGICAL_OR
      };

      LogicalOperationEnumType ();

      LogicalOperationEnumType (value v);

      LogicalOperationEnumType (const wchar_t* v);

      LogicalOperationEnumType (const ::std::wstring& v);

      LogicalOperationEnumType (const ::xml_schema::string& v);

      LogicalOperationEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      LogicalOperationEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      LogicalOperationEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      LogicalOperationEnumType (const LogicalOperationEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LogicalOperationEnumType&
      operator= (const LogicalOperationEnumType&) = default;
#endif

      virtual LogicalOperationEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LogicalOperationEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LogicalOperationEnumType_convert ();
      }

      protected:
      value
      _xsd_LogicalOperationEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LogicalOperationEnumType_literals_[2];
      static const value _xsd_LogicalOperationEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL ZoneSectionPlanesType: public ::xml_schema::type
    {
      public:
      // SectionPlane
      //
      typedef ::xsd::qif30::ZoneSectionPlaneType SectionPlane_type;
      typedef ::xsd::cxx::tree::sequence< SectionPlane_type > SectionPlane_sequence;
      typedef xsd::cxx::tree::sequence< SectionPlane_type >::iterator SectionPlane_iterator;
      typedef xsd::cxx::tree::sequence< SectionPlane_type >::const_iterator SectionPlane_const_iterator;
      typedef ::xsd::cxx::tree::traits< SectionPlane_type, wchar_t > SectionPlane_traits;

      const SectionPlane_sequence&
      SectionPlane () const;

      SectionPlane_sequence&
      SectionPlane ();

      void
      SectionPlane (const SectionPlane_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ZoneSectionPlanesType ();

      ZoneSectionPlanesType (const n_type&);

      ZoneSectionPlanesType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ZoneSectionPlanesType (const ZoneSectionPlanesType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual ZoneSectionPlanesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ZoneSectionPlanesType&
      operator= (const ZoneSectionPlanesType& x);

      virtual 
      ~ZoneSectionPlanesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SectionPlane_sequence SectionPlane_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ZoneSectionPlaneType: public ::xml_schema::type
    {
      public:
      // Plane
      //
      typedef ::xsd::qif30::PlaneXType Plane_type;
      typedef ::xsd::cxx::tree::traits< Plane_type, wchar_t > Plane_traits;

      const Plane_type&
      Plane () const;

      Plane_type&
      Plane ();

      void
      Plane (const Plane_type& x);

      void
      Plane (::std::unique_ptr< Plane_type > p);

      // SectionGroups
      //
      typedef ::xsd::qif30::SectionGroupsType SectionGroups_type;
      typedef ::xsd::cxx::tree::optional< SectionGroups_type > SectionGroups_optional;
      typedef ::xsd::cxx::tree::traits< SectionGroups_type, wchar_t > SectionGroups_traits;

      const SectionGroups_optional&
      SectionGroups () const;

      SectionGroups_optional&
      SectionGroups ();

      void
      SectionGroups (const SectionGroups_type& x);

      void
      SectionGroups (const SectionGroups_optional& x);

      void
      SectionGroups (::std::unique_ptr< SectionGroups_type > p);

      // index
      //
      typedef ::xml_schema::unsigned_int index_type;
      typedef ::xsd::cxx::tree::traits< index_type, wchar_t > index_traits;

      const index_type&
      index () const;

      index_type&
      index ();

      void
      index (const index_type& x);

      // Constructors.
      //
      ZoneSectionPlaneType ();

      ZoneSectionPlaneType (const Plane_type&,
                            const index_type&);

      ZoneSectionPlaneType (::std::unique_ptr< Plane_type >,
                            const index_type&);

      ZoneSectionPlaneType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ZoneSectionPlaneType (const ZoneSectionPlaneType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ZoneSectionPlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ZoneSectionPlaneType&
      operator= (const ZoneSectionPlaneType& x);

      virtual 
      ~ZoneSectionPlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Plane_type > Plane_;
      SectionGroups_optional SectionGroups_;
      ::xsd::cxx::tree::one< index_type > index_;
    };

    class QIF30_SYMBOL_DECL SectionGroupsType: public ::xml_schema::type
    {
      public:
      // SectionGroup
      //
      typedef ::xsd::qif30::SectionGroupType SectionGroup_type;
      typedef ::xsd::cxx::tree::sequence< SectionGroup_type > SectionGroup_sequence;
      typedef xsd::cxx::tree::sequence< SectionGroup_type >::iterator SectionGroup_iterator;
      typedef xsd::cxx::tree::sequence< SectionGroup_type >::const_iterator SectionGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< SectionGroup_type, wchar_t > SectionGroup_traits;

      const SectionGroup_sequence&
      SectionGroup () const;

      SectionGroup_sequence&
      SectionGroup ();

      void
      SectionGroup (const SectionGroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SectionGroupsType ();

      SectionGroupsType (const n_type&);

      SectionGroupsType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      SectionGroupsType (const SectionGroupsType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual SectionGroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionGroupsType&
      operator= (const SectionGroupsType& x);

      virtual 
      ~SectionGroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SectionGroup_sequence SectionGroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SectionGroupType: public ::xml_schema::type
    {
      public:
      // BodyId
      //
      typedef ::xsd::qif30::QIFReferenceFullType BodyId_type;
      typedef ::xsd::cxx::tree::optional< BodyId_type > BodyId_optional;
      typedef ::xsd::cxx::tree::traits< BodyId_type, wchar_t > BodyId_traits;

      const BodyId_optional&
      BodyId () const;

      BodyId_optional&
      BodyId ();

      void
      BodyId (const BodyId_type& x);

      void
      BodyId (const BodyId_optional& x);

      void
      BodyId (::std::unique_ptr< BodyId_type > p);

      // Areas
      //
      typedef ::xsd::qif30::SectionAreasType Areas_type;
      typedef ::xsd::cxx::tree::optional< Areas_type > Areas_optional;
      typedef ::xsd::cxx::tree::traits< Areas_type, wchar_t > Areas_traits;

      const Areas_optional&
      Areas () const;

      Areas_optional&
      Areas ();

      void
      Areas (const Areas_type& x);

      void
      Areas (const Areas_optional& x);

      void
      Areas (::std::unique_ptr< Areas_type > p);

      // Paths
      //
      typedef ::xsd::qif30::SectionPathsType Paths_type;
      typedef ::xsd::cxx::tree::optional< Paths_type > Paths_optional;
      typedef ::xsd::cxx::tree::traits< Paths_type, wchar_t > Paths_traits;

      const Paths_optional&
      Paths () const;

      Paths_optional&
      Paths ();

      void
      Paths (const Paths_type& x);

      void
      Paths (const Paths_optional& x);

      void
      Paths (::std::unique_ptr< Paths_type > p);

      // Vertices
      //
      typedef ::xsd::qif30::ArrayReferenceType Vertices_type;
      typedef ::xsd::cxx::tree::optional< Vertices_type > Vertices_optional;
      typedef ::xsd::cxx::tree::traits< Vertices_type, wchar_t > Vertices_traits;

      const Vertices_optional&
      Vertices () const;

      Vertices_optional&
      Vertices ();

      void
      Vertices (const Vertices_type& x);

      void
      Vertices (const Vertices_optional& x);

      void
      Vertices (::std::unique_ptr< Vertices_type > p);

      // Constructors.
      //
      SectionGroupType ();

      SectionGroupType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SectionGroupType (const SectionGroupType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SectionGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionGroupType&
      operator= (const SectionGroupType& x);

      virtual 
      ~SectionGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BodyId_optional BodyId_;
      Areas_optional Areas_;
      Paths_optional Paths_;
      Vertices_optional Vertices_;
    };

    class QIF30_SYMBOL_DECL SectionPathsType: public ::xml_schema::type
    {
      public:
      // Path
      //
      typedef ::xsd::qif30::SectionPathType Path_type;
      typedef ::xsd::cxx::tree::sequence< Path_type > Path_sequence;
      typedef xsd::cxx::tree::sequence< Path_type >::iterator Path_iterator;
      typedef xsd::cxx::tree::sequence< Path_type >::const_iterator Path_const_iterator;
      typedef ::xsd::cxx::tree::traits< Path_type, wchar_t > Path_traits;

      const Path_sequence&
      Path () const;

      Path_sequence&
      Path ();

      void
      Path (const Path_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SectionPathsType ();

      SectionPathsType (const n_type&);

      SectionPathsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SectionPathsType (const SectionPathsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SectionPathsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionPathsType&
      operator= (const SectionPathsType& x);

      virtual 
      ~SectionPathsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Path_sequence Path_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SectionLoopsType: public ::xml_schema::type
    {
      public:
      // Loop
      //
      typedef ::xsd::qif30::SectionPathType Loop_type;
      typedef ::xsd::cxx::tree::sequence< Loop_type > Loop_sequence;
      typedef xsd::cxx::tree::sequence< Loop_type >::iterator Loop_iterator;
      typedef xsd::cxx::tree::sequence< Loop_type >::const_iterator Loop_const_iterator;
      typedef ::xsd::cxx::tree::traits< Loop_type, wchar_t > Loop_traits;

      const Loop_sequence&
      Loop () const;

      Loop_sequence&
      Loop ();

      void
      Loop (const Loop_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SectionLoopsType ();

      SectionLoopsType (const n_type&);

      SectionLoopsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SectionLoopsType (const SectionLoopsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SectionLoopsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionLoopsType&
      operator= (const SectionLoopsType& x);

      virtual 
      ~SectionLoopsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Loop_sequence Loop_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SectionAreasType: public ::xml_schema::type
    {
      public:
      // Area
      //
      typedef ::xsd::qif30::SectionAreaType Area_type;
      typedef ::xsd::cxx::tree::sequence< Area_type > Area_sequence;
      typedef xsd::cxx::tree::sequence< Area_type >::iterator Area_iterator;
      typedef xsd::cxx::tree::sequence< Area_type >::const_iterator Area_const_iterator;
      typedef ::xsd::cxx::tree::traits< Area_type, wchar_t > Area_traits;

      const Area_sequence&
      Area () const;

      Area_sequence&
      Area ();

      void
      Area (const Area_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SectionAreasType ();

      SectionAreasType (const n_type&);

      SectionAreasType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SectionAreasType (const SectionAreasType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SectionAreasType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionAreasType&
      operator= (const SectionAreasType& x);

      virtual 
      ~SectionAreasType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Area_sequence Area_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SectionAreaType: public ::xml_schema::type
    {
      public:
      // HatchStyleId
      //
      typedef ::xsd::qif30::QIFReferenceType HatchStyleId_type;
      typedef ::xsd::cxx::tree::optional< HatchStyleId_type > HatchStyleId_optional;
      typedef ::xsd::cxx::tree::traits< HatchStyleId_type, wchar_t > HatchStyleId_traits;

      const HatchStyleId_optional&
      HatchStyleId () const;

      HatchStyleId_optional&
      HatchStyleId ();

      void
      HatchStyleId (const HatchStyleId_type& x);

      void
      HatchStyleId (const HatchStyleId_optional& x);

      void
      HatchStyleId (::std::unique_ptr< HatchStyleId_type > p);

      // Loops
      //
      typedef ::xsd::qif30::SectionLoopsType Loops_type;
      typedef ::xsd::cxx::tree::traits< Loops_type, wchar_t > Loops_traits;

      const Loops_type&
      Loops () const;

      Loops_type&
      Loops ();

      void
      Loops (const Loops_type& x);

      void
      Loops (::std::unique_ptr< Loops_type > p);

      // Constructors.
      //
      SectionAreaType ();

      SectionAreaType (const Loops_type&);

      SectionAreaType (::std::unique_ptr< Loops_type >);

      SectionAreaType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      SectionAreaType (const SectionAreaType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual SectionAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionAreaType&
      operator= (const SectionAreaType& x);

      virtual 
      ~SectionAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      HatchStyleId_optional HatchStyleId_;
      ::xsd::cxx::tree::one< Loops_type > Loops_;
    };

    class QIF30_SYMBOL_DECL SectionEdgesType: public ::xml_schema::type
    {
      public:
      // Edge
      //
      typedef ::xsd::qif30::EdgeOrientedType Edge_type;
      typedef ::xsd::cxx::tree::sequence< Edge_type > Edge_sequence;
      typedef xsd::cxx::tree::sequence< Edge_type >::iterator Edge_iterator;
      typedef xsd::cxx::tree::sequence< Edge_type >::const_iterator Edge_const_iterator;
      typedef ::xsd::cxx::tree::traits< Edge_type, wchar_t > Edge_traits;

      const Edge_sequence&
      Edge () const;

      Edge_sequence&
      Edge ();

      void
      Edge (const Edge_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SectionEdgesType ();

      SectionEdgesType (const n_type&);

      SectionEdgesType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SectionEdgesType (const SectionEdgesType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SectionEdgesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionEdgesType&
      operator= (const SectionEdgesType& x);

      virtual 
      ~SectionEdgesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Edge_sequence Edge_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SectionPathType: public ::xml_schema::type
    {
      public:
      // Edges
      //
      typedef ::xsd::qif30::SectionEdgesType Edges_type;
      typedef ::xsd::cxx::tree::traits< Edges_type, wchar_t > Edges_traits;

      const Edges_type&
      Edges () const;

      Edges_type&
      Edges ();

      void
      Edges (const Edges_type& x);

      void
      Edges (::std::unique_ptr< Edges_type > p);

      // Constructors.
      //
      SectionPathType ();

      SectionPathType (const Edges_type&);

      SectionPathType (::std::unique_ptr< Edges_type >);

      SectionPathType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      SectionPathType (const SectionPathType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual SectionPathType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionPathType&
      operator= (const SectionPathType& x);

      virtual 
      ~SectionPathType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Edges_type > Edges_;
    };

    class QIF30_SYMBOL_DECL HatchPatternsType: public ::xml_schema::type
    {
      public:
      // Pattern
      //
      typedef ::xsd::qif30::HatchPatternType Pattern_type;
      typedef ::xsd::cxx::tree::sequence< Pattern_type > Pattern_sequence;
      typedef xsd::cxx::tree::sequence< Pattern_type >::iterator Pattern_iterator;
      typedef xsd::cxx::tree::sequence< Pattern_type >::const_iterator Pattern_const_iterator;
      typedef ::xsd::cxx::tree::traits< Pattern_type, wchar_t > Pattern_traits;

      const Pattern_sequence&
      Pattern () const;

      Pattern_sequence&
      Pattern ();

      void
      Pattern (const Pattern_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      HatchPatternsType ();

      HatchPatternsType (const n_type&);

      HatchPatternsType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      HatchPatternsType (const HatchPatternsType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual HatchPatternsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      HatchPatternsType&
      operator= (const HatchPatternsType& x);

      virtual 
      ~HatchPatternsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Pattern_sequence Pattern_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL HatchStyleType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // Form
      //
      typedef ::xsd::qif30::HatchStyleFormEnumType Form_type;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_type&
      Form () const;

      Form_type&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Color
      //
      typedef ::xsd::qif30::ColorType Color_type;
      typedef ::xsd::cxx::tree::optional< Color_type > Color_optional;
      typedef ::xsd::cxx::tree::traits< Color_type, wchar_t > Color_traits;

      const Color_optional&
      Color () const;

      Color_optional&
      Color ();

      void
      Color (const Color_type& x);

      void
      Color (const Color_optional& x);

      void
      Color (::std::unique_ptr< Color_type > p);

      // Patterns
      //
      typedef ::xsd::qif30::HatchPatternsType Patterns_type;
      typedef ::xsd::cxx::tree::optional< Patterns_type > Patterns_optional;
      typedef ::xsd::cxx::tree::traits< Patterns_type, wchar_t > Patterns_traits;

      const Patterns_optional&
      Patterns () const;

      Patterns_optional&
      Patterns ();

      void
      Patterns (const Patterns_type& x);

      void
      Patterns (const Patterns_optional& x);

      void
      Patterns (::std::unique_ptr< Patterns_type > p);

      // Constructors.
      //
      HatchStyleType ();

      HatchStyleType (const id_type&,
                      const Form_type&);

      HatchStyleType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      HatchStyleType (const HatchStyleType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual HatchStyleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      HatchStyleType&
      operator= (const HatchStyleType& x);

      virtual 
      ~HatchStyleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Form_type > Form_;
      Color_optional Color_;
      Patterns_optional Patterns_;
    };

    class QIF30_SYMBOL_DECL HatchStyleFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        NONE,
        PATTERN,
        FILL,
        ERASED
      };

      HatchStyleFormEnumType ();

      HatchStyleFormEnumType (value v);

      HatchStyleFormEnumType (const wchar_t* v);

      HatchStyleFormEnumType (const ::std::wstring& v);

      HatchStyleFormEnumType (const ::xml_schema::string& v);

      HatchStyleFormEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      HatchStyleFormEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      HatchStyleFormEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      HatchStyleFormEnumType (const HatchStyleFormEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      HatchStyleFormEnumType&
      operator= (const HatchStyleFormEnumType&) = default;
#endif

      virtual HatchStyleFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      HatchStyleFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_HatchStyleFormEnumType_convert ();
      }

      protected:
      value
      _xsd_HatchStyleFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_HatchStyleFormEnumType_literals_[4];
      static const value _xsd_HatchStyleFormEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL HatchPatternType: public ::xml_schema::type
    {
      public:
      // LineStyle
      //
      typedef ::xsd::qif30::LineStyleType LineStyle_type;
      typedef ::xsd::cxx::tree::optional< LineStyle_type > LineStyle_optional;
      typedef ::xsd::cxx::tree::traits< LineStyle_type, wchar_t > LineStyle_traits;

      const LineStyle_optional&
      LineStyle () const;

      LineStyle_optional&
      LineStyle ();

      void
      LineStyle (const LineStyle_type& x);

      void
      LineStyle (const LineStyle_optional& x);

      void
      LineStyle (::std::unique_ptr< LineStyle_type > p);

      // FirstLineOrigin
      //
      typedef ::xsd::qif30::Point2dSimpleType FirstLineOrigin_type;
      typedef ::xsd::cxx::tree::traits< FirstLineOrigin_type, wchar_t > FirstLineOrigin_traits;

      const FirstLineOrigin_type&
      FirstLineOrigin () const;

      FirstLineOrigin_type&
      FirstLineOrigin ();

      void
      FirstLineOrigin (const FirstLineOrigin_type& x);

      void
      FirstLineOrigin (::std::unique_ptr< FirstLineOrigin_type > p);

      // SecondLineOrigin
      //
      typedef ::xsd::qif30::Point2dSimpleType SecondLineOrigin_type;
      typedef ::xsd::cxx::tree::traits< SecondLineOrigin_type, wchar_t > SecondLineOrigin_traits;

      const SecondLineOrigin_type&
      SecondLineOrigin () const;

      SecondLineOrigin_type&
      SecondLineOrigin ();

      void
      SecondLineOrigin (const SecondLineOrigin_type& x);

      void
      SecondLineOrigin (::std::unique_ptr< SecondLineOrigin_type > p);

      // Angle
      //
      typedef ::xsd::qif30::AngularValueType Angle_type;
      typedef ::xsd::cxx::tree::traits< Angle_type, wchar_t > Angle_traits;

      const Angle_type&
      Angle () const;

      Angle_type&
      Angle ();

      void
      Angle (const Angle_type& x);

      void
      Angle (::std::unique_ptr< Angle_type > p);

      // Color
      //
      typedef ::xsd::qif30::ColorType Color_type;
      typedef ::xsd::cxx::tree::optional< Color_type > Color_optional;
      typedef ::xsd::cxx::tree::traits< Color_type, wchar_t > Color_traits;

      const Color_optional&
      Color () const;

      Color_optional&
      Color ();

      void
      Color (const Color_type& x);

      void
      Color (const Color_optional& x);

      void
      Color (::std::unique_ptr< Color_type > p);

      // Constructors.
      //
      HatchPatternType ();

      HatchPatternType (const FirstLineOrigin_type&,
                        const SecondLineOrigin_type&,
                        const Angle_type&);

      HatchPatternType (const FirstLineOrigin_type&,
                        const SecondLineOrigin_type&,
                        ::std::unique_ptr< Angle_type >);

      HatchPatternType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      HatchPatternType (const HatchPatternType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual HatchPatternType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      HatchPatternType&
      operator= (const HatchPatternType& x);

      virtual 
      ~HatchPatternType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LineStyle_optional LineStyle_;
      ::xsd::cxx::tree::one< FirstLineOrigin_type > FirstLineOrigin_;
      ::xsd::cxx::tree::one< SecondLineOrigin_type > SecondLineOrigin_;
      ::xsd::cxx::tree::one< Angle_type > Angle_;
      Color_optional Color_;
    };

    class QIF30_SYMBOL_DECL DisplayStyleType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // Mode
      //
      typedef ::xsd::qif30::DisplayStyleModeType Mode_type;
      typedef ::xsd::cxx::tree::traits< Mode_type, wchar_t > Mode_traits;

      const Mode_type&
      Mode () const;

      Mode_type&
      Mode ();

      void
      Mode (const Mode_type& x);

      void
      Mode (::std::unique_ptr< Mode_type > p);

      // DisplayStyleGroups
      //
      typedef ::xsd::qif30::DisplayStyleGroupsType DisplayStyleGroups_type;
      typedef ::xsd::cxx::tree::optional< DisplayStyleGroups_type > DisplayStyleGroups_optional;
      typedef ::xsd::cxx::tree::traits< DisplayStyleGroups_type, wchar_t > DisplayStyleGroups_traits;

      const DisplayStyleGroups_optional&
      DisplayStyleGroups () const;

      DisplayStyleGroups_optional&
      DisplayStyleGroups ();

      void
      DisplayStyleGroups (const DisplayStyleGroups_type& x);

      void
      DisplayStyleGroups (const DisplayStyleGroups_optional& x);

      void
      DisplayStyleGroups (::std::unique_ptr< DisplayStyleGroups_type > p);

      // Constructors.
      //
      DisplayStyleType ();

      DisplayStyleType (const id_type&,
                        const Mode_type&);

      DisplayStyleType (const id_type&,
                        ::std::unique_ptr< Mode_type >);

      DisplayStyleType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      DisplayStyleType (const DisplayStyleType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual DisplayStyleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DisplayStyleType&
      operator= (const DisplayStyleType& x);

      virtual 
      ~DisplayStyleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Mode_type > Mode_;
      DisplayStyleGroups_optional DisplayStyleGroups_;
    };

    class QIF30_SYMBOL_DECL DisplayStyleGroupsType: public ::xml_schema::type
    {
      public:
      // DisplayStyleGroup
      //
      typedef ::xsd::qif30::DisplayStyleGroupType DisplayStyleGroup_type;
      typedef ::xsd::cxx::tree::sequence< DisplayStyleGroup_type > DisplayStyleGroup_sequence;
      typedef xsd::cxx::tree::sequence< DisplayStyleGroup_type >::iterator DisplayStyleGroup_iterator;
      typedef xsd::cxx::tree::sequence< DisplayStyleGroup_type >::const_iterator DisplayStyleGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< DisplayStyleGroup_type, wchar_t > DisplayStyleGroup_traits;

      const DisplayStyleGroup_sequence&
      DisplayStyleGroup () const;

      DisplayStyleGroup_sequence&
      DisplayStyleGroup ();

      void
      DisplayStyleGroup (const DisplayStyleGroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DisplayStyleGroupsType ();

      DisplayStyleGroupsType (const n_type&);

      DisplayStyleGroupsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      DisplayStyleGroupsType (const DisplayStyleGroupsType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual DisplayStyleGroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DisplayStyleGroupsType&
      operator= (const DisplayStyleGroupsType& x);

      virtual 
      ~DisplayStyleGroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DisplayStyleGroup_sequence DisplayStyleGroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DisplayStyleModeType: public ::xml_schema::type
    {
      public:
      // Form
      //
      typedef ::xsd::qif30::DisplayStyleFormEnumType Form_type;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_type&
      Form () const;

      Form_type&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Color
      //
      typedef ::xsd::qif30::ColorType Color_type;
      typedef ::xsd::cxx::tree::optional< Color_type > Color_optional;
      typedef ::xsd::cxx::tree::traits< Color_type, wchar_t > Color_traits;

      const Color_optional&
      Color () const;

      Color_optional&
      Color ();

      void
      Color (const Color_type& x);

      void
      Color (const Color_optional& x);

      void
      Color (::std::unique_ptr< Color_type > p);

      // Transparency
      //
      typedef ::xsd::qif30::TransparencyType Transparency_type;
      typedef ::xsd::cxx::tree::optional< Transparency_type > Transparency_optional;
      typedef ::xsd::cxx::tree::traits< Transparency_type, wchar_t > Transparency_traits;

      const Transparency_optional&
      Transparency () const;

      Transparency_optional&
      Transparency ();

      void
      Transparency (const Transparency_type& x);

      void
      Transparency (const Transparency_optional& x);

      void
      Transparency (::std::unique_ptr< Transparency_type > p);

      static Transparency_type
      Transparency_default_value ();

      // Constructors.
      //
      DisplayStyleModeType ();

      DisplayStyleModeType (const Form_type&);

      DisplayStyleModeType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DisplayStyleModeType (const DisplayStyleModeType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DisplayStyleModeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DisplayStyleModeType&
      operator= (const DisplayStyleModeType& x);

      virtual 
      ~DisplayStyleModeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Form_type > Form_;
      Color_optional Color_;
      Transparency_optional Transparency_;
    };

    class QIF30_SYMBOL_DECL DisplayStyleGroupType: public ::xml_schema::type
    {
      public:
      // Mode
      //
      typedef ::xsd::qif30::DisplayStyleModeType Mode_type;
      typedef ::xsd::cxx::tree::traits< Mode_type, wchar_t > Mode_traits;

      const Mode_type&
      Mode () const;

      Mode_type&
      Mode ();

      void
      Mode (const Mode_type& x);

      void
      Mode (::std::unique_ptr< Mode_type > p);

      // ComponentIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType ComponentIds_type;
      typedef ::xsd::cxx::tree::optional< ComponentIds_type > ComponentIds_optional;
      typedef ::xsd::cxx::tree::traits< ComponentIds_type, wchar_t > ComponentIds_traits;

      const ComponentIds_optional&
      ComponentIds () const;

      ComponentIds_optional&
      ComponentIds ();

      void
      ComponentIds (const ComponentIds_type& x);

      void
      ComponentIds (const ComponentIds_optional& x);

      void
      ComponentIds (::std::unique_ptr< ComponentIds_type > p);

      // BodyIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType BodyIds_type;
      typedef ::xsd::cxx::tree::optional< BodyIds_type > BodyIds_optional;
      typedef ::xsd::cxx::tree::traits< BodyIds_type, wchar_t > BodyIds_traits;

      const BodyIds_optional&
      BodyIds () const;

      BodyIds_optional&
      BodyIds ();

      void
      BodyIds (const BodyIds_type& x);

      void
      BodyIds (const BodyIds_optional& x);

      void
      BodyIds (::std::unique_ptr< BodyIds_type > p);

      // Constructors.
      //
      DisplayStyleGroupType ();

      DisplayStyleGroupType (const Mode_type&);

      DisplayStyleGroupType (::std::unique_ptr< Mode_type >);

      DisplayStyleGroupType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      DisplayStyleGroupType (const DisplayStyleGroupType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual DisplayStyleGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DisplayStyleGroupType&
      operator= (const DisplayStyleGroupType& x);

      virtual 
      ~DisplayStyleGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Mode_type > Mode_;
      ComponentIds_optional ComponentIds_;
      BodyIds_optional BodyIds_;
    };

    class QIF30_SYMBOL_DECL DisplayStyleFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        WIREFRAME,
        ISOLINES,
        ISOLINES_WITH_EDGES,
        SHADING,
        SHADING_WITH_EDGES
      };

      DisplayStyleFormEnumType ();

      DisplayStyleFormEnumType (value v);

      DisplayStyleFormEnumType (const wchar_t* v);

      DisplayStyleFormEnumType (const ::std::wstring& v);

      DisplayStyleFormEnumType (const ::xml_schema::string& v);

      DisplayStyleFormEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DisplayStyleFormEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DisplayStyleFormEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DisplayStyleFormEnumType (const DisplayStyleFormEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DisplayStyleFormEnumType&
      operator= (const DisplayStyleFormEnumType&) = default;
#endif

      virtual DisplayStyleFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DisplayStyleFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DisplayStyleFormEnumType_convert ();
      }

      protected:
      value
      _xsd_DisplayStyleFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DisplayStyleFormEnumType_literals_[5];
      static const value _xsd_DisplayStyleFormEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL ExplodedViewType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // MoveGroups
      //
      typedef ::xsd::qif30::ExplodedViewMoveGroupsType MoveGroups_type;
      typedef ::xsd::cxx::tree::traits< MoveGroups_type, wchar_t > MoveGroups_traits;

      const MoveGroups_type&
      MoveGroups () const;

      MoveGroups_type&
      MoveGroups ();

      void
      MoveGroups (const MoveGroups_type& x);

      void
      MoveGroups (::std::unique_ptr< MoveGroups_type > p);

      // Constructors.
      //
      ExplodedViewType ();

      ExplodedViewType (const id_type&,
                        const MoveGroups_type&);

      ExplodedViewType (const id_type&,
                        ::std::unique_ptr< MoveGroups_type >);

      ExplodedViewType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ExplodedViewType (const ExplodedViewType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ExplodedViewType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExplodedViewType&
      operator= (const ExplodedViewType& x);

      virtual 
      ~ExplodedViewType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MoveGroups_type > MoveGroups_;
    };

    class QIF30_SYMBOL_DECL ExplodedViewMoveGroupsType: public ::xml_schema::type
    {
      public:
      // MoveGroup
      //
      typedef ::xsd::qif30::ExplodedViewMoveGroupType MoveGroup_type;
      typedef ::xsd::cxx::tree::sequence< MoveGroup_type > MoveGroup_sequence;
      typedef xsd::cxx::tree::sequence< MoveGroup_type >::iterator MoveGroup_iterator;
      typedef xsd::cxx::tree::sequence< MoveGroup_type >::const_iterator MoveGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< MoveGroup_type, wchar_t > MoveGroup_traits;

      const MoveGroup_sequence&
      MoveGroup () const;

      MoveGroup_sequence&
      MoveGroup ();

      void
      MoveGroup (const MoveGroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ExplodedViewMoveGroupsType ();

      ExplodedViewMoveGroupsType (const n_type&);

      ExplodedViewMoveGroupsType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ExplodedViewMoveGroupsType (const ExplodedViewMoveGroupsType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ExplodedViewMoveGroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExplodedViewMoveGroupsType&
      operator= (const ExplodedViewMoveGroupsType& x);

      virtual 
      ~ExplodedViewMoveGroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MoveGroup_sequence MoveGroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ExplodedViewMoveGroupType: public ::xml_schema::type
    {
      public:
      // Translate
      //
      typedef ::xsd::qif30::ExplodedViewTranslateType Translate_type;
      typedef ::xsd::cxx::tree::optional< Translate_type > Translate_optional;
      typedef ::xsd::cxx::tree::traits< Translate_type, wchar_t > Translate_traits;

      const Translate_optional&
      Translate () const;

      Translate_optional&
      Translate ();

      void
      Translate (const Translate_type& x);

      void
      Translate (const Translate_optional& x);

      void
      Translate (::std::unique_ptr< Translate_type > p);

      // Rotate
      //
      typedef ::xsd::qif30::ExplodedViewRotateType Rotate_type;
      typedef ::xsd::cxx::tree::optional< Rotate_type > Rotate_optional;
      typedef ::xsd::cxx::tree::traits< Rotate_type, wchar_t > Rotate_traits;

      const Rotate_optional&
      Rotate () const;

      Rotate_optional&
      Rotate ();

      void
      Rotate (const Rotate_type& x);

      void
      Rotate (const Rotate_optional& x);

      void
      Rotate (::std::unique_ptr< Rotate_type > p);

      // ComponentIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType ComponentIds_type;
      typedef ::xsd::cxx::tree::optional< ComponentIds_type > ComponentIds_optional;
      typedef ::xsd::cxx::tree::traits< ComponentIds_type, wchar_t > ComponentIds_traits;

      const ComponentIds_optional&
      ComponentIds () const;

      ComponentIds_optional&
      ComponentIds ();

      void
      ComponentIds (const ComponentIds_type& x);

      void
      ComponentIds (const ComponentIds_optional& x);

      void
      ComponentIds (::std::unique_ptr< ComponentIds_type > p);

      // BodyIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType BodyIds_type;
      typedef ::xsd::cxx::tree::optional< BodyIds_type > BodyIds_optional;
      typedef ::xsd::cxx::tree::traits< BodyIds_type, wchar_t > BodyIds_traits;

      const BodyIds_optional&
      BodyIds () const;

      BodyIds_optional&
      BodyIds ();

      void
      BodyIds (const BodyIds_type& x);

      void
      BodyIds (const BodyIds_optional& x);

      void
      BodyIds (::std::unique_ptr< BodyIds_type > p);

      // Constructors.
      //
      ExplodedViewMoveGroupType ();

      ExplodedViewMoveGroupType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ExplodedViewMoveGroupType (const ExplodedViewMoveGroupType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ExplodedViewMoveGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExplodedViewMoveGroupType&
      operator= (const ExplodedViewMoveGroupType& x);

      virtual 
      ~ExplodedViewMoveGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Translate_optional Translate_;
      Rotate_optional Rotate_;
      ComponentIds_optional ComponentIds_;
      BodyIds_optional BodyIds_;
    };

    class QIF30_SYMBOL_DECL ExplodedViewTranslateType: public ::xml_schema::type
    {
      public:
      // Direction
      //
      typedef ::xsd::qif30::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // Value
      //
      typedef ::xsd::qif30::LinearValueType Value_type;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_type&
      Value () const;

      Value_type&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (::std::unique_ptr< Value_type > p);

      // Constructors.
      //
      ExplodedViewTranslateType ();

      ExplodedViewTranslateType (const Direction_type&,
                                 const Value_type&);

      ExplodedViewTranslateType (::std::unique_ptr< Direction_type >,
                                 ::std::unique_ptr< Value_type >);

      ExplodedViewTranslateType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ExplodedViewTranslateType (const ExplodedViewTranslateType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ExplodedViewTranslateType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExplodedViewTranslateType&
      operator= (const ExplodedViewTranslateType& x);

      virtual 
      ~ExplodedViewTranslateType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Direction_type > Direction_;
      ::xsd::cxx::tree::one< Value_type > Value_;
    };

    class QIF30_SYMBOL_DECL ExplodedViewRotateType: public ::xml_schema::type
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Angle
      //
      typedef ::xsd::qif30::AngularValueType Angle_type;
      typedef ::xsd::cxx::tree::traits< Angle_type, wchar_t > Angle_traits;

      const Angle_type&
      Angle () const;

      Angle_type&
      Angle ();

      void
      Angle (const Angle_type& x);

      void
      Angle (::std::unique_ptr< Angle_type > p);

      // Constructors.
      //
      ExplodedViewRotateType ();

      ExplodedViewRotateType (const Axis_type&,
                              const Angle_type&);

      ExplodedViewRotateType (::std::unique_ptr< Axis_type >,
                              ::std::unique_ptr< Angle_type >);

      ExplodedViewRotateType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ExplodedViewRotateType (const ExplodedViewRotateType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ExplodedViewRotateType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExplodedViewRotateType&
      operator= (const ExplodedViewRotateType& x);

      virtual 
      ~ExplodedViewRotateType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< Angle_type > Angle_;
    };

    class QIF30_SYMBOL_DECL SimplifiedRepresentationFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        MASTER,
        HIDE,
        BOUNDING_BOX
      };

      SimplifiedRepresentationFormEnumType ();

      SimplifiedRepresentationFormEnumType (value v);

      SimplifiedRepresentationFormEnumType (const wchar_t* v);

      SimplifiedRepresentationFormEnumType (const ::std::wstring& v);

      SimplifiedRepresentationFormEnumType (const ::xml_schema::string& v);

      SimplifiedRepresentationFormEnumType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      SimplifiedRepresentationFormEnumType (const xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      SimplifiedRepresentationFormEnumType (const ::std::wstring& s,
                                            const xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      SimplifiedRepresentationFormEnumType (const SimplifiedRepresentationFormEnumType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SimplifiedRepresentationFormEnumType&
      operator= (const SimplifiedRepresentationFormEnumType&) = default;
#endif

      virtual SimplifiedRepresentationFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimplifiedRepresentationFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SimplifiedRepresentationFormEnumType_convert ();
      }

      protected:
      value
      _xsd_SimplifiedRepresentationFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_SimplifiedRepresentationFormEnumType_literals_[3];
      static const value _xsd_SimplifiedRepresentationFormEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL SimplifiedRepresentationType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // Form
      //
      typedef ::xsd::qif30::SimplifiedRepresentationFormEnumType Form_type;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_type&
      Form () const;

      Form_type&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // SimplifiedRepresentationGroups
      //
      typedef ::xsd::qif30::SimplifiedRepresentationGroupsType SimplifiedRepresentationGroups_type;
      typedef ::xsd::cxx::tree::optional< SimplifiedRepresentationGroups_type > SimplifiedRepresentationGroups_optional;
      typedef ::xsd::cxx::tree::traits< SimplifiedRepresentationGroups_type, wchar_t > SimplifiedRepresentationGroups_traits;

      const SimplifiedRepresentationGroups_optional&
      SimplifiedRepresentationGroups () const;

      SimplifiedRepresentationGroups_optional&
      SimplifiedRepresentationGroups ();

      void
      SimplifiedRepresentationGroups (const SimplifiedRepresentationGroups_type& x);

      void
      SimplifiedRepresentationGroups (const SimplifiedRepresentationGroups_optional& x);

      void
      SimplifiedRepresentationGroups (::std::unique_ptr< SimplifiedRepresentationGroups_type > p);

      // Constructors.
      //
      SimplifiedRepresentationType ();

      SimplifiedRepresentationType (const id_type&,
                                    const Form_type&);

      SimplifiedRepresentationType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SimplifiedRepresentationType (const SimplifiedRepresentationType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SimplifiedRepresentationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimplifiedRepresentationType&
      operator= (const SimplifiedRepresentationType& x);

      virtual 
      ~SimplifiedRepresentationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Form_type > Form_;
      SimplifiedRepresentationGroups_optional SimplifiedRepresentationGroups_;
    };

    class QIF30_SYMBOL_DECL SimplifiedRepresentationGroupsType: public ::xml_schema::type
    {
      public:
      // SimplifiedRepresentationGroup
      //
      typedef ::xsd::qif30::SimplifiedRepresentationGroupType SimplifiedRepresentationGroup_type;
      typedef ::xsd::cxx::tree::sequence< SimplifiedRepresentationGroup_type > SimplifiedRepresentationGroup_sequence;
      typedef xsd::cxx::tree::sequence< SimplifiedRepresentationGroup_type >::iterator SimplifiedRepresentationGroup_iterator;
      typedef xsd::cxx::tree::sequence< SimplifiedRepresentationGroup_type >::const_iterator SimplifiedRepresentationGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< SimplifiedRepresentationGroup_type, wchar_t > SimplifiedRepresentationGroup_traits;

      const SimplifiedRepresentationGroup_sequence&
      SimplifiedRepresentationGroup () const;

      SimplifiedRepresentationGroup_sequence&
      SimplifiedRepresentationGroup ();

      void
      SimplifiedRepresentationGroup (const SimplifiedRepresentationGroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SimplifiedRepresentationGroupsType ();

      SimplifiedRepresentationGroupsType (const n_type&);

      SimplifiedRepresentationGroupsType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SimplifiedRepresentationGroupsType (const SimplifiedRepresentationGroupsType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SimplifiedRepresentationGroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimplifiedRepresentationGroupsType&
      operator= (const SimplifiedRepresentationGroupsType& x);

      virtual 
      ~SimplifiedRepresentationGroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SimplifiedRepresentationGroup_sequence SimplifiedRepresentationGroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SimplifiedRepresentationGroupType: public ::xml_schema::type
    {
      public:
      // Form
      //
      typedef ::xsd::qif30::SimplifiedRepresentationFormEnumType Form_type;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_type&
      Form () const;

      Form_type&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // ComponentIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType ComponentIds_type;
      typedef ::xsd::cxx::tree::optional< ComponentIds_type > ComponentIds_optional;
      typedef ::xsd::cxx::tree::traits< ComponentIds_type, wchar_t > ComponentIds_traits;

      const ComponentIds_optional&
      ComponentIds () const;

      ComponentIds_optional&
      ComponentIds ();

      void
      ComponentIds (const ComponentIds_type& x);

      void
      ComponentIds (const ComponentIds_optional& x);

      void
      ComponentIds (::std::unique_ptr< ComponentIds_type > p);

      // BodyIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType BodyIds_type;
      typedef ::xsd::cxx::tree::optional< BodyIds_type > BodyIds_optional;
      typedef ::xsd::cxx::tree::traits< BodyIds_type, wchar_t > BodyIds_traits;

      const BodyIds_optional&
      BodyIds () const;

      BodyIds_optional&
      BodyIds ();

      void
      BodyIds (const BodyIds_type& x);

      void
      BodyIds (const BodyIds_optional& x);

      void
      BodyIds (::std::unique_ptr< BodyIds_type > p);

      // Constructors.
      //
      SimplifiedRepresentationGroupType ();

      SimplifiedRepresentationGroupType (const Form_type&);

      SimplifiedRepresentationGroupType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      SimplifiedRepresentationGroupType (const SimplifiedRepresentationGroupType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual SimplifiedRepresentationGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimplifiedRepresentationGroupType&
      operator= (const SimplifiedRepresentationGroupType& x);

      virtual 
      ~SimplifiedRepresentationGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Form_type > Form_;
      ComponentIds_optional ComponentIds_;
      BodyIds_optional BodyIds_;
    };

    class QIF30_SYMBOL_DECL AnnotationViewType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Direction
      //
      typedef ::xsd::qif30::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // Constructors.
      //
      AnnotationViewType ();

      AnnotationViewType (const id_type&,
                          const Normal_type&,
                          const Direction_type&);

      AnnotationViewType (const id_type&,
                          ::std::unique_ptr< Normal_type >,
                          ::std::unique_ptr< Direction_type >);

      AnnotationViewType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      AnnotationViewType (const AnnotationViewType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual AnnotationViewType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AnnotationViewType&
      operator= (const AnnotationViewType& x);

      virtual 
      ~AnnotationViewType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      ::xsd::cxx::tree::one< Direction_type > Direction_;
    };

    class QIF30_SYMBOL_DECL CameraSetType: public ::xml_schema::type
    {
      public:
      // Camera
      //
      typedef ::xsd::qif30::CameraType Camera_type;
      typedef ::xsd::cxx::tree::sequence< Camera_type > Camera_sequence;
      typedef xsd::cxx::tree::sequence< Camera_type >::iterator Camera_iterator;
      typedef xsd::cxx::tree::sequence< Camera_type >::const_iterator Camera_const_iterator;
      typedef ::xsd::cxx::tree::traits< Camera_type, wchar_t > Camera_traits;

      const Camera_sequence&
      Camera () const;

      Camera_sequence&
      Camera ();

      void
      Camera (const Camera_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CameraSetType ();

      CameraSetType (const n_type&);

      CameraSetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      CameraSetType (const CameraSetType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual CameraSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CameraSetType&
      operator= (const CameraSetType& x);

      virtual 
      ~CameraSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Camera_sequence Camera_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SavedViewSetType: public ::xml_schema::type
    {
      public:
      // SavedView
      //
      typedef ::xsd::qif30::SavedViewType SavedView_type;
      typedef ::xsd::cxx::tree::sequence< SavedView_type > SavedView_sequence;
      typedef xsd::cxx::tree::sequence< SavedView_type >::iterator SavedView_iterator;
      typedef xsd::cxx::tree::sequence< SavedView_type >::const_iterator SavedView_const_iterator;
      typedef ::xsd::cxx::tree::traits< SavedView_type, wchar_t > SavedView_traits;

      const SavedView_sequence&
      SavedView () const;

      SavedView_sequence&
      SavedView ();

      void
      SavedView (const SavedView_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SavedViewSetType ();

      SavedViewSetType (const n_type&);

      SavedViewSetType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SavedViewSetType (const SavedViewSetType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SavedViewSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SavedViewSetType&
      operator= (const SavedViewSetType& x);

      virtual 
      ~SavedViewSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SavedView_sequence SavedView_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AnnotationViewSetType: public ::xml_schema::type
    {
      public:
      // AnnotationView
      //
      typedef ::xsd::qif30::AnnotationViewType AnnotationView_type;
      typedef ::xsd::cxx::tree::sequence< AnnotationView_type > AnnotationView_sequence;
      typedef xsd::cxx::tree::sequence< AnnotationView_type >::iterator AnnotationView_iterator;
      typedef xsd::cxx::tree::sequence< AnnotationView_type >::const_iterator AnnotationView_const_iterator;
      typedef ::xsd::cxx::tree::traits< AnnotationView_type, wchar_t > AnnotationView_traits;

      const AnnotationView_sequence&
      AnnotationView () const;

      AnnotationView_sequence&
      AnnotationView ();

      void
      AnnotationView (const AnnotationView_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AnnotationViewSetType ();

      AnnotationViewSetType (const n_type&);

      AnnotationViewSetType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      AnnotationViewSetType (const AnnotationViewSetType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual AnnotationViewSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AnnotationViewSetType&
      operator= (const AnnotationViewSetType& x);

      virtual 
      ~AnnotationViewSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AnnotationView_sequence AnnotationView_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DisplayStyleSetType: public ::xml_schema::type
    {
      public:
      // DisplayStyle
      //
      typedef ::xsd::qif30::DisplayStyleType DisplayStyle_type;
      typedef ::xsd::cxx::tree::sequence< DisplayStyle_type > DisplayStyle_sequence;
      typedef xsd::cxx::tree::sequence< DisplayStyle_type >::iterator DisplayStyle_iterator;
      typedef xsd::cxx::tree::sequence< DisplayStyle_type >::const_iterator DisplayStyle_const_iterator;
      typedef ::xsd::cxx::tree::traits< DisplayStyle_type, wchar_t > DisplayStyle_traits;

      const DisplayStyle_sequence&
      DisplayStyle () const;

      DisplayStyle_sequence&
      DisplayStyle ();

      void
      DisplayStyle (const DisplayStyle_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DisplayStyleSetType ();

      DisplayStyleSetType (const n_type&);

      DisplayStyleSetType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      DisplayStyleSetType (const DisplayStyleSetType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual DisplayStyleSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DisplayStyleSetType&
      operator= (const DisplayStyleSetType& x);

      virtual 
      ~DisplayStyleSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DisplayStyle_sequence DisplayStyle_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ExplodedViewSetType: public ::xml_schema::type
    {
      public:
      // ExplodedView
      //
      typedef ::xsd::qif30::ExplodedViewType ExplodedView_type;
      typedef ::xsd::cxx::tree::sequence< ExplodedView_type > ExplodedView_sequence;
      typedef xsd::cxx::tree::sequence< ExplodedView_type >::iterator ExplodedView_iterator;
      typedef xsd::cxx::tree::sequence< ExplodedView_type >::const_iterator ExplodedView_const_iterator;
      typedef ::xsd::cxx::tree::traits< ExplodedView_type, wchar_t > ExplodedView_traits;

      const ExplodedView_sequence&
      ExplodedView () const;

      ExplodedView_sequence&
      ExplodedView ();

      void
      ExplodedView (const ExplodedView_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ExplodedViewSetType ();

      ExplodedViewSetType (const n_type&);

      ExplodedViewSetType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ExplodedViewSetType (const ExplodedViewSetType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ExplodedViewSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExplodedViewSetType&
      operator= (const ExplodedViewSetType& x);

      virtual 
      ~ExplodedViewSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ExplodedView_sequence ExplodedView_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SimplifiedRepresentationSetType: public ::xml_schema::type
    {
      public:
      // SimplifiedRepresentation
      //
      typedef ::xsd::qif30::SimplifiedRepresentationType SimplifiedRepresentation_type;
      typedef ::xsd::cxx::tree::sequence< SimplifiedRepresentation_type > SimplifiedRepresentation_sequence;
      typedef xsd::cxx::tree::sequence< SimplifiedRepresentation_type >::iterator SimplifiedRepresentation_iterator;
      typedef xsd::cxx::tree::sequence< SimplifiedRepresentation_type >::const_iterator SimplifiedRepresentation_const_iterator;
      typedef ::xsd::cxx::tree::traits< SimplifiedRepresentation_type, wchar_t > SimplifiedRepresentation_traits;

      const SimplifiedRepresentation_sequence&
      SimplifiedRepresentation () const;

      SimplifiedRepresentation_sequence&
      SimplifiedRepresentation ();

      void
      SimplifiedRepresentation (const SimplifiedRepresentation_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SimplifiedRepresentationSetType ();

      SimplifiedRepresentationSetType (const n_type&);

      SimplifiedRepresentationSetType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SimplifiedRepresentationSetType (const SimplifiedRepresentationSetType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SimplifiedRepresentationSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimplifiedRepresentationSetType&
      operator= (const SimplifiedRepresentationSetType& x);

      virtual 
      ~SimplifiedRepresentationSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SimplifiedRepresentation_sequence SimplifiedRepresentation_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ZoneSectionSetType: public ::xml_schema::type
    {
      public:
      // ZoneSection
      //
      typedef ::xsd::qif30::ZoneSectionType ZoneSection_type;
      typedef ::xsd::cxx::tree::sequence< ZoneSection_type > ZoneSection_sequence;
      typedef xsd::cxx::tree::sequence< ZoneSection_type >::iterator ZoneSection_iterator;
      typedef xsd::cxx::tree::sequence< ZoneSection_type >::const_iterator ZoneSection_const_iterator;
      typedef ::xsd::cxx::tree::traits< ZoneSection_type, wchar_t > ZoneSection_traits;

      const ZoneSection_sequence&
      ZoneSection () const;

      ZoneSection_sequence&
      ZoneSection ();

      void
      ZoneSection (const ZoneSection_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ZoneSectionSetType ();

      ZoneSectionSetType (const n_type&);

      ZoneSectionSetType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ZoneSectionSetType (const ZoneSectionSetType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ZoneSectionSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ZoneSectionSetType&
      operator= (const ZoneSectionSetType& x);

      virtual 
      ~ZoneSectionSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ZoneSection_sequence ZoneSection_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL HatchStyleSetType: public ::xml_schema::type
    {
      public:
      // HatchStyle
      //
      typedef ::xsd::qif30::HatchStyleType HatchStyle_type;
      typedef ::xsd::cxx::tree::sequence< HatchStyle_type > HatchStyle_sequence;
      typedef xsd::cxx::tree::sequence< HatchStyle_type >::iterator HatchStyle_iterator;
      typedef xsd::cxx::tree::sequence< HatchStyle_type >::const_iterator HatchStyle_const_iterator;
      typedef ::xsd::cxx::tree::traits< HatchStyle_type, wchar_t > HatchStyle_traits;

      const HatchStyle_sequence&
      HatchStyle () const;

      HatchStyle_sequence&
      HatchStyle ();

      void
      HatchStyle (const HatchStyle_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      HatchStyleSetType ();

      HatchStyleSetType (const n_type&);

      HatchStyleSetType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      HatchStyleSetType (const HatchStyleSetType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual HatchStyleSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      HatchStyleSetType&
      operator= (const HatchStyleSetType& x);

      virtual 
      ~HatchStyleSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      HatchStyle_sequence HatchStyle_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL TrailingZeroDisplayType: public ::xml_schema::type
    {
      public:
      // DimensionalCharacteristicValueTarget
      //
      typedef ::xml_schema::boolean DimensionalCharacteristicValueTarget_type;
      typedef ::xsd::cxx::tree::optional< DimensionalCharacteristicValueTarget_type > DimensionalCharacteristicValueTarget_optional;
      typedef ::xsd::cxx::tree::traits< DimensionalCharacteristicValueTarget_type, wchar_t > DimensionalCharacteristicValueTarget_traits;

      const DimensionalCharacteristicValueTarget_optional&
      DimensionalCharacteristicValueTarget () const;

      DimensionalCharacteristicValueTarget_optional&
      DimensionalCharacteristicValueTarget ();

      void
      DimensionalCharacteristicValueTarget (const DimensionalCharacteristicValueTarget_type& x);

      void
      DimensionalCharacteristicValueTarget (const DimensionalCharacteristicValueTarget_optional& x);

      // DimensionalCharacteristicValueLimits
      //
      typedef ::xml_schema::boolean DimensionalCharacteristicValueLimits_type;
      typedef ::xsd::cxx::tree::optional< DimensionalCharacteristicValueLimits_type > DimensionalCharacteristicValueLimits_optional;
      typedef ::xsd::cxx::tree::traits< DimensionalCharacteristicValueLimits_type, wchar_t > DimensionalCharacteristicValueLimits_traits;

      const DimensionalCharacteristicValueLimits_optional&
      DimensionalCharacteristicValueLimits () const;

      DimensionalCharacteristicValueLimits_optional&
      DimensionalCharacteristicValueLimits ();

      void
      DimensionalCharacteristicValueLimits (const DimensionalCharacteristicValueLimits_type& x);

      void
      DimensionalCharacteristicValueLimits (const DimensionalCharacteristicValueLimits_optional& x);

      // GeometricCharacteristicValue
      //
      typedef ::xml_schema::boolean GeometricCharacteristicValue_type;
      typedef ::xsd::cxx::tree::optional< GeometricCharacteristicValue_type > GeometricCharacteristicValue_optional;
      typedef ::xsd::cxx::tree::traits< GeometricCharacteristicValue_type, wchar_t > GeometricCharacteristicValue_traits;

      const GeometricCharacteristicValue_optional&
      GeometricCharacteristicValue () const;

      GeometricCharacteristicValue_optional&
      GeometricCharacteristicValue ();

      void
      GeometricCharacteristicValue (const GeometricCharacteristicValue_type& x);

      void
      GeometricCharacteristicValue (const GeometricCharacteristicValue_optional& x);

      // TrailingZeroDimensionalCharacteristicDisplayGroups
      //
      typedef ::xsd::qif30::TrailingZeroDimensionalCharacteristicDisplayGroupsType TrailingZeroDimensionalCharacteristicDisplayGroups_type;
      typedef ::xsd::cxx::tree::optional< TrailingZeroDimensionalCharacteristicDisplayGroups_type > TrailingZeroDimensionalCharacteristicDisplayGroups_optional;
      typedef ::xsd::cxx::tree::traits< TrailingZeroDimensionalCharacteristicDisplayGroups_type, wchar_t > TrailingZeroDimensionalCharacteristicDisplayGroups_traits;

      const TrailingZeroDimensionalCharacteristicDisplayGroups_optional&
      TrailingZeroDimensionalCharacteristicDisplayGroups () const;

      TrailingZeroDimensionalCharacteristicDisplayGroups_optional&
      TrailingZeroDimensionalCharacteristicDisplayGroups ();

      void
      TrailingZeroDimensionalCharacteristicDisplayGroups (const TrailingZeroDimensionalCharacteristicDisplayGroups_type& x);

      void
      TrailingZeroDimensionalCharacteristicDisplayGroups (const TrailingZeroDimensionalCharacteristicDisplayGroups_optional& x);

      void
      TrailingZeroDimensionalCharacteristicDisplayGroups (::std::unique_ptr< TrailingZeroDimensionalCharacteristicDisplayGroups_type > p);

      // TrailingZeroGeometricCharacteristicDisplayGroups
      //
      typedef ::xsd::qif30::TrailingZeroGeometricCharacteristicDisplayGroupsType TrailingZeroGeometricCharacteristicDisplayGroups_type;
      typedef ::xsd::cxx::tree::optional< TrailingZeroGeometricCharacteristicDisplayGroups_type > TrailingZeroGeometricCharacteristicDisplayGroups_optional;
      typedef ::xsd::cxx::tree::traits< TrailingZeroGeometricCharacteristicDisplayGroups_type, wchar_t > TrailingZeroGeometricCharacteristicDisplayGroups_traits;

      const TrailingZeroGeometricCharacteristicDisplayGroups_optional&
      TrailingZeroGeometricCharacteristicDisplayGroups () const;

      TrailingZeroGeometricCharacteristicDisplayGroups_optional&
      TrailingZeroGeometricCharacteristicDisplayGroups ();

      void
      TrailingZeroGeometricCharacteristicDisplayGroups (const TrailingZeroGeometricCharacteristicDisplayGroups_type& x);

      void
      TrailingZeroGeometricCharacteristicDisplayGroups (const TrailingZeroGeometricCharacteristicDisplayGroups_optional& x);

      void
      TrailingZeroGeometricCharacteristicDisplayGroups (::std::unique_ptr< TrailingZeroGeometricCharacteristicDisplayGroups_type > p);

      // Constructors.
      //
      TrailingZeroDisplayType ();

      TrailingZeroDisplayType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      TrailingZeroDisplayType (const TrailingZeroDisplayType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual TrailingZeroDisplayType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TrailingZeroDisplayType&
      operator= (const TrailingZeroDisplayType& x);

      virtual 
      ~TrailingZeroDisplayType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DimensionalCharacteristicValueTarget_optional DimensionalCharacteristicValueTarget_;
      DimensionalCharacteristicValueLimits_optional DimensionalCharacteristicValueLimits_;
      GeometricCharacteristicValue_optional GeometricCharacteristicValue_;
      TrailingZeroDimensionalCharacteristicDisplayGroups_optional TrailingZeroDimensionalCharacteristicDisplayGroups_;
      TrailingZeroGeometricCharacteristicDisplayGroups_optional TrailingZeroGeometricCharacteristicDisplayGroups_;
    };

    class QIF30_SYMBOL_DECL TrailingZeroDimensionalCharacteristicDisplayGroupsType: public ::xml_schema::type
    {
      public:
      // TrailingZeroDimensionalCharacteristicDisplayGroup
      //
      typedef ::xsd::qif30::TrailingZeroDimensionalCharacteristicDisplayGroupType TrailingZeroDimensionalCharacteristicDisplayGroup_type;
      typedef ::xsd::cxx::tree::sequence< TrailingZeroDimensionalCharacteristicDisplayGroup_type > TrailingZeroDimensionalCharacteristicDisplayGroup_sequence;
      typedef xsd::cxx::tree::sequence< TrailingZeroDimensionalCharacteristicDisplayGroup_type >::iterator TrailingZeroDimensionalCharacteristicDisplayGroup_iterator;
      typedef xsd::cxx::tree::sequence< TrailingZeroDimensionalCharacteristicDisplayGroup_type >::const_iterator TrailingZeroDimensionalCharacteristicDisplayGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< TrailingZeroDimensionalCharacteristicDisplayGroup_type, wchar_t > TrailingZeroDimensionalCharacteristicDisplayGroup_traits;

      const TrailingZeroDimensionalCharacteristicDisplayGroup_sequence&
      TrailingZeroDimensionalCharacteristicDisplayGroup () const;

      TrailingZeroDimensionalCharacteristicDisplayGroup_sequence&
      TrailingZeroDimensionalCharacteristicDisplayGroup ();

      void
      TrailingZeroDimensionalCharacteristicDisplayGroup (const TrailingZeroDimensionalCharacteristicDisplayGroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      TrailingZeroDimensionalCharacteristicDisplayGroupsType ();

      TrailingZeroDimensionalCharacteristicDisplayGroupsType (const n_type&);

      TrailingZeroDimensionalCharacteristicDisplayGroupsType (const xercesc::DOMElement& e,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

      TrailingZeroDimensionalCharacteristicDisplayGroupsType (const TrailingZeroDimensionalCharacteristicDisplayGroupsType& x,
                                                              ::xml_schema::flags f = 0,
                                                              ::xml_schema::container* c = 0);

      virtual TrailingZeroDimensionalCharacteristicDisplayGroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TrailingZeroDimensionalCharacteristicDisplayGroupsType&
      operator= (const TrailingZeroDimensionalCharacteristicDisplayGroupsType& x);

      virtual 
      ~TrailingZeroDimensionalCharacteristicDisplayGroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TrailingZeroDimensionalCharacteristicDisplayGroup_sequence TrailingZeroDimensionalCharacteristicDisplayGroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL TrailingZeroDimensionalCharacteristicDisplayGroupType: public ::xml_schema::type
    {
      public:
      // DimensionalCharacteristicValueTarget
      //
      typedef ::xml_schema::boolean DimensionalCharacteristicValueTarget_type;
      typedef ::xsd::cxx::tree::optional< DimensionalCharacteristicValueTarget_type > DimensionalCharacteristicValueTarget_optional;
      typedef ::xsd::cxx::tree::traits< DimensionalCharacteristicValueTarget_type, wchar_t > DimensionalCharacteristicValueTarget_traits;

      const DimensionalCharacteristicValueTarget_optional&
      DimensionalCharacteristicValueTarget () const;

      DimensionalCharacteristicValueTarget_optional&
      DimensionalCharacteristicValueTarget ();

      void
      DimensionalCharacteristicValueTarget (const DimensionalCharacteristicValueTarget_type& x);

      void
      DimensionalCharacteristicValueTarget (const DimensionalCharacteristicValueTarget_optional& x);

      // DimensionalCharacteristicValueLimits
      //
      typedef ::xml_schema::boolean DimensionalCharacteristicValueLimits_type;
      typedef ::xsd::cxx::tree::optional< DimensionalCharacteristicValueLimits_type > DimensionalCharacteristicValueLimits_optional;
      typedef ::xsd::cxx::tree::traits< DimensionalCharacteristicValueLimits_type, wchar_t > DimensionalCharacteristicValueLimits_traits;

      const DimensionalCharacteristicValueLimits_optional&
      DimensionalCharacteristicValueLimits () const;

      DimensionalCharacteristicValueLimits_optional&
      DimensionalCharacteristicValueLimits ();

      void
      DimensionalCharacteristicValueLimits (const DimensionalCharacteristicValueLimits_type& x);

      void
      DimensionalCharacteristicValueLimits (const DimensionalCharacteristicValueLimits_optional& x);

      // DimensionalCharacteristicIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType DimensionalCharacteristicIds_type;
      typedef ::xsd::cxx::tree::traits< DimensionalCharacteristicIds_type, wchar_t > DimensionalCharacteristicIds_traits;

      const DimensionalCharacteristicIds_type&
      DimensionalCharacteristicIds () const;

      DimensionalCharacteristicIds_type&
      DimensionalCharacteristicIds ();

      void
      DimensionalCharacteristicIds (const DimensionalCharacteristicIds_type& x);

      void
      DimensionalCharacteristicIds (::std::unique_ptr< DimensionalCharacteristicIds_type > p);

      // Constructors.
      //
      TrailingZeroDimensionalCharacteristicDisplayGroupType ();

      TrailingZeroDimensionalCharacteristicDisplayGroupType (const DimensionalCharacteristicIds_type&);

      TrailingZeroDimensionalCharacteristicDisplayGroupType (::std::unique_ptr< DimensionalCharacteristicIds_type >);

      TrailingZeroDimensionalCharacteristicDisplayGroupType (const xercesc::DOMElement& e,
                                                             ::xml_schema::flags f = 0,
                                                             ::xml_schema::container* c = 0);

      TrailingZeroDimensionalCharacteristicDisplayGroupType (const TrailingZeroDimensionalCharacteristicDisplayGroupType& x,
                                                             ::xml_schema::flags f = 0,
                                                             ::xml_schema::container* c = 0);

      virtual TrailingZeroDimensionalCharacteristicDisplayGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TrailingZeroDimensionalCharacteristicDisplayGroupType&
      operator= (const TrailingZeroDimensionalCharacteristicDisplayGroupType& x);

      virtual 
      ~TrailingZeroDimensionalCharacteristicDisplayGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DimensionalCharacteristicValueTarget_optional DimensionalCharacteristicValueTarget_;
      DimensionalCharacteristicValueLimits_optional DimensionalCharacteristicValueLimits_;
      ::xsd::cxx::tree::one< DimensionalCharacteristicIds_type > DimensionalCharacteristicIds_;
    };

    class QIF30_SYMBOL_DECL TrailingZeroGeometricCharacteristicDisplayGroupsType: public ::xml_schema::type
    {
      public:
      // TrailingZeroGeometricCharacteristicDisplayGroup
      //
      typedef ::xsd::qif30::TrailingZeroGeometricCharacteristicDisplayGroupType TrailingZeroGeometricCharacteristicDisplayGroup_type;
      typedef ::xsd::cxx::tree::sequence< TrailingZeroGeometricCharacteristicDisplayGroup_type > TrailingZeroGeometricCharacteristicDisplayGroup_sequence;
      typedef xsd::cxx::tree::sequence< TrailingZeroGeometricCharacteristicDisplayGroup_type >::iterator TrailingZeroGeometricCharacteristicDisplayGroup_iterator;
      typedef xsd::cxx::tree::sequence< TrailingZeroGeometricCharacteristicDisplayGroup_type >::const_iterator TrailingZeroGeometricCharacteristicDisplayGroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< TrailingZeroGeometricCharacteristicDisplayGroup_type, wchar_t > TrailingZeroGeometricCharacteristicDisplayGroup_traits;

      const TrailingZeroGeometricCharacteristicDisplayGroup_sequence&
      TrailingZeroGeometricCharacteristicDisplayGroup () const;

      TrailingZeroGeometricCharacteristicDisplayGroup_sequence&
      TrailingZeroGeometricCharacteristicDisplayGroup ();

      void
      TrailingZeroGeometricCharacteristicDisplayGroup (const TrailingZeroGeometricCharacteristicDisplayGroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      TrailingZeroGeometricCharacteristicDisplayGroupsType ();

      TrailingZeroGeometricCharacteristicDisplayGroupsType (const n_type&);

      TrailingZeroGeometricCharacteristicDisplayGroupsType (const xercesc::DOMElement& e,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

      TrailingZeroGeometricCharacteristicDisplayGroupsType (const TrailingZeroGeometricCharacteristicDisplayGroupsType& x,
                                                            ::xml_schema::flags f = 0,
                                                            ::xml_schema::container* c = 0);

      virtual TrailingZeroGeometricCharacteristicDisplayGroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TrailingZeroGeometricCharacteristicDisplayGroupsType&
      operator= (const TrailingZeroGeometricCharacteristicDisplayGroupsType& x);

      virtual 
      ~TrailingZeroGeometricCharacteristicDisplayGroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TrailingZeroGeometricCharacteristicDisplayGroup_sequence TrailingZeroGeometricCharacteristicDisplayGroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL TrailingZeroGeometricCharacteristicDisplayGroupType: public ::xml_schema::type
    {
      public:
      // GeometricCharacteristicValue
      //
      typedef ::xml_schema::boolean GeometricCharacteristicValue_type;
      typedef ::xsd::cxx::tree::traits< GeometricCharacteristicValue_type, wchar_t > GeometricCharacteristicValue_traits;

      const GeometricCharacteristicValue_type&
      GeometricCharacteristicValue () const;

      GeometricCharacteristicValue_type&
      GeometricCharacteristicValue ();

      void
      GeometricCharacteristicValue (const GeometricCharacteristicValue_type& x);

      // GeometricCharacteristicIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType GeometricCharacteristicIds_type;
      typedef ::xsd::cxx::tree::traits< GeometricCharacteristicIds_type, wchar_t > GeometricCharacteristicIds_traits;

      const GeometricCharacteristicIds_type&
      GeometricCharacteristicIds () const;

      GeometricCharacteristicIds_type&
      GeometricCharacteristicIds ();

      void
      GeometricCharacteristicIds (const GeometricCharacteristicIds_type& x);

      void
      GeometricCharacteristicIds (::std::unique_ptr< GeometricCharacteristicIds_type > p);

      // Constructors.
      //
      TrailingZeroGeometricCharacteristicDisplayGroupType ();

      TrailingZeroGeometricCharacteristicDisplayGroupType (const GeometricCharacteristicValue_type&,
                                                           const GeometricCharacteristicIds_type&);

      TrailingZeroGeometricCharacteristicDisplayGroupType (const GeometricCharacteristicValue_type&,
                                                           ::std::unique_ptr< GeometricCharacteristicIds_type >);

      TrailingZeroGeometricCharacteristicDisplayGroupType (const xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

      TrailingZeroGeometricCharacteristicDisplayGroupType (const TrailingZeroGeometricCharacteristicDisplayGroupType& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

      virtual TrailingZeroGeometricCharacteristicDisplayGroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TrailingZeroGeometricCharacteristicDisplayGroupType&
      operator= (const TrailingZeroGeometricCharacteristicDisplayGroupType& x);

      virtual 
      ~TrailingZeroGeometricCharacteristicDisplayGroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< GeometricCharacteristicValue_type > GeometricCharacteristicValue_;
      ::xsd::cxx::tree::one< GeometricCharacteristicIds_type > GeometricCharacteristicIds_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VisualizationSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FontsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AlignmentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const AlignmentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const AlignmentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FontType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PMIDisplaySetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PMIDisplayType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlanePMIDisplayType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Polylines2dType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Polyline2dType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Areas2dType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Area2dType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Loops2dType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Triangulation2dType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GraphicsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderExtendType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderDoubleHeadType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderDoubleHeadExtendType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderCircularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderDoubleHeadCircularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TextsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FramesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TextType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WitnessLinesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const FrameBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const FrameBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameRectangularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameCircularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameFlagType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameIrregularFormType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameWeldSymbolTailType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldMainSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const WeldMainSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const WeldMainSymbolEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OriginType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldMainSymbolType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSupplementarySymbolType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldContourSymbolType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameWeldSymbolType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameTriangleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FramePentagonalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameOctagonalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FrameHexagonalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderHeadFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LeaderHeadFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LeaderHeadFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderHeadFormType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LeaderModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LeaderModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LeaderModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ViewSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CameraType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CameraFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CameraFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CameraFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SavedViewType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ZoneSectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LogicalOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LogicalOperationsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LogicalOperationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LogicalOperationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LogicalOperationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ZoneSectionPlanesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ZoneSectionPlaneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionGroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionPathsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionLoopsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionAreasType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionEdgesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionPathType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HatchPatternsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HatchStyleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HatchStyleFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const HatchStyleFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const HatchStyleFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HatchPatternType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DisplayStyleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DisplayStyleGroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DisplayStyleModeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DisplayStyleGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DisplayStyleFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DisplayStyleFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DisplayStyleFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExplodedViewType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExplodedViewMoveGroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExplodedViewMoveGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExplodedViewTranslateType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExplodedViewRotateType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimplifiedRepresentationFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SimplifiedRepresentationFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SimplifiedRepresentationFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimplifiedRepresentationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimplifiedRepresentationGroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimplifiedRepresentationGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AnnotationViewType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CameraSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SavedViewSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AnnotationViewSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DisplayStyleSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExplodedViewSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SimplifiedRepresentationSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ZoneSectionSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HatchStyleSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TrailingZeroDisplayType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TrailingZeroDimensionalCharacteristicDisplayGroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TrailingZeroDimensionalCharacteristicDisplayGroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TrailingZeroGeometricCharacteristicDisplayGroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TrailingZeroGeometricCharacteristicDisplayGroupType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_VISUALIZATION_HXX
