// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "PrimitivesPMI.hxx"

namespace xsd
{
  namespace qif30
  {
    // RectangularUnitAreaType
    //

    const RectangularUnitAreaType::RectangularUnitAreaLength_type& RectangularUnitAreaType::
    RectangularUnitAreaLength () const
    {
      return this->RectangularUnitAreaLength_.get ();
    }

    RectangularUnitAreaType::RectangularUnitAreaLength_type& RectangularUnitAreaType::
    RectangularUnitAreaLength ()
    {
      return this->RectangularUnitAreaLength_.get ();
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaLength (const RectangularUnitAreaLength_type& x)
    {
      this->RectangularUnitAreaLength_.set (x);
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaLength (::std::unique_ptr< RectangularUnitAreaLength_type > x)
    {
      this->RectangularUnitAreaLength_.set (std::move (x));
    }

    const RectangularUnitAreaType::RectangularUnitAreaWidth_type& RectangularUnitAreaType::
    RectangularUnitAreaWidth () const
    {
      return this->RectangularUnitAreaWidth_.get ();
    }

    RectangularUnitAreaType::RectangularUnitAreaWidth_type& RectangularUnitAreaType::
    RectangularUnitAreaWidth ()
    {
      return this->RectangularUnitAreaWidth_.get ();
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaWidth (const RectangularUnitAreaWidth_type& x)
    {
      this->RectangularUnitAreaWidth_.set (x);
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaWidth (::std::unique_ptr< RectangularUnitAreaWidth_type > x)
    {
      this->RectangularUnitAreaWidth_.set (std::move (x));
    }

    const RectangularUnitAreaType::RectangularUnitAreaOrientation_optional& RectangularUnitAreaType::
    RectangularUnitAreaOrientation () const
    {
      return this->RectangularUnitAreaOrientation_;
    }

    RectangularUnitAreaType::RectangularUnitAreaOrientation_optional& RectangularUnitAreaType::
    RectangularUnitAreaOrientation ()
    {
      return this->RectangularUnitAreaOrientation_;
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaOrientation (const RectangularUnitAreaOrientation_type& x)
    {
      this->RectangularUnitAreaOrientation_.set (x);
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaOrientation (const RectangularUnitAreaOrientation_optional& x)
    {
      this->RectangularUnitAreaOrientation_ = x;
    }

    void RectangularUnitAreaType::
    RectangularUnitAreaOrientation (::std::unique_ptr< RectangularUnitAreaOrientation_type > x)
    {
      this->RectangularUnitAreaOrientation_.set (std::move (x));
    }


    // CircularUnitAreaType
    //

    const CircularUnitAreaType::CircularUnitAreaDiameter_type& CircularUnitAreaType::
    CircularUnitAreaDiameter () const
    {
      return this->CircularUnitAreaDiameter_.get ();
    }

    CircularUnitAreaType::CircularUnitAreaDiameter_type& CircularUnitAreaType::
    CircularUnitAreaDiameter ()
    {
      return this->CircularUnitAreaDiameter_.get ();
    }

    void CircularUnitAreaType::
    CircularUnitAreaDiameter (const CircularUnitAreaDiameter_type& x)
    {
      this->CircularUnitAreaDiameter_.set (x);
    }

    void CircularUnitAreaType::
    CircularUnitAreaDiameter (::std::unique_ptr< CircularUnitAreaDiameter_type > x)
    {
      this->CircularUnitAreaDiameter_.set (std::move (x));
    }


    // MeasuredPointType
    //

    const MeasuredPointType::combinedUncertainty_optional& MeasuredPointType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    MeasuredPointType::combinedUncertainty_optional& MeasuredPointType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void MeasuredPointType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void MeasuredPointType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const MeasuredPointType::meanError_optional& MeasuredPointType::
    meanError () const
    {
      return this->meanError_;
    }

    MeasuredPointType::meanError_optional& MeasuredPointType::
    meanError ()
    {
      return this->meanError_;
    }

    void MeasuredPointType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void MeasuredPointType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const MeasuredPointType::xCombinedUncertainty_optional& MeasuredPointType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    MeasuredPointType::xCombinedUncertainty_optional& MeasuredPointType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void MeasuredPointType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void MeasuredPointType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const MeasuredPointType::xMeanError_optional& MeasuredPointType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    MeasuredPointType::xMeanError_optional& MeasuredPointType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void MeasuredPointType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void MeasuredPointType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const MeasuredPointType::yCombinedUncertainty_optional& MeasuredPointType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    MeasuredPointType::yCombinedUncertainty_optional& MeasuredPointType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void MeasuredPointType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void MeasuredPointType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const MeasuredPointType::yMeanError_optional& MeasuredPointType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    MeasuredPointType::yMeanError_optional& MeasuredPointType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void MeasuredPointType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void MeasuredPointType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const MeasuredPointType::zCombinedUncertainty_optional& MeasuredPointType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    MeasuredPointType::zCombinedUncertainty_optional& MeasuredPointType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void MeasuredPointType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void MeasuredPointType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const MeasuredPointType::zMeanError_optional& MeasuredPointType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    MeasuredPointType::zMeanError_optional& MeasuredPointType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void MeasuredPointType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void MeasuredPointType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }


    // MeasuredUnitVectorType
    //

    const MeasuredUnitVectorType::combinedUncertainty_optional& MeasuredUnitVectorType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    MeasuredUnitVectorType::combinedUncertainty_optional& MeasuredUnitVectorType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void MeasuredUnitVectorType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void MeasuredUnitVectorType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const MeasuredUnitVectorType::meanError_optional& MeasuredUnitVectorType::
    meanError () const
    {
      return this->meanError_;
    }

    MeasuredUnitVectorType::meanError_optional& MeasuredUnitVectorType::
    meanError ()
    {
      return this->meanError_;
    }

    void MeasuredUnitVectorType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void MeasuredUnitVectorType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const MeasuredUnitVectorType::xCombinedUncertainty_optional& MeasuredUnitVectorType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    MeasuredUnitVectorType::xCombinedUncertainty_optional& MeasuredUnitVectorType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void MeasuredUnitVectorType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void MeasuredUnitVectorType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const MeasuredUnitVectorType::xMeanError_optional& MeasuredUnitVectorType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    MeasuredUnitVectorType::xMeanError_optional& MeasuredUnitVectorType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void MeasuredUnitVectorType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void MeasuredUnitVectorType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const MeasuredUnitVectorType::yCombinedUncertainty_optional& MeasuredUnitVectorType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    MeasuredUnitVectorType::yCombinedUncertainty_optional& MeasuredUnitVectorType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void MeasuredUnitVectorType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void MeasuredUnitVectorType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const MeasuredUnitVectorType::yMeanError_optional& MeasuredUnitVectorType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    MeasuredUnitVectorType::yMeanError_optional& MeasuredUnitVectorType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void MeasuredUnitVectorType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void MeasuredUnitVectorType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const MeasuredUnitVectorType::zCombinedUncertainty_optional& MeasuredUnitVectorType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    MeasuredUnitVectorType::zCombinedUncertainty_optional& MeasuredUnitVectorType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void MeasuredUnitVectorType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void MeasuredUnitVectorType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const MeasuredUnitVectorType::zMeanError_optional& MeasuredUnitVectorType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    MeasuredUnitVectorType::zMeanError_optional& MeasuredUnitVectorType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void MeasuredUnitVectorType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void MeasuredUnitVectorType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }


    // MeasuredPlaneType
    //

    const MeasuredPlaneType::Point_type& MeasuredPlaneType::
    Point () const
    {
      return this->Point_.get ();
    }

    MeasuredPlaneType::Point_type& MeasuredPlaneType::
    Point ()
    {
      return this->Point_.get ();
    }

    void MeasuredPlaneType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void MeasuredPlaneType::
    Point (::std::unique_ptr< Point_type > x)
    {
      this->Point_.set (std::move (x));
    }

    const MeasuredPlaneType::Normal_type& MeasuredPlaneType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    MeasuredPlaneType::Normal_type& MeasuredPlaneType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void MeasuredPlaneType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void MeasuredPlaneType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }


    // MeasuredAxisType
    //

    const MeasuredAxisType::AxisPoint_type& MeasuredAxisType::
    AxisPoint () const
    {
      return this->AxisPoint_.get ();
    }

    MeasuredAxisType::AxisPoint_type& MeasuredAxisType::
    AxisPoint ()
    {
      return this->AxisPoint_.get ();
    }

    void MeasuredAxisType::
    AxisPoint (const AxisPoint_type& x)
    {
      this->AxisPoint_.set (x);
    }

    void MeasuredAxisType::
    AxisPoint (::std::unique_ptr< AxisPoint_type > x)
    {
      this->AxisPoint_.set (std::move (x));
    }

    const MeasuredAxisType::Direction_type& MeasuredAxisType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    MeasuredAxisType::Direction_type& MeasuredAxisType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void MeasuredAxisType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void MeasuredAxisType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }


    // MeasuredZoneAxisType
    //

    const MeasuredZoneAxisType::Length_type& MeasuredZoneAxisType::
    Length () const
    {
      return this->Length_.get ();
    }

    MeasuredZoneAxisType::Length_type& MeasuredZoneAxisType::
    Length ()
    {
      return this->Length_.get ();
    }

    void MeasuredZoneAxisType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void MeasuredZoneAxisType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }


    // BottomEnumType
    //

    BottomEnumType::
    BottomEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    BottomEnumType::
    BottomEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_BottomEnumType_literals_[v])
    {
    }

    BottomEnumType::
    BottomEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BottomEnumType::
    BottomEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BottomEnumType::
    BottomEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BottomEnumType::
    BottomEnumType (const BottomEnumType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    BottomEnumType& BottomEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_BottomEnumType_literals_[v]);

      return *this;
    }


    // BottomType
    //

    const BottomType::BottomEnum_optional& BottomType::
    BottomEnum () const
    {
      return this->BottomEnum_;
    }

    BottomType::BottomEnum_optional& BottomType::
    BottomEnum ()
    {
      return this->BottomEnum_;
    }

    void BottomType::
    BottomEnum (const BottomEnum_type& x)
    {
      this->BottomEnum_.set (x);
    }

    void BottomType::
    BottomEnum (const BottomEnum_optional& x)
    {
      this->BottomEnum_ = x;
    }

    void BottomType::
    BottomEnum (::std::unique_ptr< BottomEnum_type > x)
    {
      this->BottomEnum_.set (std::move (x));
    }

    const BottomType::OtherBottom_optional& BottomType::
    OtherBottom () const
    {
      return this->OtherBottom_;
    }

    BottomType::OtherBottom_optional& BottomType::
    OtherBottom ()
    {
      return this->OtherBottom_;
    }

    void BottomType::
    OtherBottom (const OtherBottom_type& x)
    {
      this->OtherBottom_.set (x);
    }

    void BottomType::
    OtherBottom (const OtherBottom_optional& x)
    {
      this->OtherBottom_ = x;
    }

    void BottomType::
    OtherBottom (::std::unique_ptr< OtherBottom_type > x)
    {
      this->OtherBottom_.set (std::move (x));
    }


    // BoundingBoxType
    //

    const BoundingBoxType::Length_type& BoundingBoxType::
    Length () const
    {
      return this->Length_.get ();
    }

    BoundingBoxType::Length_type& BoundingBoxType::
    Length ()
    {
      return this->Length_.get ();
    }

    void BoundingBoxType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void BoundingBoxType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const BoundingBoxType::Width_type& BoundingBoxType::
    Width () const
    {
      return this->Width_.get ();
    }

    BoundingBoxType::Width_type& BoundingBoxType::
    Width ()
    {
      return this->Width_.get ();
    }

    void BoundingBoxType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void BoundingBoxType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const BoundingBoxType::Height_type& BoundingBoxType::
    Height () const
    {
      return this->Height_.get ();
    }

    BoundingBoxType::Height_type& BoundingBoxType::
    Height ()
    {
      return this->Height_.get ();
    }

    void BoundingBoxType::
    Height (const Height_type& x)
    {
      this->Height_.set (x);
    }

    void BoundingBoxType::
    Height (::std::unique_ptr< Height_type > x)
    {
      this->Height_.set (std::move (x));
    }


    // ShapeClassEnumType
    //

    ShapeClassEnumType::
    ShapeClassEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ShapeClassEnumType_literals_[v])
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ShapeClassEnumType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ShapeClassEnumType& ShapeClassEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ShapeClassEnumType_literals_[v]);

      return *this;
    }


    // ShapeClassType
    //

    const ShapeClassType::ShapeClassEnum_optional& ShapeClassType::
    ShapeClassEnum () const
    {
      return this->ShapeClassEnum_;
    }

    ShapeClassType::ShapeClassEnum_optional& ShapeClassType::
    ShapeClassEnum ()
    {
      return this->ShapeClassEnum_;
    }

    void ShapeClassType::
    ShapeClassEnum (const ShapeClassEnum_type& x)
    {
      this->ShapeClassEnum_.set (x);
    }

    void ShapeClassType::
    ShapeClassEnum (const ShapeClassEnum_optional& x)
    {
      this->ShapeClassEnum_ = x;
    }

    void ShapeClassType::
    ShapeClassEnum (::std::unique_ptr< ShapeClassEnum_type > x)
    {
      this->ShapeClassEnum_.set (std::move (x));
    }

    const ShapeClassType::OtherShapeClass_optional& ShapeClassType::
    OtherShapeClass () const
    {
      return this->OtherShapeClass_;
    }

    ShapeClassType::OtherShapeClass_optional& ShapeClassType::
    OtherShapeClass ()
    {
      return this->OtherShapeClass_;
    }

    void ShapeClassType::
    OtherShapeClass (const OtherShapeClass_type& x)
    {
      this->OtherShapeClass_.set (x);
    }

    void ShapeClassType::
    OtherShapeClass (const OtherShapeClass_optional& x)
    {
      this->OtherShapeClass_ = x;
    }

    void ShapeClassType::
    OtherShapeClass (::std::unique_ptr< OtherShapeClass_type > x)
    {
      this->OtherShapeClass_.set (std::move (x));
    }


    // ManufacturingMethodEnumType
    //

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ManufacturingMethodEnumType_literals_[v])
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ManufacturingMethodEnumType& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ManufacturingMethodEnumType& ManufacturingMethodEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ManufacturingMethodEnumType_literals_[v]);

      return *this;
    }


    // ManufacturingMethodType
    //

    const ManufacturingMethodType::ManufacturingMethodEnum_optional& ManufacturingMethodType::
    ManufacturingMethodEnum () const
    {
      return this->ManufacturingMethodEnum_;
    }

    ManufacturingMethodType::ManufacturingMethodEnum_optional& ManufacturingMethodType::
    ManufacturingMethodEnum ()
    {
      return this->ManufacturingMethodEnum_;
    }

    void ManufacturingMethodType::
    ManufacturingMethodEnum (const ManufacturingMethodEnum_type& x)
    {
      this->ManufacturingMethodEnum_.set (x);
    }

    void ManufacturingMethodType::
    ManufacturingMethodEnum (const ManufacturingMethodEnum_optional& x)
    {
      this->ManufacturingMethodEnum_ = x;
    }

    void ManufacturingMethodType::
    ManufacturingMethodEnum (::std::unique_ptr< ManufacturingMethodEnum_type > x)
    {
      this->ManufacturingMethodEnum_.set (std::move (x));
    }

    const ManufacturingMethodType::OtherManufacturingMethod_optional& ManufacturingMethodType::
    OtherManufacturingMethod () const
    {
      return this->OtherManufacturingMethod_;
    }

    ManufacturingMethodType::OtherManufacturingMethod_optional& ManufacturingMethodType::
    OtherManufacturingMethod ()
    {
      return this->OtherManufacturingMethod_;
    }

    void ManufacturingMethodType::
    OtherManufacturingMethod (const OtherManufacturingMethod_type& x)
    {
      this->OtherManufacturingMethod_.set (x);
    }

    void ManufacturingMethodType::
    OtherManufacturingMethod (const OtherManufacturingMethod_optional& x)
    {
      this->OtherManufacturingMethod_ = x;
    }

    void ManufacturingMethodType::
    OtherManufacturingMethod (::std::unique_ptr< OtherManufacturingMethod_type > x)
    {
      this->OtherManufacturingMethod_.set (std::move (x));
    }


    // InternalExternalEnumType
    //

    InternalExternalEnumType::
    InternalExternalEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_InternalExternalEnumType_literals_[v])
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const InternalExternalEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    InternalExternalEnumType& InternalExternalEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_InternalExternalEnumType_literals_[v]);

      return *this;
    }


    // DimensionCountEnumType
    //

    DimensionCountEnumType::
    DimensionCountEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DimensionCountEnumType_literals_[v])
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const DimensionCountEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DimensionCountEnumType& DimensionCountEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DimensionCountEnumType_literals_[v]);

      return *this;
    }


    // ZoneOrientationEnumType
    //

    ZoneOrientationEnumType::
    ZoneOrientationEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ZoneOrientationEnumType::
    ZoneOrientationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ZoneOrientationEnumType_literals_[v])
    {
    }

    ZoneOrientationEnumType::
    ZoneOrientationEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ZoneOrientationEnumType::
    ZoneOrientationEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ZoneOrientationEnumType::
    ZoneOrientationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ZoneOrientationEnumType::
    ZoneOrientationEnumType (const ZoneOrientationEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ZoneOrientationEnumType& ZoneOrientationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ZoneOrientationEnumType_literals_[v]);

      return *this;
    }


    // CoordinateEnumType
    //

    CoordinateEnumType::
    CoordinateEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CoordinateEnumType_literals_[v])
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CoordinateEnumType::
    CoordinateEnumType (const CoordinateEnumType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CoordinateEnumType& CoordinateEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CoordinateEnumType_literals_[v]);

      return *this;
    }


    // TypeOfCoordinatesType
    //

    const TypeOfCoordinatesType::CoordinateEnum_optional& TypeOfCoordinatesType::
    CoordinateEnum () const
    {
      return this->CoordinateEnum_;
    }

    TypeOfCoordinatesType::CoordinateEnum_optional& TypeOfCoordinatesType::
    CoordinateEnum ()
    {
      return this->CoordinateEnum_;
    }

    void TypeOfCoordinatesType::
    CoordinateEnum (const CoordinateEnum_type& x)
    {
      this->CoordinateEnum_.set (x);
    }

    void TypeOfCoordinatesType::
    CoordinateEnum (const CoordinateEnum_optional& x)
    {
      this->CoordinateEnum_ = x;
    }

    void TypeOfCoordinatesType::
    CoordinateEnum (::std::unique_ptr< CoordinateEnum_type > x)
    {
      this->CoordinateEnum_.set (std::move (x));
    }

    const TypeOfCoordinatesType::OtherCoordinate_optional& TypeOfCoordinatesType::
    OtherCoordinate () const
    {
      return this->OtherCoordinate_;
    }

    TypeOfCoordinatesType::OtherCoordinate_optional& TypeOfCoordinatesType::
    OtherCoordinate ()
    {
      return this->OtherCoordinate_;
    }

    void TypeOfCoordinatesType::
    OtherCoordinate (const OtherCoordinate_type& x)
    {
      this->OtherCoordinate_.set (x);
    }

    void TypeOfCoordinatesType::
    OtherCoordinate (const OtherCoordinate_optional& x)
    {
      this->OtherCoordinate_ = x;
    }

    void TypeOfCoordinatesType::
    OtherCoordinate (::std::unique_ptr< OtherCoordinate_type > x)
    {
      this->OtherCoordinate_.set (std::move (x));
    }


    // RectangleType
    //

    const RectangleType::Length_type& RectangleType::
    Length () const
    {
      return this->Length_.get ();
    }

    RectangleType::Length_type& RectangleType::
    Length ()
    {
      return this->Length_.get ();
    }

    void RectangleType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void RectangleType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const RectangleType::CornerPoint_type& RectangleType::
    CornerPoint () const
    {
      return this->CornerPoint_.get ();
    }

    RectangleType::CornerPoint_type& RectangleType::
    CornerPoint ()
    {
      return this->CornerPoint_.get ();
    }

    void RectangleType::
    CornerPoint (const CornerPoint_type& x)
    {
      this->CornerPoint_.set (x);
    }

    void RectangleType::
    CornerPoint (::std::unique_ptr< CornerPoint_type > x)
    {
      this->CornerPoint_.set (std::move (x));
    }

    const RectangleType::Width_type& RectangleType::
    Width () const
    {
      return this->Width_.get ();
    }

    RectangleType::Width_type& RectangleType::
    Width ()
    {
      return this->Width_.get ();
    }

    void RectangleType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void RectangleType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const RectangleType::WidthDirection_type& RectangleType::
    WidthDirection () const
    {
      return this->WidthDirection_.get ();
    }

    RectangleType::WidthDirection_type& RectangleType::
    WidthDirection ()
    {
      return this->WidthDirection_.get ();
    }

    void RectangleType::
    WidthDirection (const WidthDirection_type& x)
    {
      this->WidthDirection_.set (x);
    }

    void RectangleType::
    WidthDirection (::std::unique_ptr< WidthDirection_type > x)
    {
      this->WidthDirection_.set (std::move (x));
    }

    const RectangleType::LengthDirection_type& RectangleType::
    LengthDirection () const
    {
      return this->LengthDirection_.get ();
    }

    RectangleType::LengthDirection_type& RectangleType::
    LengthDirection ()
    {
      return this->LengthDirection_.get ();
    }

    void RectangleType::
    LengthDirection (const LengthDirection_type& x)
    {
      this->LengthDirection_.set (x);
    }

    void RectangleType::
    LengthDirection (::std::unique_ptr< LengthDirection_type > x)
    {
      this->LengthDirection_.set (std::move (x));
    }


    // CircleType
    //

    const CircleType::CenterPoint_type& CircleType::
    CenterPoint () const
    {
      return this->CenterPoint_.get ();
    }

    CircleType::CenterPoint_type& CircleType::
    CenterPoint ()
    {
      return this->CenterPoint_.get ();
    }

    void CircleType::
    CenterPoint (const CenterPoint_type& x)
    {
      this->CenterPoint_.set (x);
    }

    void CircleType::
    CenterPoint (::std::unique_ptr< CenterPoint_type > x)
    {
      this->CenterPoint_.set (std::move (x));
    }

    const CircleType::Diameter_type& CircleType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CircleType::Diameter_type& CircleType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CircleType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const CircleType::Normal_type& CircleType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    CircleType::Normal_type& CircleType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void CircleType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircleType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }


    // CylinderType
    //

    const CylinderType::CenterPoint_type& CylinderType::
    CenterPoint () const
    {
      return this->CenterPoint_.get ();
    }

    CylinderType::CenterPoint_type& CylinderType::
    CenterPoint ()
    {
      return this->CenterPoint_.get ();
    }

    void CylinderType::
    CenterPoint (const CenterPoint_type& x)
    {
      this->CenterPoint_.set (x);
    }

    void CylinderType::
    CenterPoint (::std::unique_ptr< CenterPoint_type > x)
    {
      this->CenterPoint_.set (std::move (x));
    }

    const CylinderType::Diameter_type& CylinderType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CylinderType::Diameter_type& CylinderType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CylinderType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylinderType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const CylinderType::Axis_type& CylinderType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    CylinderType::Axis_type& CylinderType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void CylinderType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylinderType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const CylinderType::Length_type& CylinderType::
    Length () const
    {
      return this->Length_.get ();
    }

    CylinderType::Length_type& CylinderType::
    Length ()
    {
      return this->Length_.get ();
    }

    void CylinderType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylinderType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }


    // SphereType
    //

    const SphereType::CenterPoint_type& SphereType::
    CenterPoint () const
    {
      return this->CenterPoint_.get ();
    }

    SphereType::CenterPoint_type& SphereType::
    CenterPoint ()
    {
      return this->CenterPoint_.get ();
    }

    void SphereType::
    CenterPoint (const CenterPoint_type& x)
    {
      this->CenterPoint_.set (x);
    }

    void SphereType::
    CenterPoint (::std::unique_ptr< CenterPoint_type > x)
    {
      this->CenterPoint_.set (std::move (x));
    }

    const SphereType::Diameter_type& SphereType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    SphereType::Diameter_type& SphereType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void SphereType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphereType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }


    // PointAndVectorType
    //

    const PointAndVectorType::StartPoint_type& PointAndVectorType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    PointAndVectorType::StartPoint_type& PointAndVectorType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void PointAndVectorType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void PointAndVectorType::
    StartPoint (::std::unique_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (std::move (x));
    }

    const PointAndVectorType::Vector_type& PointAndVectorType::
    Vector () const
    {
      return this->Vector_.get ();
    }

    PointAndVectorType::Vector_type& PointAndVectorType::
    Vector ()
    {
      return this->Vector_.get ();
    }

    void PointAndVectorType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void PointAndVectorType::
    Vector (::std::unique_ptr< Vector_type > x)
    {
      this->Vector_.set (std::move (x));
    }


    // MeasuredPointAndVectorType
    //

    const MeasuredPointAndVectorType::StartPoint_type& MeasuredPointAndVectorType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    MeasuredPointAndVectorType::StartPoint_type& MeasuredPointAndVectorType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void MeasuredPointAndVectorType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void MeasuredPointAndVectorType::
    StartPoint (::std::unique_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (std::move (x));
    }

    const MeasuredPointAndVectorType::Vector_type& MeasuredPointAndVectorType::
    Vector () const
    {
      return this->Vector_.get ();
    }

    MeasuredPointAndVectorType::Vector_type& MeasuredPointAndVectorType::
    Vector ()
    {
      return this->Vector_.get ();
    }

    void MeasuredPointAndVectorType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void MeasuredPointAndVectorType::
    Vector (::std::unique_ptr< Vector_type > x)
    {
      this->Vector_.set (std::move (x));
    }


    // SlotEndEnumType
    //

    SlotEndEnumType::
    SlotEndEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SlotEndEnumType_literals_[v])
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SlotEndEnumType::
    SlotEndEnumType (const SlotEndEnumType& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SlotEndEnumType& SlotEndEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SlotEndEnumType_literals_[v]);

      return *this;
    }


    // EndRadiusType
    //

    const EndRadiusType::EndRadius_type& EndRadiusType::
    EndRadius () const
    {
      return this->EndRadius_.get ();
    }

    EndRadiusType::EndRadius_type& EndRadiusType::
    EndRadius ()
    {
      return this->EndRadius_.get ();
    }

    void EndRadiusType::
    EndRadius (const EndRadius_type& x)
    {
      this->EndRadius_.set (x);
    }

    void EndRadiusType::
    EndRadius (::std::unique_ptr< EndRadius_type > x)
    {
      this->EndRadius_.set (std::move (x));
    }

    const EndRadiusType::Expanded_optional& EndRadiusType::
    Expanded () const
    {
      return this->Expanded_;
    }

    EndRadiusType::Expanded_optional& EndRadiusType::
    Expanded ()
    {
      return this->Expanded_;
    }

    void EndRadiusType::
    Expanded (const Expanded_type& x)
    {
      this->Expanded_.set (x);
    }

    void EndRadiusType::
    Expanded (const Expanded_optional& x)
    {
      this->Expanded_ = x;
    }


    // MeasuredEndRadiusType
    //

    const MeasuredEndRadiusType::EndRadius_type& MeasuredEndRadiusType::
    EndRadius () const
    {
      return this->EndRadius_.get ();
    }

    MeasuredEndRadiusType::EndRadius_type& MeasuredEndRadiusType::
    EndRadius ()
    {
      return this->EndRadius_.get ();
    }

    void MeasuredEndRadiusType::
    EndRadius (const EndRadius_type& x)
    {
      this->EndRadius_.set (x);
    }

    void MeasuredEndRadiusType::
    EndRadius (::std::unique_ptr< EndRadius_type > x)
    {
      this->EndRadius_.set (std::move (x));
    }

    const MeasuredEndRadiusType::Expanded_optional& MeasuredEndRadiusType::
    Expanded () const
    {
      return this->Expanded_;
    }

    MeasuredEndRadiusType::Expanded_optional& MeasuredEndRadiusType::
    Expanded ()
    {
      return this->Expanded_;
    }

    void MeasuredEndRadiusType::
    Expanded (const Expanded_type& x)
    {
      this->Expanded_.set (x);
    }

    void MeasuredEndRadiusType::
    Expanded (const Expanded_optional& x)
    {
      this->Expanded_ = x;
    }


    // SlotEndType
    //

    const SlotEndType::SlotEndEnum_optional& SlotEndType::
    SlotEndEnum () const
    {
      return this->SlotEndEnum_;
    }

    SlotEndType::SlotEndEnum_optional& SlotEndType::
    SlotEndEnum ()
    {
      return this->SlotEndEnum_;
    }

    void SlotEndType::
    SlotEndEnum (const SlotEndEnum_type& x)
    {
      this->SlotEndEnum_.set (x);
    }

    void SlotEndType::
    SlotEndEnum (const SlotEndEnum_optional& x)
    {
      this->SlotEndEnum_ = x;
    }

    void SlotEndType::
    SlotEndEnum (::std::unique_ptr< SlotEndEnum_type > x)
    {
      this->SlotEndEnum_.set (std::move (x));
    }

    const SlotEndType::OtherSlotEnd_optional& SlotEndType::
    OtherSlotEnd () const
    {
      return this->OtherSlotEnd_;
    }

    SlotEndType::OtherSlotEnd_optional& SlotEndType::
    OtherSlotEnd ()
    {
      return this->OtherSlotEnd_;
    }

    void SlotEndType::
    OtherSlotEnd (const OtherSlotEnd_type& x)
    {
      this->OtherSlotEnd_.set (x);
    }

    void SlotEndType::
    OtherSlotEnd (const OtherSlotEnd_optional& x)
    {
      this->OtherSlotEnd_ = x;
    }

    void SlotEndType::
    OtherSlotEnd (::std::unique_ptr< OtherSlotEnd_type > x)
    {
      this->OtherSlotEnd_.set (std::move (x));
    }


    // ThreadSeriesEnumType
    //

    ThreadSeriesEnumType::
    ThreadSeriesEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ThreadSeriesEnumType_literals_[v])
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ThreadSeriesEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ThreadSeriesEnumType& ThreadSeriesEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ThreadSeriesEnumType_literals_[v]);

      return *this;
    }


    // ThreadSeriesType
    //

    const ThreadSeriesType::ThreadSeriesEnum_optional& ThreadSeriesType::
    ThreadSeriesEnum () const
    {
      return this->ThreadSeriesEnum_;
    }

    ThreadSeriesType::ThreadSeriesEnum_optional& ThreadSeriesType::
    ThreadSeriesEnum ()
    {
      return this->ThreadSeriesEnum_;
    }

    void ThreadSeriesType::
    ThreadSeriesEnum (const ThreadSeriesEnum_type& x)
    {
      this->ThreadSeriesEnum_.set (x);
    }

    void ThreadSeriesType::
    ThreadSeriesEnum (const ThreadSeriesEnum_optional& x)
    {
      this->ThreadSeriesEnum_ = x;
    }

    void ThreadSeriesType::
    ThreadSeriesEnum (::std::unique_ptr< ThreadSeriesEnum_type > x)
    {
      this->ThreadSeriesEnum_.set (std::move (x));
    }

    const ThreadSeriesType::OtherThreadSeries_optional& ThreadSeriesType::
    OtherThreadSeries () const
    {
      return this->OtherThreadSeries_;
    }

    ThreadSeriesType::OtherThreadSeries_optional& ThreadSeriesType::
    OtherThreadSeries ()
    {
      return this->OtherThreadSeries_;
    }

    void ThreadSeriesType::
    OtherThreadSeries (const OtherThreadSeries_type& x)
    {
      this->OtherThreadSeries_.set (x);
    }

    void ThreadSeriesType::
    OtherThreadSeries (const OtherThreadSeries_optional& x)
    {
      this->OtherThreadSeries_ = x;
    }

    void ThreadSeriesType::
    OtherThreadSeries (::std::unique_ptr< OtherThreadSeries_type > x)
    {
      this->OtherThreadSeries_.set (std::move (x));
    }


    // ThreadClassType
    //

    const ThreadClassType::ThreadClassEnum_optional& ThreadClassType::
    ThreadClassEnum () const
    {
      return this->ThreadClassEnum_;
    }

    ThreadClassType::ThreadClassEnum_optional& ThreadClassType::
    ThreadClassEnum ()
    {
      return this->ThreadClassEnum_;
    }

    void ThreadClassType::
    ThreadClassEnum (const ThreadClassEnum_type& x)
    {
      this->ThreadClassEnum_.set (x);
    }

    void ThreadClassType::
    ThreadClassEnum (const ThreadClassEnum_optional& x)
    {
      this->ThreadClassEnum_ = x;
    }

    void ThreadClassType::
    ThreadClassEnum (::std::unique_ptr< ThreadClassEnum_type > x)
    {
      this->ThreadClassEnum_.set (std::move (x));
    }

    const ThreadClassType::OtherThreadClass_optional& ThreadClassType::
    OtherThreadClass () const
    {
      return this->OtherThreadClass_;
    }

    ThreadClassType::OtherThreadClass_optional& ThreadClassType::
    OtherThreadClass ()
    {
      return this->OtherThreadClass_;
    }

    void ThreadClassType::
    OtherThreadClass (const OtherThreadClass_type& x)
    {
      this->OtherThreadClass_.set (x);
    }

    void ThreadClassType::
    OtherThreadClass (const OtherThreadClass_optional& x)
    {
      this->OtherThreadClass_ = x;
    }

    void ThreadClassType::
    OtherThreadClass (::std::unique_ptr< OtherThreadClass_type > x)
    {
      this->OtherThreadClass_.set (std::move (x));
    }


    // ThreadClassEnumType
    //

    ThreadClassEnumType::
    ThreadClassEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ThreadClassEnumType_literals_[v])
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ThreadClassEnumType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ThreadClassEnumType& ThreadClassEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ThreadClassEnumType_literals_[v]);

      return *this;
    }


    // SecurityClassificationEnumType
    //

    SecurityClassificationEnumType::
    SecurityClassificationEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SecurityClassificationEnumType_literals_[v])
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const SecurityClassificationEnumType& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SecurityClassificationEnumType& SecurityClassificationEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SecurityClassificationEnumType_literals_[v]);

      return *this;
    }


    // SecurityClassificationType
    //

    const SecurityClassificationType::SecurityClassificationEnum_optional& SecurityClassificationType::
    SecurityClassificationEnum () const
    {
      return this->SecurityClassificationEnum_;
    }

    SecurityClassificationType::SecurityClassificationEnum_optional& SecurityClassificationType::
    SecurityClassificationEnum ()
    {
      return this->SecurityClassificationEnum_;
    }

    void SecurityClassificationType::
    SecurityClassificationEnum (const SecurityClassificationEnum_type& x)
    {
      this->SecurityClassificationEnum_.set (x);
    }

    void SecurityClassificationType::
    SecurityClassificationEnum (const SecurityClassificationEnum_optional& x)
    {
      this->SecurityClassificationEnum_ = x;
    }

    void SecurityClassificationType::
    SecurityClassificationEnum (::std::unique_ptr< SecurityClassificationEnum_type > x)
    {
      this->SecurityClassificationEnum_.set (std::move (x));
    }

    const SecurityClassificationType::OtherSecurityClassification_optional& SecurityClassificationType::
    OtherSecurityClassification () const
    {
      return this->OtherSecurityClassification_;
    }

    SecurityClassificationType::OtherSecurityClassification_optional& SecurityClassificationType::
    OtherSecurityClassification ()
    {
      return this->OtherSecurityClassification_;
    }

    void SecurityClassificationType::
    OtherSecurityClassification (const OtherSecurityClassification_type& x)
    {
      this->OtherSecurityClassification_.set (x);
    }

    void SecurityClassificationType::
    OtherSecurityClassification (const OtherSecurityClassification_optional& x)
    {
      this->OtherSecurityClassification_ = x;
    }

    void SecurityClassificationType::
    OtherSecurityClassification (::std::unique_ptr< OtherSecurityClassification_type > x)
    {
      this->OtherSecurityClassification_.set (std::move (x));
    }


    // DigitalModelFormatEnumType
    //

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DigitalModelFormatEnumType_literals_[v])
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const DigitalModelFormatEnumType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DigitalModelFormatEnumType& DigitalModelFormatEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DigitalModelFormatEnumType_literals_[v]);

      return *this;
    }


    // StatsWithReferenceBaseType
    //

    const StatsWithReferenceBaseType::SoftwareId_optional& StatsWithReferenceBaseType::
    SoftwareId () const
    {
      return this->SoftwareId_;
    }

    StatsWithReferenceBaseType::SoftwareId_optional& StatsWithReferenceBaseType::
    SoftwareId ()
    {
      return this->SoftwareId_;
    }

    void StatsWithReferenceBaseType::
    SoftwareId (const SoftwareId_type& x)
    {
      this->SoftwareId_.set (x);
    }

    void StatsWithReferenceBaseType::
    SoftwareId (const SoftwareId_optional& x)
    {
      this->SoftwareId_ = x;
    }

    void StatsWithReferenceBaseType::
    SoftwareId (::std::unique_ptr< SoftwareId_type > x)
    {
      this->SoftwareId_.set (std::move (x));
    }

    const StatsWithReferenceBaseType::StandardId_optional& StatsWithReferenceBaseType::
    StandardId () const
    {
      return this->StandardId_;
    }

    StatsWithReferenceBaseType::StandardId_optional& StatsWithReferenceBaseType::
    StandardId ()
    {
      return this->StandardId_;
    }

    void StatsWithReferenceBaseType::
    StandardId (const StandardId_type& x)
    {
      this->StandardId_.set (x);
    }

    void StatsWithReferenceBaseType::
    StandardId (const StandardId_optional& x)
    {
      this->StandardId_ = x;
    }

    void StatsWithReferenceBaseType::
    StandardId (::std::unique_ptr< StandardId_type > x)
    {
      this->StandardId_.set (std::move (x));
    }

    const StatsWithReferenceBaseType::AlgorithmId_optional& StatsWithReferenceBaseType::
    AlgorithmId () const
    {
      return this->AlgorithmId_;
    }

    StatsWithReferenceBaseType::AlgorithmId_optional& StatsWithReferenceBaseType::
    AlgorithmId ()
    {
      return this->AlgorithmId_;
    }

    void StatsWithReferenceBaseType::
    AlgorithmId (const AlgorithmId_type& x)
    {
      this->AlgorithmId_.set (x);
    }

    void StatsWithReferenceBaseType::
    AlgorithmId (const AlgorithmId_optional& x)
    {
      this->AlgorithmId_ = x;
    }

    void StatsWithReferenceBaseType::
    AlgorithmId (::std::unique_ptr< AlgorithmId_type > x)
    {
      this->AlgorithmId_.set (std::move (x));
    }


    // StatsValuesEnumType
    //

    StatsValuesEnumType::
    StatsValuesEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    StatsValuesEnumType::
    StatsValuesEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_StatsValuesEnumType_literals_[v])
    {
    }

    StatsValuesEnumType::
    StatsValuesEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StatsValuesEnumType::
    StatsValuesEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StatsValuesEnumType::
    StatsValuesEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    StatsValuesEnumType::
    StatsValuesEnumType (const StatsValuesEnumType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    StatsValuesEnumType& StatsValuesEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_StatsValuesEnumType_literals_[v]);

      return *this;
    }


    // ListAccumulatedStatsValuesListType
    //

    ListAccumulatedStatsValuesListType::
    ListAccumulatedStatsValuesListType ()
    : ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (this)
    {
    }

    ListAccumulatedStatsValuesListType::
    ListAccumulatedStatsValuesListType (size_type n, const ::xsd::qif30::StatsValuesEnumType& x)
    : ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (n, x, this)
    {
    }

    ListAccumulatedStatsValuesListType::
    ListAccumulatedStatsValuesListType (const ListAccumulatedStatsValuesListType& o,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (o, f, this)
    {
    }

    // ListAccumulatedStatsValuesType
    //

    const ListAccumulatedStatsValuesType::Stats_type& ListAccumulatedStatsValuesType::
    Stats () const
    {
      return this->Stats_.get ();
    }

    ListAccumulatedStatsValuesType::Stats_type& ListAccumulatedStatsValuesType::
    Stats ()
    {
      return this->Stats_.get ();
    }

    void ListAccumulatedStatsValuesType::
    Stats (const Stats_type& x)
    {
      this->Stats_.set (x);
    }

    void ListAccumulatedStatsValuesType::
    Stats (::std::unique_ptr< Stats_type > x)
    {
      this->Stats_.set (std::move (x));
    }


    // SubgroupStatsValuesEnumType
    //

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SubgroupStatsValuesEnumType_literals_[v])
    {
    }

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType (const SubgroupStatsValuesEnumType& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SubgroupStatsValuesEnumType& SubgroupStatsValuesEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SubgroupStatsValuesEnumType_literals_[v]);

      return *this;
    }


    // ListSubgroupStatsValuesListType
    //

    ListSubgroupStatsValuesListType::
    ListSubgroupStatsValuesListType ()
    : ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t > (this)
    {
    }

    ListSubgroupStatsValuesListType::
    ListSubgroupStatsValuesListType (size_type n, const ::xsd::qif30::SubgroupStatsValuesEnumType& x)
    : ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t > (n, x, this)
    {
    }

    ListSubgroupStatsValuesListType::
    ListSubgroupStatsValuesListType (const ListSubgroupStatsValuesListType& o,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t > (o, f, this)
    {
    }

    // ListSubgroupStatsValuesType
    //

    const ListSubgroupStatsValuesType::Stats_type& ListSubgroupStatsValuesType::
    Stats () const
    {
      return this->Stats_.get ();
    }

    ListSubgroupStatsValuesType::Stats_type& ListSubgroupStatsValuesType::
    Stats ()
    {
      return this->Stats_.get ();
    }

    void ListSubgroupStatsValuesType::
    Stats (const Stats_type& x)
    {
      this->Stats_.set (x);
    }

    void ListSubgroupStatsValuesType::
    Stats (::std::unique_ptr< Stats_type > x)
    {
      this->Stats_.set (std::move (x));
    }


    // StatsMeasuredDecimalType
    //

    const StatsMeasuredDecimalType::Value_type& StatsMeasuredDecimalType::
    Value () const
    {
      return this->Value_.get ();
    }

    StatsMeasuredDecimalType::Value_type& StatsMeasuredDecimalType::
    Value ()
    {
      return this->Value_.get ();
    }

    void StatsMeasuredDecimalType::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void StatsMeasuredDecimalType::
    Value (::std::unique_ptr< Value_type > x)
    {
      this->Value_.set (std::move (x));
    }


    // StatsMeasuredDecimalWithReferenceType
    //

    const StatsMeasuredDecimalWithReferenceType::Id_optional& StatsMeasuredDecimalWithReferenceType::
    Id () const
    {
      return this->Id_;
    }

    StatsMeasuredDecimalWithReferenceType::Id_optional& StatsMeasuredDecimalWithReferenceType::
    Id ()
    {
      return this->Id_;
    }

    void StatsMeasuredDecimalWithReferenceType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void StatsMeasuredDecimalWithReferenceType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void StatsMeasuredDecimalWithReferenceType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // SubgroupDecimalType
    //

    const SubgroupDecimalType::subgroupId_type& SubgroupDecimalType::
    subgroupId () const
    {
      return this->subgroupId_.get ();
    }

    SubgroupDecimalType::subgroupId_type& SubgroupDecimalType::
    subgroupId ()
    {
      return this->subgroupId_.get ();
    }

    void SubgroupDecimalType::
    subgroupId (const subgroupId_type& x)
    {
      this->subgroupId_.set (x);
    }

    void SubgroupDecimalType::
    subgroupId (::std::unique_ptr< subgroupId_type > x)
    {
      this->subgroupId_.set (std::move (x));
    }


    // SubgroupDecimalArrayType
    //

    const SubgroupDecimalArrayType::SubgroupDecimal_sequence& SubgroupDecimalArrayType::
    SubgroupDecimal () const
    {
      return this->SubgroupDecimal_;
    }

    SubgroupDecimalArrayType::SubgroupDecimal_sequence& SubgroupDecimalArrayType::
    SubgroupDecimal ()
    {
      return this->SubgroupDecimal_;
    }

    void SubgroupDecimalArrayType::
    SubgroupDecimal (const SubgroupDecimal_sequence& s)
    {
      this->SubgroupDecimal_ = s;
    }

    const SubgroupDecimalArrayType::n_type& SubgroupDecimalArrayType::
    n () const
    {
      return this->n_.get ();
    }

    SubgroupDecimalArrayType::n_type& SubgroupDecimalArrayType::
    n ()
    {
      return this->n_.get ();
    }

    void SubgroupDecimalArrayType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SubgroupDecimalArrayType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SubgroupDecimalsType
    //

    const SubgroupDecimalsType::Values_type& SubgroupDecimalsType::
    Values () const
    {
      return this->Values_.get ();
    }

    SubgroupDecimalsType::Values_type& SubgroupDecimalsType::
    Values ()
    {
      return this->Values_.get ();
    }

    void SubgroupDecimalsType::
    Values (const Values_type& x)
    {
      this->Values_.set (x);
    }

    void SubgroupDecimalsType::
    Values (::std::unique_ptr< Values_type > x)
    {
      this->Values_.set (std::move (x));
    }


    // StatsNonNegativeIntegerType
    //

    const StatsNonNegativeIntegerType::Value_type& StatsNonNegativeIntegerType::
    Value () const
    {
      return this->Value_.get ();
    }

    StatsNonNegativeIntegerType::Value_type& StatsNonNegativeIntegerType::
    Value ()
    {
      return this->Value_.get ();
    }

    void StatsNonNegativeIntegerType::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }


    // StatsNonNegativeIntegerWithReferencesType
    //

    const StatsNonNegativeIntegerWithReferencesType::Ids_optional& StatsNonNegativeIntegerWithReferencesType::
    Ids () const
    {
      return this->Ids_;
    }

    StatsNonNegativeIntegerWithReferencesType::Ids_optional& StatsNonNegativeIntegerWithReferencesType::
    Ids ()
    {
      return this->Ids_;
    }

    void StatsNonNegativeIntegerWithReferencesType::
    Ids (const Ids_type& x)
    {
      this->Ids_.set (x);
    }

    void StatsNonNegativeIntegerWithReferencesType::
    Ids (const Ids_optional& x)
    {
      this->Ids_ = x;
    }

    void StatsNonNegativeIntegerWithReferencesType::
    Ids (::std::unique_ptr< Ids_type > x)
    {
      this->Ids_.set (std::move (x));
    }


    // SubgroupIntegerType
    //

    const SubgroupIntegerType::subgroupId_type& SubgroupIntegerType::
    subgroupId () const
    {
      return this->subgroupId_.get ();
    }

    SubgroupIntegerType::subgroupId_type& SubgroupIntegerType::
    subgroupId ()
    {
      return this->subgroupId_.get ();
    }

    void SubgroupIntegerType::
    subgroupId (const subgroupId_type& x)
    {
      this->subgroupId_.set (x);
    }

    void SubgroupIntegerType::
    subgroupId (::std::unique_ptr< subgroupId_type > x)
    {
      this->subgroupId_.set (std::move (x));
    }


    // SubgroupIntegerArrayType
    //

    const SubgroupIntegerArrayType::SubgroupInteger_sequence& SubgroupIntegerArrayType::
    SubgroupInteger () const
    {
      return this->SubgroupInteger_;
    }

    SubgroupIntegerArrayType::SubgroupInteger_sequence& SubgroupIntegerArrayType::
    SubgroupInteger ()
    {
      return this->SubgroupInteger_;
    }

    void SubgroupIntegerArrayType::
    SubgroupInteger (const SubgroupInteger_sequence& s)
    {
      this->SubgroupInteger_ = s;
    }

    const SubgroupIntegerArrayType::n_type& SubgroupIntegerArrayType::
    n () const
    {
      return this->n_.get ();
    }

    SubgroupIntegerArrayType::n_type& SubgroupIntegerArrayType::
    n ()
    {
      return this->n_.get ();
    }

    void SubgroupIntegerArrayType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SubgroupIntegerArrayType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SubgroupIntegersType
    //

    const SubgroupIntegersType::Values_type& SubgroupIntegersType::
    Values () const
    {
      return this->Values_.get ();
    }

    SubgroupIntegersType::Values_type& SubgroupIntegersType::
    Values ()
    {
      return this->Values_.get ();
    }

    void SubgroupIntegersType::
    Values (const Values_type& x)
    {
      this->Values_.set (x);
    }

    void SubgroupIntegersType::
    Values (::std::unique_ptr< Values_type > x)
    {
      this->Values_.set (std::move (x));
    }


    // SummaryStatsValuesEnumType
    //

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SummaryStatsValuesEnumType_literals_[v])
    {
    }

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType (const SummaryStatsValuesEnumType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SummaryStatsValuesEnumType& SummaryStatsValuesEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SummaryStatsValuesEnumType_literals_[v]);

      return *this;
    }


    // ListSummaryStatsValuesListType
    //

    ListSummaryStatsValuesListType::
    ListSummaryStatsValuesListType ()
    : ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (this)
    {
    }

    ListSummaryStatsValuesListType::
    ListSummaryStatsValuesListType (size_type n, const ::xsd::qif30::StatsValuesEnumType& x)
    : ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (n, x, this)
    {
    }

    ListSummaryStatsValuesListType::
    ListSummaryStatsValuesListType (const ListSummaryStatsValuesListType& o,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (o, f, this)
    {
    }

    // ListSummaryStatsValuesType
    //

    const ListSummaryStatsValuesType::Stats_type& ListSummaryStatsValuesType::
    Stats () const
    {
      return this->Stats_.get ();
    }

    ListSummaryStatsValuesType::Stats_type& ListSummaryStatsValuesType::
    Stats ()
    {
      return this->Stats_.get ();
    }

    void ListSummaryStatsValuesType::
    Stats (const Stats_type& x)
    {
      this->Stats_.set (x);
    }

    void ListSummaryStatsValuesType::
    Stats (::std::unique_ptr< Stats_type > x)
    {
      this->Stats_.set (std::move (x));
    }


    // SummaryStatsValuesType
    //

    const SummaryStatsValuesType::SummaryType_type& SummaryStatsValuesType::
    SummaryType () const
    {
      return this->SummaryType_.get ();
    }

    SummaryStatsValuesType::SummaryType_type& SummaryStatsValuesType::
    SummaryType ()
    {
      return this->SummaryType_.get ();
    }

    void SummaryStatsValuesType::
    SummaryType (const SummaryType_type& x)
    {
      this->SummaryType_.set (x);
    }

    void SummaryStatsValuesType::
    SummaryType (::std::unique_ptr< SummaryType_type > x)
    {
      this->SummaryType_.set (std::move (x));
    }

    const SummaryStatsValuesType::SummaryStats_type& SummaryStatsValuesType::
    SummaryStats () const
    {
      return this->SummaryStats_.get ();
    }

    SummaryStatsValuesType::SummaryStats_type& SummaryStatsValuesType::
    SummaryStats ()
    {
      return this->SummaryStats_.get ();
    }

    void SummaryStatsValuesType::
    SummaryStats (const SummaryStats_type& x)
    {
      this->SummaryStats_.set (x);
    }

    void SummaryStatsValuesType::
    SummaryStats (::std::unique_ptr< SummaryStats_type > x)
    {
      this->SummaryStats_.set (std::move (x));
    }


    // SummaryStatsValuesListType
    //

    const SummaryStatsValuesListType::SummaryStatsValues_sequence& SummaryStatsValuesListType::
    SummaryStatsValues () const
    {
      return this->SummaryStatsValues_;
    }

    SummaryStatsValuesListType::SummaryStatsValues_sequence& SummaryStatsValuesListType::
    SummaryStatsValues ()
    {
      return this->SummaryStatsValues_;
    }

    void SummaryStatsValuesListType::
    SummaryStatsValues (const SummaryStatsValues_sequence& s)
    {
      this->SummaryStatsValues_ = s;
    }

    const SummaryStatsValuesListType::n_type& SummaryStatsValuesListType::
    n () const
    {
      return this->n_.get ();
    }

    SummaryStatsValuesListType::n_type& SummaryStatsValuesListType::
    n ()
    {
      return this->n_.get ();
    }

    void SummaryStatsValuesListType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SummaryStatsValuesListType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // DigitalModelFormatType
    //

    const DigitalModelFormatType::DigitalModelFormatEnum_optional& DigitalModelFormatType::
    DigitalModelFormatEnum () const
    {
      return this->DigitalModelFormatEnum_;
    }

    DigitalModelFormatType::DigitalModelFormatEnum_optional& DigitalModelFormatType::
    DigitalModelFormatEnum ()
    {
      return this->DigitalModelFormatEnum_;
    }

    void DigitalModelFormatType::
    DigitalModelFormatEnum (const DigitalModelFormatEnum_type& x)
    {
      this->DigitalModelFormatEnum_.set (x);
    }

    void DigitalModelFormatType::
    DigitalModelFormatEnum (const DigitalModelFormatEnum_optional& x)
    {
      this->DigitalModelFormatEnum_ = x;
    }

    void DigitalModelFormatType::
    DigitalModelFormatEnum (::std::unique_ptr< DigitalModelFormatEnum_type > x)
    {
      this->DigitalModelFormatEnum_.set (std::move (x));
    }

    const DigitalModelFormatType::OtherDigitalModelFormat_optional& DigitalModelFormatType::
    OtherDigitalModelFormat () const
    {
      return this->OtherDigitalModelFormat_;
    }

    DigitalModelFormatType::OtherDigitalModelFormat_optional& DigitalModelFormatType::
    OtherDigitalModelFormat ()
    {
      return this->OtherDigitalModelFormat_;
    }

    void DigitalModelFormatType::
    OtherDigitalModelFormat (const OtherDigitalModelFormat_type& x)
    {
      this->OtherDigitalModelFormat_.set (x);
    }

    void DigitalModelFormatType::
    OtherDigitalModelFormat (const OtherDigitalModelFormat_optional& x)
    {
      this->OtherDigitalModelFormat_ = x;
    }

    void DigitalModelFormatType::
    OtherDigitalModelFormat (::std::unique_ptr< OtherDigitalModelFormat_type > x)
    {
      this->OtherDigitalModelFormat_.set (std::move (x));
    }


    // UniformScaleType
    //

    const UniformScaleType::ScaleFactor_type& UniformScaleType::
    ScaleFactor () const
    {
      return this->ScaleFactor_.get ();
    }

    UniformScaleType::ScaleFactor_type& UniformScaleType::
    ScaleFactor ()
    {
      return this->ScaleFactor_.get ();
    }

    void UniformScaleType::
    ScaleFactor (const ScaleFactor_type& x)
    {
      this->ScaleFactor_.set (x);
    }


    // RadialDifferentialScaleType
    //

    const RadialDifferentialScaleType::PerpendicularScaleFactor_type& RadialDifferentialScaleType::
    PerpendicularScaleFactor () const
    {
      return this->PerpendicularScaleFactor_.get ();
    }

    RadialDifferentialScaleType::PerpendicularScaleFactor_type& RadialDifferentialScaleType::
    PerpendicularScaleFactor ()
    {
      return this->PerpendicularScaleFactor_.get ();
    }

    void RadialDifferentialScaleType::
    PerpendicularScaleFactor (const PerpendicularScaleFactor_type& x)
    {
      this->PerpendicularScaleFactor_.set (x);
    }

    const RadialDifferentialScaleType::ParallelScaleFactor_type& RadialDifferentialScaleType::
    ParallelScaleFactor () const
    {
      return this->ParallelScaleFactor_.get ();
    }

    RadialDifferentialScaleType::ParallelScaleFactor_type& RadialDifferentialScaleType::
    ParallelScaleFactor ()
    {
      return this->ParallelScaleFactor_.get ();
    }

    void RadialDifferentialScaleType::
    ParallelScaleFactor (const ParallelScaleFactor_type& x)
    {
      this->ParallelScaleFactor_.set (x);
    }

    const RadialDifferentialScaleType::Direction_type& RadialDifferentialScaleType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    RadialDifferentialScaleType::Direction_type& RadialDifferentialScaleType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void RadialDifferentialScaleType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void RadialDifferentialScaleType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }


    // AxialDifferentialScaleType
    //

    const AxialDifferentialScaleType::XScaleFactor_type& AxialDifferentialScaleType::
    XScaleFactor () const
    {
      return this->XScaleFactor_.get ();
    }

    AxialDifferentialScaleType::XScaleFactor_type& AxialDifferentialScaleType::
    XScaleFactor ()
    {
      return this->XScaleFactor_.get ();
    }

    void AxialDifferentialScaleType::
    XScaleFactor (const XScaleFactor_type& x)
    {
      this->XScaleFactor_.set (x);
    }

    const AxialDifferentialScaleType::XaxisDirection_type& AxialDifferentialScaleType::
    XaxisDirection () const
    {
      return this->XaxisDirection_.get ();
    }

    AxialDifferentialScaleType::XaxisDirection_type& AxialDifferentialScaleType::
    XaxisDirection ()
    {
      return this->XaxisDirection_.get ();
    }

    void AxialDifferentialScaleType::
    XaxisDirection (const XaxisDirection_type& x)
    {
      this->XaxisDirection_.set (x);
    }

    void AxialDifferentialScaleType::
    XaxisDirection (::std::unique_ptr< XaxisDirection_type > x)
    {
      this->XaxisDirection_.set (std::move (x));
    }

    const AxialDifferentialScaleType::YScaleFactor_type& AxialDifferentialScaleType::
    YScaleFactor () const
    {
      return this->YScaleFactor_.get ();
    }

    AxialDifferentialScaleType::YScaleFactor_type& AxialDifferentialScaleType::
    YScaleFactor ()
    {
      return this->YScaleFactor_.get ();
    }

    void AxialDifferentialScaleType::
    YScaleFactor (const YScaleFactor_type& x)
    {
      this->YScaleFactor_.set (x);
    }

    const AxialDifferentialScaleType::YaxisDirection_type& AxialDifferentialScaleType::
    YaxisDirection () const
    {
      return this->YaxisDirection_.get ();
    }

    AxialDifferentialScaleType::YaxisDirection_type& AxialDifferentialScaleType::
    YaxisDirection ()
    {
      return this->YaxisDirection_.get ();
    }

    void AxialDifferentialScaleType::
    YaxisDirection (const YaxisDirection_type& x)
    {
      this->YaxisDirection_.set (x);
    }

    void AxialDifferentialScaleType::
    YaxisDirection (::std::unique_ptr< YaxisDirection_type > x)
    {
      this->YaxisDirection_.set (std::move (x));
    }

    const AxialDifferentialScaleType::ZScaleFactor_type& AxialDifferentialScaleType::
    ZScaleFactor () const
    {
      return this->ZScaleFactor_.get ();
    }

    AxialDifferentialScaleType::ZScaleFactor_type& AxialDifferentialScaleType::
    ZScaleFactor ()
    {
      return this->ZScaleFactor_.get ();
    }

    void AxialDifferentialScaleType::
    ZScaleFactor (const ZScaleFactor_type& x)
    {
      this->ZScaleFactor_.set (x);
    }

    const AxialDifferentialScaleType::ZaxisDirection_type& AxialDifferentialScaleType::
    ZaxisDirection () const
    {
      return this->ZaxisDirection_.get ();
    }

    AxialDifferentialScaleType::ZaxisDirection_type& AxialDifferentialScaleType::
    ZaxisDirection ()
    {
      return this->ZaxisDirection_.get ();
    }

    void AxialDifferentialScaleType::
    ZaxisDirection (const ZaxisDirection_type& x)
    {
      this->ZaxisDirection_.set (x);
    }

    void AxialDifferentialScaleType::
    ZaxisDirection (::std::unique_ptr< ZaxisDirection_type > x)
    {
      this->ZaxisDirection_.set (std::move (x));
    }


    // ScaleType
    //

    const ScaleType::Origin_type& ScaleType::
    Origin () const
    {
      return this->Origin_.get ();
    }

    ScaleType::Origin_type& ScaleType::
    Origin ()
    {
      return this->Origin_.get ();
    }

    void ScaleType::
    Origin (const Origin_type& x)
    {
      this->Origin_.set (x);
    }

    void ScaleType::
    Origin (::std::unique_ptr< Origin_type > x)
    {
      this->Origin_.set (std::move (x));
    }

    const ScaleType::UniformScale_optional& ScaleType::
    UniformScale () const
    {
      return this->UniformScale_;
    }

    ScaleType::UniformScale_optional& ScaleType::
    UniformScale ()
    {
      return this->UniformScale_;
    }

    void ScaleType::
    UniformScale (const UniformScale_type& x)
    {
      this->UniformScale_.set (x);
    }

    void ScaleType::
    UniformScale (const UniformScale_optional& x)
    {
      this->UniformScale_ = x;
    }

    void ScaleType::
    UniformScale (::std::unique_ptr< UniformScale_type > x)
    {
      this->UniformScale_.set (std::move (x));
    }

    const ScaleType::RadialDifferentialScale_optional& ScaleType::
    RadialDifferentialScale () const
    {
      return this->RadialDifferentialScale_;
    }

    ScaleType::RadialDifferentialScale_optional& ScaleType::
    RadialDifferentialScale ()
    {
      return this->RadialDifferentialScale_;
    }

    void ScaleType::
    RadialDifferentialScale (const RadialDifferentialScale_type& x)
    {
      this->RadialDifferentialScale_.set (x);
    }

    void ScaleType::
    RadialDifferentialScale (const RadialDifferentialScale_optional& x)
    {
      this->RadialDifferentialScale_ = x;
    }

    void ScaleType::
    RadialDifferentialScale (::std::unique_ptr< RadialDifferentialScale_type > x)
    {
      this->RadialDifferentialScale_.set (std::move (x));
    }

    const ScaleType::AxialDifferentialScale_optional& ScaleType::
    AxialDifferentialScale () const
    {
      return this->AxialDifferentialScale_;
    }

    ScaleType::AxialDifferentialScale_optional& ScaleType::
    AxialDifferentialScale ()
    {
      return this->AxialDifferentialScale_;
    }

    void ScaleType::
    AxialDifferentialScale (const AxialDifferentialScale_type& x)
    {
      this->AxialDifferentialScale_.set (x);
    }

    void ScaleType::
    AxialDifferentialScale (const AxialDifferentialScale_optional& x)
    {
      this->AxialDifferentialScale_ = x;
    }

    void ScaleType::
    AxialDifferentialScale (::std::unique_ptr< AxialDifferentialScale_type > x)
    {
      this->AxialDifferentialScale_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // RectangularUnitAreaType
    //

    RectangularUnitAreaType::
    RectangularUnitAreaType ()
    : ::xml_schema::type (),
      RectangularUnitAreaLength_ (this),
      RectangularUnitAreaWidth_ (this),
      RectangularUnitAreaOrientation_ (this)
    {
    }

    RectangularUnitAreaType::
    RectangularUnitAreaType (const RectangularUnitAreaLength_type& RectangularUnitAreaLength,
                             const RectangularUnitAreaWidth_type& RectangularUnitAreaWidth)
    : ::xml_schema::type (),
      RectangularUnitAreaLength_ (RectangularUnitAreaLength, this),
      RectangularUnitAreaWidth_ (RectangularUnitAreaWidth, this),
      RectangularUnitAreaOrientation_ (this)
    {
    }

    RectangularUnitAreaType::
    RectangularUnitAreaType (::std::unique_ptr< RectangularUnitAreaLength_type > RectangularUnitAreaLength,
                             ::std::unique_ptr< RectangularUnitAreaWidth_type > RectangularUnitAreaWidth)
    : ::xml_schema::type (),
      RectangularUnitAreaLength_ (std::move (RectangularUnitAreaLength), this),
      RectangularUnitAreaWidth_ (std::move (RectangularUnitAreaWidth), this),
      RectangularUnitAreaOrientation_ (this)
    {
    }

    RectangularUnitAreaType::
    RectangularUnitAreaType (const RectangularUnitAreaType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      RectangularUnitAreaLength_ (x.RectangularUnitAreaLength_, f, this),
      RectangularUnitAreaWidth_ (x.RectangularUnitAreaWidth_, f, this),
      RectangularUnitAreaOrientation_ (x.RectangularUnitAreaOrientation_, f, this)
    {
    }

    RectangularUnitAreaType::
    RectangularUnitAreaType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      RectangularUnitAreaLength_ (this),
      RectangularUnitAreaWidth_ (this),
      RectangularUnitAreaOrientation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RectangularUnitAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // RectangularUnitAreaLength
        //
        if (n.name () == L"RectangularUnitAreaLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RectangularUnitAreaLength_type > r (
            RectangularUnitAreaLength_traits::create (i, f, this));

          if (!RectangularUnitAreaLength_.present ())
          {
            this->RectangularUnitAreaLength_.set (::std::move (r));
            continue;
          }
        }

        // RectangularUnitAreaWidth
        //
        if (n.name () == L"RectangularUnitAreaWidth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RectangularUnitAreaWidth_type > r (
            RectangularUnitAreaWidth_traits::create (i, f, this));

          if (!RectangularUnitAreaWidth_.present ())
          {
            this->RectangularUnitAreaWidth_.set (::std::move (r));
            continue;
          }
        }

        // RectangularUnitAreaOrientation
        //
        if (n.name () == L"RectangularUnitAreaOrientation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RectangularUnitAreaOrientation_type > r (
            RectangularUnitAreaOrientation_traits::create (i, f, this));

          if (!this->RectangularUnitAreaOrientation_)
          {
            this->RectangularUnitAreaOrientation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!RectangularUnitAreaLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RectangularUnitAreaLength",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RectangularUnitAreaWidth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RectangularUnitAreaWidth",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    RectangularUnitAreaType* RectangularUnitAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RectangularUnitAreaType (*this, f, c);
    }

    RectangularUnitAreaType& RectangularUnitAreaType::
    operator= (const RectangularUnitAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->RectangularUnitAreaLength_ = x.RectangularUnitAreaLength_;
        this->RectangularUnitAreaWidth_ = x.RectangularUnitAreaWidth_;
        this->RectangularUnitAreaOrientation_ = x.RectangularUnitAreaOrientation_;
      }

      return *this;
    }

    RectangularUnitAreaType::
    ~RectangularUnitAreaType ()
    {
    }

    // CircularUnitAreaType
    //

    CircularUnitAreaType::
    CircularUnitAreaType ()
    : ::xml_schema::type (),
      CircularUnitAreaDiameter_ (this)
    {
    }

    CircularUnitAreaType::
    CircularUnitAreaType (const CircularUnitAreaDiameter_type& CircularUnitAreaDiameter)
    : ::xml_schema::type (),
      CircularUnitAreaDiameter_ (CircularUnitAreaDiameter, this)
    {
    }

    CircularUnitAreaType::
    CircularUnitAreaType (::std::unique_ptr< CircularUnitAreaDiameter_type > CircularUnitAreaDiameter)
    : ::xml_schema::type (),
      CircularUnitAreaDiameter_ (std::move (CircularUnitAreaDiameter), this)
    {
    }

    CircularUnitAreaType::
    CircularUnitAreaType (const CircularUnitAreaType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CircularUnitAreaDiameter_ (x.CircularUnitAreaDiameter_, f, this)
    {
    }

    CircularUnitAreaType::
    CircularUnitAreaType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CircularUnitAreaDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularUnitAreaType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CircularUnitAreaDiameter
        //
        if (n.name () == L"CircularUnitAreaDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CircularUnitAreaDiameter_type > r (
            CircularUnitAreaDiameter_traits::create (i, f, this));

          if (!CircularUnitAreaDiameter_.present ())
          {
            this->CircularUnitAreaDiameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CircularUnitAreaDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CircularUnitAreaDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularUnitAreaType* CircularUnitAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularUnitAreaType (*this, f, c);
    }

    CircularUnitAreaType& CircularUnitAreaType::
    operator= (const CircularUnitAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CircularUnitAreaDiameter_ = x.CircularUnitAreaDiameter_;
      }

      return *this;
    }

    CircularUnitAreaType::
    ~CircularUnitAreaType ()
    {
    }

    // MeasuredPointType
    //

    MeasuredPointType::
    MeasuredPointType ()
    : ::xsd::qif30::PointType (),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
    }

    MeasuredPointType::
    MeasuredPointType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::PointType (_xsd_ListDoubleType_base),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
    }

    MeasuredPointType::
    MeasuredPointType (const MeasuredPointType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::PointType (x, f, c),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this)
    {
    }

    MeasuredPointType::
    MeasuredPointType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::PointType (e, f | ::xml_schema::flags::base, c),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredPointType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredPointType* MeasuredPointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredPointType (*this, f, c);
    }

    MeasuredPointType& MeasuredPointType::
    operator= (const MeasuredPointType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointType& > (*this) = x;
        this->combinedUncertainty_ = x.combinedUncertainty_;
        this->meanError_ = x.meanError_;
        this->xCombinedUncertainty_ = x.xCombinedUncertainty_;
        this->xMeanError_ = x.xMeanError_;
        this->yCombinedUncertainty_ = x.yCombinedUncertainty_;
        this->yMeanError_ = x.yMeanError_;
        this->zCombinedUncertainty_ = x.zCombinedUncertainty_;
        this->zMeanError_ = x.zMeanError_;
      }

      return *this;
    }

    MeasuredPointType::
    ~MeasuredPointType ()
    {
    }

    // MeasuredUnitVectorType
    //

    MeasuredUnitVectorType::
    MeasuredUnitVectorType ()
    : ::xsd::qif30::UnitVectorType (),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
    }

    MeasuredUnitVectorType::
    MeasuredUnitVectorType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::UnitVectorType (_xsd_ListDoubleType_base),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
    }

    MeasuredUnitVectorType::
    MeasuredUnitVectorType (const MeasuredUnitVectorType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::UnitVectorType (x, f, c),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this)
    {
    }

    MeasuredUnitVectorType::
    MeasuredUnitVectorType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::UnitVectorType (e, f | ::xml_schema::flags::base, c),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredUnitVectorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UnitVectorType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredUnitVectorType* MeasuredUnitVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredUnitVectorType (*this, f, c);
    }

    MeasuredUnitVectorType& MeasuredUnitVectorType::
    operator= (const MeasuredUnitVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UnitVectorType& > (*this) = x;
        this->combinedUncertainty_ = x.combinedUncertainty_;
        this->meanError_ = x.meanError_;
        this->xCombinedUncertainty_ = x.xCombinedUncertainty_;
        this->xMeanError_ = x.xMeanError_;
        this->yCombinedUncertainty_ = x.yCombinedUncertainty_;
        this->yMeanError_ = x.yMeanError_;
        this->zCombinedUncertainty_ = x.zCombinedUncertainty_;
        this->zMeanError_ = x.zMeanError_;
      }

      return *this;
    }

    MeasuredUnitVectorType::
    ~MeasuredUnitVectorType ()
    {
    }

    // MeasuredPlaneType
    //

    MeasuredPlaneType::
    MeasuredPlaneType ()
    : ::xml_schema::type (),
      Point_ (this),
      Normal_ (this)
    {
    }

    MeasuredPlaneType::
    MeasuredPlaneType (const Point_type& Point,
                       const Normal_type& Normal)
    : ::xml_schema::type (),
      Point_ (Point, this),
      Normal_ (Normal, this)
    {
    }

    MeasuredPlaneType::
    MeasuredPlaneType (::std::unique_ptr< Point_type > Point,
                       ::std::unique_ptr< Normal_type > Normal)
    : ::xml_schema::type (),
      Point_ (std::move (Point), this),
      Normal_ (std::move (Normal), this)
    {
    }

    MeasuredPlaneType::
    MeasuredPlaneType (const MeasuredPlaneType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    MeasuredPlaneType::
    MeasuredPlaneType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredPlaneType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Point",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasuredPlaneType* MeasuredPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredPlaneType (*this, f, c);
    }

    MeasuredPlaneType& MeasuredPlaneType::
    operator= (const MeasuredPlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Point_ = x.Point_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    MeasuredPlaneType::
    ~MeasuredPlaneType ()
    {
    }

    // MeasuredAxisType
    //

    MeasuredAxisType::
    MeasuredAxisType ()
    : ::xml_schema::type (),
      AxisPoint_ (this),
      Direction_ (this)
    {
    }

    MeasuredAxisType::
    MeasuredAxisType (const AxisPoint_type& AxisPoint,
                      const Direction_type& Direction)
    : ::xml_schema::type (),
      AxisPoint_ (AxisPoint, this),
      Direction_ (Direction, this)
    {
    }

    MeasuredAxisType::
    MeasuredAxisType (::std::unique_ptr< AxisPoint_type > AxisPoint,
                      ::std::unique_ptr< Direction_type > Direction)
    : ::xml_schema::type (),
      AxisPoint_ (std::move (AxisPoint), this),
      Direction_ (std::move (Direction), this)
    {
    }

    MeasuredAxisType::
    MeasuredAxisType (const MeasuredAxisType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AxisPoint_ (x.AxisPoint_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    MeasuredAxisType::
    MeasuredAxisType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AxisPoint_ (this),
      Direction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredAxisType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AxisPoint
        //
        if (n.name () == L"AxisPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisPoint_type > r (
            AxisPoint_traits::create (i, f, this));

          if (!AxisPoint_.present ())
          {
            this->AxisPoint_.set (::std::move (r));
            continue;
          }
        }

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AxisPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AxisPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Direction",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasuredAxisType* MeasuredAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredAxisType (*this, f, c);
    }

    MeasuredAxisType& MeasuredAxisType::
    operator= (const MeasuredAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AxisPoint_ = x.AxisPoint_;
        this->Direction_ = x.Direction_;
      }

      return *this;
    }

    MeasuredAxisType::
    ~MeasuredAxisType ()
    {
    }

    // MeasuredZoneAxisType
    //

    MeasuredZoneAxisType::
    MeasuredZoneAxisType ()
    : ::xsd::qif30::MeasuredAxisType (),
      Length_ (this)
    {
    }

    MeasuredZoneAxisType::
    MeasuredZoneAxisType (const AxisPoint_type& AxisPoint,
                          const Direction_type& Direction,
                          const Length_type& Length)
    : ::xsd::qif30::MeasuredAxisType (AxisPoint,
                                      Direction),
      Length_ (Length, this)
    {
    }

    MeasuredZoneAxisType::
    MeasuredZoneAxisType (::std::unique_ptr< AxisPoint_type > AxisPoint,
                          ::std::unique_ptr< Direction_type > Direction,
                          ::std::unique_ptr< Length_type > Length)
    : ::xsd::qif30::MeasuredAxisType (std::move (AxisPoint),
                                      std::move (Direction)),
      Length_ (std::move (Length), this)
    {
    }

    MeasuredZoneAxisType::
    MeasuredZoneAxisType (const MeasuredZoneAxisType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredAxisType (x, f, c),
      Length_ (x.Length_, f, this)
    {
    }

    MeasuredZoneAxisType::
    MeasuredZoneAxisType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredAxisType (e, f | ::xml_schema::flags::base, c),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredZoneAxisType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredAxisType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasuredZoneAxisType* MeasuredZoneAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredZoneAxisType (*this, f, c);
    }

    MeasuredZoneAxisType& MeasuredZoneAxisType::
    operator= (const MeasuredZoneAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredAxisType& > (*this) = x;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    MeasuredZoneAxisType::
    ~MeasuredZoneAxisType ()
    {
    }

    // BottomEnumType
    //

    BottomEnumType::
    BottomEnumType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_BottomEnumType_convert ();
    }

    BottomEnumType::
    BottomEnumType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_BottomEnumType_convert ();
    }

    BottomEnumType::
    BottomEnumType (const ::std::wstring& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_BottomEnumType_convert ();
    }

    BottomEnumType* BottomEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BottomEnumType (*this, f, c);
    }

    BottomEnumType::value BottomEnumType::
    _xsd_BottomEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_BottomEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_BottomEnumType_indexes_,
                        _xsd_BottomEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_BottomEnumType_indexes_ + 3 || _xsd_BottomEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const BottomEnumType::
    _xsd_BottomEnumType_literals_[3] =
    {
      L"BLIND",
      L"THROUGH",
      L"UNDEFINED"
    };

    const BottomEnumType::value BottomEnumType::
    _xsd_BottomEnumType_indexes_[3] =
    {
      ::xsd::qif30::BottomEnumType::BLIND,
      ::xsd::qif30::BottomEnumType::THROUGH,
      ::xsd::qif30::BottomEnumType::UNDEFINED
    };

    // BottomType
    //

    BottomType::
    BottomType ()
    : ::xml_schema::type (),
      BottomEnum_ (this),
      OtherBottom_ (this)
    {
    }

    BottomType::
    BottomType (const BottomType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BottomEnum_ (x.BottomEnum_, f, this),
      OtherBottom_ (x.OtherBottom_, f, this)
    {
    }

    BottomType::
    BottomType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BottomEnum_ (this),
      OtherBottom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BottomType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BottomEnum
        //
        if (n.name () == L"BottomEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BottomEnum_type > r (
            BottomEnum_traits::create (i, f, this));

          if (!this->BottomEnum_)
          {
            this->BottomEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherBottom
        //
        if (n.name () == L"OtherBottom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherBottom_type > r (
            OtherBottom_traits::create (i, f, this));

          if (!this->OtherBottom_)
          {
            this->OtherBottom_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    BottomType* BottomType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BottomType (*this, f, c);
    }

    BottomType& BottomType::
    operator= (const BottomType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BottomEnum_ = x.BottomEnum_;
        this->OtherBottom_ = x.OtherBottom_;
      }

      return *this;
    }

    BottomType::
    ~BottomType ()
    {
    }

    // BoundingBoxType
    //

    BoundingBoxType::
    BoundingBoxType ()
    : ::xml_schema::type (),
      Length_ (this),
      Width_ (this),
      Height_ (this)
    {
    }

    BoundingBoxType::
    BoundingBoxType (const Length_type& Length,
                     const Width_type& Width,
                     const Height_type& Height)
    : ::xml_schema::type (),
      Length_ (Length, this),
      Width_ (Width, this),
      Height_ (Height, this)
    {
    }

    BoundingBoxType::
    BoundingBoxType (::std::unique_ptr< Length_type > Length,
                     ::std::unique_ptr< Width_type > Width,
                     ::std::unique_ptr< Height_type > Height)
    : ::xml_schema::type (),
      Length_ (std::move (Length), this),
      Width_ (std::move (Width), this),
      Height_ (std::move (Height), this)
    {
    }

    BoundingBoxType::
    BoundingBoxType (const BoundingBoxType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Length_ (x.Length_, f, this),
      Width_ (x.Width_, f, this),
      Height_ (x.Height_, f, this)
    {
    }

    BoundingBoxType::
    BoundingBoxType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Length_ (this),
      Width_ (this),
      Height_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BoundingBoxType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // Height
        //
        if (n.name () == L"Height" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Height_type > r (
            Height_traits::create (i, f, this));

          if (!Height_.present ())
          {
            this->Height_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Width",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Height_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Height",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    BoundingBoxType* BoundingBoxType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BoundingBoxType (*this, f, c);
    }

    BoundingBoxType& BoundingBoxType::
    operator= (const BoundingBoxType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Length_ = x.Length_;
        this->Width_ = x.Width_;
        this->Height_ = x.Height_;
      }

      return *this;
    }

    BoundingBoxType::
    ~BoundingBoxType ()
    {
    }

    // ShapeClassEnumType
    //

    ShapeClassEnumType::
    ShapeClassEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ShapeClassEnumType_convert ();
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ShapeClassEnumType_convert ();
    }

    ShapeClassEnumType::
    ShapeClassEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ShapeClassEnumType_convert ();
    }

    ShapeClassEnumType* ShapeClassEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShapeClassEnumType (*this, f, c);
    }

    ShapeClassEnumType::value ShapeClassEnumType::
    _xsd_ShapeClassEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ShapeClassEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ShapeClassEnumType_indexes_,
                        _xsd_ShapeClassEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ShapeClassEnumType_indexes_ + 5 || _xsd_ShapeClassEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ShapeClassEnumType::
    _xsd_ShapeClassEnumType_literals_[5] =
    {
      L"GEAR",
      L"FREEFORM",
      L"PRISMATIC",
      L"ROTATIONAL",
      L"THINWALLED"
    };

    const ShapeClassEnumType::value ShapeClassEnumType::
    _xsd_ShapeClassEnumType_indexes_[5] =
    {
      ::xsd::qif30::ShapeClassEnumType::FREEFORM,
      ::xsd::qif30::ShapeClassEnumType::GEAR,
      ::xsd::qif30::ShapeClassEnumType::PRISMATIC,
      ::xsd::qif30::ShapeClassEnumType::ROTATIONAL,
      ::xsd::qif30::ShapeClassEnumType::THINWALLED
    };

    // ShapeClassType
    //

    ShapeClassType::
    ShapeClassType ()
    : ::xml_schema::type (),
      ShapeClassEnum_ (this),
      OtherShapeClass_ (this)
    {
    }

    ShapeClassType::
    ShapeClassType (const ShapeClassType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ShapeClassEnum_ (x.ShapeClassEnum_, f, this),
      OtherShapeClass_ (x.OtherShapeClass_, f, this)
    {
    }

    ShapeClassType::
    ShapeClassType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ShapeClassEnum_ (this),
      OtherShapeClass_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ShapeClassType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ShapeClassEnum
        //
        if (n.name () == L"ShapeClassEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShapeClassEnum_type > r (
            ShapeClassEnum_traits::create (i, f, this));

          if (!this->ShapeClassEnum_)
          {
            this->ShapeClassEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherShapeClass
        //
        if (n.name () == L"OtherShapeClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherShapeClass_type > r (
            OtherShapeClass_traits::create (i, f, this));

          if (!this->OtherShapeClass_)
          {
            this->OtherShapeClass_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ShapeClassType* ShapeClassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShapeClassType (*this, f, c);
    }

    ShapeClassType& ShapeClassType::
    operator= (const ShapeClassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ShapeClassEnum_ = x.ShapeClassEnum_;
        this->OtherShapeClass_ = x.OtherShapeClass_;
      }

      return *this;
    }

    ShapeClassType::
    ~ShapeClassType ()
    {
    }

    // ManufacturingMethodEnumType
    //

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ManufacturingMethodEnumType_convert ();
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ManufacturingMethodEnumType_convert ();
    }

    ManufacturingMethodEnumType::
    ManufacturingMethodEnumType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ManufacturingMethodEnumType_convert ();
    }

    ManufacturingMethodEnumType* ManufacturingMethodEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManufacturingMethodEnumType (*this, f, c);
    }

    ManufacturingMethodEnumType::value ManufacturingMethodEnumType::
    _xsd_ManufacturingMethodEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ManufacturingMethodEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ManufacturingMethodEnumType_indexes_,
                        _xsd_ManufacturingMethodEnumType_indexes_ + 8,
                        *this,
                        c));

      if (i == _xsd_ManufacturingMethodEnumType_indexes_ + 8 || _xsd_ManufacturingMethodEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ManufacturingMethodEnumType::
    _xsd_ManufacturingMethodEnumType_literals_[8] =
    {
      L"ADDITIVE",
      L"CASTING",
      L"COMPOSITE",
      L"FABRICATION",
      L"FORMING",
      L"JOINING",
      L"MACHINING",
      L"MOLDING"
    };

    const ManufacturingMethodEnumType::value ManufacturingMethodEnumType::
    _xsd_ManufacturingMethodEnumType_indexes_[8] =
    {
      ::xsd::qif30::ManufacturingMethodEnumType::ADDITIVE,
      ::xsd::qif30::ManufacturingMethodEnumType::CASTING,
      ::xsd::qif30::ManufacturingMethodEnumType::COMPOSITE,
      ::xsd::qif30::ManufacturingMethodEnumType::FABRICATION,
      ::xsd::qif30::ManufacturingMethodEnumType::FORMING,
      ::xsd::qif30::ManufacturingMethodEnumType::JOINING,
      ::xsd::qif30::ManufacturingMethodEnumType::MACHINING,
      ::xsd::qif30::ManufacturingMethodEnumType::MOLDING
    };

    // ManufacturingMethodType
    //

    ManufacturingMethodType::
    ManufacturingMethodType ()
    : ::xml_schema::type (),
      ManufacturingMethodEnum_ (this),
      OtherManufacturingMethod_ (this)
    {
    }

    ManufacturingMethodType::
    ManufacturingMethodType (const ManufacturingMethodType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ManufacturingMethodEnum_ (x.ManufacturingMethodEnum_, f, this),
      OtherManufacturingMethod_ (x.OtherManufacturingMethod_, f, this)
    {
    }

    ManufacturingMethodType::
    ManufacturingMethodType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ManufacturingMethodEnum_ (this),
      OtherManufacturingMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ManufacturingMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ManufacturingMethodEnum
        //
        if (n.name () == L"ManufacturingMethodEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ManufacturingMethodEnum_type > r (
            ManufacturingMethodEnum_traits::create (i, f, this));

          if (!this->ManufacturingMethodEnum_)
          {
            this->ManufacturingMethodEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherManufacturingMethod
        //
        if (n.name () == L"OtherManufacturingMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherManufacturingMethod_type > r (
            OtherManufacturingMethod_traits::create (i, f, this));

          if (!this->OtherManufacturingMethod_)
          {
            this->OtherManufacturingMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ManufacturingMethodType* ManufacturingMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManufacturingMethodType (*this, f, c);
    }

    ManufacturingMethodType& ManufacturingMethodType::
    operator= (const ManufacturingMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ManufacturingMethodEnum_ = x.ManufacturingMethodEnum_;
        this->OtherManufacturingMethod_ = x.OtherManufacturingMethod_;
      }

      return *this;
    }

    ManufacturingMethodType::
    ~ManufacturingMethodType ()
    {
    }

    // InternalExternalEnumType
    //

    InternalExternalEnumType::
    InternalExternalEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_InternalExternalEnumType_convert ();
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_InternalExternalEnumType_convert ();
    }

    InternalExternalEnumType::
    InternalExternalEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_InternalExternalEnumType_convert ();
    }

    InternalExternalEnumType* InternalExternalEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InternalExternalEnumType (*this, f, c);
    }

    InternalExternalEnumType::value InternalExternalEnumType::
    _xsd_InternalExternalEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_InternalExternalEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_InternalExternalEnumType_indexes_,
                        _xsd_InternalExternalEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_InternalExternalEnumType_indexes_ + 3 || _xsd_InternalExternalEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const InternalExternalEnumType::
    _xsd_InternalExternalEnumType_literals_[3] =
    {
      L"INTERNAL",
      L"EXTERNAL",
      L"NOT_APPLICABLE"
    };

    const InternalExternalEnumType::value InternalExternalEnumType::
    _xsd_InternalExternalEnumType_indexes_[3] =
    {
      ::xsd::qif30::InternalExternalEnumType::EXTERNAL,
      ::xsd::qif30::InternalExternalEnumType::INTERNAL,
      ::xsd::qif30::InternalExternalEnumType::NOT_APPLICABLE
    };

    // DimensionCountEnumType
    //

    DimensionCountEnumType::
    DimensionCountEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DimensionCountEnumType_convert ();
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DimensionCountEnumType_convert ();
    }

    DimensionCountEnumType::
    DimensionCountEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DimensionCountEnumType_convert ();
    }

    DimensionCountEnumType* DimensionCountEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DimensionCountEnumType (*this, f, c);
    }

    DimensionCountEnumType::value DimensionCountEnumType::
    _xsd_DimensionCountEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DimensionCountEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DimensionCountEnumType_indexes_,
                        _xsd_DimensionCountEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_DimensionCountEnumType_indexes_ + 2 || _xsd_DimensionCountEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DimensionCountEnumType::
    _xsd_DimensionCountEnumType_literals_[2] =
    {
      L"TWODIMENSIONAL",
      L"THREEDIMENSIONAL"
    };

    const DimensionCountEnumType::value DimensionCountEnumType::
    _xsd_DimensionCountEnumType_indexes_[2] =
    {
      ::xsd::qif30::DimensionCountEnumType::THREEDIMENSIONAL,
      ::xsd::qif30::DimensionCountEnumType::TWODIMENSIONAL
    };

    // ZoneOrientationEnumType
    //

    ZoneOrientationEnumType::
    ZoneOrientationEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ZoneOrientationEnumType_convert ();
    }

    ZoneOrientationEnumType::
    ZoneOrientationEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ZoneOrientationEnumType_convert ();
    }

    ZoneOrientationEnumType::
    ZoneOrientationEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ZoneOrientationEnumType_convert ();
    }

    ZoneOrientationEnumType* ZoneOrientationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZoneOrientationEnumType (*this, f, c);
    }

    ZoneOrientationEnumType::value ZoneOrientationEnumType::
    _xsd_ZoneOrientationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ZoneOrientationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ZoneOrientationEnumType_indexes_,
                        _xsd_ZoneOrientationEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_ZoneOrientationEnumType_indexes_ + 4 || _xsd_ZoneOrientationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ZoneOrientationEnumType::
    _xsd_ZoneOrientationEnumType_literals_[4] =
    {
      L"LENGTH",
      L"WIDTH",
      L"RADIAL",
      L"ANGULAR"
    };

    const ZoneOrientationEnumType::value ZoneOrientationEnumType::
    _xsd_ZoneOrientationEnumType_indexes_[4] =
    {
      ::xsd::qif30::ZoneOrientationEnumType::ANGULAR,
      ::xsd::qif30::ZoneOrientationEnumType::LENGTH,
      ::xsd::qif30::ZoneOrientationEnumType::RADIAL,
      ::xsd::qif30::ZoneOrientationEnumType::WIDTH
    };

    // CoordinateEnumType
    //

    CoordinateEnumType::
    CoordinateEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CoordinateEnumType_convert ();
    }

    CoordinateEnumType::
    CoordinateEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CoordinateEnumType_convert ();
    }

    CoordinateEnumType::
    CoordinateEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CoordinateEnumType_convert ();
    }

    CoordinateEnumType* CoordinateEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateEnumType (*this, f, c);
    }

    CoordinateEnumType::value CoordinateEnumType::
    _xsd_CoordinateEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_CoordinateEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CoordinateEnumType_indexes_,
                        _xsd_CoordinateEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_CoordinateEnumType_indexes_ + 6 || _xsd_CoordinateEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const CoordinateEnumType::
    _xsd_CoordinateEnumType_literals_[6] =
    {
      L"CARTESIAN_2D",
      L"POLAR_2D",
      L"CARTESIAN_3D",
      L"CYLINDRICAL_3D",
      L"SPHERICAL_3D",
      L"UNDEFINED"
    };

    const CoordinateEnumType::value CoordinateEnumType::
    _xsd_CoordinateEnumType_indexes_[6] =
    {
      ::xsd::qif30::CoordinateEnumType::CARTESIAN_2D,
      ::xsd::qif30::CoordinateEnumType::CARTESIAN_3D,
      ::xsd::qif30::CoordinateEnumType::CYLINDRICAL_3D,
      ::xsd::qif30::CoordinateEnumType::POLAR_2D,
      ::xsd::qif30::CoordinateEnumType::SPHERICAL_3D,
      ::xsd::qif30::CoordinateEnumType::UNDEFINED
    };

    // TypeOfCoordinatesType
    //

    TypeOfCoordinatesType::
    TypeOfCoordinatesType ()
    : ::xml_schema::type (),
      CoordinateEnum_ (this),
      OtherCoordinate_ (this)
    {
    }

    TypeOfCoordinatesType::
    TypeOfCoordinatesType (const TypeOfCoordinatesType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoordinateEnum_ (x.CoordinateEnum_, f, this),
      OtherCoordinate_ (x.OtherCoordinate_, f, this)
    {
    }

    TypeOfCoordinatesType::
    TypeOfCoordinatesType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoordinateEnum_ (this),
      OtherCoordinate_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TypeOfCoordinatesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoordinateEnum
        //
        if (n.name () == L"CoordinateEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateEnum_type > r (
            CoordinateEnum_traits::create (i, f, this));

          if (!this->CoordinateEnum_)
          {
            this->CoordinateEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherCoordinate
        //
        if (n.name () == L"OtherCoordinate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherCoordinate_type > r (
            OtherCoordinate_traits::create (i, f, this));

          if (!this->OtherCoordinate_)
          {
            this->OtherCoordinate_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TypeOfCoordinatesType* TypeOfCoordinatesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TypeOfCoordinatesType (*this, f, c);
    }

    TypeOfCoordinatesType& TypeOfCoordinatesType::
    operator= (const TypeOfCoordinatesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoordinateEnum_ = x.CoordinateEnum_;
        this->OtherCoordinate_ = x.OtherCoordinate_;
      }

      return *this;
    }

    TypeOfCoordinatesType::
    ~TypeOfCoordinatesType ()
    {
    }

    // RectangleType
    //

    RectangleType::
    RectangleType ()
    : ::xml_schema::type (),
      Length_ (this),
      CornerPoint_ (this),
      Width_ (this),
      WidthDirection_ (this),
      LengthDirection_ (this)
    {
    }

    RectangleType::
    RectangleType (const Length_type& Length,
                   const CornerPoint_type& CornerPoint,
                   const Width_type& Width,
                   const WidthDirection_type& WidthDirection,
                   const LengthDirection_type& LengthDirection)
    : ::xml_schema::type (),
      Length_ (Length, this),
      CornerPoint_ (CornerPoint, this),
      Width_ (Width, this),
      WidthDirection_ (WidthDirection, this),
      LengthDirection_ (LengthDirection, this)
    {
    }

    RectangleType::
    RectangleType (::std::unique_ptr< Length_type > Length,
                   ::std::unique_ptr< CornerPoint_type > CornerPoint,
                   ::std::unique_ptr< Width_type > Width,
                   ::std::unique_ptr< WidthDirection_type > WidthDirection,
                   ::std::unique_ptr< LengthDirection_type > LengthDirection)
    : ::xml_schema::type (),
      Length_ (std::move (Length), this),
      CornerPoint_ (std::move (CornerPoint), this),
      Width_ (std::move (Width), this),
      WidthDirection_ (std::move (WidthDirection), this),
      LengthDirection_ (std::move (LengthDirection), this)
    {
    }

    RectangleType::
    RectangleType (const RectangleType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Length_ (x.Length_, f, this),
      CornerPoint_ (x.CornerPoint_, f, this),
      Width_ (x.Width_, f, this),
      WidthDirection_ (x.WidthDirection_, f, this),
      LengthDirection_ (x.LengthDirection_, f, this)
    {
    }

    RectangleType::
    RectangleType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Length_ (this),
      CornerPoint_ (this),
      Width_ (this),
      WidthDirection_ (this),
      LengthDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RectangleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // CornerPoint
        //
        if (n.name () == L"CornerPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CornerPoint_type > r (
            CornerPoint_traits::create (i, f, this));

          if (!CornerPoint_.present ())
          {
            this->CornerPoint_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // WidthDirection
        //
        if (n.name () == L"WidthDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthDirection_type > r (
            WidthDirection_traits::create (i, f, this));

          if (!WidthDirection_.present ())
          {
            this->WidthDirection_.set (::std::move (r));
            continue;
          }
        }

        // LengthDirection
        //
        if (n.name () == L"LengthDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthDirection_type > r (
            LengthDirection_traits::create (i, f, this));

          if (!LengthDirection_.present ())
          {
            this->LengthDirection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CornerPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CornerPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Width",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!WidthDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"WidthDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!LengthDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LengthDirection",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    RectangleType* RectangleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RectangleType (*this, f, c);
    }

    RectangleType& RectangleType::
    operator= (const RectangleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Length_ = x.Length_;
        this->CornerPoint_ = x.CornerPoint_;
        this->Width_ = x.Width_;
        this->WidthDirection_ = x.WidthDirection_;
        this->LengthDirection_ = x.LengthDirection_;
      }

      return *this;
    }

    RectangleType::
    ~RectangleType ()
    {
    }

    // CircleType
    //

    CircleType::
    CircleType ()
    : ::xml_schema::type (),
      CenterPoint_ (this),
      Diameter_ (this),
      Normal_ (this)
    {
    }

    CircleType::
    CircleType (const CenterPoint_type& CenterPoint,
                const Diameter_type& Diameter,
                const Normal_type& Normal)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this),
      Normal_ (Normal, this)
    {
    }

    CircleType::
    CircleType (::std::unique_ptr< CenterPoint_type > CenterPoint,
                ::std::unique_ptr< Diameter_type > Diameter,
                ::std::unique_ptr< Normal_type > Normal)
    : ::xml_schema::type (),
      CenterPoint_ (std::move (CenterPoint), this),
      Diameter_ (std::move (Diameter), this),
      Normal_ (std::move (Normal), this)
    {
    }

    CircleType::
    CircleType (const CircleType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CenterPoint_ (x.CenterPoint_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    CircleType::
    CircleType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CenterPoint_ (this),
      Diameter_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterPoint
        //
        if (n.name () == L"CenterPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPoint_type > r (
            CenterPoint_traits::create (i, f, this));

          if (!CenterPoint_.present ())
          {
            this->CenterPoint_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleType* CircleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleType (*this, f, c);
    }

    CircleType& CircleType::
    operator= (const CircleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CenterPoint_ = x.CenterPoint_;
        this->Diameter_ = x.Diameter_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    CircleType::
    ~CircleType ()
    {
    }

    // CylinderType
    //

    CylinderType::
    CylinderType ()
    : ::xml_schema::type (),
      CenterPoint_ (this),
      Diameter_ (this),
      Axis_ (this),
      Length_ (this)
    {
    }

    CylinderType::
    CylinderType (const CenterPoint_type& CenterPoint,
                  const Diameter_type& Diameter,
                  const Axis_type& Axis,
                  const Length_type& Length)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this),
      Axis_ (Axis, this),
      Length_ (Length, this)
    {
    }

    CylinderType::
    CylinderType (::std::unique_ptr< CenterPoint_type > CenterPoint,
                  ::std::unique_ptr< Diameter_type > Diameter,
                  ::std::unique_ptr< Axis_type > Axis,
                  ::std::unique_ptr< Length_type > Length)
    : ::xml_schema::type (),
      CenterPoint_ (std::move (CenterPoint), this),
      Diameter_ (std::move (Diameter), this),
      Axis_ (std::move (Axis), this),
      Length_ (std::move (Length), this)
    {
    }

    CylinderType::
    CylinderType (const CylinderType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CenterPoint_ (x.CenterPoint_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Axis_ (x.Axis_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    CylinderType::
    CylinderType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CenterPoint_ (this),
      Diameter_ (this),
      Axis_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterPoint
        //
        if (n.name () == L"CenterPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPoint_type > r (
            CenterPoint_traits::create (i, f, this));

          if (!CenterPoint_.present ())
          {
            this->CenterPoint_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderType* CylinderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderType (*this, f, c);
    }

    CylinderType& CylinderType::
    operator= (const CylinderType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CenterPoint_ = x.CenterPoint_;
        this->Diameter_ = x.Diameter_;
        this->Axis_ = x.Axis_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    CylinderType::
    ~CylinderType ()
    {
    }

    // SphereType
    //

    SphereType::
    SphereType ()
    : ::xml_schema::type (),
      CenterPoint_ (this),
      Diameter_ (this)
    {
    }

    SphereType::
    SphereType (const CenterPoint_type& CenterPoint,
                const Diameter_type& Diameter)
    : ::xml_schema::type (),
      CenterPoint_ (CenterPoint, this),
      Diameter_ (Diameter, this)
    {
    }

    SphereType::
    SphereType (::std::unique_ptr< CenterPoint_type > CenterPoint,
                ::std::unique_ptr< Diameter_type > Diameter)
    : ::xml_schema::type (),
      CenterPoint_ (std::move (CenterPoint), this),
      Diameter_ (std::move (Diameter), this)
    {
    }

    SphereType::
    SphereType (const SphereType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CenterPoint_ (x.CenterPoint_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    SphereType::
    SphereType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CenterPoint_ (this),
      Diameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterPoint
        //
        if (n.name () == L"CenterPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPoint_type > r (
            CenterPoint_traits::create (i, f, this));

          if (!CenterPoint_.present ())
          {
            this->CenterPoint_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereType* SphereType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereType (*this, f, c);
    }

    SphereType& SphereType::
    operator= (const SphereType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CenterPoint_ = x.CenterPoint_;
        this->Diameter_ = x.Diameter_;
      }

      return *this;
    }

    SphereType::
    ~SphereType ()
    {
    }

    // PointAndVectorType
    //

    PointAndVectorType::
    PointAndVectorType ()
    : ::xml_schema::type (),
      StartPoint_ (this),
      Vector_ (this)
    {
    }

    PointAndVectorType::
    PointAndVectorType (const StartPoint_type& StartPoint,
                        const Vector_type& Vector)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, this),
      Vector_ (Vector, this)
    {
    }

    PointAndVectorType::
    PointAndVectorType (::std::unique_ptr< StartPoint_type > StartPoint,
                        ::std::unique_ptr< Vector_type > Vector)
    : ::xml_schema::type (),
      StartPoint_ (std::move (StartPoint), this),
      Vector_ (std::move (Vector), this)
    {
    }

    PointAndVectorType::
    PointAndVectorType (const PointAndVectorType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    PointAndVectorType::
    PointAndVectorType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (this),
      Vector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointAndVectorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StartPoint
        //
        if (n.name () == L"StartPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (::std::move (r));
            continue;
          }
        }

        // Vector
        //
        if (n.name () == L"Vector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!Vector_.present ())
          {
            this->Vector_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StartPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Vector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Vector",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointAndVectorType* PointAndVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointAndVectorType (*this, f, c);
    }

    PointAndVectorType& PointAndVectorType::
    operator= (const PointAndVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StartPoint_ = x.StartPoint_;
        this->Vector_ = x.Vector_;
      }

      return *this;
    }

    PointAndVectorType::
    ~PointAndVectorType ()
    {
    }

    // MeasuredPointAndVectorType
    //

    MeasuredPointAndVectorType::
    MeasuredPointAndVectorType ()
    : ::xml_schema::type (),
      StartPoint_ (this),
      Vector_ (this)
    {
    }

    MeasuredPointAndVectorType::
    MeasuredPointAndVectorType (const StartPoint_type& StartPoint,
                                const Vector_type& Vector)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, this),
      Vector_ (Vector, this)
    {
    }

    MeasuredPointAndVectorType::
    MeasuredPointAndVectorType (::std::unique_ptr< StartPoint_type > StartPoint,
                                ::std::unique_ptr< Vector_type > Vector)
    : ::xml_schema::type (),
      StartPoint_ (std::move (StartPoint), this),
      Vector_ (std::move (Vector), this)
    {
    }

    MeasuredPointAndVectorType::
    MeasuredPointAndVectorType (const MeasuredPointAndVectorType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    MeasuredPointAndVectorType::
    MeasuredPointAndVectorType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (this),
      Vector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredPointAndVectorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StartPoint
        //
        if (n.name () == L"StartPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (::std::move (r));
            continue;
          }
        }

        // Vector
        //
        if (n.name () == L"Vector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!Vector_.present ())
          {
            this->Vector_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StartPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Vector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Vector",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasuredPointAndVectorType* MeasuredPointAndVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredPointAndVectorType (*this, f, c);
    }

    MeasuredPointAndVectorType& MeasuredPointAndVectorType::
    operator= (const MeasuredPointAndVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StartPoint_ = x.StartPoint_;
        this->Vector_ = x.Vector_;
      }

      return *this;
    }

    MeasuredPointAndVectorType::
    ~MeasuredPointAndVectorType ()
    {
    }

    // SlotEndEnumType
    //

    SlotEndEnumType::
    SlotEndEnumType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SlotEndEnumType_convert ();
    }

    SlotEndEnumType::
    SlotEndEnumType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SlotEndEnumType_convert ();
    }

    SlotEndEnumType::
    SlotEndEnumType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SlotEndEnumType_convert ();
    }

    SlotEndEnumType* SlotEndEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SlotEndEnumType (*this, f, c);
    }

    SlotEndEnumType::value SlotEndEnumType::
    _xsd_SlotEndEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SlotEndEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SlotEndEnumType_indexes_,
                        _xsd_SlotEndEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_SlotEndEnumType_indexes_ + 4 || _xsd_SlotEndEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SlotEndEnumType::
    _xsd_SlotEndEnumType_literals_[4] =
    {
      L"ROUND",
      L"FLAT",
      L"OPEN",
      L"UNDEFINED"
    };

    const SlotEndEnumType::value SlotEndEnumType::
    _xsd_SlotEndEnumType_indexes_[4] =
    {
      ::xsd::qif30::SlotEndEnumType::FLAT,
      ::xsd::qif30::SlotEndEnumType::OPEN,
      ::xsd::qif30::SlotEndEnumType::ROUND,
      ::xsd::qif30::SlotEndEnumType::UNDEFINED
    };

    // EndRadiusType
    //

    EndRadiusType::
    EndRadiusType ()
    : ::xml_schema::type (),
      EndRadius_ (this),
      Expanded_ (this)
    {
    }

    EndRadiusType::
    EndRadiusType (const EndRadius_type& EndRadius)
    : ::xml_schema::type (),
      EndRadius_ (EndRadius, this),
      Expanded_ (this)
    {
    }

    EndRadiusType::
    EndRadiusType (::std::unique_ptr< EndRadius_type > EndRadius)
    : ::xml_schema::type (),
      EndRadius_ (std::move (EndRadius), this),
      Expanded_ (this)
    {
    }

    EndRadiusType::
    EndRadiusType (const EndRadiusType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EndRadius_ (x.EndRadius_, f, this),
      Expanded_ (x.Expanded_, f, this)
    {
    }

    EndRadiusType::
    EndRadiusType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EndRadius_ (this),
      Expanded_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EndRadiusType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EndRadius
        //
        if (n.name () == L"EndRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius_type > r (
            EndRadius_traits::create (i, f, this));

          if (!EndRadius_.present ())
          {
            this->EndRadius_.set (::std::move (r));
            continue;
          }
        }

        // Expanded
        //
        if (n.name () == L"Expanded" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Expanded_)
          {
            this->Expanded_.set (Expanded_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EndRadiusType* EndRadiusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EndRadiusType (*this, f, c);
    }

    EndRadiusType& EndRadiusType::
    operator= (const EndRadiusType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EndRadius_ = x.EndRadius_;
        this->Expanded_ = x.Expanded_;
      }

      return *this;
    }

    EndRadiusType::
    ~EndRadiusType ()
    {
    }

    // MeasuredEndRadiusType
    //

    MeasuredEndRadiusType::
    MeasuredEndRadiusType ()
    : ::xml_schema::type (),
      EndRadius_ (this),
      Expanded_ (this)
    {
    }

    MeasuredEndRadiusType::
    MeasuredEndRadiusType (const EndRadius_type& EndRadius)
    : ::xml_schema::type (),
      EndRadius_ (EndRadius, this),
      Expanded_ (this)
    {
    }

    MeasuredEndRadiusType::
    MeasuredEndRadiusType (::std::unique_ptr< EndRadius_type > EndRadius)
    : ::xml_schema::type (),
      EndRadius_ (std::move (EndRadius), this),
      Expanded_ (this)
    {
    }

    MeasuredEndRadiusType::
    MeasuredEndRadiusType (const MeasuredEndRadiusType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EndRadius_ (x.EndRadius_, f, this),
      Expanded_ (x.Expanded_, f, this)
    {
    }

    MeasuredEndRadiusType::
    MeasuredEndRadiusType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EndRadius_ (this),
      Expanded_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredEndRadiusType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EndRadius
        //
        if (n.name () == L"EndRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius_type > r (
            EndRadius_traits::create (i, f, this));

          if (!EndRadius_.present ())
          {
            this->EndRadius_.set (::std::move (r));
            continue;
          }
        }

        // Expanded
        //
        if (n.name () == L"Expanded" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Expanded_)
          {
            this->Expanded_.set (Expanded_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeasuredEndRadiusType* MeasuredEndRadiusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredEndRadiusType (*this, f, c);
    }

    MeasuredEndRadiusType& MeasuredEndRadiusType::
    operator= (const MeasuredEndRadiusType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EndRadius_ = x.EndRadius_;
        this->Expanded_ = x.Expanded_;
      }

      return *this;
    }

    MeasuredEndRadiusType::
    ~MeasuredEndRadiusType ()
    {
    }

    // SlotEndType
    //

    SlotEndType::
    SlotEndType ()
    : ::xml_schema::type (),
      SlotEndEnum_ (this),
      OtherSlotEnd_ (this)
    {
    }

    SlotEndType::
    SlotEndType (const SlotEndType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SlotEndEnum_ (x.SlotEndEnum_, f, this),
      OtherSlotEnd_ (x.OtherSlotEnd_, f, this)
    {
    }

    SlotEndType::
    SlotEndType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SlotEndEnum_ (this),
      OtherSlotEnd_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SlotEndType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SlotEndEnum
        //
        if (n.name () == L"SlotEndEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SlotEndEnum_type > r (
            SlotEndEnum_traits::create (i, f, this));

          if (!this->SlotEndEnum_)
          {
            this->SlotEndEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherSlotEnd
        //
        if (n.name () == L"OtherSlotEnd" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherSlotEnd_type > r (
            OtherSlotEnd_traits::create (i, f, this));

          if (!this->OtherSlotEnd_)
          {
            this->OtherSlotEnd_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SlotEndType* SlotEndType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SlotEndType (*this, f, c);
    }

    SlotEndType& SlotEndType::
    operator= (const SlotEndType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SlotEndEnum_ = x.SlotEndEnum_;
        this->OtherSlotEnd_ = x.OtherSlotEnd_;
      }

      return *this;
    }

    SlotEndType::
    ~SlotEndType ()
    {
    }

    // ThreadSeriesEnumType
    //

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ThreadSeriesEnumType_convert ();
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ThreadSeriesEnumType_convert ();
    }

    ThreadSeriesEnumType::
    ThreadSeriesEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ThreadSeriesEnumType_convert ();
    }

    ThreadSeriesEnumType* ThreadSeriesEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSeriesEnumType (*this, f, c);
    }

    ThreadSeriesEnumType::value ThreadSeriesEnumType::
    _xsd_ThreadSeriesEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ThreadSeriesEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ThreadSeriesEnumType_indexes_,
                        _xsd_ThreadSeriesEnumType_indexes_ + 56,
                        *this,
                        c));

      if (i == _xsd_ThreadSeriesEnumType_indexes_ + 56 || _xsd_ThreadSeriesEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ThreadSeriesEnumType::
    _xsd_ThreadSeriesEnumType_literals_[56] =
    {
      L"ACME",
      L"ACME_C",
      L"ACME_G",
      L"AMO",
      L"ANPT",
      L"BUTT",
      L"PUSH_BUTT",
      L"F_PTF",
      L"M",
      L"MJ",
      L"MJS",
      L"NC5_HF",
      L"NC5_CSF",
      L"NC5_ONF",
      L"NC5_IF",
      L"NC5_INF",
      L"NGO",
      L"NGS",
      L"NGT",
      L"NH",
      L"NHR",
      L"NPSC",
      L"NPSF",
      L"NPSH",
      L"NPSI",
      L"NPSL",
      L"NPSM",
      L"NPT",
      L"NPTF",
      L"PTF_SAE_SHORT",
      L"PTF_SPL_SHORT",
      L"PTF_SPL_EXTRA_SHORT",
      L"SGT",
      L"SPL_PTF",
      L"STUB_ACME",
      L"UN",
      L"UNC",
      L"UNF",
      L"UNEF",
      L"UNJ",
      L"UNJC",
      L"UNJF",
      L"UNJEF",
      L"UNR",
      L"UNRC",
      L"UNRF",
      L"UNREF",
      L"UNM",
      L"UNS",
      L"G",
      L"R",
      L"RC",
      L"RP",
      L"S",
      L"TR",
      L"UNDEFINED"
    };

    const ThreadSeriesEnumType::value ThreadSeriesEnumType::
    _xsd_ThreadSeriesEnumType_indexes_[56] =
    {
      ::xsd::qif30::ThreadSeriesEnumType::ACME,
      ::xsd::qif30::ThreadSeriesEnumType::ACME_C,
      ::xsd::qif30::ThreadSeriesEnumType::ACME_G,
      ::xsd::qif30::ThreadSeriesEnumType::AMO,
      ::xsd::qif30::ThreadSeriesEnumType::ANPT,
      ::xsd::qif30::ThreadSeriesEnumType::BUTT,
      ::xsd::qif30::ThreadSeriesEnumType::F_PTF,
      ::xsd::qif30::ThreadSeriesEnumType::G,
      ::xsd::qif30::ThreadSeriesEnumType::M,
      ::xsd::qif30::ThreadSeriesEnumType::MJ,
      ::xsd::qif30::ThreadSeriesEnumType::MJS,
      ::xsd::qif30::ThreadSeriesEnumType::NC5_CSF,
      ::xsd::qif30::ThreadSeriesEnumType::NC5_HF,
      ::xsd::qif30::ThreadSeriesEnumType::NC5_IF,
      ::xsd::qif30::ThreadSeriesEnumType::NC5_INF,
      ::xsd::qif30::ThreadSeriesEnumType::NC5_ONF,
      ::xsd::qif30::ThreadSeriesEnumType::NGO,
      ::xsd::qif30::ThreadSeriesEnumType::NGS,
      ::xsd::qif30::ThreadSeriesEnumType::NGT,
      ::xsd::qif30::ThreadSeriesEnumType::NH,
      ::xsd::qif30::ThreadSeriesEnumType::NHR,
      ::xsd::qif30::ThreadSeriesEnumType::NPSC,
      ::xsd::qif30::ThreadSeriesEnumType::NPSF,
      ::xsd::qif30::ThreadSeriesEnumType::NPSH,
      ::xsd::qif30::ThreadSeriesEnumType::NPSI,
      ::xsd::qif30::ThreadSeriesEnumType::NPSL,
      ::xsd::qif30::ThreadSeriesEnumType::NPSM,
      ::xsd::qif30::ThreadSeriesEnumType::NPT,
      ::xsd::qif30::ThreadSeriesEnumType::NPTF,
      ::xsd::qif30::ThreadSeriesEnumType::PTF_SAE_SHORT,
      ::xsd::qif30::ThreadSeriesEnumType::PTF_SPL_EXTRA_SHORT,
      ::xsd::qif30::ThreadSeriesEnumType::PTF_SPL_SHORT,
      ::xsd::qif30::ThreadSeriesEnumType::PUSH_BUTT,
      ::xsd::qif30::ThreadSeriesEnumType::R,
      ::xsd::qif30::ThreadSeriesEnumType::RC,
      ::xsd::qif30::ThreadSeriesEnumType::RP,
      ::xsd::qif30::ThreadSeriesEnumType::S,
      ::xsd::qif30::ThreadSeriesEnumType::SGT,
      ::xsd::qif30::ThreadSeriesEnumType::SPL_PTF,
      ::xsd::qif30::ThreadSeriesEnumType::STUB_ACME,
      ::xsd::qif30::ThreadSeriesEnumType::TR,
      ::xsd::qif30::ThreadSeriesEnumType::UN,
      ::xsd::qif30::ThreadSeriesEnumType::UNC,
      ::xsd::qif30::ThreadSeriesEnumType::UNDEFINED,
      ::xsd::qif30::ThreadSeriesEnumType::UNEF,
      ::xsd::qif30::ThreadSeriesEnumType::UNF,
      ::xsd::qif30::ThreadSeriesEnumType::UNJ,
      ::xsd::qif30::ThreadSeriesEnumType::UNJC,
      ::xsd::qif30::ThreadSeriesEnumType::UNJEF,
      ::xsd::qif30::ThreadSeriesEnumType::UNJF,
      ::xsd::qif30::ThreadSeriesEnumType::UNM,
      ::xsd::qif30::ThreadSeriesEnumType::UNR,
      ::xsd::qif30::ThreadSeriesEnumType::UNRC,
      ::xsd::qif30::ThreadSeriesEnumType::UNREF,
      ::xsd::qif30::ThreadSeriesEnumType::UNRF,
      ::xsd::qif30::ThreadSeriesEnumType::UNS
    };

    // ThreadSeriesType
    //

    ThreadSeriesType::
    ThreadSeriesType ()
    : ::xml_schema::type (),
      ThreadSeriesEnum_ (this),
      OtherThreadSeries_ (this)
    {
    }

    ThreadSeriesType::
    ThreadSeriesType (const ThreadSeriesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ThreadSeriesEnum_ (x.ThreadSeriesEnum_, f, this),
      OtherThreadSeries_ (x.OtherThreadSeries_, f, this)
    {
    }

    ThreadSeriesType::
    ThreadSeriesType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ThreadSeriesEnum_ (this),
      OtherThreadSeries_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadSeriesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThreadSeriesEnum
        //
        if (n.name () == L"ThreadSeriesEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadSeriesEnum_type > r (
            ThreadSeriesEnum_traits::create (i, f, this));

          if (!this->ThreadSeriesEnum_)
          {
            this->ThreadSeriesEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherThreadSeries
        //
        if (n.name () == L"OtherThreadSeries" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherThreadSeries_type > r (
            OtherThreadSeries_traits::create (i, f, this));

          if (!this->OtherThreadSeries_)
          {
            this->OtherThreadSeries_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadSeriesType* ThreadSeriesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSeriesType (*this, f, c);
    }

    ThreadSeriesType& ThreadSeriesType::
    operator= (const ThreadSeriesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ThreadSeriesEnum_ = x.ThreadSeriesEnum_;
        this->OtherThreadSeries_ = x.OtherThreadSeries_;
      }

      return *this;
    }

    ThreadSeriesType::
    ~ThreadSeriesType ()
    {
    }

    // ThreadClassType
    //

    ThreadClassType::
    ThreadClassType ()
    : ::xml_schema::type (),
      ThreadClassEnum_ (this),
      OtherThreadClass_ (this)
    {
    }

    ThreadClassType::
    ThreadClassType (const ThreadClassType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ThreadClassEnum_ (x.ThreadClassEnum_, f, this),
      OtherThreadClass_ (x.OtherThreadClass_, f, this)
    {
    }

    ThreadClassType::
    ThreadClassType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ThreadClassEnum_ (this),
      OtherThreadClass_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadClassType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ThreadClassEnum
        //
        if (n.name () == L"ThreadClassEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadClassEnum_type > r (
            ThreadClassEnum_traits::create (i, f, this));

          if (!this->ThreadClassEnum_)
          {
            this->ThreadClassEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherThreadClass
        //
        if (n.name () == L"OtherThreadClass" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherThreadClass_type > r (
            OtherThreadClass_traits::create (i, f, this));

          if (!this->OtherThreadClass_)
          {
            this->OtherThreadClass_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadClassType* ThreadClassType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadClassType (*this, f, c);
    }

    ThreadClassType& ThreadClassType::
    operator= (const ThreadClassType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ThreadClassEnum_ = x.ThreadClassEnum_;
        this->OtherThreadClass_ = x.OtherThreadClass_;
      }

      return *this;
    }

    ThreadClassType::
    ~ThreadClassType ()
    {
    }

    // ThreadClassEnumType
    //

    ThreadClassEnumType::
    ThreadClassEnumType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ThreadClassEnumType_convert ();
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ThreadClassEnumType_convert ();
    }

    ThreadClassEnumType::
    ThreadClassEnumType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ThreadClassEnumType_convert ();
    }

    ThreadClassEnumType* ThreadClassEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadClassEnumType (*this, f, c);
    }

    ThreadClassEnumType::value ThreadClassEnumType::
    _xsd_ThreadClassEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ThreadClassEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ThreadClassEnumType_indexes_,
                        _xsd_ThreadClassEnumType_indexes_ + 50,
                        *this,
                        c));

      if (i == _xsd_ThreadClassEnumType_indexes_ + 50 || _xsd_ThreadClassEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ThreadClassEnumType::
    _xsd_ThreadClassEnumType_literals_[50] =
    {
      L"1A",
      L"1B",
      L"2A",
      L"2AG",
      L"2B",
      L"3A",
      L"3B",
      L"EXT_3E",
      L"EXT_3F",
      L"EXT_3G",
      L"EXT_3H",
      L"EXT_4E",
      L"EXT_4F",
      L"EXT_4G",
      L"EXT_4H",
      L"4G",
      L"4H",
      L"EXT_5E",
      L"EXT_5F",
      L"EXT_5G",
      L"EXT_5H",
      L"5G",
      L"5H",
      L"EXT_6E",
      L"EXT_6F",
      L"EXT_6G",
      L"EXT_6H",
      L"6G",
      L"6H",
      L"EXT_7E",
      L"EXT_7F",
      L"EXT_7G",
      L"EXT_7H",
      L"7G",
      L"7H",
      L"EXT_8E",
      L"EXT_8F",
      L"EXT_8G",
      L"EXT_8H",
      L"8G",
      L"8H",
      L"EXT_9E",
      L"EXT_9F",
      L"EXT_9G",
      L"EXT_9H",
      L"INT",
      L"EXT",
      L"SE",
      L"G",
      L"UNDEFINED"
    };

    const ThreadClassEnumType::value ThreadClassEnumType::
    _xsd_ThreadClassEnumType_indexes_[50] =
    {
      ::xsd::qif30::ThreadClassEnumType::cxx_1A,
      ::xsd::qif30::ThreadClassEnumType::cxx_1B,
      ::xsd::qif30::ThreadClassEnumType::cxx_2A,
      ::xsd::qif30::ThreadClassEnumType::cxx_2AG,
      ::xsd::qif30::ThreadClassEnumType::cxx_2B,
      ::xsd::qif30::ThreadClassEnumType::cxx_3A,
      ::xsd::qif30::ThreadClassEnumType::cxx_3B,
      ::xsd::qif30::ThreadClassEnumType::cxx_4G,
      ::xsd::qif30::ThreadClassEnumType::cxx_4H,
      ::xsd::qif30::ThreadClassEnumType::cxx_5G,
      ::xsd::qif30::ThreadClassEnumType::cxx_5H,
      ::xsd::qif30::ThreadClassEnumType::cxx_6G,
      ::xsd::qif30::ThreadClassEnumType::cxx_6H,
      ::xsd::qif30::ThreadClassEnumType::cxx_7G,
      ::xsd::qif30::ThreadClassEnumType::cxx_7H,
      ::xsd::qif30::ThreadClassEnumType::cxx_8G,
      ::xsd::qif30::ThreadClassEnumType::cxx_8H,
      ::xsd::qif30::ThreadClassEnumType::EXT,
      ::xsd::qif30::ThreadClassEnumType::EXT_3E,
      ::xsd::qif30::ThreadClassEnumType::EXT_3F,
      ::xsd::qif30::ThreadClassEnumType::EXT_3G,
      ::xsd::qif30::ThreadClassEnumType::EXT_3H,
      ::xsd::qif30::ThreadClassEnumType::EXT_4E,
      ::xsd::qif30::ThreadClassEnumType::EXT_4F,
      ::xsd::qif30::ThreadClassEnumType::EXT_4G,
      ::xsd::qif30::ThreadClassEnumType::EXT_4H,
      ::xsd::qif30::ThreadClassEnumType::EXT_5E,
      ::xsd::qif30::ThreadClassEnumType::EXT_5F,
      ::xsd::qif30::ThreadClassEnumType::EXT_5G,
      ::xsd::qif30::ThreadClassEnumType::EXT_5H,
      ::xsd::qif30::ThreadClassEnumType::EXT_6E,
      ::xsd::qif30::ThreadClassEnumType::EXT_6F,
      ::xsd::qif30::ThreadClassEnumType::EXT_6G,
      ::xsd::qif30::ThreadClassEnumType::EXT_6H,
      ::xsd::qif30::ThreadClassEnumType::EXT_7E,
      ::xsd::qif30::ThreadClassEnumType::EXT_7F,
      ::xsd::qif30::ThreadClassEnumType::EXT_7G,
      ::xsd::qif30::ThreadClassEnumType::EXT_7H,
      ::xsd::qif30::ThreadClassEnumType::EXT_8E,
      ::xsd::qif30::ThreadClassEnumType::EXT_8F,
      ::xsd::qif30::ThreadClassEnumType::EXT_8G,
      ::xsd::qif30::ThreadClassEnumType::EXT_8H,
      ::xsd::qif30::ThreadClassEnumType::EXT_9E,
      ::xsd::qif30::ThreadClassEnumType::EXT_9F,
      ::xsd::qif30::ThreadClassEnumType::EXT_9G,
      ::xsd::qif30::ThreadClassEnumType::EXT_9H,
      ::xsd::qif30::ThreadClassEnumType::G,
      ::xsd::qif30::ThreadClassEnumType::INT,
      ::xsd::qif30::ThreadClassEnumType::SE,
      ::xsd::qif30::ThreadClassEnumType::UNDEFINED
    };

    // SecurityClassificationEnumType
    //

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SecurityClassificationEnumType_convert ();
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SecurityClassificationEnumType_convert ();
    }

    SecurityClassificationEnumType::
    SecurityClassificationEnumType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SecurityClassificationEnumType_convert ();
    }

    SecurityClassificationEnumType* SecurityClassificationEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SecurityClassificationEnumType (*this, f, c);
    }

    SecurityClassificationEnumType::value SecurityClassificationEnumType::
    _xsd_SecurityClassificationEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SecurityClassificationEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SecurityClassificationEnumType_indexes_,
                        _xsd_SecurityClassificationEnumType_indexes_ + 32,
                        *this,
                        c));

      if (i == _xsd_SecurityClassificationEnumType_indexes_ + 32 || _xsd_SecurityClassificationEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SecurityClassificationEnumType::
    _xsd_SecurityClassificationEnumType_literals_[32] =
    {
      L"NONE",
      L"UNCLASSIFIED",
      L"RESTRICTED",
      L"EU_RESTRICTED",
      L"WEU_RESTRICTED",
      L"FOR_OFFICIAL_USE_ONLY",
      L"PROTECTED",
      L"PROTECTED_A",
      L"PROTECTED_B",
      L"PROTECTED_C",
      L"CONFIDENTIAL",
      L"EU_CONFIDENTIAL",
      L"WEU_CONFIDENTIAL",
      L"SECRET",
      L"SECRET_NATIONAL_SECURITY_INFORMATION",
      L"SECRET_FORMERLY_RESTRICTED_DATA",
      L"SECRET_RESTRICTED_DATA",
      L"SECRET",
      L"EU_SECRET",
      L"WEU_SECRET",
      L"TOP_SECRET_NATIONAL_SECURITY_INFORMATION",
      L"TOP_SECRET_FORMERLY_RESTRICTED_DATA",
      L"TOP_SECRET_RESTRICTED_DATA",
      L"EU_TOP_SECRET",
      L"FOCAL_TOP_SECRET",
      L"COMPANY_CONFIDENTIAL",
      L"OFFICIAL_USE_ONLY",
      L"TRADE_SECRET",
      L"TRADEMARK",
      L"REGISTERED_TRADEMARK",
      L"PATENT",
      L"UNDEFINED"
    };

    const SecurityClassificationEnumType::value SecurityClassificationEnumType::
    _xsd_SecurityClassificationEnumType_indexes_[32] =
    {
      ::xsd::qif30::SecurityClassificationEnumType::COMPANY_CONFIDENTIAL,
      ::xsd::qif30::SecurityClassificationEnumType::CONFIDENTIAL,
      ::xsd::qif30::SecurityClassificationEnumType::EU_CONFIDENTIAL,
      ::xsd::qif30::SecurityClassificationEnumType::EU_RESTRICTED,
      ::xsd::qif30::SecurityClassificationEnumType::EU_SECRET,
      ::xsd::qif30::SecurityClassificationEnumType::EU_TOP_SECRET,
      ::xsd::qif30::SecurityClassificationEnumType::FOCAL_TOP_SECRET,
      ::xsd::qif30::SecurityClassificationEnumType::FOR_OFFICIAL_USE_ONLY,
      ::xsd::qif30::SecurityClassificationEnumType::NONE,
      ::xsd::qif30::SecurityClassificationEnumType::OFFICIAL_USE_ONLY,
      ::xsd::qif30::SecurityClassificationEnumType::PATENT,
      ::xsd::qif30::SecurityClassificationEnumType::PROTECTED,
      ::xsd::qif30::SecurityClassificationEnumType::PROTECTED_A,
      ::xsd::qif30::SecurityClassificationEnumType::PROTECTED_B,
      ::xsd::qif30::SecurityClassificationEnumType::PROTECTED_C,
      ::xsd::qif30::SecurityClassificationEnumType::REGISTERED_TRADEMARK,
      ::xsd::qif30::SecurityClassificationEnumType::RESTRICTED,
      ::xsd::qif30::SecurityClassificationEnumType::SECRET,
      ::xsd::qif30::SecurityClassificationEnumType::SECRET1,
      ::xsd::qif30::SecurityClassificationEnumType::SECRET_FORMERLY_RESTRICTED_DATA,
      ::xsd::qif30::SecurityClassificationEnumType::SECRET_NATIONAL_SECURITY_INFORMATION,
      ::xsd::qif30::SecurityClassificationEnumType::SECRET_RESTRICTED_DATA,
      ::xsd::qif30::SecurityClassificationEnumType::TOP_SECRET_FORMERLY_RESTRICTED_DATA,
      ::xsd::qif30::SecurityClassificationEnumType::TOP_SECRET_NATIONAL_SECURITY_INFORMATION,
      ::xsd::qif30::SecurityClassificationEnumType::TOP_SECRET_RESTRICTED_DATA,
      ::xsd::qif30::SecurityClassificationEnumType::TRADEMARK,
      ::xsd::qif30::SecurityClassificationEnumType::TRADE_SECRET,
      ::xsd::qif30::SecurityClassificationEnumType::UNCLASSIFIED,
      ::xsd::qif30::SecurityClassificationEnumType::UNDEFINED,
      ::xsd::qif30::SecurityClassificationEnumType::WEU_CONFIDENTIAL,
      ::xsd::qif30::SecurityClassificationEnumType::WEU_RESTRICTED,
      ::xsd::qif30::SecurityClassificationEnumType::WEU_SECRET
    };

    // SecurityClassificationType
    //

    SecurityClassificationType::
    SecurityClassificationType ()
    : ::xml_schema::type (),
      SecurityClassificationEnum_ (this),
      OtherSecurityClassification_ (this)
    {
    }

    SecurityClassificationType::
    SecurityClassificationType (const SecurityClassificationType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SecurityClassificationEnum_ (x.SecurityClassificationEnum_, f, this),
      OtherSecurityClassification_ (x.OtherSecurityClassification_, f, this)
    {
    }

    SecurityClassificationType::
    SecurityClassificationType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SecurityClassificationEnum_ (this),
      OtherSecurityClassification_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SecurityClassificationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SecurityClassificationEnum
        //
        if (n.name () == L"SecurityClassificationEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecurityClassificationEnum_type > r (
            SecurityClassificationEnum_traits::create (i, f, this));

          if (!this->SecurityClassificationEnum_)
          {
            this->SecurityClassificationEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherSecurityClassification
        //
        if (n.name () == L"OtherSecurityClassification" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherSecurityClassification_type > r (
            OtherSecurityClassification_traits::create (i, f, this));

          if (!this->OtherSecurityClassification_)
          {
            this->OtherSecurityClassification_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SecurityClassificationType* SecurityClassificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SecurityClassificationType (*this, f, c);
    }

    SecurityClassificationType& SecurityClassificationType::
    operator= (const SecurityClassificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SecurityClassificationEnum_ = x.SecurityClassificationEnum_;
        this->OtherSecurityClassification_ = x.OtherSecurityClassification_;
      }

      return *this;
    }

    SecurityClassificationType::
    ~SecurityClassificationType ()
    {
    }

    // DigitalModelFormatEnumType
    //

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DigitalModelFormatEnumType_convert ();
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DigitalModelFormatEnumType_convert ();
    }

    DigitalModelFormatEnumType::
    DigitalModelFormatEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DigitalModelFormatEnumType_convert ();
    }

    DigitalModelFormatEnumType* DigitalModelFormatEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigitalModelFormatEnumType (*this, f, c);
    }

    DigitalModelFormatEnumType::value DigitalModelFormatEnumType::
    _xsd_DigitalModelFormatEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DigitalModelFormatEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DigitalModelFormatEnumType_indexes_,
                        _xsd_DigitalModelFormatEnumType_indexes_ + 15,
                        *this,
                        c));

      if (i == _xsd_DigitalModelFormatEnumType_indexes_ + 15 || _xsd_DigitalModelFormatEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DigitalModelFormatEnumType::
    _xsd_DigitalModelFormatEnumType_literals_[15] =
    {
      L"STEPAP203",
      L"STEPAP203E2",
      L"STEPAP214",
      L"STEPAP242",
      L"JTOPEN",
      L"RPC",
      L"PDPMI",
      L"ACIS",
      L"PARASOLID",
      L"AUTODESK",
      L"PTC",
      L"NX",
      L"SOLIDWORKS",
      L"CATIA",
      L"NOTDEFINED"
    };

    const DigitalModelFormatEnumType::value DigitalModelFormatEnumType::
    _xsd_DigitalModelFormatEnumType_indexes_[15] =
    {
      ::xsd::qif30::DigitalModelFormatEnumType::ACIS,
      ::xsd::qif30::DigitalModelFormatEnumType::AUTODESK,
      ::xsd::qif30::DigitalModelFormatEnumType::CATIA,
      ::xsd::qif30::DigitalModelFormatEnumType::JTOPEN,
      ::xsd::qif30::DigitalModelFormatEnumType::NOTDEFINED,
      ::xsd::qif30::DigitalModelFormatEnumType::NX,
      ::xsd::qif30::DigitalModelFormatEnumType::PARASOLID,
      ::xsd::qif30::DigitalModelFormatEnumType::PDPMI,
      ::xsd::qif30::DigitalModelFormatEnumType::PTC,
      ::xsd::qif30::DigitalModelFormatEnumType::RPC,
      ::xsd::qif30::DigitalModelFormatEnumType::SOLIDWORKS,
      ::xsd::qif30::DigitalModelFormatEnumType::STEPAP203,
      ::xsd::qif30::DigitalModelFormatEnumType::STEPAP203E2,
      ::xsd::qif30::DigitalModelFormatEnumType::STEPAP214,
      ::xsd::qif30::DigitalModelFormatEnumType::STEPAP242
    };

    // StatsWithReferenceBaseType
    //

    StatsWithReferenceBaseType::
    StatsWithReferenceBaseType ()
    : ::xml_schema::type (),
      SoftwareId_ (this),
      StandardId_ (this),
      AlgorithmId_ (this)
    {
    }

    StatsWithReferenceBaseType::
    StatsWithReferenceBaseType (const StatsWithReferenceBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SoftwareId_ (x.SoftwareId_, f, this),
      StandardId_ (x.StandardId_, f, this),
      AlgorithmId_ (x.AlgorithmId_, f, this)
    {
    }

    StatsWithReferenceBaseType::
    StatsWithReferenceBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SoftwareId_ (this),
      StandardId_ (this),
      AlgorithmId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsWithReferenceBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SoftwareId
        //
        if (n.name () == L"SoftwareId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SoftwareId_type > r (
            SoftwareId_traits::create (i, f, this));

          if (!this->SoftwareId_)
          {
            this->SoftwareId_.set (::std::move (r));
            continue;
          }
        }

        // StandardId
        //
        if (n.name () == L"StandardId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StandardId_type > r (
            StandardId_traits::create (i, f, this));

          if (!this->StandardId_)
          {
            this->StandardId_.set (::std::move (r));
            continue;
          }
        }

        // AlgorithmId
        //
        if (n.name () == L"AlgorithmId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AlgorithmId_type > r (
            AlgorithmId_traits::create (i, f, this));

          if (!this->AlgorithmId_)
          {
            this->AlgorithmId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatsWithReferenceBaseType& StatsWithReferenceBaseType::
    operator= (const StatsWithReferenceBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SoftwareId_ = x.SoftwareId_;
        this->StandardId_ = x.StandardId_;
        this->AlgorithmId_ = x.AlgorithmId_;
      }

      return *this;
    }

    StatsWithReferenceBaseType::
    ~StatsWithReferenceBaseType ()
    {
    }

    // StatsValuesEnumType
    //

    StatsValuesEnumType::
    StatsValuesEnumType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_StatsValuesEnumType_convert ();
    }

    StatsValuesEnumType::
    StatsValuesEnumType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_StatsValuesEnumType_convert ();
    }

    StatsValuesEnumType::
    StatsValuesEnumType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_StatsValuesEnumType_convert ();
    }

    StatsValuesEnumType* StatsValuesEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsValuesEnumType (*this, f, c);
    }

    StatsValuesEnumType::value StatsValuesEnumType::
    _xsd_StatsValuesEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_StatsValuesEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_StatsValuesEnumType_indexes_,
                        _xsd_StatsValuesEnumType_indexes_ + 53,
                        *this,
                        c));

      if (i == _xsd_StatsValuesEnumType_indexes_ + 53 || _xsd_StatsValuesEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const StatsValuesEnumType::
    _xsd_StatsValuesEnumType_literals_[53] =
    {
      L"TOTNUM",
      L"EFFNUM",
      L"NUMSUB",
      L"AVG",
      L"DIFF",
      L"RMS",
      L"MAX",
      L"MIN",
      L"RANGE",
      L"AVGRNG",
      L"STDDEV",
      L"SKEW",
      L"KURT",
      L"NORM",
      L"PROVAR",
      L"ESTSTDV",
      L"UCL",
      L"LCL",
      L"UCLRNG",
      L"LCLRNG",
      L"NUMOOC",
      L"NUMOOT",
      L"NOOTHI",
      L"NOOTLO",
      L"CP",
      L"CPK",
      L"PP",
      L"PPK",
      L"CM",
      L"CMK",
      L"CPM",
      L"AV",
      L"REL_AV",
      L"EV",
      L"REL_EV",
      L"INTERACTION",
      L"REL_INTERACTION",
      L"RANDR",
      L"REL_RANDR",
      L"PV",
      L"REL_PV",
      L"TV",
      L"REL_TV",
      L"LNRTY",
      L"BIAS",
      L"REL_LNRTY",
      L"REL_BIAS",
      L"R_SQR",
      L"SLOPE",
      L"INTCPT",
      L"UPRCONFLIM",
      L"LWRCONFLIM",
      L"TDIST"
    };

    const StatsValuesEnumType::value StatsValuesEnumType::
    _xsd_StatsValuesEnumType_indexes_[53] =
    {
      ::xsd::qif30::StatsValuesEnumType::AV,
      ::xsd::qif30::StatsValuesEnumType::AVG,
      ::xsd::qif30::StatsValuesEnumType::AVGRNG,
      ::xsd::qif30::StatsValuesEnumType::BIAS,
      ::xsd::qif30::StatsValuesEnumType::CM,
      ::xsd::qif30::StatsValuesEnumType::CMK,
      ::xsd::qif30::StatsValuesEnumType::CP,
      ::xsd::qif30::StatsValuesEnumType::CPK,
      ::xsd::qif30::StatsValuesEnumType::CPM,
      ::xsd::qif30::StatsValuesEnumType::DIFF,
      ::xsd::qif30::StatsValuesEnumType::EFFNUM,
      ::xsd::qif30::StatsValuesEnumType::ESTSTDV,
      ::xsd::qif30::StatsValuesEnumType::EV,
      ::xsd::qif30::StatsValuesEnumType::INTCPT,
      ::xsd::qif30::StatsValuesEnumType::INTERACTION,
      ::xsd::qif30::StatsValuesEnumType::KURT,
      ::xsd::qif30::StatsValuesEnumType::LCL,
      ::xsd::qif30::StatsValuesEnumType::LCLRNG,
      ::xsd::qif30::StatsValuesEnumType::LNRTY,
      ::xsd::qif30::StatsValuesEnumType::LWRCONFLIM,
      ::xsd::qif30::StatsValuesEnumType::MAX,
      ::xsd::qif30::StatsValuesEnumType::MIN,
      ::xsd::qif30::StatsValuesEnumType::NOOTHI,
      ::xsd::qif30::StatsValuesEnumType::NOOTLO,
      ::xsd::qif30::StatsValuesEnumType::NORM,
      ::xsd::qif30::StatsValuesEnumType::NUMOOC,
      ::xsd::qif30::StatsValuesEnumType::NUMOOT,
      ::xsd::qif30::StatsValuesEnumType::NUMSUB,
      ::xsd::qif30::StatsValuesEnumType::PP,
      ::xsd::qif30::StatsValuesEnumType::PPK,
      ::xsd::qif30::StatsValuesEnumType::PROVAR,
      ::xsd::qif30::StatsValuesEnumType::PV,
      ::xsd::qif30::StatsValuesEnumType::RANDR,
      ::xsd::qif30::StatsValuesEnumType::RANGE,
      ::xsd::qif30::StatsValuesEnumType::REL_AV,
      ::xsd::qif30::StatsValuesEnumType::REL_BIAS,
      ::xsd::qif30::StatsValuesEnumType::REL_EV,
      ::xsd::qif30::StatsValuesEnumType::REL_INTERACTION,
      ::xsd::qif30::StatsValuesEnumType::REL_LNRTY,
      ::xsd::qif30::StatsValuesEnumType::REL_PV,
      ::xsd::qif30::StatsValuesEnumType::REL_RANDR,
      ::xsd::qif30::StatsValuesEnumType::REL_TV,
      ::xsd::qif30::StatsValuesEnumType::RMS,
      ::xsd::qif30::StatsValuesEnumType::R_SQR,
      ::xsd::qif30::StatsValuesEnumType::SKEW,
      ::xsd::qif30::StatsValuesEnumType::SLOPE,
      ::xsd::qif30::StatsValuesEnumType::STDDEV,
      ::xsd::qif30::StatsValuesEnumType::TDIST,
      ::xsd::qif30::StatsValuesEnumType::TOTNUM,
      ::xsd::qif30::StatsValuesEnumType::TV,
      ::xsd::qif30::StatsValuesEnumType::UCL,
      ::xsd::qif30::StatsValuesEnumType::UCLRNG,
      ::xsd::qif30::StatsValuesEnumType::UPRCONFLIM
    };

    // ListAccumulatedStatsValuesListType
    //

    ListAccumulatedStatsValuesListType::
    ListAccumulatedStatsValuesListType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (e, f, this)
    {
    }

    ListAccumulatedStatsValuesListType::
    ListAccumulatedStatsValuesListType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (a, f, this)
    {
    }

    ListAccumulatedStatsValuesListType::
    ListAccumulatedStatsValuesListType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (s, e, f, this)
    {
    }

    ListAccumulatedStatsValuesListType* ListAccumulatedStatsValuesListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListAccumulatedStatsValuesListType (*this, f, c);
    }

    ListAccumulatedStatsValuesListType::
    ~ListAccumulatedStatsValuesListType ()
    {
    }

    // ListAccumulatedStatsValuesType
    //

    ListAccumulatedStatsValuesType::
    ListAccumulatedStatsValuesType ()
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Stats_ (this)
    {
    }

    ListAccumulatedStatsValuesType::
    ListAccumulatedStatsValuesType (const Stats_type& Stats)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Stats_ (Stats, this)
    {
    }

    ListAccumulatedStatsValuesType::
    ListAccumulatedStatsValuesType (const ListAccumulatedStatsValuesType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (x, f, c),
      Stats_ (x.Stats_, f, this)
    {
    }

    ListAccumulatedStatsValuesType::
    ListAccumulatedStatsValuesType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      Stats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ListAccumulatedStatsValuesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithReferenceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Stats
        //
        if (n.name () == L"Stats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Stats_type > r (
            Stats_traits::create (i, f, this));

          if (!Stats_.present ())
          {
            this->Stats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Stats_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Stats",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ListAccumulatedStatsValuesType* ListAccumulatedStatsValuesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListAccumulatedStatsValuesType (*this, f, c);
    }

    ListAccumulatedStatsValuesType& ListAccumulatedStatsValuesType::
    operator= (const ListAccumulatedStatsValuesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithReferenceBaseType& > (*this) = x;
        this->Stats_ = x.Stats_;
      }

      return *this;
    }

    ListAccumulatedStatsValuesType::
    ~ListAccumulatedStatsValuesType ()
    {
    }

    // SubgroupStatsValuesEnumType
    //

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SubgroupStatsValuesEnumType_convert ();
    }

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SubgroupStatsValuesEnumType_convert ();
    }

    SubgroupStatsValuesEnumType::
    SubgroupStatsValuesEnumType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SubgroupStatsValuesEnumType_convert ();
    }

    SubgroupStatsValuesEnumType* SubgroupStatsValuesEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupStatsValuesEnumType (*this, f, c);
    }

    SubgroupStatsValuesEnumType::value SubgroupStatsValuesEnumType::
    _xsd_SubgroupStatsValuesEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SubgroupStatsValuesEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SubgroupStatsValuesEnumType_indexes_,
                        _xsd_SubgroupStatsValuesEnumType_indexes_ + 10,
                        *this,
                        c));

      if (i == _xsd_SubgroupStatsValuesEnumType_indexes_ + 10 || _xsd_SubgroupStatsValuesEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SubgroupStatsValuesEnumType::
    _xsd_SubgroupStatsValuesEnumType_literals_[10] =
    {
      L"TOTNUM",
      L"EFFNUM",
      L"AVG",
      L"DIFF",
      L"MAX",
      L"MIN",
      L"RANGE",
      L"NUMOOT",
      L"NOOTHI",
      L"NOOTLO"
    };

    const SubgroupStatsValuesEnumType::value SubgroupStatsValuesEnumType::
    _xsd_SubgroupStatsValuesEnumType_indexes_[10] =
    {
      ::xsd::qif30::SubgroupStatsValuesEnumType::AVG,
      ::xsd::qif30::SubgroupStatsValuesEnumType::DIFF,
      ::xsd::qif30::SubgroupStatsValuesEnumType::EFFNUM,
      ::xsd::qif30::SubgroupStatsValuesEnumType::MAX,
      ::xsd::qif30::SubgroupStatsValuesEnumType::MIN,
      ::xsd::qif30::SubgroupStatsValuesEnumType::NOOTHI,
      ::xsd::qif30::SubgroupStatsValuesEnumType::NOOTLO,
      ::xsd::qif30::SubgroupStatsValuesEnumType::NUMOOT,
      ::xsd::qif30::SubgroupStatsValuesEnumType::RANGE,
      ::xsd::qif30::SubgroupStatsValuesEnumType::TOTNUM
    };

    // ListSubgroupStatsValuesListType
    //

    ListSubgroupStatsValuesListType::
    ListSubgroupStatsValuesListType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t > (e, f, this)
    {
    }

    ListSubgroupStatsValuesListType::
    ListSubgroupStatsValuesListType (const xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t > (a, f, this)
    {
    }

    ListSubgroupStatsValuesListType::
    ListSubgroupStatsValuesListType (const ::std::wstring& s,
                                     const xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t > (s, e, f, this)
    {
    }

    ListSubgroupStatsValuesListType* ListSubgroupStatsValuesListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListSubgroupStatsValuesListType (*this, f, c);
    }

    ListSubgroupStatsValuesListType::
    ~ListSubgroupStatsValuesListType ()
    {
    }

    // ListSubgroupStatsValuesType
    //

    ListSubgroupStatsValuesType::
    ListSubgroupStatsValuesType ()
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Stats_ (this)
    {
    }

    ListSubgroupStatsValuesType::
    ListSubgroupStatsValuesType (const Stats_type& Stats)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Stats_ (Stats, this)
    {
    }

    ListSubgroupStatsValuesType::
    ListSubgroupStatsValuesType (const ListSubgroupStatsValuesType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (x, f, c),
      Stats_ (x.Stats_, f, this)
    {
    }

    ListSubgroupStatsValuesType::
    ListSubgroupStatsValuesType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      Stats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ListSubgroupStatsValuesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithReferenceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Stats
        //
        if (n.name () == L"Stats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Stats_type > r (
            Stats_traits::create (i, f, this));

          if (!Stats_.present ())
          {
            this->Stats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Stats_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Stats",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ListSubgroupStatsValuesType* ListSubgroupStatsValuesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListSubgroupStatsValuesType (*this, f, c);
    }

    ListSubgroupStatsValuesType& ListSubgroupStatsValuesType::
    operator= (const ListSubgroupStatsValuesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithReferenceBaseType& > (*this) = x;
        this->Stats_ = x.Stats_;
      }

      return *this;
    }

    ListSubgroupStatsValuesType::
    ~ListSubgroupStatsValuesType ()
    {
    }

    // StatsMeasuredDecimalType
    //

    StatsMeasuredDecimalType::
    StatsMeasuredDecimalType ()
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Value_ (this)
    {
    }

    StatsMeasuredDecimalType::
    StatsMeasuredDecimalType (const Value_type& Value)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Value_ (Value, this)
    {
    }

    StatsMeasuredDecimalType::
    StatsMeasuredDecimalType (::std::unique_ptr< Value_type > Value)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Value_ (std::move (Value), this)
    {
    }

    StatsMeasuredDecimalType::
    StatsMeasuredDecimalType (const StatsMeasuredDecimalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (x, f, c),
      Value_ (x.Value_, f, this)
    {
    }

    StatsMeasuredDecimalType::
    StatsMeasuredDecimalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      Value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsMeasuredDecimalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithReferenceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Value
        //
        if (n.name () == L"Value" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Value_type > r (
            Value_traits::create (i, f, this));

          if (!Value_.present ())
          {
            this->Value_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Value",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    StatsMeasuredDecimalType* StatsMeasuredDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsMeasuredDecimalType (*this, f, c);
    }

    StatsMeasuredDecimalType& StatsMeasuredDecimalType::
    operator= (const StatsMeasuredDecimalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithReferenceBaseType& > (*this) = x;
        this->Value_ = x.Value_;
      }

      return *this;
    }

    StatsMeasuredDecimalType::
    ~StatsMeasuredDecimalType ()
    {
    }

    // StatsMeasuredDecimalWithReferenceType
    //

    StatsMeasuredDecimalWithReferenceType::
    StatsMeasuredDecimalWithReferenceType ()
    : ::xsd::qif30::StatsMeasuredDecimalType (),
      Id_ (this)
    {
    }

    StatsMeasuredDecimalWithReferenceType::
    StatsMeasuredDecimalWithReferenceType (const Value_type& Value)
    : ::xsd::qif30::StatsMeasuredDecimalType (Value),
      Id_ (this)
    {
    }

    StatsMeasuredDecimalWithReferenceType::
    StatsMeasuredDecimalWithReferenceType (::std::unique_ptr< Value_type > Value)
    : ::xsd::qif30::StatsMeasuredDecimalType (std::move (Value)),
      Id_ (this)
    {
    }

    StatsMeasuredDecimalWithReferenceType::
    StatsMeasuredDecimalWithReferenceType (const StatsMeasuredDecimalWithReferenceType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::StatsMeasuredDecimalType (x, f, c),
      Id_ (x.Id_, f, this)
    {
    }

    StatsMeasuredDecimalWithReferenceType::
    StatsMeasuredDecimalWithReferenceType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::StatsMeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsMeasuredDecimalWithReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsMeasuredDecimalType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          if (!this->Id_)
          {
            this->Id_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatsMeasuredDecimalWithReferenceType* StatsMeasuredDecimalWithReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsMeasuredDecimalWithReferenceType (*this, f, c);
    }

    StatsMeasuredDecimalWithReferenceType& StatsMeasuredDecimalWithReferenceType::
    operator= (const StatsMeasuredDecimalWithReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsMeasuredDecimalType& > (*this) = x;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    StatsMeasuredDecimalWithReferenceType::
    ~StatsMeasuredDecimalWithReferenceType ()
    {
    }

    // SubgroupDecimalType
    //

    SubgroupDecimalType::
    SubgroupDecimalType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      subgroupId_ (this)
    {
    }

    SubgroupDecimalType::
    SubgroupDecimalType (const ::xml_schema::decimal& _xsd_decimal_base,
                         const subgroupId_type& subgroupId)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      subgroupId_ (subgroupId, this)
    {
    }

    SubgroupDecimalType::
    SubgroupDecimalType (const SubgroupDecimalType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      subgroupId_ (x.subgroupId_, f, this)
    {
    }

    SubgroupDecimalType::
    SubgroupDecimalType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      subgroupId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SubgroupDecimalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"subgroupId" && n.namespace_ ().empty ())
        {
          this->subgroupId_.set (subgroupId_traits::create (i, f, this));
          continue;
        }
      }

      if (!subgroupId_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"subgroupId",
          L"");
      }
    }

    SubgroupDecimalType* SubgroupDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupDecimalType (*this, f, c);
    }

    SubgroupDecimalType& SubgroupDecimalType::
    operator= (const SubgroupDecimalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->subgroupId_ = x.subgroupId_;
      }

      return *this;
    }

    SubgroupDecimalType::
    ~SubgroupDecimalType ()
    {
    }

    // SubgroupDecimalArrayType
    //

    SubgroupDecimalArrayType::
    SubgroupDecimalArrayType ()
    : ::xml_schema::type (),
      SubgroupDecimal_ (this),
      n_ (this)
    {
    }

    SubgroupDecimalArrayType::
    SubgroupDecimalArrayType (const n_type& n)
    : ::xml_schema::type (),
      SubgroupDecimal_ (this),
      n_ (n, this)
    {
    }

    SubgroupDecimalArrayType::
    SubgroupDecimalArrayType (const SubgroupDecimalArrayType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SubgroupDecimal_ (x.SubgroupDecimal_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SubgroupDecimalArrayType::
    SubgroupDecimalArrayType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SubgroupDecimal_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SubgroupDecimalArrayType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SubgroupDecimal
        //
        if (n.name () == L"SubgroupDecimal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubgroupDecimal_type > r (
            SubgroupDecimal_traits::create (i, f, this));

          this->SubgroupDecimal_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SubgroupDecimalArrayType* SubgroupDecimalArrayType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupDecimalArrayType (*this, f, c);
    }

    SubgroupDecimalArrayType& SubgroupDecimalArrayType::
    operator= (const SubgroupDecimalArrayType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SubgroupDecimal_ = x.SubgroupDecimal_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SubgroupDecimalArrayType::
    ~SubgroupDecimalArrayType ()
    {
    }

    // SubgroupDecimalsType
    //

    SubgroupDecimalsType::
    SubgroupDecimalsType ()
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Values_ (this)
    {
    }

    SubgroupDecimalsType::
    SubgroupDecimalsType (const Values_type& Values)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Values_ (Values, this)
    {
    }

    SubgroupDecimalsType::
    SubgroupDecimalsType (::std::unique_ptr< Values_type > Values)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Values_ (std::move (Values), this)
    {
    }

    SubgroupDecimalsType::
    SubgroupDecimalsType (const SubgroupDecimalsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (x, f, c),
      Values_ (x.Values_, f, this)
    {
    }

    SubgroupDecimalsType::
    SubgroupDecimalsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      Values_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SubgroupDecimalsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithReferenceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Values
        //
        if (n.name () == L"Values" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Values_type > r (
            Values_traits::create (i, f, this));

          if (!Values_.present ())
          {
            this->Values_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Values_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Values",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SubgroupDecimalsType* SubgroupDecimalsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupDecimalsType (*this, f, c);
    }

    SubgroupDecimalsType& SubgroupDecimalsType::
    operator= (const SubgroupDecimalsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithReferenceBaseType& > (*this) = x;
        this->Values_ = x.Values_;
      }

      return *this;
    }

    SubgroupDecimalsType::
    ~SubgroupDecimalsType ()
    {
    }

    // StatsNonNegativeIntegerType
    //

    StatsNonNegativeIntegerType::
    StatsNonNegativeIntegerType ()
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Value_ (this)
    {
    }

    StatsNonNegativeIntegerType::
    StatsNonNegativeIntegerType (const Value_type& Value)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Value_ (Value, this)
    {
    }

    StatsNonNegativeIntegerType::
    StatsNonNegativeIntegerType (const StatsNonNegativeIntegerType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (x, f, c),
      Value_ (x.Value_, f, this)
    {
    }

    StatsNonNegativeIntegerType::
    StatsNonNegativeIntegerType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      Value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsNonNegativeIntegerType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithReferenceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Value
        //
        if (n.name () == L"Value" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Value_.present ())
          {
            this->Value_.set (Value_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Value",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    StatsNonNegativeIntegerType* StatsNonNegativeIntegerType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsNonNegativeIntegerType (*this, f, c);
    }

    StatsNonNegativeIntegerType& StatsNonNegativeIntegerType::
    operator= (const StatsNonNegativeIntegerType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithReferenceBaseType& > (*this) = x;
        this->Value_ = x.Value_;
      }

      return *this;
    }

    StatsNonNegativeIntegerType::
    ~StatsNonNegativeIntegerType ()
    {
    }

    // StatsNonNegativeIntegerWithReferencesType
    //

    StatsNonNegativeIntegerWithReferencesType::
    StatsNonNegativeIntegerWithReferencesType ()
    : ::xsd::qif30::StatsNonNegativeIntegerType (),
      Ids_ (this)
    {
    }

    StatsNonNegativeIntegerWithReferencesType::
    StatsNonNegativeIntegerWithReferencesType (const Value_type& Value)
    : ::xsd::qif30::StatsNonNegativeIntegerType (Value),
      Ids_ (this)
    {
    }

    StatsNonNegativeIntegerWithReferencesType::
    StatsNonNegativeIntegerWithReferencesType (const StatsNonNegativeIntegerWithReferencesType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::StatsNonNegativeIntegerType (x, f, c),
      Ids_ (x.Ids_, f, this)
    {
    }

    StatsNonNegativeIntegerWithReferencesType::
    StatsNonNegativeIntegerWithReferencesType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::StatsNonNegativeIntegerType (e, f | ::xml_schema::flags::base, c),
      Ids_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StatsNonNegativeIntegerWithReferencesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsNonNegativeIntegerType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Ids
        //
        if (n.name () == L"Ids" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Ids_type > r (
            Ids_traits::create (i, f, this));

          if (!this->Ids_)
          {
            this->Ids_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    StatsNonNegativeIntegerWithReferencesType* StatsNonNegativeIntegerWithReferencesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StatsNonNegativeIntegerWithReferencesType (*this, f, c);
    }

    StatsNonNegativeIntegerWithReferencesType& StatsNonNegativeIntegerWithReferencesType::
    operator= (const StatsNonNegativeIntegerWithReferencesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsNonNegativeIntegerType& > (*this) = x;
        this->Ids_ = x.Ids_;
      }

      return *this;
    }

    StatsNonNegativeIntegerWithReferencesType::
    ~StatsNonNegativeIntegerWithReferencesType ()
    {
    }

    // SubgroupIntegerType
    //

    SubgroupIntegerType::
    SubgroupIntegerType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, wchar_t, ::xml_schema::simple_type > (),
      subgroupId_ (this)
    {
    }

    SubgroupIntegerType::
    SubgroupIntegerType (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base,
                         const subgroupId_type& subgroupId)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, wchar_t, ::xml_schema::simple_type > (_xsd_non_negative_integer_base),
      subgroupId_ (subgroupId, this)
    {
    }

    SubgroupIntegerType::
    SubgroupIntegerType (const SubgroupIntegerType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, wchar_t, ::xml_schema::simple_type > (x, f, c),
      subgroupId_ (x.subgroupId_, f, this)
    {
    }

    SubgroupIntegerType::
    SubgroupIntegerType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, wchar_t, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
      subgroupId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SubgroupIntegerType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"subgroupId" && n.namespace_ ().empty ())
        {
          this->subgroupId_.set (subgroupId_traits::create (i, f, this));
          continue;
        }
      }

      if (!subgroupId_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"subgroupId",
          L"");
      }
    }

    SubgroupIntegerType* SubgroupIntegerType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupIntegerType (*this, f, c);
    }

    SubgroupIntegerType& SubgroupIntegerType::
    operator= (const SubgroupIntegerType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, wchar_t, ::xml_schema::simple_type >& > (*this) = x;
        this->subgroupId_ = x.subgroupId_;
      }

      return *this;
    }

    SubgroupIntegerType::
    ~SubgroupIntegerType ()
    {
    }

    // SubgroupIntegerArrayType
    //

    SubgroupIntegerArrayType::
    SubgroupIntegerArrayType ()
    : ::xml_schema::type (),
      SubgroupInteger_ (this),
      n_ (this)
    {
    }

    SubgroupIntegerArrayType::
    SubgroupIntegerArrayType (const n_type& n)
    : ::xml_schema::type (),
      SubgroupInteger_ (this),
      n_ (n, this)
    {
    }

    SubgroupIntegerArrayType::
    SubgroupIntegerArrayType (const SubgroupIntegerArrayType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SubgroupInteger_ (x.SubgroupInteger_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SubgroupIntegerArrayType::
    SubgroupIntegerArrayType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SubgroupInteger_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SubgroupIntegerArrayType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SubgroupInteger
        //
        if (n.name () == L"SubgroupInteger" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubgroupInteger_type > r (
            SubgroupInteger_traits::create (i, f, this));

          this->SubgroupInteger_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SubgroupIntegerArrayType* SubgroupIntegerArrayType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupIntegerArrayType (*this, f, c);
    }

    SubgroupIntegerArrayType& SubgroupIntegerArrayType::
    operator= (const SubgroupIntegerArrayType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SubgroupInteger_ = x.SubgroupInteger_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SubgroupIntegerArrayType::
    ~SubgroupIntegerArrayType ()
    {
    }

    // SubgroupIntegersType
    //

    SubgroupIntegersType::
    SubgroupIntegersType ()
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Values_ (this)
    {
    }

    SubgroupIntegersType::
    SubgroupIntegersType (const Values_type& Values)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Values_ (Values, this)
    {
    }

    SubgroupIntegersType::
    SubgroupIntegersType (::std::unique_ptr< Values_type > Values)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Values_ (std::move (Values), this)
    {
    }

    SubgroupIntegersType::
    SubgroupIntegersType (const SubgroupIntegersType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (x, f, c),
      Values_ (x.Values_, f, this)
    {
    }

    SubgroupIntegersType::
    SubgroupIntegersType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      Values_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SubgroupIntegersType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithReferenceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Values
        //
        if (n.name () == L"Values" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Values_type > r (
            Values_traits::create (i, f, this));

          if (!Values_.present ())
          {
            this->Values_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Values_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Values",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SubgroupIntegersType* SubgroupIntegersType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubgroupIntegersType (*this, f, c);
    }

    SubgroupIntegersType& SubgroupIntegersType::
    operator= (const SubgroupIntegersType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithReferenceBaseType& > (*this) = x;
        this->Values_ = x.Values_;
      }

      return *this;
    }

    SubgroupIntegersType::
    ~SubgroupIntegersType ()
    {
    }

    // SummaryStatsValuesEnumType
    //

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SummaryStatsValuesEnumType_convert ();
    }

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SummaryStatsValuesEnumType_convert ();
    }

    SummaryStatsValuesEnumType::
    SummaryStatsValuesEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SummaryStatsValuesEnumType_convert ();
    }

    SummaryStatsValuesEnumType* SummaryStatsValuesEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatsValuesEnumType (*this, f, c);
    }

    SummaryStatsValuesEnumType::value SummaryStatsValuesEnumType::
    _xsd_SummaryStatsValuesEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_SummaryStatsValuesEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SummaryStatsValuesEnumType_indexes_,
                        _xsd_SummaryStatsValuesEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_SummaryStatsValuesEnumType_indexes_ + 5 || _xsd_SummaryStatsValuesEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const SummaryStatsValuesEnumType::
    _xsd_SummaryStatsValuesEnumType_literals_[5] =
    {
      L"AVG",
      L"MAX",
      L"MIN",
      L"RANGE",
      L"STDDEV"
    };

    const SummaryStatsValuesEnumType::value SummaryStatsValuesEnumType::
    _xsd_SummaryStatsValuesEnumType_indexes_[5] =
    {
      ::xsd::qif30::SummaryStatsValuesEnumType::AVG,
      ::xsd::qif30::SummaryStatsValuesEnumType::MAX,
      ::xsd::qif30::SummaryStatsValuesEnumType::MIN,
      ::xsd::qif30::SummaryStatsValuesEnumType::RANGE,
      ::xsd::qif30::SummaryStatsValuesEnumType::STDDEV
    };

    // ListSummaryStatsValuesListType
    //

    ListSummaryStatsValuesListType::
    ListSummaryStatsValuesListType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (e, f, this)
    {
    }

    ListSummaryStatsValuesListType::
    ListSummaryStatsValuesListType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (a, f, this)
    {
    }

    ListSummaryStatsValuesListType::
    ListSummaryStatsValuesListType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t > (s, e, f, this)
    {
    }

    ListSummaryStatsValuesListType* ListSummaryStatsValuesListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListSummaryStatsValuesListType (*this, f, c);
    }

    ListSummaryStatsValuesListType::
    ~ListSummaryStatsValuesListType ()
    {
    }

    // ListSummaryStatsValuesType
    //

    ListSummaryStatsValuesType::
    ListSummaryStatsValuesType ()
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Stats_ (this)
    {
    }

    ListSummaryStatsValuesType::
    ListSummaryStatsValuesType (const Stats_type& Stats)
    : ::xsd::qif30::StatsWithReferenceBaseType (),
      Stats_ (Stats, this)
    {
    }

    ListSummaryStatsValuesType::
    ListSummaryStatsValuesType (const ListSummaryStatsValuesType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (x, f, c),
      Stats_ (x.Stats_, f, this)
    {
    }

    ListSummaryStatsValuesType::
    ListSummaryStatsValuesType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::StatsWithReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      Stats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ListSummaryStatsValuesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::StatsWithReferenceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Stats
        //
        if (n.name () == L"Stats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Stats_type > r (
            Stats_traits::create (i, f, this));

          if (!Stats_.present ())
          {
            this->Stats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Stats_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Stats",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ListSummaryStatsValuesType* ListSummaryStatsValuesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListSummaryStatsValuesType (*this, f, c);
    }

    ListSummaryStatsValuesType& ListSummaryStatsValuesType::
    operator= (const ListSummaryStatsValuesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::StatsWithReferenceBaseType& > (*this) = x;
        this->Stats_ = x.Stats_;
      }

      return *this;
    }

    ListSummaryStatsValuesType::
    ~ListSummaryStatsValuesType ()
    {
    }

    // SummaryStatsValuesType
    //

    SummaryStatsValuesType::
    SummaryStatsValuesType ()
    : ::xml_schema::type (),
      SummaryType_ (this),
      SummaryStats_ (this)
    {
    }

    SummaryStatsValuesType::
    SummaryStatsValuesType (const SummaryType_type& SummaryType,
                            const SummaryStats_type& SummaryStats)
    : ::xml_schema::type (),
      SummaryType_ (SummaryType, this),
      SummaryStats_ (SummaryStats, this)
    {
    }

    SummaryStatsValuesType::
    SummaryStatsValuesType (const SummaryType_type& SummaryType,
                            ::std::unique_ptr< SummaryStats_type > SummaryStats)
    : ::xml_schema::type (),
      SummaryType_ (SummaryType, this),
      SummaryStats_ (std::move (SummaryStats), this)
    {
    }

    SummaryStatsValuesType::
    SummaryStatsValuesType (const SummaryStatsValuesType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SummaryType_ (x.SummaryType_, f, this),
      SummaryStats_ (x.SummaryStats_, f, this)
    {
    }

    SummaryStatsValuesType::
    SummaryStatsValuesType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SummaryType_ (this),
      SummaryStats_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SummaryStatsValuesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SummaryType
        //
        if (n.name () == L"SummaryType" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SummaryType_type > r (
            SummaryType_traits::create (i, f, this));

          if (!SummaryType_.present ())
          {
            this->SummaryType_.set (::std::move (r));
            continue;
          }
        }

        // SummaryStats
        //
        if (n.name () == L"SummaryStats" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SummaryStats_type > r (
            SummaryStats_traits::create (i, f, this));

          if (!SummaryStats_.present ())
          {
            this->SummaryStats_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SummaryType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SummaryType",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SummaryStats_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SummaryStats",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SummaryStatsValuesType* SummaryStatsValuesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatsValuesType (*this, f, c);
    }

    SummaryStatsValuesType& SummaryStatsValuesType::
    operator= (const SummaryStatsValuesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SummaryType_ = x.SummaryType_;
        this->SummaryStats_ = x.SummaryStats_;
      }

      return *this;
    }

    SummaryStatsValuesType::
    ~SummaryStatsValuesType ()
    {
    }

    // SummaryStatsValuesListType
    //

    SummaryStatsValuesListType::
    SummaryStatsValuesListType ()
    : ::xml_schema::type (),
      SummaryStatsValues_ (this),
      n_ (this)
    {
    }

    SummaryStatsValuesListType::
    SummaryStatsValuesListType (const n_type& n)
    : ::xml_schema::type (),
      SummaryStatsValues_ (this),
      n_ (n, this)
    {
    }

    SummaryStatsValuesListType::
    SummaryStatsValuesListType (const SummaryStatsValuesListType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SummaryStatsValues_ (x.SummaryStatsValues_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SummaryStatsValuesListType::
    SummaryStatsValuesListType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SummaryStatsValues_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SummaryStatsValuesListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SummaryStatsValues
        //
        if (n.name () == L"SummaryStatsValues" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SummaryStatsValues_type > r (
            SummaryStatsValues_traits::create (i, f, this));

          this->SummaryStatsValues_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SummaryStatsValuesListType* SummaryStatsValuesListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SummaryStatsValuesListType (*this, f, c);
    }

    SummaryStatsValuesListType& SummaryStatsValuesListType::
    operator= (const SummaryStatsValuesListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SummaryStatsValues_ = x.SummaryStatsValues_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SummaryStatsValuesListType::
    ~SummaryStatsValuesListType ()
    {
    }

    // DigitalModelFormatType
    //

    DigitalModelFormatType::
    DigitalModelFormatType ()
    : ::xml_schema::type (),
      DigitalModelFormatEnum_ (this),
      OtherDigitalModelFormat_ (this)
    {
    }

    DigitalModelFormatType::
    DigitalModelFormatType (const DigitalModelFormatType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DigitalModelFormatEnum_ (x.DigitalModelFormatEnum_, f, this),
      OtherDigitalModelFormat_ (x.OtherDigitalModelFormat_, f, this)
    {
    }

    DigitalModelFormatType::
    DigitalModelFormatType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DigitalModelFormatEnum_ (this),
      OtherDigitalModelFormat_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DigitalModelFormatType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DigitalModelFormatEnum
        //
        if (n.name () == L"DigitalModelFormatEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DigitalModelFormatEnum_type > r (
            DigitalModelFormatEnum_traits::create (i, f, this));

          if (!this->DigitalModelFormatEnum_)
          {
            this->DigitalModelFormatEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherDigitalModelFormat
        //
        if (n.name () == L"OtherDigitalModelFormat" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherDigitalModelFormat_type > r (
            OtherDigitalModelFormat_traits::create (i, f, this));

          if (!this->OtherDigitalModelFormat_)
          {
            this->OtherDigitalModelFormat_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    DigitalModelFormatType* DigitalModelFormatType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigitalModelFormatType (*this, f, c);
    }

    DigitalModelFormatType& DigitalModelFormatType::
    operator= (const DigitalModelFormatType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DigitalModelFormatEnum_ = x.DigitalModelFormatEnum_;
        this->OtherDigitalModelFormat_ = x.OtherDigitalModelFormat_;
      }

      return *this;
    }

    DigitalModelFormatType::
    ~DigitalModelFormatType ()
    {
    }

    // UniformScaleType
    //

    UniformScaleType::
    UniformScaleType ()
    : ::xml_schema::type (),
      ScaleFactor_ (this)
    {
    }

    UniformScaleType::
    UniformScaleType (const ScaleFactor_type& ScaleFactor)
    : ::xml_schema::type (),
      ScaleFactor_ (ScaleFactor, this)
    {
    }

    UniformScaleType::
    UniformScaleType (const UniformScaleType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ScaleFactor_ (x.ScaleFactor_, f, this)
    {
    }

    UniformScaleType::
    UniformScaleType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ScaleFactor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UniformScaleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ScaleFactor
        //
        if (n.name () == L"ScaleFactor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!ScaleFactor_.present ())
          {
            this->ScaleFactor_.set (ScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!ScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ScaleFactor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    UniformScaleType* UniformScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UniformScaleType (*this, f, c);
    }

    UniformScaleType& UniformScaleType::
    operator= (const UniformScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ScaleFactor_ = x.ScaleFactor_;
      }

      return *this;
    }

    UniformScaleType::
    ~UniformScaleType ()
    {
    }

    // RadialDifferentialScaleType
    //

    RadialDifferentialScaleType::
    RadialDifferentialScaleType ()
    : ::xml_schema::type (),
      PerpendicularScaleFactor_ (this),
      ParallelScaleFactor_ (this),
      Direction_ (this)
    {
    }

    RadialDifferentialScaleType::
    RadialDifferentialScaleType (const PerpendicularScaleFactor_type& PerpendicularScaleFactor,
                                 const ParallelScaleFactor_type& ParallelScaleFactor,
                                 const Direction_type& Direction)
    : ::xml_schema::type (),
      PerpendicularScaleFactor_ (PerpendicularScaleFactor, this),
      ParallelScaleFactor_ (ParallelScaleFactor, this),
      Direction_ (Direction, this)
    {
    }

    RadialDifferentialScaleType::
    RadialDifferentialScaleType (const PerpendicularScaleFactor_type& PerpendicularScaleFactor,
                                 const ParallelScaleFactor_type& ParallelScaleFactor,
                                 ::std::unique_ptr< Direction_type > Direction)
    : ::xml_schema::type (),
      PerpendicularScaleFactor_ (PerpendicularScaleFactor, this),
      ParallelScaleFactor_ (ParallelScaleFactor, this),
      Direction_ (std::move (Direction), this)
    {
    }

    RadialDifferentialScaleType::
    RadialDifferentialScaleType (const RadialDifferentialScaleType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PerpendicularScaleFactor_ (x.PerpendicularScaleFactor_, f, this),
      ParallelScaleFactor_ (x.ParallelScaleFactor_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    RadialDifferentialScaleType::
    RadialDifferentialScaleType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PerpendicularScaleFactor_ (this),
      ParallelScaleFactor_ (this),
      Direction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RadialDifferentialScaleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PerpendicularScaleFactor
        //
        if (n.name () == L"PerpendicularScaleFactor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!PerpendicularScaleFactor_.present ())
          {
            this->PerpendicularScaleFactor_.set (PerpendicularScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // ParallelScaleFactor
        //
        if (n.name () == L"ParallelScaleFactor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!ParallelScaleFactor_.present ())
          {
            this->ParallelScaleFactor_.set (ParallelScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PerpendicularScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PerpendicularScaleFactor",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ParallelScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ParallelScaleFactor",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Direction",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    RadialDifferentialScaleType* RadialDifferentialScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RadialDifferentialScaleType (*this, f, c);
    }

    RadialDifferentialScaleType& RadialDifferentialScaleType::
    operator= (const RadialDifferentialScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PerpendicularScaleFactor_ = x.PerpendicularScaleFactor_;
        this->ParallelScaleFactor_ = x.ParallelScaleFactor_;
        this->Direction_ = x.Direction_;
      }

      return *this;
    }

    RadialDifferentialScaleType::
    ~RadialDifferentialScaleType ()
    {
    }

    // AxialDifferentialScaleType
    //

    AxialDifferentialScaleType::
    AxialDifferentialScaleType ()
    : ::xml_schema::type (),
      XScaleFactor_ (this),
      XaxisDirection_ (this),
      YScaleFactor_ (this),
      YaxisDirection_ (this),
      ZScaleFactor_ (this),
      ZaxisDirection_ (this)
    {
    }

    AxialDifferentialScaleType::
    AxialDifferentialScaleType (const XScaleFactor_type& XScaleFactor,
                                const XaxisDirection_type& XaxisDirection,
                                const YScaleFactor_type& YScaleFactor,
                                const YaxisDirection_type& YaxisDirection,
                                const ZScaleFactor_type& ZScaleFactor,
                                const ZaxisDirection_type& ZaxisDirection)
    : ::xml_schema::type (),
      XScaleFactor_ (XScaleFactor, this),
      XaxisDirection_ (XaxisDirection, this),
      YScaleFactor_ (YScaleFactor, this),
      YaxisDirection_ (YaxisDirection, this),
      ZScaleFactor_ (ZScaleFactor, this),
      ZaxisDirection_ (ZaxisDirection, this)
    {
    }

    AxialDifferentialScaleType::
    AxialDifferentialScaleType (const XScaleFactor_type& XScaleFactor,
                                ::std::unique_ptr< XaxisDirection_type > XaxisDirection,
                                const YScaleFactor_type& YScaleFactor,
                                ::std::unique_ptr< YaxisDirection_type > YaxisDirection,
                                const ZScaleFactor_type& ZScaleFactor,
                                ::std::unique_ptr< ZaxisDirection_type > ZaxisDirection)
    : ::xml_schema::type (),
      XScaleFactor_ (XScaleFactor, this),
      XaxisDirection_ (std::move (XaxisDirection), this),
      YScaleFactor_ (YScaleFactor, this),
      YaxisDirection_ (std::move (YaxisDirection), this),
      ZScaleFactor_ (ZScaleFactor, this),
      ZaxisDirection_ (std::move (ZaxisDirection), this)
    {
    }

    AxialDifferentialScaleType::
    AxialDifferentialScaleType (const AxialDifferentialScaleType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XScaleFactor_ (x.XScaleFactor_, f, this),
      XaxisDirection_ (x.XaxisDirection_, f, this),
      YScaleFactor_ (x.YScaleFactor_, f, this),
      YaxisDirection_ (x.YaxisDirection_, f, this),
      ZScaleFactor_ (x.ZScaleFactor_, f, this),
      ZaxisDirection_ (x.ZaxisDirection_, f, this)
    {
    }

    AxialDifferentialScaleType::
    AxialDifferentialScaleType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XScaleFactor_ (this),
      XaxisDirection_ (this),
      YScaleFactor_ (this),
      YaxisDirection_ (this),
      ZScaleFactor_ (this),
      ZaxisDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AxialDifferentialScaleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XScaleFactor
        //
        if (n.name () == L"XScaleFactor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!XScaleFactor_.present ())
          {
            this->XScaleFactor_.set (XScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // XaxisDirection
        //
        if (n.name () == L"XaxisDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XaxisDirection_type > r (
            XaxisDirection_traits::create (i, f, this));

          if (!XaxisDirection_.present ())
          {
            this->XaxisDirection_.set (::std::move (r));
            continue;
          }
        }

        // YScaleFactor
        //
        if (n.name () == L"YScaleFactor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!YScaleFactor_.present ())
          {
            this->YScaleFactor_.set (YScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // YaxisDirection
        //
        if (n.name () == L"YaxisDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YaxisDirection_type > r (
            YaxisDirection_traits::create (i, f, this));

          if (!YaxisDirection_.present ())
          {
            this->YaxisDirection_.set (::std::move (r));
            continue;
          }
        }

        // ZScaleFactor
        //
        if (n.name () == L"ZScaleFactor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!ZScaleFactor_.present ())
          {
            this->ZScaleFactor_.set (ZScaleFactor_traits::create (i, f, this));
            continue;
          }
        }

        // ZaxisDirection
        //
        if (n.name () == L"ZaxisDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZaxisDirection_type > r (
            ZaxisDirection_traits::create (i, f, this));

          if (!ZaxisDirection_.present ())
          {
            this->ZaxisDirection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!XScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XScaleFactor",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!XaxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XaxisDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YScaleFactor",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YaxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YaxisDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZScaleFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZScaleFactor",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZaxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZaxisDirection",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AxialDifferentialScaleType* AxialDifferentialScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AxialDifferentialScaleType (*this, f, c);
    }

    AxialDifferentialScaleType& AxialDifferentialScaleType::
    operator= (const AxialDifferentialScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XScaleFactor_ = x.XScaleFactor_;
        this->XaxisDirection_ = x.XaxisDirection_;
        this->YScaleFactor_ = x.YScaleFactor_;
        this->YaxisDirection_ = x.YaxisDirection_;
        this->ZScaleFactor_ = x.ZScaleFactor_;
        this->ZaxisDirection_ = x.ZaxisDirection_;
      }

      return *this;
    }

    AxialDifferentialScaleType::
    ~AxialDifferentialScaleType ()
    {
    }

    // ScaleType
    //

    ScaleType::
    ScaleType ()
    : ::xml_schema::type (),
      Origin_ (this),
      UniformScale_ (this),
      RadialDifferentialScale_ (this),
      AxialDifferentialScale_ (this)
    {
    }

    ScaleType::
    ScaleType (const Origin_type& Origin)
    : ::xml_schema::type (),
      Origin_ (Origin, this),
      UniformScale_ (this),
      RadialDifferentialScale_ (this),
      AxialDifferentialScale_ (this)
    {
    }

    ScaleType::
    ScaleType (::std::unique_ptr< Origin_type > Origin)
    : ::xml_schema::type (),
      Origin_ (std::move (Origin), this),
      UniformScale_ (this),
      RadialDifferentialScale_ (this),
      AxialDifferentialScale_ (this)
    {
    }

    ScaleType::
    ScaleType (const ScaleType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Origin_ (x.Origin_, f, this),
      UniformScale_ (x.UniformScale_, f, this),
      RadialDifferentialScale_ (x.RadialDifferentialScale_, f, this),
      AxialDifferentialScale_ (x.AxialDifferentialScale_, f, this)
    {
    }

    ScaleType::
    ScaleType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Origin_ (this),
      UniformScale_ (this),
      RadialDifferentialScale_ (this),
      AxialDifferentialScale_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ScaleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Origin
        //
        if (n.name () == L"Origin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          if (!Origin_.present ())
          {
            this->Origin_.set (::std::move (r));
            continue;
          }
        }

        // UniformScale
        //
        if (n.name () == L"UniformScale" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UniformScale_type > r (
            UniformScale_traits::create (i, f, this));

          if (!this->UniformScale_)
          {
            this->UniformScale_.set (::std::move (r));
            continue;
          }
        }

        // RadialDifferentialScale
        //
        if (n.name () == L"RadialDifferentialScale" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RadialDifferentialScale_type > r (
            RadialDifferentialScale_traits::create (i, f, this));

          if (!this->RadialDifferentialScale_)
          {
            this->RadialDifferentialScale_.set (::std::move (r));
            continue;
          }
        }

        // AxialDifferentialScale
        //
        if (n.name () == L"AxialDifferentialScale" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxialDifferentialScale_type > r (
            AxialDifferentialScale_traits::create (i, f, this));

          if (!this->AxialDifferentialScale_)
          {
            this->AxialDifferentialScale_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Origin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Origin",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ScaleType* ScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ScaleType (*this, f, c);
    }

    ScaleType& ScaleType::
    operator= (const ScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Origin_ = x.Origin_;
        this->UniformScale_ = x.UniformScale_;
        this->RadialDifferentialScale_ = x.RadialDifferentialScale_;
        this->AxialDifferentialScale_ = x.AxialDifferentialScale_;
      }

      return *this;
    }

    ScaleType::
    ~ScaleType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const RectangularUnitAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // RectangularUnitAreaLength
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RectangularUnitAreaLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RectangularUnitAreaLength ();
      }

      // RectangularUnitAreaWidth
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RectangularUnitAreaWidth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RectangularUnitAreaWidth ();
      }

      // RectangularUnitAreaOrientation
      //
      if (i.RectangularUnitAreaOrientation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RectangularUnitAreaOrientation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RectangularUnitAreaOrientation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularUnitAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CircularUnitAreaDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CircularUnitAreaDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CircularUnitAreaDiameter ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredPointType& i)
    {
      e << static_cast< const ::xsd::qif30::PointType& > (i);

      // combinedUncertainty
      //
      if (i.combinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"combinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.combinedUncertainty ());
      }

      // meanError
      //
      if (i.meanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"meanError",
            e));

        a << ::xml_schema::as_decimal(*i.meanError ());
      }

      // xCombinedUncertainty
      //
      if (i.xCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.xCombinedUncertainty ());
      }

      // xMeanError
      //
      if (i.xMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.xMeanError ());
      }

      // yCombinedUncertainty
      //
      if (i.yCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.yCombinedUncertainty ());
      }

      // yMeanError
      //
      if (i.yMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.yMeanError ());
      }

      // zCombinedUncertainty
      //
      if (i.zCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.zCombinedUncertainty ());
      }

      // zMeanError
      //
      if (i.zMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.zMeanError ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredUnitVectorType& i)
    {
      e << static_cast< const ::xsd::qif30::UnitVectorType& > (i);

      // combinedUncertainty
      //
      if (i.combinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"combinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.combinedUncertainty ());
      }

      // meanError
      //
      if (i.meanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"meanError",
            e));

        a << ::xml_schema::as_decimal(*i.meanError ());
      }

      // xCombinedUncertainty
      //
      if (i.xCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.xCombinedUncertainty ());
      }

      // xMeanError
      //
      if (i.xMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.xMeanError ());
      }

      // yCombinedUncertainty
      //
      if (i.yCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.yCombinedUncertainty ());
      }

      // yMeanError
      //
      if (i.yMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.yMeanError ());
      }

      // zCombinedUncertainty
      //
      if (i.zCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.zCombinedUncertainty ());
      }

      // zMeanError
      //
      if (i.zMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.zMeanError ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredPlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Point
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Point ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredAxisType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AxisPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AxisPoint ();
      }

      // Direction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Direction ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredZoneAxisType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredAxisType& > (i);

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Length ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BottomEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const BottomEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const BottomEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const BottomType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BottomEnum
      //
      if (i.BottomEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BottomEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BottomEnum ();
      }

      // OtherBottom
      //
      if (i.OtherBottom ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherBottom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherBottom ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BoundingBoxType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Length ();
      }

      // Width
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Width ();
      }

      // Height
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Height",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Height ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ShapeClassEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ShapeClassEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ShapeClassEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ShapeClassType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ShapeClassEnum
      //
      if (i.ShapeClassEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShapeClassEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ShapeClassEnum ();
      }

      // OtherShapeClass
      //
      if (i.OtherShapeClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherShapeClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherShapeClass ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ManufacturingMethodEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ManufacturingMethodEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ManufacturingMethodEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ManufacturingMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ManufacturingMethodEnum
      //
      if (i.ManufacturingMethodEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ManufacturingMethodEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ManufacturingMethodEnum ();
      }

      // OtherManufacturingMethod
      //
      if (i.OtherManufacturingMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherManufacturingMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherManufacturingMethod ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const InternalExternalEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const InternalExternalEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const InternalExternalEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DimensionCountEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DimensionCountEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DimensionCountEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ZoneOrientationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ZoneOrientationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ZoneOrientationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CoordinateEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const CoordinateEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CoordinateEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const TypeOfCoordinatesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoordinateEnum
      //
      if (i.CoordinateEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CoordinateEnum ();
      }

      // OtherCoordinate
      //
      if (i.OtherCoordinate ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherCoordinate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherCoordinate ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RectangleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Length ();
      }

      // CornerPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CornerPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CornerPoint ();
      }

      // Width
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Width ();
      }

      // WidthDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.WidthDirection ();
      }

      // LengthDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LengthDirection ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CenterPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterPoint ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CenterPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterPoint ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Length ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CenterPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterPoint ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointAndVectorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StartPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StartPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.StartPoint ();
      }

      // Vector
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Vector ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredPointAndVectorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StartPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StartPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.StartPoint ();
      }

      // Vector
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Vector ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SlotEndEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SlotEndEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SlotEndEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const EndRadiusType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EndRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndRadius ();
      }

      // Expanded
      //
      if (i.Expanded ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Expanded",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Expanded ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredEndRadiusType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EndRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndRadius ();
      }

      // Expanded
      //
      if (i.Expanded ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Expanded",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Expanded ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SlotEndType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SlotEndEnum
      //
      if (i.SlotEndEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SlotEndEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SlotEndEnum ();
      }

      // OtherSlotEnd
      //
      if (i.OtherSlotEnd ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherSlotEnd",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherSlotEnd ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadSeriesEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ThreadSeriesEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ThreadSeriesEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadSeriesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ThreadSeriesEnum
      //
      if (i.ThreadSeriesEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadSeriesEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThreadSeriesEnum ();
      }

      // OtherThreadSeries
      //
      if (i.OtherThreadSeries ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherThreadSeries",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherThreadSeries ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadClassType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ThreadClassEnum
      //
      if (i.ThreadClassEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadClassEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ThreadClassEnum ();
      }

      // OtherThreadClass
      //
      if (i.OtherThreadClass ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherThreadClass",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherThreadClass ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadClassEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ThreadClassEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ThreadClassEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SecurityClassificationEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SecurityClassificationEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SecurityClassificationEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SecurityClassificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SecurityClassificationEnum
      //
      if (i.SecurityClassificationEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecurityClassificationEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SecurityClassificationEnum ();
      }

      // OtherSecurityClassification
      //
      if (i.OtherSecurityClassification ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherSecurityClassification",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherSecurityClassification ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DigitalModelFormatEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DigitalModelFormatEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DigitalModelFormatEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsWithReferenceBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SoftwareId
      //
      if (i.SoftwareId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SoftwareId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SoftwareId ();
      }

      // StandardId
      //
      if (i.StandardId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandardId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StandardId ();
      }

      // AlgorithmId
      //
      if (i.AlgorithmId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AlgorithmId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AlgorithmId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsValuesEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const StatsValuesEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const StatsValuesEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListAccumulatedStatsValuesListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListAccumulatedStatsValuesListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListAccumulatedStatsValuesListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListAccumulatedStatsValuesType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithReferenceBaseType& > (i);

      // Stats
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Stats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Stats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupStatsValuesEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SubgroupStatsValuesEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SubgroupStatsValuesEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListSubgroupStatsValuesListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListSubgroupStatsValuesListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListSubgroupStatsValuesListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::SubgroupStatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListSubgroupStatsValuesType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithReferenceBaseType& > (i);

      // Stats
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Stats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Stats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsMeasuredDecimalType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithReferenceBaseType& > (i);

      // Value
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Value",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Value ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsMeasuredDecimalWithReferenceType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsMeasuredDecimalType& > (i);

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupDecimalType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // subgroupId
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"subgroupId",
            e));

        a << i.subgroupId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupDecimalArrayType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SubgroupDecimal
      //
      for (SubgroupDecimalArrayType::SubgroupDecimal_const_iterator
           b (i.SubgroupDecimal ().begin ()), n (i.SubgroupDecimal ().end ());
           b != n; ++b)
      {
        const SubgroupDecimalArrayType::SubgroupDecimal_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubgroupDecimal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupDecimalsType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithReferenceBaseType& > (i);

      // Values
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Values",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Values ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsNonNegativeIntegerType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithReferenceBaseType& > (i);

      // Value
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Value",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Value ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const StatsNonNegativeIntegerWithReferencesType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsNonNegativeIntegerType& > (i);

      // Ids
      //
      if (i.Ids ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Ids",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Ids ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupIntegerType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, wchar_t, ::xml_schema::simple_type >& > (i);

      // subgroupId
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"subgroupId",
            e));

        a << i.subgroupId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupIntegerArrayType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SubgroupInteger
      //
      for (SubgroupIntegerArrayType::SubgroupInteger_const_iterator
           b (i.SubgroupInteger ().begin ()), n (i.SubgroupInteger ().end ());
           b != n; ++b)
      {
        const SubgroupIntegerArrayType::SubgroupInteger_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubgroupInteger",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SubgroupIntegersType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithReferenceBaseType& > (i);

      // Values
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Values",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Values ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatsValuesEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const SummaryStatsValuesEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SummaryStatsValuesEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListSummaryStatsValuesListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListSummaryStatsValuesListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListSummaryStatsValuesListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::StatsValuesEnumType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListSummaryStatsValuesType& i)
    {
      e << static_cast< const ::xsd::qif30::StatsWithReferenceBaseType& > (i);

      // Stats
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Stats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Stats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatsValuesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SummaryType
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SummaryType",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SummaryType ();
      }

      // SummaryStats
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SummaryStats",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SummaryStats ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SummaryStatsValuesListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SummaryStatsValues
      //
      for (SummaryStatsValuesListType::SummaryStatsValues_const_iterator
           b (i.SummaryStatsValues ().begin ()), n (i.SummaryStatsValues ().end ());
           b != n; ++b)
      {
        const SummaryStatsValuesListType::SummaryStatsValues_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SummaryStatsValues",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DigitalModelFormatType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DigitalModelFormatEnum
      //
      if (i.DigitalModelFormatEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DigitalModelFormatEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DigitalModelFormatEnum ();
      }

      // OtherDigitalModelFormat
      //
      if (i.OtherDigitalModelFormat ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherDigitalModelFormat",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherDigitalModelFormat ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UniformScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ScaleFactor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ScaleFactor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.ScaleFactor ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RadialDifferentialScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PerpendicularScaleFactor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PerpendicularScaleFactor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.PerpendicularScaleFactor ());
      }

      // ParallelScaleFactor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ParallelScaleFactor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.ParallelScaleFactor ());
      }

      // Direction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Direction ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AxialDifferentialScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XScaleFactor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XScaleFactor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.XScaleFactor ());
      }

      // XaxisDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XaxisDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XaxisDirection ();
      }

      // YScaleFactor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YScaleFactor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.YScaleFactor ());
      }

      // YaxisDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YaxisDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YaxisDirection ();
      }

      // ZScaleFactor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZScaleFactor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(i.ZScaleFactor ());
      }

      // ZaxisDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZaxisDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZaxisDirection ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Origin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Origin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Origin ();
      }

      // UniformScale
      //
      if (i.UniformScale ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UniformScale",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UniformScale ();
      }

      // RadialDifferentialScale
      //
      if (i.RadialDifferentialScale ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RadialDifferentialScale",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RadialDifferentialScale ();
      }

      // AxialDifferentialScale
      //
      if (i.AxialDifferentialScale ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxialDifferentialScale",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AxialDifferentialScale ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

