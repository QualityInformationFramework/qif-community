// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_EXPRESSIONS_HXX
#define CXX___QIFLIBRARY_EXPRESSIONS_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class SamplingCategoryIsType;
    class FeatureIsDatumType;
    class FeatureIsInternalType;
    class CharacteristicIsType;
    class FeatureTypeIsType;
    class ShapeClassIsType;
    class PointSamplingStrategyEnumBaseType;
    class PointPointSamplingStrategyEnumType;
    class OpenCurvePointSamplingStrategyEnumType;
    class ClosedCurvePointSamplingStrategyEnumType;
    class PointDefinedPointSamplingStrategyEnumType;
    class ConePointSamplingStrategyEnumType;
    class ElongatedCylinderPointSamplingStrategyEnumType;
    class ExtrudedCrossSectionPointSamplingStrategyEnumType;
    class SpherePointSamplingStrategyEnumType;
    class SurfaceOfRevolutionPointSamplingStrategyEnumType;
    class PlanePointSamplingStrategyEnumType;
    class CharacteristicTypeEnumType;
    class FeatureTypeEnumType;
    class DMEClassNameEnumType;
    class ArithmeticComparisonEnumType;
    class ArithmeticParameterBaseType;
    class ArithmeticFeatureParameterType;
    class ArithmeticCharacteristicParameterType;
    class ArithmeticDMEParameterType;
    class ArithmeticPartParameterType;
    class CharacteristicToleranceType;
    class FeatureLengthType;
    class FeatureAreaType;
    class FeatureSizeType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/GenericExpressions.hxx"

#include "../QIFLibrary/PrimitivesPMI.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL SamplingCategoryIsType: public ::xsd::qif30::BooleanExpressionBaseType
    {
      public:
      // val
      //
      typedef ::xml_schema::unsigned_int val_type;
      typedef ::xsd::cxx::tree::traits< val_type, wchar_t > val_traits;

      const val_type&
      val () const;

      val_type&
      val ();

      void
      val (const val_type& x);

      // Constructors.
      //
      SamplingCategoryIsType ();

      SamplingCategoryIsType (const val_type&);

      SamplingCategoryIsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      SamplingCategoryIsType (const SamplingCategoryIsType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual SamplingCategoryIsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SamplingCategoryIsType&
      operator= (const SamplingCategoryIsType& x);

      virtual 
      ~SamplingCategoryIsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< val_type > val_;
    };

    class QIF30_SYMBOL_DECL FeatureIsDatumType: public ::xsd::qif30::BooleanExpressionBaseType
    {
      public:
      // Constructors.
      //
      FeatureIsDatumType ();

      FeatureIsDatumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FeatureIsDatumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FeatureIsDatumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FeatureIsDatumType (const FeatureIsDatumType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual FeatureIsDatumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FeatureIsDatumType&
      operator= (const FeatureIsDatumType&) = default;
#endif

      virtual 
      ~FeatureIsDatumType ();
    };

    class QIF30_SYMBOL_DECL FeatureIsInternalType: public ::xsd::qif30::BooleanExpressionBaseType
    {
      public:
      // Constructors.
      //
      FeatureIsInternalType ();

      FeatureIsInternalType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      FeatureIsInternalType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      FeatureIsInternalType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      FeatureIsInternalType (const FeatureIsInternalType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual FeatureIsInternalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FeatureIsInternalType&
      operator= (const FeatureIsInternalType&) = default;
#endif

      virtual 
      ~FeatureIsInternalType ();
    };

    class QIF30_SYMBOL_DECL CharacteristicIsType: public ::xsd::qif30::BooleanExpressionBaseType
    {
      public:
      // val
      //
      typedef ::xsd::qif30::CharacteristicTypeEnumType val_type;
      typedef ::xsd::cxx::tree::traits< val_type, wchar_t > val_traits;

      const val_type&
      val () const;

      val_type&
      val ();

      void
      val (const val_type& x);

      void
      val (::std::unique_ptr< val_type > p);

      // Constructors.
      //
      CharacteristicIsType ();

      CharacteristicIsType (const val_type&);

      CharacteristicIsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CharacteristicIsType (const CharacteristicIsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CharacteristicIsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicIsType&
      operator= (const CharacteristicIsType& x);

      virtual 
      ~CharacteristicIsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< val_type > val_;
    };

    class QIF30_SYMBOL_DECL FeatureTypeIsType: public ::xsd::qif30::BooleanExpressionBaseType
    {
      public:
      // val
      //
      typedef ::xsd::qif30::FeatureTypeEnumType val_type;
      typedef ::xsd::cxx::tree::traits< val_type, wchar_t > val_traits;

      const val_type&
      val () const;

      val_type&
      val ();

      void
      val (const val_type& x);

      void
      val (::std::unique_ptr< val_type > p);

      // Constructors.
      //
      FeatureTypeIsType ();

      FeatureTypeIsType (const val_type&);

      FeatureTypeIsType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      FeatureTypeIsType (const FeatureTypeIsType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual FeatureTypeIsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureTypeIsType&
      operator= (const FeatureTypeIsType& x);

      virtual 
      ~FeatureTypeIsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< val_type > val_;
    };

    class QIF30_SYMBOL_DECL ShapeClassIsType: public ::xsd::qif30::BooleanExpressionBaseType
    {
      public:
      // val
      //
      typedef ::xsd::qif30::ShapeClassEnumType val_type;
      typedef ::xsd::cxx::tree::traits< val_type, wchar_t > val_traits;

      const val_type&
      val () const;

      val_type&
      val ();

      void
      val (const val_type& x);

      void
      val (::std::unique_ptr< val_type > p);

      // Constructors.
      //
      ShapeClassIsType ();

      ShapeClassIsType (const val_type&);

      ShapeClassIsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ShapeClassIsType (const ShapeClassIsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ShapeClassIsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ShapeClassIsType&
      operator= (const ShapeClassIsType& x);

      virtual 
      ~ShapeClassIsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< val_type > val_;
    };

    class QIF30_SYMBOL_DECL PointSamplingStrategyEnumBaseType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ORTHOGONALGRID,
        BIRDCAGE,
        POLARGRID,
        SPECIFIEDGRID,
        STRATIFIED,
        HELIX,
        SPIRAL,
        SPIDERWEB,
        POINTS
      };

      PointSamplingStrategyEnumBaseType ();

      PointSamplingStrategyEnumBaseType (value v);

      PointSamplingStrategyEnumBaseType (const wchar_t* v);

      PointSamplingStrategyEnumBaseType (const ::std::wstring& v);

      PointSamplingStrategyEnumBaseType (const ::xml_schema::nmtoken& v);

      PointSamplingStrategyEnumBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      PointSamplingStrategyEnumBaseType (const xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      PointSamplingStrategyEnumBaseType (const ::std::wstring& s,
                                         const xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      PointSamplingStrategyEnumBaseType (const PointSamplingStrategyEnumBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      PointSamplingStrategyEnumBaseType&
      operator= (const PointSamplingStrategyEnumBaseType&) = default;
#endif

      virtual PointSamplingStrategyEnumBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointSamplingStrategyEnumBaseType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PointSamplingStrategyEnumBaseType_convert ();
      }

      protected:
      value
      _xsd_PointSamplingStrategyEnumBaseType_convert () const;

      public:
      static const wchar_t* const _xsd_PointSamplingStrategyEnumBaseType_literals_[9];
      static const value _xsd_PointSamplingStrategyEnumBaseType_indexes_[9];
    };

    class QIF30_SYMBOL_DECL PointPointSamplingStrategyEnumType: public ::xsd::qif30::PointSamplingStrategyEnumBaseType
    {
      public:
      typedef ::xsd::qif30::PointSamplingStrategyEnumBaseType::value value;

      PointPointSamplingStrategyEnumType ();

      PointPointSamplingStrategyEnumType (value v);

      PointPointSamplingStrategyEnumType (const wchar_t* v);

      PointPointSamplingStrategyEnumType (const ::std::wstring& v);

      PointPointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v);

      PointPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PointPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PointPointSamplingStrategyEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PointPointSamplingStrategyEnumType (const PointPointSamplingStrategyEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      PointPointSamplingStrategyEnumType&
      operator= (const PointPointSamplingStrategyEnumType&) = default;
#endif

      virtual PointPointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointPointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PointPointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_PointPointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const* _xsd_PointPointSamplingStrategyEnumType_literals_;
      static const value _xsd_PointPointSamplingStrategyEnumType_indexes_[1];
    };

    class QIF30_SYMBOL_DECL OpenCurvePointSamplingStrategyEnumType: public ::xsd::qif30::PointSamplingStrategyEnumBaseType
    {
      public:
      typedef ::xsd::qif30::PointSamplingStrategyEnumBaseType::value value;

      OpenCurvePointSamplingStrategyEnumType ();

      OpenCurvePointSamplingStrategyEnumType (value v);

      OpenCurvePointSamplingStrategyEnumType (const wchar_t* v);

      OpenCurvePointSamplingStrategyEnumType (const ::std::wstring& v);

      OpenCurvePointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v);

      OpenCurvePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OpenCurvePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OpenCurvePointSamplingStrategyEnumType (const ::std::wstring& s,
                                              const xercesc::DOMElement* e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OpenCurvePointSamplingStrategyEnumType (const OpenCurvePointSamplingStrategyEnumType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      OpenCurvePointSamplingStrategyEnumType&
      operator= (const OpenCurvePointSamplingStrategyEnumType&) = default;
#endif

      virtual OpenCurvePointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OpenCurvePointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_OpenCurvePointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_OpenCurvePointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const* _xsd_OpenCurvePointSamplingStrategyEnumType_literals_;
      static const value _xsd_OpenCurvePointSamplingStrategyEnumType_indexes_[1];
    };

    class QIF30_SYMBOL_DECL ClosedCurvePointSamplingStrategyEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        POINTS,
        EQUIDISTANT
      };

      ClosedCurvePointSamplingStrategyEnumType ();

      ClosedCurvePointSamplingStrategyEnumType (value v);

      ClosedCurvePointSamplingStrategyEnumType (const wchar_t* v);

      ClosedCurvePointSamplingStrategyEnumType (const ::std::wstring& v);

      ClosedCurvePointSamplingStrategyEnumType (const ::xml_schema::nmtoken& v);

      ClosedCurvePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ClosedCurvePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ClosedCurvePointSamplingStrategyEnumType (const ::std::wstring& s,
                                                const xercesc::DOMElement* e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ClosedCurvePointSamplingStrategyEnumType (const ClosedCurvePointSamplingStrategyEnumType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ClosedCurvePointSamplingStrategyEnumType&
      operator= (const ClosedCurvePointSamplingStrategyEnumType&) = default;
#endif

      virtual ClosedCurvePointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ClosedCurvePointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ClosedCurvePointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_ClosedCurvePointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ClosedCurvePointSamplingStrategyEnumType_literals_[2];
      static const value _xsd_ClosedCurvePointSamplingStrategyEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL PointDefinedPointSamplingStrategyEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        GIVENPOINTS,
        POINTS
      };

      PointDefinedPointSamplingStrategyEnumType ();

      PointDefinedPointSamplingStrategyEnumType (value v);

      PointDefinedPointSamplingStrategyEnumType (const wchar_t* v);

      PointDefinedPointSamplingStrategyEnumType (const ::std::wstring& v);

      PointDefinedPointSamplingStrategyEnumType (const ::xml_schema::nmtoken& v);

      PointDefinedPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PointDefinedPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PointDefinedPointSamplingStrategyEnumType (const ::std::wstring& s,
                                                 const xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PointDefinedPointSamplingStrategyEnumType (const PointDefinedPointSamplingStrategyEnumType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      PointDefinedPointSamplingStrategyEnumType&
      operator= (const PointDefinedPointSamplingStrategyEnumType&) = default;
#endif

      virtual PointDefinedPointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedPointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PointDefinedPointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_PointDefinedPointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_PointDefinedPointSamplingStrategyEnumType_literals_[2];
      static const value _xsd_PointDefinedPointSamplingStrategyEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL ConePointSamplingStrategyEnumType: public ::xsd::qif30::PointSamplingStrategyEnumBaseType
    {
      public:
      typedef ::xsd::qif30::PointSamplingStrategyEnumBaseType::value value;

      ConePointSamplingStrategyEnumType ();

      ConePointSamplingStrategyEnumType (value v);

      ConePointSamplingStrategyEnumType (const wchar_t* v);

      ConePointSamplingStrategyEnumType (const ::std::wstring& v);

      ConePointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v);

      ConePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ConePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ConePointSamplingStrategyEnumType (const ::std::wstring& s,
                                         const xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ConePointSamplingStrategyEnumType (const ConePointSamplingStrategyEnumType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ConePointSamplingStrategyEnumType&
      operator= (const ConePointSamplingStrategyEnumType&) = default;
#endif

      virtual ConePointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConePointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ConePointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_ConePointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const* _xsd_ConePointSamplingStrategyEnumType_literals_;
      static const value _xsd_ConePointSamplingStrategyEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderPointSamplingStrategyEnumType: public ::xsd::qif30::PointSamplingStrategyEnumBaseType
    {
      public:
      typedef ::xsd::qif30::PointSamplingStrategyEnumBaseType::value value;

      ElongatedCylinderPointSamplingStrategyEnumType ();

      ElongatedCylinderPointSamplingStrategyEnumType (value v);

      ElongatedCylinderPointSamplingStrategyEnumType (const wchar_t* v);

      ElongatedCylinderPointSamplingStrategyEnumType (const ::std::wstring& v);

      ElongatedCylinderPointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v);

      ElongatedCylinderPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      ElongatedCylinderPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      ElongatedCylinderPointSamplingStrategyEnumType (const ::std::wstring& s,
                                                      const xercesc::DOMElement* e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      ElongatedCylinderPointSamplingStrategyEnumType (const ElongatedCylinderPointSamplingStrategyEnumType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ElongatedCylinderPointSamplingStrategyEnumType&
      operator= (const ElongatedCylinderPointSamplingStrategyEnumType&) = default;
#endif

      virtual ElongatedCylinderPointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderPointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ElongatedCylinderPointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_ElongatedCylinderPointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const* _xsd_ElongatedCylinderPointSamplingStrategyEnumType_literals_;
      static const value _xsd_ElongatedCylinderPointSamplingStrategyEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionPointSamplingStrategyEnumType: public ::xsd::qif30::PointSamplingStrategyEnumBaseType
    {
      public:
      typedef ::xsd::qif30::PointSamplingStrategyEnumBaseType::value value;

      ExtrudedCrossSectionPointSamplingStrategyEnumType ();

      ExtrudedCrossSectionPointSamplingStrategyEnumType (value v);

      ExtrudedCrossSectionPointSamplingStrategyEnumType (const wchar_t* v);

      ExtrudedCrossSectionPointSamplingStrategyEnumType (const ::std::wstring& v);

      ExtrudedCrossSectionPointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v);

      ExtrudedCrossSectionPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      ExtrudedCrossSectionPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      ExtrudedCrossSectionPointSamplingStrategyEnumType (const ::std::wstring& s,
                                                         const xercesc::DOMElement* e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      ExtrudedCrossSectionPointSamplingStrategyEnumType (const ExtrudedCrossSectionPointSamplingStrategyEnumType& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ExtrudedCrossSectionPointSamplingStrategyEnumType&
      operator= (const ExtrudedCrossSectionPointSamplingStrategyEnumType&) = default;
#endif

      virtual ExtrudedCrossSectionPointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionPointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const* _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_literals_;
      static const value _xsd_ExtrudedCrossSectionPointSamplingStrategyEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL SpherePointSamplingStrategyEnumType: public ::xsd::qif30::PointSamplingStrategyEnumBaseType
    {
      public:
      typedef ::xsd::qif30::PointSamplingStrategyEnumBaseType::value value;

      SpherePointSamplingStrategyEnumType ();

      SpherePointSamplingStrategyEnumType (value v);

      SpherePointSamplingStrategyEnumType (const wchar_t* v);

      SpherePointSamplingStrategyEnumType (const ::std::wstring& v);

      SpherePointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v);

      SpherePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      SpherePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      SpherePointSamplingStrategyEnumType (const ::std::wstring& s,
                                           const xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      SpherePointSamplingStrategyEnumType (const SpherePointSamplingStrategyEnumType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SpherePointSamplingStrategyEnumType&
      operator= (const SpherePointSamplingStrategyEnumType&) = default;
#endif

      virtual SpherePointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpherePointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SpherePointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_SpherePointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const* _xsd_SpherePointSamplingStrategyEnumType_literals_;
      static const value _xsd_SpherePointSamplingStrategyEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionPointSamplingStrategyEnumType: public ::xsd::qif30::PointSamplingStrategyEnumBaseType
    {
      public:
      typedef ::xsd::qif30::PointSamplingStrategyEnumBaseType::value value;

      SurfaceOfRevolutionPointSamplingStrategyEnumType ();

      SurfaceOfRevolutionPointSamplingStrategyEnumType (value v);

      SurfaceOfRevolutionPointSamplingStrategyEnumType (const wchar_t* v);

      SurfaceOfRevolutionPointSamplingStrategyEnumType (const ::std::wstring& v);

      SurfaceOfRevolutionPointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v);

      SurfaceOfRevolutionPointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      SurfaceOfRevolutionPointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      SurfaceOfRevolutionPointSamplingStrategyEnumType (const ::std::wstring& s,
                                                        const xercesc::DOMElement* e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      SurfaceOfRevolutionPointSamplingStrategyEnumType (const SurfaceOfRevolutionPointSamplingStrategyEnumType& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SurfaceOfRevolutionPointSamplingStrategyEnumType&
      operator= (const SurfaceOfRevolutionPointSamplingStrategyEnumType&) = default;
#endif

      virtual SurfaceOfRevolutionPointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionPointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const* _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_literals_;
      static const value _xsd_SurfaceOfRevolutionPointSamplingStrategyEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL PlanePointSamplingStrategyEnumType: public ::xsd::qif30::PointSamplingStrategyEnumBaseType
    {
      public:
      typedef ::xsd::qif30::PointSamplingStrategyEnumBaseType::value value;

      PlanePointSamplingStrategyEnumType ();

      PlanePointSamplingStrategyEnumType (value v);

      PlanePointSamplingStrategyEnumType (const wchar_t* v);

      PlanePointSamplingStrategyEnumType (const ::std::wstring& v);

      PlanePointSamplingStrategyEnumType (const ::xsd::qif30::PointSamplingStrategyEnumBaseType& v);

      PlanePointSamplingStrategyEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PlanePointSamplingStrategyEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PlanePointSamplingStrategyEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PlanePointSamplingStrategyEnumType (const PlanePointSamplingStrategyEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      PlanePointSamplingStrategyEnumType&
      operator= (const PlanePointSamplingStrategyEnumType&) = default;
#endif

      virtual PlanePointSamplingStrategyEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlanePointSamplingStrategyEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PlanePointSamplingStrategyEnumType_convert ();
      }

      protected:
      value
      _xsd_PlanePointSamplingStrategyEnumType_convert () const;

      public:
      static const wchar_t* const* _xsd_PlanePointSamplingStrategyEnumType_literals_;
      static const value _xsd_PlanePointSamplingStrategyEnumType_indexes_[7];
    };

    class QIF30_SYMBOL_DECL CharacteristicTypeEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ANGLE,
        ANGLEBETWEEN,
        ANGLECOORDINATE,
        ANGLEFROM,
        ANGULARITY,
        CHORD,
        CIRCULARITY,
        CIRCULARRUNOUT,
        CONCENTRICITY,
        CONICALTAPER,
        CONICITY,
        CURVELENGTH,
        CYLINDRICITY,
        DEPTH,
        DIAMETER,
        DISTANCE,
        DISTANCEFROM,
        ELLIPTICITY,
        FLATTAPER,
        FLATNESS,
        HEIGHT,
        LENGTH,
        LENGTHCOORDINATE,
        LINEPROFILE,
        OTHERFORM,
        PERPENDICULARITY,
        PARALLELISM,
        POINTPROFILE,
        POSITION,
        RADIUS,
        SPHERICALDIAMTER,
        SPHERICALRADIUS,
        SPHERICITY,
        SQUARE,
        STRAIGHTNESS,
        SURFACEPROFILE,
        SURFACEPROFILENONUNIFORM,
        SYMMETRY,
        THICKNESS,
        THREAD,
        TOROIDICITY,
        TOTALRUNOUT,
        WELDBEVEL,
        WELDEDGE,
        WELDFILLET,
        WELDFLAREBEVEL,
        WELDFLAREV,
        WELDJ,
        WELDPLUG,
        WELDSCARF,
        WELDSEAM,
        WELDSLOT,
        WELDSPOT,
        WELDSQUARE,
        WELDSTUD,
        WELDSURFACING,
        WELDU,
        WELDV,
        WIDTH
      };

      CharacteristicTypeEnumType ();

      CharacteristicTypeEnumType (value v);

      CharacteristicTypeEnumType (const wchar_t* v);

      CharacteristicTypeEnumType (const ::std::wstring& v);

      CharacteristicTypeEnumType (const ::xml_schema::nmtoken& v);

      CharacteristicTypeEnumType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CharacteristicTypeEnumType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CharacteristicTypeEnumType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CharacteristicTypeEnumType (const CharacteristicTypeEnumType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CharacteristicTypeEnumType&
      operator= (const CharacteristicTypeEnumType&) = default;
#endif

      virtual CharacteristicTypeEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicTypeEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CharacteristicTypeEnumType_convert ();
      }

      protected:
      value
      _xsd_CharacteristicTypeEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CharacteristicTypeEnumType_literals_[59];
      static const value _xsd_CharacteristicTypeEnumType_indexes_[59];
    };

    class QIF30_SYMBOL_DECL FeatureTypeEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        CIRCLE,
        CIRCULARARC,
        CONE,
        CONICALSEGMENT,
        CYLINDER,
        CYLINDRICALSEGMENT,
        EDGEPOINT,
        ELLIPSE,
        ELLIPTICALARC,
        ELONGATEDCIRCLE,
        ELONGATEDCYLINDER,
        EXTRUDEDCROSSSECTION,
        GROUP,
        LINE,
        MARKING,
        OPPOSITEANGLEDLINES,
        OPPOSITEPARALLELLINES,
        OPPOSITEANGLEDPLANES,
        OPPOSITEPARALLELPLANES,
        OTHERCURVE,
        OTHERNONSHAPE,
        OTHERSHAPE,
        OTHERSURFACE,
        PATTERN,
        PATTERNCIRCLE,
        PATTERNCIRCULARARC,
        PATTERNLINEAR,
        PATTERNPARALLELOGRAM,
        PLANE,
        POINT,
        POINTDEFINEDCURVE,
        POINTDEFINEDSURFACE,
        SPHERE,
        SPHERICALSEGMENT,
        SURFACEOFREVOLUTION,
        THREADED,
        TOROIDALSEGMENT,
        TORUS
      };

      FeatureTypeEnumType ();

      FeatureTypeEnumType (value v);

      FeatureTypeEnumType (const wchar_t* v);

      FeatureTypeEnumType (const ::std::wstring& v);

      FeatureTypeEnumType (const ::xml_schema::nmtoken& v);

      FeatureTypeEnumType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FeatureTypeEnumType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FeatureTypeEnumType (const ::std::wstring& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FeatureTypeEnumType (const FeatureTypeEnumType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      FeatureTypeEnumType&
      operator= (const FeatureTypeEnumType&) = default;
#endif

      virtual FeatureTypeEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureTypeEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_FeatureTypeEnumType_convert ();
      }

      protected:
      value
      _xsd_FeatureTypeEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_FeatureTypeEnumType_literals_[38];
      static const value _xsd_FeatureTypeEnumType_indexes_[38];
    };

    class QIF30_SYMBOL_DECL DMEClassNameEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        AACMM,
        ALLDMES,
        ANALOG_MICROMETER,
        AUTOCOLLIMATOR,
        CALIPER,
        CAPACITIVE_SENSOR,
        CARTESIAN_CMM,
        CHARGE_COUPLED_DEVICE_CAMERA_SENSOR,
        CMM,
        COMPLEX_TACTILE_PROBE_SENSOR,
        COMPUTED_TOMOGRAPHY,
        CONFOCAL_CHROMATIC_SENSOR,
        DIAL_CALIPER,
        DIGITAL_CALIPER,
        DIGITAL_MICROMETER,
        DRAW_WIRE_SENSOR,
        DVRT_SENSOR,
        EDDY_CURRENT_SENSOR,
        GAGE,
        LASER_RADAR,
        LASER_TRACKER,
        LASER_TRIANGULATION_SENSOR,
        LIGHT_PEN_CMM,
        LVDT_SENSOR,
        MAGNETO_INDUCTIVE_SENSOR,
        MEASUREMENT_ROOM,
        MICROMETER,
        MICROSCOPE,
        MULTIPLE_CARRIAGE_CARTESIAN_CMM,
        OPTICAL_COMPARATOR,
        PARALLEL_LINK_CMM,
        PROBE_TIP,
        SIMPLE_TACTILE_PROBE_SENSOR,
        SINE_BAR,
        STRUCTURED_LIGHT_SENSOR,
        TACTILE_PROBE_SENSOR,
        THEODOLITE,
        TOOL_WITH_CCD_CAMERA_SENSOR,
        TOOL_WITH_CAPACITIVE_SENSOR,
        TOOL_WITH_COMPLEX_TACTILE_PROBE_SENSOR,
        TOOL_WITH_CONFOCAL_CHROMATIC_SENSOR,
        TOOL_WITH_DETACHABLE_SENSORS,
        TOOL_WITH_DVRT_SENSOR,
        TOOL_WITH_DRAW_WIRE_SENSOR,
        TOOL_WITH_EDDY_CURRENT_SENSOR,
        TOOL_WITH_INTEGRATED_SENSOR,
        TOOL_WITH_LVDT_SENSOR,
        TOOL_WITH_LASER_TRIANGULATION_SENSOR,
        TOOL_WITH_MAGNETOINDUCTIVE_SENSOR,
        TOOL_WITH_SIMPLE_TACTILE_PROBE_SENSOR,
        TOOL_WITH_STRUCTURED_LIGHT_SENSOR,
        TOOL_WITH_ULTRASONIC_SENSOR,
        ULTRASONIC_SENSOR,
        UNIVERSAL_DEVICE,
        UNIVERSAL_LENGTH_MEASURING
      };

      DMEClassNameEnumType ();

      DMEClassNameEnumType (value v);

      DMEClassNameEnumType (const wchar_t* v);

      DMEClassNameEnumType (const ::std::wstring& v);

      DMEClassNameEnumType (const ::xml_schema::nmtoken& v);

      DMEClassNameEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DMEClassNameEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DMEClassNameEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DMEClassNameEnumType (const DMEClassNameEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DMEClassNameEnumType&
      operator= (const DMEClassNameEnumType&) = default;
#endif

      virtual DMEClassNameEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMEClassNameEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DMEClassNameEnumType_convert ();
      }

      protected:
      value
      _xsd_DMEClassNameEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DMEClassNameEnumType_literals_[55];
      static const value _xsd_DMEClassNameEnumType_indexes_[55];
    };

    class QIF30_SYMBOL_DECL ArithmeticComparisonEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        EQUAL,
        GREATER,
        GREATEROREQUAL,
        LESS,
        LESSOREQUAL
      };

      ArithmeticComparisonEnumType ();

      ArithmeticComparisonEnumType (value v);

      ArithmeticComparisonEnumType (const wchar_t* v);

      ArithmeticComparisonEnumType (const ::std::wstring& v);

      ArithmeticComparisonEnumType (const ::xml_schema::nmtoken& v);

      ArithmeticComparisonEnumType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ArithmeticComparisonEnumType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ArithmeticComparisonEnumType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ArithmeticComparisonEnumType (const ArithmeticComparisonEnumType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ArithmeticComparisonEnumType&
      operator= (const ArithmeticComparisonEnumType&) = default;
#endif

      virtual ArithmeticComparisonEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArithmeticComparisonEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ArithmeticComparisonEnumType_convert ();
      }

      protected:
      value
      _xsd_ArithmeticComparisonEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ArithmeticComparisonEnumType_literals_[5];
      static const value _xsd_ArithmeticComparisonEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL ArithmeticParameterBaseType: public ::xsd::qif30::ArithmeticExpressionBaseType
    {
      public:
      // Parameter
      //
      typedef ::xml_schema::token Parameter_type;
      typedef ::xsd::cxx::tree::traits< Parameter_type, wchar_t > Parameter_traits;

      const Parameter_type&
      Parameter () const;

      Parameter_type&
      Parameter ();

      void
      Parameter (const Parameter_type& x);

      void
      Parameter (::std::unique_ptr< Parameter_type > p);

      // Constructors.
      //
      ArithmeticParameterBaseType ();

      ArithmeticParameterBaseType (const Parameter_type&);

      ArithmeticParameterBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ArithmeticParameterBaseType (const ArithmeticParameterBaseType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ArithmeticParameterBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ArithmeticParameterBaseType&
      operator= (const ArithmeticParameterBaseType& x);

      virtual 
      ~ArithmeticParameterBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Parameter_type > Parameter_;
    };

    class QIF30_SYMBOL_DECL ArithmeticFeatureParameterType: public ::xsd::qif30::ArithmeticParameterBaseType
    {
      public:
      // FeatureTypeEnum
      //
      typedef ::xsd::qif30::FeatureTypeEnumType FeatureTypeEnum_type;
      typedef ::xsd::cxx::tree::optional< FeatureTypeEnum_type > FeatureTypeEnum_optional;
      typedef ::xsd::cxx::tree::traits< FeatureTypeEnum_type, wchar_t > FeatureTypeEnum_traits;

      const FeatureTypeEnum_optional&
      FeatureTypeEnum () const;

      FeatureTypeEnum_optional&
      FeatureTypeEnum ();

      void
      FeatureTypeEnum (const FeatureTypeEnum_type& x);

      void
      FeatureTypeEnum (const FeatureTypeEnum_optional& x);

      void
      FeatureTypeEnum (::std::unique_ptr< FeatureTypeEnum_type > p);

      // Constructors.
      //
      ArithmeticFeatureParameterType ();

      ArithmeticFeatureParameterType (const Parameter_type&);

      ArithmeticFeatureParameterType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ArithmeticFeatureParameterType (const ArithmeticFeatureParameterType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ArithmeticFeatureParameterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArithmeticFeatureParameterType&
      operator= (const ArithmeticFeatureParameterType& x);

      virtual 
      ~ArithmeticFeatureParameterType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureTypeEnum_optional FeatureTypeEnum_;
    };

    class QIF30_SYMBOL_DECL ArithmeticCharacteristicParameterType: public ::xsd::qif30::ArithmeticParameterBaseType
    {
      public:
      // CharacteristicTypeEnum
      //
      typedef ::xsd::qif30::CharacteristicTypeEnumType CharacteristicTypeEnum_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicTypeEnum_type > CharacteristicTypeEnum_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicTypeEnum_type, wchar_t > CharacteristicTypeEnum_traits;

      const CharacteristicTypeEnum_optional&
      CharacteristicTypeEnum () const;

      CharacteristicTypeEnum_optional&
      CharacteristicTypeEnum ();

      void
      CharacteristicTypeEnum (const CharacteristicTypeEnum_type& x);

      void
      CharacteristicTypeEnum (const CharacteristicTypeEnum_optional& x);

      void
      CharacteristicTypeEnum (::std::unique_ptr< CharacteristicTypeEnum_type > p);

      // Constructors.
      //
      ArithmeticCharacteristicParameterType ();

      ArithmeticCharacteristicParameterType (const Parameter_type&);

      ArithmeticCharacteristicParameterType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ArithmeticCharacteristicParameterType (const ArithmeticCharacteristicParameterType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ArithmeticCharacteristicParameterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArithmeticCharacteristicParameterType&
      operator= (const ArithmeticCharacteristicParameterType& x);

      virtual 
      ~ArithmeticCharacteristicParameterType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicTypeEnum_optional CharacteristicTypeEnum_;
    };

    class QIF30_SYMBOL_DECL ArithmeticDMEParameterType: public ::xsd::qif30::ArithmeticParameterBaseType
    {
      public:
      // DMEClassNameEnum
      //
      typedef ::xsd::qif30::DMEClassNameEnumType DMEClassNameEnum_type;
      typedef ::xsd::cxx::tree::traits< DMEClassNameEnum_type, wchar_t > DMEClassNameEnum_traits;

      const DMEClassNameEnum_type&
      DMEClassNameEnum () const;

      DMEClassNameEnum_type&
      DMEClassNameEnum ();

      void
      DMEClassNameEnum (const DMEClassNameEnum_type& x);

      void
      DMEClassNameEnum (::std::unique_ptr< DMEClassNameEnum_type > p);

      // Constructors.
      //
      ArithmeticDMEParameterType ();

      ArithmeticDMEParameterType (const Parameter_type&,
                                  const DMEClassNameEnum_type&);

      ArithmeticDMEParameterType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ArithmeticDMEParameterType (const ArithmeticDMEParameterType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ArithmeticDMEParameterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArithmeticDMEParameterType&
      operator= (const ArithmeticDMEParameterType& x);

      virtual 
      ~ArithmeticDMEParameterType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DMEClassNameEnum_type > DMEClassNameEnum_;
    };

    class QIF30_SYMBOL_DECL ArithmeticPartParameterType: public ::xsd::qif30::ArithmeticParameterBaseType
    {
      public:
      // Constructors.
      //
      ArithmeticPartParameterType ();

      ArithmeticPartParameterType (const Parameter_type&);

      ArithmeticPartParameterType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ArithmeticPartParameterType (const ArithmeticPartParameterType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ArithmeticPartParameterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ArithmeticPartParameterType&
      operator= (const ArithmeticPartParameterType&) = default;
#endif

      virtual 
      ~ArithmeticPartParameterType ();
    };

    class QIF30_SYMBOL_DECL CharacteristicToleranceType: public ::xsd::qif30::ArithmeticExpressionBaseType
    {
      public:
      // Constructors.
      //
      CharacteristicToleranceType ();

      CharacteristicToleranceType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      CharacteristicToleranceType (const xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      CharacteristicToleranceType (const ::std::wstring& s,
                                   const xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      CharacteristicToleranceType (const CharacteristicToleranceType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual CharacteristicToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CharacteristicToleranceType&
      operator= (const CharacteristicToleranceType&) = default;
#endif

      virtual 
      ~CharacteristicToleranceType ();
    };

    class QIF30_SYMBOL_DECL FeatureLengthType: public ::xsd::qif30::ArithmeticExpressionBaseType
    {
      public:
      // Constructors.
      //
      FeatureLengthType ();

      FeatureLengthType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      FeatureLengthType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      FeatureLengthType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      FeatureLengthType (const FeatureLengthType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual FeatureLengthType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FeatureLengthType&
      operator= (const FeatureLengthType&) = default;
#endif

      virtual 
      ~FeatureLengthType ();
    };

    class QIF30_SYMBOL_DECL FeatureAreaType: public ::xsd::qif30::ArithmeticExpressionBaseType
    {
      public:
      // Constructors.
      //
      FeatureAreaType ();

      FeatureAreaType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      FeatureAreaType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      FeatureAreaType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      FeatureAreaType (const FeatureAreaType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual FeatureAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FeatureAreaType&
      operator= (const FeatureAreaType&) = default;
#endif

      virtual 
      ~FeatureAreaType ();
    };

    class QIF30_SYMBOL_DECL FeatureSizeType: public ::xsd::qif30::ArithmeticExpressionBaseType
    {
      public:
      // Constructors.
      //
      FeatureSizeType ();

      FeatureSizeType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      FeatureSizeType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      FeatureSizeType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      FeatureSizeType (const FeatureSizeType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual FeatureSizeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FeatureSizeType&
      operator= (const FeatureSizeType&) = default;
#endif

      virtual 
      ~FeatureSizeType ();
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SamplingCategoryIsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureIsDatumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const FeatureIsDatumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const FeatureIsDatumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureIsInternalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const FeatureIsInternalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const FeatureIsInternalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicIsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureTypeIsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ShapeClassIsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointSamplingStrategyEnumBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PointSamplingStrategyEnumBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PointSamplingStrategyEnumBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PointPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PointPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OpenCurvePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const OpenCurvePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const OpenCurvePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ClosedCurvePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ClosedCurvePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ClosedCurvePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PointDefinedPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PointDefinedPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ConePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ConePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ElongatedCylinderPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ElongatedCylinderPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ExtrudedCrossSectionPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ExtrudedCrossSectionPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpherePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SpherePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SpherePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SurfaceOfRevolutionPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SurfaceOfRevolutionPointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlanePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PlanePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PlanePointSamplingStrategyEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicTypeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CharacteristicTypeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CharacteristicTypeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureTypeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const FeatureTypeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const FeatureTypeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DMEClassNameEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DMEClassNameEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DMEClassNameEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArithmeticComparisonEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ArithmeticComparisonEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ArithmeticComparisonEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArithmeticParameterBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArithmeticFeatureParameterType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArithmeticCharacteristicParameterType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArithmeticDMEParameterType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArithmeticPartParameterType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CharacteristicToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CharacteristicToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const FeatureLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const FeatureLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const FeatureAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const FeatureAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureSizeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const FeatureSizeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const FeatureSizeType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_EXPRESSIONS_HXX
