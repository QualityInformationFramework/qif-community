// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_FEATURES_HXX
#define CXX___QIFLIBRARY_FEATURES_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class FeatureBaseType;
    class FeatureItemBaseType;
    class ShapeFeatureItemBaseType;
    class NonShapeFeatureItemBaseType;
    class FeatureDefinitionBaseType;
    class ShapeFeatureDefinitionBaseType;
    class NonShapeFeatureDefinitionBaseType;
    class PointSetNominalType;
    class NominalPointSetListType;
    class FeatureNominalBaseType;
    class ShapeFeatureNominalBaseType;
    class NonShapeFeatureNominalBaseType;
    class MeasuredPointSetsType;
    class PointListType;
    class MeasuredPointSetType;
    class FeatureMeasurementBaseType;
    class ShapeFeatureMeasurementBaseType;
    class NonShapeFeatureMeasurementBaseType;
    class SetFeatureType;
    class MeasuredFeatureType;
    class ConstructionMethodBaseType;
    class PointRangeType;
    class PointIndexType;
    class BaseFeaturePointSetType;
    class BaseFeaturePointListType;
    class TransformationReferenceType;
    class SurfaceFeatureItemBaseType;
    class SurfaceFeatureDefinitionBaseType;
    class SurfaceFeatureNominalBaseType;
    class SurfaceFeatureMeasurementBaseType;
    class CurveFeatureItemBaseType;
    class CurveFeatureDefinitionBaseType;
    class CurveFeatureNominalBaseType;
    class CurveFeatureMeasurementBaseType;
    class PointFeatureItemBaseType;
    class PointFeatureDefinitionBaseType;
    class PointFeatureNominalBaseType;
    class PointFeatureMeasurementBaseType;
    class SpecifiedFeatureItemBaseType;
    class SpecifiedFeatureDefinitionBaseType;
    class SpecifiedFeatureNominalBaseType;
    class SpecifiedFeatureMeasurementBaseType;
    class CircleConstructionMethodType;
    class CircleBestFitType;
    class CircleRecompType;
    class CircleIntersectionType;
    class CircleProjectionType;
    class CircleCopyType;
    class CircleCastType;
    class CircleTangentType;
    class CircleTangentThroughType;
    class CircleTransformType;
    class CircleFromConeType;
    class CircleFromScanType;
    class CircleCheckedType;
    class CircleCheckedFeatureType;
    class CircleMeasurementDeterminationType;
    class CircleFeatureItemType;
    class CircleFeatureDefinitionType;
    class CircleFeatureNominalType;
    class CircleFeatureMeasurementType;
    class CircularArcConstructionMethodType;
    class CircularArcBestFitType;
    class CircularArcRecompType;
    class CircularArcProjectionType;
    class CircularArcCopyType;
    class CircularArcCastType;
    class CircularArcTransformType;
    class CircularArcFromScanType;
    class CircularArcIntersectionType;
    class CircularArcExtractType;
    class CircularArcCheckedType;
    class CircularArcCheckedFeatureType;
    class CircularArcMeasurementDeterminationType;
    class CircularArcFeatureItemType;
    class CircularArcFeatureDefinitionType;
    class CircularArcFeatureNominalType;
    class CircularArcFeatureMeasurementType;
    class ConeConstructionMethodType;
    class ConeBestFitType;
    class ConeRecompType;
    class ConeCopyType;
    class ConeCastType;
    class ConeTransformType;
    class ConeFromScanType;
    class ConeCheckedType;
    class ConeCheckedFeatureType;
    class ConeMeasurementDeterminationType;
    class ConeFeatureItemType;
    class ConeFeatureDefinitionType;
    class ConeFeatureNominalType;
    class ConeFeatureMeasurementType;
    class ConicalSegmentConstructionMethodType;
    class ConicalSegmentBestFitType;
    class ConicalSegmentRecompType;
    class ConicalSegmentCopyType;
    class ConicalSegmentCastType;
    class ConicalSegmentTransformType;
    class ConicalSegmentCheckedType;
    class ConicalSegmentCheckedFeatureType;
    class ConicalSegmentMeasurementDeterminationType;
    class ConicalSegmentFeatureItemType;
    class ConicalSegmentFeatureDefinitionType;
    class ConicalSegmentFeatureNominalType;
    class ConicalSegmentFeatureMeasurementType;
    class CylinderConstructionMethodType;
    class CylinderBestFitType;
    class CylinderRecompType;
    class CylinderCopyType;
    class CylinderCastType;
    class CylinderTransformType;
    class CylinderFromScanType;
    class CylinderCheckedType;
    class CylinderCheckedFeatureType;
    class CylinderMeasurementDeterminationType;
    class CylinderFeatureItemType;
    class CylinderFeatureDefinitionType;
    class CylinderFeatureNominalType;
    class CylinderFeatureMeasurementType;
    class CylindricalSegmentConstructionMethodType;
    class CylindricalSegmentBestFitType;
    class CylindricalSegmentRecompType;
    class CylindricalSegmentCopyType;
    class CylindricalSegmentCastType;
    class CylindricalSegmentTransformType;
    class CylindricalSegmentCheckedType;
    class CylindricalSegmentCheckedFeatureType;
    class CylindricalSegmentMeasurementDeterminationType;
    class CylindricalSegmentFeatureItemType;
    class CylindricalSegmentFeatureDefinitionType;
    class CylindricalSegmentFeatureNominalType;
    class CylindricalSegmentFeatureMeasurementType;
    class EdgePointConstructionMethodType;
    class EdgePointCopyType;
    class EdgePointCastType;
    class EdgePointTransformType;
    class EdgePointFromScanType;
    class EdgePointCheckedType;
    class EdgePointCheckedFeatureType;
    class EdgePointMeasurementDeterminationType;
    class EdgePointFeatureItemType;
    class EdgePointFeatureDefinitionType;
    class EdgePointFeatureNominalType;
    class EdgePointFeatureMeasurementType;
    class EllipseConstructionMethodType;
    class EllipseBestFitType;
    class EllipseRecompType;
    class EllipseProjectionType;
    class EllipseIntersectionType;
    class EllipseCopyType;
    class EllipseCastType;
    class EllipseTransformType;
    class EllipseFromScanType;
    class EllipseCheckedType;
    class EllipseCheckedFeatureType;
    class EllipseMeasurementDeterminationType;
    class EllipseFeatureItemType;
    class EllipseFeatureDefinitionType;
    class EllipseFeatureNominalType;
    class EllipseFeatureMeasurementType;
    class EllipticalArcConstructionMethodType;
    class EllipticalArcBestFitType;
    class EllipticalArcRecompType;
    class EllipticalArcProjectionType;
    class EllipticalArcIntersectionType;
    class EllipticalArcCopyType;
    class EllipticalArcCastType;
    class EllipticalArcTransformType;
    class EllipticalArcFromScanType;
    class EllipticalArcCheckedType;
    class EllipticalArcCheckedFeatureType;
    class EllipticalArcMeasurementDeterminationType;
    class EllipticalArcFeatureItemType;
    class EllipticalArcFeatureDefinitionType;
    class EllipticalArcFeatureNominalType;
    class EllipticalArcFeatureMeasurementType;
    class ElongatedCircleConstructionMethodType;
    class ElongatedCircleBestFitType;
    class ElongatedCircleRecompType;
    class ElongatedCircleCopyType;
    class ElongatedCircleCastType;
    class ElongatedCircleTransformType;
    class ElongatedCircleCheckedType;
    class ElongatedCircleCheckedFeatureType;
    class ElongatedCircleMeasurementDeterminationType;
    class ElongatedCircleFeatureItemType;
    class ElongatedCircleFeatureDefinitionType;
    class ElongatedCircleFeatureNominalType;
    class ElongatedCircleFeatureMeasurementType;
    class ElongatedCylinderConstructionMethodType;
    class ElongatedCylinderBestFitType;
    class ElongatedCylinderRecompType;
    class ElongatedCylinderCopyType;
    class ElongatedCylinderCastType;
    class ElongatedCylinderTransformType;
    class ElongatedCylinderCheckedType;
    class ElongatedCylinderCheckedFeatureType;
    class ElongatedCylinderMeasurementDeterminationType;
    class ElongatedCylinderFeatureItemType;
    class ElongatedCylinderFeatureDefinitionType;
    class ElongatedCylinderFeatureNominalType;
    class ElongatedCylinderFeatureMeasurementType;
    class ExtrudedCrossSectionConstructionMethodType;
    class ExtrudedCrossSectionBestFitType;
    class ExtrudedCrossSectionRecompType;
    class ExtrudedCrossSectionCopyType;
    class ExtrudedCrossSectionCastType;
    class ExtrudedCrossSectionTransformType;
    class ExtrudedCrossSectionCheckedType;
    class ExtrudedCrossSectionCheckedFeatureType;
    class ExtrudedCrossSectionMeasurementDeterminationType;
    class ExtrudedCrossSectionFeatureItemType;
    class ExtrudedCrossSectionFeatureDefinitionType;
    class ExtrudedCrossSectionFeatureNominalType;
    class ExtrudedCrossSectionFeatureMeasurementType;
    class LineConstructionMethodType;
    class LineBestFitType;
    class LineRecompType;
    class LineMidlineType;
    class LineIntersectionType;
    class LineProjectionType;
    class LinePerpendicularType;
    class LineParallelType;
    class LineCopyType;
    class LineCastType;
    class LineTangentThroughType;
    class LineTransformType;
    class LineFromScanType;
    class LineExtractType;
    class LineCheckedType;
    class LineCheckedFeatureType;
    class LineMeasurementDeterminationType;
    class LineFeatureItemType;
    class LineFeatureDefinitionType;
    class LineFeatureNominalType;
    class LineFeatureMeasurementType;
    class OppositeParallelLinesConstructionMethodType;
    class OppositeParallelLinesBestFitType;
    class OppositeParallelLinesRecompType;
    class OppositeParallelLinesIntersectionType;
    class OppositeParallelLinesProjectionType;
    class OppositeParallelLinesCopyType;
    class OppositeParallelLinesCastType;
    class OppositeParallelLinesTransformType;
    class OppositeParallelLinesFromScanType;
    class OppositeParallelLinesCheckedType;
    class OppositeParallelLinesCheckedFeatureType;
    class OppositeParallelLinesMeasurementDeterminationType;
    class OppositeParallelLinesFeatureItemType;
    class OppositeParallelLinesFeatureDefinitionType;
    class OppositeParallelLinesFeatureNominalType;
    class OppositeParallelLinesFeatureMeasurementType;
    class OppositeAngledLinesConstructionMethodType;
    class OppositeAngledLinesBestFitType;
    class OppositeAngledLinesRecompType;
    class OppositeAngledLinesIntersectionType;
    class OppositeAngledLinesProjectionType;
    class OppositeAngledLinesCopyType;
    class OppositeAngledLinesCastType;
    class OppositeAngledLinesTransformType;
    class OppositeAngledLinesFromScanType;
    class OppositeAngledLinesCheckedType;
    class OppositeAngledLinesCheckedFeatureType;
    class OppositeAngledLinesMeasurementDeterminationType;
    class OppositeAngledLinesFeatureItemType;
    class OppositeAngledLinesFeatureDefinitionType;
    class OppositeAngledLinesFeatureNominalType;
    class OppositeAngledLinesFeatureMeasurementType;
    class OppositeParallelPlanesConstructionMethodType;
    class OppositeParallelPlanesBestFitType;
    class OppositeParallelPlanesRecompType;
    class OppositeParallelPlanesCopyType;
    class OppositeParallelPlanesCastType;
    class OppositeParallelPlanesTransformType;
    class OppositeParallelPlanesFromScanType;
    class OppositeParallelPlanesCheckedType;
    class OppositeParallelPlanesCheckedFeatureType;
    class OppositeParallelPlanesMeasurementDeterminationType;
    class OppositeParallelPlanesFeatureItemType;
    class OppositeParallelPlanesFeatureDefinitionType;
    class OppositeParallelPlanesFeatureNominalType;
    class OppositeParallelPlanesFeatureMeasurementType;
    class OppositeAngledPlanesConstructionMethodType;
    class OppositeAngledPlanesBestFitType;
    class OppositeAngledPlanesRecompType;
    class OppositeAngledPlanesCopyType;
    class OppositeAngledPlanesCastType;
    class OppositeAngledPlanesTransformType;
    class OppositeAngledPlanesFromScanType;
    class OppositeAngledPlanesCheckedType;
    class OppositeAngledPlanesCheckedFeatureType;
    class OppositeAngledPlanesMeasurementDeterminationType;
    class OppositeAngledPlanesFeatureItemType;
    class OppositeAngledPlanesFeatureDefinitionType;
    class OppositeAngledPlanesFeatureNominalType;
    class OppositeAngledPlanesFeatureMeasurementType;
    class OtherCurveConstructionMethodType;
    class OtherCurveFeatureCopyType;
    class OtherCurveCheckedType;
    class OtherCurveCheckedFeatureType;
    class OtherCurveMeasurementDeterminationType;
    class OtherCurveFeatureItemType;
    class OtherCurveFeatureDefinitionType;
    class OtherCurveFeatureNominalType;
    class OtherCurveFeatureMeasurementType;
    class OtherNonShapeFeatureItemType;
    class OtherNonShapeFeatureDefinitionType;
    class OtherNonShapeFeatureNominalType;
    class OtherNonShapeFeatureMeasurementType;
    class MarkingMethodEnumType;
    class MarkingMethodType;
    class MarkingFeatureItemType;
    class MarkingFeatureDefinitionType;
    class MarkingFeatureNominalType;
    class MarkingFeatureMeasurementType;
    class OtherShapeConstructionMethodType;
    class OtherShapeFeatureCopyType;
    class OtherShapeCheckedType;
    class OtherShapeCheckedFeatureType;
    class OtherShapeMeasurementDeterminationType;
    class OtherShapeFeatureItemType;
    class OtherShapeFeatureDefinitionType;
    class OtherShapeFeatureNominalType;
    class OtherShapeFeatureMeasurementType;
    class OtherSurfaceConstructionMethodType;
    class OtherSurfaceFeatureCopyType;
    class OtherSurfaceCheckedType;
    class OtherSurfaceCheckedFeatureType;
    class OtherSurfaceMeasurementDeterminationType;
    class OtherSurfaceFeatureItemType;
    class OtherSurfaceFeatureDefinitionType;
    class OtherSurfaceFeatureNominalType;
    class OtherSurfaceFeatureMeasurementType;
    class PlaneConstructionMethodType;
    class PlaneBestFitType;
    class PlaneRecompType;
    class PlaneMidplaneType;
    class PlaneOffsetType;
    class PlanePerpendicularType;
    class PlaneParallelType;
    class PlaneCopyType;
    class PlaneCastType;
    class PlaneTangentThroughType;
    class PlaneThroughType;
    class PlaneTransformType;
    class PlaneExtractType;
    class PlaneCheckedType;
    class PlaneCheckedFeatureType;
    class PlaneMeasurementDeterminationType;
    class PlaneFeatureItemType;
    class PlaneFeatureDefinitionType;
    class PlaneFeatureNominalType;
    class PlaneFeatureMeasurementType;
    class PointDefinedCurveConstructionMethodType;
    class PointDefinedCurveBestFitType;
    class PointDefinedCurveRecompType;
    class PointDefinedCurveCopyType;
    class PointDefinedCurveTransformType;
    class PointDefinedCurveFromScanType;
    class PointDefinedCurveExtractType;
    class PointDefinedCurveCheckedType;
    class PointDefinedCurveCheckedFeatureType;
    class PointDefinedCurveMeasurementDeterminationType;
    class PointDefinedCurveFeatureItemType;
    class PointDefinedCurveFeatureDefinitionType;
    class PointDefinedCurveFeatureNominalType;
    class DefiningPointsMeasurementType;
    class PointDefinedCurveFeatureMeasurementType;
    class PointDefinedSurfaceConstructionMethodType;
    class PointDefinedSurfaceBestFitType;
    class PointDefinedSurfaceRecompType;
    class PointDefinedSurfaceCopyType;
    class PointDefinedSurfaceTransformType;
    class PointDefinedSurfaceExtractType;
    class PointDefinedSurfaceCheckedType;
    class PointDefinedSurfaceCheckedFeatureType;
    class PointDefinedSurfaceMeasurementDeterminationType;
    class PointDefinedSurfaceFeatureItemType;
    class PointDefinedSurfaceFeatureDefinitionType;
    class DefiningPointsNominalType;
    class PointDefinedSurfaceFeatureNominalType;
    class PointDefinedSurfaceFeatureMeasurementType;
    class PointConstructionMethodType;
    class PointFeatureIntersectionType;
    class PointFeaturePierceType;
    class PointFeatureProjectionType;
    class PointFeatureFromConeType;
    class PointFeatureCopyType;
    class PointFeatureTransformType;
    class PointFeatureFromScanType;
    class PointFeatureCenterOfGravityType;
    class PointFeatureMidPointType;
    class PointFeatureCastType;
    class PointFeatureMovePointType;
    class PointFeatureMovePointVectorType;
    class PointFeatureMovePointAxisType;
    class PointFeatureExtremeType;
    class PointCheckedType;
    class PointCheckedFeatureType;
    class PointMeasurementDeterminationType;
    class PointFeatureItemType;
    class PointFeatureDefinitionType;
    class PointFeatureNominalType;
    class PointFeatureMeasurementType;
    class SphereConstructionMethodType;
    class SphereBestFitType;
    class SphereRecompType;
    class SphereCopyType;
    class SphereCastType;
    class SphereTransformType;
    class SphereFromScanType;
    class SphereCheckedType;
    class SphereCheckedFeatureType;
    class SphereMeasurementDeterminationType;
    class SphereFeatureItemType;
    class SphereFeatureDefinitionType;
    class SphereFeatureNominalType;
    class SphereFeatureMeasurementType;
    class SphericalSegmentConstructionMethodType;
    class SphericalSegmentBestFitType;
    class SphericalSegmentRecompType;
    class SphericalSegmentCopyType;
    class SphericalSegmentCastType;
    class SphericalSegmentTransformType;
    class SphericalSegmentCheckedType;
    class SphericalSegmentCheckedFeatureType;
    class SphericalSegmentMeasurementDeterminationType;
    class SphericalSegmentFeatureItemType;
    class SphericalSegmentFeatureDefinitionType;
    class SphericalSegmentFeatureNominalType;
    class SphericalSegmentFeatureMeasurementType;
    class SurfaceOfRevolutionConstructionMethodType;
    class SurfaceOfRevolutionBestFitType;
    class SurfaceOfRevolutionRecompType;
    class SurfaceOfRevolutionCopyType;
    class SurfaceOfRevolutionCastType;
    class SurfaceOfRevolutionTransformType;
    class SurfaceOfRevolutionCheckedType;
    class SurfaceOfRevolutionCheckedFeatureType;
    class SurfaceOfRevolutionMeasurementDeterminationType;
    class SurfaceOfRevolutionFeatureItemType;
    class SurfaceOfRevolutionFeatureDefinitionType;
    class SurfaceOfRevolutionFeatureNominalType;
    class SurfaceOfRevolutionFeatureMeasurementType;
    class ThreadedFeatureConstructionMethodType;
    class ThreadedFeatureBestFitType;
    class ThreadedFeatureRecompType;
    class ThreadedFeatureCopyType;
    class ThreadedFeatureCastType;
    class ThreadedFeatureTransformType;
    class ThreadedFeatureFromCylinderType;
    class ThreadedFeatureCheckedType;
    class ThreadedFeatureCheckedFeatureType;
    class ThreadedFeatureMeasurementDeterminationType;
    class ThreadedFeatureItemType;
    class ThreadedFeatureDefinitionType;
    class ThreadedFeatureNominalType;
    class ThreadedFeatureMeasurementType;
    class ToroidalSegmentConstructionMethodType;
    class ToroidalSegmentBestFitType;
    class ToroidalSegmentRecompType;
    class ToroidalSegmentCopyType;
    class ToroidalSegmentCastType;
    class ToroidalSegmentTransformType;
    class ToroidalSegmentCheckedType;
    class ToroidalSegmentCheckedFeatureType;
    class ToroidalSegmentMeasurementDeterminationType;
    class ToroidalSegmentFeatureItemType;
    class ToroidalSegmentFeatureDefinitionType;
    class ToroidalSegmentFeatureNominalType;
    class ToroidalSegmentFeatureMeasurementType;
    class TorusConstructionMethodType;
    class TorusBestFitType;
    class TorusRecompType;
    class TorusCopyType;
    class TorusCastType;
    class TorusTransformType;
    class TorusFromScanType;
    class TorusCheckedType;
    class TorusCheckedFeatureType;
    class TorusMeasurementDeterminationType;
    class TorusFeatureItemType;
    class TorusFeatureDefinitionType;
    class TorusFeatureNominalType;
    class TorusFeatureMeasurementType;
    class GroupFeatureItemType;
    class GroupFeatureDefinitionType;
    class GroupFeatureNominalType;
    class GroupFeatureMeasurementType;
    class PatternFeatureItemBaseType;
    class PatternFeatureDefinitionBaseType;
    class PatternFeatureNominalBaseType;
    class PatternFeatureLinearItemType;
    class PatternFeatureLinearDefinitionType;
    class PatternFeatureLinearNominalType;
    class PatternFeatureParallelogramItemType;
    class PatternFeatureParallelogramDefinitionType;
    class PatternFeatureParallelogramNominalType;
    class PatternFeatureCircularArcItemType;
    class PatternFeatureCircularArcDefinitionType;
    class PatternFeatureCircularArcNominalType;
    class PatternFeatureCircleItemType;
    class PatternFeatureCircleDefinitionType;
    class PatternFeatureCircleNominalType;
    class FeatureZoneBaseType;
    class FeatureZonePointType;
    class FeatureZoneCurveBaseType;
    class FeatureZoneCurveLineType;
    class FeatureZoneCurveCircularType;
    class FeatureZoneCurveIrregularType;
    class FeatureZoneAreaBaseType;
    class FeatureZoneAreaCircularType;
    class FeatureZoneAreaRectangularType;
    class FeatureZoneAreaIrregularType;
    class FeatureZoneAreaCylindricalType;
    class FeatureZoneAreaBetweenType;
    class FeatureZoneAreaSphericalType;
    class FeatureAspectsListsType;
    class FeatureDefinitionsType;
    class FeatureNominalsType;
    class FeatureItemsType;
    class FeatureMeasurementsType;
    class FeatureZoneListType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/IntermediatesPMI.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL FeatureBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      FeatureBaseType ();

      FeatureBaseType (const id_type&);

      FeatureBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      FeatureBaseType (const FeatureBaseType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual FeatureBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FeatureBaseType&
      operator= (const FeatureBaseType& x);

      virtual 
      ~FeatureBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL FeatureItemBaseType: public ::xsd::qif30::FeatureBaseType
    {
      public:
      // FeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType FeatureNominalId_type;
      typedef ::xsd::cxx::tree::traits< FeatureNominalId_type, wchar_t > FeatureNominalId_traits;

      const FeatureNominalId_type&
      FeatureNominalId () const;

      FeatureNominalId_type&
      FeatureNominalId ();

      void
      FeatureNominalId (const FeatureNominalId_type& x);

      void
      FeatureNominalId (::std::unique_ptr< FeatureNominalId_type > p);

      // ParentFeatureItemId
      //
      typedef ::xsd::qif30::QIFReferenceType ParentFeatureItemId_type;
      typedef ::xsd::cxx::tree::optional< ParentFeatureItemId_type > ParentFeatureItemId_optional;
      typedef ::xsd::cxx::tree::traits< ParentFeatureItemId_type, wchar_t > ParentFeatureItemId_traits;

      const ParentFeatureItemId_optional&
      ParentFeatureItemId () const;

      ParentFeatureItemId_optional&
      ParentFeatureItemId ();

      void
      ParentFeatureItemId (const ParentFeatureItemId_type& x);

      void
      ParentFeatureItemId (const ParentFeatureItemId_optional& x);

      void
      ParentFeatureItemId (::std::unique_ptr< ParentFeatureItemId_type > p);

      // FeatureName
      //
      typedef ::xml_schema::token FeatureName_type;
      typedef ::xsd::cxx::tree::traits< FeatureName_type, wchar_t > FeatureName_traits;

      const FeatureName_type&
      FeatureName () const;

      FeatureName_type&
      FeatureName ();

      void
      FeatureName (const FeatureName_type& x);

      void
      FeatureName (::std::unique_ptr< FeatureName_type > p);

      // UUID
      //
      typedef ::xsd::qif30::QPIdType UUID_type;
      typedef ::xsd::cxx::tree::optional< UUID_type > UUID_optional;
      typedef ::xsd::cxx::tree::traits< UUID_type, wchar_t > UUID_traits;

      const UUID_optional&
      UUID () const;

      UUID_optional&
      UUID ();

      void
      UUID (const UUID_type& x);

      void
      UUID (const UUID_optional& x);

      void
      UUID (::std::unique_ptr< UUID_type > p);

      // NotableEventIds
      //
      typedef ::xsd::qif30::ArrayReferenceType NotableEventIds_type;
      typedef ::xsd::cxx::tree::optional< NotableEventIds_type > NotableEventIds_optional;
      typedef ::xsd::cxx::tree::traits< NotableEventIds_type, wchar_t > NotableEventIds_traits;

      const NotableEventIds_optional&
      NotableEventIds () const;

      NotableEventIds_optional&
      NotableEventIds ();

      void
      NotableEventIds (const NotableEventIds_type& x);

      void
      NotableEventIds (const NotableEventIds_optional& x);

      void
      NotableEventIds (::std::unique_ptr< NotableEventIds_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // Constructors.
      //
      FeatureItemBaseType ();

      FeatureItemBaseType (const id_type&,
                           const FeatureNominalId_type&,
                           const FeatureName_type&);

      FeatureItemBaseType (const id_type&,
                           ::std::unique_ptr< FeatureNominalId_type >,
                           const FeatureName_type&);

      FeatureItemBaseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FeatureItemBaseType (const FeatureItemBaseType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual FeatureItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FeatureItemBaseType&
      operator= (const FeatureItemBaseType& x);

      virtual 
      ~FeatureItemBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureNominalId_type > FeatureNominalId_;
      ParentFeatureItemId_optional ParentFeatureItemId_;
      ::xsd::cxx::tree::one< FeatureName_type > FeatureName_;
      UUID_optional UUID_;
      NotableEventIds_optional NotableEventIds_;
      CoordinateSystemId_optional CoordinateSystemId_;
    };

    class QIF30_SYMBOL_DECL ShapeFeatureItemBaseType: public ::xsd::qif30::FeatureItemBaseType
    {
      public:
      // PointList
      //
      typedef ::xsd::qif30::PointListType PointList_type;
      typedef ::xsd::cxx::tree::optional< PointList_type > PointList_optional;
      typedef ::xsd::cxx::tree::traits< PointList_type, wchar_t > PointList_traits;

      const PointList_optional&
      PointList () const;

      PointList_optional&
      PointList ();

      void
      PointList (const PointList_type& x);

      void
      PointList (const PointList_optional& x);

      void
      PointList (::std::unique_ptr< PointList_type > p);

      // SubstituteFeatureAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType SubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithm_type > SubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithm_type, wchar_t > SubstituteFeatureAlgorithm_traits;

      const SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm () const;

      SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm ();

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x);

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x);

      void
      SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > p);

      // VirtualMeasurement
      //
      typedef ::xsd::qif30::VirtualMeasurementType VirtualMeasurement_type;
      typedef ::xsd::cxx::tree::optional< VirtualMeasurement_type > VirtualMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< VirtualMeasurement_type, wchar_t > VirtualMeasurement_traits;

      const VirtualMeasurement_optional&
      VirtualMeasurement () const;

      VirtualMeasurement_optional&
      VirtualMeasurement ();

      void
      VirtualMeasurement (const VirtualMeasurement_type& x);

      void
      VirtualMeasurement (const VirtualMeasurement_optional& x);

      void
      VirtualMeasurement (::std::unique_ptr< VirtualMeasurement_type > p);

      // Constructors.
      //
      ShapeFeatureItemBaseType ();

      ShapeFeatureItemBaseType (const id_type&,
                                const FeatureNominalId_type&,
                                const FeatureName_type&);

      ShapeFeatureItemBaseType (const id_type&,
                                ::std::unique_ptr< FeatureNominalId_type >,
                                const FeatureName_type&);

      ShapeFeatureItemBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ShapeFeatureItemBaseType (const ShapeFeatureItemBaseType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ShapeFeatureItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ShapeFeatureItemBaseType&
      operator= (const ShapeFeatureItemBaseType& x);

      virtual 
      ~ShapeFeatureItemBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointList_optional PointList_;
      SubstituteFeatureAlgorithm_optional SubstituteFeatureAlgorithm_;
      VirtualMeasurement_optional VirtualMeasurement_;
    };

    class QIF30_SYMBOL_DECL NonShapeFeatureItemBaseType: public ::xsd::qif30::FeatureItemBaseType
    {
      public:
      // Constructors.
      //
      NonShapeFeatureItemBaseType ();

      NonShapeFeatureItemBaseType (const id_type&,
                                   const FeatureNominalId_type&,
                                   const FeatureName_type&);

      NonShapeFeatureItemBaseType (const id_type&,
                                   ::std::unique_ptr< FeatureNominalId_type >,
                                   const FeatureName_type&);

      NonShapeFeatureItemBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      NonShapeFeatureItemBaseType (const NonShapeFeatureItemBaseType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual NonShapeFeatureItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      NonShapeFeatureItemBaseType&
      operator= (const NonShapeFeatureItemBaseType&) = default;
#endif

      virtual 
      ~NonShapeFeatureItemBaseType ();
    };

    class QIF30_SYMBOL_DECL FeatureDefinitionBaseType: public ::xsd::qif30::FeatureBaseType
    {
      public:
      // Constructors.
      //
      FeatureDefinitionBaseType ();

      FeatureDefinitionBaseType (const id_type&);

      FeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      FeatureDefinitionBaseType (const FeatureDefinitionBaseType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual FeatureDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      FeatureDefinitionBaseType&
      operator= (const FeatureDefinitionBaseType&) = default;
#endif

      virtual 
      ~FeatureDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL ShapeFeatureDefinitionBaseType: public ::xsd::qif30::FeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      ShapeFeatureDefinitionBaseType ();

      ShapeFeatureDefinitionBaseType (const id_type&);

      ShapeFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ShapeFeatureDefinitionBaseType (const ShapeFeatureDefinitionBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ShapeFeatureDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      ShapeFeatureDefinitionBaseType&
      operator= (const ShapeFeatureDefinitionBaseType&) = default;
#endif

      virtual 
      ~ShapeFeatureDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL NonShapeFeatureDefinitionBaseType: public ::xsd::qif30::FeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      NonShapeFeatureDefinitionBaseType ();

      NonShapeFeatureDefinitionBaseType (const id_type&);

      NonShapeFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      NonShapeFeatureDefinitionBaseType (const NonShapeFeatureDefinitionBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual NonShapeFeatureDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      NonShapeFeatureDefinitionBaseType&
      operator= (const NonShapeFeatureDefinitionBaseType&) = default;
#endif

      virtual 
      ~NonShapeFeatureDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL PointSetNominalType: public ::xml_schema::type
    {
      public:
      // MeasurePoint
      //
      typedef ::xsd::qif30::MeasurePointNominalType MeasurePoint_type;
      typedef ::xsd::cxx::tree::sequence< MeasurePoint_type > MeasurePoint_sequence;
      typedef xsd::cxx::tree::sequence< MeasurePoint_type >::iterator MeasurePoint_iterator;
      typedef xsd::cxx::tree::sequence< MeasurePoint_type >::const_iterator MeasurePoint_const_iterator;
      typedef ::xsd::cxx::tree::traits< MeasurePoint_type, wchar_t > MeasurePoint_traits;

      const MeasurePoint_sequence&
      MeasurePoint () const;

      MeasurePoint_sequence&
      MeasurePoint ();

      void
      MeasurePoint (const MeasurePoint_sequence& s);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      PointSetNominalType ();

      PointSetNominalType (const n_type&,
                           const id_type&);

      PointSetNominalType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PointSetNominalType (const PointSetNominalType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual PointSetNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointSetNominalType&
      operator= (const PointSetNominalType& x);

      virtual 
      ~PointSetNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurePoint_sequence MeasurePoint_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
      ::xsd::cxx::tree::one< n_type > n_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL NominalPointSetListType: public ::xml_schema::type
    {
      public:
      // NominalPointSet
      //
      typedef ::xsd::qif30::PointSetNominalType NominalPointSet_type;
      typedef ::xsd::cxx::tree::sequence< NominalPointSet_type > NominalPointSet_sequence;
      typedef xsd::cxx::tree::sequence< NominalPointSet_type >::iterator NominalPointSet_iterator;
      typedef xsd::cxx::tree::sequence< NominalPointSet_type >::const_iterator NominalPointSet_const_iterator;
      typedef ::xsd::cxx::tree::traits< NominalPointSet_type, wchar_t > NominalPointSet_traits;

      const NominalPointSet_sequence&
      NominalPointSet () const;

      NominalPointSet_sequence&
      NominalPointSet ();

      void
      NominalPointSet (const NominalPointSet_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      NominalPointSetListType ();

      NominalPointSetListType (const n_type&);

      NominalPointSetListType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      NominalPointSetListType (const NominalPointSetListType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual NominalPointSetListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NominalPointSetListType&
      operator= (const NominalPointSetListType& x);

      virtual 
      ~NominalPointSetListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NominalPointSet_sequence NominalPointSet_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FeatureNominalBaseType: public ::xsd::qif30::FeatureBaseType
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // UUID
      //
      typedef ::xsd::qif30::QPIdType UUID_type;
      typedef ::xsd::cxx::tree::optional< UUID_type > UUID_optional;
      typedef ::xsd::cxx::tree::traits< UUID_type, wchar_t > UUID_traits;

      const UUID_optional&
      UUID () const;

      UUID_optional&
      UUID ();

      void
      UUID (const UUID_type& x);

      void
      UUID (const UUID_optional& x);

      void
      UUID (::std::unique_ptr< UUID_type > p);

      // FeatureDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceType FeatureDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< FeatureDefinitionId_type, wchar_t > FeatureDefinitionId_traits;

      const FeatureDefinitionId_type&
      FeatureDefinitionId () const;

      FeatureDefinitionId_type&
      FeatureDefinitionId ();

      void
      FeatureDefinitionId (const FeatureDefinitionId_type& x);

      void
      FeatureDefinitionId (::std::unique_ptr< FeatureDefinitionId_type > p);

      // ParentFeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceType ParentFeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< ParentFeatureNominalId_type > ParentFeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< ParentFeatureNominalId_type, wchar_t > ParentFeatureNominalId_traits;

      const ParentFeatureNominalId_optional&
      ParentFeatureNominalId () const;

      ParentFeatureNominalId_optional&
      ParentFeatureNominalId ();

      void
      ParentFeatureNominalId (const ParentFeatureNominalId_type& x);

      void
      ParentFeatureNominalId (const ParentFeatureNominalId_optional& x);

      void
      ParentFeatureNominalId (::std::unique_ptr< ParentFeatureNominalId_type > p);

      // EntityInternalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType EntityInternalIds_type;
      typedef ::xsd::cxx::tree::optional< EntityInternalIds_type > EntityInternalIds_optional;
      typedef ::xsd::cxx::tree::traits< EntityInternalIds_type, wchar_t > EntityInternalIds_traits;

      const EntityInternalIds_optional&
      EntityInternalIds () const;

      EntityInternalIds_optional&
      EntityInternalIds ();

      void
      EntityInternalIds (const EntityInternalIds_type& x);

      void
      EntityInternalIds (const EntityInternalIds_optional& x);

      void
      EntityInternalIds (::std::unique_ptr< EntityInternalIds_type > p);

      // EntityExternalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType EntityExternalIds_type;
      typedef ::xsd::cxx::tree::optional< EntityExternalIds_type > EntityExternalIds_optional;
      typedef ::xsd::cxx::tree::traits< EntityExternalIds_type, wchar_t > EntityExternalIds_traits;

      const EntityExternalIds_optional&
      EntityExternalIds () const;

      EntityExternalIds_optional&
      EntityExternalIds ();

      void
      EntityExternalIds (const EntityExternalIds_type& x);

      void
      EntityExternalIds (const EntityExternalIds_optional& x);

      void
      EntityExternalIds (::std::unique_ptr< EntityExternalIds_type > p);

      // Constructors.
      //
      FeatureNominalBaseType ();

      FeatureNominalBaseType (const id_type&,
                              const FeatureDefinitionId_type&);

      FeatureNominalBaseType (const id_type&,
                              ::std::unique_ptr< FeatureDefinitionId_type >);

      FeatureNominalBaseType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      FeatureNominalBaseType (const FeatureNominalBaseType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual FeatureNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FeatureNominalBaseType&
      operator= (const FeatureNominalBaseType& x);

      virtual 
      ~FeatureNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Name_optional Name_;
      UUID_optional UUID_;
      ::xsd::cxx::tree::one< FeatureDefinitionId_type > FeatureDefinitionId_;
      ParentFeatureNominalId_optional ParentFeatureNominalId_;
      EntityInternalIds_optional EntityInternalIds_;
      EntityExternalIds_optional EntityExternalIds_;
    };

    class QIF30_SYMBOL_DECL ShapeFeatureNominalBaseType: public ::xsd::qif30::FeatureNominalBaseType
    {
      public:
      // PointList
      //
      typedef ::xsd::qif30::PointListType PointList_type;
      typedef ::xsd::cxx::tree::optional< PointList_type > PointList_optional;
      typedef ::xsd::cxx::tree::traits< PointList_type, wchar_t > PointList_traits;

      const PointList_optional&
      PointList () const;

      PointList_optional&
      PointList ();

      void
      PointList (const PointList_type& x);

      void
      PointList (const PointList_optional& x);

      void
      PointList (::std::unique_ptr< PointList_type > p);

      // SubstituteFeatureAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType SubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithm_type > SubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithm_type, wchar_t > SubstituteFeatureAlgorithm_traits;

      const SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm () const;

      SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm ();

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x);

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x);

      void
      SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > p);

      // Constructors.
      //
      ShapeFeatureNominalBaseType ();

      ShapeFeatureNominalBaseType (const id_type&,
                                   const FeatureDefinitionId_type&);

      ShapeFeatureNominalBaseType (const id_type&,
                                   ::std::unique_ptr< FeatureDefinitionId_type >);

      ShapeFeatureNominalBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ShapeFeatureNominalBaseType (const ShapeFeatureNominalBaseType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ShapeFeatureNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ShapeFeatureNominalBaseType&
      operator= (const ShapeFeatureNominalBaseType& x);

      virtual 
      ~ShapeFeatureNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointList_optional PointList_;
      SubstituteFeatureAlgorithm_optional SubstituteFeatureAlgorithm_;
    };

    class QIF30_SYMBOL_DECL NonShapeFeatureNominalBaseType: public ::xsd::qif30::FeatureNominalBaseType
    {
      public:
      // Constructors.
      //
      NonShapeFeatureNominalBaseType ();

      NonShapeFeatureNominalBaseType (const id_type&,
                                      const FeatureDefinitionId_type&);

      NonShapeFeatureNominalBaseType (const id_type&,
                                      ::std::unique_ptr< FeatureDefinitionId_type >);

      NonShapeFeatureNominalBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      NonShapeFeatureNominalBaseType (const NonShapeFeatureNominalBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual NonShapeFeatureNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      NonShapeFeatureNominalBaseType&
      operator= (const NonShapeFeatureNominalBaseType&) = default;
#endif

      virtual 
      ~NonShapeFeatureNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL MeasuredPointSetsType: public ::xml_schema::type
    {
      public:
      // MeasuredPointSet
      //
      typedef ::xsd::qif30::MeasuredPointSetType MeasuredPointSet_type;
      typedef ::xsd::cxx::tree::sequence< MeasuredPointSet_type > MeasuredPointSet_sequence;
      typedef xsd::cxx::tree::sequence< MeasuredPointSet_type >::iterator MeasuredPointSet_iterator;
      typedef xsd::cxx::tree::sequence< MeasuredPointSet_type >::const_iterator MeasuredPointSet_const_iterator;
      typedef ::xsd::cxx::tree::traits< MeasuredPointSet_type, wchar_t > MeasuredPointSet_traits;

      const MeasuredPointSet_sequence&
      MeasuredPointSet () const;

      MeasuredPointSet_sequence&
      MeasuredPointSet ();

      void
      MeasuredPointSet (const MeasuredPointSet_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      MeasuredPointSetsType ();

      MeasuredPointSetsType (const n_type&);

      MeasuredPointSetsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MeasuredPointSetsType (const MeasuredPointSetsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MeasuredPointSetsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredPointSetsType&
      operator= (const MeasuredPointSetsType& x);

      virtual 
      ~MeasuredPointSetsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasuredPointSet_sequence MeasuredPointSet_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointListType: public ::xml_schema::type
    {
      public:
      // PointSetId
      //
      typedef ::xsd::qif30::PointSetReferenceBaseType PointSetId_type;
      typedef ::xsd::cxx::tree::sequence< PointSetId_type > PointSetId_sequence;
      typedef xsd::cxx::tree::sequence< PointSetId_type >::iterator PointSetId_iterator;
      typedef xsd::cxx::tree::sequence< PointSetId_type >::const_iterator PointSetId_const_iterator;
      typedef ::xsd::cxx::tree::traits< PointSetId_type, wchar_t > PointSetId_traits;

      const PointSetId_sequence&
      PointSetId () const;

      PointSetId_sequence&
      PointSetId ();

      void
      PointSetId (const PointSetId_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PointListType ();

      PointListType (const n_type&);

      PointListType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      PointListType (const PointListType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual PointListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointListType&
      operator= (const PointListType& x);

      virtual 
      ~PointListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSetId_sequence PointSetId_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MeasuredPointSetType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Units
      //
      typedef ::xsd::qif30::OtherUnitsType Units_type;
      typedef ::xsd::cxx::tree::optional< Units_type > Units_optional;
      typedef ::xsd::cxx::tree::traits< Units_type, wchar_t > Units_traits;

      const Units_optional&
      Units () const;

      Units_optional&
      Units ();

      void
      Units (const Units_type& x);

      void
      Units (const Units_optional& x);

      void
      Units (::std::unique_ptr< Units_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // TranformId
      //
      typedef ::xsd::qif30::QIFReferenceType TranformId_type;
      typedef ::xsd::cxx::tree::optional< TranformId_type > TranformId_optional;
      typedef ::xsd::cxx::tree::traits< TranformId_type, wchar_t > TranformId_traits;

      const TranformId_optional&
      TranformId () const;

      TranformId_optional&
      TranformId ();

      void
      TranformId (const TranformId_type& x);

      void
      TranformId (const TranformId_optional& x);

      void
      TranformId (::std::unique_ptr< TranformId_type > p);

      // Points
      //
      typedef ::xsd::qif30::ListDoubleType Points_type;
      typedef ::xsd::cxx::tree::optional< Points_type > Points_optional;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_optional&
      Points () const;

      Points_optional&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (const Points_optional& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // BinaryPoints
      //
      typedef ::xsd::qif30::ArrayBinaryType BinaryPoints_type;
      typedef ::xsd::cxx::tree::optional< BinaryPoints_type > BinaryPoints_optional;
      typedef ::xsd::cxx::tree::traits< BinaryPoints_type, wchar_t > BinaryPoints_traits;

      const BinaryPoints_optional&
      BinaryPoints () const;

      BinaryPoints_optional&
      BinaryPoints ();

      void
      BinaryPoints (const BinaryPoints_type& x);

      void
      BinaryPoints (const BinaryPoints_optional& x);

      void
      BinaryPoints (::std::unique_ptr< BinaryPoints_type > p);

      // Normals
      //
      typedef ::xsd::qif30::ListDoubleType Normals_type;
      typedef ::xsd::cxx::tree::optional< Normals_type > Normals_optional;
      typedef ::xsd::cxx::tree::traits< Normals_type, wchar_t > Normals_traits;

      const Normals_optional&
      Normals () const;

      Normals_optional&
      Normals ();

      void
      Normals (const Normals_type& x);

      void
      Normals (const Normals_optional& x);

      void
      Normals (::std::unique_ptr< Normals_type > p);

      // BinaryNormals
      //
      typedef ::xsd::qif30::ArrayBinaryType BinaryNormals_type;
      typedef ::xsd::cxx::tree::optional< BinaryNormals_type > BinaryNormals_optional;
      typedef ::xsd::cxx::tree::traits< BinaryNormals_type, wchar_t > BinaryNormals_traits;

      const BinaryNormals_optional&
      BinaryNormals () const;

      BinaryNormals_optional&
      BinaryNormals ();

      void
      BinaryNormals (const BinaryNormals_type& x);

      void
      BinaryNormals (const BinaryNormals_optional& x);

      void
      BinaryNormals (::std::unique_ptr< BinaryNormals_type > p);

      // Compensated
      //
      typedef ::xml_schema::boolean Compensated_type;
      typedef ::xsd::cxx::tree::optional< Compensated_type > Compensated_optional;
      typedef ::xsd::cxx::tree::traits< Compensated_type, wchar_t > Compensated_traits;

      const Compensated_optional&
      Compensated () const;

      Compensated_optional&
      Compensated ();

      void
      Compensated (const Compensated_type& x);

      void
      Compensated (const Compensated_optional& x);

      // Compensations
      //
      typedef ::xsd::qif30::ListBooleanType Compensations_type;
      typedef ::xsd::cxx::tree::optional< Compensations_type > Compensations_optional;
      typedef ::xsd::cxx::tree::traits< Compensations_type, wchar_t > Compensations_traits;

      const Compensations_optional&
      Compensations () const;

      Compensations_optional&
      Compensations ();

      void
      Compensations (const Compensations_type& x);

      void
      Compensations (const Compensations_optional& x);

      void
      Compensations (::std::unique_ptr< Compensations_type > p);

      // BinaryCompensated
      //
      typedef ::xsd::qif30::ArrayBinaryType BinaryCompensated_type;
      typedef ::xsd::cxx::tree::optional< BinaryCompensated_type > BinaryCompensated_optional;
      typedef ::xsd::cxx::tree::traits< BinaryCompensated_type, wchar_t > BinaryCompensated_traits;

      const BinaryCompensated_optional&
      BinaryCompensated () const;

      BinaryCompensated_optional&
      BinaryCompensated ();

      void
      BinaryCompensated (const BinaryCompensated_type& x);

      void
      BinaryCompensated (const BinaryCompensated_optional& x);

      void
      BinaryCompensated (::std::unique_ptr< BinaryCompensated_type > p);

      // ProbeRadius
      //
      typedef ::xml_schema::decimal ProbeRadius_type;
      typedef ::xsd::cxx::tree::optional< ProbeRadius_type > ProbeRadius_optional;
      typedef ::xsd::cxx::tree::traits< ProbeRadius_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > ProbeRadius_traits;

      const ProbeRadius_optional&
      ProbeRadius () const;

      ProbeRadius_optional&
      ProbeRadius ();

      void
      ProbeRadius (const ProbeRadius_type& x);

      void
      ProbeRadius (const ProbeRadius_optional& x);

      // ProbeRadii
      //
      typedef ::xsd::qif30::ListDoubleType ProbeRadii_type;
      typedef ::xsd::cxx::tree::optional< ProbeRadii_type > ProbeRadii_optional;
      typedef ::xsd::cxx::tree::traits< ProbeRadii_type, wchar_t > ProbeRadii_traits;

      const ProbeRadii_optional&
      ProbeRadii () const;

      ProbeRadii_optional&
      ProbeRadii ();

      void
      ProbeRadii (const ProbeRadii_type& x);

      void
      ProbeRadii (const ProbeRadii_optional& x);

      void
      ProbeRadii (::std::unique_ptr< ProbeRadii_type > p);

      // BinaryProbeRadii
      //
      typedef ::xsd::qif30::ArrayBinaryType BinaryProbeRadii_type;
      typedef ::xsd::cxx::tree::optional< BinaryProbeRadii_type > BinaryProbeRadii_optional;
      typedef ::xsd::cxx::tree::traits< BinaryProbeRadii_type, wchar_t > BinaryProbeRadii_traits;

      const BinaryProbeRadii_optional&
      BinaryProbeRadii () const;

      BinaryProbeRadii_optional&
      BinaryProbeRadii ();

      void
      BinaryProbeRadii (const BinaryProbeRadii_type& x);

      void
      BinaryProbeRadii (const BinaryProbeRadii_optional& x);

      void
      BinaryProbeRadii (::std::unique_ptr< BinaryProbeRadii_type > p);

      // MeasurementDeviceId
      //
      typedef ::xsd::qif30::QIFReferenceType MeasurementDeviceId_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceId_type > MeasurementDeviceId_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceId_type, wchar_t > MeasurementDeviceId_traits;

      const MeasurementDeviceId_optional&
      MeasurementDeviceId () const;

      MeasurementDeviceId_optional&
      MeasurementDeviceId ();

      void
      MeasurementDeviceId (const MeasurementDeviceId_type& x);

      void
      MeasurementDeviceId (const MeasurementDeviceId_optional& x);

      void
      MeasurementDeviceId (::std::unique_ptr< MeasurementDeviceId_type > p);

      // SensorId
      //
      typedef ::xsd::qif30::QIFReferenceType SensorId_type;
      typedef ::xsd::cxx::tree::optional< SensorId_type > SensorId_optional;
      typedef ::xsd::cxx::tree::traits< SensorId_type, wchar_t > SensorId_traits;

      const SensorId_optional&
      SensorId () const;

      SensorId_optional&
      SensorId ();

      void
      SensorId (const SensorId_type& x);

      void
      SensorId (const SensorId_optional& x);

      void
      SensorId (::std::unique_ptr< SensorId_type > p);

      // SensorIds
      //
      typedef ::xsd::qif30::ListQIFReferenceType SensorIds_type;
      typedef ::xsd::cxx::tree::optional< SensorIds_type > SensorIds_optional;
      typedef ::xsd::cxx::tree::traits< SensorIds_type, wchar_t > SensorIds_traits;

      const SensorIds_optional&
      SensorIds () const;

      SensorIds_optional&
      SensorIds ();

      void
      SensorIds (const SensorIds_type& x);

      void
      SensorIds (const SensorIds_optional& x);

      void
      SensorIds (::std::unique_ptr< SensorIds_type > p);

      // BinarySensorIds
      //
      typedef ::xsd::qif30::ArrayBinaryQIFReferenceType BinarySensorIds_type;
      typedef ::xsd::cxx::tree::optional< BinarySensorIds_type > BinarySensorIds_optional;
      typedef ::xsd::cxx::tree::traits< BinarySensorIds_type, wchar_t > BinarySensorIds_traits;

      const BinarySensorIds_optional&
      BinarySensorIds () const;

      BinarySensorIds_optional&
      BinarySensorIds ();

      void
      BinarySensorIds (const BinarySensorIds_type& x);

      void
      BinarySensorIds (const BinarySensorIds_optional& x);

      void
      BinarySensorIds (::std::unique_ptr< BinarySensorIds_type > p);

      // TipId
      //
      typedef ::xsd::qif30::QIFReferenceType TipId_type;
      typedef ::xsd::cxx::tree::optional< TipId_type > TipId_optional;
      typedef ::xsd::cxx::tree::traits< TipId_type, wchar_t > TipId_traits;

      const TipId_optional&
      TipId () const;

      TipId_optional&
      TipId ();

      void
      TipId (const TipId_type& x);

      void
      TipId (const TipId_optional& x);

      void
      TipId (::std::unique_ptr< TipId_type > p);

      // TipIds
      //
      typedef ::xsd::qif30::ListQIFReferenceType TipIds_type;
      typedef ::xsd::cxx::tree::optional< TipIds_type > TipIds_optional;
      typedef ::xsd::cxx::tree::traits< TipIds_type, wchar_t > TipIds_traits;

      const TipIds_optional&
      TipIds () const;

      TipIds_optional&
      TipIds ();

      void
      TipIds (const TipIds_type& x);

      void
      TipIds (const TipIds_optional& x);

      void
      TipIds (::std::unique_ptr< TipIds_type > p);

      // BinaryTipIds
      //
      typedef ::xsd::qif30::ArrayBinaryQIFReferenceType BinaryTipIds_type;
      typedef ::xsd::cxx::tree::optional< BinaryTipIds_type > BinaryTipIds_optional;
      typedef ::xsd::cxx::tree::traits< BinaryTipIds_type, wchar_t > BinaryTipIds_traits;

      const BinaryTipIds_optional&
      BinaryTipIds () const;

      BinaryTipIds_optional&
      BinaryTipIds ();

      void
      BinaryTipIds (const BinaryTipIds_type& x);

      void
      BinaryTipIds (const BinaryTipIds_optional& x);

      void
      BinaryTipIds (::std::unique_ptr< BinaryTipIds_type > p);

      // MeasurePointNominalIds
      //
      typedef ::xsd::qif30::ListQIFReferenceFullType MeasurePointNominalIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurePointNominalIds_type > MeasurePointNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurePointNominalIds_type, wchar_t > MeasurePointNominalIds_traits;

      const MeasurePointNominalIds_optional&
      MeasurePointNominalIds () const;

      MeasurePointNominalIds_optional&
      MeasurePointNominalIds ();

      void
      MeasurePointNominalIds (const MeasurePointNominalIds_type& x);

      void
      MeasurePointNominalIds (const MeasurePointNominalIds_optional& x);

      void
      MeasurePointNominalIds (::std::unique_ptr< MeasurePointNominalIds_type > p);

      // BinaryMeasurePointNominalIds
      //
      typedef ::xsd::qif30::ArrayBinaryQIFReferenceFullType BinaryMeasurePointNominalIds_type;
      typedef ::xsd::cxx::tree::optional< BinaryMeasurePointNominalIds_type > BinaryMeasurePointNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< BinaryMeasurePointNominalIds_type, wchar_t > BinaryMeasurePointNominalIds_traits;

      const BinaryMeasurePointNominalIds_optional&
      BinaryMeasurePointNominalIds () const;

      BinaryMeasurePointNominalIds_optional&
      BinaryMeasurePointNominalIds ();

      void
      BinaryMeasurePointNominalIds (const BinaryMeasurePointNominalIds_type& x);

      void
      BinaryMeasurePointNominalIds (const BinaryMeasurePointNominalIds_optional& x);

      void
      BinaryMeasurePointNominalIds (::std::unique_ptr< BinaryMeasurePointNominalIds_type > p);

      // TimeStamp
      //
      typedef ::xml_schema::date_time TimeStamp_type;
      typedef ::xsd::cxx::tree::optional< TimeStamp_type > TimeStamp_optional;
      typedef ::xsd::cxx::tree::traits< TimeStamp_type, wchar_t > TimeStamp_traits;

      const TimeStamp_optional&
      TimeStamp () const;

      TimeStamp_optional&
      TimeStamp ();

      void
      TimeStamp (const TimeStamp_type& x);

      void
      TimeStamp (const TimeStamp_optional& x);

      void
      TimeStamp (::std::unique_ptr< TimeStamp_type > p);

      // TimeStamps
      //
      typedef ::xsd::qif30::ListDateTimeType TimeStamps_type;
      typedef ::xsd::cxx::tree::optional< TimeStamps_type > TimeStamps_optional;
      typedef ::xsd::cxx::tree::traits< TimeStamps_type, wchar_t > TimeStamps_traits;

      const TimeStamps_optional&
      TimeStamps () const;

      TimeStamps_optional&
      TimeStamps ();

      void
      TimeStamps (const TimeStamps_type& x);

      void
      TimeStamps (const TimeStamps_optional& x);

      void
      TimeStamps (::std::unique_ptr< TimeStamps_type > p);

      // Quality
      //
      typedef ::xsd::qif30::ListDoubleType Quality_type;
      typedef ::xsd::cxx::tree::optional< Quality_type > Quality_optional;
      typedef ::xsd::cxx::tree::traits< Quality_type, wchar_t > Quality_traits;

      const Quality_optional&
      Quality () const;

      Quality_optional&
      Quality ();

      void
      Quality (const Quality_type& x);

      void
      Quality (const Quality_optional& x);

      void
      Quality (::std::unique_ptr< Quality_type > p);

      // BinaryQuality
      //
      typedef ::xsd::qif30::ArrayBinaryType BinaryQuality_type;
      typedef ::xsd::cxx::tree::optional< BinaryQuality_type > BinaryQuality_optional;
      typedef ::xsd::cxx::tree::traits< BinaryQuality_type, wchar_t > BinaryQuality_traits;

      const BinaryQuality_optional&
      BinaryQuality () const;

      BinaryQuality_optional&
      BinaryQuality ();

      void
      BinaryQuality (const BinaryQuality_type& x);

      void
      BinaryQuality (const BinaryQuality_optional& x);

      void
      BinaryQuality (::std::unique_ptr< BinaryQuality_type > p);

      // Deviations
      //
      typedef ::xsd::qif30::ListDoubleType Deviations_type;
      typedef ::xsd::cxx::tree::optional< Deviations_type > Deviations_optional;
      typedef ::xsd::cxx::tree::traits< Deviations_type, wchar_t > Deviations_traits;

      const Deviations_optional&
      Deviations () const;

      Deviations_optional&
      Deviations ();

      void
      Deviations (const Deviations_type& x);

      void
      Deviations (const Deviations_optional& x);

      void
      Deviations (::std::unique_ptr< Deviations_type > p);

      // BinaryDeviations
      //
      typedef ::xsd::qif30::ArrayBinaryType BinaryDeviations_type;
      typedef ::xsd::cxx::tree::optional< BinaryDeviations_type > BinaryDeviations_optional;
      typedef ::xsd::cxx::tree::traits< BinaryDeviations_type, wchar_t > BinaryDeviations_traits;

      const BinaryDeviations_optional&
      BinaryDeviations () const;

      BinaryDeviations_optional&
      BinaryDeviations ();

      void
      BinaryDeviations (const BinaryDeviations_type& x);

      void
      BinaryDeviations (const BinaryDeviations_optional& x);

      void
      BinaryDeviations (::std::unique_ptr< BinaryDeviations_type > p);

      // Colors
      //
      typedef ::xsd::qif30::ListIntType Colors_type;
      typedef ::xsd::cxx::tree::optional< Colors_type > Colors_optional;
      typedef ::xsd::cxx::tree::traits< Colors_type, wchar_t > Colors_traits;

      const Colors_optional&
      Colors () const;

      Colors_optional&
      Colors ();

      void
      Colors (const Colors_type& x);

      void
      Colors (const Colors_optional& x);

      void
      Colors (::std::unique_ptr< Colors_type > p);

      // BinaryColors
      //
      typedef ::xsd::qif30::ArrayBinaryType BinaryColors_type;
      typedef ::xsd::cxx::tree::optional< BinaryColors_type > BinaryColors_optional;
      typedef ::xsd::cxx::tree::traits< BinaryColors_type, wchar_t > BinaryColors_traits;

      const BinaryColors_optional&
      BinaryColors () const;

      BinaryColors_optional&
      BinaryColors ();

      void
      BinaryColors (const BinaryColors_type& x);

      void
      BinaryColors (const BinaryColors_optional& x);

      void
      BinaryColors (::std::unique_ptr< BinaryColors_type > p);

      // NumberOfFacets
      //
      typedef ::xsd::qif30::NaturalType NumberOfFacets_type;
      typedef ::xsd::cxx::tree::optional< NumberOfFacets_type > NumberOfFacets_optional;
      typedef ::xsd::cxx::tree::traits< NumberOfFacets_type, wchar_t > NumberOfFacets_traits;

      const NumberOfFacets_optional&
      NumberOfFacets () const;

      NumberOfFacets_optional&
      NumberOfFacets ();

      void
      NumberOfFacets (const NumberOfFacets_type& x);

      void
      NumberOfFacets (const NumberOfFacets_optional& x);

      void
      NumberOfFacets (::std::unique_ptr< NumberOfFacets_type > p);

      // PointIndices
      //
      typedef ::xsd::qif30::ArrayI3Type PointIndices_type;
      typedef ::xsd::cxx::tree::optional< PointIndices_type > PointIndices_optional;
      typedef ::xsd::cxx::tree::traits< PointIndices_type, wchar_t > PointIndices_traits;

      const PointIndices_optional&
      PointIndices () const;

      PointIndices_optional&
      PointIndices ();

      void
      PointIndices (const PointIndices_type& x);

      void
      PointIndices (const PointIndices_optional& x);

      void
      PointIndices (::std::unique_ptr< PointIndices_type > p);

      // BinaryPointIndices
      //
      typedef ::xsd::qif30::ArrayBinaryType BinaryPointIndices_type;
      typedef ::xsd::cxx::tree::optional< BinaryPointIndices_type > BinaryPointIndices_optional;
      typedef ::xsd::cxx::tree::traits< BinaryPointIndices_type, wchar_t > BinaryPointIndices_traits;

      const BinaryPointIndices_optional&
      BinaryPointIndices () const;

      BinaryPointIndices_optional&
      BinaryPointIndices ();

      void
      BinaryPointIndices (const BinaryPointIndices_type& x);

      void
      BinaryPointIndices (const BinaryPointIndices_optional& x);

      void
      BinaryPointIndices (::std::unique_ptr< BinaryPointIndices_type > p);

      // count
      //
      typedef ::xsd::qif30::NaturalType count_type;
      typedef ::xsd::cxx::tree::traits< count_type, wchar_t > count_traits;

      const count_type&
      count () const;

      count_type&
      count ();

      void
      count (const count_type& x);

      void
      count (::std::unique_ptr< count_type > p);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // combinedUncertainty
      //
      typedef ::xml_schema::decimal combinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< combinedUncertainty_type > combinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< combinedUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > combinedUncertainty_traits;

      const combinedUncertainty_optional&
      combinedUncertainty () const;

      combinedUncertainty_optional&
      combinedUncertainty ();

      void
      combinedUncertainty (const combinedUncertainty_type& x);

      void
      combinedUncertainty (const combinedUncertainty_optional& x);

      // meanError
      //
      typedef ::xml_schema::decimal meanError_type;
      typedef ::xsd::cxx::tree::optional< meanError_type > meanError_optional;
      typedef ::xsd::cxx::tree::traits< meanError_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > meanError_traits;

      const meanError_optional&
      meanError () const;

      meanError_optional&
      meanError ();

      void
      meanError (const meanError_type& x);

      void
      meanError (const meanError_optional& x);

      // xCombinedUncertainty
      //
      typedef ::xml_schema::decimal xCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< xCombinedUncertainty_type > xCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< xCombinedUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > xCombinedUncertainty_traits;

      const xCombinedUncertainty_optional&
      xCombinedUncertainty () const;

      xCombinedUncertainty_optional&
      xCombinedUncertainty ();

      void
      xCombinedUncertainty (const xCombinedUncertainty_type& x);

      void
      xCombinedUncertainty (const xCombinedUncertainty_optional& x);

      // xMeanError
      //
      typedef ::xml_schema::decimal xMeanError_type;
      typedef ::xsd::cxx::tree::optional< xMeanError_type > xMeanError_optional;
      typedef ::xsd::cxx::tree::traits< xMeanError_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > xMeanError_traits;

      const xMeanError_optional&
      xMeanError () const;

      xMeanError_optional&
      xMeanError ();

      void
      xMeanError (const xMeanError_type& x);

      void
      xMeanError (const xMeanError_optional& x);

      // yCombinedUncertainty
      //
      typedef ::xml_schema::decimal yCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< yCombinedUncertainty_type > yCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< yCombinedUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > yCombinedUncertainty_traits;

      const yCombinedUncertainty_optional&
      yCombinedUncertainty () const;

      yCombinedUncertainty_optional&
      yCombinedUncertainty ();

      void
      yCombinedUncertainty (const yCombinedUncertainty_type& x);

      void
      yCombinedUncertainty (const yCombinedUncertainty_optional& x);

      // yMeanError
      //
      typedef ::xml_schema::decimal yMeanError_type;
      typedef ::xsd::cxx::tree::optional< yMeanError_type > yMeanError_optional;
      typedef ::xsd::cxx::tree::traits< yMeanError_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > yMeanError_traits;

      const yMeanError_optional&
      yMeanError () const;

      yMeanError_optional&
      yMeanError ();

      void
      yMeanError (const yMeanError_type& x);

      void
      yMeanError (const yMeanError_optional& x);

      // zCombinedUncertainty
      //
      typedef ::xml_schema::decimal zCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< zCombinedUncertainty_type > zCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< zCombinedUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > zCombinedUncertainty_traits;

      const zCombinedUncertainty_optional&
      zCombinedUncertainty () const;

      zCombinedUncertainty_optional&
      zCombinedUncertainty ();

      void
      zCombinedUncertainty (const zCombinedUncertainty_type& x);

      void
      zCombinedUncertainty (const zCombinedUncertainty_optional& x);

      // zMeanError
      //
      typedef ::xml_schema::decimal zMeanError_type;
      typedef ::xsd::cxx::tree::optional< zMeanError_type > zMeanError_optional;
      typedef ::xsd::cxx::tree::traits< zMeanError_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > zMeanError_traits;

      const zMeanError_optional&
      zMeanError () const;

      zMeanError_optional&
      zMeanError ();

      void
      zMeanError (const zMeanError_type& x);

      void
      zMeanError (const zMeanError_optional& x);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      MeasuredPointSetType ();

      MeasuredPointSetType (const count_type&,
                            const id_type&);

      MeasuredPointSetType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      MeasuredPointSetType (const MeasuredPointSetType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual MeasuredPointSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredPointSetType&
      operator= (const MeasuredPointSetType& x);

      virtual 
      ~MeasuredPointSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Units_optional Units_;
      CoordinateSystemId_optional CoordinateSystemId_;
      TranformId_optional TranformId_;
      Points_optional Points_;
      BinaryPoints_optional BinaryPoints_;
      Normals_optional Normals_;
      BinaryNormals_optional BinaryNormals_;
      Compensated_optional Compensated_;
      Compensations_optional Compensations_;
      BinaryCompensated_optional BinaryCompensated_;
      ProbeRadius_optional ProbeRadius_;
      ProbeRadii_optional ProbeRadii_;
      BinaryProbeRadii_optional BinaryProbeRadii_;
      MeasurementDeviceId_optional MeasurementDeviceId_;
      SensorId_optional SensorId_;
      SensorIds_optional SensorIds_;
      BinarySensorIds_optional BinarySensorIds_;
      TipId_optional TipId_;
      TipIds_optional TipIds_;
      BinaryTipIds_optional BinaryTipIds_;
      MeasurePointNominalIds_optional MeasurePointNominalIds_;
      BinaryMeasurePointNominalIds_optional BinaryMeasurePointNominalIds_;
      TimeStamp_optional TimeStamp_;
      TimeStamps_optional TimeStamps_;
      Quality_optional Quality_;
      BinaryQuality_optional BinaryQuality_;
      Deviations_optional Deviations_;
      BinaryDeviations_optional BinaryDeviations_;
      Colors_optional Colors_;
      BinaryColors_optional BinaryColors_;
      NumberOfFacets_optional NumberOfFacets_;
      PointIndices_optional PointIndices_;
      BinaryPointIndices_optional BinaryPointIndices_;
      ::xsd::cxx::tree::one< count_type > count_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
      combinedUncertainty_optional combinedUncertainty_;
      meanError_optional meanError_;
      xCombinedUncertainty_optional xCombinedUncertainty_;
      xMeanError_optional xMeanError_;
      yCombinedUncertainty_optional yCombinedUncertainty_;
      yMeanError_optional yMeanError_;
      zCombinedUncertainty_optional zCombinedUncertainty_;
      zMeanError_optional zMeanError_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL FeatureMeasurementBaseType: public ::xsd::qif30::FeatureBaseType
    {
      public:
      // FeatureItemId
      //
      typedef ::xsd::qif30::QIFReferenceType FeatureItemId_type;
      typedef ::xsd::cxx::tree::optional< FeatureItemId_type > FeatureItemId_optional;
      typedef ::xsd::cxx::tree::traits< FeatureItemId_type, wchar_t > FeatureItemId_traits;

      const FeatureItemId_optional&
      FeatureItemId () const;

      FeatureItemId_optional&
      FeatureItemId ();

      void
      FeatureItemId (const FeatureItemId_type& x);

      void
      FeatureItemId (const FeatureItemId_optional& x);

      void
      FeatureItemId (::std::unique_ptr< FeatureItemId_type > p);

      // FeatureName
      //
      typedef ::xml_schema::token FeatureName_type;
      typedef ::xsd::cxx::tree::optional< FeatureName_type > FeatureName_optional;
      typedef ::xsd::cxx::tree::traits< FeatureName_type, wchar_t > FeatureName_traits;

      const FeatureName_optional&
      FeatureName () const;

      FeatureName_optional&
      FeatureName ();

      void
      FeatureName (const FeatureName_type& x);

      void
      FeatureName (const FeatureName_optional& x);

      void
      FeatureName (::std::unique_ptr< FeatureName_type > p);

      // TimeStamp
      //
      typedef ::xml_schema::date_time TimeStamp_type;
      typedef ::xsd::cxx::tree::optional< TimeStamp_type > TimeStamp_optional;
      typedef ::xsd::cxx::tree::traits< TimeStamp_type, wchar_t > TimeStamp_traits;

      const TimeStamp_optional&
      TimeStamp () const;

      TimeStamp_optional&
      TimeStamp ();

      void
      TimeStamp (const TimeStamp_type& x);

      void
      TimeStamp (const TimeStamp_optional& x);

      void
      TimeStamp (::std::unique_ptr< TimeStamp_type > p);

      // ActualComponentId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ActualComponentId_type;
      typedef ::xsd::cxx::tree::optional< ActualComponentId_type > ActualComponentId_optional;
      typedef ::xsd::cxx::tree::traits< ActualComponentId_type, wchar_t > ActualComponentId_traits;

      const ActualComponentId_optional&
      ActualComponentId () const;

      ActualComponentId_optional&
      ActualComponentId ();

      void
      ActualComponentId (const ActualComponentId_type& x);

      void
      ActualComponentId (const ActualComponentId_optional& x);

      void
      ActualComponentId (::std::unique_ptr< ActualComponentId_type > p);

      // ManufacturingProcessId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ManufacturingProcessId_type;
      typedef ::xsd::cxx::tree::optional< ManufacturingProcessId_type > ManufacturingProcessId_optional;
      typedef ::xsd::cxx::tree::traits< ManufacturingProcessId_type, wchar_t > ManufacturingProcessId_traits;

      const ManufacturingProcessId_optional&
      ManufacturingProcessId () const;

      ManufacturingProcessId_optional&
      ManufacturingProcessId ();

      void
      ManufacturingProcessId (const ManufacturingProcessId_type& x);

      void
      ManufacturingProcessId (const ManufacturingProcessId_optional& x);

      void
      ManufacturingProcessId (::std::unique_ptr< ManufacturingProcessId_type > p);

      // MeasurementDeviceIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType MeasurementDeviceIds_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceIds_type > MeasurementDeviceIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceIds_type, wchar_t > MeasurementDeviceIds_traits;

      const MeasurementDeviceIds_optional&
      MeasurementDeviceIds () const;

      MeasurementDeviceIds_optional&
      MeasurementDeviceIds ();

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_type& x);

      void
      MeasurementDeviceIds (const MeasurementDeviceIds_optional& x);

      void
      MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > p);

      // ActualTransformId
      //
      typedef ::xsd::qif30::QIFReferenceType ActualTransformId_type;
      typedef ::xsd::cxx::tree::optional< ActualTransformId_type > ActualTransformId_optional;
      typedef ::xsd::cxx::tree::traits< ActualTransformId_type, wchar_t > ActualTransformId_traits;

      const ActualTransformId_optional&
      ActualTransformId () const;

      ActualTransformId_optional&
      ActualTransformId ();

      void
      ActualTransformId (const ActualTransformId_type& x);

      void
      ActualTransformId (const ActualTransformId_optional& x);

      void
      ActualTransformId (::std::unique_ptr< ActualTransformId_type > p);

      // NotedEventIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType NotedEventIds_type;
      typedef ::xsd::cxx::tree::optional< NotedEventIds_type > NotedEventIds_optional;
      typedef ::xsd::cxx::tree::traits< NotedEventIds_type, wchar_t > NotedEventIds_traits;

      const NotedEventIds_optional&
      NotedEventIds () const;

      NotedEventIds_optional&
      NotedEventIds ();

      void
      NotedEventIds (const NotedEventIds_type& x);

      void
      NotedEventIds (const NotedEventIds_optional& x);

      void
      NotedEventIds (::std::unique_ptr< NotedEventIds_type > p);

      // Constructors.
      //
      FeatureMeasurementBaseType ();

      FeatureMeasurementBaseType (const id_type&);

      FeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      FeatureMeasurementBaseType (const FeatureMeasurementBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual FeatureMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FeatureMeasurementBaseType&
      operator= (const FeatureMeasurementBaseType& x);

      virtual 
      ~FeatureMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureItemId_optional FeatureItemId_;
      FeatureName_optional FeatureName_;
      TimeStamp_optional TimeStamp_;
      ActualComponentId_optional ActualComponentId_;
      ManufacturingProcessId_optional ManufacturingProcessId_;
      MeasurementDeviceIds_optional MeasurementDeviceIds_;
      ActualTransformId_optional ActualTransformId_;
      NotedEventIds_optional NotedEventIds_;
    };

    class QIF30_SYMBOL_DECL ShapeFeatureMeasurementBaseType: public ::xsd::qif30::FeatureMeasurementBaseType
    {
      public:
      // PointList
      //
      typedef ::xsd::qif30::PointListType PointList_type;
      typedef ::xsd::cxx::tree::optional< PointList_type > PointList_optional;
      typedef ::xsd::cxx::tree::traits< PointList_type, wchar_t > PointList_traits;

      const PointList_optional&
      PointList () const;

      PointList_optional&
      PointList ();

      void
      PointList (const PointList_type& x);

      void
      PointList (const PointList_optional& x);

      void
      PointList (::std::unique_ptr< PointList_type > p);

      // SubstituteFeatureAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType SubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithm_type > SubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithm_type, wchar_t > SubstituteFeatureAlgorithm_traits;

      const SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm () const;

      SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm ();

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x);

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x);

      void
      SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > p);

      // ProxyMeasurementId
      //
      typedef ::xsd::qif30::QIFReferenceType ProxyMeasurementId_type;
      typedef ::xsd::cxx::tree::optional< ProxyMeasurementId_type > ProxyMeasurementId_optional;
      typedef ::xsd::cxx::tree::traits< ProxyMeasurementId_type, wchar_t > ProxyMeasurementId_traits;

      const ProxyMeasurementId_optional&
      ProxyMeasurementId () const;

      ProxyMeasurementId_optional&
      ProxyMeasurementId ();

      void
      ProxyMeasurementId (const ProxyMeasurementId_type& x);

      void
      ProxyMeasurementId (const ProxyMeasurementId_optional& x);

      void
      ProxyMeasurementId (::std::unique_ptr< ProxyMeasurementId_type > p);

      // Constructors.
      //
      ShapeFeatureMeasurementBaseType ();

      ShapeFeatureMeasurementBaseType (const id_type&);

      ShapeFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ShapeFeatureMeasurementBaseType (const ShapeFeatureMeasurementBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ShapeFeatureMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ShapeFeatureMeasurementBaseType&
      operator= (const ShapeFeatureMeasurementBaseType& x);

      virtual 
      ~ShapeFeatureMeasurementBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointList_optional PointList_;
      SubstituteFeatureAlgorithm_optional SubstituteFeatureAlgorithm_;
      ProxyMeasurementId_optional ProxyMeasurementId_;
    };

    class QIF30_SYMBOL_DECL NonShapeFeatureMeasurementBaseType: public ::xsd::qif30::FeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      NonShapeFeatureMeasurementBaseType ();

      NonShapeFeatureMeasurementBaseType (const id_type&);

      NonShapeFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      NonShapeFeatureMeasurementBaseType (const NonShapeFeatureMeasurementBaseType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual NonShapeFeatureMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      NonShapeFeatureMeasurementBaseType&
      operator= (const NonShapeFeatureMeasurementBaseType&) = default;
#endif

      virtual 
      ~NonShapeFeatureMeasurementBaseType ();
    };

    class QIF30_SYMBOL_DECL SetFeatureType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      SetFeatureType ();

      SetFeatureType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SetFeatureType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SetFeatureType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SetFeatureType (const SetFeatureType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SetFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SetFeatureType&
      operator= (const SetFeatureType&) = default;
#endif

      virtual 
      ~SetFeatureType ();
    };

    class QIF30_SYMBOL_DECL MeasuredFeatureType: public ::xml_schema::type
    {
      public:
      // PointList
      //
      typedef ::xsd::qif30::PointListType PointList_type;
      typedef ::xsd::cxx::tree::optional< PointList_type > PointList_optional;
      typedef ::xsd::cxx::tree::traits< PointList_type, wchar_t > PointList_traits;

      const PointList_optional&
      PointList () const;

      PointList_optional&
      PointList ();

      void
      PointList (const PointList_type& x);

      void
      PointList (const PointList_optional& x);

      void
      PointList (::std::unique_ptr< PointList_type > p);

      // Constructors.
      //
      MeasuredFeatureType ();

      MeasuredFeatureType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      MeasuredFeatureType (const MeasuredFeatureType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual MeasuredFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredFeatureType&
      operator= (const MeasuredFeatureType& x);

      virtual 
      ~MeasuredFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointList_optional PointList_;
    };

    class QIF30_SYMBOL_DECL ConstructionMethodBaseType: public ::xml_schema::type
    {
      public:
      // NominalsCalculated
      //
      typedef ::xml_schema::boolean NominalsCalculated_type;
      typedef ::xsd::cxx::tree::optional< NominalsCalculated_type > NominalsCalculated_optional;
      typedef ::xsd::cxx::tree::traits< NominalsCalculated_type, wchar_t > NominalsCalculated_traits;

      const NominalsCalculated_optional&
      NominalsCalculated () const;

      NominalsCalculated_optional&
      NominalsCalculated ();

      void
      NominalsCalculated (const NominalsCalculated_type& x);

      void
      NominalsCalculated (const NominalsCalculated_optional& x);

      // Constructors.
      //
      ConstructionMethodBaseType ();

      ConstructionMethodBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ConstructionMethodBaseType (const ConstructionMethodBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ConstructionMethodBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ConstructionMethodBaseType&
      operator= (const ConstructionMethodBaseType& x);

      virtual 
      ~ConstructionMethodBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NominalsCalculated_optional NominalsCalculated_;
    };

    class QIF30_SYMBOL_DECL PointRangeType: public ::xml_schema::type
    {
      public:
      // Start
      //
      typedef ::xsd::qif30::NaturalType Start_type;
      typedef ::xsd::cxx::tree::traits< Start_type, wchar_t > Start_traits;

      const Start_type&
      Start () const;

      Start_type&
      Start ();

      void
      Start (const Start_type& x);

      void
      Start (::std::unique_ptr< Start_type > p);

      // Stop
      //
      typedef ::xsd::qif30::NaturalType Stop_type;
      typedef ::xsd::cxx::tree::traits< Stop_type, wchar_t > Stop_traits;

      const Stop_type&
      Stop () const;

      Stop_type&
      Stop ();

      void
      Stop (const Stop_type& x);

      void
      Stop (::std::unique_ptr< Stop_type > p);

      // Constructors.
      //
      PointRangeType ();

      PointRangeType (const Start_type&,
                      const Stop_type&);

      PointRangeType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      PointRangeType (const PointRangeType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual PointRangeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointRangeType&
      operator= (const PointRangeType& x);

      virtual 
      ~PointRangeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Start_type > Start_;
      ::xsd::cxx::tree::one< Stop_type > Stop_;
    };

    class QIF30_SYMBOL_DECL PointIndexType: public ::xml_schema::type
    {
      public:
      // Single
      //
      typedef ::xsd::qif30::NaturalType Single_type;
      typedef ::xsd::cxx::tree::optional< Single_type > Single_optional;
      typedef ::xsd::cxx::tree::traits< Single_type, wchar_t > Single_traits;

      const Single_optional&
      Single () const;

      Single_optional&
      Single ();

      void
      Single (const Single_type& x);

      void
      Single (const Single_optional& x);

      void
      Single (::std::unique_ptr< Single_type > p);

      // Range
      //
      typedef ::xsd::qif30::PointRangeType Range_type;
      typedef ::xsd::cxx::tree::optional< Range_type > Range_optional;
      typedef ::xsd::cxx::tree::traits< Range_type, wchar_t > Range_traits;

      const Range_optional&
      Range () const;

      Range_optional&
      Range ();

      void
      Range (const Range_type& x);

      void
      Range (const Range_optional& x);

      void
      Range (::std::unique_ptr< Range_type > p);

      // All
      //
      typedef ::xml_schema::token All_type;
      typedef ::xsd::cxx::tree::optional< All_type > All_optional;
      typedef ::xsd::cxx::tree::traits< All_type, wchar_t > All_traits;

      const All_optional&
      All () const;

      All_optional&
      All ();

      void
      All (const All_type& x);

      void
      All (const All_optional& x);

      void
      All (::std::unique_ptr< All_type > p);

      static const All_type&
      All_default_value ();

      // Constructors.
      //
      PointIndexType ();

      PointIndexType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      PointIndexType (const PointIndexType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual PointIndexType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointIndexType&
      operator= (const PointIndexType& x);

      virtual 
      ~PointIndexType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Single_optional Single_;
      Range_optional Range_;
      All_optional All_;
      static const All_type All_default_value_;
    };

    class QIF30_SYMBOL_DECL BaseFeaturePointSetType: public ::xml_schema::type
    {
      public:
      // FeatureId
      //
      typedef ::xsd::qif30::QIFReferenceType FeatureId_type;
      typedef ::xsd::cxx::tree::traits< FeatureId_type, wchar_t > FeatureId_traits;

      const FeatureId_type&
      FeatureId () const;

      FeatureId_type&
      FeatureId ();

      void
      FeatureId (const FeatureId_type& x);

      void
      FeatureId (::std::unique_ptr< FeatureId_type > p);

      // PointIndex
      //
      typedef ::xsd::qif30::PointIndexType PointIndex_type;
      typedef ::xsd::cxx::tree::traits< PointIndex_type, wchar_t > PointIndex_traits;

      const PointIndex_type&
      PointIndex () const;

      PointIndex_type&
      PointIndex ();

      void
      PointIndex (const PointIndex_type& x);

      void
      PointIndex (::std::unique_ptr< PointIndex_type > p);

      // ReferencedComponent
      //
      typedef ::xsd::qif30::ReferencedComponentEnumType ReferencedComponent_type;
      typedef ::xsd::cxx::tree::traits< ReferencedComponent_type, wchar_t > ReferencedComponent_traits;

      const ReferencedComponent_type&
      ReferencedComponent () const;

      ReferencedComponent_type&
      ReferencedComponent ();

      void
      ReferencedComponent (const ReferencedComponent_type& x);

      void
      ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > p);

      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // Constructors.
      //
      BaseFeaturePointSetType ();

      BaseFeaturePointSetType (const FeatureId_type&,
                               const PointIndex_type&,
                               const ReferencedComponent_type&,
                               const SequenceNumber_type&);

      BaseFeaturePointSetType (::std::unique_ptr< FeatureId_type >,
                               ::std::unique_ptr< PointIndex_type >,
                               const ReferencedComponent_type&,
                               const SequenceNumber_type&);

      BaseFeaturePointSetType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      BaseFeaturePointSetType (const BaseFeaturePointSetType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual BaseFeaturePointSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BaseFeaturePointSetType&
      operator= (const BaseFeaturePointSetType& x);

      virtual 
      ~BaseFeaturePointSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureId_type > FeatureId_;
      ::xsd::cxx::tree::one< PointIndex_type > PointIndex_;
      ::xsd::cxx::tree::one< ReferencedComponent_type > ReferencedComponent_;
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class QIF30_SYMBOL_DECL BaseFeaturePointListType: public ::xml_schema::type
    {
      public:
      // BaseFeaturePointSet
      //
      typedef ::xsd::qif30::BaseFeaturePointSetType BaseFeaturePointSet_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeaturePointSet_type > BaseFeaturePointSet_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeaturePointSet_type >::iterator BaseFeaturePointSet_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeaturePointSet_type >::const_iterator BaseFeaturePointSet_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointSet_type, wchar_t > BaseFeaturePointSet_traits;

      const BaseFeaturePointSet_sequence&
      BaseFeaturePointSet () const;

      BaseFeaturePointSet_sequence&
      BaseFeaturePointSet ();

      void
      BaseFeaturePointSet (const BaseFeaturePointSet_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      BaseFeaturePointListType ();

      BaseFeaturePointListType (const n_type&);

      BaseFeaturePointListType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      BaseFeaturePointListType (const BaseFeaturePointListType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual BaseFeaturePointListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BaseFeaturePointListType&
      operator= (const BaseFeaturePointListType& x);

      virtual 
      ~BaseFeaturePointListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeaturePointSet_sequence BaseFeaturePointSet_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL TransformationReferenceType: public ::xml_schema::type
    {
      public:
      // ReferencedComponent
      //
      typedef ::xsd::qif30::ReferencedComponentEnumType ReferencedComponent_type;
      typedef ::xsd::cxx::tree::traits< ReferencedComponent_type, wchar_t > ReferencedComponent_traits;

      const ReferencedComponent_type&
      ReferencedComponent () const;

      ReferencedComponent_type&
      ReferencedComponent ();

      void
      ReferencedComponent (const ReferencedComponent_type& x);

      void
      ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_type&
      CoordinateSystemId () const;

      CoordinateSystemId_type&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // Constructors.
      //
      TransformationReferenceType ();

      TransformationReferenceType (const ReferencedComponent_type&,
                                   const CoordinateSystemId_type&,
                                   const SequenceNumber_type&);

      TransformationReferenceType (const ReferencedComponent_type&,
                                   ::std::unique_ptr< CoordinateSystemId_type >,
                                   const SequenceNumber_type&);

      TransformationReferenceType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      TransformationReferenceType (const TransformationReferenceType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual TransformationReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformationReferenceType&
      operator= (const TransformationReferenceType& x);

      virtual 
      ~TransformationReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ReferencedComponent_type > ReferencedComponent_;
      ::xsd::cxx::tree::one< CoordinateSystemId_type > CoordinateSystemId_;
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class QIF30_SYMBOL_DECL SurfaceFeatureItemBaseType: public ::xsd::qif30::ShapeFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      SurfaceFeatureItemBaseType ();

      SurfaceFeatureItemBaseType (const id_type&,
                                  const FeatureNominalId_type&,
                                  const FeatureName_type&);

      SurfaceFeatureItemBaseType (const id_type&,
                                  ::std::unique_ptr< FeatureNominalId_type >,
                                  const FeatureName_type&);

      SurfaceFeatureItemBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      SurfaceFeatureItemBaseType (const SurfaceFeatureItemBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual SurfaceFeatureItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SurfaceFeatureItemBaseType&
      operator= (const SurfaceFeatureItemBaseType&) = default;
#endif

      virtual 
      ~SurfaceFeatureItemBaseType ();
    };

    class QIF30_SYMBOL_DECL SurfaceFeatureDefinitionBaseType: public ::xsd::qif30::ShapeFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      SurfaceFeatureDefinitionBaseType ();

      SurfaceFeatureDefinitionBaseType (const id_type&);

      SurfaceFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      SurfaceFeatureDefinitionBaseType (const SurfaceFeatureDefinitionBaseType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual SurfaceFeatureDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SurfaceFeatureDefinitionBaseType&
      operator= (const SurfaceFeatureDefinitionBaseType&) = default;
#endif

      virtual 
      ~SurfaceFeatureDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL SurfaceFeatureNominalBaseType: public ::xsd::qif30::ShapeFeatureNominalBaseType
    {
      public:
      // Constructors.
      //
      SurfaceFeatureNominalBaseType ();

      SurfaceFeatureNominalBaseType (const id_type&,
                                     const FeatureDefinitionId_type&);

      SurfaceFeatureNominalBaseType (const id_type&,
                                     ::std::unique_ptr< FeatureDefinitionId_type >);

      SurfaceFeatureNominalBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      SurfaceFeatureNominalBaseType (const SurfaceFeatureNominalBaseType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual SurfaceFeatureNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SurfaceFeatureNominalBaseType&
      operator= (const SurfaceFeatureNominalBaseType&) = default;
#endif

      virtual 
      ~SurfaceFeatureNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL SurfaceFeatureMeasurementBaseType: public ::xsd::qif30::ShapeFeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      SurfaceFeatureMeasurementBaseType ();

      SurfaceFeatureMeasurementBaseType (const id_type&);

      SurfaceFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      SurfaceFeatureMeasurementBaseType (const SurfaceFeatureMeasurementBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual SurfaceFeatureMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SurfaceFeatureMeasurementBaseType&
      operator= (const SurfaceFeatureMeasurementBaseType&) = default;
#endif

      virtual 
      ~SurfaceFeatureMeasurementBaseType ();
    };

    class QIF30_SYMBOL_DECL CurveFeatureItemBaseType: public ::xsd::qif30::ShapeFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      CurveFeatureItemBaseType ();

      CurveFeatureItemBaseType (const id_type&,
                                const FeatureNominalId_type&,
                                const FeatureName_type&);

      CurveFeatureItemBaseType (const id_type&,
                                ::std::unique_ptr< FeatureNominalId_type >,
                                const FeatureName_type&);

      CurveFeatureItemBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CurveFeatureItemBaseType (const CurveFeatureItemBaseType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CurveFeatureItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CurveFeatureItemBaseType&
      operator= (const CurveFeatureItemBaseType&) = default;
#endif

      virtual 
      ~CurveFeatureItemBaseType ();
    };

    class QIF30_SYMBOL_DECL CurveFeatureDefinitionBaseType: public ::xsd::qif30::ShapeFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      CurveFeatureDefinitionBaseType ();

      CurveFeatureDefinitionBaseType (const id_type&);

      CurveFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      CurveFeatureDefinitionBaseType (const CurveFeatureDefinitionBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual CurveFeatureDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CurveFeatureDefinitionBaseType&
      operator= (const CurveFeatureDefinitionBaseType&) = default;
#endif

      virtual 
      ~CurveFeatureDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL CurveFeatureNominalBaseType: public ::xsd::qif30::ShapeFeatureNominalBaseType
    {
      public:
      // SurfaceFeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType SurfaceFeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< SurfaceFeatureNominalId_type > SurfaceFeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceFeatureNominalId_type, wchar_t > SurfaceFeatureNominalId_traits;

      const SurfaceFeatureNominalId_optional&
      SurfaceFeatureNominalId () const;

      SurfaceFeatureNominalId_optional&
      SurfaceFeatureNominalId ();

      void
      SurfaceFeatureNominalId (const SurfaceFeatureNominalId_type& x);

      void
      SurfaceFeatureNominalId (const SurfaceFeatureNominalId_optional& x);

      void
      SurfaceFeatureNominalId (::std::unique_ptr< SurfaceFeatureNominalId_type > p);

      // Constructors.
      //
      CurveFeatureNominalBaseType ();

      CurveFeatureNominalBaseType (const id_type&,
                                   const FeatureDefinitionId_type&);

      CurveFeatureNominalBaseType (const id_type&,
                                   ::std::unique_ptr< FeatureDefinitionId_type >);

      CurveFeatureNominalBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      CurveFeatureNominalBaseType (const CurveFeatureNominalBaseType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual CurveFeatureNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CurveFeatureNominalBaseType&
      operator= (const CurveFeatureNominalBaseType& x);

      virtual 
      ~CurveFeatureNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SurfaceFeatureNominalId_optional SurfaceFeatureNominalId_;
    };

    class QIF30_SYMBOL_DECL CurveFeatureMeasurementBaseType: public ::xsd::qif30::ShapeFeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      CurveFeatureMeasurementBaseType ();

      CurveFeatureMeasurementBaseType (const id_type&);

      CurveFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CurveFeatureMeasurementBaseType (const CurveFeatureMeasurementBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CurveFeatureMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      CurveFeatureMeasurementBaseType&
      operator= (const CurveFeatureMeasurementBaseType&) = default;
#endif

      virtual 
      ~CurveFeatureMeasurementBaseType ();
    };

    class QIF30_SYMBOL_DECL PointFeatureItemBaseType: public ::xsd::qif30::ShapeFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      PointFeatureItemBaseType ();

      PointFeatureItemBaseType (const id_type&,
                                const FeatureNominalId_type&,
                                const FeatureName_type&);

      PointFeatureItemBaseType (const id_type&,
                                ::std::unique_ptr< FeatureNominalId_type >,
                                const FeatureName_type&);

      PointFeatureItemBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      PointFeatureItemBaseType (const PointFeatureItemBaseType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual PointFeatureItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PointFeatureItemBaseType&
      operator= (const PointFeatureItemBaseType&) = default;
#endif

      virtual 
      ~PointFeatureItemBaseType ();
    };

    class QIF30_SYMBOL_DECL PointFeatureDefinitionBaseType: public ::xsd::qif30::ShapeFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      PointFeatureDefinitionBaseType ();

      PointFeatureDefinitionBaseType (const id_type&);

      PointFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PointFeatureDefinitionBaseType (const PointFeatureDefinitionBaseType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PointFeatureDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PointFeatureDefinitionBaseType&
      operator= (const PointFeatureDefinitionBaseType&) = default;
#endif

      virtual 
      ~PointFeatureDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL PointFeatureNominalBaseType: public ::xsd::qif30::ShapeFeatureNominalBaseType
    {
      public:
      // SurfaceFeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType SurfaceFeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< SurfaceFeatureNominalId_type > SurfaceFeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceFeatureNominalId_type, wchar_t > SurfaceFeatureNominalId_traits;

      const SurfaceFeatureNominalId_optional&
      SurfaceFeatureNominalId () const;

      SurfaceFeatureNominalId_optional&
      SurfaceFeatureNominalId ();

      void
      SurfaceFeatureNominalId (const SurfaceFeatureNominalId_type& x);

      void
      SurfaceFeatureNominalId (const SurfaceFeatureNominalId_optional& x);

      void
      SurfaceFeatureNominalId (::std::unique_ptr< SurfaceFeatureNominalId_type > p);

      // CurveFeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CurveFeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< CurveFeatureNominalId_type > CurveFeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< CurveFeatureNominalId_type, wchar_t > CurveFeatureNominalId_traits;

      const CurveFeatureNominalId_optional&
      CurveFeatureNominalId () const;

      CurveFeatureNominalId_optional&
      CurveFeatureNominalId ();

      void
      CurveFeatureNominalId (const CurveFeatureNominalId_type& x);

      void
      CurveFeatureNominalId (const CurveFeatureNominalId_optional& x);

      void
      CurveFeatureNominalId (::std::unique_ptr< CurveFeatureNominalId_type > p);

      // Constructors.
      //
      PointFeatureNominalBaseType ();

      PointFeatureNominalBaseType (const id_type&,
                                   const FeatureDefinitionId_type&);

      PointFeatureNominalBaseType (const id_type&,
                                   ::std::unique_ptr< FeatureDefinitionId_type >);

      PointFeatureNominalBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PointFeatureNominalBaseType (const PointFeatureNominalBaseType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PointFeatureNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      PointFeatureNominalBaseType&
      operator= (const PointFeatureNominalBaseType& x);

      virtual 
      ~PointFeatureNominalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SurfaceFeatureNominalId_optional SurfaceFeatureNominalId_;
      CurveFeatureNominalId_optional CurveFeatureNominalId_;
    };

    class QIF30_SYMBOL_DECL PointFeatureMeasurementBaseType: public ::xsd::qif30::ShapeFeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      PointFeatureMeasurementBaseType ();

      PointFeatureMeasurementBaseType (const id_type&);

      PointFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      PointFeatureMeasurementBaseType (const PointFeatureMeasurementBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual PointFeatureMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PointFeatureMeasurementBaseType&
      operator= (const PointFeatureMeasurementBaseType&) = default;
#endif

      virtual 
      ~PointFeatureMeasurementBaseType ();
    };

    class QIF30_SYMBOL_DECL SpecifiedFeatureItemBaseType: public ::xsd::qif30::ShapeFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      SpecifiedFeatureItemBaseType ();

      SpecifiedFeatureItemBaseType (const id_type&,
                                    const FeatureNominalId_type&,
                                    const FeatureName_type&);

      SpecifiedFeatureItemBaseType (const id_type&,
                                    ::std::unique_ptr< FeatureNominalId_type >,
                                    const FeatureName_type&);

      SpecifiedFeatureItemBaseType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SpecifiedFeatureItemBaseType (const SpecifiedFeatureItemBaseType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SpecifiedFeatureItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SpecifiedFeatureItemBaseType&
      operator= (const SpecifiedFeatureItemBaseType&) = default;
#endif

      virtual 
      ~SpecifiedFeatureItemBaseType ();
    };

    class QIF30_SYMBOL_DECL SpecifiedFeatureDefinitionBaseType: public ::xsd::qif30::ShapeFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      SpecifiedFeatureDefinitionBaseType ();

      SpecifiedFeatureDefinitionBaseType (const id_type&);

      SpecifiedFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SpecifiedFeatureDefinitionBaseType (const SpecifiedFeatureDefinitionBaseType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SpecifiedFeatureDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SpecifiedFeatureDefinitionBaseType&
      operator= (const SpecifiedFeatureDefinitionBaseType&) = default;
#endif

      virtual 
      ~SpecifiedFeatureDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL SpecifiedFeatureNominalBaseType: public ::xsd::qif30::ShapeFeatureNominalBaseType
    {
      public:
      // Constructors.
      //
      SpecifiedFeatureNominalBaseType ();

      SpecifiedFeatureNominalBaseType (const id_type&,
                                       const FeatureDefinitionId_type&);

      SpecifiedFeatureNominalBaseType (const id_type&,
                                       ::std::unique_ptr< FeatureDefinitionId_type >);

      SpecifiedFeatureNominalBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SpecifiedFeatureNominalBaseType (const SpecifiedFeatureNominalBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SpecifiedFeatureNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SpecifiedFeatureNominalBaseType&
      operator= (const SpecifiedFeatureNominalBaseType&) = default;
#endif

      virtual 
      ~SpecifiedFeatureNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL SpecifiedFeatureMeasurementBaseType: public ::xsd::qif30::ShapeFeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      SpecifiedFeatureMeasurementBaseType ();

      SpecifiedFeatureMeasurementBaseType (const id_type&);

      SpecifiedFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      SpecifiedFeatureMeasurementBaseType (const SpecifiedFeatureMeasurementBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual SpecifiedFeatureMeasurementBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SpecifiedFeatureMeasurementBaseType&
      operator= (const SpecifiedFeatureMeasurementBaseType&) = default;
#endif

      virtual 
      ~SpecifiedFeatureMeasurementBaseType ();
    };

    class QIF30_SYMBOL_DECL CircleConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::CircleBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::CircleRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Intersection
      //
      typedef ::xsd::qif30::CircleIntersectionType Intersection_type;
      typedef ::xsd::cxx::tree::optional< Intersection_type > Intersection_optional;
      typedef ::xsd::cxx::tree::traits< Intersection_type, wchar_t > Intersection_traits;

      const Intersection_optional&
      Intersection () const;

      Intersection_optional&
      Intersection ();

      void
      Intersection (const Intersection_type& x);

      void
      Intersection (const Intersection_optional& x);

      void
      Intersection (::std::unique_ptr< Intersection_type > p);

      // Projection
      //
      typedef ::xsd::qif30::CircleProjectionType Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      void
      Projection (::std::unique_ptr< Projection_type > p);

      // Copy
      //
      typedef ::xsd::qif30::CircleCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::CircleCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Tangent
      //
      typedef ::xsd::qif30::CircleTangentType Tangent_type;
      typedef ::xsd::cxx::tree::optional< Tangent_type > Tangent_optional;
      typedef ::xsd::cxx::tree::traits< Tangent_type, wchar_t > Tangent_traits;

      const Tangent_optional&
      Tangent () const;

      Tangent_optional&
      Tangent ();

      void
      Tangent (const Tangent_type& x);

      void
      Tangent (const Tangent_optional& x);

      void
      Tangent (::std::unique_ptr< Tangent_type > p);

      // TangentThrough
      //
      typedef ::xsd::qif30::CircleTangentThroughType TangentThrough_type;
      typedef ::xsd::cxx::tree::optional< TangentThrough_type > TangentThrough_optional;
      typedef ::xsd::cxx::tree::traits< TangentThrough_type, wchar_t > TangentThrough_traits;

      const TangentThrough_optional&
      TangentThrough () const;

      TangentThrough_optional&
      TangentThrough ();

      void
      TangentThrough (const TangentThrough_type& x);

      void
      TangentThrough (const TangentThrough_optional& x);

      void
      TangentThrough (::std::unique_ptr< TangentThrough_type > p);

      // Transform
      //
      typedef ::xsd::qif30::CircleTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromCone
      //
      typedef ::xsd::qif30::CircleFromConeType FromCone_type;
      typedef ::xsd::cxx::tree::optional< FromCone_type > FromCone_optional;
      typedef ::xsd::cxx::tree::traits< FromCone_type, wchar_t > FromCone_traits;

      const FromCone_optional&
      FromCone () const;

      FromCone_optional&
      FromCone ();

      void
      FromCone (const FromCone_type& x);

      void
      FromCone (const FromCone_optional& x);

      void
      FromCone (::std::unique_ptr< FromCone_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::CircleFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      CircleConstructionMethodType ();

      CircleConstructionMethodType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CircleConstructionMethodType (const CircleConstructionMethodType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual CircleConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleConstructionMethodType&
      operator= (const CircleConstructionMethodType& x);

      virtual 
      ~CircleConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Intersection_optional Intersection_;
      Projection_optional Projection_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Tangent_optional Tangent_;
      TangentThrough_optional TangentThrough_;
      Transform_optional Transform_;
      FromCone_optional FromCone_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL CircleBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CircleBestFitType ();

      CircleBestFitType (const n_type&);

      CircleBestFitType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CircleBestFitType (const CircleBestFitType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CircleBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleBestFitType&
      operator= (const CircleBestFitType& x);

      virtual 
      ~CircleBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CircleRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      CircleRecompType ();

      CircleRecompType (const BaseFeaturePointList_type&);

      CircleRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      CircleRecompType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      CircleRecompType (const CircleRecompType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual CircleRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleRecompType&
      operator= (const CircleRecompType& x);

      virtual 
      ~CircleRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL CircleIntersectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // IntersectionFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType IntersectionFeature_type;
      typedef ::xsd::cxx::tree::sequence< IntersectionFeature_type > IntersectionFeature_sequence;
      typedef xsd::cxx::tree::sequence< IntersectionFeature_type >::iterator IntersectionFeature_iterator;
      typedef xsd::cxx::tree::sequence< IntersectionFeature_type >::const_iterator IntersectionFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< IntersectionFeature_type, wchar_t > IntersectionFeature_traits;

      const IntersectionFeature_sequence&
      IntersectionFeature () const;

      IntersectionFeature_sequence&
      IntersectionFeature ();

      void
      IntersectionFeature (const IntersectionFeature_sequence& s);

      // Constructors.
      //
      CircleIntersectionType ();

      CircleIntersectionType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CircleIntersectionType (const CircleIntersectionType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual CircleIntersectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleIntersectionType&
      operator= (const CircleIntersectionType& x);

      virtual 
      ~CircleIntersectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IntersectionFeature_sequence IntersectionFeature_;
    };

    class QIF30_SYMBOL_DECL CircleProjectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ProjectionCircle
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionCircle_type;
      typedef ::xsd::cxx::tree::traits< ProjectionCircle_type, wchar_t > ProjectionCircle_traits;

      const ProjectionCircle_type&
      ProjectionCircle () const;

      ProjectionCircle_type&
      ProjectionCircle ();

      void
      ProjectionCircle (const ProjectionCircle_type& x);

      void
      ProjectionCircle (::std::unique_ptr< ProjectionCircle_type > p);

      // ProjectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionPlane_type;
      typedef ::xsd::cxx::tree::traits< ProjectionPlane_type, wchar_t > ProjectionPlane_traits;

      const ProjectionPlane_type&
      ProjectionPlane () const;

      ProjectionPlane_type&
      ProjectionPlane ();

      void
      ProjectionPlane (const ProjectionPlane_type& x);

      void
      ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > p);

      // Constructors.
      //
      CircleProjectionType ();

      CircleProjectionType (const ProjectionCircle_type&,
                            const ProjectionPlane_type&);

      CircleProjectionType (::std::unique_ptr< ProjectionCircle_type >,
                            ::std::unique_ptr< ProjectionPlane_type >);

      CircleProjectionType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CircleProjectionType (const CircleProjectionType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CircleProjectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleProjectionType&
      operator= (const CircleProjectionType& x);

      virtual 
      ~CircleProjectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProjectionCircle_type > ProjectionCircle_;
      ::xsd::cxx::tree::one< ProjectionPlane_type > ProjectionPlane_;
    };

    class QIF30_SYMBOL_DECL CircleCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCircle
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCircle_type;
      typedef ::xsd::cxx::tree::traits< BaseCircle_type, wchar_t > BaseCircle_traits;

      const BaseCircle_type&
      BaseCircle () const;

      BaseCircle_type&
      BaseCircle ();

      void
      BaseCircle (const BaseCircle_type& x);

      void
      BaseCircle (::std::unique_ptr< BaseCircle_type > p);

      // Constructors.
      //
      CircleCopyType ();

      CircleCopyType (const BaseCircle_type&);

      CircleCopyType (::std::unique_ptr< BaseCircle_type >);

      CircleCopyType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      CircleCopyType (const CircleCopyType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual CircleCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleCopyType&
      operator= (const CircleCopyType& x);

      virtual 
      ~CircleCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCircle_type > BaseCircle_;
    };

    class QIF30_SYMBOL_DECL CircleCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      CircleCastType ();

      CircleCastType (const BaseFeature_type&);

      CircleCastType (::std::unique_ptr< BaseFeature_type >);

      CircleCastType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      CircleCastType (const CircleCastType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual CircleCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleCastType&
      operator= (const CircleCastType& x);

      virtual 
      ~CircleCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL CircleTangentType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // TangentFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType TangentFeature_type;
      typedef ::xsd::cxx::tree::sequence< TangentFeature_type > TangentFeature_sequence;
      typedef xsd::cxx::tree::sequence< TangentFeature_type >::iterator TangentFeature_iterator;
      typedef xsd::cxx::tree::sequence< TangentFeature_type >::const_iterator TangentFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< TangentFeature_type, wchar_t > TangentFeature_traits;

      const TangentFeature_sequence&
      TangentFeature () const;

      TangentFeature_sequence&
      TangentFeature ();

      void
      TangentFeature (const TangentFeature_sequence& s);

      // Constructors.
      //
      CircleTangentType ();

      CircleTangentType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CircleTangentType (const CircleTangentType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CircleTangentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleTangentType&
      operator= (const CircleTangentType& x);

      virtual 
      ~CircleTangentType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TangentFeature_sequence TangentFeature_;
    };

    class QIF30_SYMBOL_DECL CircleTangentThroughType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // TangentFeature
      //
      typedef ::xsd::qif30::BaseFeatureType TangentFeature_type;
      typedef ::xsd::cxx::tree::traits< TangentFeature_type, wchar_t > TangentFeature_traits;

      const TangentFeature_type&
      TangentFeature () const;

      TangentFeature_type&
      TangentFeature ();

      void
      TangentFeature (const TangentFeature_type& x);

      void
      TangentFeature (::std::unique_ptr< TangentFeature_type > p);

      // PointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PointFeature_type;
      typedef ::xsd::cxx::tree::traits< PointFeature_type, wchar_t > PointFeature_traits;

      const PointFeature_type&
      PointFeature () const;

      PointFeature_type&
      PointFeature ();

      void
      PointFeature (const PointFeature_type& x);

      void
      PointFeature (::std::unique_ptr< PointFeature_type > p);

      // Constructors.
      //
      CircleTangentThroughType ();

      CircleTangentThroughType (const TangentFeature_type&,
                                const PointFeature_type&);

      CircleTangentThroughType (::std::unique_ptr< TangentFeature_type >,
                                ::std::unique_ptr< PointFeature_type >);

      CircleTangentThroughType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CircleTangentThroughType (const CircleTangentThroughType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CircleTangentThroughType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleTangentThroughType&
      operator= (const CircleTangentThroughType& x);

      virtual 
      ~CircleTangentThroughType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TangentFeature_type > TangentFeature_;
      ::xsd::cxx::tree::one< PointFeature_type > PointFeature_;
    };

    class QIF30_SYMBOL_DECL CircleTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCircle
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCircle_type;
      typedef ::xsd::cxx::tree::traits< BaseCircle_type, wchar_t > BaseCircle_traits;

      const BaseCircle_type&
      BaseCircle () const;

      BaseCircle_type&
      BaseCircle ();

      void
      BaseCircle (const BaseCircle_type& x);

      void
      BaseCircle (::std::unique_ptr< BaseCircle_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      CircleTransformType ();

      CircleTransformType (const BaseCircle_type&,
                           const Transformation_type&);

      CircleTransformType (::std::unique_ptr< BaseCircle_type >,
                           ::std::unique_ptr< Transformation_type >);

      CircleTransformType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CircleTransformType (const CircleTransformType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CircleTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleTransformType&
      operator= (const CircleTransformType& x);

      virtual 
      ~CircleTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCircle_type > BaseCircle_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL CircleFromConeType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Distance
      //
      typedef ::xsd::qif30::LinearValueType Distance_type;
      typedef ::xsd::cxx::tree::optional< Distance_type > Distance_optional;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t > Distance_traits;

      const Distance_optional&
      Distance () const;

      Distance_optional&
      Distance ();

      void
      Distance (const Distance_type& x);

      void
      Distance (const Distance_optional& x);

      void
      Distance (::std::unique_ptr< Distance_type > p);

      // Constructors.
      //
      CircleFromConeType ();

      CircleFromConeType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CircleFromConeType (const CircleFromConeType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual CircleFromConeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleFromConeType&
      operator= (const CircleFromConeType& x);

      virtual 
      ~CircleFromConeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Diameter_optional Diameter_;
      Distance_optional Distance_;
    };

    class QIF30_SYMBOL_DECL CircleFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_type&
      Depth () const;

      Depth_type&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Constructors.
      //
      CircleFromScanType ();

      CircleFromScanType (const SurfaceFeature_type&,
                          const SearchRadius_type&,
                          const Depth_type&);

      CircleFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                          ::std::unique_ptr< SearchRadius_type >,
                          ::std::unique_ptr< Depth_type >);

      CircleFromScanType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CircleFromScanType (const CircleFromScanType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual CircleFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleFromScanType&
      operator= (const CircleFromScanType& x);

      virtual 
      ~CircleFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      ::xsd::cxx::tree::one< Depth_type > Depth_;
    };

    class QIF30_SYMBOL_DECL CircleCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::CircleConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      CircleCheckedType ();

      CircleCheckedType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CircleCheckedType (const CircleCheckedType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CircleCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleCheckedType&
      operator= (const CircleCheckedType& x);

      virtual 
      ~CircleCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL CircleCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::CircleCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      CircleCheckedFeatureType ();

      CircleCheckedFeatureType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CircleCheckedFeatureType (const CircleCheckedFeatureType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CircleCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleCheckedFeatureType&
      operator= (const CircleCheckedFeatureType& x);

      virtual 
      ~CircleCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL CircleMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::CircleCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      CircleMeasurementDeterminationType ();

      CircleMeasurementDeterminationType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      CircleMeasurementDeterminationType (const CircleMeasurementDeterminationType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual CircleMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleMeasurementDeterminationType&
      operator= (const CircleMeasurementDeterminationType& x);

      virtual 
      ~CircleMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL CircleFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::CircleMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      CircleFeatureItemType ();

      CircleFeatureItemType (const id_type&,
                             const FeatureNominalId_type&,
                             const FeatureName_type&,
                             const DeterminationMode_type&);

      CircleFeatureItemType (const id_type&,
                             ::std::unique_ptr< FeatureNominalId_type >,
                             const FeatureName_type&,
                             ::std::unique_ptr< DeterminationMode_type >);

      CircleFeatureItemType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CircleFeatureItemType (const CircleFeatureItemType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CircleFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleFeatureItemType&
      operator= (const CircleFeatureItemType& x);

      virtual 
      ~CircleFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL CircleFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Constructors.
      //
      CircleFeatureDefinitionType ();

      CircleFeatureDefinitionType (const id_type&,
                                   const InternalExternal_type&,
                                   const Diameter_type&);

      CircleFeatureDefinitionType (const id_type&,
                                   const InternalExternal_type&,
                                   ::std::unique_ptr< Diameter_type >);

      CircleFeatureDefinitionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      CircleFeatureDefinitionType (const CircleFeatureDefinitionType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual CircleFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleFeatureDefinitionType&
      operator= (const CircleFeatureDefinitionType& x);

      virtual 
      ~CircleFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
    };

    class QIF30_SYMBOL_DECL CircleFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::optional< Sweep_type > Sweep_optional;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_optional&
      Sweep () const;

      Sweep_optional&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (const Sweep_optional& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::CircleConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      CircleFeatureNominalType ();

      CircleFeatureNominalType (const id_type&,
                                const FeatureDefinitionId_type&,
                                const Location_type&,
                                const Normal_type&);

      CircleFeatureNominalType (const id_type&,
                                ::std::unique_ptr< FeatureDefinitionId_type >,
                                ::std::unique_ptr< Location_type >,
                                ::std::unique_ptr< Normal_type >);

      CircleFeatureNominalType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CircleFeatureNominalType (const CircleFeatureNominalType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CircleFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleFeatureNominalType&
      operator= (const CircleFeatureNominalType& x);

      virtual 
      ~CircleFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      Sweep_optional Sweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL CircleFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // Constructors.
      //
      CircleFeatureMeasurementType ();

      CircleFeatureMeasurementType (const id_type&);

      CircleFeatureMeasurementType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CircleFeatureMeasurementType (const CircleFeatureMeasurementType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual CircleFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircleFeatureMeasurementType&
      operator= (const CircleFeatureMeasurementType& x);

      virtual 
      ~CircleFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      Normal_optional Normal_;
      Diameter_optional Diameter_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      Form_optional Form_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
    };

    class QIF30_SYMBOL_DECL CircularArcConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::CircularArcBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Intersection
      //
      typedef ::xsd::qif30::CircularArcIntersectionType Intersection_type;
      typedef ::xsd::cxx::tree::optional< Intersection_type > Intersection_optional;
      typedef ::xsd::cxx::tree::traits< Intersection_type, wchar_t > Intersection_traits;

      const Intersection_optional&
      Intersection () const;

      Intersection_optional&
      Intersection ();

      void
      Intersection (const Intersection_type& x);

      void
      Intersection (const Intersection_optional& x);

      void
      Intersection (::std::unique_ptr< Intersection_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::CircularArcRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Projection
      //
      typedef ::xsd::qif30::CircularArcProjectionType Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      void
      Projection (::std::unique_ptr< Projection_type > p);

      // Copy
      //
      typedef ::xsd::qif30::CircularArcCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::CircularArcCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::CircularArcTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::CircularArcFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Extract
      //
      typedef ::xsd::qif30::CircularArcExtractType Extract_type;
      typedef ::xsd::cxx::tree::optional< Extract_type > Extract_optional;
      typedef ::xsd::cxx::tree::traits< Extract_type, wchar_t > Extract_traits;

      const Extract_optional&
      Extract () const;

      Extract_optional&
      Extract ();

      void
      Extract (const Extract_type& x);

      void
      Extract (const Extract_optional& x);

      void
      Extract (::std::unique_ptr< Extract_type > p);

      // Constructors.
      //
      CircularArcConstructionMethodType ();

      CircularArcConstructionMethodType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CircularArcConstructionMethodType (const CircularArcConstructionMethodType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CircularArcConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcConstructionMethodType&
      operator= (const CircularArcConstructionMethodType& x);

      virtual 
      ~CircularArcConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Intersection_optional Intersection_;
      Recompensated_optional Recompensated_;
      Projection_optional Projection_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
      Extract_optional Extract_;
    };

    class QIF30_SYMBOL_DECL CircularArcBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CircularArcBestFitType ();

      CircularArcBestFitType (const n_type&);

      CircularArcBestFitType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CircularArcBestFitType (const CircularArcBestFitType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual CircularArcBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcBestFitType&
      operator= (const CircularArcBestFitType& x);

      virtual 
      ~CircularArcBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CircularArcRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      CircularArcRecompType ();

      CircularArcRecompType (const BaseFeaturePointList_type&);

      CircularArcRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      CircularArcRecompType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CircularArcRecompType (const CircularArcRecompType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CircularArcRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcRecompType&
      operator= (const CircularArcRecompType& x);

      virtual 
      ~CircularArcRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL CircularArcProjectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ProjectionArc
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionArc_type;
      typedef ::xsd::cxx::tree::traits< ProjectionArc_type, wchar_t > ProjectionArc_traits;

      const ProjectionArc_type&
      ProjectionArc () const;

      ProjectionArc_type&
      ProjectionArc ();

      void
      ProjectionArc (const ProjectionArc_type& x);

      void
      ProjectionArc (::std::unique_ptr< ProjectionArc_type > p);

      // ProjectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionPlane_type;
      typedef ::xsd::cxx::tree::traits< ProjectionPlane_type, wchar_t > ProjectionPlane_traits;

      const ProjectionPlane_type&
      ProjectionPlane () const;

      ProjectionPlane_type&
      ProjectionPlane ();

      void
      ProjectionPlane (const ProjectionPlane_type& x);

      void
      ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > p);

      // Constructors.
      //
      CircularArcProjectionType ();

      CircularArcProjectionType (const ProjectionArc_type&,
                                 const ProjectionPlane_type&);

      CircularArcProjectionType (::std::unique_ptr< ProjectionArc_type >,
                                 ::std::unique_ptr< ProjectionPlane_type >);

      CircularArcProjectionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      CircularArcProjectionType (const CircularArcProjectionType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual CircularArcProjectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcProjectionType&
      operator= (const CircularArcProjectionType& x);

      virtual 
      ~CircularArcProjectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProjectionArc_type > ProjectionArc_;
      ::xsd::cxx::tree::one< ProjectionPlane_type > ProjectionPlane_;
    };

    class QIF30_SYMBOL_DECL CircularArcCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseArc
      //
      typedef ::xsd::qif30::BaseFeatureType BaseArc_type;
      typedef ::xsd::cxx::tree::traits< BaseArc_type, wchar_t > BaseArc_traits;

      const BaseArc_type&
      BaseArc () const;

      BaseArc_type&
      BaseArc ();

      void
      BaseArc (const BaseArc_type& x);

      void
      BaseArc (::std::unique_ptr< BaseArc_type > p);

      // Constructors.
      //
      CircularArcCopyType ();

      CircularArcCopyType (const BaseArc_type&);

      CircularArcCopyType (::std::unique_ptr< BaseArc_type >);

      CircularArcCopyType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CircularArcCopyType (const CircularArcCopyType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CircularArcCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcCopyType&
      operator= (const CircularArcCopyType& x);

      virtual 
      ~CircularArcCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseArc_type > BaseArc_;
    };

    class QIF30_SYMBOL_DECL CircularArcCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      CircularArcCastType ();

      CircularArcCastType (const BaseFeature_type&);

      CircularArcCastType (::std::unique_ptr< BaseFeature_type >);

      CircularArcCastType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CircularArcCastType (const CircularArcCastType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CircularArcCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcCastType&
      operator= (const CircularArcCastType& x);

      virtual 
      ~CircularArcCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL CircularArcTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseArc
      //
      typedef ::xsd::qif30::BaseFeatureType BaseArc_type;
      typedef ::xsd::cxx::tree::traits< BaseArc_type, wchar_t > BaseArc_traits;

      const BaseArc_type&
      BaseArc () const;

      BaseArc_type&
      BaseArc ();

      void
      BaseArc (const BaseArc_type& x);

      void
      BaseArc (::std::unique_ptr< BaseArc_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      CircularArcTransformType ();

      CircularArcTransformType (const BaseArc_type&,
                                const Transformation_type&);

      CircularArcTransformType (::std::unique_ptr< BaseArc_type >,
                                ::std::unique_ptr< Transformation_type >);

      CircularArcTransformType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CircularArcTransformType (const CircularArcTransformType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CircularArcTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcTransformType&
      operator= (const CircularArcTransformType& x);

      virtual 
      ~CircularArcTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseArc_type > BaseArc_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL CircularArcFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_type&
      Depth () const;

      Depth_type&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Constructors.
      //
      CircularArcFromScanType ();

      CircularArcFromScanType (const SurfaceFeature_type&,
                               const SearchRadius_type&,
                               const Depth_type&);

      CircularArcFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                               ::std::unique_ptr< SearchRadius_type >,
                               ::std::unique_ptr< Depth_type >);

      CircularArcFromScanType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CircularArcFromScanType (const CircularArcFromScanType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CircularArcFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcFromScanType&
      operator= (const CircularArcFromScanType& x);

      virtual 
      ~CircularArcFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      ::xsd::cxx::tree::one< Depth_type > Depth_;
    };

    class QIF30_SYMBOL_DECL CircularArcIntersectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // IntersectionFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType IntersectionFeature_type;
      typedef ::xsd::cxx::tree::sequence< IntersectionFeature_type > IntersectionFeature_sequence;
      typedef xsd::cxx::tree::sequence< IntersectionFeature_type >::iterator IntersectionFeature_iterator;
      typedef xsd::cxx::tree::sequence< IntersectionFeature_type >::const_iterator IntersectionFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< IntersectionFeature_type, wchar_t > IntersectionFeature_traits;

      const IntersectionFeature_sequence&
      IntersectionFeature () const;

      IntersectionFeature_sequence&
      IntersectionFeature ();

      void
      IntersectionFeature (const IntersectionFeature_sequence& s);

      // Constructors.
      //
      CircularArcIntersectionType ();

      CircularArcIntersectionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      CircularArcIntersectionType (const CircularArcIntersectionType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual CircularArcIntersectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcIntersectionType&
      operator= (const CircularArcIntersectionType& x);

      virtual 
      ~CircularArcIntersectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IntersectionFeature_sequence IntersectionFeature_;
    };

    class QIF30_SYMBOL_DECL CircularArcExtractType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // CurveFeature
      //
      typedef ::xsd::qif30::BaseFeatureType CurveFeature_type;
      typedef ::xsd::cxx::tree::traits< CurveFeature_type, wchar_t > CurveFeature_traits;

      const CurveFeature_type&
      CurveFeature () const;

      CurveFeature_type&
      CurveFeature ();

      void
      CurveFeature (const CurveFeature_type& x);

      void
      CurveFeature (::std::unique_ptr< CurveFeature_type > p);

      // Constructors.
      //
      CircularArcExtractType ();

      CircularArcExtractType (const CurveFeature_type&);

      CircularArcExtractType (::std::unique_ptr< CurveFeature_type >);

      CircularArcExtractType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CircularArcExtractType (const CircularArcExtractType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual CircularArcExtractType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcExtractType&
      operator= (const CircularArcExtractType& x);

      virtual 
      ~CircularArcExtractType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CurveFeature_type > CurveFeature_;
    };

    class QIF30_SYMBOL_DECL CircularArcCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::CircularArcConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      CircularArcCheckedType ();

      CircularArcCheckedType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CircularArcCheckedType (const CircularArcCheckedType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual CircularArcCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcCheckedType&
      operator= (const CircularArcCheckedType& x);

      virtual 
      ~CircularArcCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL CircularArcCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::CircularArcCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      CircularArcCheckedFeatureType ();

      CircularArcCheckedFeatureType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CircularArcCheckedFeatureType (const CircularArcCheckedFeatureType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CircularArcCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcCheckedFeatureType&
      operator= (const CircularArcCheckedFeatureType& x);

      virtual 
      ~CircularArcCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL CircularArcMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::CircularArcCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      CircularArcMeasurementDeterminationType ();

      CircularArcMeasurementDeterminationType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CircularArcMeasurementDeterminationType (const CircularArcMeasurementDeterminationType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CircularArcMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcMeasurementDeterminationType&
      operator= (const CircularArcMeasurementDeterminationType& x);

      virtual 
      ~CircularArcMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL CircularArcFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::CircularArcMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      CircularArcFeatureItemType ();

      CircularArcFeatureItemType (const id_type&,
                                  const FeatureNominalId_type&,
                                  const FeatureName_type&,
                                  const DeterminationMode_type&);

      CircularArcFeatureItemType (const id_type&,
                                  ::std::unique_ptr< FeatureNominalId_type >,
                                  const FeatureName_type&,
                                  ::std::unique_ptr< DeterminationMode_type >);

      CircularArcFeatureItemType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CircularArcFeatureItemType (const CircularArcFeatureItemType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CircularArcFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcFeatureItemType&
      operator= (const CircularArcFeatureItemType& x);

      virtual 
      ~CircularArcFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL CircularArcFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Radius
      //
      typedef ::xsd::qif30::LinearValueType Radius_type;
      typedef ::xsd::cxx::tree::traits< Radius_type, wchar_t > Radius_traits;

      const Radius_type&
      Radius () const;

      Radius_type&
      Radius ();

      void
      Radius (const Radius_type& x);

      void
      Radius (::std::unique_ptr< Radius_type > p);

      // Constructors.
      //
      CircularArcFeatureDefinitionType ();

      CircularArcFeatureDefinitionType (const id_type&,
                                        const InternalExternal_type&,
                                        const Radius_type&);

      CircularArcFeatureDefinitionType (const id_type&,
                                        const InternalExternal_type&,
                                        ::std::unique_ptr< Radius_type >);

      CircularArcFeatureDefinitionType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      CircularArcFeatureDefinitionType (const CircularArcFeatureDefinitionType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual CircularArcFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcFeatureDefinitionType&
      operator= (const CircularArcFeatureDefinitionType& x);

      virtual 
      ~CircularArcFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Radius_type > Radius_;
    };

    class QIF30_SYMBOL_DECL CircularArcFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_type&
      Sweep () const;

      Sweep_type&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::CircularArcConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      CircularArcFeatureNominalType ();

      CircularArcFeatureNominalType (const id_type&,
                                     const FeatureDefinitionId_type&,
                                     const Location_type&,
                                     const Sweep_type&,
                                     const Normal_type&);

      CircularArcFeatureNominalType (const id_type&,
                                     ::std::unique_ptr< FeatureDefinitionId_type >,
                                     ::std::unique_ptr< Location_type >,
                                     ::std::unique_ptr< Sweep_type >,
                                     ::std::unique_ptr< Normal_type >);

      CircularArcFeatureNominalType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CircularArcFeatureNominalType (const CircularArcFeatureNominalType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CircularArcFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcFeatureNominalType&
      operator= (const CircularArcFeatureNominalType& x);

      virtual 
      ~CircularArcFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< Sweep_type > Sweep_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL CircularArcFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Radius
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Radius_type;
      typedef ::xsd::cxx::tree::optional< Radius_type > Radius_optional;
      typedef ::xsd::cxx::tree::traits< Radius_type, wchar_t > Radius_traits;

      const Radius_optional&
      Radius () const;

      Radius_optional&
      Radius ();

      void
      Radius (const Radius_type& x);

      void
      Radius (const Radius_optional& x);

      void
      Radius (::std::unique_ptr< Radius_type > p);

      // RadiusMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType RadiusMin_type;
      typedef ::xsd::cxx::tree::optional< RadiusMin_type > RadiusMin_optional;
      typedef ::xsd::cxx::tree::traits< RadiusMin_type, wchar_t > RadiusMin_traits;

      const RadiusMin_optional&
      RadiusMin () const;

      RadiusMin_optional&
      RadiusMin ();

      void
      RadiusMin (const RadiusMin_type& x);

      void
      RadiusMin (const RadiusMin_optional& x);

      void
      RadiusMin (::std::unique_ptr< RadiusMin_type > p);

      // RadiusMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType RadiusMax_type;
      typedef ::xsd::cxx::tree::optional< RadiusMax_type > RadiusMax_optional;
      typedef ::xsd::cxx::tree::traits< RadiusMax_type, wchar_t > RadiusMax_traits;

      const RadiusMax_optional&
      RadiusMax () const;

      RadiusMax_optional&
      RadiusMax ();

      void
      RadiusMax (const RadiusMax_type& x);

      void
      RadiusMax (const RadiusMax_optional& x);

      void
      RadiusMax (::std::unique_ptr< RadiusMax_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      CircularArcFeatureMeasurementType ();

      CircularArcFeatureMeasurementType (const id_type&);

      CircularArcFeatureMeasurementType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CircularArcFeatureMeasurementType (const CircularArcFeatureMeasurementType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CircularArcFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularArcFeatureMeasurementType&
      operator= (const CircularArcFeatureMeasurementType& x);

      virtual 
      ~CircularArcFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      Normal_optional Normal_;
      Radius_optional Radius_;
      RadiusMin_optional RadiusMin_;
      RadiusMax_optional RadiusMax_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL ConeConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::ConeBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::ConeRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::ConeCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::ConeCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ConeTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::ConeFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      ConeConstructionMethodType ();

      ConeConstructionMethodType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ConeConstructionMethodType (const ConeConstructionMethodType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ConeConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeConstructionMethodType&
      operator= (const ConeConstructionMethodType& x);

      virtual 
      ~ConeConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL ConeBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ConeBestFitType ();

      ConeBestFitType (const n_type&);

      ConeBestFitType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ConeBestFitType (const ConeBestFitType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ConeBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeBestFitType&
      operator= (const ConeBestFitType& x);

      virtual 
      ~ConeBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ConeRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      ConeRecompType ();

      ConeRecompType (const BaseFeaturePointList_type&);

      ConeRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      ConeRecompType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ConeRecompType (const ConeRecompType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ConeRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeRecompType&
      operator= (const ConeRecompType& x);

      virtual 
      ~ConeRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL ConeCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCone
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCone_type;
      typedef ::xsd::cxx::tree::traits< BaseCone_type, wchar_t > BaseCone_traits;

      const BaseCone_type&
      BaseCone () const;

      BaseCone_type&
      BaseCone ();

      void
      BaseCone (const BaseCone_type& x);

      void
      BaseCone (::std::unique_ptr< BaseCone_type > p);

      // Constructors.
      //
      ConeCopyType ();

      ConeCopyType (const BaseCone_type&);

      ConeCopyType (::std::unique_ptr< BaseCone_type >);

      ConeCopyType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ConeCopyType (const ConeCopyType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ConeCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeCopyType&
      operator= (const ConeCopyType& x);

      virtual 
      ~ConeCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCone_type > BaseCone_;
    };

    class QIF30_SYMBOL_DECL ConeCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      ConeCastType ();

      ConeCastType (const BaseFeature_type&);

      ConeCastType (::std::unique_ptr< BaseFeature_type >);

      ConeCastType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ConeCastType (const ConeCastType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ConeCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeCastType&
      operator= (const ConeCastType& x);

      virtual 
      ~ConeCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL ConeTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCone
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCone_type;
      typedef ::xsd::cxx::tree::traits< BaseCone_type, wchar_t > BaseCone_traits;

      const BaseCone_type&
      BaseCone () const;

      BaseCone_type&
      BaseCone ();

      void
      BaseCone (const BaseCone_type& x);

      void
      BaseCone (::std::unique_ptr< BaseCone_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      ConeTransformType ();

      ConeTransformType (const BaseCone_type&,
                         const Transformation_type&);

      ConeTransformType (::std::unique_ptr< BaseCone_type >,
                         ::std::unique_ptr< Transformation_type >);

      ConeTransformType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ConeTransformType (const ConeTransformType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ConeTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeTransformType&
      operator= (const ConeTransformType& x);

      virtual 
      ~ConeTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCone_type > BaseCone_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL ConeFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Constructors.
      //
      ConeFromScanType ();

      ConeFromScanType (const SurfaceFeature_type&,
                        const SearchRadius_type&);

      ConeFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                        ::std::unique_ptr< SearchRadius_type >);

      ConeFromScanType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ConeFromScanType (const ConeFromScanType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ConeFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeFromScanType&
      operator= (const ConeFromScanType& x);

      virtual 
      ~ConeFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
    };

    class QIF30_SYMBOL_DECL ConeCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ConeConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ConeCheckedType ();

      ConeCheckedType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ConeCheckedType (const ConeCheckedType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ConeCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeCheckedType&
      operator= (const ConeCheckedType& x);

      virtual 
      ~ConeCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ConeCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::ConeCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      ConeCheckedFeatureType ();

      ConeCheckedFeatureType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ConeCheckedFeatureType (const ConeCheckedFeatureType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ConeCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeCheckedFeatureType&
      operator= (const ConeCheckedFeatureType& x);

      virtual 
      ~ConeCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL ConeMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::ConeCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      ConeMeasurementDeterminationType ();

      ConeMeasurementDeterminationType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ConeMeasurementDeterminationType (const ConeMeasurementDeterminationType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual ConeMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeMeasurementDeterminationType&
      operator= (const ConeMeasurementDeterminationType& x);

      virtual 
      ~ConeMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL ConeFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::ConeMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      ConeFeatureItemType ();

      ConeFeatureItemType (const id_type&,
                           const FeatureNominalId_type&,
                           const FeatureName_type&,
                           const DeterminationMode_type&);

      ConeFeatureItemType (const id_type&,
                           ::std::unique_ptr< FeatureNominalId_type >,
                           const FeatureName_type&,
                           ::std::unique_ptr< DeterminationMode_type >);

      ConeFeatureItemType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ConeFeatureItemType (const ConeFeatureItemType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ConeFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeFeatureItemType&
      operator= (const ConeFeatureItemType& x);

      virtual 
      ~ConeFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL ConeFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // HalfAngle
      //
      typedef ::xsd::qif30::AngularValueType HalfAngle_type;
      typedef ::xsd::cxx::tree::optional< HalfAngle_type > HalfAngle_optional;
      typedef ::xsd::cxx::tree::traits< HalfAngle_type, wchar_t > HalfAngle_traits;

      const HalfAngle_optional&
      HalfAngle () const;

      HalfAngle_optional&
      HalfAngle ();

      void
      HalfAngle (const HalfAngle_type& x);

      void
      HalfAngle (const HalfAngle_optional& x);

      void
      HalfAngle (::std::unique_ptr< HalfAngle_type > p);

      // FullAngle
      //
      typedef ::xsd::qif30::AngularValueType FullAngle_type;
      typedef ::xsd::cxx::tree::optional< FullAngle_type > FullAngle_optional;
      typedef ::xsd::cxx::tree::traits< FullAngle_type, wchar_t > FullAngle_traits;

      const FullAngle_optional&
      FullAngle () const;

      FullAngle_optional&
      FullAngle ();

      void
      FullAngle (const FullAngle_type& x);

      void
      FullAngle (const FullAngle_optional& x);

      void
      FullAngle (::std::unique_ptr< FullAngle_type > p);

      // LargeEndDistance
      //
      typedef ::xsd::qif30::LinearValueType LargeEndDistance_type;
      typedef ::xsd::cxx::tree::optional< LargeEndDistance_type > LargeEndDistance_optional;
      typedef ::xsd::cxx::tree::traits< LargeEndDistance_type, wchar_t > LargeEndDistance_traits;

      const LargeEndDistance_optional&
      LargeEndDistance () const;

      LargeEndDistance_optional&
      LargeEndDistance ();

      void
      LargeEndDistance (const LargeEndDistance_type& x);

      void
      LargeEndDistance (const LargeEndDistance_optional& x);

      void
      LargeEndDistance (::std::unique_ptr< LargeEndDistance_type > p);

      // SmallEndDistance
      //
      typedef ::xsd::qif30::LinearValueType SmallEndDistance_type;
      typedef ::xsd::cxx::tree::optional< SmallEndDistance_type > SmallEndDistance_optional;
      typedef ::xsd::cxx::tree::traits< SmallEndDistance_type, wchar_t > SmallEndDistance_traits;

      const SmallEndDistance_optional&
      SmallEndDistance () const;

      SmallEndDistance_optional&
      SmallEndDistance ();

      void
      SmallEndDistance (const SmallEndDistance_type& x);

      void
      SmallEndDistance (const SmallEndDistance_optional& x);

      void
      SmallEndDistance (::std::unique_ptr< SmallEndDistance_type > p);

      // Constructors.
      //
      ConeFeatureDefinitionType ();

      ConeFeatureDefinitionType (const id_type&,
                                 const InternalExternal_type&,
                                 const Diameter_type&);

      ConeFeatureDefinitionType (const id_type&,
                                 const InternalExternal_type&,
                                 ::std::unique_ptr< Diameter_type >);

      ConeFeatureDefinitionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ConeFeatureDefinitionType (const ConeFeatureDefinitionType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ConeFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeFeatureDefinitionType&
      operator= (const ConeFeatureDefinitionType& x);

      virtual 
      ~ConeFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      HalfAngle_optional HalfAngle_;
      FullAngle_optional FullAngle_;
      LargeEndDistance_optional LargeEndDistance_;
      SmallEndDistance_optional SmallEndDistance_;
    };

    class QIF30_SYMBOL_DECL ConeFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::optional< Sweep_type > Sweep_optional;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_optional&
      Sweep () const;

      Sweep_optional&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (const Sweep_optional& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ConeConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ConeFeatureNominalType ();

      ConeFeatureNominalType (const id_type&,
                              const FeatureDefinitionId_type&,
                              const Axis_type&);

      ConeFeatureNominalType (const id_type&,
                              ::std::unique_ptr< FeatureDefinitionId_type >,
                              ::std::unique_ptr< Axis_type >);

      ConeFeatureNominalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ConeFeatureNominalType (const ConeFeatureNominalType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ConeFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeFeatureNominalType&
      operator= (const ConeFeatureNominalType& x);

      virtual 
      ~ConeFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      Sweep_optional Sweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ConeFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::MeasuredAxisType Axis_type;
      typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_optional&
      Axis () const;

      Axis_optional&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (const Axis_optional& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // HalfAngle
      //
      typedef ::xsd::qif30::MeasuredAngularValueType HalfAngle_type;
      typedef ::xsd::cxx::tree::optional< HalfAngle_type > HalfAngle_optional;
      typedef ::xsd::cxx::tree::traits< HalfAngle_type, wchar_t > HalfAngle_traits;

      const HalfAngle_optional&
      HalfAngle () const;

      HalfAngle_optional&
      HalfAngle ();

      void
      HalfAngle (const HalfAngle_type& x);

      void
      HalfAngle (const HalfAngle_optional& x);

      void
      HalfAngle (::std::unique_ptr< HalfAngle_type > p);

      // FullAngle
      //
      typedef ::xsd::qif30::MeasuredAngularValueType FullAngle_type;
      typedef ::xsd::cxx::tree::optional< FullAngle_type > FullAngle_optional;
      typedef ::xsd::cxx::tree::traits< FullAngle_type, wchar_t > FullAngle_traits;

      const FullAngle_optional&
      FullAngle () const;

      FullAngle_optional&
      FullAngle ();

      void
      FullAngle (const FullAngle_type& x);

      void
      FullAngle (const FullAngle_optional& x);

      void
      FullAngle (::std::unique_ptr< FullAngle_type > p);

      // SmallEndDistance
      //
      typedef ::xsd::qif30::MeasuredLinearValueType SmallEndDistance_type;
      typedef ::xsd::cxx::tree::optional< SmallEndDistance_type > SmallEndDistance_optional;
      typedef ::xsd::cxx::tree::traits< SmallEndDistance_type, wchar_t > SmallEndDistance_traits;

      const SmallEndDistance_optional&
      SmallEndDistance () const;

      SmallEndDistance_optional&
      SmallEndDistance ();

      void
      SmallEndDistance (const SmallEndDistance_type& x);

      void
      SmallEndDistance (const SmallEndDistance_optional& x);

      void
      SmallEndDistance (::std::unique_ptr< SmallEndDistance_type > p);

      // LargeEndDistance
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LargeEndDistance_type;
      typedef ::xsd::cxx::tree::optional< LargeEndDistance_type > LargeEndDistance_optional;
      typedef ::xsd::cxx::tree::traits< LargeEndDistance_type, wchar_t > LargeEndDistance_traits;

      const LargeEndDistance_optional&
      LargeEndDistance () const;

      LargeEndDistance_optional&
      LargeEndDistance ();

      void
      LargeEndDistance (const LargeEndDistance_type& x);

      void
      LargeEndDistance (const LargeEndDistance_optional& x);

      void
      LargeEndDistance (::std::unique_ptr< LargeEndDistance_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      ConeFeatureMeasurementType ();

      ConeFeatureMeasurementType (const id_type&);

      ConeFeatureMeasurementType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ConeFeatureMeasurementType (const ConeFeatureMeasurementType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ConeFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConeFeatureMeasurementType&
      operator= (const ConeFeatureMeasurementType& x);

      virtual 
      ~ConeFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Axis_optional Axis_;
      Diameter_optional Diameter_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      HalfAngle_optional HalfAngle_;
      FullAngle_optional FullAngle_;
      SmallEndDistance_optional SmallEndDistance_;
      LargeEndDistance_optional LargeEndDistance_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::ConicalSegmentBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::ConicalSegmentRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::ConicalSegmentCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::ConicalSegmentCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ConicalSegmentTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      ConicalSegmentConstructionMethodType ();

      ConicalSegmentConstructionMethodType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ConicalSegmentConstructionMethodType (const ConicalSegmentConstructionMethodType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ConicalSegmentConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentConstructionMethodType&
      operator= (const ConicalSegmentConstructionMethodType& x);

      virtual 
      ~ConicalSegmentConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ConicalSegmentBestFitType ();

      ConicalSegmentBestFitType (const n_type&);

      ConicalSegmentBestFitType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ConicalSegmentBestFitType (const ConicalSegmentBestFitType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ConicalSegmentBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentBestFitType&
      operator= (const ConicalSegmentBestFitType& x);

      virtual 
      ~ConicalSegmentBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      ConicalSegmentRecompType ();

      ConicalSegmentRecompType (const BaseFeaturePointList_type&);

      ConicalSegmentRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      ConicalSegmentRecompType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ConicalSegmentRecompType (const ConicalSegmentRecompType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ConicalSegmentRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentRecompType&
      operator= (const ConicalSegmentRecompType& x);

      virtual 
      ~ConicalSegmentRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseConicalSegment
      //
      typedef ::xsd::qif30::BaseFeatureType BaseConicalSegment_type;
      typedef ::xsd::cxx::tree::traits< BaseConicalSegment_type, wchar_t > BaseConicalSegment_traits;

      const BaseConicalSegment_type&
      BaseConicalSegment () const;

      BaseConicalSegment_type&
      BaseConicalSegment ();

      void
      BaseConicalSegment (const BaseConicalSegment_type& x);

      void
      BaseConicalSegment (::std::unique_ptr< BaseConicalSegment_type > p);

      // Constructors.
      //
      ConicalSegmentCopyType ();

      ConicalSegmentCopyType (const BaseConicalSegment_type&);

      ConicalSegmentCopyType (::std::unique_ptr< BaseConicalSegment_type >);

      ConicalSegmentCopyType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ConicalSegmentCopyType (const ConicalSegmentCopyType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ConicalSegmentCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentCopyType&
      operator= (const ConicalSegmentCopyType& x);

      virtual 
      ~ConicalSegmentCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseConicalSegment_type > BaseConicalSegment_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      ConicalSegmentCastType ();

      ConicalSegmentCastType (const BaseFeature_type&);

      ConicalSegmentCastType (::std::unique_ptr< BaseFeature_type >);

      ConicalSegmentCastType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ConicalSegmentCastType (const ConicalSegmentCastType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ConicalSegmentCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentCastType&
      operator= (const ConicalSegmentCastType& x);

      virtual 
      ~ConicalSegmentCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseConicalSegment
      //
      typedef ::xsd::qif30::BaseFeatureType BaseConicalSegment_type;
      typedef ::xsd::cxx::tree::traits< BaseConicalSegment_type, wchar_t > BaseConicalSegment_traits;

      const BaseConicalSegment_type&
      BaseConicalSegment () const;

      BaseConicalSegment_type&
      BaseConicalSegment ();

      void
      BaseConicalSegment (const BaseConicalSegment_type& x);

      void
      BaseConicalSegment (::std::unique_ptr< BaseConicalSegment_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      ConicalSegmentTransformType ();

      ConicalSegmentTransformType (const BaseConicalSegment_type&,
                                   const Transformation_type&);

      ConicalSegmentTransformType (::std::unique_ptr< BaseConicalSegment_type >,
                                   ::std::unique_ptr< Transformation_type >);

      ConicalSegmentTransformType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ConicalSegmentTransformType (const ConicalSegmentTransformType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ConicalSegmentTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentTransformType&
      operator= (const ConicalSegmentTransformType& x);

      virtual 
      ~ConicalSegmentTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseConicalSegment_type > BaseConicalSegment_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ConicalSegmentConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ConicalSegmentCheckedType ();

      ConicalSegmentCheckedType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ConicalSegmentCheckedType (const ConicalSegmentCheckedType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ConicalSegmentCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentCheckedType&
      operator= (const ConicalSegmentCheckedType& x);

      virtual 
      ~ConicalSegmentCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::ConicalSegmentCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      ConicalSegmentCheckedFeatureType ();

      ConicalSegmentCheckedFeatureType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ConicalSegmentCheckedFeatureType (const ConicalSegmentCheckedFeatureType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual ConicalSegmentCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentCheckedFeatureType&
      operator= (const ConicalSegmentCheckedFeatureType& x);

      virtual 
      ~ConicalSegmentCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::ConicalSegmentCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      ConicalSegmentMeasurementDeterminationType ();

      ConicalSegmentMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      ConicalSegmentMeasurementDeterminationType (const ConicalSegmentMeasurementDeterminationType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual ConicalSegmentMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentMeasurementDeterminationType&
      operator= (const ConicalSegmentMeasurementDeterminationType& x);

      virtual 
      ~ConicalSegmentMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::ConicalSegmentMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      ConicalSegmentFeatureItemType ();

      ConicalSegmentFeatureItemType (const id_type&,
                                     const FeatureNominalId_type&,
                                     const FeatureName_type&,
                                     const DeterminationMode_type&);

      ConicalSegmentFeatureItemType (const id_type&,
                                     ::std::unique_ptr< FeatureNominalId_type >,
                                     const FeatureName_type&,
                                     ::std::unique_ptr< DeterminationMode_type >);

      ConicalSegmentFeatureItemType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ConicalSegmentFeatureItemType (const ConicalSegmentFeatureItemType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ConicalSegmentFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentFeatureItemType&
      operator= (const ConicalSegmentFeatureItemType& x);

      virtual 
      ~ConicalSegmentFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // HalfAngle
      //
      typedef ::xsd::qif30::AngularValueType HalfAngle_type;
      typedef ::xsd::cxx::tree::optional< HalfAngle_type > HalfAngle_optional;
      typedef ::xsd::cxx::tree::traits< HalfAngle_type, wchar_t > HalfAngle_traits;

      const HalfAngle_optional&
      HalfAngle () const;

      HalfAngle_optional&
      HalfAngle ();

      void
      HalfAngle (const HalfAngle_type& x);

      void
      HalfAngle (const HalfAngle_optional& x);

      void
      HalfAngle (::std::unique_ptr< HalfAngle_type > p);

      // FullAngle
      //
      typedef ::xsd::qif30::AngularValueType FullAngle_type;
      typedef ::xsd::cxx::tree::optional< FullAngle_type > FullAngle_optional;
      typedef ::xsd::cxx::tree::traits< FullAngle_type, wchar_t > FullAngle_traits;

      const FullAngle_optional&
      FullAngle () const;

      FullAngle_optional&
      FullAngle ();

      void
      FullAngle (const FullAngle_type& x);

      void
      FullAngle (const FullAngle_optional& x);

      void
      FullAngle (::std::unique_ptr< FullAngle_type > p);

      // LargeEndDistance
      //
      typedef ::xsd::qif30::LinearValueType LargeEndDistance_type;
      typedef ::xsd::cxx::tree::optional< LargeEndDistance_type > LargeEndDistance_optional;
      typedef ::xsd::cxx::tree::traits< LargeEndDistance_type, wchar_t > LargeEndDistance_traits;

      const LargeEndDistance_optional&
      LargeEndDistance () const;

      LargeEndDistance_optional&
      LargeEndDistance ();

      void
      LargeEndDistance (const LargeEndDistance_type& x);

      void
      LargeEndDistance (const LargeEndDistance_optional& x);

      void
      LargeEndDistance (::std::unique_ptr< LargeEndDistance_type > p);

      // SmallEndDistance
      //
      typedef ::xsd::qif30::LinearValueType SmallEndDistance_type;
      typedef ::xsd::cxx::tree::optional< SmallEndDistance_type > SmallEndDistance_optional;
      typedef ::xsd::cxx::tree::traits< SmallEndDistance_type, wchar_t > SmallEndDistance_traits;

      const SmallEndDistance_optional&
      SmallEndDistance () const;

      SmallEndDistance_optional&
      SmallEndDistance ();

      void
      SmallEndDistance (const SmallEndDistance_type& x);

      void
      SmallEndDistance (const SmallEndDistance_optional& x);

      void
      SmallEndDistance (::std::unique_ptr< SmallEndDistance_type > p);

      // Constructors.
      //
      ConicalSegmentFeatureDefinitionType ();

      ConicalSegmentFeatureDefinitionType (const id_type&,
                                           const InternalExternal_type&,
                                           const Diameter_type&);

      ConicalSegmentFeatureDefinitionType (const id_type&,
                                           const InternalExternal_type&,
                                           ::std::unique_ptr< Diameter_type >);

      ConicalSegmentFeatureDefinitionType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ConicalSegmentFeatureDefinitionType (const ConicalSegmentFeatureDefinitionType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ConicalSegmentFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentFeatureDefinitionType&
      operator= (const ConicalSegmentFeatureDefinitionType& x);

      virtual 
      ~ConicalSegmentFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      HalfAngle_optional HalfAngle_;
      FullAngle_optional FullAngle_;
      LargeEndDistance_optional LargeEndDistance_;
      SmallEndDistance_optional SmallEndDistance_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_type&
      Sweep () const;

      Sweep_type&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ConicalSegmentConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ConicalSegmentFeatureNominalType ();

      ConicalSegmentFeatureNominalType (const id_type&,
                                        const FeatureDefinitionId_type&,
                                        const Axis_type&,
                                        const Sweep_type&);

      ConicalSegmentFeatureNominalType (const id_type&,
                                        ::std::unique_ptr< FeatureDefinitionId_type >,
                                        ::std::unique_ptr< Axis_type >,
                                        ::std::unique_ptr< Sweep_type >);

      ConicalSegmentFeatureNominalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ConicalSegmentFeatureNominalType (const ConicalSegmentFeatureNominalType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual ConicalSegmentFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentFeatureNominalType&
      operator= (const ConicalSegmentFeatureNominalType& x);

      virtual 
      ~ConicalSegmentFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< Sweep_type > Sweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ConicalSegmentFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::MeasuredAxisType Axis_type;
      typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_optional&
      Axis () const;

      Axis_optional&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (const Axis_optional& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // HalfAngle
      //
      typedef ::xsd::qif30::MeasuredAngularValueType HalfAngle_type;
      typedef ::xsd::cxx::tree::optional< HalfAngle_type > HalfAngle_optional;
      typedef ::xsd::cxx::tree::traits< HalfAngle_type, wchar_t > HalfAngle_traits;

      const HalfAngle_optional&
      HalfAngle () const;

      HalfAngle_optional&
      HalfAngle ();

      void
      HalfAngle (const HalfAngle_type& x);

      void
      HalfAngle (const HalfAngle_optional& x);

      void
      HalfAngle (::std::unique_ptr< HalfAngle_type > p);

      // FullAngle
      //
      typedef ::xsd::qif30::MeasuredAngularValueType FullAngle_type;
      typedef ::xsd::cxx::tree::optional< FullAngle_type > FullAngle_optional;
      typedef ::xsd::cxx::tree::traits< FullAngle_type, wchar_t > FullAngle_traits;

      const FullAngle_optional&
      FullAngle () const;

      FullAngle_optional&
      FullAngle ();

      void
      FullAngle (const FullAngle_type& x);

      void
      FullAngle (const FullAngle_optional& x);

      void
      FullAngle (::std::unique_ptr< FullAngle_type > p);

      // SmallEndDistance
      //
      typedef ::xsd::qif30::MeasuredLinearValueType SmallEndDistance_type;
      typedef ::xsd::cxx::tree::optional< SmallEndDistance_type > SmallEndDistance_optional;
      typedef ::xsd::cxx::tree::traits< SmallEndDistance_type, wchar_t > SmallEndDistance_traits;

      const SmallEndDistance_optional&
      SmallEndDistance () const;

      SmallEndDistance_optional&
      SmallEndDistance ();

      void
      SmallEndDistance (const SmallEndDistance_type& x);

      void
      SmallEndDistance (const SmallEndDistance_optional& x);

      void
      SmallEndDistance (::std::unique_ptr< SmallEndDistance_type > p);

      // LargeEndDistance
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LargeEndDistance_type;
      typedef ::xsd::cxx::tree::optional< LargeEndDistance_type > LargeEndDistance_optional;
      typedef ::xsd::cxx::tree::traits< LargeEndDistance_type, wchar_t > LargeEndDistance_traits;

      const LargeEndDistance_optional&
      LargeEndDistance () const;

      LargeEndDistance_optional&
      LargeEndDistance ();

      void
      LargeEndDistance (const LargeEndDistance_type& x);

      void
      LargeEndDistance (const LargeEndDistance_optional& x);

      void
      LargeEndDistance (::std::unique_ptr< LargeEndDistance_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      ConicalSegmentFeatureMeasurementType ();

      ConicalSegmentFeatureMeasurementType (const id_type&);

      ConicalSegmentFeatureMeasurementType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ConicalSegmentFeatureMeasurementType (const ConicalSegmentFeatureMeasurementType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ConicalSegmentFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentFeatureMeasurementType&
      operator= (const ConicalSegmentFeatureMeasurementType& x);

      virtual 
      ~ConicalSegmentFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Axis_optional Axis_;
      Diameter_optional Diameter_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      HalfAngle_optional HalfAngle_;
      FullAngle_optional FullAngle_;
      SmallEndDistance_optional SmallEndDistance_;
      LargeEndDistance_optional LargeEndDistance_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL CylinderConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::CylinderBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::CylinderRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::CylinderCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::CylinderCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::CylinderTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::CylinderFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      CylinderConstructionMethodType ();

      CylinderConstructionMethodType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      CylinderConstructionMethodType (const CylinderConstructionMethodType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual CylinderConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderConstructionMethodType&
      operator= (const CylinderConstructionMethodType& x);

      virtual 
      ~CylinderConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL CylinderBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CylinderBestFitType ();

      CylinderBestFitType (const n_type&);

      CylinderBestFitType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CylinderBestFitType (const CylinderBestFitType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CylinderBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderBestFitType&
      operator= (const CylinderBestFitType& x);

      virtual 
      ~CylinderBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CylinderRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      CylinderRecompType ();

      CylinderRecompType (const BaseFeaturePointList_type&);

      CylinderRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      CylinderRecompType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CylinderRecompType (const CylinderRecompType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual CylinderRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderRecompType&
      operator= (const CylinderRecompType& x);

      virtual 
      ~CylinderRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL CylinderCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCylinder
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCylinder_type;
      typedef ::xsd::cxx::tree::traits< BaseCylinder_type, wchar_t > BaseCylinder_traits;

      const BaseCylinder_type&
      BaseCylinder () const;

      BaseCylinder_type&
      BaseCylinder ();

      void
      BaseCylinder (const BaseCylinder_type& x);

      void
      BaseCylinder (::std::unique_ptr< BaseCylinder_type > p);

      // Constructors.
      //
      CylinderCopyType ();

      CylinderCopyType (const BaseCylinder_type&);

      CylinderCopyType (::std::unique_ptr< BaseCylinder_type >);

      CylinderCopyType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      CylinderCopyType (const CylinderCopyType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual CylinderCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderCopyType&
      operator= (const CylinderCopyType& x);

      virtual 
      ~CylinderCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCylinder_type > BaseCylinder_;
    };

    class QIF30_SYMBOL_DECL CylinderCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      CylinderCastType ();

      CylinderCastType (const BaseFeature_type&);

      CylinderCastType (::std::unique_ptr< BaseFeature_type >);

      CylinderCastType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      CylinderCastType (const CylinderCastType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual CylinderCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderCastType&
      operator= (const CylinderCastType& x);

      virtual 
      ~CylinderCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL CylinderTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCylinder
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCylinder_type;
      typedef ::xsd::cxx::tree::traits< BaseCylinder_type, wchar_t > BaseCylinder_traits;

      const BaseCylinder_type&
      BaseCylinder () const;

      BaseCylinder_type&
      BaseCylinder ();

      void
      BaseCylinder (const BaseCylinder_type& x);

      void
      BaseCylinder (::std::unique_ptr< BaseCylinder_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      CylinderTransformType ();

      CylinderTransformType (const BaseCylinder_type&,
                             const Transformation_type&);

      CylinderTransformType (::std::unique_ptr< BaseCylinder_type >,
                             ::std::unique_ptr< Transformation_type >);

      CylinderTransformType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CylinderTransformType (const CylinderTransformType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CylinderTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderTransformType&
      operator= (const CylinderTransformType& x);

      virtual 
      ~CylinderTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCylinder_type > BaseCylinder_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL CylinderFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Constructors.
      //
      CylinderFromScanType ();

      CylinderFromScanType (const SurfaceFeature_type&,
                            const SearchRadius_type&);

      CylinderFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                            ::std::unique_ptr< SearchRadius_type >);

      CylinderFromScanType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CylinderFromScanType (const CylinderFromScanType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CylinderFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderFromScanType&
      operator= (const CylinderFromScanType& x);

      virtual 
      ~CylinderFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
    };

    class QIF30_SYMBOL_DECL CylinderCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::CylinderConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      CylinderCheckedType ();

      CylinderCheckedType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CylinderCheckedType (const CylinderCheckedType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CylinderCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderCheckedType&
      operator= (const CylinderCheckedType& x);

      virtual 
      ~CylinderCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL CylinderCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::CylinderCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      CylinderCheckedFeatureType ();

      CylinderCheckedFeatureType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CylinderCheckedFeatureType (const CylinderCheckedFeatureType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CylinderCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderCheckedFeatureType&
      operator= (const CylinderCheckedFeatureType& x);

      virtual 
      ~CylinderCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL CylinderMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::CylinderCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      CylinderMeasurementDeterminationType ();

      CylinderMeasurementDeterminationType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CylinderMeasurementDeterminationType (const CylinderMeasurementDeterminationType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CylinderMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderMeasurementDeterminationType&
      operator= (const CylinderMeasurementDeterminationType& x);

      virtual 
      ~CylinderMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL CylinderFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::CylinderMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      CylinderFeatureItemType ();

      CylinderFeatureItemType (const id_type&,
                               const FeatureNominalId_type&,
                               const FeatureName_type&,
                               const DeterminationMode_type&);

      CylinderFeatureItemType (const id_type&,
                               ::std::unique_ptr< FeatureNominalId_type >,
                               const FeatureName_type&,
                               ::std::unique_ptr< DeterminationMode_type >);

      CylinderFeatureItemType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CylinderFeatureItemType (const CylinderFeatureItemType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CylinderFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderFeatureItemType&
      operator= (const CylinderFeatureItemType& x);

      virtual 
      ~CylinderFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL CylinderFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Bottom
      //
      typedef ::xsd::qif30::BottomType Bottom_type;
      typedef ::xsd::cxx::tree::optional< Bottom_type > Bottom_optional;
      typedef ::xsd::cxx::tree::traits< Bottom_type, wchar_t > Bottom_traits;

      const Bottom_optional&
      Bottom () const;

      Bottom_optional&
      Bottom ();

      void
      Bottom (const Bottom_type& x);

      void
      Bottom (const Bottom_optional& x);

      void
      Bottom (::std::unique_ptr< Bottom_type > p);

      // Constructors.
      //
      CylinderFeatureDefinitionType ();

      CylinderFeatureDefinitionType (const id_type&,
                                     const InternalExternal_type&,
                                     const Diameter_type&);

      CylinderFeatureDefinitionType (const id_type&,
                                     const InternalExternal_type&,
                                     ::std::unique_ptr< Diameter_type >);

      CylinderFeatureDefinitionType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CylinderFeatureDefinitionType (const CylinderFeatureDefinitionType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CylinderFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderFeatureDefinitionType&
      operator= (const CylinderFeatureDefinitionType& x);

      virtual 
      ~CylinderFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      Length_optional Length_;
      Bottom_optional Bottom_;
    };

    class QIF30_SYMBOL_DECL CylinderFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::optional< Sweep_type > Sweep_optional;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_optional&
      Sweep () const;

      Sweep_optional&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (const Sweep_optional& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::CylinderConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      CylinderFeatureNominalType ();

      CylinderFeatureNominalType (const id_type&,
                                  const FeatureDefinitionId_type&,
                                  const Axis_type&);

      CylinderFeatureNominalType (const id_type&,
                                  ::std::unique_ptr< FeatureDefinitionId_type >,
                                  ::std::unique_ptr< Axis_type >);

      CylinderFeatureNominalType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CylinderFeatureNominalType (const CylinderFeatureNominalType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CylinderFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderFeatureNominalType&
      operator= (const CylinderFeatureNominalType& x);

      virtual 
      ~CylinderFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      Sweep_optional Sweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL CylinderFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::MeasuredAxisType Axis_type;
      typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_optional&
      Axis () const;

      Axis_optional&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (const Axis_optional& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      CylinderFeatureMeasurementType ();

      CylinderFeatureMeasurementType (const id_type&);

      CylinderFeatureMeasurementType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      CylinderFeatureMeasurementType (const CylinderFeatureMeasurementType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual CylinderFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderFeatureMeasurementType&
      operator= (const CylinderFeatureMeasurementType& x);

      virtual 
      ~CylinderFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Axis_optional Axis_;
      Diameter_optional Diameter_;
      Length_optional Length_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::CylindricalSegmentBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::CylindricalSegmentRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::CylindricalSegmentCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::CylindricalSegmentCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::CylindricalSegmentTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      CylindricalSegmentConstructionMethodType ();

      CylindricalSegmentConstructionMethodType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      CylindricalSegmentConstructionMethodType (const CylindricalSegmentConstructionMethodType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual CylindricalSegmentConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentConstructionMethodType&
      operator= (const CylindricalSegmentConstructionMethodType& x);

      virtual 
      ~CylindricalSegmentConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CylindricalSegmentBestFitType ();

      CylindricalSegmentBestFitType (const n_type&);

      CylindricalSegmentBestFitType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CylindricalSegmentBestFitType (const CylindricalSegmentBestFitType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CylindricalSegmentBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentBestFitType&
      operator= (const CylindricalSegmentBestFitType& x);

      virtual 
      ~CylindricalSegmentBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      CylindricalSegmentRecompType ();

      CylindricalSegmentRecompType (const BaseFeaturePointList_type&);

      CylindricalSegmentRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      CylindricalSegmentRecompType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CylindricalSegmentRecompType (const CylindricalSegmentRecompType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual CylindricalSegmentRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentRecompType&
      operator= (const CylindricalSegmentRecompType& x);

      virtual 
      ~CylindricalSegmentRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCylindricalSegment
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCylindricalSegment_type;
      typedef ::xsd::cxx::tree::traits< BaseCylindricalSegment_type, wchar_t > BaseCylindricalSegment_traits;

      const BaseCylindricalSegment_type&
      BaseCylindricalSegment () const;

      BaseCylindricalSegment_type&
      BaseCylindricalSegment ();

      void
      BaseCylindricalSegment (const BaseCylindricalSegment_type& x);

      void
      BaseCylindricalSegment (::std::unique_ptr< BaseCylindricalSegment_type > p);

      // Constructors.
      //
      CylindricalSegmentCopyType ();

      CylindricalSegmentCopyType (const BaseCylindricalSegment_type&);

      CylindricalSegmentCopyType (::std::unique_ptr< BaseCylindricalSegment_type >);

      CylindricalSegmentCopyType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CylindricalSegmentCopyType (const CylindricalSegmentCopyType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CylindricalSegmentCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentCopyType&
      operator= (const CylindricalSegmentCopyType& x);

      virtual 
      ~CylindricalSegmentCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCylindricalSegment_type > BaseCylindricalSegment_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      CylindricalSegmentCastType ();

      CylindricalSegmentCastType (const BaseFeature_type&);

      CylindricalSegmentCastType (::std::unique_ptr< BaseFeature_type >);

      CylindricalSegmentCastType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CylindricalSegmentCastType (const CylindricalSegmentCastType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CylindricalSegmentCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentCastType&
      operator= (const CylindricalSegmentCastType& x);

      virtual 
      ~CylindricalSegmentCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCylindricalSegment
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCylindricalSegment_type;
      typedef ::xsd::cxx::tree::traits< BaseCylindricalSegment_type, wchar_t > BaseCylindricalSegment_traits;

      const BaseCylindricalSegment_type&
      BaseCylindricalSegment () const;

      BaseCylindricalSegment_type&
      BaseCylindricalSegment ();

      void
      BaseCylindricalSegment (const BaseCylindricalSegment_type& x);

      void
      BaseCylindricalSegment (::std::unique_ptr< BaseCylindricalSegment_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      CylindricalSegmentTransformType ();

      CylindricalSegmentTransformType (const BaseCylindricalSegment_type&,
                                       const Transformation_type&);

      CylindricalSegmentTransformType (::std::unique_ptr< BaseCylindricalSegment_type >,
                                       ::std::unique_ptr< Transformation_type >);

      CylindricalSegmentTransformType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CylindricalSegmentTransformType (const CylindricalSegmentTransformType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CylindricalSegmentTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentTransformType&
      operator= (const CylindricalSegmentTransformType& x);

      virtual 
      ~CylindricalSegmentTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCylindricalSegment_type > BaseCylindricalSegment_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::CylindricalSegmentConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      CylindricalSegmentCheckedType ();

      CylindricalSegmentCheckedType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      CylindricalSegmentCheckedType (const CylindricalSegmentCheckedType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual CylindricalSegmentCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentCheckedType&
      operator= (const CylindricalSegmentCheckedType& x);

      virtual 
      ~CylindricalSegmentCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::CylindricalSegmentCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      CylindricalSegmentCheckedFeatureType ();

      CylindricalSegmentCheckedFeatureType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CylindricalSegmentCheckedFeatureType (const CylindricalSegmentCheckedFeatureType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CylindricalSegmentCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentCheckedFeatureType&
      operator= (const CylindricalSegmentCheckedFeatureType& x);

      virtual 
      ~CylindricalSegmentCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::CylindricalSegmentCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      CylindricalSegmentMeasurementDeterminationType ();

      CylindricalSegmentMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      CylindricalSegmentMeasurementDeterminationType (const CylindricalSegmentMeasurementDeterminationType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual CylindricalSegmentMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentMeasurementDeterminationType&
      operator= (const CylindricalSegmentMeasurementDeterminationType& x);

      virtual 
      ~CylindricalSegmentMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::CylindricalSegmentMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      CylindricalSegmentFeatureItemType ();

      CylindricalSegmentFeatureItemType (const id_type&,
                                         const FeatureNominalId_type&,
                                         const FeatureName_type&,
                                         const DeterminationMode_type&);

      CylindricalSegmentFeatureItemType (const id_type&,
                                         ::std::unique_ptr< FeatureNominalId_type >,
                                         const FeatureName_type&,
                                         ::std::unique_ptr< DeterminationMode_type >);

      CylindricalSegmentFeatureItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CylindricalSegmentFeatureItemType (const CylindricalSegmentFeatureItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CylindricalSegmentFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentFeatureItemType&
      operator= (const CylindricalSegmentFeatureItemType& x);

      virtual 
      ~CylindricalSegmentFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Bottom
      //
      typedef ::xsd::qif30::BottomType Bottom_type;
      typedef ::xsd::cxx::tree::optional< Bottom_type > Bottom_optional;
      typedef ::xsd::cxx::tree::traits< Bottom_type, wchar_t > Bottom_traits;

      const Bottom_optional&
      Bottom () const;

      Bottom_optional&
      Bottom ();

      void
      Bottom (const Bottom_type& x);

      void
      Bottom (const Bottom_optional& x);

      void
      Bottom (::std::unique_ptr< Bottom_type > p);

      // Constructors.
      //
      CylindricalSegmentFeatureDefinitionType ();

      CylindricalSegmentFeatureDefinitionType (const id_type&,
                                               const InternalExternal_type&,
                                               const Diameter_type&);

      CylindricalSegmentFeatureDefinitionType (const id_type&,
                                               const InternalExternal_type&,
                                               ::std::unique_ptr< Diameter_type >);

      CylindricalSegmentFeatureDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CylindricalSegmentFeatureDefinitionType (const CylindricalSegmentFeatureDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CylindricalSegmentFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentFeatureDefinitionType&
      operator= (const CylindricalSegmentFeatureDefinitionType& x);

      virtual 
      ~CylindricalSegmentFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      Length_optional Length_;
      Bottom_optional Bottom_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_type&
      Sweep () const;

      Sweep_type&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::CylindricalSegmentConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      CylindricalSegmentFeatureNominalType ();

      CylindricalSegmentFeatureNominalType (const id_type&,
                                            const FeatureDefinitionId_type&,
                                            const Axis_type&,
                                            const Sweep_type&);

      CylindricalSegmentFeatureNominalType (const id_type&,
                                            ::std::unique_ptr< FeatureDefinitionId_type >,
                                            ::std::unique_ptr< Axis_type >,
                                            ::std::unique_ptr< Sweep_type >);

      CylindricalSegmentFeatureNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CylindricalSegmentFeatureNominalType (const CylindricalSegmentFeatureNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CylindricalSegmentFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentFeatureNominalType&
      operator= (const CylindricalSegmentFeatureNominalType& x);

      virtual 
      ~CylindricalSegmentFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< Sweep_type > Sweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL CylindricalSegmentFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::MeasuredAxisType Axis_type;
      typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_optional&
      Axis () const;

      Axis_optional&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (const Axis_optional& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      CylindricalSegmentFeatureMeasurementType ();

      CylindricalSegmentFeatureMeasurementType (const id_type&);

      CylindricalSegmentFeatureMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      CylindricalSegmentFeatureMeasurementType (const CylindricalSegmentFeatureMeasurementType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual CylindricalSegmentFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentFeatureMeasurementType&
      operator= (const CylindricalSegmentFeatureMeasurementType& x);

      virtual 
      ~CylindricalSegmentFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Axis_optional Axis_;
      Diameter_optional Diameter_;
      Length_optional Length_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL EdgePointConstructionMethodType: public ::xml_schema::type
    {
      public:
      // Copy
      //
      typedef ::xsd::qif30::EdgePointCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::EdgePointCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::EdgePointTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::EdgePointFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      EdgePointConstructionMethodType ();

      EdgePointConstructionMethodType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      EdgePointConstructionMethodType (const EdgePointConstructionMethodType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual EdgePointConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointConstructionMethodType&
      operator= (const EdgePointConstructionMethodType& x);

      virtual 
      ~EdgePointConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL EdgePointCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseEdgePoint
      //
      typedef ::xsd::qif30::BaseFeatureType BaseEdgePoint_type;
      typedef ::xsd::cxx::tree::traits< BaseEdgePoint_type, wchar_t > BaseEdgePoint_traits;

      const BaseEdgePoint_type&
      BaseEdgePoint () const;

      BaseEdgePoint_type&
      BaseEdgePoint ();

      void
      BaseEdgePoint (const BaseEdgePoint_type& x);

      void
      BaseEdgePoint (::std::unique_ptr< BaseEdgePoint_type > p);

      // Constructors.
      //
      EdgePointCopyType ();

      EdgePointCopyType (const BaseEdgePoint_type&);

      EdgePointCopyType (::std::unique_ptr< BaseEdgePoint_type >);

      EdgePointCopyType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      EdgePointCopyType (const EdgePointCopyType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual EdgePointCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointCopyType&
      operator= (const EdgePointCopyType& x);

      virtual 
      ~EdgePointCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseEdgePoint_type > BaseEdgePoint_;
    };

    class QIF30_SYMBOL_DECL EdgePointCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      EdgePointCastType ();

      EdgePointCastType (const BaseFeature_type&);

      EdgePointCastType (::std::unique_ptr< BaseFeature_type >);

      EdgePointCastType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      EdgePointCastType (const EdgePointCastType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual EdgePointCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointCastType&
      operator= (const EdgePointCastType& x);

      virtual 
      ~EdgePointCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL EdgePointTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseEdgePoint
      //
      typedef ::xsd::qif30::BaseFeatureType BaseEdgePoint_type;
      typedef ::xsd::cxx::tree::traits< BaseEdgePoint_type, wchar_t > BaseEdgePoint_traits;

      const BaseEdgePoint_type&
      BaseEdgePoint () const;

      BaseEdgePoint_type&
      BaseEdgePoint ();

      void
      BaseEdgePoint (const BaseEdgePoint_type& x);

      void
      BaseEdgePoint (::std::unique_ptr< BaseEdgePoint_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      EdgePointTransformType ();

      EdgePointTransformType (const BaseEdgePoint_type&,
                              const Transformation_type&);

      EdgePointTransformType (::std::unique_ptr< BaseEdgePoint_type >,
                              ::std::unique_ptr< Transformation_type >);

      EdgePointTransformType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      EdgePointTransformType (const EdgePointTransformType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual EdgePointTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointTransformType&
      operator= (const EdgePointTransformType& x);

      virtual 
      ~EdgePointTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseEdgePoint_type > BaseEdgePoint_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL EdgePointFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // PatchRadius
      //
      typedef ::xsd::qif30::LinearValueType PatchRadius_type;
      typedef ::xsd::cxx::tree::traits< PatchRadius_type, wchar_t > PatchRadius_traits;

      const PatchRadius_type&
      PatchRadius () const;

      PatchRadius_type&
      PatchRadius ();

      void
      PatchRadius (const PatchRadius_type& x);

      void
      PatchRadius (::std::unique_ptr< PatchRadius_type > p);

      // Distance
      //
      typedef ::xsd::qif30::LinearValueType Distance_type;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t > Distance_traits;

      const Distance_type&
      Distance () const;

      Distance_type&
      Distance ();

      void
      Distance (const Distance_type& x);

      void
      Distance (::std::unique_ptr< Distance_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_type&
      Depth () const;

      Depth_type&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // RetrievalMethod
      //
      typedef ::xsd::qif30::RetrievalMethodEnumType RetrievalMethod_type;
      typedef ::xsd::cxx::tree::traits< RetrievalMethod_type, wchar_t > RetrievalMethod_traits;

      const RetrievalMethod_type&
      RetrievalMethod () const;

      RetrievalMethod_type&
      RetrievalMethod ();

      void
      RetrievalMethod (const RetrievalMethod_type& x);

      void
      RetrievalMethod (::std::unique_ptr< RetrievalMethod_type > p);

      // Constructors.
      //
      EdgePointFromScanType ();

      EdgePointFromScanType (const SurfaceFeature_type&,
                             const SearchRadius_type&,
                             const PatchRadius_type&,
                             const Distance_type&,
                             const Depth_type&,
                             const RetrievalMethod_type&);

      EdgePointFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                             ::std::unique_ptr< SearchRadius_type >,
                             ::std::unique_ptr< PatchRadius_type >,
                             ::std::unique_ptr< Distance_type >,
                             ::std::unique_ptr< Depth_type >,
                             const RetrievalMethod_type&);

      EdgePointFromScanType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      EdgePointFromScanType (const EdgePointFromScanType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual EdgePointFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointFromScanType&
      operator= (const EdgePointFromScanType& x);

      virtual 
      ~EdgePointFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      ::xsd::cxx::tree::one< PatchRadius_type > PatchRadius_;
      ::xsd::cxx::tree::one< Distance_type > Distance_;
      ::xsd::cxx::tree::one< Depth_type > Depth_;
      ::xsd::cxx::tree::one< RetrievalMethod_type > RetrievalMethod_;
    };

    class QIF30_SYMBOL_DECL EdgePointCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::EdgePointConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      EdgePointCheckedType ();

      EdgePointCheckedType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      EdgePointCheckedType (const EdgePointCheckedType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual EdgePointCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointCheckedType&
      operator= (const EdgePointCheckedType& x);

      virtual 
      ~EdgePointCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL EdgePointCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::EdgePointCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      EdgePointCheckedFeatureType ();

      EdgePointCheckedFeatureType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      EdgePointCheckedFeatureType (const EdgePointCheckedFeatureType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual EdgePointCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointCheckedFeatureType&
      operator= (const EdgePointCheckedFeatureType& x);

      virtual 
      ~EdgePointCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL EdgePointMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::EdgePointCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      EdgePointMeasurementDeterminationType ();

      EdgePointMeasurementDeterminationType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      EdgePointMeasurementDeterminationType (const EdgePointMeasurementDeterminationType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual EdgePointMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointMeasurementDeterminationType&
      operator= (const EdgePointMeasurementDeterminationType& x);

      virtual 
      ~EdgePointMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL EdgePointFeatureItemType: public ::xsd::qif30::PointFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::EdgePointMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      EdgePointFeatureItemType ();

      EdgePointFeatureItemType (const id_type&,
                                const FeatureNominalId_type&,
                                const FeatureName_type&,
                                const DeterminationMode_type&);

      EdgePointFeatureItemType (const id_type&,
                                ::std::unique_ptr< FeatureNominalId_type >,
                                const FeatureName_type&,
                                ::std::unique_ptr< DeterminationMode_type >);

      EdgePointFeatureItemType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      EdgePointFeatureItemType (const EdgePointFeatureItemType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual EdgePointFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointFeatureItemType&
      operator= (const EdgePointFeatureItemType& x);

      virtual 
      ~EdgePointFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL EdgePointFeatureDefinitionType: public ::xsd::qif30::PointFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Constructors.
      //
      EdgePointFeatureDefinitionType ();

      EdgePointFeatureDefinitionType (const id_type&,
                                      const InternalExternal_type&);

      EdgePointFeatureDefinitionType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      EdgePointFeatureDefinitionType (const EdgePointFeatureDefinitionType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual EdgePointFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointFeatureDefinitionType&
      operator= (const EdgePointFeatureDefinitionType& x);

      virtual 
      ~EdgePointFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
    };

    class QIF30_SYMBOL_DECL EdgePointFeatureNominalType: public ::xsd::qif30::PointFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // AdjacentNormal
      //
      typedef ::xsd::qif30::UnitVectorType AdjacentNormal_type;
      typedef ::xsd::cxx::tree::optional< AdjacentNormal_type > AdjacentNormal_optional;
      typedef ::xsd::cxx::tree::traits< AdjacentNormal_type, wchar_t > AdjacentNormal_traits;

      const AdjacentNormal_optional&
      AdjacentNormal () const;

      AdjacentNormal_optional&
      AdjacentNormal ();

      void
      AdjacentNormal (const AdjacentNormal_type& x);

      void
      AdjacentNormal (const AdjacentNormal_optional& x);

      void
      AdjacentNormal (::std::unique_ptr< AdjacentNormal_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::EdgePointConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      EdgePointFeatureNominalType ();

      EdgePointFeatureNominalType (const id_type&,
                                   const FeatureDefinitionId_type&,
                                   const Location_type&,
                                   const Normal_type&);

      EdgePointFeatureNominalType (const id_type&,
                                   ::std::unique_ptr< FeatureDefinitionId_type >,
                                   ::std::unique_ptr< Location_type >,
                                   ::std::unique_ptr< Normal_type >);

      EdgePointFeatureNominalType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      EdgePointFeatureNominalType (const EdgePointFeatureNominalType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual EdgePointFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointFeatureNominalType&
      operator= (const EdgePointFeatureNominalType& x);

      virtual 
      ~EdgePointFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      AdjacentNormal_optional AdjacentNormal_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL EdgePointFeatureMeasurementType: public ::xsd::qif30::PointFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // AdjacentNormal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType AdjacentNormal_type;
      typedef ::xsd::cxx::tree::optional< AdjacentNormal_type > AdjacentNormal_optional;
      typedef ::xsd::cxx::tree::traits< AdjacentNormal_type, wchar_t > AdjacentNormal_traits;

      const AdjacentNormal_optional&
      AdjacentNormal () const;

      AdjacentNormal_optional&
      AdjacentNormal ();

      void
      AdjacentNormal (const AdjacentNormal_type& x);

      void
      AdjacentNormal (const AdjacentNormal_optional& x);

      void
      AdjacentNormal (::std::unique_ptr< AdjacentNormal_type > p);

      // Constructors.
      //
      EdgePointFeatureMeasurementType ();

      EdgePointFeatureMeasurementType (const id_type&);

      EdgePointFeatureMeasurementType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      EdgePointFeatureMeasurementType (const EdgePointFeatureMeasurementType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual EdgePointFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EdgePointFeatureMeasurementType&
      operator= (const EdgePointFeatureMeasurementType& x);

      virtual 
      ~EdgePointFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      Normal_optional Normal_;
      AdjacentNormal_optional AdjacentNormal_;
    };

    class QIF30_SYMBOL_DECL EllipseConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::EllipseBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::EllipseRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Intersection
      //
      typedef ::xsd::qif30::EllipseIntersectionType Intersection_type;
      typedef ::xsd::cxx::tree::optional< Intersection_type > Intersection_optional;
      typedef ::xsd::cxx::tree::traits< Intersection_type, wchar_t > Intersection_traits;

      const Intersection_optional&
      Intersection () const;

      Intersection_optional&
      Intersection ();

      void
      Intersection (const Intersection_type& x);

      void
      Intersection (const Intersection_optional& x);

      void
      Intersection (::std::unique_ptr< Intersection_type > p);

      // Projection
      //
      typedef ::xsd::qif30::EllipseProjectionType Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      void
      Projection (::std::unique_ptr< Projection_type > p);

      // Copy
      //
      typedef ::xsd::qif30::EllipseCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::EllipseCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::EllipseTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::EllipseFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      EllipseConstructionMethodType ();

      EllipseConstructionMethodType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      EllipseConstructionMethodType (const EllipseConstructionMethodType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual EllipseConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseConstructionMethodType&
      operator= (const EllipseConstructionMethodType& x);

      virtual 
      ~EllipseConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Intersection_optional Intersection_;
      Projection_optional Projection_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL EllipseBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      EllipseBestFitType ();

      EllipseBestFitType (const n_type&);

      EllipseBestFitType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      EllipseBestFitType (const EllipseBestFitType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual EllipseBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseBestFitType&
      operator= (const EllipseBestFitType& x);

      virtual 
      ~EllipseBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL EllipseRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      EllipseRecompType ();

      EllipseRecompType (const BaseFeaturePointList_type&);

      EllipseRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      EllipseRecompType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      EllipseRecompType (const EllipseRecompType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual EllipseRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseRecompType&
      operator= (const EllipseRecompType& x);

      virtual 
      ~EllipseRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL EllipseProjectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ProjectionFeature
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionFeature_type;
      typedef ::xsd::cxx::tree::traits< ProjectionFeature_type, wchar_t > ProjectionFeature_traits;

      const ProjectionFeature_type&
      ProjectionFeature () const;

      ProjectionFeature_type&
      ProjectionFeature ();

      void
      ProjectionFeature (const ProjectionFeature_type& x);

      void
      ProjectionFeature (::std::unique_ptr< ProjectionFeature_type > p);

      // ProjectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionPlane_type;
      typedef ::xsd::cxx::tree::traits< ProjectionPlane_type, wchar_t > ProjectionPlane_traits;

      const ProjectionPlane_type&
      ProjectionPlane () const;

      ProjectionPlane_type&
      ProjectionPlane ();

      void
      ProjectionPlane (const ProjectionPlane_type& x);

      void
      ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > p);

      // Constructors.
      //
      EllipseProjectionType ();

      EllipseProjectionType (const ProjectionFeature_type&,
                             const ProjectionPlane_type&);

      EllipseProjectionType (::std::unique_ptr< ProjectionFeature_type >,
                             ::std::unique_ptr< ProjectionPlane_type >);

      EllipseProjectionType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      EllipseProjectionType (const EllipseProjectionType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual EllipseProjectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseProjectionType&
      operator= (const EllipseProjectionType& x);

      virtual 
      ~EllipseProjectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProjectionFeature_type > ProjectionFeature_;
      ::xsd::cxx::tree::one< ProjectionPlane_type > ProjectionPlane_;
    };

    class QIF30_SYMBOL_DECL EllipseIntersectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // IntersectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType IntersectionPlane_type;
      typedef ::xsd::cxx::tree::traits< IntersectionPlane_type, wchar_t > IntersectionPlane_traits;

      const IntersectionPlane_type&
      IntersectionPlane () const;

      IntersectionPlane_type&
      IntersectionPlane ();

      void
      IntersectionPlane (const IntersectionPlane_type& x);

      void
      IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > p);

      // IntersectionFeature
      //
      typedef ::xsd::qif30::BaseFeatureType IntersectionFeature_type;
      typedef ::xsd::cxx::tree::traits< IntersectionFeature_type, wchar_t > IntersectionFeature_traits;

      const IntersectionFeature_type&
      IntersectionFeature () const;

      IntersectionFeature_type&
      IntersectionFeature ();

      void
      IntersectionFeature (const IntersectionFeature_type& x);

      void
      IntersectionFeature (::std::unique_ptr< IntersectionFeature_type > p);

      // Constructors.
      //
      EllipseIntersectionType ();

      EllipseIntersectionType (const IntersectionPlane_type&,
                               const IntersectionFeature_type&);

      EllipseIntersectionType (::std::unique_ptr< IntersectionPlane_type >,
                               ::std::unique_ptr< IntersectionFeature_type >);

      EllipseIntersectionType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      EllipseIntersectionType (const EllipseIntersectionType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual EllipseIntersectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseIntersectionType&
      operator= (const EllipseIntersectionType& x);

      virtual 
      ~EllipseIntersectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< IntersectionPlane_type > IntersectionPlane_;
      ::xsd::cxx::tree::one< IntersectionFeature_type > IntersectionFeature_;
    };

    class QIF30_SYMBOL_DECL EllipseCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseEllipse
      //
      typedef ::xsd::qif30::BaseFeatureType BaseEllipse_type;
      typedef ::xsd::cxx::tree::traits< BaseEllipse_type, wchar_t > BaseEllipse_traits;

      const BaseEllipse_type&
      BaseEllipse () const;

      BaseEllipse_type&
      BaseEllipse ();

      void
      BaseEllipse (const BaseEllipse_type& x);

      void
      BaseEllipse (::std::unique_ptr< BaseEllipse_type > p);

      // Constructors.
      //
      EllipseCopyType ();

      EllipseCopyType (const BaseEllipse_type&);

      EllipseCopyType (::std::unique_ptr< BaseEllipse_type >);

      EllipseCopyType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      EllipseCopyType (const EllipseCopyType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual EllipseCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseCopyType&
      operator= (const EllipseCopyType& x);

      virtual 
      ~EllipseCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseEllipse_type > BaseEllipse_;
    };

    class QIF30_SYMBOL_DECL EllipseCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      EllipseCastType ();

      EllipseCastType (const BaseFeature_type&);

      EllipseCastType (::std::unique_ptr< BaseFeature_type >);

      EllipseCastType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      EllipseCastType (const EllipseCastType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual EllipseCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseCastType&
      operator= (const EllipseCastType& x);

      virtual 
      ~EllipseCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL EllipseTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseEllipse
      //
      typedef ::xsd::qif30::BaseFeatureType BaseEllipse_type;
      typedef ::xsd::cxx::tree::traits< BaseEllipse_type, wchar_t > BaseEllipse_traits;

      const BaseEllipse_type&
      BaseEllipse () const;

      BaseEllipse_type&
      BaseEllipse ();

      void
      BaseEllipse (const BaseEllipse_type& x);

      void
      BaseEllipse (::std::unique_ptr< BaseEllipse_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      EllipseTransformType ();

      EllipseTransformType (const BaseEllipse_type&,
                            const Transformation_type&);

      EllipseTransformType (::std::unique_ptr< BaseEllipse_type >,
                            ::std::unique_ptr< Transformation_type >);

      EllipseTransformType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      EllipseTransformType (const EllipseTransformType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual EllipseTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseTransformType&
      operator= (const EllipseTransformType& x);

      virtual 
      ~EllipseTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseEllipse_type > BaseEllipse_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL EllipseFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_type&
      Depth () const;

      Depth_type&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Constructors.
      //
      EllipseFromScanType ();

      EllipseFromScanType (const SurfaceFeature_type&,
                           const SearchRadius_type&,
                           const Depth_type&);

      EllipseFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                           ::std::unique_ptr< SearchRadius_type >,
                           ::std::unique_ptr< Depth_type >);

      EllipseFromScanType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      EllipseFromScanType (const EllipseFromScanType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual EllipseFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseFromScanType&
      operator= (const EllipseFromScanType& x);

      virtual 
      ~EllipseFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      ::xsd::cxx::tree::one< Depth_type > Depth_;
    };

    class QIF30_SYMBOL_DECL EllipseCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::EllipseConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      EllipseCheckedType ();

      EllipseCheckedType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      EllipseCheckedType (const EllipseCheckedType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual EllipseCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseCheckedType&
      operator= (const EllipseCheckedType& x);

      virtual 
      ~EllipseCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL EllipseCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::EllipseCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      EllipseCheckedFeatureType ();

      EllipseCheckedFeatureType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      EllipseCheckedFeatureType (const EllipseCheckedFeatureType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual EllipseCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseCheckedFeatureType&
      operator= (const EllipseCheckedFeatureType& x);

      virtual 
      ~EllipseCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL EllipseMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::EllipseCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      EllipseMeasurementDeterminationType ();

      EllipseMeasurementDeterminationType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      EllipseMeasurementDeterminationType (const EllipseMeasurementDeterminationType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual EllipseMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseMeasurementDeterminationType&
      operator= (const EllipseMeasurementDeterminationType& x);

      virtual 
      ~EllipseMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL EllipseFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::EllipseMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      EllipseFeatureItemType ();

      EllipseFeatureItemType (const id_type&,
                              const FeatureNominalId_type&,
                              const FeatureName_type&,
                              const DeterminationMode_type&);

      EllipseFeatureItemType (const id_type&,
                              ::std::unique_ptr< FeatureNominalId_type >,
                              const FeatureName_type&,
                              ::std::unique_ptr< DeterminationMode_type >);

      EllipseFeatureItemType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      EllipseFeatureItemType (const EllipseFeatureItemType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual EllipseFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseFeatureItemType&
      operator= (const EllipseFeatureItemType& x);

      virtual 
      ~EllipseFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL EllipseFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // MajorDiameter
      //
      typedef ::xsd::qif30::LinearValueType MajorDiameter_type;
      typedef ::xsd::cxx::tree::traits< MajorDiameter_type, wchar_t > MajorDiameter_traits;

      const MajorDiameter_type&
      MajorDiameter () const;

      MajorDiameter_type&
      MajorDiameter ();

      void
      MajorDiameter (const MajorDiameter_type& x);

      void
      MajorDiameter (::std::unique_ptr< MajorDiameter_type > p);

      // MinorDiameter
      //
      typedef ::xsd::qif30::LinearValueType MinorDiameter_type;
      typedef ::xsd::cxx::tree::traits< MinorDiameter_type, wchar_t > MinorDiameter_traits;

      const MinorDiameter_type&
      MinorDiameter () const;

      MinorDiameter_type&
      MinorDiameter ();

      void
      MinorDiameter (const MinorDiameter_type& x);

      void
      MinorDiameter (::std::unique_ptr< MinorDiameter_type > p);

      // Constructors.
      //
      EllipseFeatureDefinitionType ();

      EllipseFeatureDefinitionType (const id_type&,
                                    const InternalExternal_type&,
                                    const MajorDiameter_type&,
                                    const MinorDiameter_type&);

      EllipseFeatureDefinitionType (const id_type&,
                                    const InternalExternal_type&,
                                    ::std::unique_ptr< MajorDiameter_type >,
                                    ::std::unique_ptr< MinorDiameter_type >);

      EllipseFeatureDefinitionType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      EllipseFeatureDefinitionType (const EllipseFeatureDefinitionType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual EllipseFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseFeatureDefinitionType&
      operator= (const EllipseFeatureDefinitionType& x);

      virtual 
      ~EllipseFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< MajorDiameter_type > MajorDiameter_;
      ::xsd::cxx::tree::one< MinorDiameter_type > MinorDiameter_;
    };

    class QIF30_SYMBOL_DECL EllipseFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::optional< Sweep_type > Sweep_optional;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_optional&
      Sweep () const;

      Sweep_optional&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (const Sweep_optional& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::EllipseConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      EllipseFeatureNominalType ();

      EllipseFeatureNominalType (const id_type&,
                                 const FeatureDefinitionId_type&,
                                 const Axis_type&,
                                 const Normal_type&);

      EllipseFeatureNominalType (const id_type&,
                                 ::std::unique_ptr< FeatureDefinitionId_type >,
                                 ::std::unique_ptr< Axis_type >,
                                 ::std::unique_ptr< Normal_type >);

      EllipseFeatureNominalType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      EllipseFeatureNominalType (const EllipseFeatureNominalType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual EllipseFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseFeatureNominalType&
      operator= (const EllipseFeatureNominalType& x);

      virtual 
      ~EllipseFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      Sweep_optional Sweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL EllipseFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::MeasuredAxisType Axis_type;
      typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_optional&
      Axis () const;

      Axis_optional&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (const Axis_optional& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // MajorDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MajorDiameter_type;
      typedef ::xsd::cxx::tree::optional< MajorDiameter_type > MajorDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MajorDiameter_type, wchar_t > MajorDiameter_traits;

      const MajorDiameter_optional&
      MajorDiameter () const;

      MajorDiameter_optional&
      MajorDiameter ();

      void
      MajorDiameter (const MajorDiameter_type& x);

      void
      MajorDiameter (const MajorDiameter_optional& x);

      void
      MajorDiameter (::std::unique_ptr< MajorDiameter_type > p);

      // MinorDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinorDiameter_type;
      typedef ::xsd::cxx::tree::optional< MinorDiameter_type > MinorDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MinorDiameter_type, wchar_t > MinorDiameter_traits;

      const MinorDiameter_optional&
      MinorDiameter () const;

      MinorDiameter_optional&
      MinorDiameter ();

      void
      MinorDiameter (const MinorDiameter_type& x);

      void
      MinorDiameter (const MinorDiameter_optional& x);

      void
      MinorDiameter (::std::unique_ptr< MinorDiameter_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      EllipseFeatureMeasurementType ();

      EllipseFeatureMeasurementType (const id_type&);

      EllipseFeatureMeasurementType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      EllipseFeatureMeasurementType (const EllipseFeatureMeasurementType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual EllipseFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipseFeatureMeasurementType&
      operator= (const EllipseFeatureMeasurementType& x);

      virtual 
      ~EllipseFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Axis_optional Axis_;
      Normal_optional Normal_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
      MajorDiameter_optional MajorDiameter_;
      MinorDiameter_optional MinorDiameter_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::EllipticalArcBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::EllipticalArcRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Intersection
      //
      typedef ::xsd::qif30::EllipticalArcIntersectionType Intersection_type;
      typedef ::xsd::cxx::tree::optional< Intersection_type > Intersection_optional;
      typedef ::xsd::cxx::tree::traits< Intersection_type, wchar_t > Intersection_traits;

      const Intersection_optional&
      Intersection () const;

      Intersection_optional&
      Intersection ();

      void
      Intersection (const Intersection_type& x);

      void
      Intersection (const Intersection_optional& x);

      void
      Intersection (::std::unique_ptr< Intersection_type > p);

      // Projection
      //
      typedef ::xsd::qif30::EllipticalArcProjectionType Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      void
      Projection (::std::unique_ptr< Projection_type > p);

      // Copy
      //
      typedef ::xsd::qif30::EllipticalArcCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::EllipticalArcCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::EllipticalArcTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::EllipticalArcFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      EllipticalArcConstructionMethodType ();

      EllipticalArcConstructionMethodType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      EllipticalArcConstructionMethodType (const EllipticalArcConstructionMethodType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual EllipticalArcConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcConstructionMethodType&
      operator= (const EllipticalArcConstructionMethodType& x);

      virtual 
      ~EllipticalArcConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Intersection_optional Intersection_;
      Projection_optional Projection_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      EllipticalArcBestFitType ();

      EllipticalArcBestFitType (const n_type&);

      EllipticalArcBestFitType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      EllipticalArcBestFitType (const EllipticalArcBestFitType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual EllipticalArcBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcBestFitType&
      operator= (const EllipticalArcBestFitType& x);

      virtual 
      ~EllipticalArcBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      EllipticalArcRecompType ();

      EllipticalArcRecompType (const BaseFeaturePointList_type&);

      EllipticalArcRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      EllipticalArcRecompType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      EllipticalArcRecompType (const EllipticalArcRecompType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual EllipticalArcRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcRecompType&
      operator= (const EllipticalArcRecompType& x);

      virtual 
      ~EllipticalArcRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcProjectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ProjectionFeature
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionFeature_type;
      typedef ::xsd::cxx::tree::traits< ProjectionFeature_type, wchar_t > ProjectionFeature_traits;

      const ProjectionFeature_type&
      ProjectionFeature () const;

      ProjectionFeature_type&
      ProjectionFeature ();

      void
      ProjectionFeature (const ProjectionFeature_type& x);

      void
      ProjectionFeature (::std::unique_ptr< ProjectionFeature_type > p);

      // ProjectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionPlane_type;
      typedef ::xsd::cxx::tree::traits< ProjectionPlane_type, wchar_t > ProjectionPlane_traits;

      const ProjectionPlane_type&
      ProjectionPlane () const;

      ProjectionPlane_type&
      ProjectionPlane ();

      void
      ProjectionPlane (const ProjectionPlane_type& x);

      void
      ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > p);

      // Constructors.
      //
      EllipticalArcProjectionType ();

      EllipticalArcProjectionType (const ProjectionFeature_type&,
                                   const ProjectionPlane_type&);

      EllipticalArcProjectionType (::std::unique_ptr< ProjectionFeature_type >,
                                   ::std::unique_ptr< ProjectionPlane_type >);

      EllipticalArcProjectionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      EllipticalArcProjectionType (const EllipticalArcProjectionType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual EllipticalArcProjectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcProjectionType&
      operator= (const EllipticalArcProjectionType& x);

      virtual 
      ~EllipticalArcProjectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProjectionFeature_type > ProjectionFeature_;
      ::xsd::cxx::tree::one< ProjectionPlane_type > ProjectionPlane_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcIntersectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // IntersectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType IntersectionPlane_type;
      typedef ::xsd::cxx::tree::traits< IntersectionPlane_type, wchar_t > IntersectionPlane_traits;

      const IntersectionPlane_type&
      IntersectionPlane () const;

      IntersectionPlane_type&
      IntersectionPlane ();

      void
      IntersectionPlane (const IntersectionPlane_type& x);

      void
      IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > p);

      // IntersectionFeature
      //
      typedef ::xsd::qif30::BaseFeatureType IntersectionFeature_type;
      typedef ::xsd::cxx::tree::traits< IntersectionFeature_type, wchar_t > IntersectionFeature_traits;

      const IntersectionFeature_type&
      IntersectionFeature () const;

      IntersectionFeature_type&
      IntersectionFeature ();

      void
      IntersectionFeature (const IntersectionFeature_type& x);

      void
      IntersectionFeature (::std::unique_ptr< IntersectionFeature_type > p);

      // Constructors.
      //
      EllipticalArcIntersectionType ();

      EllipticalArcIntersectionType (const IntersectionPlane_type&,
                                     const IntersectionFeature_type&);

      EllipticalArcIntersectionType (::std::unique_ptr< IntersectionPlane_type >,
                                     ::std::unique_ptr< IntersectionFeature_type >);

      EllipticalArcIntersectionType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      EllipticalArcIntersectionType (const EllipticalArcIntersectionType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual EllipticalArcIntersectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcIntersectionType&
      operator= (const EllipticalArcIntersectionType& x);

      virtual 
      ~EllipticalArcIntersectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< IntersectionPlane_type > IntersectionPlane_;
      ::xsd::cxx::tree::one< IntersectionFeature_type > IntersectionFeature_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseEllipticalArc
      //
      typedef ::xsd::qif30::BaseFeatureType BaseEllipticalArc_type;
      typedef ::xsd::cxx::tree::traits< BaseEllipticalArc_type, wchar_t > BaseEllipticalArc_traits;

      const BaseEllipticalArc_type&
      BaseEllipticalArc () const;

      BaseEllipticalArc_type&
      BaseEllipticalArc ();

      void
      BaseEllipticalArc (const BaseEllipticalArc_type& x);

      void
      BaseEllipticalArc (::std::unique_ptr< BaseEllipticalArc_type > p);

      // Constructors.
      //
      EllipticalArcCopyType ();

      EllipticalArcCopyType (const BaseEllipticalArc_type&);

      EllipticalArcCopyType (::std::unique_ptr< BaseEllipticalArc_type >);

      EllipticalArcCopyType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      EllipticalArcCopyType (const EllipticalArcCopyType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual EllipticalArcCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcCopyType&
      operator= (const EllipticalArcCopyType& x);

      virtual 
      ~EllipticalArcCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseEllipticalArc_type > BaseEllipticalArc_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      EllipticalArcCastType ();

      EllipticalArcCastType (const BaseFeature_type&);

      EllipticalArcCastType (::std::unique_ptr< BaseFeature_type >);

      EllipticalArcCastType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      EllipticalArcCastType (const EllipticalArcCastType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual EllipticalArcCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcCastType&
      operator= (const EllipticalArcCastType& x);

      virtual 
      ~EllipticalArcCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseEllipticalArc
      //
      typedef ::xsd::qif30::BaseFeatureType BaseEllipticalArc_type;
      typedef ::xsd::cxx::tree::traits< BaseEllipticalArc_type, wchar_t > BaseEllipticalArc_traits;

      const BaseEllipticalArc_type&
      BaseEllipticalArc () const;

      BaseEllipticalArc_type&
      BaseEllipticalArc ();

      void
      BaseEllipticalArc (const BaseEllipticalArc_type& x);

      void
      BaseEllipticalArc (::std::unique_ptr< BaseEllipticalArc_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      EllipticalArcTransformType ();

      EllipticalArcTransformType (const BaseEllipticalArc_type&,
                                  const Transformation_type&);

      EllipticalArcTransformType (::std::unique_ptr< BaseEllipticalArc_type >,
                                  ::std::unique_ptr< Transformation_type >);

      EllipticalArcTransformType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      EllipticalArcTransformType (const EllipticalArcTransformType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual EllipticalArcTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcTransformType&
      operator= (const EllipticalArcTransformType& x);

      virtual 
      ~EllipticalArcTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseEllipticalArc_type > BaseEllipticalArc_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_type&
      Depth () const;

      Depth_type&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Constructors.
      //
      EllipticalArcFromScanType ();

      EllipticalArcFromScanType (const SurfaceFeature_type&,
                                 const SearchRadius_type&,
                                 const Depth_type&);

      EllipticalArcFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                                 ::std::unique_ptr< SearchRadius_type >,
                                 ::std::unique_ptr< Depth_type >);

      EllipticalArcFromScanType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      EllipticalArcFromScanType (const EllipticalArcFromScanType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual EllipticalArcFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcFromScanType&
      operator= (const EllipticalArcFromScanType& x);

      virtual 
      ~EllipticalArcFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      ::xsd::cxx::tree::one< Depth_type > Depth_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::EllipticalArcConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      EllipticalArcCheckedType ();

      EllipticalArcCheckedType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      EllipticalArcCheckedType (const EllipticalArcCheckedType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual EllipticalArcCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcCheckedType&
      operator= (const EllipticalArcCheckedType& x);

      virtual 
      ~EllipticalArcCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::EllipticalArcCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      EllipticalArcCheckedFeatureType ();

      EllipticalArcCheckedFeatureType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      EllipticalArcCheckedFeatureType (const EllipticalArcCheckedFeatureType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual EllipticalArcCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcCheckedFeatureType&
      operator= (const EllipticalArcCheckedFeatureType& x);

      virtual 
      ~EllipticalArcCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::EllipticalArcCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      EllipticalArcMeasurementDeterminationType ();

      EllipticalArcMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      EllipticalArcMeasurementDeterminationType (const EllipticalArcMeasurementDeterminationType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual EllipticalArcMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcMeasurementDeterminationType&
      operator= (const EllipticalArcMeasurementDeterminationType& x);

      virtual 
      ~EllipticalArcMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::EllipticalArcMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      EllipticalArcFeatureItemType ();

      EllipticalArcFeatureItemType (const id_type&,
                                    const FeatureNominalId_type&,
                                    const FeatureName_type&,
                                    const DeterminationMode_type&);

      EllipticalArcFeatureItemType (const id_type&,
                                    ::std::unique_ptr< FeatureNominalId_type >,
                                    const FeatureName_type&,
                                    ::std::unique_ptr< DeterminationMode_type >);

      EllipticalArcFeatureItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      EllipticalArcFeatureItemType (const EllipticalArcFeatureItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual EllipticalArcFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcFeatureItemType&
      operator= (const EllipticalArcFeatureItemType& x);

      virtual 
      ~EllipticalArcFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // MajorDiameter
      //
      typedef ::xsd::qif30::LinearValueType MajorDiameter_type;
      typedef ::xsd::cxx::tree::traits< MajorDiameter_type, wchar_t > MajorDiameter_traits;

      const MajorDiameter_type&
      MajorDiameter () const;

      MajorDiameter_type&
      MajorDiameter ();

      void
      MajorDiameter (const MajorDiameter_type& x);

      void
      MajorDiameter (::std::unique_ptr< MajorDiameter_type > p);

      // MinorDiameter
      //
      typedef ::xsd::qif30::LinearValueType MinorDiameter_type;
      typedef ::xsd::cxx::tree::traits< MinorDiameter_type, wchar_t > MinorDiameter_traits;

      const MinorDiameter_type&
      MinorDiameter () const;

      MinorDiameter_type&
      MinorDiameter ();

      void
      MinorDiameter (const MinorDiameter_type& x);

      void
      MinorDiameter (::std::unique_ptr< MinorDiameter_type > p);

      // Constructors.
      //
      EllipticalArcFeatureDefinitionType ();

      EllipticalArcFeatureDefinitionType (const id_type&,
                                          const InternalExternal_type&,
                                          const MajorDiameter_type&,
                                          const MinorDiameter_type&);

      EllipticalArcFeatureDefinitionType (const id_type&,
                                          const InternalExternal_type&,
                                          ::std::unique_ptr< MajorDiameter_type >,
                                          ::std::unique_ptr< MinorDiameter_type >);

      EllipticalArcFeatureDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      EllipticalArcFeatureDefinitionType (const EllipticalArcFeatureDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual EllipticalArcFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcFeatureDefinitionType&
      operator= (const EllipticalArcFeatureDefinitionType& x);

      virtual 
      ~EllipticalArcFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< MajorDiameter_type > MajorDiameter_;
      ::xsd::cxx::tree::one< MinorDiameter_type > MinorDiameter_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_type&
      Sweep () const;

      Sweep_type&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::EllipticalArcConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      EllipticalArcFeatureNominalType ();

      EllipticalArcFeatureNominalType (const id_type&,
                                       const FeatureDefinitionId_type&,
                                       const Axis_type&,
                                       const Normal_type&,
                                       const Sweep_type&);

      EllipticalArcFeatureNominalType (const id_type&,
                                       ::std::unique_ptr< FeatureDefinitionId_type >,
                                       ::std::unique_ptr< Axis_type >,
                                       ::std::unique_ptr< Normal_type >,
                                       ::std::unique_ptr< Sweep_type >);

      EllipticalArcFeatureNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      EllipticalArcFeatureNominalType (const EllipticalArcFeatureNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual EllipticalArcFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcFeatureNominalType&
      operator= (const EllipticalArcFeatureNominalType& x);

      virtual 
      ~EllipticalArcFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      ::xsd::cxx::tree::one< Sweep_type > Sweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL EllipticalArcFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::MeasuredAxisType Axis_type;
      typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_optional&
      Axis () const;

      Axis_optional&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (const Axis_optional& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // MajorDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MajorDiameter_type;
      typedef ::xsd::cxx::tree::optional< MajorDiameter_type > MajorDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MajorDiameter_type, wchar_t > MajorDiameter_traits;

      const MajorDiameter_optional&
      MajorDiameter () const;

      MajorDiameter_optional&
      MajorDiameter ();

      void
      MajorDiameter (const MajorDiameter_type& x);

      void
      MajorDiameter (const MajorDiameter_optional& x);

      void
      MajorDiameter (::std::unique_ptr< MajorDiameter_type > p);

      // MinorDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinorDiameter_type;
      typedef ::xsd::cxx::tree::optional< MinorDiameter_type > MinorDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MinorDiameter_type, wchar_t > MinorDiameter_traits;

      const MinorDiameter_optional&
      MinorDiameter () const;

      MinorDiameter_optional&
      MinorDiameter ();

      void
      MinorDiameter (const MinorDiameter_type& x);

      void
      MinorDiameter (const MinorDiameter_optional& x);

      void
      MinorDiameter (::std::unique_ptr< MinorDiameter_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      EllipticalArcFeatureMeasurementType ();

      EllipticalArcFeatureMeasurementType (const id_type&);

      EllipticalArcFeatureMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      EllipticalArcFeatureMeasurementType (const EllipticalArcFeatureMeasurementType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual EllipticalArcFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipticalArcFeatureMeasurementType&
      operator= (const EllipticalArcFeatureMeasurementType& x);

      virtual 
      ~EllipticalArcFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Axis_optional Axis_;
      Normal_optional Normal_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
      MajorDiameter_optional MajorDiameter_;
      MinorDiameter_optional MinorDiameter_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::ElongatedCircleBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::ElongatedCircleRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::ElongatedCircleCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::ElongatedCircleCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElongatedCircleTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      ElongatedCircleConstructionMethodType ();

      ElongatedCircleConstructionMethodType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ElongatedCircleConstructionMethodType (const ElongatedCircleConstructionMethodType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ElongatedCircleConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleConstructionMethodType&
      operator= (const ElongatedCircleConstructionMethodType& x);

      virtual 
      ~ElongatedCircleConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ElongatedCircleBestFitType ();

      ElongatedCircleBestFitType (const n_type&);

      ElongatedCircleBestFitType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ElongatedCircleBestFitType (const ElongatedCircleBestFitType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ElongatedCircleBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleBestFitType&
      operator= (const ElongatedCircleBestFitType& x);

      virtual 
      ~ElongatedCircleBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      ElongatedCircleRecompType ();

      ElongatedCircleRecompType (const BaseFeaturePointList_type&);

      ElongatedCircleRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      ElongatedCircleRecompType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ElongatedCircleRecompType (const ElongatedCircleRecompType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ElongatedCircleRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleRecompType&
      operator= (const ElongatedCircleRecompType& x);

      virtual 
      ~ElongatedCircleRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseElongatedCircle
      //
      typedef ::xsd::qif30::BaseFeatureType BaseElongatedCircle_type;
      typedef ::xsd::cxx::tree::traits< BaseElongatedCircle_type, wchar_t > BaseElongatedCircle_traits;

      const BaseElongatedCircle_type&
      BaseElongatedCircle () const;

      BaseElongatedCircle_type&
      BaseElongatedCircle ();

      void
      BaseElongatedCircle (const BaseElongatedCircle_type& x);

      void
      BaseElongatedCircle (::std::unique_ptr< BaseElongatedCircle_type > p);

      // Constructors.
      //
      ElongatedCircleCopyType ();

      ElongatedCircleCopyType (const BaseElongatedCircle_type&);

      ElongatedCircleCopyType (::std::unique_ptr< BaseElongatedCircle_type >);

      ElongatedCircleCopyType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ElongatedCircleCopyType (const ElongatedCircleCopyType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ElongatedCircleCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleCopyType&
      operator= (const ElongatedCircleCopyType& x);

      virtual 
      ~ElongatedCircleCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseElongatedCircle_type > BaseElongatedCircle_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      ElongatedCircleCastType ();

      ElongatedCircleCastType (const BaseFeature_type&);

      ElongatedCircleCastType (::std::unique_ptr< BaseFeature_type >);

      ElongatedCircleCastType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ElongatedCircleCastType (const ElongatedCircleCastType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ElongatedCircleCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleCastType&
      operator= (const ElongatedCircleCastType& x);

      virtual 
      ~ElongatedCircleCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseElongatedCircle
      //
      typedef ::xsd::qif30::BaseFeatureType BaseElongatedCircle_type;
      typedef ::xsd::cxx::tree::traits< BaseElongatedCircle_type, wchar_t > BaseElongatedCircle_traits;

      const BaseElongatedCircle_type&
      BaseElongatedCircle () const;

      BaseElongatedCircle_type&
      BaseElongatedCircle ();

      void
      BaseElongatedCircle (const BaseElongatedCircle_type& x);

      void
      BaseElongatedCircle (::std::unique_ptr< BaseElongatedCircle_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      ElongatedCircleTransformType ();

      ElongatedCircleTransformType (const BaseElongatedCircle_type&,
                                    const Transformation_type&);

      ElongatedCircleTransformType (::std::unique_ptr< BaseElongatedCircle_type >,
                                    ::std::unique_ptr< Transformation_type >);

      ElongatedCircleTransformType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ElongatedCircleTransformType (const ElongatedCircleTransformType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ElongatedCircleTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleTransformType&
      operator= (const ElongatedCircleTransformType& x);

      virtual 
      ~ElongatedCircleTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseElongatedCircle_type > BaseElongatedCircle_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ElongatedCircleConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ElongatedCircleCheckedType ();

      ElongatedCircleCheckedType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ElongatedCircleCheckedType (const ElongatedCircleCheckedType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ElongatedCircleCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleCheckedType&
      operator= (const ElongatedCircleCheckedType& x);

      virtual 
      ~ElongatedCircleCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::ElongatedCircleCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      ElongatedCircleCheckedFeatureType ();

      ElongatedCircleCheckedFeatureType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ElongatedCircleCheckedFeatureType (const ElongatedCircleCheckedFeatureType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ElongatedCircleCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleCheckedFeatureType&
      operator= (const ElongatedCircleCheckedFeatureType& x);

      virtual 
      ~ElongatedCircleCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::ElongatedCircleCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      ElongatedCircleMeasurementDeterminationType ();

      ElongatedCircleMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      ElongatedCircleMeasurementDeterminationType (const ElongatedCircleMeasurementDeterminationType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual ElongatedCircleMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleMeasurementDeterminationType&
      operator= (const ElongatedCircleMeasurementDeterminationType& x);

      virtual 
      ~ElongatedCircleMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::ElongatedCircleMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      ElongatedCircleFeatureItemType ();

      ElongatedCircleFeatureItemType (const id_type&,
                                      const FeatureNominalId_type&,
                                      const FeatureName_type&,
                                      const DeterminationMode_type&);

      ElongatedCircleFeatureItemType (const id_type&,
                                      ::std::unique_ptr< FeatureNominalId_type >,
                                      const FeatureName_type&,
                                      ::std::unique_ptr< DeterminationMode_type >);

      ElongatedCircleFeatureItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ElongatedCircleFeatureItemType (const ElongatedCircleFeatureItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ElongatedCircleFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleFeatureItemType&
      operator= (const ElongatedCircleFeatureItemType& x);

      virtual 
      ~ElongatedCircleFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_type&
      Length () const;

      Length_type&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Constructors.
      //
      ElongatedCircleFeatureDefinitionType ();

      ElongatedCircleFeatureDefinitionType (const id_type&,
                                            const InternalExternal_type&,
                                            const Diameter_type&,
                                            const Length_type&);

      ElongatedCircleFeatureDefinitionType (const id_type&,
                                            const InternalExternal_type&,
                                            ::std::unique_ptr< Diameter_type >,
                                            ::std::unique_ptr< Length_type >);

      ElongatedCircleFeatureDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ElongatedCircleFeatureDefinitionType (const ElongatedCircleFeatureDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ElongatedCircleFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleFeatureDefinitionType&
      operator= (const ElongatedCircleFeatureDefinitionType& x);

      virtual 
      ~ElongatedCircleFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      ::xsd::cxx::tree::one< Length_type > Length_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // CenterLine
      //
      typedef ::xsd::qif30::PointAndVectorType CenterLine_type;
      typedef ::xsd::cxx::tree::traits< CenterLine_type, wchar_t > CenterLine_traits;

      const CenterLine_type&
      CenterLine () const;

      CenterLine_type&
      CenterLine ();

      void
      CenterLine (const CenterLine_type& x);

      void
      CenterLine (::std::unique_ptr< CenterLine_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ElongatedCircleConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ElongatedCircleFeatureNominalType ();

      ElongatedCircleFeatureNominalType (const id_type&,
                                         const FeatureDefinitionId_type&,
                                         const CenterLine_type&,
                                         const Normal_type&);

      ElongatedCircleFeatureNominalType (const id_type&,
                                         ::std::unique_ptr< FeatureDefinitionId_type >,
                                         ::std::unique_ptr< CenterLine_type >,
                                         ::std::unique_ptr< Normal_type >);

      ElongatedCircleFeatureNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ElongatedCircleFeatureNominalType (const ElongatedCircleFeatureNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ElongatedCircleFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleFeatureNominalType&
      operator= (const ElongatedCircleFeatureNominalType& x);

      virtual 
      ~ElongatedCircleFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CenterLine_type > CenterLine_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ElongatedCircleFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // CenterLine
      //
      typedef ::xsd::qif30::MeasuredPointAndVectorType CenterLine_type;
      typedef ::xsd::cxx::tree::optional< CenterLine_type > CenterLine_optional;
      typedef ::xsd::cxx::tree::traits< CenterLine_type, wchar_t > CenterLine_traits;

      const CenterLine_optional&
      CenterLine () const;

      CenterLine_optional&
      CenterLine ();

      void
      CenterLine (const CenterLine_type& x);

      void
      CenterLine (const CenterLine_optional& x);

      void
      CenterLine (::std::unique_ptr< CenterLine_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // LengthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMax_type;
      typedef ::xsd::cxx::tree::optional< LengthMax_type > LengthMax_optional;
      typedef ::xsd::cxx::tree::traits< LengthMax_type, wchar_t > LengthMax_traits;

      const LengthMax_optional&
      LengthMax () const;

      LengthMax_optional&
      LengthMax ();

      void
      LengthMax (const LengthMax_type& x);

      void
      LengthMax (const LengthMax_optional& x);

      void
      LengthMax (::std::unique_ptr< LengthMax_type > p);

      // LengthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMin_type;
      typedef ::xsd::cxx::tree::optional< LengthMin_type > LengthMin_optional;
      typedef ::xsd::cxx::tree::traits< LengthMin_type, wchar_t > LengthMin_traits;

      const LengthMin_optional&
      LengthMin () const;

      LengthMin_optional&
      LengthMin ();

      void
      LengthMin (const LengthMin_type& x);

      void
      LengthMin (const LengthMin_optional& x);

      void
      LengthMin (::std::unique_ptr< LengthMin_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      ElongatedCircleFeatureMeasurementType ();

      ElongatedCircleFeatureMeasurementType (const id_type&);

      ElongatedCircleFeatureMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ElongatedCircleFeatureMeasurementType (const ElongatedCircleFeatureMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ElongatedCircleFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCircleFeatureMeasurementType&
      operator= (const ElongatedCircleFeatureMeasurementType& x);

      virtual 
      ~ElongatedCircleFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Diameter_optional Diameter_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      CenterLine_optional CenterLine_;
      Normal_optional Normal_;
      Length_optional Length_;
      LengthMax_optional LengthMax_;
      LengthMin_optional LengthMin_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::ElongatedCylinderBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::ElongatedCylinderRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::ElongatedCylinderCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::ElongatedCylinderCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElongatedCylinderTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      ElongatedCylinderConstructionMethodType ();

      ElongatedCylinderConstructionMethodType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      ElongatedCylinderConstructionMethodType (const ElongatedCylinderConstructionMethodType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual ElongatedCylinderConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderConstructionMethodType&
      operator= (const ElongatedCylinderConstructionMethodType& x);

      virtual 
      ~ElongatedCylinderConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ElongatedCylinderBestFitType ();

      ElongatedCylinderBestFitType (const n_type&);

      ElongatedCylinderBestFitType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ElongatedCylinderBestFitType (const ElongatedCylinderBestFitType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ElongatedCylinderBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderBestFitType&
      operator= (const ElongatedCylinderBestFitType& x);

      virtual 
      ~ElongatedCylinderBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      ElongatedCylinderRecompType ();

      ElongatedCylinderRecompType (const BaseFeaturePointList_type&);

      ElongatedCylinderRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      ElongatedCylinderRecompType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ElongatedCylinderRecompType (const ElongatedCylinderRecompType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ElongatedCylinderRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderRecompType&
      operator= (const ElongatedCylinderRecompType& x);

      virtual 
      ~ElongatedCylinderRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseElongatedCylinder
      //
      typedef ::xsd::qif30::BaseFeatureType BaseElongatedCylinder_type;
      typedef ::xsd::cxx::tree::traits< BaseElongatedCylinder_type, wchar_t > BaseElongatedCylinder_traits;

      const BaseElongatedCylinder_type&
      BaseElongatedCylinder () const;

      BaseElongatedCylinder_type&
      BaseElongatedCylinder ();

      void
      BaseElongatedCylinder (const BaseElongatedCylinder_type& x);

      void
      BaseElongatedCylinder (::std::unique_ptr< BaseElongatedCylinder_type > p);

      // Constructors.
      //
      ElongatedCylinderCopyType ();

      ElongatedCylinderCopyType (const BaseElongatedCylinder_type&);

      ElongatedCylinderCopyType (::std::unique_ptr< BaseElongatedCylinder_type >);

      ElongatedCylinderCopyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ElongatedCylinderCopyType (const ElongatedCylinderCopyType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ElongatedCylinderCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderCopyType&
      operator= (const ElongatedCylinderCopyType& x);

      virtual 
      ~ElongatedCylinderCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseElongatedCylinder_type > BaseElongatedCylinder_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      ElongatedCylinderCastType ();

      ElongatedCylinderCastType (const BaseFeature_type&);

      ElongatedCylinderCastType (::std::unique_ptr< BaseFeature_type >);

      ElongatedCylinderCastType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ElongatedCylinderCastType (const ElongatedCylinderCastType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ElongatedCylinderCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderCastType&
      operator= (const ElongatedCylinderCastType& x);

      virtual 
      ~ElongatedCylinderCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseElongatedCylinder
      //
      typedef ::xsd::qif30::BaseFeatureType BaseElongatedCylinder_type;
      typedef ::xsd::cxx::tree::traits< BaseElongatedCylinder_type, wchar_t > BaseElongatedCylinder_traits;

      const BaseElongatedCylinder_type&
      BaseElongatedCylinder () const;

      BaseElongatedCylinder_type&
      BaseElongatedCylinder ();

      void
      BaseElongatedCylinder (const BaseElongatedCylinder_type& x);

      void
      BaseElongatedCylinder (::std::unique_ptr< BaseElongatedCylinder_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      ElongatedCylinderTransformType ();

      ElongatedCylinderTransformType (const BaseElongatedCylinder_type&,
                                      const Transformation_type&);

      ElongatedCylinderTransformType (::std::unique_ptr< BaseElongatedCylinder_type >,
                                      ::std::unique_ptr< Transformation_type >);

      ElongatedCylinderTransformType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ElongatedCylinderTransformType (const ElongatedCylinderTransformType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ElongatedCylinderTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderTransformType&
      operator= (const ElongatedCylinderTransformType& x);

      virtual 
      ~ElongatedCylinderTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseElongatedCylinder_type > BaseElongatedCylinder_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ElongatedCylinderConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ElongatedCylinderCheckedType ();

      ElongatedCylinderCheckedType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ElongatedCylinderCheckedType (const ElongatedCylinderCheckedType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ElongatedCylinderCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderCheckedType&
      operator= (const ElongatedCylinderCheckedType& x);

      virtual 
      ~ElongatedCylinderCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::ElongatedCylinderCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      ElongatedCylinderCheckedFeatureType ();

      ElongatedCylinderCheckedFeatureType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ElongatedCylinderCheckedFeatureType (const ElongatedCylinderCheckedFeatureType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ElongatedCylinderCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderCheckedFeatureType&
      operator= (const ElongatedCylinderCheckedFeatureType& x);

      virtual 
      ~ElongatedCylinderCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::ElongatedCylinderCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      ElongatedCylinderMeasurementDeterminationType ();

      ElongatedCylinderMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      ElongatedCylinderMeasurementDeterminationType (const ElongatedCylinderMeasurementDeterminationType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual ElongatedCylinderMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderMeasurementDeterminationType&
      operator= (const ElongatedCylinderMeasurementDeterminationType& x);

      virtual 
      ~ElongatedCylinderMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::ElongatedCylinderMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      ElongatedCylinderFeatureItemType ();

      ElongatedCylinderFeatureItemType (const id_type&,
                                        const FeatureNominalId_type&,
                                        const FeatureName_type&,
                                        const DeterminationMode_type&);

      ElongatedCylinderFeatureItemType (const id_type&,
                                        ::std::unique_ptr< FeatureNominalId_type >,
                                        const FeatureName_type&,
                                        ::std::unique_ptr< DeterminationMode_type >);

      ElongatedCylinderFeatureItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ElongatedCylinderFeatureItemType (const ElongatedCylinderFeatureItemType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual ElongatedCylinderFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderFeatureItemType&
      operator= (const ElongatedCylinderFeatureItemType& x);

      virtual 
      ~ElongatedCylinderFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_type&
      Length () const;

      Length_type&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::optional< Depth_type > Depth_optional;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_optional&
      Depth () const;

      Depth_optional&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (const Depth_optional& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Constructors.
      //
      ElongatedCylinderFeatureDefinitionType ();

      ElongatedCylinderFeatureDefinitionType (const id_type&,
                                              const InternalExternal_type&,
                                              const Diameter_type&,
                                              const Length_type&);

      ElongatedCylinderFeatureDefinitionType (const id_type&,
                                              const InternalExternal_type&,
                                              ::std::unique_ptr< Diameter_type >,
                                              ::std::unique_ptr< Length_type >);

      ElongatedCylinderFeatureDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ElongatedCylinderFeatureDefinitionType (const ElongatedCylinderFeatureDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ElongatedCylinderFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderFeatureDefinitionType&
      operator= (const ElongatedCylinderFeatureDefinitionType& x);

      virtual 
      ~ElongatedCylinderFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      ::xsd::cxx::tree::one< Length_type > Length_;
      Depth_optional Depth_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // CenterPlane
      //
      typedef ::xsd::qif30::PlaneType CenterPlane_type;
      typedef ::xsd::cxx::tree::traits< CenterPlane_type, wchar_t > CenterPlane_traits;

      const CenterPlane_type&
      CenterPlane () const;

      CenterPlane_type&
      CenterPlane ();

      void
      CenterPlane (const CenterPlane_type& x);

      void
      CenterPlane (::std::unique_ptr< CenterPlane_type > p);

      // DepthVector
      //
      typedef ::xsd::qif30::UnitVectorType DepthVector_type;
      typedef ::xsd::cxx::tree::traits< DepthVector_type, wchar_t > DepthVector_traits;

      const DepthVector_type&
      DepthVector () const;

      DepthVector_type&
      DepthVector ();

      void
      DepthVector (const DepthVector_type& x);

      void
      DepthVector (::std::unique_ptr< DepthVector_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ElongatedCylinderConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ElongatedCylinderFeatureNominalType ();

      ElongatedCylinderFeatureNominalType (const id_type&,
                                           const FeatureDefinitionId_type&,
                                           const CenterPlane_type&,
                                           const DepthVector_type&);

      ElongatedCylinderFeatureNominalType (const id_type&,
                                           ::std::unique_ptr< FeatureDefinitionId_type >,
                                           ::std::unique_ptr< CenterPlane_type >,
                                           ::std::unique_ptr< DepthVector_type >);

      ElongatedCylinderFeatureNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ElongatedCylinderFeatureNominalType (const ElongatedCylinderFeatureNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ElongatedCylinderFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderFeatureNominalType&
      operator= (const ElongatedCylinderFeatureNominalType& x);

      virtual 
      ~ElongatedCylinderFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CenterPlane_type > CenterPlane_;
      ::xsd::cxx::tree::one< DepthVector_type > DepthVector_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ElongatedCylinderFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // CenterPlane
      //
      typedef ::xsd::qif30::MeasuredPlaneType CenterPlane_type;
      typedef ::xsd::cxx::tree::optional< CenterPlane_type > CenterPlane_optional;
      typedef ::xsd::cxx::tree::traits< CenterPlane_type, wchar_t > CenterPlane_traits;

      const CenterPlane_optional&
      CenterPlane () const;

      CenterPlane_optional&
      CenterPlane ();

      void
      CenterPlane (const CenterPlane_type& x);

      void
      CenterPlane (const CenterPlane_optional& x);

      void
      CenterPlane (::std::unique_ptr< CenterPlane_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // LengthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMax_type;
      typedef ::xsd::cxx::tree::optional< LengthMax_type > LengthMax_optional;
      typedef ::xsd::cxx::tree::traits< LengthMax_type, wchar_t > LengthMax_traits;

      const LengthMax_optional&
      LengthMax () const;

      LengthMax_optional&
      LengthMax ();

      void
      LengthMax (const LengthMax_type& x);

      void
      LengthMax (const LengthMax_optional& x);

      void
      LengthMax (::std::unique_ptr< LengthMax_type > p);

      // LengthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMin_type;
      typedef ::xsd::cxx::tree::optional< LengthMin_type > LengthMin_optional;
      typedef ::xsd::cxx::tree::traits< LengthMin_type, wchar_t > LengthMin_traits;

      const LengthMin_optional&
      LengthMin () const;

      LengthMin_optional&
      LengthMin ();

      void
      LengthMin (const LengthMin_type& x);

      void
      LengthMin (const LengthMin_optional& x);

      void
      LengthMin (::std::unique_ptr< LengthMin_type > p);

      // Depth
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Depth_type;
      typedef ::xsd::cxx::tree::optional< Depth_type > Depth_optional;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_optional&
      Depth () const;

      Depth_optional&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (const Depth_optional& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // DepthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DepthMax_type;
      typedef ::xsd::cxx::tree::optional< DepthMax_type > DepthMax_optional;
      typedef ::xsd::cxx::tree::traits< DepthMax_type, wchar_t > DepthMax_traits;

      const DepthMax_optional&
      DepthMax () const;

      DepthMax_optional&
      DepthMax ();

      void
      DepthMax (const DepthMax_type& x);

      void
      DepthMax (const DepthMax_optional& x);

      void
      DepthMax (::std::unique_ptr< DepthMax_type > p);

      // DepthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DepthMin_type;
      typedef ::xsd::cxx::tree::optional< DepthMin_type > DepthMin_optional;
      typedef ::xsd::cxx::tree::traits< DepthMin_type, wchar_t > DepthMin_traits;

      const DepthMin_optional&
      DepthMin () const;

      DepthMin_optional&
      DepthMin ();

      void
      DepthMin (const DepthMin_type& x);

      void
      DepthMin (const DepthMin_optional& x);

      void
      DepthMin (::std::unique_ptr< DepthMin_type > p);

      // DepthVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType DepthVector_type;
      typedef ::xsd::cxx::tree::optional< DepthVector_type > DepthVector_optional;
      typedef ::xsd::cxx::tree::traits< DepthVector_type, wchar_t > DepthVector_traits;

      const DepthVector_optional&
      DepthVector () const;

      DepthVector_optional&
      DepthVector ();

      void
      DepthVector (const DepthVector_type& x);

      void
      DepthVector (const DepthVector_optional& x);

      void
      DepthVector (::std::unique_ptr< DepthVector_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      ElongatedCylinderFeatureMeasurementType ();

      ElongatedCylinderFeatureMeasurementType (const id_type&);

      ElongatedCylinderFeatureMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      ElongatedCylinderFeatureMeasurementType (const ElongatedCylinderFeatureMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual ElongatedCylinderFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderFeatureMeasurementType&
      operator= (const ElongatedCylinderFeatureMeasurementType& x);

      virtual 
      ~ElongatedCylinderFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Diameter_optional Diameter_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      CenterPlane_optional CenterPlane_;
      Length_optional Length_;
      LengthMax_optional LengthMax_;
      LengthMin_optional LengthMin_;
      Depth_optional Depth_;
      DepthMax_optional DepthMax_;
      DepthMin_optional DepthMin_;
      DepthVector_optional DepthVector_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionConstructionMethodType ();

      ExtrudedCrossSectionConstructionMethodType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      ExtrudedCrossSectionConstructionMethodType (const ExtrudedCrossSectionConstructionMethodType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionConstructionMethodType&
      operator= (const ExtrudedCrossSectionConstructionMethodType& x);

      virtual 
      ~ExtrudedCrossSectionConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionBestFitType ();

      ExtrudedCrossSectionBestFitType (const n_type&);

      ExtrudedCrossSectionBestFitType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ExtrudedCrossSectionBestFitType (const ExtrudedCrossSectionBestFitType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionBestFitType&
      operator= (const ExtrudedCrossSectionBestFitType& x);

      virtual 
      ~ExtrudedCrossSectionBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionRecompType ();

      ExtrudedCrossSectionRecompType (const BaseFeaturePointList_type&);

      ExtrudedCrossSectionRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      ExtrudedCrossSectionRecompType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ExtrudedCrossSectionRecompType (const ExtrudedCrossSectionRecompType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionRecompType&
      operator= (const ExtrudedCrossSectionRecompType& x);

      virtual 
      ~ExtrudedCrossSectionRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseExtrudedCrossSection
      //
      typedef ::xsd::qif30::BaseFeatureType BaseExtrudedCrossSection_type;
      typedef ::xsd::cxx::tree::traits< BaseExtrudedCrossSection_type, wchar_t > BaseExtrudedCrossSection_traits;

      const BaseExtrudedCrossSection_type&
      BaseExtrudedCrossSection () const;

      BaseExtrudedCrossSection_type&
      BaseExtrudedCrossSection ();

      void
      BaseExtrudedCrossSection (const BaseExtrudedCrossSection_type& x);

      void
      BaseExtrudedCrossSection (::std::unique_ptr< BaseExtrudedCrossSection_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionCopyType ();

      ExtrudedCrossSectionCopyType (const BaseExtrudedCrossSection_type&);

      ExtrudedCrossSectionCopyType (::std::unique_ptr< BaseExtrudedCrossSection_type >);

      ExtrudedCrossSectionCopyType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ExtrudedCrossSectionCopyType (const ExtrudedCrossSectionCopyType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionCopyType&
      operator= (const ExtrudedCrossSectionCopyType& x);

      virtual 
      ~ExtrudedCrossSectionCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseExtrudedCrossSection_type > BaseExtrudedCrossSection_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionCastType ();

      ExtrudedCrossSectionCastType (const BaseFeature_type&);

      ExtrudedCrossSectionCastType (::std::unique_ptr< BaseFeature_type >);

      ExtrudedCrossSectionCastType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ExtrudedCrossSectionCastType (const ExtrudedCrossSectionCastType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionCastType&
      operator= (const ExtrudedCrossSectionCastType& x);

      virtual 
      ~ExtrudedCrossSectionCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseExtrudedCrossSection
      //
      typedef ::xsd::qif30::BaseFeatureType BaseExtrudedCrossSection_type;
      typedef ::xsd::cxx::tree::traits< BaseExtrudedCrossSection_type, wchar_t > BaseExtrudedCrossSection_traits;

      const BaseExtrudedCrossSection_type&
      BaseExtrudedCrossSection () const;

      BaseExtrudedCrossSection_type&
      BaseExtrudedCrossSection ();

      void
      BaseExtrudedCrossSection (const BaseExtrudedCrossSection_type& x);

      void
      BaseExtrudedCrossSection (::std::unique_ptr< BaseExtrudedCrossSection_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionTransformType ();

      ExtrudedCrossSectionTransformType (const BaseExtrudedCrossSection_type&,
                                         const Transformation_type&);

      ExtrudedCrossSectionTransformType (::std::unique_ptr< BaseExtrudedCrossSection_type >,
                                         ::std::unique_ptr< Transformation_type >);

      ExtrudedCrossSectionTransformType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ExtrudedCrossSectionTransformType (const ExtrudedCrossSectionTransformType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionTransformType&
      operator= (const ExtrudedCrossSectionTransformType& x);

      virtual 
      ~ExtrudedCrossSectionTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseExtrudedCrossSection_type > BaseExtrudedCrossSection_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionCheckedType ();

      ExtrudedCrossSectionCheckedType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ExtrudedCrossSectionCheckedType (const ExtrudedCrossSectionCheckedType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionCheckedType&
      operator= (const ExtrudedCrossSectionCheckedType& x);

      virtual 
      ~ExtrudedCrossSectionCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionCheckedFeatureType ();

      ExtrudedCrossSectionCheckedFeatureType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ExtrudedCrossSectionCheckedFeatureType (const ExtrudedCrossSectionCheckedFeatureType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionCheckedFeatureType&
      operator= (const ExtrudedCrossSectionCheckedFeatureType& x);

      virtual 
      ~ExtrudedCrossSectionCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionMeasurementDeterminationType ();

      ExtrudedCrossSectionMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      ExtrudedCrossSectionMeasurementDeterminationType (const ExtrudedCrossSectionMeasurementDeterminationType& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionMeasurementDeterminationType&
      operator= (const ExtrudedCrossSectionMeasurementDeterminationType& x);

      virtual 
      ~ExtrudedCrossSectionMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionFeatureItemType ();

      ExtrudedCrossSectionFeatureItemType (const id_type&,
                                           const FeatureNominalId_type&,
                                           const FeatureName_type&,
                                           const DeterminationMode_type&);

      ExtrudedCrossSectionFeatureItemType (const id_type&,
                                           ::std::unique_ptr< FeatureNominalId_type >,
                                           const FeatureName_type&,
                                           ::std::unique_ptr< DeterminationMode_type >);

      ExtrudedCrossSectionFeatureItemType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ExtrudedCrossSectionFeatureItemType (const ExtrudedCrossSectionFeatureItemType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionFeatureItemType&
      operator= (const ExtrudedCrossSectionFeatureItemType& x);

      virtual 
      ~ExtrudedCrossSectionFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_type&
      Length () const;

      Length_type&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionFeatureDefinitionType ();

      ExtrudedCrossSectionFeatureDefinitionType (const id_type&,
                                                 const InternalExternal_type&,
                                                 const Length_type&);

      ExtrudedCrossSectionFeatureDefinitionType (const id_type&,
                                                 const InternalExternal_type&,
                                                 ::std::unique_ptr< Length_type >);

      ExtrudedCrossSectionFeatureDefinitionType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      ExtrudedCrossSectionFeatureDefinitionType (const ExtrudedCrossSectionFeatureDefinitionType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionFeatureDefinitionType&
      operator= (const ExtrudedCrossSectionFeatureDefinitionType& x);

      virtual 
      ~ExtrudedCrossSectionFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Length_type > Length_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Direction
      //
      typedef ::xsd::qif30::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // CrossSectionReferenceFeatureId
      //
      typedef ::xsd::qif30::ArrayReferenceFullType CrossSectionReferenceFeatureId_type;
      typedef ::xsd::cxx::tree::traits< CrossSectionReferenceFeatureId_type, wchar_t > CrossSectionReferenceFeatureId_traits;

      const CrossSectionReferenceFeatureId_type&
      CrossSectionReferenceFeatureId () const;

      CrossSectionReferenceFeatureId_type&
      CrossSectionReferenceFeatureId ();

      void
      CrossSectionReferenceFeatureId (const CrossSectionReferenceFeatureId_type& x);

      void
      CrossSectionReferenceFeatureId (::std::unique_ptr< CrossSectionReferenceFeatureId_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ExtrudedCrossSectionConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionFeatureNominalType ();

      ExtrudedCrossSectionFeatureNominalType (const id_type&,
                                              const FeatureDefinitionId_type&,
                                              const Direction_type&,
                                              const CrossSectionReferenceFeatureId_type&);

      ExtrudedCrossSectionFeatureNominalType (const id_type&,
                                              ::std::unique_ptr< FeatureDefinitionId_type >,
                                              ::std::unique_ptr< Direction_type >,
                                              ::std::unique_ptr< CrossSectionReferenceFeatureId_type >);

      ExtrudedCrossSectionFeatureNominalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ExtrudedCrossSectionFeatureNominalType (const ExtrudedCrossSectionFeatureNominalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionFeatureNominalType&
      operator= (const ExtrudedCrossSectionFeatureNominalType& x);

      virtual 
      ~ExtrudedCrossSectionFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Direction_type > Direction_;
      ::xsd::cxx::tree::one< CrossSectionReferenceFeatureId_type > CrossSectionReferenceFeatureId_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ExtrudedCrossSectionFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Direction
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::optional< Direction_type > Direction_optional;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_optional&
      Direction () const;

      Direction_optional&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (const Direction_optional& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionFeatureMeasurementType ();

      ExtrudedCrossSectionFeatureMeasurementType (const id_type&);

      ExtrudedCrossSectionFeatureMeasurementType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      ExtrudedCrossSectionFeatureMeasurementType (const ExtrudedCrossSectionFeatureMeasurementType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionFeatureMeasurementType&
      operator= (const ExtrudedCrossSectionFeatureMeasurementType& x);

      virtual 
      ~ExtrudedCrossSectionFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Direction_optional Direction_;
      Length_optional Length_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL LineConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::LineBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::LineRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Midline
      //
      typedef ::xsd::qif30::LineMidlineType Midline_type;
      typedef ::xsd::cxx::tree::optional< Midline_type > Midline_optional;
      typedef ::xsd::cxx::tree::traits< Midline_type, wchar_t > Midline_traits;

      const Midline_optional&
      Midline () const;

      Midline_optional&
      Midline ();

      void
      Midline (const Midline_type& x);

      void
      Midline (const Midline_optional& x);

      void
      Midline (::std::unique_ptr< Midline_type > p);

      // Intersection
      //
      typedef ::xsd::qif30::LineIntersectionType Intersection_type;
      typedef ::xsd::cxx::tree::optional< Intersection_type > Intersection_optional;
      typedef ::xsd::cxx::tree::traits< Intersection_type, wchar_t > Intersection_traits;

      const Intersection_optional&
      Intersection () const;

      Intersection_optional&
      Intersection ();

      void
      Intersection (const Intersection_type& x);

      void
      Intersection (const Intersection_optional& x);

      void
      Intersection (::std::unique_ptr< Intersection_type > p);

      // Projection
      //
      typedef ::xsd::qif30::LineProjectionType Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      void
      Projection (::std::unique_ptr< Projection_type > p);

      // Perpendicular
      //
      typedef ::xsd::qif30::LinePerpendicularType Perpendicular_type;
      typedef ::xsd::cxx::tree::optional< Perpendicular_type > Perpendicular_optional;
      typedef ::xsd::cxx::tree::traits< Perpendicular_type, wchar_t > Perpendicular_traits;

      const Perpendicular_optional&
      Perpendicular () const;

      Perpendicular_optional&
      Perpendicular ();

      void
      Perpendicular (const Perpendicular_type& x);

      void
      Perpendicular (const Perpendicular_optional& x);

      void
      Perpendicular (::std::unique_ptr< Perpendicular_type > p);

      // Parallel
      //
      typedef ::xsd::qif30::LineParallelType Parallel_type;
      typedef ::xsd::cxx::tree::optional< Parallel_type > Parallel_optional;
      typedef ::xsd::cxx::tree::traits< Parallel_type, wchar_t > Parallel_traits;

      const Parallel_optional&
      Parallel () const;

      Parallel_optional&
      Parallel ();

      void
      Parallel (const Parallel_type& x);

      void
      Parallel (const Parallel_optional& x);

      void
      Parallel (::std::unique_ptr< Parallel_type > p);

      // Copy
      //
      typedef ::xsd::qif30::LineCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::LineCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // TangentThrough
      //
      typedef ::xsd::qif30::LineTangentThroughType TangentThrough_type;
      typedef ::xsd::cxx::tree::optional< TangentThrough_type > TangentThrough_optional;
      typedef ::xsd::cxx::tree::traits< TangentThrough_type, wchar_t > TangentThrough_traits;

      const TangentThrough_optional&
      TangentThrough () const;

      TangentThrough_optional&
      TangentThrough ();

      void
      TangentThrough (const TangentThrough_type& x);

      void
      TangentThrough (const TangentThrough_optional& x);

      void
      TangentThrough (::std::unique_ptr< TangentThrough_type > p);

      // Transform
      //
      typedef ::xsd::qif30::LineTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Extract
      //
      typedef ::xsd::qif30::LineExtractType Extract_type;
      typedef ::xsd::cxx::tree::optional< Extract_type > Extract_optional;
      typedef ::xsd::cxx::tree::traits< Extract_type, wchar_t > Extract_traits;

      const Extract_optional&
      Extract () const;

      Extract_optional&
      Extract ();

      void
      Extract (const Extract_type& x);

      void
      Extract (const Extract_optional& x);

      void
      Extract (::std::unique_ptr< Extract_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::LineFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      LineConstructionMethodType ();

      LineConstructionMethodType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      LineConstructionMethodType (const LineConstructionMethodType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual LineConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineConstructionMethodType&
      operator= (const LineConstructionMethodType& x);

      virtual 
      ~LineConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Midline_optional Midline_;
      Intersection_optional Intersection_;
      Projection_optional Projection_;
      Perpendicular_optional Perpendicular_;
      Parallel_optional Parallel_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      TangentThrough_optional TangentThrough_;
      Transform_optional Transform_;
      Extract_optional Extract_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL LineBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      LineBestFitType ();

      LineBestFitType (const n_type&);

      LineBestFitType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LineBestFitType (const LineBestFitType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LineBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineBestFitType&
      operator= (const LineBestFitType& x);

      virtual 
      ~LineBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL LineRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      LineRecompType ();

      LineRecompType (const BaseFeaturePointList_type&);

      LineRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      LineRecompType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      LineRecompType (const LineRecompType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual LineRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineRecompType&
      operator= (const LineRecompType& x);

      virtual 
      ~LineRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL LineMidlineType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseLine
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseLine_type;
      typedef ::xsd::cxx::tree::sequence< BaseLine_type > BaseLine_sequence;
      typedef xsd::cxx::tree::sequence< BaseLine_type >::iterator BaseLine_iterator;
      typedef xsd::cxx::tree::sequence< BaseLine_type >::const_iterator BaseLine_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseLine_type, wchar_t > BaseLine_traits;

      const BaseLine_sequence&
      BaseLine () const;

      BaseLine_sequence&
      BaseLine ();

      void
      BaseLine (const BaseLine_sequence& s);

      // Constructors.
      //
      LineMidlineType ();

      LineMidlineType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LineMidlineType (const LineMidlineType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LineMidlineType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineMidlineType&
      operator= (const LineMidlineType& x);

      virtual 
      ~LineMidlineType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseLine_sequence BaseLine_;
    };

    class QIF30_SYMBOL_DECL LineIntersectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // IntersectionFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType IntersectionFeature_type;
      typedef ::xsd::cxx::tree::sequence< IntersectionFeature_type > IntersectionFeature_sequence;
      typedef xsd::cxx::tree::sequence< IntersectionFeature_type >::iterator IntersectionFeature_iterator;
      typedef xsd::cxx::tree::sequence< IntersectionFeature_type >::const_iterator IntersectionFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< IntersectionFeature_type, wchar_t > IntersectionFeature_traits;

      const IntersectionFeature_sequence&
      IntersectionFeature () const;

      IntersectionFeature_sequence&
      IntersectionFeature ();

      void
      IntersectionFeature (const IntersectionFeature_sequence& s);

      // Constructors.
      //
      LineIntersectionType ();

      LineIntersectionType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      LineIntersectionType (const LineIntersectionType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual LineIntersectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineIntersectionType&
      operator= (const LineIntersectionType& x);

      virtual 
      ~LineIntersectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IntersectionFeature_sequence IntersectionFeature_;
    };

    class QIF30_SYMBOL_DECL LineProjectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ProjectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionPlane_type;
      typedef ::xsd::cxx::tree::traits< ProjectionPlane_type, wchar_t > ProjectionPlane_traits;

      const ProjectionPlane_type&
      ProjectionPlane () const;

      ProjectionPlane_type&
      ProjectionPlane ();

      void
      ProjectionPlane (const ProjectionPlane_type& x);

      void
      ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > p);

      // ProjectionLine
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionLine_type;
      typedef ::xsd::cxx::tree::traits< ProjectionLine_type, wchar_t > ProjectionLine_traits;

      const ProjectionLine_type&
      ProjectionLine () const;

      ProjectionLine_type&
      ProjectionLine ();

      void
      ProjectionLine (const ProjectionLine_type& x);

      void
      ProjectionLine (::std::unique_ptr< ProjectionLine_type > p);

      // Constructors.
      //
      LineProjectionType ();

      LineProjectionType (const ProjectionPlane_type&,
                          const ProjectionLine_type&);

      LineProjectionType (::std::unique_ptr< ProjectionPlane_type >,
                          ::std::unique_ptr< ProjectionLine_type >);

      LineProjectionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      LineProjectionType (const LineProjectionType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual LineProjectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineProjectionType&
      operator= (const LineProjectionType& x);

      virtual 
      ~LineProjectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProjectionPlane_type > ProjectionPlane_;
      ::xsd::cxx::tree::one< ProjectionLine_type > ProjectionLine_;
    };

    class QIF30_SYMBOL_DECL LinePerpendicularType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // PerpendicularFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PerpendicularFeature_type;
      typedef ::xsd::cxx::tree::traits< PerpendicularFeature_type, wchar_t > PerpendicularFeature_traits;

      const PerpendicularFeature_type&
      PerpendicularFeature () const;

      PerpendicularFeature_type&
      PerpendicularFeature ();

      void
      PerpendicularFeature (const PerpendicularFeature_type& x);

      void
      PerpendicularFeature (::std::unique_ptr< PerpendicularFeature_type > p);

      // PointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PointFeature_type;
      typedef ::xsd::cxx::tree::traits< PointFeature_type, wchar_t > PointFeature_traits;

      const PointFeature_type&
      PointFeature () const;

      PointFeature_type&
      PointFeature ();

      void
      PointFeature (const PointFeature_type& x);

      void
      PointFeature (::std::unique_ptr< PointFeature_type > p);

      // Constructors.
      //
      LinePerpendicularType ();

      LinePerpendicularType (const PerpendicularFeature_type&,
                             const PointFeature_type&);

      LinePerpendicularType (::std::unique_ptr< PerpendicularFeature_type >,
                             ::std::unique_ptr< PointFeature_type >);

      LinePerpendicularType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      LinePerpendicularType (const LinePerpendicularType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual LinePerpendicularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinePerpendicularType&
      operator= (const LinePerpendicularType& x);

      virtual 
      ~LinePerpendicularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PerpendicularFeature_type > PerpendicularFeature_;
      ::xsd::cxx::tree::one< PointFeature_type > PointFeature_;
    };

    class QIF30_SYMBOL_DECL LineParallelType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ParallelFeature
      //
      typedef ::xsd::qif30::BaseFeatureType ParallelFeature_type;
      typedef ::xsd::cxx::tree::traits< ParallelFeature_type, wchar_t > ParallelFeature_traits;

      const ParallelFeature_type&
      ParallelFeature () const;

      ParallelFeature_type&
      ParallelFeature ();

      void
      ParallelFeature (const ParallelFeature_type& x);

      void
      ParallelFeature (::std::unique_ptr< ParallelFeature_type > p);

      // PointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PointFeature_type;
      typedef ::xsd::cxx::tree::traits< PointFeature_type, wchar_t > PointFeature_traits;

      const PointFeature_type&
      PointFeature () const;

      PointFeature_type&
      PointFeature ();

      void
      PointFeature (const PointFeature_type& x);

      void
      PointFeature (::std::unique_ptr< PointFeature_type > p);

      // Constructors.
      //
      LineParallelType ();

      LineParallelType (const ParallelFeature_type&,
                        const PointFeature_type&);

      LineParallelType (::std::unique_ptr< ParallelFeature_type >,
                        ::std::unique_ptr< PointFeature_type >);

      LineParallelType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      LineParallelType (const LineParallelType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual LineParallelType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineParallelType&
      operator= (const LineParallelType& x);

      virtual 
      ~LineParallelType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ParallelFeature_type > ParallelFeature_;
      ::xsd::cxx::tree::one< PointFeature_type > PointFeature_;
    };

    class QIF30_SYMBOL_DECL LineCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseLine
      //
      typedef ::xsd::qif30::BaseFeatureType BaseLine_type;
      typedef ::xsd::cxx::tree::traits< BaseLine_type, wchar_t > BaseLine_traits;

      const BaseLine_type&
      BaseLine () const;

      BaseLine_type&
      BaseLine ();

      void
      BaseLine (const BaseLine_type& x);

      void
      BaseLine (::std::unique_ptr< BaseLine_type > p);

      // Constructors.
      //
      LineCopyType ();

      LineCopyType (const BaseLine_type&);

      LineCopyType (::std::unique_ptr< BaseLine_type >);

      LineCopyType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      LineCopyType (const LineCopyType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual LineCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineCopyType&
      operator= (const LineCopyType& x);

      virtual 
      ~LineCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseLine_type > BaseLine_;
    };

    class QIF30_SYMBOL_DECL LineCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      LineCastType ();

      LineCastType (const BaseFeature_type&);

      LineCastType (::std::unique_ptr< BaseFeature_type >);

      LineCastType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      LineCastType (const LineCastType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual LineCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineCastType&
      operator= (const LineCastType& x);

      virtual 
      ~LineCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL LineTangentThroughType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // TangentFeature
      //
      typedef ::xsd::qif30::BaseFeatureType TangentFeature_type;
      typedef ::xsd::cxx::tree::traits< TangentFeature_type, wchar_t > TangentFeature_traits;

      const TangentFeature_type&
      TangentFeature () const;

      TangentFeature_type&
      TangentFeature ();

      void
      TangentFeature (const TangentFeature_type& x);

      void
      TangentFeature (::std::unique_ptr< TangentFeature_type > p);

      // PointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PointFeature_type;
      typedef ::xsd::cxx::tree::traits< PointFeature_type, wchar_t > PointFeature_traits;

      const PointFeature_type&
      PointFeature () const;

      PointFeature_type&
      PointFeature ();

      void
      PointFeature (const PointFeature_type& x);

      void
      PointFeature (::std::unique_ptr< PointFeature_type > p);

      // Constructors.
      //
      LineTangentThroughType ();

      LineTangentThroughType (const TangentFeature_type&,
                              const PointFeature_type&);

      LineTangentThroughType (::std::unique_ptr< TangentFeature_type >,
                              ::std::unique_ptr< PointFeature_type >);

      LineTangentThroughType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LineTangentThroughType (const LineTangentThroughType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual LineTangentThroughType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineTangentThroughType&
      operator= (const LineTangentThroughType& x);

      virtual 
      ~LineTangentThroughType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TangentFeature_type > TangentFeature_;
      ::xsd::cxx::tree::one< PointFeature_type > PointFeature_;
    };

    class QIF30_SYMBOL_DECL LineTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseLine
      //
      typedef ::xsd::qif30::BaseFeatureType BaseLine_type;
      typedef ::xsd::cxx::tree::traits< BaseLine_type, wchar_t > BaseLine_traits;

      const BaseLine_type&
      BaseLine () const;

      BaseLine_type&
      BaseLine ();

      void
      BaseLine (const BaseLine_type& x);

      void
      BaseLine (::std::unique_ptr< BaseLine_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      LineTransformType ();

      LineTransformType (const BaseLine_type&,
                         const Transformation_type&);

      LineTransformType (::std::unique_ptr< BaseLine_type >,
                         ::std::unique_ptr< Transformation_type >);

      LineTransformType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      LineTransformType (const LineTransformType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual LineTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineTransformType&
      operator= (const LineTransformType& x);

      virtual 
      ~LineTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseLine_type > BaseLine_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL LineFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Constructors.
      //
      LineFromScanType ();

      LineFromScanType (const SurfaceFeature_type&,
                        const SearchRadius_type&);

      LineFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                        ::std::unique_ptr< SearchRadius_type >);

      LineFromScanType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      LineFromScanType (const LineFromScanType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual LineFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineFromScanType&
      operator= (const LineFromScanType& x);

      virtual 
      ~LineFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
    };

    class QIF30_SYMBOL_DECL LineExtractType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // CurveFeature
      //
      typedef ::xsd::qif30::BaseFeatureType CurveFeature_type;
      typedef ::xsd::cxx::tree::traits< CurveFeature_type, wchar_t > CurveFeature_traits;

      const CurveFeature_type&
      CurveFeature () const;

      CurveFeature_type&
      CurveFeature ();

      void
      CurveFeature (const CurveFeature_type& x);

      void
      CurveFeature (::std::unique_ptr< CurveFeature_type > p);

      // Constructors.
      //
      LineExtractType ();

      LineExtractType (const CurveFeature_type&);

      LineExtractType (::std::unique_ptr< CurveFeature_type >);

      LineExtractType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LineExtractType (const LineExtractType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LineExtractType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineExtractType&
      operator= (const LineExtractType& x);

      virtual 
      ~LineExtractType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CurveFeature_type > CurveFeature_;
    };

    class QIF30_SYMBOL_DECL LineCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::LineConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      LineCheckedType ();

      LineCheckedType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LineCheckedType (const LineCheckedType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LineCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineCheckedType&
      operator= (const LineCheckedType& x);

      virtual 
      ~LineCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL LineCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::LineCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      LineCheckedFeatureType ();

      LineCheckedFeatureType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LineCheckedFeatureType (const LineCheckedFeatureType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual LineCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineCheckedFeatureType&
      operator= (const LineCheckedFeatureType& x);

      virtual 
      ~LineCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL LineMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::LineCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      LineMeasurementDeterminationType ();

      LineMeasurementDeterminationType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      LineMeasurementDeterminationType (const LineMeasurementDeterminationType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual LineMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineMeasurementDeterminationType&
      operator= (const LineMeasurementDeterminationType& x);

      virtual 
      ~LineMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL LineFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::LineMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      LineFeatureItemType ();

      LineFeatureItemType (const id_type&,
                           const FeatureNominalId_type&,
                           const FeatureName_type&,
                           const DeterminationMode_type&);

      LineFeatureItemType (const id_type&,
                           ::std::unique_ptr< FeatureNominalId_type >,
                           const FeatureName_type&,
                           ::std::unique_ptr< DeterminationMode_type >);

      LineFeatureItemType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      LineFeatureItemType (const LineFeatureItemType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual LineFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineFeatureItemType&
      operator= (const LineFeatureItemType& x);

      virtual 
      ~LineFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL LineFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      LineFeatureDefinitionType ();

      LineFeatureDefinitionType (const id_type&);

      LineFeatureDefinitionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      LineFeatureDefinitionType (const LineFeatureDefinitionType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual LineFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LineFeatureDefinitionType&
      operator= (const LineFeatureDefinitionType&) = default;
#endif

      virtual 
      ~LineFeatureDefinitionType ();
    };

    class QIF30_SYMBOL_DECL LineFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Direction
      //
      typedef ::xsd::qif30::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::LineConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      LineFeatureNominalType ();

      LineFeatureNominalType (const id_type&,
                              const FeatureDefinitionId_type&,
                              const Location_type&,
                              const Direction_type&);

      LineFeatureNominalType (const id_type&,
                              ::std::unique_ptr< FeatureDefinitionId_type >,
                              ::std::unique_ptr< Location_type >,
                              ::std::unique_ptr< Direction_type >);

      LineFeatureNominalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      LineFeatureNominalType (const LineFeatureNominalType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual LineFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineFeatureNominalType&
      operator= (const LineFeatureNominalType& x);

      virtual 
      ~LineFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< Direction_type > Direction_;
      Length_optional Length_;
      Normal_optional Normal_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL LineFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Direction
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::optional< Direction_type > Direction_optional;
      typedef ::xsd::cxx::tree::traits< Direction_type, wchar_t > Direction_traits;

      const Direction_optional&
      Direction () const;

      Direction_optional&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (const Direction_optional& x);

      void
      Direction (::std::unique_ptr< Direction_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      LineFeatureMeasurementType ();

      LineFeatureMeasurementType (const id_type&);

      LineFeatureMeasurementType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      LineFeatureMeasurementType (const LineFeatureMeasurementType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual LineFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineFeatureMeasurementType&
      operator= (const LineFeatureMeasurementType& x);

      virtual 
      ~LineFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      Direction_optional Direction_;
      Length_optional Length_;
      Normal_optional Normal_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::OppositeParallelLinesBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::OppositeParallelLinesRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Intersection
      //
      typedef ::xsd::qif30::OppositeParallelLinesIntersectionType Intersection_type;
      typedef ::xsd::cxx::tree::optional< Intersection_type > Intersection_optional;
      typedef ::xsd::cxx::tree::traits< Intersection_type, wchar_t > Intersection_traits;

      const Intersection_optional&
      Intersection () const;

      Intersection_optional&
      Intersection ();

      void
      Intersection (const Intersection_type& x);

      void
      Intersection (const Intersection_optional& x);

      void
      Intersection (::std::unique_ptr< Intersection_type > p);

      // Projection
      //
      typedef ::xsd::qif30::OppositeParallelLinesProjectionType Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      void
      Projection (::std::unique_ptr< Projection_type > p);

      // Copy
      //
      typedef ::xsd::qif30::OppositeParallelLinesCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::OppositeParallelLinesCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::OppositeParallelLinesTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::OppositeParallelLinesFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      OppositeParallelLinesConstructionMethodType ();

      OppositeParallelLinesConstructionMethodType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      OppositeParallelLinesConstructionMethodType (const OppositeParallelLinesConstructionMethodType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesConstructionMethodType&
      operator= (const OppositeParallelLinesConstructionMethodType& x);

      virtual 
      ~OppositeParallelLinesConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Intersection_optional Intersection_;
      Projection_optional Projection_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      OppositeParallelLinesBestFitType ();

      OppositeParallelLinesBestFitType (const n_type&);

      OppositeParallelLinesBestFitType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OppositeParallelLinesBestFitType (const OppositeParallelLinesBestFitType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesBestFitType&
      operator= (const OppositeParallelLinesBestFitType& x);

      virtual 
      ~OppositeParallelLinesBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      OppositeParallelLinesRecompType ();

      OppositeParallelLinesRecompType (const BaseFeaturePointList_type&);

      OppositeParallelLinesRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      OppositeParallelLinesRecompType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      OppositeParallelLinesRecompType (const OppositeParallelLinesRecompType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesRecompType&
      operator= (const OppositeParallelLinesRecompType& x);

      virtual 
      ~OppositeParallelLinesRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesIntersectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // IntersectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType IntersectionPlane_type;
      typedef ::xsd::cxx::tree::traits< IntersectionPlane_type, wchar_t > IntersectionPlane_traits;

      const IntersectionPlane_type&
      IntersectionPlane () const;

      IntersectionPlane_type&
      IntersectionPlane ();

      void
      IntersectionPlane (const IntersectionPlane_type& x);

      void
      IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > p);

      // IntersectionFeature
      //
      typedef ::xsd::qif30::BaseFeatureType IntersectionFeature_type;
      typedef ::xsd::cxx::tree::traits< IntersectionFeature_type, wchar_t > IntersectionFeature_traits;

      const IntersectionFeature_type&
      IntersectionFeature () const;

      IntersectionFeature_type&
      IntersectionFeature ();

      void
      IntersectionFeature (const IntersectionFeature_type& x);

      void
      IntersectionFeature (::std::unique_ptr< IntersectionFeature_type > p);

      // Constructors.
      //
      OppositeParallelLinesIntersectionType ();

      OppositeParallelLinesIntersectionType (const IntersectionPlane_type&,
                                             const IntersectionFeature_type&);

      OppositeParallelLinesIntersectionType (::std::unique_ptr< IntersectionPlane_type >,
                                             ::std::unique_ptr< IntersectionFeature_type >);

      OppositeParallelLinesIntersectionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OppositeParallelLinesIntersectionType (const OppositeParallelLinesIntersectionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesIntersectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesIntersectionType&
      operator= (const OppositeParallelLinesIntersectionType& x);

      virtual 
      ~OppositeParallelLinesIntersectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< IntersectionPlane_type > IntersectionPlane_;
      ::xsd::cxx::tree::one< IntersectionFeature_type > IntersectionFeature_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesProjectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ProjectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionPlane_type;
      typedef ::xsd::cxx::tree::traits< ProjectionPlane_type, wchar_t > ProjectionPlane_traits;

      const ProjectionPlane_type&
      ProjectionPlane () const;

      ProjectionPlane_type&
      ProjectionPlane ();

      void
      ProjectionPlane (const ProjectionPlane_type& x);

      void
      ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > p);

      // ProjectionOppositeParallelLines
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionOppositeParallelLines_type;
      typedef ::xsd::cxx::tree::traits< ProjectionOppositeParallelLines_type, wchar_t > ProjectionOppositeParallelLines_traits;

      const ProjectionOppositeParallelLines_type&
      ProjectionOppositeParallelLines () const;

      ProjectionOppositeParallelLines_type&
      ProjectionOppositeParallelLines ();

      void
      ProjectionOppositeParallelLines (const ProjectionOppositeParallelLines_type& x);

      void
      ProjectionOppositeParallelLines (::std::unique_ptr< ProjectionOppositeParallelLines_type > p);

      // Constructors.
      //
      OppositeParallelLinesProjectionType ();

      OppositeParallelLinesProjectionType (const ProjectionPlane_type&,
                                           const ProjectionOppositeParallelLines_type&);

      OppositeParallelLinesProjectionType (::std::unique_ptr< ProjectionPlane_type >,
                                           ::std::unique_ptr< ProjectionOppositeParallelLines_type >);

      OppositeParallelLinesProjectionType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      OppositeParallelLinesProjectionType (const OppositeParallelLinesProjectionType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesProjectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesProjectionType&
      operator= (const OppositeParallelLinesProjectionType& x);

      virtual 
      ~OppositeParallelLinesProjectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProjectionPlane_type > ProjectionPlane_;
      ::xsd::cxx::tree::one< ProjectionOppositeParallelLines_type > ProjectionOppositeParallelLines_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOppositeParallelLines
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOppositeParallelLines_type;
      typedef ::xsd::cxx::tree::traits< BaseOppositeParallelLines_type, wchar_t > BaseOppositeParallelLines_traits;

      const BaseOppositeParallelLines_type&
      BaseOppositeParallelLines () const;

      BaseOppositeParallelLines_type&
      BaseOppositeParallelLines ();

      void
      BaseOppositeParallelLines (const BaseOppositeParallelLines_type& x);

      void
      BaseOppositeParallelLines (::std::unique_ptr< BaseOppositeParallelLines_type > p);

      // Constructors.
      //
      OppositeParallelLinesCopyType ();

      OppositeParallelLinesCopyType (const BaseOppositeParallelLines_type&);

      OppositeParallelLinesCopyType (::std::unique_ptr< BaseOppositeParallelLines_type >);

      OppositeParallelLinesCopyType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      OppositeParallelLinesCopyType (const OppositeParallelLinesCopyType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesCopyType&
      operator= (const OppositeParallelLinesCopyType& x);

      virtual 
      ~OppositeParallelLinesCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOppositeParallelLines_type > BaseOppositeParallelLines_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      OppositeParallelLinesCastType ();

      OppositeParallelLinesCastType (const BaseFeature_type&);

      OppositeParallelLinesCastType (::std::unique_ptr< BaseFeature_type >);

      OppositeParallelLinesCastType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      OppositeParallelLinesCastType (const OppositeParallelLinesCastType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesCastType&
      operator= (const OppositeParallelLinesCastType& x);

      virtual 
      ~OppositeParallelLinesCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOppositeParallelLines
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOppositeParallelLines_type;
      typedef ::xsd::cxx::tree::traits< BaseOppositeParallelLines_type, wchar_t > BaseOppositeParallelLines_traits;

      const BaseOppositeParallelLines_type&
      BaseOppositeParallelLines () const;

      BaseOppositeParallelLines_type&
      BaseOppositeParallelLines ();

      void
      BaseOppositeParallelLines (const BaseOppositeParallelLines_type& x);

      void
      BaseOppositeParallelLines (::std::unique_ptr< BaseOppositeParallelLines_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      OppositeParallelLinesTransformType ();

      OppositeParallelLinesTransformType (const BaseOppositeParallelLines_type&,
                                          const Transformation_type&);

      OppositeParallelLinesTransformType (::std::unique_ptr< BaseOppositeParallelLines_type >,
                                          ::std::unique_ptr< Transformation_type >);

      OppositeParallelLinesTransformType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OppositeParallelLinesTransformType (const OppositeParallelLinesTransformType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesTransformType&
      operator= (const OppositeParallelLinesTransformType& x);

      virtual 
      ~OppositeParallelLinesTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOppositeParallelLines_type > BaseOppositeParallelLines_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_type&
      Depth () const;

      Depth_type&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Constructors.
      //
      OppositeParallelLinesFromScanType ();

      OppositeParallelLinesFromScanType (const SurfaceFeature_type&,
                                         const SearchRadius_type&,
                                         const Depth_type&);

      OppositeParallelLinesFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                                         ::std::unique_ptr< SearchRadius_type >,
                                         ::std::unique_ptr< Depth_type >);

      OppositeParallelLinesFromScanType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      OppositeParallelLinesFromScanType (const OppositeParallelLinesFromScanType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesFromScanType&
      operator= (const OppositeParallelLinesFromScanType& x);

      virtual 
      ~OppositeParallelLinesFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      ::xsd::cxx::tree::one< Depth_type > Depth_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OppositeParallelLinesConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OppositeParallelLinesCheckedType ();

      OppositeParallelLinesCheckedType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OppositeParallelLinesCheckedType (const OppositeParallelLinesCheckedType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesCheckedType&
      operator= (const OppositeParallelLinesCheckedType& x);

      virtual 
      ~OppositeParallelLinesCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::OppositeParallelLinesCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      OppositeParallelLinesCheckedFeatureType ();

      OppositeParallelLinesCheckedFeatureType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      OppositeParallelLinesCheckedFeatureType (const OppositeParallelLinesCheckedFeatureType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesCheckedFeatureType&
      operator= (const OppositeParallelLinesCheckedFeatureType& x);

      virtual 
      ~OppositeParallelLinesCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::OppositeParallelLinesCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      OppositeParallelLinesMeasurementDeterminationType ();

      OppositeParallelLinesMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      OppositeParallelLinesMeasurementDeterminationType (const OppositeParallelLinesMeasurementDeterminationType& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesMeasurementDeterminationType&
      operator= (const OppositeParallelLinesMeasurementDeterminationType& x);

      virtual 
      ~OppositeParallelLinesMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::OppositeParallelLinesMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      OppositeParallelLinesFeatureItemType ();

      OppositeParallelLinesFeatureItemType (const id_type&,
                                            const FeatureNominalId_type&,
                                            const FeatureName_type&,
                                            const DeterminationMode_type&);

      OppositeParallelLinesFeatureItemType (const id_type&,
                                            ::std::unique_ptr< FeatureNominalId_type >,
                                            const FeatureName_type&,
                                            ::std::unique_ptr< DeterminationMode_type >);

      OppositeParallelLinesFeatureItemType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      OppositeParallelLinesFeatureItemType (const OppositeParallelLinesFeatureItemType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesFeatureItemType&
      operator= (const OppositeParallelLinesFeatureItemType& x);

      virtual 
      ~OppositeParallelLinesFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Width
      //
      typedef ::xsd::qif30::LinearValueType Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // EndType
      //
      typedef ::xsd::qif30::SlotEndType EndType_type;
      typedef ::xsd::cxx::tree::traits< EndType_type, wchar_t > EndType_traits;

      const EndType_type&
      EndType () const;

      EndType_type&
      EndType ();

      void
      EndType (const EndType_type& x);

      void
      EndType (::std::unique_ptr< EndType_type > p);

      // SingleOpenEnd
      //
      typedef ::xml_schema::boolean SingleOpenEnd_type;
      typedef ::xsd::cxx::tree::optional< SingleOpenEnd_type > SingleOpenEnd_optional;
      typedef ::xsd::cxx::tree::traits< SingleOpenEnd_type, wchar_t > SingleOpenEnd_traits;

      const SingleOpenEnd_optional&
      SingleOpenEnd () const;

      SingleOpenEnd_optional&
      SingleOpenEnd ();

      void
      SingleOpenEnd (const SingleOpenEnd_type& x);

      void
      SingleOpenEnd (const SingleOpenEnd_optional& x);

      // EndRadius1
      //
      typedef ::xsd::qif30::EndRadiusType EndRadius1_type;
      typedef ::xsd::cxx::tree::optional< EndRadius1_type > EndRadius1_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius1_type, wchar_t > EndRadius1_traits;

      const EndRadius1_optional&
      EndRadius1 () const;

      EndRadius1_optional&
      EndRadius1 ();

      void
      EndRadius1 (const EndRadius1_type& x);

      void
      EndRadius1 (const EndRadius1_optional& x);

      void
      EndRadius1 (::std::unique_ptr< EndRadius1_type > p);

      // EndRadius2
      //
      typedef ::xsd::qif30::EndRadiusType EndRadius2_type;
      typedef ::xsd::cxx::tree::optional< EndRadius2_type > EndRadius2_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius2_type, wchar_t > EndRadius2_traits;

      const EndRadius2_optional&
      EndRadius2 () const;

      EndRadius2_optional&
      EndRadius2 ();

      void
      EndRadius2 (const EndRadius2_type& x);

      void
      EndRadius2 (const EndRadius2_optional& x);

      void
      EndRadius2 (::std::unique_ptr< EndRadius2_type > p);

      // Constructors.
      //
      OppositeParallelLinesFeatureDefinitionType ();

      OppositeParallelLinesFeatureDefinitionType (const id_type&,
                                                  const InternalExternal_type&,
                                                  const Width_type&,
                                                  const EndType_type&);

      OppositeParallelLinesFeatureDefinitionType (const id_type&,
                                                  const InternalExternal_type&,
                                                  ::std::unique_ptr< Width_type >,
                                                  ::std::unique_ptr< EndType_type >);

      OppositeParallelLinesFeatureDefinitionType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      OppositeParallelLinesFeatureDefinitionType (const OppositeParallelLinesFeatureDefinitionType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesFeatureDefinitionType&
      operator= (const OppositeParallelLinesFeatureDefinitionType& x);

      virtual 
      ~OppositeParallelLinesFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Width_type > Width_;
      Length_optional Length_;
      ::xsd::cxx::tree::one< EndType_type > EndType_;
      SingleOpenEnd_optional SingleOpenEnd_;
      EndRadius1_optional EndRadius1_;
      EndRadius2_optional EndRadius2_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // CenterLine
      //
      typedef ::xsd::qif30::PointAndVectorType CenterLine_type;
      typedef ::xsd::cxx::tree::traits< CenterLine_type, wchar_t > CenterLine_traits;

      const CenterLine_type&
      CenterLine () const;

      CenterLine_type&
      CenterLine ();

      void
      CenterLine (const CenterLine_type& x);

      void
      CenterLine (::std::unique_ptr< CenterLine_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OppositeParallelLinesConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OppositeParallelLinesFeatureNominalType ();

      OppositeParallelLinesFeatureNominalType (const id_type&,
                                               const FeatureDefinitionId_type&,
                                               const CenterLine_type&,
                                               const Normal_type&);

      OppositeParallelLinesFeatureNominalType (const id_type&,
                                               ::std::unique_ptr< FeatureDefinitionId_type >,
                                               ::std::unique_ptr< CenterLine_type >,
                                               ::std::unique_ptr< Normal_type >);

      OppositeParallelLinesFeatureNominalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      OppositeParallelLinesFeatureNominalType (const OppositeParallelLinesFeatureNominalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesFeatureNominalType&
      operator= (const OppositeParallelLinesFeatureNominalType& x);

      virtual 
      ~OppositeParallelLinesFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CenterLine_type > CenterLine_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelLinesFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // CenterLine
      //
      typedef ::xsd::qif30::MeasuredPointAndVectorType CenterLine_type;
      typedef ::xsd::cxx::tree::optional< CenterLine_type > CenterLine_optional;
      typedef ::xsd::cxx::tree::traits< CenterLine_type, wchar_t > CenterLine_traits;

      const CenterLine_optional&
      CenterLine () const;

      CenterLine_optional&
      CenterLine ();

      void
      CenterLine (const CenterLine_type& x);

      void
      CenterLine (const CenterLine_optional& x);

      void
      CenterLine (::std::unique_ptr< CenterLine_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Width
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Width_type;
      typedef ::xsd::cxx::tree::optional< Width_type > Width_optional;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_optional&
      Width () const;

      Width_optional&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (const Width_optional& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // WidthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType WidthMin_type;
      typedef ::xsd::cxx::tree::optional< WidthMin_type > WidthMin_optional;
      typedef ::xsd::cxx::tree::traits< WidthMin_type, wchar_t > WidthMin_traits;

      const WidthMin_optional&
      WidthMin () const;

      WidthMin_optional&
      WidthMin ();

      void
      WidthMin (const WidthMin_type& x);

      void
      WidthMin (const WidthMin_optional& x);

      void
      WidthMin (::std::unique_ptr< WidthMin_type > p);

      // WidthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType WidthMax_type;
      typedef ::xsd::cxx::tree::optional< WidthMax_type > WidthMax_optional;
      typedef ::xsd::cxx::tree::traits< WidthMax_type, wchar_t > WidthMax_traits;

      const WidthMax_optional&
      WidthMax () const;

      WidthMax_optional&
      WidthMax ();

      void
      WidthMax (const WidthMax_type& x);

      void
      WidthMax (const WidthMax_optional& x);

      void
      WidthMax (::std::unique_ptr< WidthMax_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // LengthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMin_type;
      typedef ::xsd::cxx::tree::optional< LengthMin_type > LengthMin_optional;
      typedef ::xsd::cxx::tree::traits< LengthMin_type, wchar_t > LengthMin_traits;

      const LengthMin_optional&
      LengthMin () const;

      LengthMin_optional&
      LengthMin ();

      void
      LengthMin (const LengthMin_type& x);

      void
      LengthMin (const LengthMin_optional& x);

      void
      LengthMin (::std::unique_ptr< LengthMin_type > p);

      // LengthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMax_type;
      typedef ::xsd::cxx::tree::optional< LengthMax_type > LengthMax_optional;
      typedef ::xsd::cxx::tree::traits< LengthMax_type, wchar_t > LengthMax_traits;

      const LengthMax_optional&
      LengthMax () const;

      LengthMax_optional&
      LengthMax ();

      void
      LengthMax (const LengthMax_type& x);

      void
      LengthMax (const LengthMax_optional& x);

      void
      LengthMax (::std::unique_ptr< LengthMax_type > p);

      // EndRadius1
      //
      typedef ::xsd::qif30::MeasuredEndRadiusType EndRadius1_type;
      typedef ::xsd::cxx::tree::optional< EndRadius1_type > EndRadius1_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius1_type, wchar_t > EndRadius1_traits;

      const EndRadius1_optional&
      EndRadius1 () const;

      EndRadius1_optional&
      EndRadius1 ();

      void
      EndRadius1 (const EndRadius1_type& x);

      void
      EndRadius1 (const EndRadius1_optional& x);

      void
      EndRadius1 (::std::unique_ptr< EndRadius1_type > p);

      // EndRadius2
      //
      typedef ::xsd::qif30::MeasuredEndRadiusType EndRadius2_type;
      typedef ::xsd::cxx::tree::optional< EndRadius2_type > EndRadius2_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius2_type, wchar_t > EndRadius2_traits;

      const EndRadius2_optional&
      EndRadius2 () const;

      EndRadius2_optional&
      EndRadius2 ();

      void
      EndRadius2 (const EndRadius2_type& x);

      void
      EndRadius2 (const EndRadius2_optional& x);

      void
      EndRadius2 (::std::unique_ptr< EndRadius2_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      OppositeParallelLinesFeatureMeasurementType ();

      OppositeParallelLinesFeatureMeasurementType (const id_type&);

      OppositeParallelLinesFeatureMeasurementType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      OppositeParallelLinesFeatureMeasurementType (const OppositeParallelLinesFeatureMeasurementType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual OppositeParallelLinesFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelLinesFeatureMeasurementType&
      operator= (const OppositeParallelLinesFeatureMeasurementType& x);

      virtual 
      ~OppositeParallelLinesFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CenterLine_optional CenterLine_;
      Normal_optional Normal_;
      Width_optional Width_;
      WidthMin_optional WidthMin_;
      WidthMax_optional WidthMax_;
      Length_optional Length_;
      LengthMin_optional LengthMin_;
      LengthMax_optional LengthMax_;
      EndRadius1_optional EndRadius1_;
      EndRadius2_optional EndRadius2_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::OppositeAngledLinesBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::OppositeAngledLinesRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Intersection
      //
      typedef ::xsd::qif30::OppositeAngledLinesIntersectionType Intersection_type;
      typedef ::xsd::cxx::tree::optional< Intersection_type > Intersection_optional;
      typedef ::xsd::cxx::tree::traits< Intersection_type, wchar_t > Intersection_traits;

      const Intersection_optional&
      Intersection () const;

      Intersection_optional&
      Intersection ();

      void
      Intersection (const Intersection_type& x);

      void
      Intersection (const Intersection_optional& x);

      void
      Intersection (::std::unique_ptr< Intersection_type > p);

      // Projection
      //
      typedef ::xsd::qif30::OppositeAngledLinesProjectionType Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      void
      Projection (::std::unique_ptr< Projection_type > p);

      // Copy
      //
      typedef ::xsd::qif30::OppositeAngledLinesCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::OppositeAngledLinesCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::OppositeAngledLinesTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::OppositeAngledLinesFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      OppositeAngledLinesConstructionMethodType ();

      OppositeAngledLinesConstructionMethodType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      OppositeAngledLinesConstructionMethodType (const OppositeAngledLinesConstructionMethodType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesConstructionMethodType&
      operator= (const OppositeAngledLinesConstructionMethodType& x);

      virtual 
      ~OppositeAngledLinesConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Intersection_optional Intersection_;
      Projection_optional Projection_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      OppositeAngledLinesBestFitType ();

      OppositeAngledLinesBestFitType (const n_type&);

      OppositeAngledLinesBestFitType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      OppositeAngledLinesBestFitType (const OppositeAngledLinesBestFitType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesBestFitType&
      operator= (const OppositeAngledLinesBestFitType& x);

      virtual 
      ~OppositeAngledLinesBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      OppositeAngledLinesRecompType ();

      OppositeAngledLinesRecompType (const BaseFeaturePointList_type&);

      OppositeAngledLinesRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      OppositeAngledLinesRecompType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      OppositeAngledLinesRecompType (const OppositeAngledLinesRecompType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesRecompType&
      operator= (const OppositeAngledLinesRecompType& x);

      virtual 
      ~OppositeAngledLinesRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesIntersectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // IntersectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType IntersectionPlane_type;
      typedef ::xsd::cxx::tree::traits< IntersectionPlane_type, wchar_t > IntersectionPlane_traits;

      const IntersectionPlane_type&
      IntersectionPlane () const;

      IntersectionPlane_type&
      IntersectionPlane ();

      void
      IntersectionPlane (const IntersectionPlane_type& x);

      void
      IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > p);

      // IntersectionFeature
      //
      typedef ::xsd::qif30::BaseFeatureType IntersectionFeature_type;
      typedef ::xsd::cxx::tree::traits< IntersectionFeature_type, wchar_t > IntersectionFeature_traits;

      const IntersectionFeature_type&
      IntersectionFeature () const;

      IntersectionFeature_type&
      IntersectionFeature ();

      void
      IntersectionFeature (const IntersectionFeature_type& x);

      void
      IntersectionFeature (::std::unique_ptr< IntersectionFeature_type > p);

      // Constructors.
      //
      OppositeAngledLinesIntersectionType ();

      OppositeAngledLinesIntersectionType (const IntersectionPlane_type&,
                                           const IntersectionFeature_type&);

      OppositeAngledLinesIntersectionType (::std::unique_ptr< IntersectionPlane_type >,
                                           ::std::unique_ptr< IntersectionFeature_type >);

      OppositeAngledLinesIntersectionType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      OppositeAngledLinesIntersectionType (const OppositeAngledLinesIntersectionType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesIntersectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesIntersectionType&
      operator= (const OppositeAngledLinesIntersectionType& x);

      virtual 
      ~OppositeAngledLinesIntersectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< IntersectionPlane_type > IntersectionPlane_;
      ::xsd::cxx::tree::one< IntersectionFeature_type > IntersectionFeature_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesProjectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ProjectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionPlane_type;
      typedef ::xsd::cxx::tree::traits< ProjectionPlane_type, wchar_t > ProjectionPlane_traits;

      const ProjectionPlane_type&
      ProjectionPlane () const;

      ProjectionPlane_type&
      ProjectionPlane ();

      void
      ProjectionPlane (const ProjectionPlane_type& x);

      void
      ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > p);

      // ProjectionOppositeAngledLines
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionOppositeAngledLines_type;
      typedef ::xsd::cxx::tree::traits< ProjectionOppositeAngledLines_type, wchar_t > ProjectionOppositeAngledLines_traits;

      const ProjectionOppositeAngledLines_type&
      ProjectionOppositeAngledLines () const;

      ProjectionOppositeAngledLines_type&
      ProjectionOppositeAngledLines ();

      void
      ProjectionOppositeAngledLines (const ProjectionOppositeAngledLines_type& x);

      void
      ProjectionOppositeAngledLines (::std::unique_ptr< ProjectionOppositeAngledLines_type > p);

      // Constructors.
      //
      OppositeAngledLinesProjectionType ();

      OppositeAngledLinesProjectionType (const ProjectionPlane_type&,
                                         const ProjectionOppositeAngledLines_type&);

      OppositeAngledLinesProjectionType (::std::unique_ptr< ProjectionPlane_type >,
                                         ::std::unique_ptr< ProjectionOppositeAngledLines_type >);

      OppositeAngledLinesProjectionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      OppositeAngledLinesProjectionType (const OppositeAngledLinesProjectionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesProjectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesProjectionType&
      operator= (const OppositeAngledLinesProjectionType& x);

      virtual 
      ~OppositeAngledLinesProjectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProjectionPlane_type > ProjectionPlane_;
      ::xsd::cxx::tree::one< ProjectionOppositeAngledLines_type > ProjectionOppositeAngledLines_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOppositeAngledLines
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOppositeAngledLines_type;
      typedef ::xsd::cxx::tree::traits< BaseOppositeAngledLines_type, wchar_t > BaseOppositeAngledLines_traits;

      const BaseOppositeAngledLines_type&
      BaseOppositeAngledLines () const;

      BaseOppositeAngledLines_type&
      BaseOppositeAngledLines ();

      void
      BaseOppositeAngledLines (const BaseOppositeAngledLines_type& x);

      void
      BaseOppositeAngledLines (::std::unique_ptr< BaseOppositeAngledLines_type > p);

      // Constructors.
      //
      OppositeAngledLinesCopyType ();

      OppositeAngledLinesCopyType (const BaseOppositeAngledLines_type&);

      OppositeAngledLinesCopyType (::std::unique_ptr< BaseOppositeAngledLines_type >);

      OppositeAngledLinesCopyType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      OppositeAngledLinesCopyType (const OppositeAngledLinesCopyType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesCopyType&
      operator= (const OppositeAngledLinesCopyType& x);

      virtual 
      ~OppositeAngledLinesCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOppositeAngledLines_type > BaseOppositeAngledLines_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      OppositeAngledLinesCastType ();

      OppositeAngledLinesCastType (const BaseFeature_type&);

      OppositeAngledLinesCastType (::std::unique_ptr< BaseFeature_type >);

      OppositeAngledLinesCastType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      OppositeAngledLinesCastType (const OppositeAngledLinesCastType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesCastType&
      operator= (const OppositeAngledLinesCastType& x);

      virtual 
      ~OppositeAngledLinesCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOppositeAngledLines
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOppositeAngledLines_type;
      typedef ::xsd::cxx::tree::traits< BaseOppositeAngledLines_type, wchar_t > BaseOppositeAngledLines_traits;

      const BaseOppositeAngledLines_type&
      BaseOppositeAngledLines () const;

      BaseOppositeAngledLines_type&
      BaseOppositeAngledLines ();

      void
      BaseOppositeAngledLines (const BaseOppositeAngledLines_type& x);

      void
      BaseOppositeAngledLines (::std::unique_ptr< BaseOppositeAngledLines_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      OppositeAngledLinesTransformType ();

      OppositeAngledLinesTransformType (const BaseOppositeAngledLines_type&,
                                        const Transformation_type&);

      OppositeAngledLinesTransformType (::std::unique_ptr< BaseOppositeAngledLines_type >,
                                        ::std::unique_ptr< Transformation_type >);

      OppositeAngledLinesTransformType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OppositeAngledLinesTransformType (const OppositeAngledLinesTransformType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesTransformType&
      operator= (const OppositeAngledLinesTransformType& x);

      virtual 
      ~OppositeAngledLinesTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOppositeAngledLines_type > BaseOppositeAngledLines_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_type&
      Depth () const;

      Depth_type&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Constructors.
      //
      OppositeAngledLinesFromScanType ();

      OppositeAngledLinesFromScanType (const SurfaceFeature_type&,
                                       const SearchRadius_type&,
                                       const Depth_type&);

      OppositeAngledLinesFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                                       ::std::unique_ptr< SearchRadius_type >,
                                       ::std::unique_ptr< Depth_type >);

      OppositeAngledLinesFromScanType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      OppositeAngledLinesFromScanType (const OppositeAngledLinesFromScanType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesFromScanType&
      operator= (const OppositeAngledLinesFromScanType& x);

      virtual 
      ~OppositeAngledLinesFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      ::xsd::cxx::tree::one< Depth_type > Depth_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OppositeAngledLinesConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OppositeAngledLinesCheckedType ();

      OppositeAngledLinesCheckedType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      OppositeAngledLinesCheckedType (const OppositeAngledLinesCheckedType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesCheckedType&
      operator= (const OppositeAngledLinesCheckedType& x);

      virtual 
      ~OppositeAngledLinesCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::OppositeAngledLinesCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      OppositeAngledLinesCheckedFeatureType ();

      OppositeAngledLinesCheckedFeatureType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OppositeAngledLinesCheckedFeatureType (const OppositeAngledLinesCheckedFeatureType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesCheckedFeatureType&
      operator= (const OppositeAngledLinesCheckedFeatureType& x);

      virtual 
      ~OppositeAngledLinesCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::OppositeAngledLinesCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      OppositeAngledLinesMeasurementDeterminationType ();

      OppositeAngledLinesMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      OppositeAngledLinesMeasurementDeterminationType (const OppositeAngledLinesMeasurementDeterminationType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesMeasurementDeterminationType&
      operator= (const OppositeAngledLinesMeasurementDeterminationType& x);

      virtual 
      ~OppositeAngledLinesMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::OppositeAngledLinesMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      OppositeAngledLinesFeatureItemType ();

      OppositeAngledLinesFeatureItemType (const id_type&,
                                          const FeatureNominalId_type&,
                                          const FeatureName_type&,
                                          const DeterminationMode_type&);

      OppositeAngledLinesFeatureItemType (const id_type&,
                                          ::std::unique_ptr< FeatureNominalId_type >,
                                          const FeatureName_type&,
                                          ::std::unique_ptr< DeterminationMode_type >);

      OppositeAngledLinesFeatureItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OppositeAngledLinesFeatureItemType (const OppositeAngledLinesFeatureItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesFeatureItemType&
      operator= (const OppositeAngledLinesFeatureItemType& x);

      virtual 
      ~OppositeAngledLinesFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Width
      //
      typedef ::xsd::qif30::LinearValueType Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // EndType
      //
      typedef ::xsd::qif30::SlotEndType EndType_type;
      typedef ::xsd::cxx::tree::traits< EndType_type, wchar_t > EndType_traits;

      const EndType_type&
      EndType () const;

      EndType_type&
      EndType ();

      void
      EndType (const EndType_type& x);

      void
      EndType (::std::unique_ptr< EndType_type > p);

      // TaperAngle
      //
      typedef ::xsd::qif30::AngularValueType TaperAngle_type;
      typedef ::xsd::cxx::tree::traits< TaperAngle_type, wchar_t > TaperAngle_traits;

      const TaperAngle_type&
      TaperAngle () const;

      TaperAngle_type&
      TaperAngle ();

      void
      TaperAngle (const TaperAngle_type& x);

      void
      TaperAngle (::std::unique_ptr< TaperAngle_type > p);

      // SingleOpenEnd
      //
      typedef ::xml_schema::boolean SingleOpenEnd_type;
      typedef ::xsd::cxx::tree::optional< SingleOpenEnd_type > SingleOpenEnd_optional;
      typedef ::xsd::cxx::tree::traits< SingleOpenEnd_type, wchar_t > SingleOpenEnd_traits;

      const SingleOpenEnd_optional&
      SingleOpenEnd () const;

      SingleOpenEnd_optional&
      SingleOpenEnd ();

      void
      SingleOpenEnd (const SingleOpenEnd_type& x);

      void
      SingleOpenEnd (const SingleOpenEnd_optional& x);

      // EndRadius1
      //
      typedef ::xsd::qif30::EndRadiusType EndRadius1_type;
      typedef ::xsd::cxx::tree::optional< EndRadius1_type > EndRadius1_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius1_type, wchar_t > EndRadius1_traits;

      const EndRadius1_optional&
      EndRadius1 () const;

      EndRadius1_optional&
      EndRadius1 ();

      void
      EndRadius1 (const EndRadius1_type& x);

      void
      EndRadius1 (const EndRadius1_optional& x);

      void
      EndRadius1 (::std::unique_ptr< EndRadius1_type > p);

      // EndRadius2
      //
      typedef ::xsd::qif30::EndRadiusType EndRadius2_type;
      typedef ::xsd::cxx::tree::optional< EndRadius2_type > EndRadius2_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius2_type, wchar_t > EndRadius2_traits;

      const EndRadius2_optional&
      EndRadius2 () const;

      EndRadius2_optional&
      EndRadius2 ();

      void
      EndRadius2 (const EndRadius2_type& x);

      void
      EndRadius2 (const EndRadius2_optional& x);

      void
      EndRadius2 (::std::unique_ptr< EndRadius2_type > p);

      // Constructors.
      //
      OppositeAngledLinesFeatureDefinitionType ();

      OppositeAngledLinesFeatureDefinitionType (const id_type&,
                                                const InternalExternal_type&,
                                                const Width_type&,
                                                const EndType_type&,
                                                const TaperAngle_type&);

      OppositeAngledLinesFeatureDefinitionType (const id_type&,
                                                const InternalExternal_type&,
                                                ::std::unique_ptr< Width_type >,
                                                ::std::unique_ptr< EndType_type >,
                                                ::std::unique_ptr< TaperAngle_type >);

      OppositeAngledLinesFeatureDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      OppositeAngledLinesFeatureDefinitionType (const OppositeAngledLinesFeatureDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesFeatureDefinitionType&
      operator= (const OppositeAngledLinesFeatureDefinitionType& x);

      virtual 
      ~OppositeAngledLinesFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Width_type > Width_;
      Length_optional Length_;
      ::xsd::cxx::tree::one< EndType_type > EndType_;
      ::xsd::cxx::tree::one< TaperAngle_type > TaperAngle_;
      SingleOpenEnd_optional SingleOpenEnd_;
      EndRadius1_optional EndRadius1_;
      EndRadius2_optional EndRadius2_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // CenterLine
      //
      typedef ::xsd::qif30::PointAndVectorType CenterLine_type;
      typedef ::xsd::cxx::tree::traits< CenterLine_type, wchar_t > CenterLine_traits;

      const CenterLine_type&
      CenterLine () const;

      CenterLine_type&
      CenterLine ();

      void
      CenterLine (const CenterLine_type& x);

      void
      CenterLine (::std::unique_ptr< CenterLine_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OppositeAngledLinesConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OppositeAngledLinesFeatureNominalType ();

      OppositeAngledLinesFeatureNominalType (const id_type&,
                                             const FeatureDefinitionId_type&,
                                             const CenterLine_type&,
                                             const Normal_type&);

      OppositeAngledLinesFeatureNominalType (const id_type&,
                                             ::std::unique_ptr< FeatureDefinitionId_type >,
                                             ::std::unique_ptr< CenterLine_type >,
                                             ::std::unique_ptr< Normal_type >);

      OppositeAngledLinesFeatureNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OppositeAngledLinesFeatureNominalType (const OppositeAngledLinesFeatureNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesFeatureNominalType&
      operator= (const OppositeAngledLinesFeatureNominalType& x);

      virtual 
      ~OppositeAngledLinesFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CenterLine_type > CenterLine_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledLinesFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // CenterLine
      //
      typedef ::xsd::qif30::MeasuredPointAndVectorType CenterLine_type;
      typedef ::xsd::cxx::tree::optional< CenterLine_type > CenterLine_optional;
      typedef ::xsd::cxx::tree::traits< CenterLine_type, wchar_t > CenterLine_traits;

      const CenterLine_optional&
      CenterLine () const;

      CenterLine_optional&
      CenterLine ();

      void
      CenterLine (const CenterLine_type& x);

      void
      CenterLine (const CenterLine_optional& x);

      void
      CenterLine (::std::unique_ptr< CenterLine_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Width
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Width_type;
      typedef ::xsd::cxx::tree::optional< Width_type > Width_optional;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_optional&
      Width () const;

      Width_optional&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (const Width_optional& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // WidthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType WidthMin_type;
      typedef ::xsd::cxx::tree::optional< WidthMin_type > WidthMin_optional;
      typedef ::xsd::cxx::tree::traits< WidthMin_type, wchar_t > WidthMin_traits;

      const WidthMin_optional&
      WidthMin () const;

      WidthMin_optional&
      WidthMin ();

      void
      WidthMin (const WidthMin_type& x);

      void
      WidthMin (const WidthMin_optional& x);

      void
      WidthMin (::std::unique_ptr< WidthMin_type > p);

      // WidthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType WidthMax_type;
      typedef ::xsd::cxx::tree::optional< WidthMax_type > WidthMax_optional;
      typedef ::xsd::cxx::tree::traits< WidthMax_type, wchar_t > WidthMax_traits;

      const WidthMax_optional&
      WidthMax () const;

      WidthMax_optional&
      WidthMax ();

      void
      WidthMax (const WidthMax_type& x);

      void
      WidthMax (const WidthMax_optional& x);

      void
      WidthMax (::std::unique_ptr< WidthMax_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // LengthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMin_type;
      typedef ::xsd::cxx::tree::optional< LengthMin_type > LengthMin_optional;
      typedef ::xsd::cxx::tree::traits< LengthMin_type, wchar_t > LengthMin_traits;

      const LengthMin_optional&
      LengthMin () const;

      LengthMin_optional&
      LengthMin ();

      void
      LengthMin (const LengthMin_type& x);

      void
      LengthMin (const LengthMin_optional& x);

      void
      LengthMin (::std::unique_ptr< LengthMin_type > p);

      // LengthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMax_type;
      typedef ::xsd::cxx::tree::optional< LengthMax_type > LengthMax_optional;
      typedef ::xsd::cxx::tree::traits< LengthMax_type, wchar_t > LengthMax_traits;

      const LengthMax_optional&
      LengthMax () const;

      LengthMax_optional&
      LengthMax ();

      void
      LengthMax (const LengthMax_type& x);

      void
      LengthMax (const LengthMax_optional& x);

      void
      LengthMax (::std::unique_ptr< LengthMax_type > p);

      // TaperAngle
      //
      typedef ::xsd::qif30::MeasuredAngularValueType TaperAngle_type;
      typedef ::xsd::cxx::tree::optional< TaperAngle_type > TaperAngle_optional;
      typedef ::xsd::cxx::tree::traits< TaperAngle_type, wchar_t > TaperAngle_traits;

      const TaperAngle_optional&
      TaperAngle () const;

      TaperAngle_optional&
      TaperAngle ();

      void
      TaperAngle (const TaperAngle_type& x);

      void
      TaperAngle (const TaperAngle_optional& x);

      void
      TaperAngle (::std::unique_ptr< TaperAngle_type > p);

      // EndRadius1
      //
      typedef ::xsd::qif30::MeasuredEndRadiusType EndRadius1_type;
      typedef ::xsd::cxx::tree::optional< EndRadius1_type > EndRadius1_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius1_type, wchar_t > EndRadius1_traits;

      const EndRadius1_optional&
      EndRadius1 () const;

      EndRadius1_optional&
      EndRadius1 ();

      void
      EndRadius1 (const EndRadius1_type& x);

      void
      EndRadius1 (const EndRadius1_optional& x);

      void
      EndRadius1 (::std::unique_ptr< EndRadius1_type > p);

      // EndRadius2
      //
      typedef ::xsd::qif30::MeasuredEndRadiusType EndRadius2_type;
      typedef ::xsd::cxx::tree::optional< EndRadius2_type > EndRadius2_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius2_type, wchar_t > EndRadius2_traits;

      const EndRadius2_optional&
      EndRadius2 () const;

      EndRadius2_optional&
      EndRadius2 ();

      void
      EndRadius2 (const EndRadius2_type& x);

      void
      EndRadius2 (const EndRadius2_optional& x);

      void
      EndRadius2 (::std::unique_ptr< EndRadius2_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      OppositeAngledLinesFeatureMeasurementType ();

      OppositeAngledLinesFeatureMeasurementType (const id_type&);

      OppositeAngledLinesFeatureMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      OppositeAngledLinesFeatureMeasurementType (const OppositeAngledLinesFeatureMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual OppositeAngledLinesFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledLinesFeatureMeasurementType&
      operator= (const OppositeAngledLinesFeatureMeasurementType& x);

      virtual 
      ~OppositeAngledLinesFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CenterLine_optional CenterLine_;
      Normal_optional Normal_;
      Width_optional Width_;
      WidthMin_optional WidthMin_;
      WidthMax_optional WidthMax_;
      Length_optional Length_;
      LengthMin_optional LengthMin_;
      LengthMax_optional LengthMax_;
      TaperAngle_optional TaperAngle_;
      EndRadius1_optional EndRadius1_;
      EndRadius2_optional EndRadius2_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::OppositeParallelPlanesBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::OppositeParallelPlanesRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::OppositeParallelPlanesCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::OppositeParallelPlanesCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::OppositeParallelPlanesTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::OppositeParallelPlanesFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      OppositeParallelPlanesConstructionMethodType ();

      OppositeParallelPlanesConstructionMethodType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      OppositeParallelPlanesConstructionMethodType (const OppositeParallelPlanesConstructionMethodType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesConstructionMethodType&
      operator= (const OppositeParallelPlanesConstructionMethodType& x);

      virtual 
      ~OppositeParallelPlanesConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      OppositeParallelPlanesBestFitType ();

      OppositeParallelPlanesBestFitType (const n_type&);

      OppositeParallelPlanesBestFitType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      OppositeParallelPlanesBestFitType (const OppositeParallelPlanesBestFitType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesBestFitType&
      operator= (const OppositeParallelPlanesBestFitType& x);

      virtual 
      ~OppositeParallelPlanesBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      OppositeParallelPlanesRecompType ();

      OppositeParallelPlanesRecompType (const BaseFeaturePointList_type&);

      OppositeParallelPlanesRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      OppositeParallelPlanesRecompType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OppositeParallelPlanesRecompType (const OppositeParallelPlanesRecompType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesRecompType&
      operator= (const OppositeParallelPlanesRecompType& x);

      virtual 
      ~OppositeParallelPlanesRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOppositeParallelPlanes
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOppositeParallelPlanes_type;
      typedef ::xsd::cxx::tree::traits< BaseOppositeParallelPlanes_type, wchar_t > BaseOppositeParallelPlanes_traits;

      const BaseOppositeParallelPlanes_type&
      BaseOppositeParallelPlanes () const;

      BaseOppositeParallelPlanes_type&
      BaseOppositeParallelPlanes ();

      void
      BaseOppositeParallelPlanes (const BaseOppositeParallelPlanes_type& x);

      void
      BaseOppositeParallelPlanes (::std::unique_ptr< BaseOppositeParallelPlanes_type > p);

      // Constructors.
      //
      OppositeParallelPlanesCopyType ();

      OppositeParallelPlanesCopyType (const BaseOppositeParallelPlanes_type&);

      OppositeParallelPlanesCopyType (::std::unique_ptr< BaseOppositeParallelPlanes_type >);

      OppositeParallelPlanesCopyType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      OppositeParallelPlanesCopyType (const OppositeParallelPlanesCopyType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesCopyType&
      operator= (const OppositeParallelPlanesCopyType& x);

      virtual 
      ~OppositeParallelPlanesCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOppositeParallelPlanes_type > BaseOppositeParallelPlanes_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      OppositeParallelPlanesCastType ();

      OppositeParallelPlanesCastType (const BaseFeature_type&);

      OppositeParallelPlanesCastType (::std::unique_ptr< BaseFeature_type >);

      OppositeParallelPlanesCastType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      OppositeParallelPlanesCastType (const OppositeParallelPlanesCastType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesCastType&
      operator= (const OppositeParallelPlanesCastType& x);

      virtual 
      ~OppositeParallelPlanesCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOppositeParallelPlanes
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOppositeParallelPlanes_type;
      typedef ::xsd::cxx::tree::traits< BaseOppositeParallelPlanes_type, wchar_t > BaseOppositeParallelPlanes_traits;

      const BaseOppositeParallelPlanes_type&
      BaseOppositeParallelPlanes () const;

      BaseOppositeParallelPlanes_type&
      BaseOppositeParallelPlanes ();

      void
      BaseOppositeParallelPlanes (const BaseOppositeParallelPlanes_type& x);

      void
      BaseOppositeParallelPlanes (::std::unique_ptr< BaseOppositeParallelPlanes_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      OppositeParallelPlanesTransformType ();

      OppositeParallelPlanesTransformType (const BaseOppositeParallelPlanes_type&,
                                           const Transformation_type&);

      OppositeParallelPlanesTransformType (::std::unique_ptr< BaseOppositeParallelPlanes_type >,
                                           ::std::unique_ptr< Transformation_type >);

      OppositeParallelPlanesTransformType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      OppositeParallelPlanesTransformType (const OppositeParallelPlanesTransformType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesTransformType&
      operator= (const OppositeParallelPlanesTransformType& x);

      virtual 
      ~OppositeParallelPlanesTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOppositeParallelPlanes_type > BaseOppositeParallelPlanes_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Constructors.
      //
      OppositeParallelPlanesFromScanType ();

      OppositeParallelPlanesFromScanType (const SurfaceFeature_type&,
                                          const SearchRadius_type&);

      OppositeParallelPlanesFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                                          ::std::unique_ptr< SearchRadius_type >);

      OppositeParallelPlanesFromScanType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OppositeParallelPlanesFromScanType (const OppositeParallelPlanesFromScanType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesFromScanType&
      operator= (const OppositeParallelPlanesFromScanType& x);

      virtual 
      ~OppositeParallelPlanesFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OppositeParallelPlanesConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OppositeParallelPlanesCheckedType ();

      OppositeParallelPlanesCheckedType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      OppositeParallelPlanesCheckedType (const OppositeParallelPlanesCheckedType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesCheckedType&
      operator= (const OppositeParallelPlanesCheckedType& x);

      virtual 
      ~OppositeParallelPlanesCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::OppositeParallelPlanesCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      OppositeParallelPlanesCheckedFeatureType ();

      OppositeParallelPlanesCheckedFeatureType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      OppositeParallelPlanesCheckedFeatureType (const OppositeParallelPlanesCheckedFeatureType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesCheckedFeatureType&
      operator= (const OppositeParallelPlanesCheckedFeatureType& x);

      virtual 
      ~OppositeParallelPlanesCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::OppositeParallelPlanesCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      OppositeParallelPlanesMeasurementDeterminationType ();

      OppositeParallelPlanesMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      OppositeParallelPlanesMeasurementDeterminationType (const OppositeParallelPlanesMeasurementDeterminationType& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesMeasurementDeterminationType&
      operator= (const OppositeParallelPlanesMeasurementDeterminationType& x);

      virtual 
      ~OppositeParallelPlanesMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::OppositeParallelPlanesMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      OppositeParallelPlanesFeatureItemType ();

      OppositeParallelPlanesFeatureItemType (const id_type&,
                                             const FeatureNominalId_type&,
                                             const FeatureName_type&,
                                             const DeterminationMode_type&);

      OppositeParallelPlanesFeatureItemType (const id_type&,
                                             ::std::unique_ptr< FeatureNominalId_type >,
                                             const FeatureName_type&,
                                             ::std::unique_ptr< DeterminationMode_type >);

      OppositeParallelPlanesFeatureItemType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OppositeParallelPlanesFeatureItemType (const OppositeParallelPlanesFeatureItemType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesFeatureItemType&
      operator= (const OppositeParallelPlanesFeatureItemType& x);

      virtual 
      ~OppositeParallelPlanesFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Width
      //
      typedef ::xsd::qif30::LinearValueType Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // EndType
      //
      typedef ::xsd::qif30::SlotEndType EndType_type;
      typedef ::xsd::cxx::tree::traits< EndType_type, wchar_t > EndType_traits;

      const EndType_type&
      EndType () const;

      EndType_type&
      EndType ();

      void
      EndType (const EndType_type& x);

      void
      EndType (::std::unique_ptr< EndType_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::optional< Depth_type > Depth_optional;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_optional&
      Depth () const;

      Depth_optional&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (const Depth_optional& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Bottom
      //
      typedef ::xsd::qif30::BottomType Bottom_type;
      typedef ::xsd::cxx::tree::optional< Bottom_type > Bottom_optional;
      typedef ::xsd::cxx::tree::traits< Bottom_type, wchar_t > Bottom_traits;

      const Bottom_optional&
      Bottom () const;

      Bottom_optional&
      Bottom ();

      void
      Bottom (const Bottom_type& x);

      void
      Bottom (const Bottom_optional& x);

      void
      Bottom (::std::unique_ptr< Bottom_type > p);

      // SingleOpenEnd
      //
      typedef ::xml_schema::boolean SingleOpenEnd_type;
      typedef ::xsd::cxx::tree::optional< SingleOpenEnd_type > SingleOpenEnd_optional;
      typedef ::xsd::cxx::tree::traits< SingleOpenEnd_type, wchar_t > SingleOpenEnd_traits;

      const SingleOpenEnd_optional&
      SingleOpenEnd () const;

      SingleOpenEnd_optional&
      SingleOpenEnd ();

      void
      SingleOpenEnd (const SingleOpenEnd_type& x);

      void
      SingleOpenEnd (const SingleOpenEnd_optional& x);

      // EndRadius1
      //
      typedef ::xsd::qif30::EndRadiusType EndRadius1_type;
      typedef ::xsd::cxx::tree::optional< EndRadius1_type > EndRadius1_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius1_type, wchar_t > EndRadius1_traits;

      const EndRadius1_optional&
      EndRadius1 () const;

      EndRadius1_optional&
      EndRadius1 ();

      void
      EndRadius1 (const EndRadius1_type& x);

      void
      EndRadius1 (const EndRadius1_optional& x);

      void
      EndRadius1 (::std::unique_ptr< EndRadius1_type > p);

      // EndRadius2
      //
      typedef ::xsd::qif30::EndRadiusType EndRadius2_type;
      typedef ::xsd::cxx::tree::optional< EndRadius2_type > EndRadius2_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius2_type, wchar_t > EndRadius2_traits;

      const EndRadius2_optional&
      EndRadius2 () const;

      EndRadius2_optional&
      EndRadius2 ();

      void
      EndRadius2 (const EndRadius2_type& x);

      void
      EndRadius2 (const EndRadius2_optional& x);

      void
      EndRadius2 (::std::unique_ptr< EndRadius2_type > p);

      // Constructors.
      //
      OppositeParallelPlanesFeatureDefinitionType ();

      OppositeParallelPlanesFeatureDefinitionType (const id_type&,
                                                   const InternalExternal_type&,
                                                   const Width_type&,
                                                   const EndType_type&);

      OppositeParallelPlanesFeatureDefinitionType (const id_type&,
                                                   const InternalExternal_type&,
                                                   ::std::unique_ptr< Width_type >,
                                                   ::std::unique_ptr< EndType_type >);

      OppositeParallelPlanesFeatureDefinitionType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      OppositeParallelPlanesFeatureDefinitionType (const OppositeParallelPlanesFeatureDefinitionType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesFeatureDefinitionType&
      operator= (const OppositeParallelPlanesFeatureDefinitionType& x);

      virtual 
      ~OppositeParallelPlanesFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Width_type > Width_;
      Length_optional Length_;
      ::xsd::cxx::tree::one< EndType_type > EndType_;
      Depth_optional Depth_;
      Bottom_optional Bottom_;
      SingleOpenEnd_optional SingleOpenEnd_;
      EndRadius1_optional EndRadius1_;
      EndRadius2_optional EndRadius2_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // CenterPlane
      //
      typedef ::xsd::qif30::PlaneType CenterPlane_type;
      typedef ::xsd::cxx::tree::traits< CenterPlane_type, wchar_t > CenterPlane_traits;

      const CenterPlane_type&
      CenterPlane () const;

      CenterPlane_type&
      CenterPlane ();

      void
      CenterPlane (const CenterPlane_type& x);

      void
      CenterPlane (::std::unique_ptr< CenterPlane_type > p);

      // LengthVector
      //
      typedef ::xsd::qif30::UnitVectorType LengthVector_type;
      typedef ::xsd::cxx::tree::optional< LengthVector_type > LengthVector_optional;
      typedef ::xsd::cxx::tree::traits< LengthVector_type, wchar_t > LengthVector_traits;

      const LengthVector_optional&
      LengthVector () const;

      LengthVector_optional&
      LengthVector ();

      void
      LengthVector (const LengthVector_type& x);

      void
      LengthVector (const LengthVector_optional& x);

      void
      LengthVector (::std::unique_ptr< LengthVector_type > p);

      // DepthVector
      //
      typedef ::xsd::qif30::UnitVectorType DepthVector_type;
      typedef ::xsd::cxx::tree::optional< DepthVector_type > DepthVector_optional;
      typedef ::xsd::cxx::tree::traits< DepthVector_type, wchar_t > DepthVector_traits;

      const DepthVector_optional&
      DepthVector () const;

      DepthVector_optional&
      DepthVector ();

      void
      DepthVector (const DepthVector_type& x);

      void
      DepthVector (const DepthVector_optional& x);

      void
      DepthVector (::std::unique_ptr< DepthVector_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OppositeParallelPlanesConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OppositeParallelPlanesFeatureNominalType ();

      OppositeParallelPlanesFeatureNominalType (const id_type&,
                                                const FeatureDefinitionId_type&,
                                                const CenterPlane_type&);

      OppositeParallelPlanesFeatureNominalType (const id_type&,
                                                ::std::unique_ptr< FeatureDefinitionId_type >,
                                                ::std::unique_ptr< CenterPlane_type >);

      OppositeParallelPlanesFeatureNominalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      OppositeParallelPlanesFeatureNominalType (const OppositeParallelPlanesFeatureNominalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesFeatureNominalType&
      operator= (const OppositeParallelPlanesFeatureNominalType& x);

      virtual 
      ~OppositeParallelPlanesFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CenterPlane_type > CenterPlane_;
      LengthVector_optional LengthVector_;
      DepthVector_optional DepthVector_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OppositeParallelPlanesFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // CenterPlane
      //
      typedef ::xsd::qif30::MeasuredPlaneType CenterPlane_type;
      typedef ::xsd::cxx::tree::optional< CenterPlane_type > CenterPlane_optional;
      typedef ::xsd::cxx::tree::traits< CenterPlane_type, wchar_t > CenterPlane_traits;

      const CenterPlane_optional&
      CenterPlane () const;

      CenterPlane_optional&
      CenterPlane ();

      void
      CenterPlane (const CenterPlane_type& x);

      void
      CenterPlane (const CenterPlane_optional& x);

      void
      CenterPlane (::std::unique_ptr< CenterPlane_type > p);

      // LengthVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType LengthVector_type;
      typedef ::xsd::cxx::tree::optional< LengthVector_type > LengthVector_optional;
      typedef ::xsd::cxx::tree::traits< LengthVector_type, wchar_t > LengthVector_traits;

      const LengthVector_optional&
      LengthVector () const;

      LengthVector_optional&
      LengthVector ();

      void
      LengthVector (const LengthVector_type& x);

      void
      LengthVector (const LengthVector_optional& x);

      void
      LengthVector (::std::unique_ptr< LengthVector_type > p);

      // DepthVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType DepthVector_type;
      typedef ::xsd::cxx::tree::optional< DepthVector_type > DepthVector_optional;
      typedef ::xsd::cxx::tree::traits< DepthVector_type, wchar_t > DepthVector_traits;

      const DepthVector_optional&
      DepthVector () const;

      DepthVector_optional&
      DepthVector ();

      void
      DepthVector (const DepthVector_type& x);

      void
      DepthVector (const DepthVector_optional& x);

      void
      DepthVector (::std::unique_ptr< DepthVector_type > p);

      // Width
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Width_type;
      typedef ::xsd::cxx::tree::optional< Width_type > Width_optional;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_optional&
      Width () const;

      Width_optional&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (const Width_optional& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // WidthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType WidthMin_type;
      typedef ::xsd::cxx::tree::optional< WidthMin_type > WidthMin_optional;
      typedef ::xsd::cxx::tree::traits< WidthMin_type, wchar_t > WidthMin_traits;

      const WidthMin_optional&
      WidthMin () const;

      WidthMin_optional&
      WidthMin ();

      void
      WidthMin (const WidthMin_type& x);

      void
      WidthMin (const WidthMin_optional& x);

      void
      WidthMin (::std::unique_ptr< WidthMin_type > p);

      // WidthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType WidthMax_type;
      typedef ::xsd::cxx::tree::optional< WidthMax_type > WidthMax_optional;
      typedef ::xsd::cxx::tree::traits< WidthMax_type, wchar_t > WidthMax_traits;

      const WidthMax_optional&
      WidthMax () const;

      WidthMax_optional&
      WidthMax ();

      void
      WidthMax (const WidthMax_type& x);

      void
      WidthMax (const WidthMax_optional& x);

      void
      WidthMax (::std::unique_ptr< WidthMax_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // LengthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMin_type;
      typedef ::xsd::cxx::tree::optional< LengthMin_type > LengthMin_optional;
      typedef ::xsd::cxx::tree::traits< LengthMin_type, wchar_t > LengthMin_traits;

      const LengthMin_optional&
      LengthMin () const;

      LengthMin_optional&
      LengthMin ();

      void
      LengthMin (const LengthMin_type& x);

      void
      LengthMin (const LengthMin_optional& x);

      void
      LengthMin (::std::unique_ptr< LengthMin_type > p);

      // LengthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMax_type;
      typedef ::xsd::cxx::tree::optional< LengthMax_type > LengthMax_optional;
      typedef ::xsd::cxx::tree::traits< LengthMax_type, wchar_t > LengthMax_traits;

      const LengthMax_optional&
      LengthMax () const;

      LengthMax_optional&
      LengthMax ();

      void
      LengthMax (const LengthMax_type& x);

      void
      LengthMax (const LengthMax_optional& x);

      void
      LengthMax (::std::unique_ptr< LengthMax_type > p);

      // Depth
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Depth_type;
      typedef ::xsd::cxx::tree::optional< Depth_type > Depth_optional;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_optional&
      Depth () const;

      Depth_optional&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (const Depth_optional& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // EndRadius1
      //
      typedef ::xsd::qif30::MeasuredEndRadiusType EndRadius1_type;
      typedef ::xsd::cxx::tree::optional< EndRadius1_type > EndRadius1_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius1_type, wchar_t > EndRadius1_traits;

      const EndRadius1_optional&
      EndRadius1 () const;

      EndRadius1_optional&
      EndRadius1 ();

      void
      EndRadius1 (const EndRadius1_type& x);

      void
      EndRadius1 (const EndRadius1_optional& x);

      void
      EndRadius1 (::std::unique_ptr< EndRadius1_type > p);

      // EndRadius2
      //
      typedef ::xsd::qif30::MeasuredEndRadiusType EndRadius2_type;
      typedef ::xsd::cxx::tree::optional< EndRadius2_type > EndRadius2_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius2_type, wchar_t > EndRadius2_traits;

      const EndRadius2_optional&
      EndRadius2 () const;

      EndRadius2_optional&
      EndRadius2 ();

      void
      EndRadius2 (const EndRadius2_type& x);

      void
      EndRadius2 (const EndRadius2_optional& x);

      void
      EndRadius2 (::std::unique_ptr< EndRadius2_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      OppositeParallelPlanesFeatureMeasurementType ();

      OppositeParallelPlanesFeatureMeasurementType (const id_type&);

      OppositeParallelPlanesFeatureMeasurementType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      OppositeParallelPlanesFeatureMeasurementType (const OppositeParallelPlanesFeatureMeasurementType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual OppositeParallelPlanesFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeParallelPlanesFeatureMeasurementType&
      operator= (const OppositeParallelPlanesFeatureMeasurementType& x);

      virtual 
      ~OppositeParallelPlanesFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CenterPlane_optional CenterPlane_;
      LengthVector_optional LengthVector_;
      DepthVector_optional DepthVector_;
      Width_optional Width_;
      WidthMin_optional WidthMin_;
      WidthMax_optional WidthMax_;
      Length_optional Length_;
      LengthMin_optional LengthMin_;
      LengthMax_optional LengthMax_;
      Depth_optional Depth_;
      EndRadius1_optional EndRadius1_;
      EndRadius2_optional EndRadius2_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::OppositeAngledPlanesBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::OppositeAngledPlanesRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::OppositeAngledPlanesCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::OppositeAngledPlanesCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::OppositeAngledPlanesTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::OppositeAngledPlanesFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      OppositeAngledPlanesConstructionMethodType ();

      OppositeAngledPlanesConstructionMethodType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      OppositeAngledPlanesConstructionMethodType (const OppositeAngledPlanesConstructionMethodType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesConstructionMethodType&
      operator= (const OppositeAngledPlanesConstructionMethodType& x);

      virtual 
      ~OppositeAngledPlanesConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      OppositeAngledPlanesBestFitType ();

      OppositeAngledPlanesBestFitType (const n_type&);

      OppositeAngledPlanesBestFitType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      OppositeAngledPlanesBestFitType (const OppositeAngledPlanesBestFitType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesBestFitType&
      operator= (const OppositeAngledPlanesBestFitType& x);

      virtual 
      ~OppositeAngledPlanesBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      OppositeAngledPlanesRecompType ();

      OppositeAngledPlanesRecompType (const BaseFeaturePointList_type&);

      OppositeAngledPlanesRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      OppositeAngledPlanesRecompType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      OppositeAngledPlanesRecompType (const OppositeAngledPlanesRecompType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesRecompType&
      operator= (const OppositeAngledPlanesRecompType& x);

      virtual 
      ~OppositeAngledPlanesRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOppositeAngledPlanes
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOppositeAngledPlanes_type;
      typedef ::xsd::cxx::tree::traits< BaseOppositeAngledPlanes_type, wchar_t > BaseOppositeAngledPlanes_traits;

      const BaseOppositeAngledPlanes_type&
      BaseOppositeAngledPlanes () const;

      BaseOppositeAngledPlanes_type&
      BaseOppositeAngledPlanes ();

      void
      BaseOppositeAngledPlanes (const BaseOppositeAngledPlanes_type& x);

      void
      BaseOppositeAngledPlanes (::std::unique_ptr< BaseOppositeAngledPlanes_type > p);

      // Constructors.
      //
      OppositeAngledPlanesCopyType ();

      OppositeAngledPlanesCopyType (const BaseOppositeAngledPlanes_type&);

      OppositeAngledPlanesCopyType (::std::unique_ptr< BaseOppositeAngledPlanes_type >);

      OppositeAngledPlanesCopyType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      OppositeAngledPlanesCopyType (const OppositeAngledPlanesCopyType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesCopyType&
      operator= (const OppositeAngledPlanesCopyType& x);

      virtual 
      ~OppositeAngledPlanesCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOppositeAngledPlanes_type > BaseOppositeAngledPlanes_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      OppositeAngledPlanesCastType ();

      OppositeAngledPlanesCastType (const BaseFeature_type&);

      OppositeAngledPlanesCastType (::std::unique_ptr< BaseFeature_type >);

      OppositeAngledPlanesCastType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      OppositeAngledPlanesCastType (const OppositeAngledPlanesCastType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesCastType&
      operator= (const OppositeAngledPlanesCastType& x);

      virtual 
      ~OppositeAngledPlanesCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOppositeAngledPlanes
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOppositeAngledPlanes_type;
      typedef ::xsd::cxx::tree::traits< BaseOppositeAngledPlanes_type, wchar_t > BaseOppositeAngledPlanes_traits;

      const BaseOppositeAngledPlanes_type&
      BaseOppositeAngledPlanes () const;

      BaseOppositeAngledPlanes_type&
      BaseOppositeAngledPlanes ();

      void
      BaseOppositeAngledPlanes (const BaseOppositeAngledPlanes_type& x);

      void
      BaseOppositeAngledPlanes (::std::unique_ptr< BaseOppositeAngledPlanes_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      OppositeAngledPlanesTransformType ();

      OppositeAngledPlanesTransformType (const BaseOppositeAngledPlanes_type&,
                                         const Transformation_type&);

      OppositeAngledPlanesTransformType (::std::unique_ptr< BaseOppositeAngledPlanes_type >,
                                         ::std::unique_ptr< Transformation_type >);

      OppositeAngledPlanesTransformType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      OppositeAngledPlanesTransformType (const OppositeAngledPlanesTransformType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesTransformType&
      operator= (const OppositeAngledPlanesTransformType& x);

      virtual 
      ~OppositeAngledPlanesTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOppositeAngledPlanes_type > BaseOppositeAngledPlanes_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Constructors.
      //
      OppositeAngledPlanesFromScanType ();

      OppositeAngledPlanesFromScanType (const SurfaceFeature_type&,
                                        const SearchRadius_type&);

      OppositeAngledPlanesFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                                        ::std::unique_ptr< SearchRadius_type >);

      OppositeAngledPlanesFromScanType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OppositeAngledPlanesFromScanType (const OppositeAngledPlanesFromScanType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesFromScanType&
      operator= (const OppositeAngledPlanesFromScanType& x);

      virtual 
      ~OppositeAngledPlanesFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OppositeAngledPlanesConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OppositeAngledPlanesCheckedType ();

      OppositeAngledPlanesCheckedType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      OppositeAngledPlanesCheckedType (const OppositeAngledPlanesCheckedType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesCheckedType&
      operator= (const OppositeAngledPlanesCheckedType& x);

      virtual 
      ~OppositeAngledPlanesCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::OppositeAngledPlanesCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      OppositeAngledPlanesCheckedFeatureType ();

      OppositeAngledPlanesCheckedFeatureType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OppositeAngledPlanesCheckedFeatureType (const OppositeAngledPlanesCheckedFeatureType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesCheckedFeatureType&
      operator= (const OppositeAngledPlanesCheckedFeatureType& x);

      virtual 
      ~OppositeAngledPlanesCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::OppositeAngledPlanesCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      OppositeAngledPlanesMeasurementDeterminationType ();

      OppositeAngledPlanesMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      OppositeAngledPlanesMeasurementDeterminationType (const OppositeAngledPlanesMeasurementDeterminationType& x,
                                                        ::xml_schema::flags f = 0,
                                                        ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesMeasurementDeterminationType&
      operator= (const OppositeAngledPlanesMeasurementDeterminationType& x);

      virtual 
      ~OppositeAngledPlanesMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::OppositeAngledPlanesMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      OppositeAngledPlanesFeatureItemType ();

      OppositeAngledPlanesFeatureItemType (const id_type&,
                                           const FeatureNominalId_type&,
                                           const FeatureName_type&,
                                           const DeterminationMode_type&);

      OppositeAngledPlanesFeatureItemType (const id_type&,
                                           ::std::unique_ptr< FeatureNominalId_type >,
                                           const FeatureName_type&,
                                           ::std::unique_ptr< DeterminationMode_type >);

      OppositeAngledPlanesFeatureItemType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      OppositeAngledPlanesFeatureItemType (const OppositeAngledPlanesFeatureItemType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesFeatureItemType&
      operator= (const OppositeAngledPlanesFeatureItemType& x);

      virtual 
      ~OppositeAngledPlanesFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Width
      //
      typedef ::xsd::qif30::LinearValueType Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // EndType
      //
      typedef ::xsd::qif30::SlotEndType EndType_type;
      typedef ::xsd::cxx::tree::traits< EndType_type, wchar_t > EndType_traits;

      const EndType_type&
      EndType () const;

      EndType_type&
      EndType ();

      void
      EndType (const EndType_type& x);

      void
      EndType (::std::unique_ptr< EndType_type > p);

      // Depth
      //
      typedef ::xsd::qif30::LinearValueType Depth_type;
      typedef ::xsd::cxx::tree::optional< Depth_type > Depth_optional;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_optional&
      Depth () const;

      Depth_optional&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (const Depth_optional& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // Bottom
      //
      typedef ::xsd::qif30::BottomType Bottom_type;
      typedef ::xsd::cxx::tree::optional< Bottom_type > Bottom_optional;
      typedef ::xsd::cxx::tree::traits< Bottom_type, wchar_t > Bottom_traits;

      const Bottom_optional&
      Bottom () const;

      Bottom_optional&
      Bottom ();

      void
      Bottom (const Bottom_type& x);

      void
      Bottom (const Bottom_optional& x);

      void
      Bottom (::std::unique_ptr< Bottom_type > p);

      // SingleOpenEnd
      //
      typedef ::xml_schema::boolean SingleOpenEnd_type;
      typedef ::xsd::cxx::tree::optional< SingleOpenEnd_type > SingleOpenEnd_optional;
      typedef ::xsd::cxx::tree::traits< SingleOpenEnd_type, wchar_t > SingleOpenEnd_traits;

      const SingleOpenEnd_optional&
      SingleOpenEnd () const;

      SingleOpenEnd_optional&
      SingleOpenEnd ();

      void
      SingleOpenEnd (const SingleOpenEnd_type& x);

      void
      SingleOpenEnd (const SingleOpenEnd_optional& x);

      // EndRadius1
      //
      typedef ::xsd::qif30::EndRadiusType EndRadius1_type;
      typedef ::xsd::cxx::tree::optional< EndRadius1_type > EndRadius1_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius1_type, wchar_t > EndRadius1_traits;

      const EndRadius1_optional&
      EndRadius1 () const;

      EndRadius1_optional&
      EndRadius1 ();

      void
      EndRadius1 (const EndRadius1_type& x);

      void
      EndRadius1 (const EndRadius1_optional& x);

      void
      EndRadius1 (::std::unique_ptr< EndRadius1_type > p);

      // EndRadius2
      //
      typedef ::xsd::qif30::EndRadiusType EndRadius2_type;
      typedef ::xsd::cxx::tree::optional< EndRadius2_type > EndRadius2_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius2_type, wchar_t > EndRadius2_traits;

      const EndRadius2_optional&
      EndRadius2 () const;

      EndRadius2_optional&
      EndRadius2 ();

      void
      EndRadius2 (const EndRadius2_type& x);

      void
      EndRadius2 (const EndRadius2_optional& x);

      void
      EndRadius2 (::std::unique_ptr< EndRadius2_type > p);

      // TaperAngle
      //
      typedef ::xsd::qif30::AngularValueType TaperAngle_type;
      typedef ::xsd::cxx::tree::optional< TaperAngle_type > TaperAngle_optional;
      typedef ::xsd::cxx::tree::traits< TaperAngle_type, wchar_t > TaperAngle_traits;

      const TaperAngle_optional&
      TaperAngle () const;

      TaperAngle_optional&
      TaperAngle ();

      void
      TaperAngle (const TaperAngle_type& x);

      void
      TaperAngle (const TaperAngle_optional& x);

      void
      TaperAngle (::std::unique_ptr< TaperAngle_type > p);

      // DraftAngle
      //
      typedef ::xsd::qif30::AngularValueType DraftAngle_type;
      typedef ::xsd::cxx::tree::optional< DraftAngle_type > DraftAngle_optional;
      typedef ::xsd::cxx::tree::traits< DraftAngle_type, wchar_t > DraftAngle_traits;

      const DraftAngle_optional&
      DraftAngle () const;

      DraftAngle_optional&
      DraftAngle ();

      void
      DraftAngle (const DraftAngle_type& x);

      void
      DraftAngle (const DraftAngle_optional& x);

      void
      DraftAngle (::std::unique_ptr< DraftAngle_type > p);

      // Constructors.
      //
      OppositeAngledPlanesFeatureDefinitionType ();

      OppositeAngledPlanesFeatureDefinitionType (const id_type&,
                                                 const InternalExternal_type&,
                                                 const Width_type&,
                                                 const EndType_type&);

      OppositeAngledPlanesFeatureDefinitionType (const id_type&,
                                                 const InternalExternal_type&,
                                                 ::std::unique_ptr< Width_type >,
                                                 ::std::unique_ptr< EndType_type >);

      OppositeAngledPlanesFeatureDefinitionType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      OppositeAngledPlanesFeatureDefinitionType (const OppositeAngledPlanesFeatureDefinitionType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesFeatureDefinitionType&
      operator= (const OppositeAngledPlanesFeatureDefinitionType& x);

      virtual 
      ~OppositeAngledPlanesFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Width_type > Width_;
      Length_optional Length_;
      ::xsd::cxx::tree::one< EndType_type > EndType_;
      Depth_optional Depth_;
      Bottom_optional Bottom_;
      SingleOpenEnd_optional SingleOpenEnd_;
      EndRadius1_optional EndRadius1_;
      EndRadius2_optional EndRadius2_;
      TaperAngle_optional TaperAngle_;
      DraftAngle_optional DraftAngle_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // CenterPlane
      //
      typedef ::xsd::qif30::PlaneType CenterPlane_type;
      typedef ::xsd::cxx::tree::traits< CenterPlane_type, wchar_t > CenterPlane_traits;

      const CenterPlane_type&
      CenterPlane () const;

      CenterPlane_type&
      CenterPlane ();

      void
      CenterPlane (const CenterPlane_type& x);

      void
      CenterPlane (::std::unique_ptr< CenterPlane_type > p);

      // LengthVector
      //
      typedef ::xsd::qif30::UnitVectorType LengthVector_type;
      typedef ::xsd::cxx::tree::optional< LengthVector_type > LengthVector_optional;
      typedef ::xsd::cxx::tree::traits< LengthVector_type, wchar_t > LengthVector_traits;

      const LengthVector_optional&
      LengthVector () const;

      LengthVector_optional&
      LengthVector ();

      void
      LengthVector (const LengthVector_type& x);

      void
      LengthVector (const LengthVector_optional& x);

      void
      LengthVector (::std::unique_ptr< LengthVector_type > p);

      // DepthVector
      //
      typedef ::xsd::qif30::UnitVectorType DepthVector_type;
      typedef ::xsd::cxx::tree::optional< DepthVector_type > DepthVector_optional;
      typedef ::xsd::cxx::tree::traits< DepthVector_type, wchar_t > DepthVector_traits;

      const DepthVector_optional&
      DepthVector () const;

      DepthVector_optional&
      DepthVector ();

      void
      DepthVector (const DepthVector_type& x);

      void
      DepthVector (const DepthVector_optional& x);

      void
      DepthVector (::std::unique_ptr< DepthVector_type > p);

      // DraftVector
      //
      typedef ::xsd::qif30::UnitVectorType DraftVector_type;
      typedef ::xsd::cxx::tree::optional< DraftVector_type > DraftVector_optional;
      typedef ::xsd::cxx::tree::traits< DraftVector_type, wchar_t > DraftVector_traits;

      const DraftVector_optional&
      DraftVector () const;

      DraftVector_optional&
      DraftVector ();

      void
      DraftVector (const DraftVector_type& x);

      void
      DraftVector (const DraftVector_optional& x);

      void
      DraftVector (::std::unique_ptr< DraftVector_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OppositeAngledPlanesConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OppositeAngledPlanesFeatureNominalType ();

      OppositeAngledPlanesFeatureNominalType (const id_type&,
                                              const FeatureDefinitionId_type&,
                                              const CenterPlane_type&);

      OppositeAngledPlanesFeatureNominalType (const id_type&,
                                              ::std::unique_ptr< FeatureDefinitionId_type >,
                                              ::std::unique_ptr< CenterPlane_type >);

      OppositeAngledPlanesFeatureNominalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OppositeAngledPlanesFeatureNominalType (const OppositeAngledPlanesFeatureNominalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesFeatureNominalType&
      operator= (const OppositeAngledPlanesFeatureNominalType& x);

      virtual 
      ~OppositeAngledPlanesFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CenterPlane_type > CenterPlane_;
      LengthVector_optional LengthVector_;
      DepthVector_optional DepthVector_;
      DraftVector_optional DraftVector_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OppositeAngledPlanesFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // CenterPlane
      //
      typedef ::xsd::qif30::MeasuredPlaneType CenterPlane_type;
      typedef ::xsd::cxx::tree::optional< CenterPlane_type > CenterPlane_optional;
      typedef ::xsd::cxx::tree::traits< CenterPlane_type, wchar_t > CenterPlane_traits;

      const CenterPlane_optional&
      CenterPlane () const;

      CenterPlane_optional&
      CenterPlane ();

      void
      CenterPlane (const CenterPlane_type& x);

      void
      CenterPlane (const CenterPlane_optional& x);

      void
      CenterPlane (::std::unique_ptr< CenterPlane_type > p);

      // LengthVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType LengthVector_type;
      typedef ::xsd::cxx::tree::optional< LengthVector_type > LengthVector_optional;
      typedef ::xsd::cxx::tree::traits< LengthVector_type, wchar_t > LengthVector_traits;

      const LengthVector_optional&
      LengthVector () const;

      LengthVector_optional&
      LengthVector ();

      void
      LengthVector (const LengthVector_type& x);

      void
      LengthVector (const LengthVector_optional& x);

      void
      LengthVector (::std::unique_ptr< LengthVector_type > p);

      // DepthVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType DepthVector_type;
      typedef ::xsd::cxx::tree::optional< DepthVector_type > DepthVector_optional;
      typedef ::xsd::cxx::tree::traits< DepthVector_type, wchar_t > DepthVector_traits;

      const DepthVector_optional&
      DepthVector () const;

      DepthVector_optional&
      DepthVector ();

      void
      DepthVector (const DepthVector_type& x);

      void
      DepthVector (const DepthVector_optional& x);

      void
      DepthVector (::std::unique_ptr< DepthVector_type > p);

      // Width
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Width_type;
      typedef ::xsd::cxx::tree::optional< Width_type > Width_optional;
      typedef ::xsd::cxx::tree::traits< Width_type, wchar_t > Width_traits;

      const Width_optional&
      Width () const;

      Width_optional&
      Width ();

      void
      Width (const Width_type& x);

      void
      Width (const Width_optional& x);

      void
      Width (::std::unique_ptr< Width_type > p);

      // WidthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType WidthMin_type;
      typedef ::xsd::cxx::tree::optional< WidthMin_type > WidthMin_optional;
      typedef ::xsd::cxx::tree::traits< WidthMin_type, wchar_t > WidthMin_traits;

      const WidthMin_optional&
      WidthMin () const;

      WidthMin_optional&
      WidthMin ();

      void
      WidthMin (const WidthMin_type& x);

      void
      WidthMin (const WidthMin_optional& x);

      void
      WidthMin (::std::unique_ptr< WidthMin_type > p);

      // WidthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType WidthMax_type;
      typedef ::xsd::cxx::tree::optional< WidthMax_type > WidthMax_optional;
      typedef ::xsd::cxx::tree::traits< WidthMax_type, wchar_t > WidthMax_traits;

      const WidthMax_optional&
      WidthMax () const;

      WidthMax_optional&
      WidthMax ();

      void
      WidthMax (const WidthMax_type& x);

      void
      WidthMax (const WidthMax_optional& x);

      void
      WidthMax (::std::unique_ptr< WidthMax_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // LengthMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMin_type;
      typedef ::xsd::cxx::tree::optional< LengthMin_type > LengthMin_optional;
      typedef ::xsd::cxx::tree::traits< LengthMin_type, wchar_t > LengthMin_traits;

      const LengthMin_optional&
      LengthMin () const;

      LengthMin_optional&
      LengthMin ();

      void
      LengthMin (const LengthMin_type& x);

      void
      LengthMin (const LengthMin_optional& x);

      void
      LengthMin (::std::unique_ptr< LengthMin_type > p);

      // LengthMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType LengthMax_type;
      typedef ::xsd::cxx::tree::optional< LengthMax_type > LengthMax_optional;
      typedef ::xsd::cxx::tree::traits< LengthMax_type, wchar_t > LengthMax_traits;

      const LengthMax_optional&
      LengthMax () const;

      LengthMax_optional&
      LengthMax ();

      void
      LengthMax (const LengthMax_type& x);

      void
      LengthMax (const LengthMax_optional& x);

      void
      LengthMax (::std::unique_ptr< LengthMax_type > p);

      // Depth
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Depth_type;
      typedef ::xsd::cxx::tree::optional< Depth_type > Depth_optional;
      typedef ::xsd::cxx::tree::traits< Depth_type, wchar_t > Depth_traits;

      const Depth_optional&
      Depth () const;

      Depth_optional&
      Depth ();

      void
      Depth (const Depth_type& x);

      void
      Depth (const Depth_optional& x);

      void
      Depth (::std::unique_ptr< Depth_type > p);

      // TaperAngle
      //
      typedef ::xsd::qif30::MeasuredAngularValueType TaperAngle_type;
      typedef ::xsd::cxx::tree::optional< TaperAngle_type > TaperAngle_optional;
      typedef ::xsd::cxx::tree::traits< TaperAngle_type, wchar_t > TaperAngle_traits;

      const TaperAngle_optional&
      TaperAngle () const;

      TaperAngle_optional&
      TaperAngle ();

      void
      TaperAngle (const TaperAngle_type& x);

      void
      TaperAngle (const TaperAngle_optional& x);

      void
      TaperAngle (::std::unique_ptr< TaperAngle_type > p);

      // DraftAngle
      //
      typedef ::xsd::qif30::MeasuredAngularValueType DraftAngle_type;
      typedef ::xsd::cxx::tree::optional< DraftAngle_type > DraftAngle_optional;
      typedef ::xsd::cxx::tree::traits< DraftAngle_type, wchar_t > DraftAngle_traits;

      const DraftAngle_optional&
      DraftAngle () const;

      DraftAngle_optional&
      DraftAngle ();

      void
      DraftAngle (const DraftAngle_type& x);

      void
      DraftAngle (const DraftAngle_optional& x);

      void
      DraftAngle (::std::unique_ptr< DraftAngle_type > p);

      // EndRadius1
      //
      typedef ::xsd::qif30::MeasuredEndRadiusType EndRadius1_type;
      typedef ::xsd::cxx::tree::optional< EndRadius1_type > EndRadius1_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius1_type, wchar_t > EndRadius1_traits;

      const EndRadius1_optional&
      EndRadius1 () const;

      EndRadius1_optional&
      EndRadius1 ();

      void
      EndRadius1 (const EndRadius1_type& x);

      void
      EndRadius1 (const EndRadius1_optional& x);

      void
      EndRadius1 (::std::unique_ptr< EndRadius1_type > p);

      // EndRadius2
      //
      typedef ::xsd::qif30::MeasuredEndRadiusType EndRadius2_type;
      typedef ::xsd::cxx::tree::optional< EndRadius2_type > EndRadius2_optional;
      typedef ::xsd::cxx::tree::traits< EndRadius2_type, wchar_t > EndRadius2_traits;

      const EndRadius2_optional&
      EndRadius2 () const;

      EndRadius2_optional&
      EndRadius2 ();

      void
      EndRadius2 (const EndRadius2_type& x);

      void
      EndRadius2 (const EndRadius2_optional& x);

      void
      EndRadius2 (::std::unique_ptr< EndRadius2_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      OppositeAngledPlanesFeatureMeasurementType ();

      OppositeAngledPlanesFeatureMeasurementType (const id_type&);

      OppositeAngledPlanesFeatureMeasurementType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      OppositeAngledPlanesFeatureMeasurementType (const OppositeAngledPlanesFeatureMeasurementType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual OppositeAngledPlanesFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeAngledPlanesFeatureMeasurementType&
      operator= (const OppositeAngledPlanesFeatureMeasurementType& x);

      virtual 
      ~OppositeAngledPlanesFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CenterPlane_optional CenterPlane_;
      LengthVector_optional LengthVector_;
      DepthVector_optional DepthVector_;
      Width_optional Width_;
      WidthMin_optional WidthMin_;
      WidthMax_optional WidthMax_;
      Length_optional Length_;
      LengthMin_optional LengthMin_;
      LengthMax_optional LengthMax_;
      Depth_optional Depth_;
      TaperAngle_optional TaperAngle_;
      DraftAngle_optional DraftAngle_;
      EndRadius1_optional EndRadius1_;
      EndRadius2_optional EndRadius2_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL OtherCurveConstructionMethodType: public ::xml_schema::type
    {
      public:
      // Copy
      //
      typedef ::xsd::qif30::OtherCurveFeatureCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Constructors.
      //
      OtherCurveConstructionMethodType ();

      OtherCurveConstructionMethodType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OtherCurveConstructionMethodType (const OtherCurveConstructionMethodType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OtherCurveConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherCurveConstructionMethodType&
      operator= (const OtherCurveConstructionMethodType& x);

      virtual 
      ~OtherCurveConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Copy_optional Copy_;
    };

    class QIF30_SYMBOL_DECL OtherCurveFeatureCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOtherCurveFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOtherCurveFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseOtherCurveFeature_type, wchar_t > BaseOtherCurveFeature_traits;

      const BaseOtherCurveFeature_type&
      BaseOtherCurveFeature () const;

      BaseOtherCurveFeature_type&
      BaseOtherCurveFeature ();

      void
      BaseOtherCurveFeature (const BaseOtherCurveFeature_type& x);

      void
      BaseOtherCurveFeature (::std::unique_ptr< BaseOtherCurveFeature_type > p);

      // Constructors.
      //
      OtherCurveFeatureCopyType ();

      OtherCurveFeatureCopyType (const BaseOtherCurveFeature_type&);

      OtherCurveFeatureCopyType (::std::unique_ptr< BaseOtherCurveFeature_type >);

      OtherCurveFeatureCopyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      OtherCurveFeatureCopyType (const OtherCurveFeatureCopyType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual OtherCurveFeatureCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherCurveFeatureCopyType&
      operator= (const OtherCurveFeatureCopyType& x);

      virtual 
      ~OtherCurveFeatureCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOtherCurveFeature_type > BaseOtherCurveFeature_;
    };

    class QIF30_SYMBOL_DECL OtherCurveCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OtherCurveConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OtherCurveCheckedType ();

      OtherCurveCheckedType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      OtherCurveCheckedType (const OtherCurveCheckedType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual OtherCurveCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherCurveCheckedType&
      operator= (const OtherCurveCheckedType& x);

      virtual 
      ~OtherCurveCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OtherCurveCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::OtherCurveCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      OtherCurveCheckedFeatureType ();

      OtherCurveCheckedFeatureType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      OtherCurveCheckedFeatureType (const OtherCurveCheckedFeatureType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual OtherCurveCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherCurveCheckedFeatureType&
      operator= (const OtherCurveCheckedFeatureType& x);

      virtual 
      ~OtherCurveCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL OtherCurveMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::OtherCurveCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      OtherCurveMeasurementDeterminationType ();

      OtherCurveMeasurementDeterminationType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OtherCurveMeasurementDeterminationType (const OtherCurveMeasurementDeterminationType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual OtherCurveMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherCurveMeasurementDeterminationType&
      operator= (const OtherCurveMeasurementDeterminationType& x);

      virtual 
      ~OtherCurveMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL OtherCurveFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::OtherCurveMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      OtherCurveFeatureItemType ();

      OtherCurveFeatureItemType (const id_type&,
                                 const FeatureNominalId_type&,
                                 const FeatureName_type&,
                                 const DeterminationMode_type&);

      OtherCurveFeatureItemType (const id_type&,
                                 ::std::unique_ptr< FeatureNominalId_type >,
                                 const FeatureName_type&,
                                 ::std::unique_ptr< DeterminationMode_type >);

      OtherCurveFeatureItemType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      OtherCurveFeatureItemType (const OtherCurveFeatureItemType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual OtherCurveFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherCurveFeatureItemType&
      operator= (const OtherCurveFeatureItemType& x);

      virtual 
      ~OtherCurveFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL OtherCurveFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      OtherCurveFeatureDefinitionType ();

      OtherCurveFeatureDefinitionType (const id_type&);

      OtherCurveFeatureDefinitionType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      OtherCurveFeatureDefinitionType (const OtherCurveFeatureDefinitionType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual OtherCurveFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherCurveFeatureDefinitionType&
      operator= (const OtherCurveFeatureDefinitionType&) = default;
#endif

      virtual 
      ~OtherCurveFeatureDefinitionType ();
    };

    class QIF30_SYMBOL_DECL OtherCurveFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // Constructed
      //
      typedef ::xsd::qif30::OtherCurveConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OtherCurveFeatureNominalType ();

      OtherCurveFeatureNominalType (const id_type&,
                                    const FeatureDefinitionId_type&);

      OtherCurveFeatureNominalType (const id_type&,
                                    ::std::unique_ptr< FeatureDefinitionId_type >);

      OtherCurveFeatureNominalType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      OtherCurveFeatureNominalType (const OtherCurveFeatureNominalType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual OtherCurveFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherCurveFeatureNominalType&
      operator= (const OtherCurveFeatureNominalType& x);

      virtual 
      ~OtherCurveFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OtherCurveFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      OtherCurveFeatureMeasurementType ();

      OtherCurveFeatureMeasurementType (const id_type&);

      OtherCurveFeatureMeasurementType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OtherCurveFeatureMeasurementType (const OtherCurveFeatureMeasurementType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OtherCurveFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherCurveFeatureMeasurementType&
      operator= (const OtherCurveFeatureMeasurementType&) = default;
#endif

      virtual 
      ~OtherCurveFeatureMeasurementType ();
    };

    class QIF30_SYMBOL_DECL OtherNonShapeFeatureItemType: public ::xsd::qif30::NonShapeFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      OtherNonShapeFeatureItemType ();

      OtherNonShapeFeatureItemType (const id_type&,
                                    const FeatureNominalId_type&,
                                    const FeatureName_type&);

      OtherNonShapeFeatureItemType (const id_type&,
                                    ::std::unique_ptr< FeatureNominalId_type >,
                                    const FeatureName_type&);

      OtherNonShapeFeatureItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      OtherNonShapeFeatureItemType (const OtherNonShapeFeatureItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual OtherNonShapeFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherNonShapeFeatureItemType&
      operator= (const OtherNonShapeFeatureItemType&) = default;
#endif

      virtual 
      ~OtherNonShapeFeatureItemType ();
    };

    class QIF30_SYMBOL_DECL OtherNonShapeFeatureDefinitionType: public ::xsd::qif30::NonShapeFeatureDefinitionBaseType
    {
      public:
      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_type&
      Description () const;

      Description_type&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Constructors.
      //
      OtherNonShapeFeatureDefinitionType ();

      OtherNonShapeFeatureDefinitionType (const id_type&,
                                          const Description_type&);

      OtherNonShapeFeatureDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OtherNonShapeFeatureDefinitionType (const OtherNonShapeFeatureDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OtherNonShapeFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherNonShapeFeatureDefinitionType&
      operator= (const OtherNonShapeFeatureDefinitionType& x);

      virtual 
      ~OtherNonShapeFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Description_type > Description_;
    };

    class QIF30_SYMBOL_DECL OtherNonShapeFeatureNominalType: public ::xsd::qif30::NonShapeFeatureNominalBaseType
    {
      public:
      // ReferenceFeatureNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType ReferenceFeatureNominalIds_type;
      typedef ::xsd::cxx::tree::optional< ReferenceFeatureNominalIds_type > ReferenceFeatureNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< ReferenceFeatureNominalIds_type, wchar_t > ReferenceFeatureNominalIds_traits;

      const ReferenceFeatureNominalIds_optional&
      ReferenceFeatureNominalIds () const;

      ReferenceFeatureNominalIds_optional&
      ReferenceFeatureNominalIds ();

      void
      ReferenceFeatureNominalIds (const ReferenceFeatureNominalIds_type& x);

      void
      ReferenceFeatureNominalIds (const ReferenceFeatureNominalIds_optional& x);

      void
      ReferenceFeatureNominalIds (::std::unique_ptr< ReferenceFeatureNominalIds_type > p);

      // Constructors.
      //
      OtherNonShapeFeatureNominalType ();

      OtherNonShapeFeatureNominalType (const id_type&,
                                       const FeatureDefinitionId_type&);

      OtherNonShapeFeatureNominalType (const id_type&,
                                       ::std::unique_ptr< FeatureDefinitionId_type >);

      OtherNonShapeFeatureNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      OtherNonShapeFeatureNominalType (const OtherNonShapeFeatureNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual OtherNonShapeFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherNonShapeFeatureNominalType&
      operator= (const OtherNonShapeFeatureNominalType& x);

      virtual 
      ~OtherNonShapeFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ReferenceFeatureNominalIds_optional ReferenceFeatureNominalIds_;
    };

    class QIF30_SYMBOL_DECL OtherNonShapeFeatureMeasurementType: public ::xsd::qif30::NonShapeFeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      OtherNonShapeFeatureMeasurementType ();

      OtherNonShapeFeatureMeasurementType (const id_type&);

      OtherNonShapeFeatureMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      OtherNonShapeFeatureMeasurementType (const OtherNonShapeFeatureMeasurementType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual OtherNonShapeFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherNonShapeFeatureMeasurementType&
      operator= (const OtherNonShapeFeatureMeasurementType&) = default;
#endif

      virtual 
      ~OtherNonShapeFeatureMeasurementType ();
    };

    class QIF30_SYMBOL_DECL MarkingMethodEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PAINT,
        STAIN,
        ENSCRIBE,
        EMBOSS
      };

      MarkingMethodEnumType ();

      MarkingMethodEnumType (value v);

      MarkingMethodEnumType (const wchar_t* v);

      MarkingMethodEnumType (const ::std::wstring& v);

      MarkingMethodEnumType (const ::xml_schema::nmtoken& v);

      MarkingMethodEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MarkingMethodEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MarkingMethodEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MarkingMethodEnumType (const MarkingMethodEnumType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      MarkingMethodEnumType&
      operator= (const MarkingMethodEnumType&) = default;
#endif

      virtual MarkingMethodEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MarkingMethodEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MarkingMethodEnumType_convert ();
      }

      protected:
      value
      _xsd_MarkingMethodEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_MarkingMethodEnumType_literals_[4];
      static const value _xsd_MarkingMethodEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL MarkingMethodType: public ::xml_schema::type
    {
      public:
      // MarkingMethodEnum
      //
      typedef ::xsd::qif30::MarkingMethodEnumType MarkingMethodEnum_type;
      typedef ::xsd::cxx::tree::optional< MarkingMethodEnum_type > MarkingMethodEnum_optional;
      typedef ::xsd::cxx::tree::traits< MarkingMethodEnum_type, wchar_t > MarkingMethodEnum_traits;

      const MarkingMethodEnum_optional&
      MarkingMethodEnum () const;

      MarkingMethodEnum_optional&
      MarkingMethodEnum ();

      void
      MarkingMethodEnum (const MarkingMethodEnum_type& x);

      void
      MarkingMethodEnum (const MarkingMethodEnum_optional& x);

      void
      MarkingMethodEnum (::std::unique_ptr< MarkingMethodEnum_type > p);

      // OtherMarkingMethod
      //
      typedef ::xml_schema::string OtherMarkingMethod_type;
      typedef ::xsd::cxx::tree::optional< OtherMarkingMethod_type > OtherMarkingMethod_optional;
      typedef ::xsd::cxx::tree::traits< OtherMarkingMethod_type, wchar_t > OtherMarkingMethod_traits;

      const OtherMarkingMethod_optional&
      OtherMarkingMethod () const;

      OtherMarkingMethod_optional&
      OtherMarkingMethod ();

      void
      OtherMarkingMethod (const OtherMarkingMethod_type& x);

      void
      OtherMarkingMethod (const OtherMarkingMethod_optional& x);

      void
      OtherMarkingMethod (::std::unique_ptr< OtherMarkingMethod_type > p);

      // Constructors.
      //
      MarkingMethodType ();

      MarkingMethodType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      MarkingMethodType (const MarkingMethodType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual MarkingMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MarkingMethodType&
      operator= (const MarkingMethodType& x);

      virtual 
      ~MarkingMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MarkingMethodEnum_optional MarkingMethodEnum_;
      OtherMarkingMethod_optional OtherMarkingMethod_;
    };

    class QIF30_SYMBOL_DECL MarkingFeatureItemType: public ::xsd::qif30::NonShapeFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      MarkingFeatureItemType ();

      MarkingFeatureItemType (const id_type&,
                              const FeatureNominalId_type&,
                              const FeatureName_type&);

      MarkingFeatureItemType (const id_type&,
                              ::std::unique_ptr< FeatureNominalId_type >,
                              const FeatureName_type&);

      MarkingFeatureItemType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      MarkingFeatureItemType (const MarkingFeatureItemType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual MarkingFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      MarkingFeatureItemType&
      operator= (const MarkingFeatureItemType&) = default;
#endif

      virtual 
      ~MarkingFeatureItemType ();
    };

    class QIF30_SYMBOL_DECL MarkingFeatureDefinitionType: public ::xsd::qif30::NonShapeFeatureDefinitionBaseType
    {
      public:
      // Text
      //
      typedef ::xml_schema::string Text_type;
      typedef ::xsd::cxx::tree::traits< Text_type, wchar_t > Text_traits;

      const Text_type&
      Text () const;

      Text_type&
      Text ();

      void
      Text (const Text_type& x);

      void
      Text (::std::unique_ptr< Text_type > p);

      // MarkingMethod
      //
      typedef ::xsd::qif30::MarkingMethodType MarkingMethod_type;
      typedef ::xsd::cxx::tree::traits< MarkingMethod_type, wchar_t > MarkingMethod_traits;

      const MarkingMethod_type&
      MarkingMethod () const;

      MarkingMethod_type&
      MarkingMethod ();

      void
      MarkingMethod (const MarkingMethod_type& x);

      void
      MarkingMethod (::std::unique_ptr< MarkingMethod_type > p);

      // Constructors.
      //
      MarkingFeatureDefinitionType ();

      MarkingFeatureDefinitionType (const id_type&,
                                    const Text_type&,
                                    const MarkingMethod_type&);

      MarkingFeatureDefinitionType (const id_type&,
                                    const Text_type&,
                                    ::std::unique_ptr< MarkingMethod_type >);

      MarkingFeatureDefinitionType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MarkingFeatureDefinitionType (const MarkingFeatureDefinitionType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual MarkingFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MarkingFeatureDefinitionType&
      operator= (const MarkingFeatureDefinitionType& x);

      virtual 
      ~MarkingFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Text_type > Text_;
      ::xsd::cxx::tree::one< MarkingMethod_type > MarkingMethod_;
    };

    class QIF30_SYMBOL_DECL MarkingFeatureNominalType: public ::xsd::qif30::NonShapeFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::RectangleType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Constructors.
      //
      MarkingFeatureNominalType ();

      MarkingFeatureNominalType (const id_type&,
                                 const FeatureDefinitionId_type&,
                                 const Location_type&);

      MarkingFeatureNominalType (const id_type&,
                                 ::std::unique_ptr< FeatureDefinitionId_type >,
                                 ::std::unique_ptr< Location_type >);

      MarkingFeatureNominalType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      MarkingFeatureNominalType (const MarkingFeatureNominalType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual MarkingFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MarkingFeatureNominalType&
      operator= (const MarkingFeatureNominalType& x);

      virtual 
      ~MarkingFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
    };

    class QIF30_SYMBOL_DECL MarkingFeatureMeasurementType: public ::xsd::qif30::NonShapeFeatureMeasurementBaseType
    {
      public:
      // Text
      //
      typedef ::xml_schema::string Text_type;
      typedef ::xsd::cxx::tree::traits< Text_type, wchar_t > Text_traits;

      const Text_type&
      Text () const;

      Text_type&
      Text ();

      void
      Text (const Text_type& x);

      void
      Text (::std::unique_ptr< Text_type > p);

      // Location
      //
      typedef ::xsd::qif30::RectangleType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Constructors.
      //
      MarkingFeatureMeasurementType ();

      MarkingFeatureMeasurementType (const id_type&,
                                     const Text_type&,
                                     const Location_type&);

      MarkingFeatureMeasurementType (const id_type&,
                                     const Text_type&,
                                     ::std::unique_ptr< Location_type >);

      MarkingFeatureMeasurementType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      MarkingFeatureMeasurementType (const MarkingFeatureMeasurementType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual MarkingFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MarkingFeatureMeasurementType&
      operator= (const MarkingFeatureMeasurementType& x);

      virtual 
      ~MarkingFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Text_type > Text_;
      ::xsd::cxx::tree::one< Location_type > Location_;
    };

    class QIF30_SYMBOL_DECL OtherShapeConstructionMethodType: public ::xml_schema::type
    {
      public:
      // Copy
      //
      typedef ::xsd::qif30::OtherShapeFeatureCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Constructors.
      //
      OtherShapeConstructionMethodType ();

      OtherShapeConstructionMethodType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OtherShapeConstructionMethodType (const OtherShapeConstructionMethodType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OtherShapeConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherShapeConstructionMethodType&
      operator= (const OtherShapeConstructionMethodType& x);

      virtual 
      ~OtherShapeConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Copy_optional Copy_;
    };

    class QIF30_SYMBOL_DECL OtherShapeFeatureCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOtherShapeFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOtherShapeFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseOtherShapeFeature_type, wchar_t > BaseOtherShapeFeature_traits;

      const BaseOtherShapeFeature_type&
      BaseOtherShapeFeature () const;

      BaseOtherShapeFeature_type&
      BaseOtherShapeFeature ();

      void
      BaseOtherShapeFeature (const BaseOtherShapeFeature_type& x);

      void
      BaseOtherShapeFeature (::std::unique_ptr< BaseOtherShapeFeature_type > p);

      // Constructors.
      //
      OtherShapeFeatureCopyType ();

      OtherShapeFeatureCopyType (const BaseOtherShapeFeature_type&);

      OtherShapeFeatureCopyType (::std::unique_ptr< BaseOtherShapeFeature_type >);

      OtherShapeFeatureCopyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      OtherShapeFeatureCopyType (const OtherShapeFeatureCopyType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual OtherShapeFeatureCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherShapeFeatureCopyType&
      operator= (const OtherShapeFeatureCopyType& x);

      virtual 
      ~OtherShapeFeatureCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOtherShapeFeature_type > BaseOtherShapeFeature_;
    };

    class QIF30_SYMBOL_DECL OtherShapeCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OtherShapeConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OtherShapeCheckedType ();

      OtherShapeCheckedType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      OtherShapeCheckedType (const OtherShapeCheckedType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual OtherShapeCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherShapeCheckedType&
      operator= (const OtherShapeCheckedType& x);

      virtual 
      ~OtherShapeCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OtherShapeCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::OtherShapeCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      OtherShapeCheckedFeatureType ();

      OtherShapeCheckedFeatureType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      OtherShapeCheckedFeatureType (const OtherShapeCheckedFeatureType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual OtherShapeCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherShapeCheckedFeatureType&
      operator= (const OtherShapeCheckedFeatureType& x);

      virtual 
      ~OtherShapeCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL OtherShapeMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::OtherShapeCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      OtherShapeMeasurementDeterminationType ();

      OtherShapeMeasurementDeterminationType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OtherShapeMeasurementDeterminationType (const OtherShapeMeasurementDeterminationType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual OtherShapeMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherShapeMeasurementDeterminationType&
      operator= (const OtherShapeMeasurementDeterminationType& x);

      virtual 
      ~OtherShapeMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL OtherShapeFeatureItemType: public ::xsd::qif30::ShapeFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::OtherShapeMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      OtherShapeFeatureItemType ();

      OtherShapeFeatureItemType (const id_type&,
                                 const FeatureNominalId_type&,
                                 const FeatureName_type&,
                                 const DeterminationMode_type&);

      OtherShapeFeatureItemType (const id_type&,
                                 ::std::unique_ptr< FeatureNominalId_type >,
                                 const FeatureName_type&,
                                 ::std::unique_ptr< DeterminationMode_type >);

      OtherShapeFeatureItemType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      OtherShapeFeatureItemType (const OtherShapeFeatureItemType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual OtherShapeFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherShapeFeatureItemType&
      operator= (const OtherShapeFeatureItemType& x);

      virtual 
      ~OtherShapeFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL OtherShapeFeatureDefinitionType: public ::xsd::qif30::ShapeFeatureDefinitionBaseType
    {
      public:
      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_type&
      Description () const;

      Description_type&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Constructors.
      //
      OtherShapeFeatureDefinitionType ();

      OtherShapeFeatureDefinitionType (const id_type&,
                                       const Description_type&);

      OtherShapeFeatureDefinitionType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      OtherShapeFeatureDefinitionType (const OtherShapeFeatureDefinitionType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual OtherShapeFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherShapeFeatureDefinitionType&
      operator= (const OtherShapeFeatureDefinitionType& x);

      virtual 
      ~OtherShapeFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Description_type > Description_;
    };

    class QIF30_SYMBOL_DECL OtherShapeFeatureNominalType: public ::xsd::qif30::ShapeFeatureNominalBaseType
    {
      public:
      // Constructed
      //
      typedef ::xsd::qif30::OtherShapeConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OtherShapeFeatureNominalType ();

      OtherShapeFeatureNominalType (const id_type&,
                                    const FeatureDefinitionId_type&);

      OtherShapeFeatureNominalType (const id_type&,
                                    ::std::unique_ptr< FeatureDefinitionId_type >);

      OtherShapeFeatureNominalType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      OtherShapeFeatureNominalType (const OtherShapeFeatureNominalType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual OtherShapeFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherShapeFeatureNominalType&
      operator= (const OtherShapeFeatureNominalType& x);

      virtual 
      ~OtherShapeFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OtherShapeFeatureMeasurementType: public ::xsd::qif30::ShapeFeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      OtherShapeFeatureMeasurementType ();

      OtherShapeFeatureMeasurementType (const id_type&);

      OtherShapeFeatureMeasurementType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      OtherShapeFeatureMeasurementType (const OtherShapeFeatureMeasurementType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual OtherShapeFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherShapeFeatureMeasurementType&
      operator= (const OtherShapeFeatureMeasurementType&) = default;
#endif

      virtual 
      ~OtherShapeFeatureMeasurementType ();
    };

    class QIF30_SYMBOL_DECL OtherSurfaceConstructionMethodType: public ::xml_schema::type
    {
      public:
      // Copy
      //
      typedef ::xsd::qif30::OtherSurfaceFeatureCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Constructors.
      //
      OtherSurfaceConstructionMethodType ();

      OtherSurfaceConstructionMethodType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OtherSurfaceConstructionMethodType (const OtherSurfaceConstructionMethodType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OtherSurfaceConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherSurfaceConstructionMethodType&
      operator= (const OtherSurfaceConstructionMethodType& x);

      virtual 
      ~OtherSurfaceConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Copy_optional Copy_;
    };

    class QIF30_SYMBOL_DECL OtherSurfaceFeatureCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseOtherSurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseOtherSurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseOtherSurfaceFeature_type, wchar_t > BaseOtherSurfaceFeature_traits;

      const BaseOtherSurfaceFeature_type&
      BaseOtherSurfaceFeature () const;

      BaseOtherSurfaceFeature_type&
      BaseOtherSurfaceFeature ();

      void
      BaseOtherSurfaceFeature (const BaseOtherSurfaceFeature_type& x);

      void
      BaseOtherSurfaceFeature (::std::unique_ptr< BaseOtherSurfaceFeature_type > p);

      // Constructors.
      //
      OtherSurfaceFeatureCopyType ();

      OtherSurfaceFeatureCopyType (const BaseOtherSurfaceFeature_type&);

      OtherSurfaceFeatureCopyType (::std::unique_ptr< BaseOtherSurfaceFeature_type >);

      OtherSurfaceFeatureCopyType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      OtherSurfaceFeatureCopyType (const OtherSurfaceFeatureCopyType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual OtherSurfaceFeatureCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherSurfaceFeatureCopyType&
      operator= (const OtherSurfaceFeatureCopyType& x);

      virtual 
      ~OtherSurfaceFeatureCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseOtherSurfaceFeature_type > BaseOtherSurfaceFeature_;
    };

    class QIF30_SYMBOL_DECL OtherSurfaceCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OtherSurfaceConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OtherSurfaceCheckedType ();

      OtherSurfaceCheckedType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      OtherSurfaceCheckedType (const OtherSurfaceCheckedType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual OtherSurfaceCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherSurfaceCheckedType&
      operator= (const OtherSurfaceCheckedType& x);

      virtual 
      ~OtherSurfaceCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OtherSurfaceCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::OtherSurfaceCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      OtherSurfaceCheckedFeatureType ();

      OtherSurfaceCheckedFeatureType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      OtherSurfaceCheckedFeatureType (const OtherSurfaceCheckedFeatureType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual OtherSurfaceCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherSurfaceCheckedFeatureType&
      operator= (const OtherSurfaceCheckedFeatureType& x);

      virtual 
      ~OtherSurfaceCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL OtherSurfaceMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::OtherSurfaceCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      OtherSurfaceMeasurementDeterminationType ();

      OtherSurfaceMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      OtherSurfaceMeasurementDeterminationType (const OtherSurfaceMeasurementDeterminationType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual OtherSurfaceMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherSurfaceMeasurementDeterminationType&
      operator= (const OtherSurfaceMeasurementDeterminationType& x);

      virtual 
      ~OtherSurfaceMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL OtherSurfaceFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::OtherSurfaceMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      OtherSurfaceFeatureItemType ();

      OtherSurfaceFeatureItemType (const id_type&,
                                   const FeatureNominalId_type&,
                                   const FeatureName_type&,
                                   const DeterminationMode_type&);

      OtherSurfaceFeatureItemType (const id_type&,
                                   ::std::unique_ptr< FeatureNominalId_type >,
                                   const FeatureName_type&,
                                   ::std::unique_ptr< DeterminationMode_type >);

      OtherSurfaceFeatureItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      OtherSurfaceFeatureItemType (const OtherSurfaceFeatureItemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual OtherSurfaceFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherSurfaceFeatureItemType&
      operator= (const OtherSurfaceFeatureItemType& x);

      virtual 
      ~OtherSurfaceFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL OtherSurfaceFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      OtherSurfaceFeatureDefinitionType ();

      OtherSurfaceFeatureDefinitionType (const id_type&);

      OtherSurfaceFeatureDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      OtherSurfaceFeatureDefinitionType (const OtherSurfaceFeatureDefinitionType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual OtherSurfaceFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherSurfaceFeatureDefinitionType&
      operator= (const OtherSurfaceFeatureDefinitionType&) = default;
#endif

      virtual 
      ~OtherSurfaceFeatureDefinitionType ();
    };

    class QIF30_SYMBOL_DECL OtherSurfaceFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // PolyLine
      //
      typedef ::xsd::qif30::PolyLineType PolyLine_type;
      typedef ::xsd::cxx::tree::optional< PolyLine_type > PolyLine_optional;
      typedef ::xsd::cxx::tree::traits< PolyLine_type, wchar_t > PolyLine_traits;

      const PolyLine_optional&
      PolyLine () const;

      PolyLine_optional&
      PolyLine ();

      void
      PolyLine (const PolyLine_type& x);

      void
      PolyLine (const PolyLine_optional& x);

      void
      PolyLine (::std::unique_ptr< PolyLine_type > p);

      // ClosedSurface
      //
      typedef ::xsd::qif30::InternalExternalEnumType ClosedSurface_type;
      typedef ::xsd::cxx::tree::optional< ClosedSurface_type > ClosedSurface_optional;
      typedef ::xsd::cxx::tree::traits< ClosedSurface_type, wchar_t > ClosedSurface_traits;

      const ClosedSurface_optional&
      ClosedSurface () const;

      ClosedSurface_optional&
      ClosedSurface ();

      void
      ClosedSurface (const ClosedSurface_type& x);

      void
      ClosedSurface (const ClosedSurface_optional& x);

      void
      ClosedSurface (::std::unique_ptr< ClosedSurface_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::OtherSurfaceConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      OtherSurfaceFeatureNominalType ();

      OtherSurfaceFeatureNominalType (const id_type&,
                                      const FeatureDefinitionId_type&);

      OtherSurfaceFeatureNominalType (const id_type&,
                                      ::std::unique_ptr< FeatureDefinitionId_type >);

      OtherSurfaceFeatureNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      OtherSurfaceFeatureNominalType (const OtherSurfaceFeatureNominalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual OtherSurfaceFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherSurfaceFeatureNominalType&
      operator= (const OtherSurfaceFeatureNominalType& x);

      virtual 
      ~OtherSurfaceFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PolyLine_optional PolyLine_;
      ClosedSurface_optional ClosedSurface_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL OtherSurfaceFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // PolyLine
      //
      typedef ::xsd::qif30::PolyLineType PolyLine_type;
      typedef ::xsd::cxx::tree::optional< PolyLine_type > PolyLine_optional;
      typedef ::xsd::cxx::tree::traits< PolyLine_type, wchar_t > PolyLine_traits;

      const PolyLine_optional&
      PolyLine () const;

      PolyLine_optional&
      PolyLine ();

      void
      PolyLine (const PolyLine_type& x);

      void
      PolyLine (const PolyLine_optional& x);

      void
      PolyLine (::std::unique_ptr< PolyLine_type > p);

      // Constructors.
      //
      OtherSurfaceFeatureMeasurementType ();

      OtherSurfaceFeatureMeasurementType (const id_type&);

      OtherSurfaceFeatureMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OtherSurfaceFeatureMeasurementType (const OtherSurfaceFeatureMeasurementType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OtherSurfaceFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherSurfaceFeatureMeasurementType&
      operator= (const OtherSurfaceFeatureMeasurementType& x);

      virtual 
      ~OtherSurfaceFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PolyLine_optional PolyLine_;
    };

    class QIF30_SYMBOL_DECL PlaneConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::PlaneBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::PlaneRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Midplane
      //
      typedef ::xsd::qif30::PlaneMidplaneType Midplane_type;
      typedef ::xsd::cxx::tree::optional< Midplane_type > Midplane_optional;
      typedef ::xsd::cxx::tree::traits< Midplane_type, wchar_t > Midplane_traits;

      const Midplane_optional&
      Midplane () const;

      Midplane_optional&
      Midplane ();

      void
      Midplane (const Midplane_type& x);

      void
      Midplane (const Midplane_optional& x);

      void
      Midplane (::std::unique_ptr< Midplane_type > p);

      // Offset
      //
      typedef ::xsd::qif30::PlaneOffsetType Offset_type;
      typedef ::xsd::cxx::tree::optional< Offset_type > Offset_optional;
      typedef ::xsd::cxx::tree::traits< Offset_type, wchar_t > Offset_traits;

      const Offset_optional&
      Offset () const;

      Offset_optional&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (const Offset_optional& x);

      void
      Offset (::std::unique_ptr< Offset_type > p);

      // Perpendicular
      //
      typedef ::xsd::qif30::PlanePerpendicularType Perpendicular_type;
      typedef ::xsd::cxx::tree::optional< Perpendicular_type > Perpendicular_optional;
      typedef ::xsd::cxx::tree::traits< Perpendicular_type, wchar_t > Perpendicular_traits;

      const Perpendicular_optional&
      Perpendicular () const;

      Perpendicular_optional&
      Perpendicular ();

      void
      Perpendicular (const Perpendicular_type& x);

      void
      Perpendicular (const Perpendicular_optional& x);

      void
      Perpendicular (::std::unique_ptr< Perpendicular_type > p);

      // Parallel
      //
      typedef ::xsd::qif30::PlaneParallelType Parallel_type;
      typedef ::xsd::cxx::tree::optional< Parallel_type > Parallel_optional;
      typedef ::xsd::cxx::tree::traits< Parallel_type, wchar_t > Parallel_traits;

      const Parallel_optional&
      Parallel () const;

      Parallel_optional&
      Parallel ();

      void
      Parallel (const Parallel_type& x);

      void
      Parallel (const Parallel_optional& x);

      void
      Parallel (::std::unique_ptr< Parallel_type > p);

      // Copy
      //
      typedef ::xsd::qif30::PlaneCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::PlaneCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // TangentThrough
      //
      typedef ::xsd::qif30::PlaneTangentThroughType TangentThrough_type;
      typedef ::xsd::cxx::tree::optional< TangentThrough_type > TangentThrough_optional;
      typedef ::xsd::cxx::tree::traits< TangentThrough_type, wchar_t > TangentThrough_traits;

      const TangentThrough_optional&
      TangentThrough () const;

      TangentThrough_optional&
      TangentThrough ();

      void
      TangentThrough (const TangentThrough_type& x);

      void
      TangentThrough (const TangentThrough_optional& x);

      void
      TangentThrough (::std::unique_ptr< TangentThrough_type > p);

      // Through
      //
      typedef ::xsd::qif30::PlaneThroughType Through_type;
      typedef ::xsd::cxx::tree::optional< Through_type > Through_optional;
      typedef ::xsd::cxx::tree::traits< Through_type, wchar_t > Through_traits;

      const Through_optional&
      Through () const;

      Through_optional&
      Through ();

      void
      Through (const Through_type& x);

      void
      Through (const Through_optional& x);

      void
      Through (::std::unique_ptr< Through_type > p);

      // Transform
      //
      typedef ::xsd::qif30::PlaneTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Extract
      //
      typedef ::xsd::qif30::PlaneExtractType Extract_type;
      typedef ::xsd::cxx::tree::optional< Extract_type > Extract_optional;
      typedef ::xsd::cxx::tree::traits< Extract_type, wchar_t > Extract_traits;

      const Extract_optional&
      Extract () const;

      Extract_optional&
      Extract ();

      void
      Extract (const Extract_type& x);

      void
      Extract (const Extract_optional& x);

      void
      Extract (::std::unique_ptr< Extract_type > p);

      // Constructors.
      //
      PlaneConstructionMethodType ();

      PlaneConstructionMethodType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PlaneConstructionMethodType (const PlaneConstructionMethodType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PlaneConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneConstructionMethodType&
      operator= (const PlaneConstructionMethodType& x);

      virtual 
      ~PlaneConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Midplane_optional Midplane_;
      Offset_optional Offset_;
      Perpendicular_optional Perpendicular_;
      Parallel_optional Parallel_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      TangentThrough_optional TangentThrough_;
      Through_optional Through_;
      Transform_optional Transform_;
      Extract_optional Extract_;
    };

    class QIF30_SYMBOL_DECL PlaneBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PlaneBestFitType ();

      PlaneBestFitType (const n_type&);

      PlaneBestFitType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PlaneBestFitType (const PlaneBestFitType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PlaneBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneBestFitType&
      operator= (const PlaneBestFitType& x);

      virtual 
      ~PlaneBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PlaneRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      PlaneRecompType ();

      PlaneRecompType (const BaseFeaturePointList_type&);

      PlaneRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      PlaneRecompType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PlaneRecompType (const PlaneRecompType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual PlaneRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneRecompType&
      operator= (const PlaneRecompType& x);

      virtual 
      ~PlaneRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL PlaneMidplaneType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePlane
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BasePlane_type;
      typedef ::xsd::cxx::tree::sequence< BasePlane_type > BasePlane_sequence;
      typedef xsd::cxx::tree::sequence< BasePlane_type >::iterator BasePlane_iterator;
      typedef xsd::cxx::tree::sequence< BasePlane_type >::const_iterator BasePlane_const_iterator;
      typedef ::xsd::cxx::tree::traits< BasePlane_type, wchar_t > BasePlane_traits;

      const BasePlane_sequence&
      BasePlane () const;

      BasePlane_sequence&
      BasePlane ();

      void
      BasePlane (const BasePlane_sequence& s);

      // Constructors.
      //
      PlaneMidplaneType ();

      PlaneMidplaneType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PlaneMidplaneType (const PlaneMidplaneType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PlaneMidplaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneMidplaneType&
      operator= (const PlaneMidplaneType& x);

      virtual 
      ~PlaneMidplaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BasePlane_sequence BasePlane_;
    };

    class QIF30_SYMBOL_DECL PlaneOffsetType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePlane
      //
      typedef ::xsd::qif30::BaseFeatureType BasePlane_type;
      typedef ::xsd::cxx::tree::traits< BasePlane_type, wchar_t > BasePlane_traits;

      const BasePlane_type&
      BasePlane () const;

      BasePlane_type&
      BasePlane ();

      void
      BasePlane (const BasePlane_type& x);

      void
      BasePlane (::std::unique_ptr< BasePlane_type > p);

      // Offset
      //
      typedef ::xsd::qif30::LinearValueType Offset_type;
      typedef ::xsd::cxx::tree::traits< Offset_type, wchar_t > Offset_traits;

      const Offset_type&
      Offset () const;

      Offset_type&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (::std::unique_ptr< Offset_type > p);

      // Constructors.
      //
      PlaneOffsetType ();

      PlaneOffsetType (const BasePlane_type&,
                       const Offset_type&);

      PlaneOffsetType (::std::unique_ptr< BasePlane_type >,
                       ::std::unique_ptr< Offset_type >);

      PlaneOffsetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PlaneOffsetType (const PlaneOffsetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual PlaneOffsetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneOffsetType&
      operator= (const PlaneOffsetType& x);

      virtual 
      ~PlaneOffsetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePlane_type > BasePlane_;
      ::xsd::cxx::tree::one< Offset_type > Offset_;
    };

    class QIF30_SYMBOL_DECL PlanePerpendicularType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // PerpendicularFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PerpendicularFeature_type;
      typedef ::xsd::cxx::tree::traits< PerpendicularFeature_type, wchar_t > PerpendicularFeature_traits;

      const PerpendicularFeature_type&
      PerpendicularFeature () const;

      PerpendicularFeature_type&
      PerpendicularFeature ();

      void
      PerpendicularFeature (const PerpendicularFeature_type& x);

      void
      PerpendicularFeature (::std::unique_ptr< PerpendicularFeature_type > p);

      // PointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PointFeature_type;
      typedef ::xsd::cxx::tree::traits< PointFeature_type, wchar_t > PointFeature_traits;

      const PointFeature_type&
      PointFeature () const;

      PointFeature_type&
      PointFeature ();

      void
      PointFeature (const PointFeature_type& x);

      void
      PointFeature (::std::unique_ptr< PointFeature_type > p);

      // Constructors.
      //
      PlanePerpendicularType ();

      PlanePerpendicularType (const PerpendicularFeature_type&,
                              const PointFeature_type&);

      PlanePerpendicularType (::std::unique_ptr< PerpendicularFeature_type >,
                              ::std::unique_ptr< PointFeature_type >);

      PlanePerpendicularType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      PlanePerpendicularType (const PlanePerpendicularType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual PlanePerpendicularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlanePerpendicularType&
      operator= (const PlanePerpendicularType& x);

      virtual 
      ~PlanePerpendicularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PerpendicularFeature_type > PerpendicularFeature_;
      ::xsd::cxx::tree::one< PointFeature_type > PointFeature_;
    };

    class QIF30_SYMBOL_DECL PlaneParallelType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ParallelFeature
      //
      typedef ::xsd::qif30::BaseFeatureType ParallelFeature_type;
      typedef ::xsd::cxx::tree::traits< ParallelFeature_type, wchar_t > ParallelFeature_traits;

      const ParallelFeature_type&
      ParallelFeature () const;

      ParallelFeature_type&
      ParallelFeature ();

      void
      ParallelFeature (const ParallelFeature_type& x);

      void
      ParallelFeature (::std::unique_ptr< ParallelFeature_type > p);

      // PointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PointFeature_type;
      typedef ::xsd::cxx::tree::traits< PointFeature_type, wchar_t > PointFeature_traits;

      const PointFeature_type&
      PointFeature () const;

      PointFeature_type&
      PointFeature ();

      void
      PointFeature (const PointFeature_type& x);

      void
      PointFeature (::std::unique_ptr< PointFeature_type > p);

      // Constructors.
      //
      PlaneParallelType ();

      PlaneParallelType (const ParallelFeature_type&,
                         const PointFeature_type&);

      PlaneParallelType (::std::unique_ptr< ParallelFeature_type >,
                         ::std::unique_ptr< PointFeature_type >);

      PlaneParallelType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PlaneParallelType (const PlaneParallelType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PlaneParallelType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneParallelType&
      operator= (const PlaneParallelType& x);

      virtual 
      ~PlaneParallelType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ParallelFeature_type > ParallelFeature_;
      ::xsd::cxx::tree::one< PointFeature_type > PointFeature_;
    };

    class QIF30_SYMBOL_DECL PlaneCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePlane
      //
      typedef ::xsd::qif30::BaseFeatureType BasePlane_type;
      typedef ::xsd::cxx::tree::traits< BasePlane_type, wchar_t > BasePlane_traits;

      const BasePlane_type&
      BasePlane () const;

      BasePlane_type&
      BasePlane ();

      void
      BasePlane (const BasePlane_type& x);

      void
      BasePlane (::std::unique_ptr< BasePlane_type > p);

      // Constructors.
      //
      PlaneCopyType ();

      PlaneCopyType (const BasePlane_type&);

      PlaneCopyType (::std::unique_ptr< BasePlane_type >);

      PlaneCopyType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      PlaneCopyType (const PlaneCopyType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual PlaneCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneCopyType&
      operator= (const PlaneCopyType& x);

      virtual 
      ~PlaneCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePlane_type > BasePlane_;
    };

    class QIF30_SYMBOL_DECL PlaneCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      PlaneCastType ();

      PlaneCastType (const BaseFeature_type&);

      PlaneCastType (::std::unique_ptr< BaseFeature_type >);

      PlaneCastType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      PlaneCastType (const PlaneCastType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual PlaneCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneCastType&
      operator= (const PlaneCastType& x);

      virtual 
      ~PlaneCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL PlaneTangentThroughType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // TangentFeature
      //
      typedef ::xsd::qif30::BaseFeatureType TangentFeature_type;
      typedef ::xsd::cxx::tree::traits< TangentFeature_type, wchar_t > TangentFeature_traits;

      const TangentFeature_type&
      TangentFeature () const;

      TangentFeature_type&
      TangentFeature ();

      void
      TangentFeature (const TangentFeature_type& x);

      void
      TangentFeature (::std::unique_ptr< TangentFeature_type > p);

      // PointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType PointFeature_type;
      typedef ::xsd::cxx::tree::traits< PointFeature_type, wchar_t > PointFeature_traits;

      const PointFeature_type&
      PointFeature () const;

      PointFeature_type&
      PointFeature ();

      void
      PointFeature (const PointFeature_type& x);

      void
      PointFeature (::std::unique_ptr< PointFeature_type > p);

      // Constructors.
      //
      PlaneTangentThroughType ();

      PlaneTangentThroughType (const TangentFeature_type&,
                               const PointFeature_type&);

      PlaneTangentThroughType (::std::unique_ptr< TangentFeature_type >,
                               ::std::unique_ptr< PointFeature_type >);

      PlaneTangentThroughType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PlaneTangentThroughType (const PlaneTangentThroughType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PlaneTangentThroughType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneTangentThroughType&
      operator= (const PlaneTangentThroughType& x);

      virtual 
      ~PlaneTangentThroughType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TangentFeature_type > TangentFeature_;
      ::xsd::cxx::tree::one< PointFeature_type > PointFeature_;
    };

    class QIF30_SYMBOL_DECL PlaneThroughType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // Constructors.
      //
      PlaneThroughType ();

      PlaneThroughType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PlaneThroughType (const PlaneThroughType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PlaneThroughType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneThroughType&
      operator= (const PlaneThroughType& x);

      virtual 
      ~PlaneThroughType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
    };

    class QIF30_SYMBOL_DECL PlaneTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePlane
      //
      typedef ::xsd::qif30::BaseFeatureType BasePlane_type;
      typedef ::xsd::cxx::tree::traits< BasePlane_type, wchar_t > BasePlane_traits;

      const BasePlane_type&
      BasePlane () const;

      BasePlane_type&
      BasePlane ();

      void
      BasePlane (const BasePlane_type& x);

      void
      BasePlane (::std::unique_ptr< BasePlane_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      PlaneTransformType ();

      PlaneTransformType (const BasePlane_type&,
                          const Transformation_type&);

      PlaneTransformType (::std::unique_ptr< BasePlane_type >,
                          ::std::unique_ptr< Transformation_type >);

      PlaneTransformType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PlaneTransformType (const PlaneTransformType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual PlaneTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneTransformType&
      operator= (const PlaneTransformType& x);

      virtual 
      ~PlaneTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePlane_type > BasePlane_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL PlaneExtractType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // Constructors.
      //
      PlaneExtractType ();

      PlaneExtractType (const SurfaceFeature_type&);

      PlaneExtractType (::std::unique_ptr< SurfaceFeature_type >);

      PlaneExtractType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PlaneExtractType (const PlaneExtractType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PlaneExtractType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneExtractType&
      operator= (const PlaneExtractType& x);

      virtual 
      ~PlaneExtractType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
    };

    class QIF30_SYMBOL_DECL PlaneCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::PlaneConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      PlaneCheckedType ();

      PlaneCheckedType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PlaneCheckedType (const PlaneCheckedType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PlaneCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneCheckedType&
      operator= (const PlaneCheckedType& x);

      virtual 
      ~PlaneCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL PlaneCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::PlaneCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      PlaneCheckedFeatureType ();

      PlaneCheckedFeatureType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PlaneCheckedFeatureType (const PlaneCheckedFeatureType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PlaneCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneCheckedFeatureType&
      operator= (const PlaneCheckedFeatureType& x);

      virtual 
      ~PlaneCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL PlaneMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::PlaneCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      PlaneMeasurementDeterminationType ();

      PlaneMeasurementDeterminationType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      PlaneMeasurementDeterminationType (const PlaneMeasurementDeterminationType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual PlaneMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneMeasurementDeterminationType&
      operator= (const PlaneMeasurementDeterminationType& x);

      virtual 
      ~PlaneMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL PlaneFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::PlaneMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      PlaneFeatureItemType ();

      PlaneFeatureItemType (const id_type&,
                            const FeatureNominalId_type&,
                            const FeatureName_type&,
                            const DeterminationMode_type&);

      PlaneFeatureItemType (const id_type&,
                            ::std::unique_ptr< FeatureNominalId_type >,
                            const FeatureName_type&,
                            ::std::unique_ptr< DeterminationMode_type >);

      PlaneFeatureItemType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      PlaneFeatureItemType (const PlaneFeatureItemType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual PlaneFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneFeatureItemType&
      operator= (const PlaneFeatureItemType& x);

      virtual 
      ~PlaneFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL PlaneFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      PlaneFeatureDefinitionType ();

      PlaneFeatureDefinitionType (const id_type&);

      PlaneFeatureDefinitionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      PlaneFeatureDefinitionType (const PlaneFeatureDefinitionType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual PlaneFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PlaneFeatureDefinitionType&
      operator= (const PlaneFeatureDefinitionType&) = default;
#endif

      virtual 
      ~PlaneFeatureDefinitionType ();
    };

    class QIF30_SYMBOL_DECL PlaneFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // PolyLine
      //
      typedef ::xsd::qif30::PolyLineType PolyLine_type;
      typedef ::xsd::cxx::tree::optional< PolyLine_type > PolyLine_optional;
      typedef ::xsd::cxx::tree::traits< PolyLine_type, wchar_t > PolyLine_traits;

      const PolyLine_optional&
      PolyLine () const;

      PolyLine_optional&
      PolyLine ();

      void
      PolyLine (const PolyLine_type& x);

      void
      PolyLine (const PolyLine_optional& x);

      void
      PolyLine (::std::unique_ptr< PolyLine_type > p);

      // Rectangle
      //
      typedef ::xsd::qif30::RectangleType Rectangle_type;
      typedef ::xsd::cxx::tree::optional< Rectangle_type > Rectangle_optional;
      typedef ::xsd::cxx::tree::traits< Rectangle_type, wchar_t > Rectangle_traits;

      const Rectangle_optional&
      Rectangle () const;

      Rectangle_optional&
      Rectangle ();

      void
      Rectangle (const Rectangle_type& x);

      void
      Rectangle (const Rectangle_optional& x);

      void
      Rectangle (::std::unique_ptr< Rectangle_type > p);

      // Circle
      //
      typedef ::xsd::qif30::CircleType Circle_type;
      typedef ::xsd::cxx::tree::optional< Circle_type > Circle_optional;
      typedef ::xsd::cxx::tree::traits< Circle_type, wchar_t > Circle_traits;

      const Circle_optional&
      Circle () const;

      Circle_optional&
      Circle ();

      void
      Circle (const Circle_type& x);

      void
      Circle (const Circle_optional& x);

      void
      Circle (::std::unique_ptr< Circle_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::PlaneConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      PlaneFeatureNominalType ();

      PlaneFeatureNominalType (const id_type&,
                               const FeatureDefinitionId_type&,
                               const Location_type&,
                               const Normal_type&);

      PlaneFeatureNominalType (const id_type&,
                               ::std::unique_ptr< FeatureDefinitionId_type >,
                               ::std::unique_ptr< Location_type >,
                               ::std::unique_ptr< Normal_type >);

      PlaneFeatureNominalType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PlaneFeatureNominalType (const PlaneFeatureNominalType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PlaneFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneFeatureNominalType&
      operator= (const PlaneFeatureNominalType& x);

      virtual 
      ~PlaneFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      PolyLine_optional PolyLine_;
      Rectangle_optional Rectangle_;
      Circle_optional Circle_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL PlaneFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // PolyLine
      //
      typedef ::xsd::qif30::PolyLineType PolyLine_type;
      typedef ::xsd::cxx::tree::optional< PolyLine_type > PolyLine_optional;
      typedef ::xsd::cxx::tree::traits< PolyLine_type, wchar_t > PolyLine_traits;

      const PolyLine_optional&
      PolyLine () const;

      PolyLine_optional&
      PolyLine ();

      void
      PolyLine (const PolyLine_type& x);

      void
      PolyLine (const PolyLine_optional& x);

      void
      PolyLine (::std::unique_ptr< PolyLine_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      PlaneFeatureMeasurementType ();

      PlaneFeatureMeasurementType (const id_type&);

      PlaneFeatureMeasurementType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PlaneFeatureMeasurementType (const PlaneFeatureMeasurementType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PlaneFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneFeatureMeasurementType&
      operator= (const PlaneFeatureMeasurementType& x);

      virtual 
      ~PlaneFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      Normal_optional Normal_;
      PolyLine_optional PolyLine_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::PointDefinedCurveBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::PointDefinedCurveRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::PointDefinedCurveCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Transform
      //
      typedef ::xsd::qif30::PointDefinedCurveTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::PointDefinedCurveFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Extract
      //
      typedef ::xsd::qif30::PointDefinedCurveExtractType Extract_type;
      typedef ::xsd::cxx::tree::optional< Extract_type > Extract_optional;
      typedef ::xsd::cxx::tree::traits< Extract_type, wchar_t > Extract_traits;

      const Extract_optional&
      Extract () const;

      Extract_optional&
      Extract ();

      void
      Extract (const Extract_type& x);

      void
      Extract (const Extract_optional& x);

      void
      Extract (::std::unique_ptr< Extract_type > p);

      // Constructors.
      //
      PointDefinedCurveConstructionMethodType ();

      PointDefinedCurveConstructionMethodType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      PointDefinedCurveConstructionMethodType (const PointDefinedCurveConstructionMethodType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual PointDefinedCurveConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveConstructionMethodType&
      operator= (const PointDefinedCurveConstructionMethodType& x);

      virtual 
      ~PointDefinedCurveConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
      Extract_optional Extract_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PointDefinedCurveBestFitType ();

      PointDefinedCurveBestFitType (const n_type&);

      PointDefinedCurveBestFitType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      PointDefinedCurveBestFitType (const PointDefinedCurveBestFitType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual PointDefinedCurveBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveBestFitType&
      operator= (const PointDefinedCurveBestFitType& x);

      virtual 
      ~PointDefinedCurveBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      PointDefinedCurveRecompType ();

      PointDefinedCurveRecompType (const BaseFeaturePointList_type&);

      PointDefinedCurveRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      PointDefinedCurveRecompType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PointDefinedCurveRecompType (const PointDefinedCurveRecompType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PointDefinedCurveRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveRecompType&
      operator= (const PointDefinedCurveRecompType& x);

      virtual 
      ~PointDefinedCurveRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePointDefinedCurve
      //
      typedef ::xsd::qif30::BaseFeatureType BasePointDefinedCurve_type;
      typedef ::xsd::cxx::tree::traits< BasePointDefinedCurve_type, wchar_t > BasePointDefinedCurve_traits;

      const BasePointDefinedCurve_type&
      BasePointDefinedCurve () const;

      BasePointDefinedCurve_type&
      BasePointDefinedCurve ();

      void
      BasePointDefinedCurve (const BasePointDefinedCurve_type& x);

      void
      BasePointDefinedCurve (::std::unique_ptr< BasePointDefinedCurve_type > p);

      // Constructors.
      //
      PointDefinedCurveCopyType ();

      PointDefinedCurveCopyType (const BasePointDefinedCurve_type&);

      PointDefinedCurveCopyType (::std::unique_ptr< BasePointDefinedCurve_type >);

      PointDefinedCurveCopyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      PointDefinedCurveCopyType (const PointDefinedCurveCopyType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual PointDefinedCurveCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveCopyType&
      operator= (const PointDefinedCurveCopyType& x);

      virtual 
      ~PointDefinedCurveCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePointDefinedCurve_type > BasePointDefinedCurve_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePointDefinedCurve
      //
      typedef ::xsd::qif30::BaseFeatureType BasePointDefinedCurve_type;
      typedef ::xsd::cxx::tree::traits< BasePointDefinedCurve_type, wchar_t > BasePointDefinedCurve_traits;

      const BasePointDefinedCurve_type&
      BasePointDefinedCurve () const;

      BasePointDefinedCurve_type&
      BasePointDefinedCurve ();

      void
      BasePointDefinedCurve (const BasePointDefinedCurve_type& x);

      void
      BasePointDefinedCurve (::std::unique_ptr< BasePointDefinedCurve_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      PointDefinedCurveTransformType ();

      PointDefinedCurveTransformType (const BasePointDefinedCurve_type&,
                                      const Transformation_type&);

      PointDefinedCurveTransformType (::std::unique_ptr< BasePointDefinedCurve_type >,
                                      ::std::unique_ptr< Transformation_type >);

      PointDefinedCurveTransformType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PointDefinedCurveTransformType (const PointDefinedCurveTransformType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PointDefinedCurveTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveTransformType&
      operator= (const PointDefinedCurveTransformType& x);

      virtual 
      ~PointDefinedCurveTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePointDefinedCurve_type > BasePointDefinedCurve_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Constructors.
      //
      PointDefinedCurveFromScanType ();

      PointDefinedCurveFromScanType (const SurfaceFeature_type&,
                                     const SearchRadius_type&);

      PointDefinedCurveFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                                     ::std::unique_ptr< SearchRadius_type >);

      PointDefinedCurveFromScanType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      PointDefinedCurveFromScanType (const PointDefinedCurveFromScanType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual PointDefinedCurveFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveFromScanType&
      operator= (const PointDefinedCurveFromScanType& x);

      virtual 
      ~PointDefinedCurveFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveExtractType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // CurveFeature
      //
      typedef ::xsd::qif30::BaseFeatureType CurveFeature_type;
      typedef ::xsd::cxx::tree::traits< CurveFeature_type, wchar_t > CurveFeature_traits;

      const CurveFeature_type&
      CurveFeature () const;

      CurveFeature_type&
      CurveFeature ();

      void
      CurveFeature (const CurveFeature_type& x);

      void
      CurveFeature (::std::unique_ptr< CurveFeature_type > p);

      // Constructors.
      //
      PointDefinedCurveExtractType ();

      PointDefinedCurveExtractType (const CurveFeature_type&);

      PointDefinedCurveExtractType (::std::unique_ptr< CurveFeature_type >);

      PointDefinedCurveExtractType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      PointDefinedCurveExtractType (const PointDefinedCurveExtractType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual PointDefinedCurveExtractType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveExtractType&
      operator= (const PointDefinedCurveExtractType& x);

      virtual 
      ~PointDefinedCurveExtractType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CurveFeature_type > CurveFeature_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::PointDefinedCurveConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      PointDefinedCurveCheckedType ();

      PointDefinedCurveCheckedType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      PointDefinedCurveCheckedType (const PointDefinedCurveCheckedType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual PointDefinedCurveCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveCheckedType&
      operator= (const PointDefinedCurveCheckedType& x);

      virtual 
      ~PointDefinedCurveCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::PointDefinedCurveCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      PointDefinedCurveCheckedFeatureType ();

      PointDefinedCurveCheckedFeatureType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      PointDefinedCurveCheckedFeatureType (const PointDefinedCurveCheckedFeatureType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual PointDefinedCurveCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveCheckedFeatureType&
      operator= (const PointDefinedCurveCheckedFeatureType& x);

      virtual 
      ~PointDefinedCurveCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::PointDefinedCurveCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      PointDefinedCurveMeasurementDeterminationType ();

      PointDefinedCurveMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      PointDefinedCurveMeasurementDeterminationType (const PointDefinedCurveMeasurementDeterminationType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual PointDefinedCurveMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveMeasurementDeterminationType&
      operator= (const PointDefinedCurveMeasurementDeterminationType& x);

      virtual 
      ~PointDefinedCurveMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveFeatureItemType: public ::xsd::qif30::CurveFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::PointDefinedCurveMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      PointDefinedCurveFeatureItemType ();

      PointDefinedCurveFeatureItemType (const id_type&,
                                        const FeatureNominalId_type&,
                                        const FeatureName_type&,
                                        const DeterminationMode_type&);

      PointDefinedCurveFeatureItemType (const id_type&,
                                        ::std::unique_ptr< FeatureNominalId_type >,
                                        const FeatureName_type&,
                                        ::std::unique_ptr< DeterminationMode_type >);

      PointDefinedCurveFeatureItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      PointDefinedCurveFeatureItemType (const PointDefinedCurveFeatureItemType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual PointDefinedCurveFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveFeatureItemType&
      operator= (const PointDefinedCurveFeatureItemType& x);

      virtual 
      ~PointDefinedCurveFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveFeatureDefinitionType: public ::xsd::qif30::CurveFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      PointDefinedCurveFeatureDefinitionType ();

      PointDefinedCurveFeatureDefinitionType (const id_type&);

      PointDefinedCurveFeatureDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      PointDefinedCurveFeatureDefinitionType (const PointDefinedCurveFeatureDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual PointDefinedCurveFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointDefinedCurveFeatureDefinitionType&
      operator= (const PointDefinedCurveFeatureDefinitionType&) = default;
#endif

      virtual 
      ~PointDefinedCurveFeatureDefinitionType ();
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveFeatureNominalType: public ::xsd::qif30::CurveFeatureNominalBaseType
    {
      public:
      // DefiningPoints
      //
      typedef ::xsd::qif30::DefiningPointsNominalType DefiningPoints_type;
      typedef ::xsd::cxx::tree::traits< DefiningPoints_type, wchar_t > DefiningPoints_traits;

      const DefiningPoints_type&
      DefiningPoints () const;

      DefiningPoints_type&
      DefiningPoints ();

      void
      DefiningPoints (const DefiningPoints_type& x);

      void
      DefiningPoints (::std::unique_ptr< DefiningPoints_type > p);

      // Plane
      //
      typedef ::xsd::qif30::PlaneType Plane_type;
      typedef ::xsd::cxx::tree::optional< Plane_type > Plane_optional;
      typedef ::xsd::cxx::tree::traits< Plane_type, wchar_t > Plane_traits;

      const Plane_optional&
      Plane () const;

      Plane_optional&
      Plane ();

      void
      Plane (const Plane_type& x);

      void
      Plane (const Plane_optional& x);

      void
      Plane (::std::unique_ptr< Plane_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::PointDefinedCurveConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      PointDefinedCurveFeatureNominalType ();

      PointDefinedCurveFeatureNominalType (const id_type&,
                                           const FeatureDefinitionId_type&,
                                           const DefiningPoints_type&);

      PointDefinedCurveFeatureNominalType (const id_type&,
                                           ::std::unique_ptr< FeatureDefinitionId_type >,
                                           ::std::unique_ptr< DefiningPoints_type >);

      PointDefinedCurveFeatureNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      PointDefinedCurveFeatureNominalType (const PointDefinedCurveFeatureNominalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual PointDefinedCurveFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveFeatureNominalType&
      operator= (const PointDefinedCurveFeatureNominalType& x);

      virtual 
      ~PointDefinedCurveFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DefiningPoints_type > DefiningPoints_;
      Plane_optional Plane_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL DefiningPointsMeasurementType: public ::xml_schema::type
    {
      public:
      // DefiningPoint
      //
      typedef ::xsd::qif30::DefiningPointMeasurementType DefiningPoint_type;
      typedef ::xsd::cxx::tree::sequence< DefiningPoint_type > DefiningPoint_sequence;
      typedef xsd::cxx::tree::sequence< DefiningPoint_type >::iterator DefiningPoint_iterator;
      typedef xsd::cxx::tree::sequence< DefiningPoint_type >::const_iterator DefiningPoint_const_iterator;
      typedef ::xsd::cxx::tree::traits< DefiningPoint_type, wchar_t > DefiningPoint_traits;

      const DefiningPoint_sequence&
      DefiningPoint () const;

      DefiningPoint_sequence&
      DefiningPoint ();

      void
      DefiningPoint (const DefiningPoint_sequence& s);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // combinedUncertainty
      //
      typedef ::xml_schema::decimal combinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< combinedUncertainty_type > combinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< combinedUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > combinedUncertainty_traits;

      const combinedUncertainty_optional&
      combinedUncertainty () const;

      combinedUncertainty_optional&
      combinedUncertainty ();

      void
      combinedUncertainty (const combinedUncertainty_type& x);

      void
      combinedUncertainty (const combinedUncertainty_optional& x);

      // meanError
      //
      typedef ::xml_schema::decimal meanError_type;
      typedef ::xsd::cxx::tree::optional< meanError_type > meanError_optional;
      typedef ::xsd::cxx::tree::traits< meanError_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > meanError_traits;

      const meanError_optional&
      meanError () const;

      meanError_optional&
      meanError ();

      void
      meanError (const meanError_type& x);

      void
      meanError (const meanError_optional& x);

      // xCombinedUncertainty
      //
      typedef ::xml_schema::decimal xCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< xCombinedUncertainty_type > xCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< xCombinedUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > xCombinedUncertainty_traits;

      const xCombinedUncertainty_optional&
      xCombinedUncertainty () const;

      xCombinedUncertainty_optional&
      xCombinedUncertainty ();

      void
      xCombinedUncertainty (const xCombinedUncertainty_type& x);

      void
      xCombinedUncertainty (const xCombinedUncertainty_optional& x);

      // xMeanError
      //
      typedef ::xml_schema::decimal xMeanError_type;
      typedef ::xsd::cxx::tree::optional< xMeanError_type > xMeanError_optional;
      typedef ::xsd::cxx::tree::traits< xMeanError_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > xMeanError_traits;

      const xMeanError_optional&
      xMeanError () const;

      xMeanError_optional&
      xMeanError ();

      void
      xMeanError (const xMeanError_type& x);

      void
      xMeanError (const xMeanError_optional& x);

      // yCombinedUncertainty
      //
      typedef ::xml_schema::decimal yCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< yCombinedUncertainty_type > yCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< yCombinedUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > yCombinedUncertainty_traits;

      const yCombinedUncertainty_optional&
      yCombinedUncertainty () const;

      yCombinedUncertainty_optional&
      yCombinedUncertainty ();

      void
      yCombinedUncertainty (const yCombinedUncertainty_type& x);

      void
      yCombinedUncertainty (const yCombinedUncertainty_optional& x);

      // yMeanError
      //
      typedef ::xml_schema::decimal yMeanError_type;
      typedef ::xsd::cxx::tree::optional< yMeanError_type > yMeanError_optional;
      typedef ::xsd::cxx::tree::traits< yMeanError_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > yMeanError_traits;

      const yMeanError_optional&
      yMeanError () const;

      yMeanError_optional&
      yMeanError ();

      void
      yMeanError (const yMeanError_type& x);

      void
      yMeanError (const yMeanError_optional& x);

      // zCombinedUncertainty
      //
      typedef ::xml_schema::decimal zCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< zCombinedUncertainty_type > zCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< zCombinedUncertainty_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > zCombinedUncertainty_traits;

      const zCombinedUncertainty_optional&
      zCombinedUncertainty () const;

      zCombinedUncertainty_optional&
      zCombinedUncertainty ();

      void
      zCombinedUncertainty (const zCombinedUncertainty_type& x);

      void
      zCombinedUncertainty (const zCombinedUncertainty_optional& x);

      // zMeanError
      //
      typedef ::xml_schema::decimal zMeanError_type;
      typedef ::xsd::cxx::tree::optional< zMeanError_type > zMeanError_optional;
      typedef ::xsd::cxx::tree::traits< zMeanError_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > zMeanError_traits;

      const zMeanError_optional&
      zMeanError () const;

      zMeanError_optional&
      zMeanError ();

      void
      zMeanError (const zMeanError_type& x);

      void
      zMeanError (const zMeanError_optional& x);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DefiningPointsMeasurementType ();

      DefiningPointsMeasurementType (const n_type&);

      DefiningPointsMeasurementType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      DefiningPointsMeasurementType (const DefiningPointsMeasurementType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual DefiningPointsMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DefiningPointsMeasurementType&
      operator= (const DefiningPointsMeasurementType& x);

      virtual 
      ~DefiningPointsMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DefiningPoint_sequence DefiningPoint_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
      combinedUncertainty_optional combinedUncertainty_;
      meanError_optional meanError_;
      xCombinedUncertainty_optional xCombinedUncertainty_;
      xMeanError_optional xMeanError_;
      yCombinedUncertainty_optional yCombinedUncertainty_;
      yMeanError_optional yMeanError_;
      zCombinedUncertainty_optional zCombinedUncertainty_;
      zMeanError_optional zMeanError_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointDefinedCurveFeatureMeasurementType: public ::xsd::qif30::CurveFeatureMeasurementBaseType
    {
      public:
      // DefiningPoints
      //
      typedef ::xsd::qif30::DefiningPointsMeasurementType DefiningPoints_type;
      typedef ::xsd::cxx::tree::optional< DefiningPoints_type > DefiningPoints_optional;
      typedef ::xsd::cxx::tree::traits< DefiningPoints_type, wchar_t > DefiningPoints_traits;

      const DefiningPoints_optional&
      DefiningPoints () const;

      DefiningPoints_optional&
      DefiningPoints ();

      void
      DefiningPoints (const DefiningPoints_type& x);

      void
      DefiningPoints (const DefiningPoints_optional& x);

      void
      DefiningPoints (::std::unique_ptr< DefiningPoints_type > p);

      // Plane
      //
      typedef ::xsd::qif30::MeasuredPlaneType Plane_type;
      typedef ::xsd::cxx::tree::optional< Plane_type > Plane_optional;
      typedef ::xsd::cxx::tree::traits< Plane_type, wchar_t > Plane_traits;

      const Plane_optional&
      Plane () const;

      Plane_optional&
      Plane ();

      void
      Plane (const Plane_type& x);

      void
      Plane (const Plane_optional& x);

      void
      Plane (::std::unique_ptr< Plane_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      PointDefinedCurveFeatureMeasurementType ();

      PointDefinedCurveFeatureMeasurementType (const id_type&);

      PointDefinedCurveFeatureMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      PointDefinedCurveFeatureMeasurementType (const PointDefinedCurveFeatureMeasurementType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual PointDefinedCurveFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurveFeatureMeasurementType&
      operator= (const PointDefinedCurveFeatureMeasurementType& x);

      virtual 
      ~PointDefinedCurveFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DefiningPoints_optional DefiningPoints_;
      Plane_optional Plane_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::PointDefinedSurfaceBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::PointDefinedSurfaceRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::PointDefinedSurfaceCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Transform
      //
      typedef ::xsd::qif30::PointDefinedSurfaceTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Extract
      //
      typedef ::xsd::qif30::PointDefinedSurfaceExtractType Extract_type;
      typedef ::xsd::cxx::tree::optional< Extract_type > Extract_optional;
      typedef ::xsd::cxx::tree::traits< Extract_type, wchar_t > Extract_traits;

      const Extract_optional&
      Extract () const;

      Extract_optional&
      Extract ();

      void
      Extract (const Extract_type& x);

      void
      Extract (const Extract_optional& x);

      void
      Extract (::std::unique_ptr< Extract_type > p);

      // Constructors.
      //
      PointDefinedSurfaceConstructionMethodType ();

      PointDefinedSurfaceConstructionMethodType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PointDefinedSurfaceConstructionMethodType (const PointDefinedSurfaceConstructionMethodType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceConstructionMethodType&
      operator= (const PointDefinedSurfaceConstructionMethodType& x);

      virtual 
      ~PointDefinedSurfaceConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Transform_optional Transform_;
      Extract_optional Extract_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PointDefinedSurfaceBestFitType ();

      PointDefinedSurfaceBestFitType (const n_type&);

      PointDefinedSurfaceBestFitType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PointDefinedSurfaceBestFitType (const PointDefinedSurfaceBestFitType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceBestFitType&
      operator= (const PointDefinedSurfaceBestFitType& x);

      virtual 
      ~PointDefinedSurfaceBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      PointDefinedSurfaceRecompType ();

      PointDefinedSurfaceRecompType (const BaseFeaturePointList_type&);

      PointDefinedSurfaceRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      PointDefinedSurfaceRecompType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      PointDefinedSurfaceRecompType (const PointDefinedSurfaceRecompType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceRecompType&
      operator= (const PointDefinedSurfaceRecompType& x);

      virtual 
      ~PointDefinedSurfaceRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePointDefinedSurface
      //
      typedef ::xsd::qif30::BaseFeatureType BasePointDefinedSurface_type;
      typedef ::xsd::cxx::tree::traits< BasePointDefinedSurface_type, wchar_t > BasePointDefinedSurface_traits;

      const BasePointDefinedSurface_type&
      BasePointDefinedSurface () const;

      BasePointDefinedSurface_type&
      BasePointDefinedSurface ();

      void
      BasePointDefinedSurface (const BasePointDefinedSurface_type& x);

      void
      BasePointDefinedSurface (::std::unique_ptr< BasePointDefinedSurface_type > p);

      // Constructors.
      //
      PointDefinedSurfaceCopyType ();

      PointDefinedSurfaceCopyType (const BasePointDefinedSurface_type&);

      PointDefinedSurfaceCopyType (::std::unique_ptr< BasePointDefinedSurface_type >);

      PointDefinedSurfaceCopyType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PointDefinedSurfaceCopyType (const PointDefinedSurfaceCopyType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceCopyType&
      operator= (const PointDefinedSurfaceCopyType& x);

      virtual 
      ~PointDefinedSurfaceCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePointDefinedSurface_type > BasePointDefinedSurface_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePointDefinedSurface
      //
      typedef ::xsd::qif30::BaseFeatureType BasePointDefinedSurface_type;
      typedef ::xsd::cxx::tree::traits< BasePointDefinedSurface_type, wchar_t > BasePointDefinedSurface_traits;

      const BasePointDefinedSurface_type&
      BasePointDefinedSurface () const;

      BasePointDefinedSurface_type&
      BasePointDefinedSurface ();

      void
      BasePointDefinedSurface (const BasePointDefinedSurface_type& x);

      void
      BasePointDefinedSurface (::std::unique_ptr< BasePointDefinedSurface_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      PointDefinedSurfaceTransformType ();

      PointDefinedSurfaceTransformType (const BasePointDefinedSurface_type&,
                                        const Transformation_type&);

      PointDefinedSurfaceTransformType (::std::unique_ptr< BasePointDefinedSurface_type >,
                                        ::std::unique_ptr< Transformation_type >);

      PointDefinedSurfaceTransformType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      PointDefinedSurfaceTransformType (const PointDefinedSurfaceTransformType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceTransformType&
      operator= (const PointDefinedSurfaceTransformType& x);

      virtual 
      ~PointDefinedSurfaceTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePointDefinedSurface_type > BasePointDefinedSurface_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceExtractType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // Constructors.
      //
      PointDefinedSurfaceExtractType ();

      PointDefinedSurfaceExtractType (const SurfaceFeature_type&);

      PointDefinedSurfaceExtractType (::std::unique_ptr< SurfaceFeature_type >);

      PointDefinedSurfaceExtractType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PointDefinedSurfaceExtractType (const PointDefinedSurfaceExtractType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceExtractType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceExtractType&
      operator= (const PointDefinedSurfaceExtractType& x);

      virtual 
      ~PointDefinedSurfaceExtractType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::PointDefinedSurfaceConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      PointDefinedSurfaceCheckedType ();

      PointDefinedSurfaceCheckedType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PointDefinedSurfaceCheckedType (const PointDefinedSurfaceCheckedType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceCheckedType&
      operator= (const PointDefinedSurfaceCheckedType& x);

      virtual 
      ~PointDefinedSurfaceCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::PointDefinedSurfaceCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      PointDefinedSurfaceCheckedFeatureType ();

      PointDefinedSurfaceCheckedFeatureType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      PointDefinedSurfaceCheckedFeatureType (const PointDefinedSurfaceCheckedFeatureType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceCheckedFeatureType&
      operator= (const PointDefinedSurfaceCheckedFeatureType& x);

      virtual 
      ~PointDefinedSurfaceCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::PointDefinedSurfaceCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      PointDefinedSurfaceMeasurementDeterminationType ();

      PointDefinedSurfaceMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      PointDefinedSurfaceMeasurementDeterminationType (const PointDefinedSurfaceMeasurementDeterminationType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceMeasurementDeterminationType&
      operator= (const PointDefinedSurfaceMeasurementDeterminationType& x);

      virtual 
      ~PointDefinedSurfaceMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::PointDefinedSurfaceMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      PointDefinedSurfaceFeatureItemType ();

      PointDefinedSurfaceFeatureItemType (const id_type&,
                                          const FeatureNominalId_type&,
                                          const FeatureName_type&,
                                          const DeterminationMode_type&);

      PointDefinedSurfaceFeatureItemType (const id_type&,
                                          ::std::unique_ptr< FeatureNominalId_type >,
                                          const FeatureName_type&,
                                          ::std::unique_ptr< DeterminationMode_type >);

      PointDefinedSurfaceFeatureItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PointDefinedSurfaceFeatureItemType (const PointDefinedSurfaceFeatureItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceFeatureItemType&
      operator= (const PointDefinedSurfaceFeatureItemType& x);

      virtual 
      ~PointDefinedSurfaceFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      PointDefinedSurfaceFeatureDefinitionType ();

      PointDefinedSurfaceFeatureDefinitionType (const id_type&);

      PointDefinedSurfaceFeatureDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      PointDefinedSurfaceFeatureDefinitionType (const PointDefinedSurfaceFeatureDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointDefinedSurfaceFeatureDefinitionType&
      operator= (const PointDefinedSurfaceFeatureDefinitionType&) = default;
#endif

      virtual 
      ~PointDefinedSurfaceFeatureDefinitionType ();
    };

    class QIF30_SYMBOL_DECL DefiningPointsNominalType: public ::xml_schema::type
    {
      public:
      // DefiningPoint
      //
      typedef ::xsd::qif30::DefiningPointNominalType DefiningPoint_type;
      typedef ::xsd::cxx::tree::sequence< DefiningPoint_type > DefiningPoint_sequence;
      typedef xsd::cxx::tree::sequence< DefiningPoint_type >::iterator DefiningPoint_iterator;
      typedef xsd::cxx::tree::sequence< DefiningPoint_type >::const_iterator DefiningPoint_const_iterator;
      typedef ::xsd::cxx::tree::traits< DefiningPoint_type, wchar_t > DefiningPoint_traits;

      const DefiningPoint_sequence&
      DefiningPoint () const;

      DefiningPoint_sequence&
      DefiningPoint ();

      void
      DefiningPoint (const DefiningPoint_sequence& s);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif30::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, wchar_t > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::unique_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, wchar_t > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, wchar_t > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif30::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, wchar_t > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::unique_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, wchar_t > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, wchar_t > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif30::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, wchar_t > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::unique_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, wchar_t > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, wchar_t > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif30::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, wchar_t > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::unique_ptr< zValidity_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DefiningPointsNominalType ();

      DefiningPointsNominalType (const n_type&);

      DefiningPointsNominalType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      DefiningPointsNominalType (const DefiningPointsNominalType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual DefiningPointsNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DefiningPointsNominalType&
      operator= (const DefiningPointsNominalType& x);

      virtual 
      ~DefiningPointsNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DefiningPoint_sequence DefiningPoint_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // DefiningPoints
      //
      typedef ::xsd::qif30::DefiningPointsNominalType DefiningPoints_type;
      typedef ::xsd::cxx::tree::traits< DefiningPoints_type, wchar_t > DefiningPoints_traits;

      const DefiningPoints_type&
      DefiningPoints () const;

      DefiningPoints_type&
      DefiningPoints ();

      void
      DefiningPoints (const DefiningPoints_type& x);

      void
      DefiningPoints (::std::unique_ptr< DefiningPoints_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::PointDefinedSurfaceConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      PointDefinedSurfaceFeatureNominalType ();

      PointDefinedSurfaceFeatureNominalType (const id_type&,
                                             const FeatureDefinitionId_type&,
                                             const DefiningPoints_type&);

      PointDefinedSurfaceFeatureNominalType (const id_type&,
                                             ::std::unique_ptr< FeatureDefinitionId_type >,
                                             ::std::unique_ptr< DefiningPoints_type >);

      PointDefinedSurfaceFeatureNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      PointDefinedSurfaceFeatureNominalType (const PointDefinedSurfaceFeatureNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceFeatureNominalType&
      operator= (const PointDefinedSurfaceFeatureNominalType& x);

      virtual 
      ~PointDefinedSurfaceFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DefiningPoints_type > DefiningPoints_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL PointDefinedSurfaceFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // DefiningPoints
      //
      typedef ::xsd::qif30::DefiningPointsMeasurementType DefiningPoints_type;
      typedef ::xsd::cxx::tree::optional< DefiningPoints_type > DefiningPoints_optional;
      typedef ::xsd::cxx::tree::traits< DefiningPoints_type, wchar_t > DefiningPoints_traits;

      const DefiningPoints_optional&
      DefiningPoints () const;

      DefiningPoints_optional&
      DefiningPoints ();

      void
      DefiningPoints (const DefiningPoints_type& x);

      void
      DefiningPoints (const DefiningPoints_optional& x);

      void
      DefiningPoints (::std::unique_ptr< DefiningPoints_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      PointDefinedSurfaceFeatureMeasurementType ();

      PointDefinedSurfaceFeatureMeasurementType (const id_type&);

      PointDefinedSurfaceFeatureMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PointDefinedSurfaceFeatureMeasurementType (const PointDefinedSurfaceFeatureMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual PointDefinedSurfaceFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfaceFeatureMeasurementType&
      operator= (const PointDefinedSurfaceFeatureMeasurementType& x);

      virtual 
      ~PointDefinedSurfaceFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DefiningPoints_optional DefiningPoints_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL PointConstructionMethodType: public ::xml_schema::type
    {
      public:
      // Intersection
      //
      typedef ::xsd::qif30::PointFeatureIntersectionType Intersection_type;
      typedef ::xsd::cxx::tree::optional< Intersection_type > Intersection_optional;
      typedef ::xsd::cxx::tree::traits< Intersection_type, wchar_t > Intersection_traits;

      const Intersection_optional&
      Intersection () const;

      Intersection_optional&
      Intersection ();

      void
      Intersection (const Intersection_type& x);

      void
      Intersection (const Intersection_optional& x);

      void
      Intersection (::std::unique_ptr< Intersection_type > p);

      // Projection
      //
      typedef ::xsd::qif30::PointFeatureProjectionType Projection_type;
      typedef ::xsd::cxx::tree::optional< Projection_type > Projection_optional;
      typedef ::xsd::cxx::tree::traits< Projection_type, wchar_t > Projection_traits;

      const Projection_optional&
      Projection () const;

      Projection_optional&
      Projection ();

      void
      Projection (const Projection_type& x);

      void
      Projection (const Projection_optional& x);

      void
      Projection (::std::unique_ptr< Projection_type > p);

      // Copy
      //
      typedef ::xsd::qif30::PointFeatureCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::PointFeatureCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::PointFeatureTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromCone
      //
      typedef ::xsd::qif30::PointFeatureFromConeType FromCone_type;
      typedef ::xsd::cxx::tree::optional< FromCone_type > FromCone_optional;
      typedef ::xsd::cxx::tree::traits< FromCone_type, wchar_t > FromCone_traits;

      const FromCone_optional&
      FromCone () const;

      FromCone_optional&
      FromCone ();

      void
      FromCone (const FromCone_type& x);

      void
      FromCone (const FromCone_optional& x);

      void
      FromCone (::std::unique_ptr< FromCone_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::PointFeatureFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // CenterOfGravity
      //
      typedef ::xsd::qif30::PointFeatureCenterOfGravityType CenterOfGravity_type;
      typedef ::xsd::cxx::tree::optional< CenterOfGravity_type > CenterOfGravity_optional;
      typedef ::xsd::cxx::tree::traits< CenterOfGravity_type, wchar_t > CenterOfGravity_traits;

      const CenterOfGravity_optional&
      CenterOfGravity () const;

      CenterOfGravity_optional&
      CenterOfGravity ();

      void
      CenterOfGravity (const CenterOfGravity_type& x);

      void
      CenterOfGravity (const CenterOfGravity_optional& x);

      void
      CenterOfGravity (::std::unique_ptr< CenterOfGravity_type > p);

      // Pierce
      //
      typedef ::xsd::qif30::PointFeaturePierceType Pierce_type;
      typedef ::xsd::cxx::tree::optional< Pierce_type > Pierce_optional;
      typedef ::xsd::cxx::tree::traits< Pierce_type, wchar_t > Pierce_traits;

      const Pierce_optional&
      Pierce () const;

      Pierce_optional&
      Pierce ();

      void
      Pierce (const Pierce_type& x);

      void
      Pierce (const Pierce_optional& x);

      void
      Pierce (::std::unique_ptr< Pierce_type > p);

      // MidPoint
      //
      typedef ::xsd::qif30::PointFeatureMidPointType MidPoint_type;
      typedef ::xsd::cxx::tree::optional< MidPoint_type > MidPoint_optional;
      typedef ::xsd::cxx::tree::traits< MidPoint_type, wchar_t > MidPoint_traits;

      const MidPoint_optional&
      MidPoint () const;

      MidPoint_optional&
      MidPoint ();

      void
      MidPoint (const MidPoint_type& x);

      void
      MidPoint (const MidPoint_optional& x);

      void
      MidPoint (::std::unique_ptr< MidPoint_type > p);

      // MovePoint
      //
      typedef ::xsd::qif30::PointFeatureMovePointType MovePoint_type;
      typedef ::xsd::cxx::tree::optional< MovePoint_type > MovePoint_optional;
      typedef ::xsd::cxx::tree::traits< MovePoint_type, wchar_t > MovePoint_traits;

      const MovePoint_optional&
      MovePoint () const;

      MovePoint_optional&
      MovePoint ();

      void
      MovePoint (const MovePoint_type& x);

      void
      MovePoint (const MovePoint_optional& x);

      void
      MovePoint (::std::unique_ptr< MovePoint_type > p);

      // MovePointVector
      //
      typedef ::xsd::qif30::PointFeatureMovePointVectorType MovePointVector_type;
      typedef ::xsd::cxx::tree::optional< MovePointVector_type > MovePointVector_optional;
      typedef ::xsd::cxx::tree::traits< MovePointVector_type, wchar_t > MovePointVector_traits;

      const MovePointVector_optional&
      MovePointVector () const;

      MovePointVector_optional&
      MovePointVector ();

      void
      MovePointVector (const MovePointVector_type& x);

      void
      MovePointVector (const MovePointVector_optional& x);

      void
      MovePointVector (::std::unique_ptr< MovePointVector_type > p);

      // MovePointAxis
      //
      typedef ::xsd::qif30::PointFeatureMovePointAxisType MovePointAxis_type;
      typedef ::xsd::cxx::tree::optional< MovePointAxis_type > MovePointAxis_optional;
      typedef ::xsd::cxx::tree::traits< MovePointAxis_type, wchar_t > MovePointAxis_traits;

      const MovePointAxis_optional&
      MovePointAxis () const;

      MovePointAxis_optional&
      MovePointAxis ();

      void
      MovePointAxis (const MovePointAxis_type& x);

      void
      MovePointAxis (const MovePointAxis_optional& x);

      void
      MovePointAxis (::std::unique_ptr< MovePointAxis_type > p);

      // Extreme
      //
      typedef ::xsd::qif30::PointFeatureExtremeType Extreme_type;
      typedef ::xsd::cxx::tree::optional< Extreme_type > Extreme_optional;
      typedef ::xsd::cxx::tree::traits< Extreme_type, wchar_t > Extreme_traits;

      const Extreme_optional&
      Extreme () const;

      Extreme_optional&
      Extreme ();

      void
      Extreme (const Extreme_type& x);

      void
      Extreme (const Extreme_optional& x);

      void
      Extreme (::std::unique_ptr< Extreme_type > p);

      // Constructors.
      //
      PointConstructionMethodType ();

      PointConstructionMethodType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PointConstructionMethodType (const PointConstructionMethodType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PointConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointConstructionMethodType&
      operator= (const PointConstructionMethodType& x);

      virtual 
      ~PointConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Intersection_optional Intersection_;
      Projection_optional Projection_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromCone_optional FromCone_;
      FromScan_optional FromScan_;
      CenterOfGravity_optional CenterOfGravity_;
      Pierce_optional Pierce_;
      MidPoint_optional MidPoint_;
      MovePoint_optional MovePoint_;
      MovePointVector_optional MovePointVector_;
      MovePointAxis_optional MovePointAxis_;
      Extreme_optional Extreme_;
    };

    class QIF30_SYMBOL_DECL PointFeatureIntersectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // IntersectionFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType IntersectionFeature_type;
      typedef ::xsd::cxx::tree::sequence< IntersectionFeature_type > IntersectionFeature_sequence;
      typedef xsd::cxx::tree::sequence< IntersectionFeature_type >::iterator IntersectionFeature_iterator;
      typedef xsd::cxx::tree::sequence< IntersectionFeature_type >::const_iterator IntersectionFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< IntersectionFeature_type, wchar_t > IntersectionFeature_traits;

      const IntersectionFeature_sequence&
      IntersectionFeature () const;

      IntersectionFeature_sequence&
      IntersectionFeature ();

      void
      IntersectionFeature (const IntersectionFeature_sequence& s);

      // Constructors.
      //
      PointFeatureIntersectionType ();

      PointFeatureIntersectionType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      PointFeatureIntersectionType (const PointFeatureIntersectionType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual PointFeatureIntersectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureIntersectionType&
      operator= (const PointFeatureIntersectionType& x);

      virtual 
      ~PointFeatureIntersectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IntersectionFeature_sequence IntersectionFeature_;
    };

    class QIF30_SYMBOL_DECL PointFeaturePierceType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // CurveFeature
      //
      typedef ::xsd::qif30::BaseFeatureType CurveFeature_type;
      typedef ::xsd::cxx::tree::traits< CurveFeature_type, wchar_t > CurveFeature_traits;

      const CurveFeature_type&
      CurveFeature () const;

      CurveFeature_type&
      CurveFeature ();

      void
      CurveFeature (const CurveFeature_type& x);

      void
      CurveFeature (::std::unique_ptr< CurveFeature_type > p);

      // Constructors.
      //
      PointFeaturePierceType ();

      PointFeaturePierceType (const SurfaceFeature_type&,
                              const CurveFeature_type&);

      PointFeaturePierceType (::std::unique_ptr< SurfaceFeature_type >,
                              ::std::unique_ptr< CurveFeature_type >);

      PointFeaturePierceType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      PointFeaturePierceType (const PointFeaturePierceType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual PointFeaturePierceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeaturePierceType&
      operator= (const PointFeaturePierceType& x);

      virtual 
      ~PointFeaturePierceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< CurveFeature_type > CurveFeature_;
    };

    class QIF30_SYMBOL_DECL PointFeatureProjectionType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // ProjectionPlane
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionPlane_type;
      typedef ::xsd::cxx::tree::traits< ProjectionPlane_type, wchar_t > ProjectionPlane_traits;

      const ProjectionPlane_type&
      ProjectionPlane () const;

      ProjectionPlane_type&
      ProjectionPlane ();

      void
      ProjectionPlane (const ProjectionPlane_type& x);

      void
      ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > p);

      // ProjectionFeature
      //
      typedef ::xsd::qif30::BaseFeatureType ProjectionFeature_type;
      typedef ::xsd::cxx::tree::traits< ProjectionFeature_type, wchar_t > ProjectionFeature_traits;

      const ProjectionFeature_type&
      ProjectionFeature () const;

      ProjectionFeature_type&
      ProjectionFeature ();

      void
      ProjectionFeature (const ProjectionFeature_type& x);

      void
      ProjectionFeature (::std::unique_ptr< ProjectionFeature_type > p);

      // Constructors.
      //
      PointFeatureProjectionType ();

      PointFeatureProjectionType (const ProjectionPlane_type&,
                                  const ProjectionFeature_type&);

      PointFeatureProjectionType (::std::unique_ptr< ProjectionPlane_type >,
                                  ::std::unique_ptr< ProjectionFeature_type >);

      PointFeatureProjectionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      PointFeatureProjectionType (const PointFeatureProjectionType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual PointFeatureProjectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureProjectionType&
      operator= (const PointFeatureProjectionType& x);

      virtual 
      ~PointFeatureProjectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ProjectionPlane_type > ProjectionPlane_;
      ::xsd::cxx::tree::one< ProjectionFeature_type > ProjectionFeature_;
    };

    class QIF30_SYMBOL_DECL PointFeatureFromConeType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCone
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCone_type;
      typedef ::xsd::cxx::tree::traits< BaseCone_type, wchar_t > BaseCone_traits;

      const BaseCone_type&
      BaseCone () const;

      BaseCone_type&
      BaseCone ();

      void
      BaseCone (const BaseCone_type& x);

      void
      BaseCone (::std::unique_ptr< BaseCone_type > p);

      // Constructors.
      //
      PointFeatureFromConeType ();

      PointFeatureFromConeType (const BaseCone_type&);

      PointFeatureFromConeType (::std::unique_ptr< BaseCone_type >);

      PointFeatureFromConeType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      PointFeatureFromConeType (const PointFeatureFromConeType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual PointFeatureFromConeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureFromConeType&
      operator= (const PointFeatureFromConeType& x);

      virtual 
      ~PointFeatureFromConeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCone_type > BaseCone_;
    };

    class QIF30_SYMBOL_DECL PointFeatureCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BasePointFeature_type;
      typedef ::xsd::cxx::tree::traits< BasePointFeature_type, wchar_t > BasePointFeature_traits;

      const BasePointFeature_type&
      BasePointFeature () const;

      BasePointFeature_type&
      BasePointFeature ();

      void
      BasePointFeature (const BasePointFeature_type& x);

      void
      BasePointFeature (::std::unique_ptr< BasePointFeature_type > p);

      // Constructors.
      //
      PointFeatureCopyType ();

      PointFeatureCopyType (const BasePointFeature_type&);

      PointFeatureCopyType (::std::unique_ptr< BasePointFeature_type >);

      PointFeatureCopyType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      PointFeatureCopyType (const PointFeatureCopyType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual PointFeatureCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureCopyType&
      operator= (const PointFeatureCopyType& x);

      virtual 
      ~PointFeatureCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePointFeature_type > BasePointFeature_;
    };

    class QIF30_SYMBOL_DECL PointFeatureTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BasePointFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BasePointFeature_type;
      typedef ::xsd::cxx::tree::traits< BasePointFeature_type, wchar_t > BasePointFeature_traits;

      const BasePointFeature_type&
      BasePointFeature () const;

      BasePointFeature_type&
      BasePointFeature ();

      void
      BasePointFeature (const BasePointFeature_type& x);

      void
      BasePointFeature (::std::unique_ptr< BasePointFeature_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      PointFeatureTransformType ();

      PointFeatureTransformType (const BasePointFeature_type&,
                                 const Transformation_type&);

      PointFeatureTransformType (::std::unique_ptr< BasePointFeature_type >,
                                 ::std::unique_ptr< Transformation_type >);

      PointFeatureTransformType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      PointFeatureTransformType (const PointFeatureTransformType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual PointFeatureTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureTransformType&
      operator= (const PointFeatureTransformType& x);

      virtual 
      ~PointFeatureTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BasePointFeature_type > BasePointFeature_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL PointFeatureFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // RetrievalMethod
      //
      typedef ::xsd::qif30::RetrievalMethodEnumType RetrievalMethod_type;
      typedef ::xsd::cxx::tree::traits< RetrievalMethod_type, wchar_t > RetrievalMethod_traits;

      const RetrievalMethod_type&
      RetrievalMethod () const;

      RetrievalMethod_type&
      RetrievalMethod ();

      void
      RetrievalMethod (const RetrievalMethod_type& x);

      void
      RetrievalMethod (::std::unique_ptr< RetrievalMethod_type > p);

      // Constructors.
      //
      PointFeatureFromScanType ();

      PointFeatureFromScanType (const SurfaceFeature_type&,
                                const SearchRadius_type&,
                                const RetrievalMethod_type&);

      PointFeatureFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                                ::std::unique_ptr< SearchRadius_type >,
                                const RetrievalMethod_type&);

      PointFeatureFromScanType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      PointFeatureFromScanType (const PointFeatureFromScanType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual PointFeatureFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureFromScanType&
      operator= (const PointFeatureFromScanType& x);

      virtual 
      ~PointFeatureFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      ::xsd::cxx::tree::one< RetrievalMethod_type > RetrievalMethod_;
    };

    class QIF30_SYMBOL_DECL PointFeatureCenterOfGravityType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PointFeatureCenterOfGravityType ();

      PointFeatureCenterOfGravityType (const n_type&);

      PointFeatureCenterOfGravityType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      PointFeatureCenterOfGravityType (const PointFeatureCenterOfGravityType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual PointFeatureCenterOfGravityType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureCenterOfGravityType&
      operator= (const PointFeatureCenterOfGravityType& x);

      virtual 
      ~PointFeatureCenterOfGravityType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointFeatureMidPointType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // Constructors.
      //
      PointFeatureMidPointType ();

      PointFeatureMidPointType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      PointFeatureMidPointType (const PointFeatureMidPointType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual PointFeatureMidPointType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureMidPointType&
      operator= (const PointFeatureMidPointType& x);

      virtual 
      ~PointFeatureMidPointType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
    };

    class QIF30_SYMBOL_DECL PointFeatureCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      PointFeatureCastType ();

      PointFeatureCastType (const BaseFeature_type&);

      PointFeatureCastType (::std::unique_ptr< BaseFeature_type >);

      PointFeatureCastType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      PointFeatureCastType (const PointFeatureCastType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual PointFeatureCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureCastType&
      operator= (const PointFeatureCastType& x);

      virtual 
      ~PointFeatureCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL PointFeatureMovePointType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Offset
      //
      typedef ::xsd::qif30::VectorType Offset_type;
      typedef ::xsd::cxx::tree::optional< Offset_type > Offset_optional;
      typedef ::xsd::cxx::tree::traits< Offset_type, wchar_t > Offset_traits;

      const Offset_optional&
      Offset () const;

      Offset_optional&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (const Offset_optional& x);

      void
      Offset (::std::unique_ptr< Offset_type > p);

      // DirectionalOffset
      //
      typedef ::xsd::qif30::DirectionalOffsetType DirectionalOffset_type;
      typedef ::xsd::cxx::tree::optional< DirectionalOffset_type > DirectionalOffset_optional;
      typedef ::xsd::cxx::tree::traits< DirectionalOffset_type, wchar_t > DirectionalOffset_traits;

      const DirectionalOffset_optional&
      DirectionalOffset () const;

      DirectionalOffset_optional&
      DirectionalOffset ();

      void
      DirectionalOffset (const DirectionalOffset_type& x);

      void
      DirectionalOffset (const DirectionalOffset_optional& x);

      void
      DirectionalOffset (::std::unique_ptr< DirectionalOffset_type > p);

      // Constructors.
      //
      PointFeatureMovePointType ();

      PointFeatureMovePointType (const BaseFeature_type&);

      PointFeatureMovePointType (::std::unique_ptr< BaseFeature_type >);

      PointFeatureMovePointType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      PointFeatureMovePointType (const PointFeatureMovePointType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual PointFeatureMovePointType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureMovePointType&
      operator= (const PointFeatureMovePointType& x);

      virtual 
      ~PointFeatureMovePointType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
      Offset_optional Offset_;
      DirectionalOffset_optional DirectionalOffset_;
    };

    class QIF30_SYMBOL_DECL PointFeatureMovePointVectorType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Distance
      //
      typedef ::xsd::qif30::LinearValueType Distance_type;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t > Distance_traits;

      const Distance_type&
      Distance () const;

      Distance_type&
      Distance ();

      void
      Distance (const Distance_type& x);

      void
      Distance (::std::unique_ptr< Distance_type > p);

      // Vector
      //
      typedef ::xsd::qif30::UnitVectorType Vector_type;
      typedef ::xsd::cxx::tree::traits< Vector_type, wchar_t > Vector_traits;

      const Vector_type&
      Vector () const;

      Vector_type&
      Vector ();

      void
      Vector (const Vector_type& x);

      void
      Vector (::std::unique_ptr< Vector_type > p);

      // Constructors.
      //
      PointFeatureMovePointVectorType ();

      PointFeatureMovePointVectorType (const BaseFeature_type&,
                                       const Distance_type&,
                                       const Vector_type&);

      PointFeatureMovePointVectorType (::std::unique_ptr< BaseFeature_type >,
                                       ::std::unique_ptr< Distance_type >,
                                       ::std::unique_ptr< Vector_type >);

      PointFeatureMovePointVectorType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      PointFeatureMovePointVectorType (const PointFeatureMovePointVectorType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual PointFeatureMovePointVectorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureMovePointVectorType&
      operator= (const PointFeatureMovePointVectorType& x);

      virtual 
      ~PointFeatureMovePointVectorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
      ::xsd::cxx::tree::one< Distance_type > Distance_;
      ::xsd::cxx::tree::one< Vector_type > Vector_;
    };

    class QIF30_SYMBOL_DECL PointFeatureMovePointAxisType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseLocationFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseLocationFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseLocationFeature_type, wchar_t > BaseLocationFeature_traits;

      const BaseLocationFeature_type&
      BaseLocationFeature () const;

      BaseLocationFeature_type&
      BaseLocationFeature ();

      void
      BaseLocationFeature (const BaseLocationFeature_type& x);

      void
      BaseLocationFeature (::std::unique_ptr< BaseLocationFeature_type > p);

      // Distance
      //
      typedef ::xsd::qif30::LinearValueType Distance_type;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t > Distance_traits;

      const Distance_type&
      Distance () const;

      Distance_type&
      Distance ();

      void
      Distance (const Distance_type& x);

      void
      Distance (::std::unique_ptr< Distance_type > p);

      // BaseAxisFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseAxisFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseAxisFeature_type, wchar_t > BaseAxisFeature_traits;

      const BaseAxisFeature_type&
      BaseAxisFeature () const;

      BaseAxisFeature_type&
      BaseAxisFeature ();

      void
      BaseAxisFeature (const BaseAxisFeature_type& x);

      void
      BaseAxisFeature (::std::unique_ptr< BaseAxisFeature_type > p);

      // Constructors.
      //
      PointFeatureMovePointAxisType ();

      PointFeatureMovePointAxisType (const BaseLocationFeature_type&,
                                     const Distance_type&,
                                     const BaseAxisFeature_type&);

      PointFeatureMovePointAxisType (::std::unique_ptr< BaseLocationFeature_type >,
                                     ::std::unique_ptr< Distance_type >,
                                     ::std::unique_ptr< BaseAxisFeature_type >);

      PointFeatureMovePointAxisType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      PointFeatureMovePointAxisType (const PointFeatureMovePointAxisType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual PointFeatureMovePointAxisType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureMovePointAxisType&
      operator= (const PointFeatureMovePointAxisType& x);

      virtual 
      ~PointFeatureMovePointAxisType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseLocationFeature_type > BaseLocationFeature_;
      ::xsd::cxx::tree::one< Distance_type > Distance_;
      ::xsd::cxx::tree::one< BaseAxisFeature_type > BaseAxisFeature_;
    };

    class QIF30_SYMBOL_DECL PointFeatureExtremeType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Minimum
      //
      typedef ::xml_schema::boolean Minimum_type;
      typedef ::xsd::cxx::tree::traits< Minimum_type, wchar_t > Minimum_traits;

      const Minimum_type&
      Minimum () const;

      Minimum_type&
      Minimum ();

      void
      Minimum (const Minimum_type& x);

      static Minimum_type
      Minimum_default_value ();

      // BaseAxisFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseAxisFeature_type;
      typedef ::xsd::cxx::tree::optional< BaseAxisFeature_type > BaseAxisFeature_optional;
      typedef ::xsd::cxx::tree::traits< BaseAxisFeature_type, wchar_t > BaseAxisFeature_traits;

      const BaseAxisFeature_optional&
      BaseAxisFeature () const;

      BaseAxisFeature_optional&
      BaseAxisFeature ();

      void
      BaseAxisFeature (const BaseAxisFeature_type& x);

      void
      BaseAxisFeature (const BaseAxisFeature_optional& x);

      void
      BaseAxisFeature (::std::unique_ptr< BaseAxisFeature_type > p);

      // Vector
      //
      typedef ::xsd::qif30::UnitVectorType Vector_type;
      typedef ::xsd::cxx::tree::optional< Vector_type > Vector_optional;
      typedef ::xsd::cxx::tree::traits< Vector_type, wchar_t > Vector_traits;

      const Vector_optional&
      Vector () const;

      Vector_optional&
      Vector ();

      void
      Vector (const Vector_type& x);

      void
      Vector (const Vector_optional& x);

      void
      Vector (::std::unique_ptr< Vector_type > p);

      // Radial
      //
      typedef ::xml_schema::token Radial_type;
      typedef ::xsd::cxx::tree::optional< Radial_type > Radial_optional;
      typedef ::xsd::cxx::tree::traits< Radial_type, wchar_t > Radial_traits;

      const Radial_optional&
      Radial () const;

      Radial_optional&
      Radial ();

      void
      Radial (const Radial_type& x);

      void
      Radial (const Radial_optional& x);

      void
      Radial (::std::unique_ptr< Radial_type > p);

      static const Radial_type&
      Radial_default_value ();

      // Xaxis
      //
      typedef ::xml_schema::token Xaxis_type;
      typedef ::xsd::cxx::tree::optional< Xaxis_type > Xaxis_optional;
      typedef ::xsd::cxx::tree::traits< Xaxis_type, wchar_t > Xaxis_traits;

      const Xaxis_optional&
      Xaxis () const;

      Xaxis_optional&
      Xaxis ();

      void
      Xaxis (const Xaxis_type& x);

      void
      Xaxis (const Xaxis_optional& x);

      void
      Xaxis (::std::unique_ptr< Xaxis_type > p);

      static const Xaxis_type&
      Xaxis_default_value ();

      // Yaxis
      //
      typedef ::xml_schema::token Yaxis_type;
      typedef ::xsd::cxx::tree::optional< Yaxis_type > Yaxis_optional;
      typedef ::xsd::cxx::tree::traits< Yaxis_type, wchar_t > Yaxis_traits;

      const Yaxis_optional&
      Yaxis () const;

      Yaxis_optional&
      Yaxis ();

      void
      Yaxis (const Yaxis_type& x);

      void
      Yaxis (const Yaxis_optional& x);

      void
      Yaxis (::std::unique_ptr< Yaxis_type > p);

      static const Yaxis_type&
      Yaxis_default_value ();

      // Zaxis
      //
      typedef ::xml_schema::token Zaxis_type;
      typedef ::xsd::cxx::tree::optional< Zaxis_type > Zaxis_optional;
      typedef ::xsd::cxx::tree::traits< Zaxis_type, wchar_t > Zaxis_traits;

      const Zaxis_optional&
      Zaxis () const;

      Zaxis_optional&
      Zaxis ();

      void
      Zaxis (const Zaxis_type& x);

      void
      Zaxis (const Zaxis_optional& x);

      void
      Zaxis (::std::unique_ptr< Zaxis_type > p);

      static const Zaxis_type&
      Zaxis_default_value ();

      // Constructors.
      //
      PointFeatureExtremeType ();

      PointFeatureExtremeType (const BaseFeature_type&,
                               const Minimum_type&);

      PointFeatureExtremeType (::std::unique_ptr< BaseFeature_type >,
                               const Minimum_type&);

      PointFeatureExtremeType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PointFeatureExtremeType (const PointFeatureExtremeType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PointFeatureExtremeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureExtremeType&
      operator= (const PointFeatureExtremeType& x);

      virtual 
      ~PointFeatureExtremeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
      ::xsd::cxx::tree::one< Minimum_type > Minimum_;
      BaseAxisFeature_optional BaseAxisFeature_;
      Vector_optional Vector_;
      Radial_optional Radial_;
      static const Radial_type Radial_default_value_;
      Xaxis_optional Xaxis_;
      static const Xaxis_type Xaxis_default_value_;
      Yaxis_optional Yaxis_;
      static const Yaxis_type Yaxis_default_value_;
      Zaxis_optional Zaxis_;
      static const Zaxis_type Zaxis_default_value_;
    };

    class QIF30_SYMBOL_DECL PointCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::PointConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      PointCheckedType ();

      PointCheckedType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PointCheckedType (const PointCheckedType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PointCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointCheckedType&
      operator= (const PointCheckedType& x);

      virtual 
      ~PointCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL PointCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::PointCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      PointCheckedFeatureType ();

      PointCheckedFeatureType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PointCheckedFeatureType (const PointCheckedFeatureType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PointCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointCheckedFeatureType&
      operator= (const PointCheckedFeatureType& x);

      virtual 
      ~PointCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL PointMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::PointCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      PointMeasurementDeterminationType ();

      PointMeasurementDeterminationType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      PointMeasurementDeterminationType (const PointMeasurementDeterminationType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual PointMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointMeasurementDeterminationType&
      operator= (const PointMeasurementDeterminationType& x);

      virtual 
      ~PointMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL PointFeatureItemType: public ::xsd::qif30::PointFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::PointMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      PointFeatureItemType ();

      PointFeatureItemType (const id_type&,
                            const FeatureNominalId_type&,
                            const FeatureName_type&,
                            const DeterminationMode_type&);

      PointFeatureItemType (const id_type&,
                            ::std::unique_ptr< FeatureNominalId_type >,
                            const FeatureName_type&,
                            ::std::unique_ptr< DeterminationMode_type >);

      PointFeatureItemType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      PointFeatureItemType (const PointFeatureItemType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual PointFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureItemType&
      operator= (const PointFeatureItemType& x);

      virtual 
      ~PointFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL PointFeatureDefinitionType: public ::xsd::qif30::PointFeatureDefinitionBaseType
    {
      public:
      // Constructors.
      //
      PointFeatureDefinitionType ();

      PointFeatureDefinitionType (const id_type&);

      PointFeatureDefinitionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      PointFeatureDefinitionType (const PointFeatureDefinitionType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual PointFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointFeatureDefinitionType&
      operator= (const PointFeatureDefinitionType&) = default;
#endif

      virtual 
      ~PointFeatureDefinitionType ();
    };

    class QIF30_SYMBOL_DECL PointFeatureNominalType: public ::xsd::qif30::PointFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::PointConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      PointFeatureNominalType ();

      PointFeatureNominalType (const id_type&,
                               const FeatureDefinitionId_type&,
                               const Location_type&);

      PointFeatureNominalType (const id_type&,
                               ::std::unique_ptr< FeatureDefinitionId_type >,
                               ::std::unique_ptr< Location_type >);

      PointFeatureNominalType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PointFeatureNominalType (const PointFeatureNominalType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PointFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureNominalType&
      operator= (const PointFeatureNominalType& x);

      virtual 
      ~PointFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      Normal_optional Normal_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL PointFeatureMeasurementType: public ::xsd::qif30::PointFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructors.
      //
      PointFeatureMeasurementType ();

      PointFeatureMeasurementType (const id_type&);

      PointFeatureMeasurementType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PointFeatureMeasurementType (const PointFeatureMeasurementType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PointFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointFeatureMeasurementType&
      operator= (const PointFeatureMeasurementType& x);

      virtual 
      ~PointFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      Normal_optional Normal_;
    };

    class QIF30_SYMBOL_DECL SphereConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::SphereBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::SphereRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::SphereCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::SphereCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::SphereTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::SphereFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      SphereConstructionMethodType ();

      SphereConstructionMethodType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SphereConstructionMethodType (const SphereConstructionMethodType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SphereConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereConstructionMethodType&
      operator= (const SphereConstructionMethodType& x);

      virtual 
      ~SphereConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL SphereBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SphereBestFitType ();

      SphereBestFitType (const n_type&);

      SphereBestFitType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      SphereBestFitType (const SphereBestFitType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual SphereBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereBestFitType&
      operator= (const SphereBestFitType& x);

      virtual 
      ~SphereBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SphereRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      SphereRecompType ();

      SphereRecompType (const BaseFeaturePointList_type&);

      SphereRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      SphereRecompType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SphereRecompType (const SphereRecompType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SphereRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereRecompType&
      operator= (const SphereRecompType& x);

      virtual 
      ~SphereRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL SphereCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseSphere
      //
      typedef ::xsd::qif30::BaseFeatureType BaseSphere_type;
      typedef ::xsd::cxx::tree::traits< BaseSphere_type, wchar_t > BaseSphere_traits;

      const BaseSphere_type&
      BaseSphere () const;

      BaseSphere_type&
      BaseSphere ();

      void
      BaseSphere (const BaseSphere_type& x);

      void
      BaseSphere (::std::unique_ptr< BaseSphere_type > p);

      // Constructors.
      //
      SphereCopyType ();

      SphereCopyType (const BaseSphere_type&);

      SphereCopyType (::std::unique_ptr< BaseSphere_type >);

      SphereCopyType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SphereCopyType (const SphereCopyType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SphereCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereCopyType&
      operator= (const SphereCopyType& x);

      virtual 
      ~SphereCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseSphere_type > BaseSphere_;
    };

    class QIF30_SYMBOL_DECL SphereCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      SphereCastType ();

      SphereCastType (const BaseFeature_type&);

      SphereCastType (::std::unique_ptr< BaseFeature_type >);

      SphereCastType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SphereCastType (const SphereCastType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SphereCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereCastType&
      operator= (const SphereCastType& x);

      virtual 
      ~SphereCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL SphereTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseSphere
      //
      typedef ::xsd::qif30::BaseFeatureType BaseSphere_type;
      typedef ::xsd::cxx::tree::traits< BaseSphere_type, wchar_t > BaseSphere_traits;

      const BaseSphere_type&
      BaseSphere () const;

      BaseSphere_type&
      BaseSphere ();

      void
      BaseSphere (const BaseSphere_type& x);

      void
      BaseSphere (::std::unique_ptr< BaseSphere_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      SphereTransformType ();

      SphereTransformType (const BaseSphere_type&,
                           const Transformation_type&);

      SphereTransformType (::std::unique_ptr< BaseSphere_type >,
                           ::std::unique_ptr< Transformation_type >);

      SphereTransformType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      SphereTransformType (const SphereTransformType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual SphereTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereTransformType&
      operator= (const SphereTransformType& x);

      virtual 
      ~SphereTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseSphere_type > BaseSphere_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL SphereFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Vector
      //
      typedef ::xsd::qif30::UnitVectorType Vector_type;
      typedef ::xsd::cxx::tree::optional< Vector_type > Vector_optional;
      typedef ::xsd::cxx::tree::traits< Vector_type, wchar_t > Vector_traits;

      const Vector_optional&
      Vector () const;

      Vector_optional&
      Vector ();

      void
      Vector (const Vector_type& x);

      void
      Vector (const Vector_optional& x);

      void
      Vector (::std::unique_ptr< Vector_type > p);

      // Constructors.
      //
      SphereFromScanType ();

      SphereFromScanType (const SurfaceFeature_type&,
                          const SearchRadius_type&);

      SphereFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                          ::std::unique_ptr< SearchRadius_type >);

      SphereFromScanType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SphereFromScanType (const SphereFromScanType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SphereFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereFromScanType&
      operator= (const SphereFromScanType& x);

      virtual 
      ~SphereFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
      Vector_optional Vector_;
    };

    class QIF30_SYMBOL_DECL SphereCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::SphereConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      SphereCheckedType ();

      SphereCheckedType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      SphereCheckedType (const SphereCheckedType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual SphereCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereCheckedType&
      operator= (const SphereCheckedType& x);

      virtual 
      ~SphereCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL SphereCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::SphereCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      SphereCheckedFeatureType ();

      SphereCheckedFeatureType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SphereCheckedFeatureType (const SphereCheckedFeatureType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual SphereCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereCheckedFeatureType&
      operator= (const SphereCheckedFeatureType& x);

      virtual 
      ~SphereCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL SphereMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::SphereCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      SphereMeasurementDeterminationType ();

      SphereMeasurementDeterminationType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SphereMeasurementDeterminationType (const SphereMeasurementDeterminationType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SphereMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereMeasurementDeterminationType&
      operator= (const SphereMeasurementDeterminationType& x);

      virtual 
      ~SphereMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL SphereFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::SphereMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      SphereFeatureItemType ();

      SphereFeatureItemType (const id_type&,
                             const FeatureNominalId_type&,
                             const FeatureName_type&,
                             const DeterminationMode_type&);

      SphereFeatureItemType (const id_type&,
                             ::std::unique_ptr< FeatureNominalId_type >,
                             const FeatureName_type&,
                             ::std::unique_ptr< DeterminationMode_type >);

      SphereFeatureItemType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      SphereFeatureItemType (const SphereFeatureItemType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual SphereFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereFeatureItemType&
      operator= (const SphereFeatureItemType& x);

      virtual 
      ~SphereFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL SphereFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Constructors.
      //
      SphereFeatureDefinitionType ();

      SphereFeatureDefinitionType (const id_type&,
                                   const InternalExternal_type&,
                                   const Diameter_type&);

      SphereFeatureDefinitionType (const id_type&,
                                   const InternalExternal_type&,
                                   ::std::unique_ptr< Diameter_type >);

      SphereFeatureDefinitionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SphereFeatureDefinitionType (const SphereFeatureDefinitionType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SphereFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereFeatureDefinitionType&
      operator= (const SphereFeatureDefinitionType& x);

      virtual 
      ~SphereFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
    };

    class QIF30_SYMBOL_DECL SphereFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // LatitudeLongitudeSweep
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweep_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweep_type, wchar_t > LatitudeLongitudeSweep_traits;

      const LatitudeLongitudeSweep_optional&
      LatitudeLongitudeSweep () const;

      LatitudeLongitudeSweep_optional&
      LatitudeLongitudeSweep ();

      void
      LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x);

      void
      LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x);

      void
      LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::SphereConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      SphereFeatureNominalType ();

      SphereFeatureNominalType (const id_type&,
                                const FeatureDefinitionId_type&,
                                const Location_type&);

      SphereFeatureNominalType (const id_type&,
                                ::std::unique_ptr< FeatureDefinitionId_type >,
                                ::std::unique_ptr< Location_type >);

      SphereFeatureNominalType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SphereFeatureNominalType (const SphereFeatureNominalType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual SphereFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereFeatureNominalType&
      operator= (const SphereFeatureNominalType& x);

      virtual 
      ~SphereFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      LatitudeLongitudeSweep_optional LatitudeLongitudeSweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL SphereFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // LatitudeLongitudeSweepMeasurementRange
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweepMeasurementRange_type > LatitudeLongitudeSweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweepMeasurementRange_type, wchar_t > LatitudeLongitudeSweepMeasurementRange_traits;

      const LatitudeLongitudeSweepMeasurementRange_optional&
      LatitudeLongitudeSweepMeasurementRange () const;

      LatitudeLongitudeSweepMeasurementRange_optional&
      LatitudeLongitudeSweepMeasurementRange ();

      void
      LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_type& x);

      void
      LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_optional& x);

      void
      LatitudeLongitudeSweepMeasurementRange (::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > p);

      // LatitudeLongitudeSweepFull
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweepFull_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweepFull_type > LatitudeLongitudeSweepFull_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweepFull_type, wchar_t > LatitudeLongitudeSweepFull_traits;

      const LatitudeLongitudeSweepFull_optional&
      LatitudeLongitudeSweepFull () const;

      LatitudeLongitudeSweepFull_optional&
      LatitudeLongitudeSweepFull ();

      void
      LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_type& x);

      void
      LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_optional& x);

      void
      LatitudeLongitudeSweepFull (::std::unique_ptr< LatitudeLongitudeSweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      SphereFeatureMeasurementType ();

      SphereFeatureMeasurementType (const id_type&);

      SphereFeatureMeasurementType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SphereFeatureMeasurementType (const SphereFeatureMeasurementType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SphereFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphereFeatureMeasurementType&
      operator= (const SphereFeatureMeasurementType& x);

      virtual 
      ~SphereFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      Diameter_optional Diameter_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      LatitudeLongitudeSweepMeasurementRange_optional LatitudeLongitudeSweepMeasurementRange_;
      LatitudeLongitudeSweepFull_optional LatitudeLongitudeSweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::SphericalSegmentBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::SphericalSegmentRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::SphericalSegmentCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::SphericalSegmentCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::SphericalSegmentTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      SphericalSegmentConstructionMethodType ();

      SphericalSegmentConstructionMethodType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      SphericalSegmentConstructionMethodType (const SphericalSegmentConstructionMethodType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual SphericalSegmentConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentConstructionMethodType&
      operator= (const SphericalSegmentConstructionMethodType& x);

      virtual 
      ~SphericalSegmentConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SphericalSegmentBestFitType ();

      SphericalSegmentBestFitType (const n_type&);

      SphericalSegmentBestFitType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SphericalSegmentBestFitType (const SphericalSegmentBestFitType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SphericalSegmentBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentBestFitType&
      operator= (const SphericalSegmentBestFitType& x);

      virtual 
      ~SphericalSegmentBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      SphericalSegmentRecompType ();

      SphericalSegmentRecompType (const BaseFeaturePointList_type&);

      SphericalSegmentRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      SphericalSegmentRecompType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      SphericalSegmentRecompType (const SphericalSegmentRecompType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual SphericalSegmentRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentRecompType&
      operator= (const SphericalSegmentRecompType& x);

      virtual 
      ~SphericalSegmentRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseSphericalSegment
      //
      typedef ::xsd::qif30::BaseFeatureType BaseSphericalSegment_type;
      typedef ::xsd::cxx::tree::traits< BaseSphericalSegment_type, wchar_t > BaseSphericalSegment_traits;

      const BaseSphericalSegment_type&
      BaseSphericalSegment () const;

      BaseSphericalSegment_type&
      BaseSphericalSegment ();

      void
      BaseSphericalSegment (const BaseSphericalSegment_type& x);

      void
      BaseSphericalSegment (::std::unique_ptr< BaseSphericalSegment_type > p);

      // Constructors.
      //
      SphericalSegmentCopyType ();

      SphericalSegmentCopyType (const BaseSphericalSegment_type&);

      SphericalSegmentCopyType (::std::unique_ptr< BaseSphericalSegment_type >);

      SphericalSegmentCopyType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SphericalSegmentCopyType (const SphericalSegmentCopyType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual SphericalSegmentCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentCopyType&
      operator= (const SphericalSegmentCopyType& x);

      virtual 
      ~SphericalSegmentCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseSphericalSegment_type > BaseSphericalSegment_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      SphericalSegmentCastType ();

      SphericalSegmentCastType (const BaseFeature_type&);

      SphericalSegmentCastType (::std::unique_ptr< BaseFeature_type >);

      SphericalSegmentCastType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SphericalSegmentCastType (const SphericalSegmentCastType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual SphericalSegmentCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentCastType&
      operator= (const SphericalSegmentCastType& x);

      virtual 
      ~SphericalSegmentCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseSphericalSegment
      //
      typedef ::xsd::qif30::BaseFeatureType BaseSphericalSegment_type;
      typedef ::xsd::cxx::tree::traits< BaseSphericalSegment_type, wchar_t > BaseSphericalSegment_traits;

      const BaseSphericalSegment_type&
      BaseSphericalSegment () const;

      BaseSphericalSegment_type&
      BaseSphericalSegment ();

      void
      BaseSphericalSegment (const BaseSphericalSegment_type& x);

      void
      BaseSphericalSegment (::std::unique_ptr< BaseSphericalSegment_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      SphericalSegmentTransformType ();

      SphericalSegmentTransformType (const BaseSphericalSegment_type&,
                                     const Transformation_type&);

      SphericalSegmentTransformType (::std::unique_ptr< BaseSphericalSegment_type >,
                                     ::std::unique_ptr< Transformation_type >);

      SphericalSegmentTransformType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      SphericalSegmentTransformType (const SphericalSegmentTransformType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual SphericalSegmentTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentTransformType&
      operator= (const SphericalSegmentTransformType& x);

      virtual 
      ~SphericalSegmentTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseSphericalSegment_type > BaseSphericalSegment_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::SphericalSegmentConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      SphericalSegmentCheckedType ();

      SphericalSegmentCheckedType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SphericalSegmentCheckedType (const SphericalSegmentCheckedType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SphericalSegmentCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentCheckedType&
      operator= (const SphericalSegmentCheckedType& x);

      virtual 
      ~SphericalSegmentCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::SphericalSegmentCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      SphericalSegmentCheckedFeatureType ();

      SphericalSegmentCheckedFeatureType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SphericalSegmentCheckedFeatureType (const SphericalSegmentCheckedFeatureType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SphericalSegmentCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentCheckedFeatureType&
      operator= (const SphericalSegmentCheckedFeatureType& x);

      virtual 
      ~SphericalSegmentCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::SphericalSegmentCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      SphericalSegmentMeasurementDeterminationType ();

      SphericalSegmentMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      SphericalSegmentMeasurementDeterminationType (const SphericalSegmentMeasurementDeterminationType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual SphericalSegmentMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentMeasurementDeterminationType&
      operator= (const SphericalSegmentMeasurementDeterminationType& x);

      virtual 
      ~SphericalSegmentMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::SphericalSegmentMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      SphericalSegmentFeatureItemType ();

      SphericalSegmentFeatureItemType (const id_type&,
                                       const FeatureNominalId_type&,
                                       const FeatureName_type&,
                                       const DeterminationMode_type&);

      SphericalSegmentFeatureItemType (const id_type&,
                                       ::std::unique_ptr< FeatureNominalId_type >,
                                       const FeatureName_type&,
                                       ::std::unique_ptr< DeterminationMode_type >);

      SphericalSegmentFeatureItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SphericalSegmentFeatureItemType (const SphericalSegmentFeatureItemType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SphericalSegmentFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentFeatureItemType&
      operator= (const SphericalSegmentFeatureItemType& x);

      virtual 
      ~SphericalSegmentFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // Constructors.
      //
      SphericalSegmentFeatureDefinitionType ();

      SphericalSegmentFeatureDefinitionType (const id_type&,
                                             const InternalExternal_type&,
                                             const Diameter_type&);

      SphericalSegmentFeatureDefinitionType (const id_type&,
                                             const InternalExternal_type&,
                                             ::std::unique_ptr< Diameter_type >);

      SphericalSegmentFeatureDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      SphericalSegmentFeatureDefinitionType (const SphericalSegmentFeatureDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual SphericalSegmentFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentFeatureDefinitionType&
      operator= (const SphericalSegmentFeatureDefinitionType& x);

      virtual 
      ~SphericalSegmentFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // LatitudeLongitudeSweep
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweep_type;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweep_type, wchar_t > LatitudeLongitudeSweep_traits;

      const LatitudeLongitudeSweep_type&
      LatitudeLongitudeSweep () const;

      LatitudeLongitudeSweep_type&
      LatitudeLongitudeSweep ();

      void
      LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x);

      void
      LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::SphericalSegmentConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      SphericalSegmentFeatureNominalType ();

      SphericalSegmentFeatureNominalType (const id_type&,
                                          const FeatureDefinitionId_type&,
                                          const Location_type&,
                                          const LatitudeLongitudeSweep_type&);

      SphericalSegmentFeatureNominalType (const id_type&,
                                          ::std::unique_ptr< FeatureDefinitionId_type >,
                                          ::std::unique_ptr< Location_type >,
                                          ::std::unique_ptr< LatitudeLongitudeSweep_type >);

      SphericalSegmentFeatureNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SphericalSegmentFeatureNominalType (const SphericalSegmentFeatureNominalType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SphericalSegmentFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentFeatureNominalType&
      operator= (const SphericalSegmentFeatureNominalType& x);

      virtual 
      ~SphericalSegmentFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL SphericalSegmentFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // Diameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::optional< Diameter_type > Diameter_optional;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_optional&
      Diameter () const;

      Diameter_optional&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (const Diameter_optional& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // DiameterMin
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMin_type;
      typedef ::xsd::cxx::tree::optional< DiameterMin_type > DiameterMin_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMin_type, wchar_t > DiameterMin_traits;

      const DiameterMin_optional&
      DiameterMin () const;

      DiameterMin_optional&
      DiameterMin ();

      void
      DiameterMin (const DiameterMin_type& x);

      void
      DiameterMin (const DiameterMin_optional& x);

      void
      DiameterMin (::std::unique_ptr< DiameterMin_type > p);

      // DiameterMax
      //
      typedef ::xsd::qif30::MeasuredLinearValueType DiameterMax_type;
      typedef ::xsd::cxx::tree::optional< DiameterMax_type > DiameterMax_optional;
      typedef ::xsd::cxx::tree::traits< DiameterMax_type, wchar_t > DiameterMax_traits;

      const DiameterMax_optional&
      DiameterMax () const;

      DiameterMax_optional&
      DiameterMax ();

      void
      DiameterMax (const DiameterMax_type& x);

      void
      DiameterMax (const DiameterMax_optional& x);

      void
      DiameterMax (::std::unique_ptr< DiameterMax_type > p);

      // LatitudeLongitudeSweepMeasurementRange
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweepMeasurementRange_type > LatitudeLongitudeSweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweepMeasurementRange_type, wchar_t > LatitudeLongitudeSweepMeasurementRange_traits;

      const LatitudeLongitudeSweepMeasurementRange_optional&
      LatitudeLongitudeSweepMeasurementRange () const;

      LatitudeLongitudeSweepMeasurementRange_optional&
      LatitudeLongitudeSweepMeasurementRange ();

      void
      LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_type& x);

      void
      LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_optional& x);

      void
      LatitudeLongitudeSweepMeasurementRange (::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > p);

      // LatitudeLongitudeSweepFull
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweepFull_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweepFull_type > LatitudeLongitudeSweepFull_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweepFull_type, wchar_t > LatitudeLongitudeSweepFull_traits;

      const LatitudeLongitudeSweepFull_optional&
      LatitudeLongitudeSweepFull () const;

      LatitudeLongitudeSweepFull_optional&
      LatitudeLongitudeSweepFull ();

      void
      LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_type& x);

      void
      LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_optional& x);

      void
      LatitudeLongitudeSweepFull (::std::unique_ptr< LatitudeLongitudeSweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      SphericalSegmentFeatureMeasurementType ();

      SphericalSegmentFeatureMeasurementType (const id_type&);

      SphericalSegmentFeatureMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      SphericalSegmentFeatureMeasurementType (const SphericalSegmentFeatureMeasurementType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual SphericalSegmentFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentFeatureMeasurementType&
      operator= (const SphericalSegmentFeatureMeasurementType& x);

      virtual 
      ~SphericalSegmentFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      Diameter_optional Diameter_;
      DiameterMin_optional DiameterMin_;
      DiameterMax_optional DiameterMax_;
      LatitudeLongitudeSweepMeasurementRange_optional LatitudeLongitudeSweepMeasurementRange_;
      LatitudeLongitudeSweepFull_optional LatitudeLongitudeSweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionConstructionMethodType ();

      SurfaceOfRevolutionConstructionMethodType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SurfaceOfRevolutionConstructionMethodType (const SurfaceOfRevolutionConstructionMethodType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionConstructionMethodType&
      operator= (const SurfaceOfRevolutionConstructionMethodType& x);

      virtual 
      ~SurfaceOfRevolutionConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionBestFitType ();

      SurfaceOfRevolutionBestFitType (const n_type&);

      SurfaceOfRevolutionBestFitType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      SurfaceOfRevolutionBestFitType (const SurfaceOfRevolutionBestFitType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionBestFitType&
      operator= (const SurfaceOfRevolutionBestFitType& x);

      virtual 
      ~SurfaceOfRevolutionBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionRecompType ();

      SurfaceOfRevolutionRecompType (const BaseFeaturePointList_type&);

      SurfaceOfRevolutionRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      SurfaceOfRevolutionRecompType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      SurfaceOfRevolutionRecompType (const SurfaceOfRevolutionRecompType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionRecompType&
      operator= (const SurfaceOfRevolutionRecompType& x);

      virtual 
      ~SurfaceOfRevolutionRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseSurfaceOfRevolution
      //
      typedef ::xsd::qif30::BaseFeatureType BaseSurfaceOfRevolution_type;
      typedef ::xsd::cxx::tree::traits< BaseSurfaceOfRevolution_type, wchar_t > BaseSurfaceOfRevolution_traits;

      const BaseSurfaceOfRevolution_type&
      BaseSurfaceOfRevolution () const;

      BaseSurfaceOfRevolution_type&
      BaseSurfaceOfRevolution ();

      void
      BaseSurfaceOfRevolution (const BaseSurfaceOfRevolution_type& x);

      void
      BaseSurfaceOfRevolution (::std::unique_ptr< BaseSurfaceOfRevolution_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionCopyType ();

      SurfaceOfRevolutionCopyType (const BaseSurfaceOfRevolution_type&);

      SurfaceOfRevolutionCopyType (::std::unique_ptr< BaseSurfaceOfRevolution_type >);

      SurfaceOfRevolutionCopyType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SurfaceOfRevolutionCopyType (const SurfaceOfRevolutionCopyType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionCopyType&
      operator= (const SurfaceOfRevolutionCopyType& x);

      virtual 
      ~SurfaceOfRevolutionCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseSurfaceOfRevolution_type > BaseSurfaceOfRevolution_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionCastType ();

      SurfaceOfRevolutionCastType (const BaseFeature_type&);

      SurfaceOfRevolutionCastType (::std::unique_ptr< BaseFeature_type >);

      SurfaceOfRevolutionCastType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SurfaceOfRevolutionCastType (const SurfaceOfRevolutionCastType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionCastType&
      operator= (const SurfaceOfRevolutionCastType& x);

      virtual 
      ~SurfaceOfRevolutionCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseSurfaceOfRevolution
      //
      typedef ::xsd::qif30::BaseFeatureType BaseSurfaceOfRevolution_type;
      typedef ::xsd::cxx::tree::traits< BaseSurfaceOfRevolution_type, wchar_t > BaseSurfaceOfRevolution_traits;

      const BaseSurfaceOfRevolution_type&
      BaseSurfaceOfRevolution () const;

      BaseSurfaceOfRevolution_type&
      BaseSurfaceOfRevolution ();

      void
      BaseSurfaceOfRevolution (const BaseSurfaceOfRevolution_type& x);

      void
      BaseSurfaceOfRevolution (::std::unique_ptr< BaseSurfaceOfRevolution_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionTransformType ();

      SurfaceOfRevolutionTransformType (const BaseSurfaceOfRevolution_type&,
                                        const Transformation_type&);

      SurfaceOfRevolutionTransformType (::std::unique_ptr< BaseSurfaceOfRevolution_type >,
                                        ::std::unique_ptr< Transformation_type >);

      SurfaceOfRevolutionTransformType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      SurfaceOfRevolutionTransformType (const SurfaceOfRevolutionTransformType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionTransformType&
      operator= (const SurfaceOfRevolutionTransformType& x);

      virtual 
      ~SurfaceOfRevolutionTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseSurfaceOfRevolution_type > BaseSurfaceOfRevolution_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionCheckedType ();

      SurfaceOfRevolutionCheckedType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      SurfaceOfRevolutionCheckedType (const SurfaceOfRevolutionCheckedType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionCheckedType&
      operator= (const SurfaceOfRevolutionCheckedType& x);

      virtual 
      ~SurfaceOfRevolutionCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionCheckedFeatureType ();

      SurfaceOfRevolutionCheckedFeatureType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      SurfaceOfRevolutionCheckedFeatureType (const SurfaceOfRevolutionCheckedFeatureType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionCheckedFeatureType&
      operator= (const SurfaceOfRevolutionCheckedFeatureType& x);

      virtual 
      ~SurfaceOfRevolutionCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionMeasurementDeterminationType ();

      SurfaceOfRevolutionMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      SurfaceOfRevolutionMeasurementDeterminationType (const SurfaceOfRevolutionMeasurementDeterminationType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionMeasurementDeterminationType&
      operator= (const SurfaceOfRevolutionMeasurementDeterminationType& x);

      virtual 
      ~SurfaceOfRevolutionMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionFeatureItemType ();

      SurfaceOfRevolutionFeatureItemType (const id_type&,
                                          const FeatureNominalId_type&,
                                          const FeatureName_type&,
                                          const DeterminationMode_type&);

      SurfaceOfRevolutionFeatureItemType (const id_type&,
                                          ::std::unique_ptr< FeatureNominalId_type >,
                                          const FeatureName_type&,
                                          ::std::unique_ptr< DeterminationMode_type >);

      SurfaceOfRevolutionFeatureItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SurfaceOfRevolutionFeatureItemType (const SurfaceOfRevolutionFeatureItemType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionFeatureItemType&
      operator= (const SurfaceOfRevolutionFeatureItemType& x);

      virtual 
      ~SurfaceOfRevolutionFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionFeatureDefinitionType ();

      SurfaceOfRevolutionFeatureDefinitionType (const id_type&,
                                                const InternalExternal_type&);

      SurfaceOfRevolutionFeatureDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      SurfaceOfRevolutionFeatureDefinitionType (const SurfaceOfRevolutionFeatureDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionFeatureDefinitionType&
      operator= (const SurfaceOfRevolutionFeatureDefinitionType& x);

      virtual 
      ~SurfaceOfRevolutionFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      Length_optional Length_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::optional< Sweep_type > Sweep_optional;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_optional&
      Sweep () const;

      Sweep_optional&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (const Sweep_optional& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // ReferenceFeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ReferenceFeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< ReferenceFeatureNominalId_type > ReferenceFeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< ReferenceFeatureNominalId_type, wchar_t > ReferenceFeatureNominalId_traits;

      const ReferenceFeatureNominalId_optional&
      ReferenceFeatureNominalId () const;

      ReferenceFeatureNominalId_optional&
      ReferenceFeatureNominalId ();

      void
      ReferenceFeatureNominalId (const ReferenceFeatureNominalId_type& x);

      void
      ReferenceFeatureNominalId (const ReferenceFeatureNominalId_optional& x);

      void
      ReferenceFeatureNominalId (::std::unique_ptr< ReferenceFeatureNominalId_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::SurfaceOfRevolutionConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionFeatureNominalType ();

      SurfaceOfRevolutionFeatureNominalType (const id_type&,
                                             const FeatureDefinitionId_type&,
                                             const Axis_type&);

      SurfaceOfRevolutionFeatureNominalType (const id_type&,
                                             ::std::unique_ptr< FeatureDefinitionId_type >,
                                             ::std::unique_ptr< Axis_type >);

      SurfaceOfRevolutionFeatureNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      SurfaceOfRevolutionFeatureNominalType (const SurfaceOfRevolutionFeatureNominalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionFeatureNominalType&
      operator= (const SurfaceOfRevolutionFeatureNominalType& x);

      virtual 
      ~SurfaceOfRevolutionFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      Sweep_optional Sweep_;
      ReferenceFeatureNominalId_optional ReferenceFeatureNominalId_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL SurfaceOfRevolutionFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::MeasuredAxisType Axis_type;
      typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_optional&
      Axis () const;

      Axis_optional&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (const Axis_optional& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // SweepMeasurementRange
      //
      typedef ::xsd::qif30::SweepType SweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< SweepMeasurementRange_type > SweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< SweepMeasurementRange_type, wchar_t > SweepMeasurementRange_traits;

      const SweepMeasurementRange_optional&
      SweepMeasurementRange () const;

      SweepMeasurementRange_optional&
      SweepMeasurementRange ();

      void
      SweepMeasurementRange (const SweepMeasurementRange_type& x);

      void
      SweepMeasurementRange (const SweepMeasurementRange_optional& x);

      void
      SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > p);

      // SweepFull
      //
      typedef ::xsd::qif30::SweepType SweepFull_type;
      typedef ::xsd::cxx::tree::optional< SweepFull_type > SweepFull_optional;
      typedef ::xsd::cxx::tree::traits< SweepFull_type, wchar_t > SweepFull_traits;

      const SweepFull_optional&
      SweepFull () const;

      SweepFull_optional&
      SweepFull ();

      void
      SweepFull (const SweepFull_type& x);

      void
      SweepFull (const SweepFull_optional& x);

      void
      SweepFull (::std::unique_ptr< SweepFull_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionFeatureMeasurementType ();

      SurfaceOfRevolutionFeatureMeasurementType (const id_type&);

      SurfaceOfRevolutionFeatureMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SurfaceOfRevolutionFeatureMeasurementType (const SurfaceOfRevolutionFeatureMeasurementType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionFeatureMeasurementType&
      operator= (const SurfaceOfRevolutionFeatureMeasurementType& x);

      virtual 
      ~SurfaceOfRevolutionFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Axis_optional Axis_;
      SweepMeasurementRange_optional SweepMeasurementRange_;
      SweepFull_optional SweepFull_;
      Length_optional Length_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::ThreadedFeatureBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::ThreadedFeatureRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::ThreadedFeatureCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::ThreadedFeatureCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ThreadedFeatureTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromCylinder
      //
      typedef ::xsd::qif30::ThreadedFeatureFromCylinderType FromCylinder_type;
      typedef ::xsd::cxx::tree::optional< FromCylinder_type > FromCylinder_optional;
      typedef ::xsd::cxx::tree::traits< FromCylinder_type, wchar_t > FromCylinder_traits;

      const FromCylinder_optional&
      FromCylinder () const;

      FromCylinder_optional&
      FromCylinder ();

      void
      FromCylinder (const FromCylinder_type& x);

      void
      FromCylinder (const FromCylinder_optional& x);

      void
      FromCylinder (::std::unique_ptr< FromCylinder_type > p);

      // Constructors.
      //
      ThreadedFeatureConstructionMethodType ();

      ThreadedFeatureConstructionMethodType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ThreadedFeatureConstructionMethodType (const ThreadedFeatureConstructionMethodType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ThreadedFeatureConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureConstructionMethodType&
      operator= (const ThreadedFeatureConstructionMethodType& x);

      virtual 
      ~ThreadedFeatureConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromCylinder_optional FromCylinder_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ThreadedFeatureBestFitType ();

      ThreadedFeatureBestFitType (const n_type&);

      ThreadedFeatureBestFitType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ThreadedFeatureBestFitType (const ThreadedFeatureBestFitType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ThreadedFeatureBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureBestFitType&
      operator= (const ThreadedFeatureBestFitType& x);

      virtual 
      ~ThreadedFeatureBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      ThreadedFeatureRecompType ();

      ThreadedFeatureRecompType (const BaseFeaturePointList_type&);

      ThreadedFeatureRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      ThreadedFeatureRecompType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ThreadedFeatureRecompType (const ThreadedFeatureRecompType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ThreadedFeatureRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureRecompType&
      operator= (const ThreadedFeatureRecompType& x);

      virtual 
      ~ThreadedFeatureRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseThreadedFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseThreadedFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseThreadedFeature_type, wchar_t > BaseThreadedFeature_traits;

      const BaseThreadedFeature_type&
      BaseThreadedFeature () const;

      BaseThreadedFeature_type&
      BaseThreadedFeature ();

      void
      BaseThreadedFeature (const BaseThreadedFeature_type& x);

      void
      BaseThreadedFeature (::std::unique_ptr< BaseThreadedFeature_type > p);

      // Constructors.
      //
      ThreadedFeatureCopyType ();

      ThreadedFeatureCopyType (const BaseThreadedFeature_type&);

      ThreadedFeatureCopyType (::std::unique_ptr< BaseThreadedFeature_type >);

      ThreadedFeatureCopyType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ThreadedFeatureCopyType (const ThreadedFeatureCopyType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ThreadedFeatureCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureCopyType&
      operator= (const ThreadedFeatureCopyType& x);

      virtual 
      ~ThreadedFeatureCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseThreadedFeature_type > BaseThreadedFeature_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      ThreadedFeatureCastType ();

      ThreadedFeatureCastType (const BaseFeature_type&);

      ThreadedFeatureCastType (::std::unique_ptr< BaseFeature_type >);

      ThreadedFeatureCastType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ThreadedFeatureCastType (const ThreadedFeatureCastType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ThreadedFeatureCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureCastType&
      operator= (const ThreadedFeatureCastType& x);

      virtual 
      ~ThreadedFeatureCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseThreadedFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseThreadedFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseThreadedFeature_type, wchar_t > BaseThreadedFeature_traits;

      const BaseThreadedFeature_type&
      BaseThreadedFeature () const;

      BaseThreadedFeature_type&
      BaseThreadedFeature ();

      void
      BaseThreadedFeature (const BaseThreadedFeature_type& x);

      void
      BaseThreadedFeature (::std::unique_ptr< BaseThreadedFeature_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      ThreadedFeatureTransformType ();

      ThreadedFeatureTransformType (const BaseThreadedFeature_type&,
                                    const Transformation_type&);

      ThreadedFeatureTransformType (::std::unique_ptr< BaseThreadedFeature_type >,
                                    ::std::unique_ptr< Transformation_type >);

      ThreadedFeatureTransformType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ThreadedFeatureTransformType (const ThreadedFeatureTransformType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ThreadedFeatureTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureTransformType&
      operator= (const ThreadedFeatureTransformType& x);

      virtual 
      ~ThreadedFeatureTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseThreadedFeature_type > BaseThreadedFeature_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureFromCylinderType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseCylinder
      //
      typedef ::xsd::qif30::BaseFeatureType BaseCylinder_type;
      typedef ::xsd::cxx::tree::traits< BaseCylinder_type, wchar_t > BaseCylinder_traits;

      const BaseCylinder_type&
      BaseCylinder () const;

      BaseCylinder_type&
      BaseCylinder ();

      void
      BaseCylinder (const BaseCylinder_type& x);

      void
      BaseCylinder (::std::unique_ptr< BaseCylinder_type > p);

      // Offset
      //
      typedef ::xsd::qif30::LinearValueType Offset_type;
      typedef ::xsd::cxx::tree::optional< Offset_type > Offset_optional;
      typedef ::xsd::cxx::tree::traits< Offset_type, wchar_t > Offset_traits;

      const Offset_optional&
      Offset () const;

      Offset_optional&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (const Offset_optional& x);

      void
      Offset (::std::unique_ptr< Offset_type > p);

      // Constructors.
      //
      ThreadedFeatureFromCylinderType ();

      ThreadedFeatureFromCylinderType (const BaseCylinder_type&);

      ThreadedFeatureFromCylinderType (::std::unique_ptr< BaseCylinder_type >);

      ThreadedFeatureFromCylinderType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      ThreadedFeatureFromCylinderType (const ThreadedFeatureFromCylinderType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual ThreadedFeatureFromCylinderType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureFromCylinderType&
      operator= (const ThreadedFeatureFromCylinderType& x);

      virtual 
      ~ThreadedFeatureFromCylinderType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseCylinder_type > BaseCylinder_;
      Offset_optional Offset_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ThreadedFeatureConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ThreadedFeatureCheckedType ();

      ThreadedFeatureCheckedType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ThreadedFeatureCheckedType (const ThreadedFeatureCheckedType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ThreadedFeatureCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureCheckedType&
      operator= (const ThreadedFeatureCheckedType& x);

      virtual 
      ~ThreadedFeatureCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::ThreadedFeatureCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      ThreadedFeatureCheckedFeatureType ();

      ThreadedFeatureCheckedFeatureType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ThreadedFeatureCheckedFeatureType (const ThreadedFeatureCheckedFeatureType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ThreadedFeatureCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureCheckedFeatureType&
      operator= (const ThreadedFeatureCheckedFeatureType& x);

      virtual 
      ~ThreadedFeatureCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::ThreadedFeatureCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      ThreadedFeatureMeasurementDeterminationType ();

      ThreadedFeatureMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      ThreadedFeatureMeasurementDeterminationType (const ThreadedFeatureMeasurementDeterminationType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual ThreadedFeatureMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureMeasurementDeterminationType&
      operator= (const ThreadedFeatureMeasurementDeterminationType& x);

      virtual 
      ~ThreadedFeatureMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureItemType: public ::xsd::qif30::SpecifiedFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::ThreadedFeatureMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      ThreadedFeatureItemType ();

      ThreadedFeatureItemType (const id_type&,
                               const FeatureNominalId_type&,
                               const FeatureName_type&,
                               const DeterminationMode_type&);

      ThreadedFeatureItemType (const id_type&,
                               ::std::unique_ptr< FeatureNominalId_type >,
                               const FeatureName_type&,
                               ::std::unique_ptr< DeterminationMode_type >);

      ThreadedFeatureItemType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ThreadedFeatureItemType (const ThreadedFeatureItemType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ThreadedFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureItemType&
      operator= (const ThreadedFeatureItemType& x);

      virtual 
      ~ThreadedFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureDefinitionType: public ::xsd::qif30::SpecifiedFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // ThreadSpecificationId
      //
      typedef ::xsd::qif30::QIFReferenceType ThreadSpecificationId_type;
      typedef ::xsd::cxx::tree::traits< ThreadSpecificationId_type, wchar_t > ThreadSpecificationId_traits;

      const ThreadSpecificationId_type&
      ThreadSpecificationId () const;

      ThreadSpecificationId_type&
      ThreadSpecificationId ();

      void
      ThreadSpecificationId (const ThreadSpecificationId_type& x);

      void
      ThreadSpecificationId (::std::unique_ptr< ThreadSpecificationId_type > p);

      // Length
      //
      typedef ::xsd::qif30::LinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Bottom
      //
      typedef ::xsd::qif30::BottomType Bottom_type;
      typedef ::xsd::cxx::tree::optional< Bottom_type > Bottom_optional;
      typedef ::xsd::cxx::tree::traits< Bottom_type, wchar_t > Bottom_traits;

      const Bottom_optional&
      Bottom () const;

      Bottom_optional&
      Bottom ();

      void
      Bottom (const Bottom_type& x);

      void
      Bottom (const Bottom_optional& x);

      void
      Bottom (::std::unique_ptr< Bottom_type > p);

      // Constructors.
      //
      ThreadedFeatureDefinitionType ();

      ThreadedFeatureDefinitionType (const id_type&,
                                     const InternalExternal_type&,
                                     const ThreadSpecificationId_type&);

      ThreadedFeatureDefinitionType (const id_type&,
                                     const InternalExternal_type&,
                                     ::std::unique_ptr< ThreadSpecificationId_type >);

      ThreadedFeatureDefinitionType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ThreadedFeatureDefinitionType (const ThreadedFeatureDefinitionType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ThreadedFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureDefinitionType&
      operator= (const ThreadedFeatureDefinitionType& x);

      virtual 
      ~ThreadedFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< ThreadSpecificationId_type > ThreadSpecificationId_;
      Length_optional Length_;
      Bottom_optional Bottom_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureNominalType: public ::xsd::qif30::SpecifiedFeatureNominalBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ThreadedFeatureConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ThreadedFeatureNominalType ();

      ThreadedFeatureNominalType (const id_type&,
                                  const FeatureDefinitionId_type&,
                                  const Axis_type&);

      ThreadedFeatureNominalType (const id_type&,
                                  ::std::unique_ptr< FeatureDefinitionId_type >,
                                  ::std::unique_ptr< Axis_type >);

      ThreadedFeatureNominalType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ThreadedFeatureNominalType (const ThreadedFeatureNominalType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ThreadedFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureNominalType&
      operator= (const ThreadedFeatureNominalType& x);

      virtual 
      ~ThreadedFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ThreadedFeatureMeasurementType: public ::xsd::qif30::SpecifiedFeatureMeasurementBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::MeasuredAxisType Axis_type;
      typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_optional&
      Axis () const;

      Axis_optional&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (const Axis_optional& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // PitchDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType PitchDiameter_type;
      typedef ::xsd::cxx::tree::optional< PitchDiameter_type > PitchDiameter_optional;
      typedef ::xsd::cxx::tree::traits< PitchDiameter_type, wchar_t > PitchDiameter_traits;

      const PitchDiameter_optional&
      PitchDiameter () const;

      PitchDiameter_optional&
      PitchDiameter ();

      void
      PitchDiameter (const PitchDiameter_type& x);

      void
      PitchDiameter (const PitchDiameter_optional& x);

      void
      PitchDiameter (::std::unique_ptr< PitchDiameter_type > p);

      // FunctionalSize
      //
      typedef ::xsd::qif30::MeasuredLinearValueType FunctionalSize_type;
      typedef ::xsd::cxx::tree::optional< FunctionalSize_type > FunctionalSize_optional;
      typedef ::xsd::cxx::tree::traits< FunctionalSize_type, wchar_t > FunctionalSize_traits;

      const FunctionalSize_optional&
      FunctionalSize () const;

      FunctionalSize_optional&
      FunctionalSize ();

      void
      FunctionalSize (const FunctionalSize_type& x);

      void
      FunctionalSize (const FunctionalSize_optional& x);

      void
      FunctionalSize (::std::unique_ptr< FunctionalSize_type > p);

      // Length
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Length_type;
      typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t > Length_traits;

      const Length_optional&
      Length () const;

      Length_optional&
      Length ();

      void
      Length (const Length_type& x);

      void
      Length (const Length_optional& x);

      void
      Length (::std::unique_ptr< Length_type > p);

      // Constructors.
      //
      ThreadedFeatureMeasurementType ();

      ThreadedFeatureMeasurementType (const id_type&);

      ThreadedFeatureMeasurementType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ThreadedFeatureMeasurementType (const ThreadedFeatureMeasurementType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ThreadedFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadedFeatureMeasurementType&
      operator= (const ThreadedFeatureMeasurementType& x);

      virtual 
      ~ThreadedFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Axis_optional Axis_;
      PitchDiameter_optional PitchDiameter_;
      FunctionalSize_optional FunctionalSize_;
      Length_optional Length_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::ToroidalSegmentBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::ToroidalSegmentRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::ToroidalSegmentCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::ToroidalSegmentCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ToroidalSegmentTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      ToroidalSegmentConstructionMethodType ();

      ToroidalSegmentConstructionMethodType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ToroidalSegmentConstructionMethodType (const ToroidalSegmentConstructionMethodType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ToroidalSegmentConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentConstructionMethodType&
      operator= (const ToroidalSegmentConstructionMethodType& x);

      virtual 
      ~ToroidalSegmentConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ToroidalSegmentBestFitType ();

      ToroidalSegmentBestFitType (const n_type&);

      ToroidalSegmentBestFitType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ToroidalSegmentBestFitType (const ToroidalSegmentBestFitType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ToroidalSegmentBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentBestFitType&
      operator= (const ToroidalSegmentBestFitType& x);

      virtual 
      ~ToroidalSegmentBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      ToroidalSegmentRecompType ();

      ToroidalSegmentRecompType (const BaseFeaturePointList_type&);

      ToroidalSegmentRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      ToroidalSegmentRecompType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ToroidalSegmentRecompType (const ToroidalSegmentRecompType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ToroidalSegmentRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentRecompType&
      operator= (const ToroidalSegmentRecompType& x);

      virtual 
      ~ToroidalSegmentRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseToroidalSegment
      //
      typedef ::xsd::qif30::BaseFeatureType BaseToroidalSegment_type;
      typedef ::xsd::cxx::tree::traits< BaseToroidalSegment_type, wchar_t > BaseToroidalSegment_traits;

      const BaseToroidalSegment_type&
      BaseToroidalSegment () const;

      BaseToroidalSegment_type&
      BaseToroidalSegment ();

      void
      BaseToroidalSegment (const BaseToroidalSegment_type& x);

      void
      BaseToroidalSegment (::std::unique_ptr< BaseToroidalSegment_type > p);

      // Constructors.
      //
      ToroidalSegmentCopyType ();

      ToroidalSegmentCopyType (const BaseToroidalSegment_type&);

      ToroidalSegmentCopyType (::std::unique_ptr< BaseToroidalSegment_type >);

      ToroidalSegmentCopyType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ToroidalSegmentCopyType (const ToroidalSegmentCopyType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ToroidalSegmentCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentCopyType&
      operator= (const ToroidalSegmentCopyType& x);

      virtual 
      ~ToroidalSegmentCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseToroidalSegment_type > BaseToroidalSegment_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      ToroidalSegmentCastType ();

      ToroidalSegmentCastType (const BaseFeature_type&);

      ToroidalSegmentCastType (::std::unique_ptr< BaseFeature_type >);

      ToroidalSegmentCastType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ToroidalSegmentCastType (const ToroidalSegmentCastType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ToroidalSegmentCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentCastType&
      operator= (const ToroidalSegmentCastType& x);

      virtual 
      ~ToroidalSegmentCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseToroidalSegment
      //
      typedef ::xsd::qif30::BaseFeatureType BaseToroidalSegment_type;
      typedef ::xsd::cxx::tree::traits< BaseToroidalSegment_type, wchar_t > BaseToroidalSegment_traits;

      const BaseToroidalSegment_type&
      BaseToroidalSegment () const;

      BaseToroidalSegment_type&
      BaseToroidalSegment ();

      void
      BaseToroidalSegment (const BaseToroidalSegment_type& x);

      void
      BaseToroidalSegment (::std::unique_ptr< BaseToroidalSegment_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      ToroidalSegmentTransformType ();

      ToroidalSegmentTransformType (const BaseToroidalSegment_type&,
                                    const Transformation_type&);

      ToroidalSegmentTransformType (::std::unique_ptr< BaseToroidalSegment_type >,
                                    ::std::unique_ptr< Transformation_type >);

      ToroidalSegmentTransformType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ToroidalSegmentTransformType (const ToroidalSegmentTransformType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ToroidalSegmentTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentTransformType&
      operator= (const ToroidalSegmentTransformType& x);

      virtual 
      ~ToroidalSegmentTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseToroidalSegment_type > BaseToroidalSegment_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ToroidalSegmentConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ToroidalSegmentCheckedType ();

      ToroidalSegmentCheckedType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ToroidalSegmentCheckedType (const ToroidalSegmentCheckedType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ToroidalSegmentCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentCheckedType&
      operator= (const ToroidalSegmentCheckedType& x);

      virtual 
      ~ToroidalSegmentCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::ToroidalSegmentCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      ToroidalSegmentCheckedFeatureType ();

      ToroidalSegmentCheckedFeatureType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ToroidalSegmentCheckedFeatureType (const ToroidalSegmentCheckedFeatureType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ToroidalSegmentCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentCheckedFeatureType&
      operator= (const ToroidalSegmentCheckedFeatureType& x);

      virtual 
      ~ToroidalSegmentCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::ToroidalSegmentCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      ToroidalSegmentMeasurementDeterminationType ();

      ToroidalSegmentMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      ToroidalSegmentMeasurementDeterminationType (const ToroidalSegmentMeasurementDeterminationType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual ToroidalSegmentMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentMeasurementDeterminationType&
      operator= (const ToroidalSegmentMeasurementDeterminationType& x);

      virtual 
      ~ToroidalSegmentMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::ToroidalSegmentMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      ToroidalSegmentFeatureItemType ();

      ToroidalSegmentFeatureItemType (const id_type&,
                                      const FeatureNominalId_type&,
                                      const FeatureName_type&,
                                      const DeterminationMode_type&);

      ToroidalSegmentFeatureItemType (const id_type&,
                                      ::std::unique_ptr< FeatureNominalId_type >,
                                      const FeatureName_type&,
                                      ::std::unique_ptr< DeterminationMode_type >);

      ToroidalSegmentFeatureItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ToroidalSegmentFeatureItemType (const ToroidalSegmentFeatureItemType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ToroidalSegmentFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentFeatureItemType&
      operator= (const ToroidalSegmentFeatureItemType& x);

      virtual 
      ~ToroidalSegmentFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // MinorDiameter
      //
      typedef ::xsd::qif30::LinearValueType MinorDiameter_type;
      typedef ::xsd::cxx::tree::traits< MinorDiameter_type, wchar_t > MinorDiameter_traits;

      const MinorDiameter_type&
      MinorDiameter () const;

      MinorDiameter_type&
      MinorDiameter ();

      void
      MinorDiameter (const MinorDiameter_type& x);

      void
      MinorDiameter (::std::unique_ptr< MinorDiameter_type > p);

      // MajorDiameter
      //
      typedef ::xsd::qif30::LinearValueType MajorDiameter_type;
      typedef ::xsd::cxx::tree::traits< MajorDiameter_type, wchar_t > MajorDiameter_traits;

      const MajorDiameter_type&
      MajorDiameter () const;

      MajorDiameter_type&
      MajorDiameter ();

      void
      MajorDiameter (const MajorDiameter_type& x);

      void
      MajorDiameter (::std::unique_ptr< MajorDiameter_type > p);

      // Constructors.
      //
      ToroidalSegmentFeatureDefinitionType ();

      ToroidalSegmentFeatureDefinitionType (const id_type&,
                                            const InternalExternal_type&,
                                            const MinorDiameter_type&,
                                            const MajorDiameter_type&);

      ToroidalSegmentFeatureDefinitionType (const id_type&,
                                            const InternalExternal_type&,
                                            ::std::unique_ptr< MinorDiameter_type >,
                                            ::std::unique_ptr< MajorDiameter_type >);

      ToroidalSegmentFeatureDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ToroidalSegmentFeatureDefinitionType (const ToroidalSegmentFeatureDefinitionType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ToroidalSegmentFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentFeatureDefinitionType&
      operator= (const ToroidalSegmentFeatureDefinitionType& x);

      virtual 
      ~ToroidalSegmentFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< MinorDiameter_type > MinorDiameter_;
      ::xsd::cxx::tree::one< MajorDiameter_type > MajorDiameter_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // AxisVector
      //
      typedef ::xsd::qif30::UnitVectorType AxisVector_type;
      typedef ::xsd::cxx::tree::traits< AxisVector_type, wchar_t > AxisVector_traits;

      const AxisVector_type&
      AxisVector () const;

      AxisVector_type&
      AxisVector ();

      void
      AxisVector (const AxisVector_type& x);

      void
      AxisVector (::std::unique_ptr< AxisVector_type > p);

      // LatitudeLongitudeSweep
      //
      typedef ::xsd::qif30::LatitudeLongitudeSweepType LatitudeLongitudeSweep_type;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweep_type, wchar_t > LatitudeLongitudeSweep_traits;

      const LatitudeLongitudeSweep_type&
      LatitudeLongitudeSweep () const;

      LatitudeLongitudeSweep_type&
      LatitudeLongitudeSweep ();

      void
      LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x);

      void
      LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::ToroidalSegmentConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      ToroidalSegmentFeatureNominalType ();

      ToroidalSegmentFeatureNominalType (const id_type&,
                                         const FeatureDefinitionId_type&,
                                         const Location_type&,
                                         const AxisVector_type&,
                                         const LatitudeLongitudeSweep_type&);

      ToroidalSegmentFeatureNominalType (const id_type&,
                                         ::std::unique_ptr< FeatureDefinitionId_type >,
                                         ::std::unique_ptr< Location_type >,
                                         ::std::unique_ptr< AxisVector_type >,
                                         ::std::unique_ptr< LatitudeLongitudeSweep_type >);

      ToroidalSegmentFeatureNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ToroidalSegmentFeatureNominalType (const ToroidalSegmentFeatureNominalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ToroidalSegmentFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentFeatureNominalType&
      operator= (const ToroidalSegmentFeatureNominalType& x);

      virtual 
      ~ToroidalSegmentFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< AxisVector_type > AxisVector_;
      ::xsd::cxx::tree::one< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL ToroidalSegmentFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // AxisVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType AxisVector_type;
      typedef ::xsd::cxx::tree::optional< AxisVector_type > AxisVector_optional;
      typedef ::xsd::cxx::tree::traits< AxisVector_type, wchar_t > AxisVector_traits;

      const AxisVector_optional&
      AxisVector () const;

      AxisVector_optional&
      AxisVector ();

      void
      AxisVector (const AxisVector_type& x);

      void
      AxisVector (const AxisVector_optional& x);

      void
      AxisVector (::std::unique_ptr< AxisVector_type > p);

      // MinorDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinorDiameter_type;
      typedef ::xsd::cxx::tree::optional< MinorDiameter_type > MinorDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MinorDiameter_type, wchar_t > MinorDiameter_traits;

      const MinorDiameter_optional&
      MinorDiameter () const;

      MinorDiameter_optional&
      MinorDiameter ();

      void
      MinorDiameter (const MinorDiameter_type& x);

      void
      MinorDiameter (const MinorDiameter_optional& x);

      void
      MinorDiameter (::std::unique_ptr< MinorDiameter_type > p);

      // MajorDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MajorDiameter_type;
      typedef ::xsd::cxx::tree::optional< MajorDiameter_type > MajorDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MajorDiameter_type, wchar_t > MajorDiameter_traits;

      const MajorDiameter_optional&
      MajorDiameter () const;

      MajorDiameter_optional&
      MajorDiameter ();

      void
      MajorDiameter (const MajorDiameter_type& x);

      void
      MajorDiameter (const MajorDiameter_optional& x);

      void
      MajorDiameter (::std::unique_ptr< MajorDiameter_type > p);

      // LatitudeLongitudeSweepMeasurementRange
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweepMeasurementRange_type > LatitudeLongitudeSweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweepMeasurementRange_type, wchar_t > LatitudeLongitudeSweepMeasurementRange_traits;

      const LatitudeLongitudeSweepMeasurementRange_optional&
      LatitudeLongitudeSweepMeasurementRange () const;

      LatitudeLongitudeSweepMeasurementRange_optional&
      LatitudeLongitudeSweepMeasurementRange ();

      void
      LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_type& x);

      void
      LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_optional& x);

      void
      LatitudeLongitudeSweepMeasurementRange (::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > p);

      // LatitudeLongitudeSweepFull
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweepFull_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweepFull_type > LatitudeLongitudeSweepFull_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweepFull_type, wchar_t > LatitudeLongitudeSweepFull_traits;

      const LatitudeLongitudeSweepFull_optional&
      LatitudeLongitudeSweepFull () const;

      LatitudeLongitudeSweepFull_optional&
      LatitudeLongitudeSweepFull ();

      void
      LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_type& x);

      void
      LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_optional& x);

      void
      LatitudeLongitudeSweepFull (::std::unique_ptr< LatitudeLongitudeSweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      ToroidalSegmentFeatureMeasurementType ();

      ToroidalSegmentFeatureMeasurementType (const id_type&);

      ToroidalSegmentFeatureMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      ToroidalSegmentFeatureMeasurementType (const ToroidalSegmentFeatureMeasurementType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual ToroidalSegmentFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentFeatureMeasurementType&
      operator= (const ToroidalSegmentFeatureMeasurementType& x);

      virtual 
      ~ToroidalSegmentFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      AxisVector_optional AxisVector_;
      MinorDiameter_optional MinorDiameter_;
      MajorDiameter_optional MajorDiameter_;
      LatitudeLongitudeSweepMeasurementRange_optional LatitudeLongitudeSweepMeasurementRange_;
      LatitudeLongitudeSweepFull_optional LatitudeLongitudeSweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL TorusConstructionMethodType: public ::xml_schema::type
    {
      public:
      // BestFit
      //
      typedef ::xsd::qif30::TorusBestFitType BestFit_type;
      typedef ::xsd::cxx::tree::optional< BestFit_type > BestFit_optional;
      typedef ::xsd::cxx::tree::traits< BestFit_type, wchar_t > BestFit_traits;

      const BestFit_optional&
      BestFit () const;

      BestFit_optional&
      BestFit ();

      void
      BestFit (const BestFit_type& x);

      void
      BestFit (const BestFit_optional& x);

      void
      BestFit (::std::unique_ptr< BestFit_type > p);

      // Recompensated
      //
      typedef ::xsd::qif30::TorusRecompType Recompensated_type;
      typedef ::xsd::cxx::tree::optional< Recompensated_type > Recompensated_optional;
      typedef ::xsd::cxx::tree::traits< Recompensated_type, wchar_t > Recompensated_traits;

      const Recompensated_optional&
      Recompensated () const;

      Recompensated_optional&
      Recompensated ();

      void
      Recompensated (const Recompensated_type& x);

      void
      Recompensated (const Recompensated_optional& x);

      void
      Recompensated (::std::unique_ptr< Recompensated_type > p);

      // Copy
      //
      typedef ::xsd::qif30::TorusCopyType Copy_type;
      typedef ::xsd::cxx::tree::optional< Copy_type > Copy_optional;
      typedef ::xsd::cxx::tree::traits< Copy_type, wchar_t > Copy_traits;

      const Copy_optional&
      Copy () const;

      Copy_optional&
      Copy ();

      void
      Copy (const Copy_type& x);

      void
      Copy (const Copy_optional& x);

      void
      Copy (::std::unique_ptr< Copy_type > p);

      // Cast
      //
      typedef ::xsd::qif30::TorusCastType Cast_type;
      typedef ::xsd::cxx::tree::optional< Cast_type > Cast_optional;
      typedef ::xsd::cxx::tree::traits< Cast_type, wchar_t > Cast_traits;

      const Cast_optional&
      Cast () const;

      Cast_optional&
      Cast ();

      void
      Cast (const Cast_type& x);

      void
      Cast (const Cast_optional& x);

      void
      Cast (::std::unique_ptr< Cast_type > p);

      // Transform
      //
      typedef ::xsd::qif30::TorusTransformType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // FromScan
      //
      typedef ::xsd::qif30::TorusFromScanType FromScan_type;
      typedef ::xsd::cxx::tree::optional< FromScan_type > FromScan_optional;
      typedef ::xsd::cxx::tree::traits< FromScan_type, wchar_t > FromScan_traits;

      const FromScan_optional&
      FromScan () const;

      FromScan_optional&
      FromScan ();

      void
      FromScan (const FromScan_type& x);

      void
      FromScan (const FromScan_optional& x);

      void
      FromScan (::std::unique_ptr< FromScan_type > p);

      // Constructors.
      //
      TorusConstructionMethodType ();

      TorusConstructionMethodType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      TorusConstructionMethodType (const TorusConstructionMethodType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual TorusConstructionMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusConstructionMethodType&
      operator= (const TorusConstructionMethodType& x);

      virtual 
      ~TorusConstructionMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BestFit_optional BestFit_;
      Recompensated_optional Recompensated_;
      Copy_optional Copy_;
      Cast_optional Cast_;
      Transform_optional Transform_;
      FromScan_optional FromScan_;
    };

    class QIF30_SYMBOL_DECL TorusBestFitType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      TorusBestFitType ();

      TorusBestFitType (const n_type&);

      TorusBestFitType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      TorusBestFitType (const TorusBestFitType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual TorusBestFitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusBestFitType&
      operator= (const TorusBestFitType& x);

      virtual 
      ~TorusBestFitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL TorusRecompType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeaturePointList
      //
      typedef ::xsd::qif30::BaseFeaturePointListType BaseFeaturePointList_type;
      typedef ::xsd::cxx::tree::traits< BaseFeaturePointList_type, wchar_t > BaseFeaturePointList_traits;

      const BaseFeaturePointList_type&
      BaseFeaturePointList () const;

      BaseFeaturePointList_type&
      BaseFeaturePointList ();

      void
      BaseFeaturePointList (const BaseFeaturePointList_type& x);

      void
      BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > p);

      // Constructors.
      //
      TorusRecompType ();

      TorusRecompType (const BaseFeaturePointList_type&);

      TorusRecompType (::std::unique_ptr< BaseFeaturePointList_type >);

      TorusRecompType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      TorusRecompType (const TorusRecompType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual TorusRecompType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusRecompType&
      operator= (const TorusRecompType& x);

      virtual 
      ~TorusRecompType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeaturePointList_type > BaseFeaturePointList_;
    };

    class QIF30_SYMBOL_DECL TorusCopyType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseTorus
      //
      typedef ::xsd::qif30::BaseFeatureType BaseTorus_type;
      typedef ::xsd::cxx::tree::traits< BaseTorus_type, wchar_t > BaseTorus_traits;

      const BaseTorus_type&
      BaseTorus () const;

      BaseTorus_type&
      BaseTorus ();

      void
      BaseTorus (const BaseTorus_type& x);

      void
      BaseTorus (::std::unique_ptr< BaseTorus_type > p);

      // Constructors.
      //
      TorusCopyType ();

      TorusCopyType (const BaseTorus_type&);

      TorusCopyType (::std::unique_ptr< BaseTorus_type >);

      TorusCopyType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      TorusCopyType (const TorusCopyType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual TorusCopyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusCopyType&
      operator= (const TorusCopyType& x);

      virtual 
      ~TorusCopyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseTorus_type > BaseTorus_;
    };

    class QIF30_SYMBOL_DECL TorusCastType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_type&
      BaseFeature () const;

      BaseFeature_type&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      TorusCastType ();

      TorusCastType (const BaseFeature_type&);

      TorusCastType (::std::unique_ptr< BaseFeature_type >);

      TorusCastType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      TorusCastType (const TorusCastType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual TorusCastType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusCastType&
      operator= (const TorusCastType& x);

      virtual 
      ~TorusCastType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseFeature_type > BaseFeature_;
    };

    class QIF30_SYMBOL_DECL TorusTransformType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // BaseTorus
      //
      typedef ::xsd::qif30::BaseFeatureType BaseTorus_type;
      typedef ::xsd::cxx::tree::traits< BaseTorus_type, wchar_t > BaseTorus_traits;

      const BaseTorus_type&
      BaseTorus () const;

      BaseTorus_type&
      BaseTorus ();

      void
      BaseTorus (const BaseTorus_type& x);

      void
      BaseTorus (::std::unique_ptr< BaseTorus_type > p);

      // Transformation
      //
      typedef ::xsd::qif30::TransformationReferenceType Transformation_type;
      typedef ::xsd::cxx::tree::traits< Transformation_type, wchar_t > Transformation_traits;

      const Transformation_type&
      Transformation () const;

      Transformation_type&
      Transformation ();

      void
      Transformation (const Transformation_type& x);

      void
      Transformation (::std::unique_ptr< Transformation_type > p);

      // Constructors.
      //
      TorusTransformType ();

      TorusTransformType (const BaseTorus_type&,
                          const Transformation_type&);

      TorusTransformType (::std::unique_ptr< BaseTorus_type >,
                          ::std::unique_ptr< Transformation_type >);

      TorusTransformType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      TorusTransformType (const TorusTransformType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual TorusTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusTransformType&
      operator= (const TorusTransformType& x);

      virtual 
      ~TorusTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseTorus_type > BaseTorus_;
      ::xsd::cxx::tree::one< Transformation_type > Transformation_;
    };

    class QIF30_SYMBOL_DECL TorusFromScanType: public ::xsd::qif30::ConstructionMethodBaseType
    {
      public:
      // SurfaceFeature
      //
      typedef ::xsd::qif30::BaseFeatureType SurfaceFeature_type;
      typedef ::xsd::cxx::tree::traits< SurfaceFeature_type, wchar_t > SurfaceFeature_traits;

      const SurfaceFeature_type&
      SurfaceFeature () const;

      SurfaceFeature_type&
      SurfaceFeature ();

      void
      SurfaceFeature (const SurfaceFeature_type& x);

      void
      SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > p);

      // SearchRadius
      //
      typedef ::xsd::qif30::LinearValueType SearchRadius_type;
      typedef ::xsd::cxx::tree::traits< SearchRadius_type, wchar_t > SearchRadius_traits;

      const SearchRadius_type&
      SearchRadius () const;

      SearchRadius_type&
      SearchRadius ();

      void
      SearchRadius (const SearchRadius_type& x);

      void
      SearchRadius (::std::unique_ptr< SearchRadius_type > p);

      // Constructors.
      //
      TorusFromScanType ();

      TorusFromScanType (const SurfaceFeature_type&,
                         const SearchRadius_type&);

      TorusFromScanType (::std::unique_ptr< SurfaceFeature_type >,
                         ::std::unique_ptr< SearchRadius_type >);

      TorusFromScanType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      TorusFromScanType (const TorusFromScanType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual TorusFromScanType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusFromScanType&
      operator= (const TorusFromScanType& x);

      virtual 
      ~TorusFromScanType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceFeature_type > SurfaceFeature_;
      ::xsd::cxx::tree::one< SearchRadius_type > SearchRadius_;
    };

    class QIF30_SYMBOL_DECL TorusCheckedType: public ::xml_schema::type
    {
      public:
      // Measured
      //
      typedef ::xsd::qif30::MeasuredFeatureType Measured_type;
      typedef ::xsd::cxx::tree::optional< Measured_type > Measured_optional;
      typedef ::xsd::cxx::tree::traits< Measured_type, wchar_t > Measured_traits;

      const Measured_optional&
      Measured () const;

      Measured_optional&
      Measured ();

      void
      Measured (const Measured_type& x);

      void
      Measured (const Measured_optional& x);

      void
      Measured (::std::unique_ptr< Measured_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::TorusConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      TorusCheckedType ();

      TorusCheckedType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      TorusCheckedType (const TorusCheckedType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual TorusCheckedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusCheckedType&
      operator= (const TorusCheckedType& x);

      virtual 
      ~TorusCheckedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Measured_optional Measured_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL TorusCheckedFeatureType: public ::xml_schema::type
    {
      public:
      // CheckDetails
      //
      typedef ::xsd::qif30::TorusCheckedType CheckDetails_type;
      typedef ::xsd::cxx::tree::optional< CheckDetails_type > CheckDetails_optional;
      typedef ::xsd::cxx::tree::traits< CheckDetails_type, wchar_t > CheckDetails_traits;

      const CheckDetails_optional&
      CheckDetails () const;

      CheckDetails_optional&
      CheckDetails ();

      void
      CheckDetails (const CheckDetails_type& x);

      void
      CheckDetails (const CheckDetails_optional& x);

      void
      CheckDetails (::std::unique_ptr< CheckDetails_type > p);

      // Constructors.
      //
      TorusCheckedFeatureType ();

      TorusCheckedFeatureType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      TorusCheckedFeatureType (const TorusCheckedFeatureType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual TorusCheckedFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusCheckedFeatureType&
      operator= (const TorusCheckedFeatureType& x);

      virtual 
      ~TorusCheckedFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CheckDetails_optional CheckDetails_;
    };

    class QIF30_SYMBOL_DECL TorusMeasurementDeterminationType: public ::xml_schema::type
    {
      public:
      // Checked
      //
      typedef ::xsd::qif30::TorusCheckedFeatureType Checked_type;
      typedef ::xsd::cxx::tree::optional< Checked_type > Checked_optional;
      typedef ::xsd::cxx::tree::traits< Checked_type, wchar_t > Checked_traits;

      const Checked_optional&
      Checked () const;

      Checked_optional&
      Checked ();

      void
      Checked (const Checked_type& x);

      void
      Checked (const Checked_optional& x);

      void
      Checked (::std::unique_ptr< Checked_type > p);

      // Set
      //
      typedef ::xsd::qif30::SetFeatureType Set_type;
      typedef ::xsd::cxx::tree::optional< Set_type > Set_optional;
      typedef ::xsd::cxx::tree::traits< Set_type, wchar_t > Set_traits;

      const Set_optional&
      Set () const;

      Set_optional&
      Set ();

      void
      Set (const Set_type& x);

      void
      Set (const Set_optional& x);

      void
      Set (::std::unique_ptr< Set_type > p);

      // Constructors.
      //
      TorusMeasurementDeterminationType ();

      TorusMeasurementDeterminationType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      TorusMeasurementDeterminationType (const TorusMeasurementDeterminationType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual TorusMeasurementDeterminationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusMeasurementDeterminationType&
      operator= (const TorusMeasurementDeterminationType& x);

      virtual 
      ~TorusMeasurementDeterminationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Checked_optional Checked_;
      Set_optional Set_;
    };

    class QIF30_SYMBOL_DECL TorusFeatureItemType: public ::xsd::qif30::SurfaceFeatureItemBaseType
    {
      public:
      // DeterminationMode
      //
      typedef ::xsd::qif30::TorusMeasurementDeterminationType DeterminationMode_type;
      typedef ::xsd::cxx::tree::traits< DeterminationMode_type, wchar_t > DeterminationMode_traits;

      const DeterminationMode_type&
      DeterminationMode () const;

      DeterminationMode_type&
      DeterminationMode ();

      void
      DeterminationMode (const DeterminationMode_type& x);

      void
      DeterminationMode (::std::unique_ptr< DeterminationMode_type > p);

      // Constructors.
      //
      TorusFeatureItemType ();

      TorusFeatureItemType (const id_type&,
                            const FeatureNominalId_type&,
                            const FeatureName_type&,
                            const DeterminationMode_type&);

      TorusFeatureItemType (const id_type&,
                            ::std::unique_ptr< FeatureNominalId_type >,
                            const FeatureName_type&,
                            ::std::unique_ptr< DeterminationMode_type >);

      TorusFeatureItemType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      TorusFeatureItemType (const TorusFeatureItemType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual TorusFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusFeatureItemType&
      operator= (const TorusFeatureItemType& x);

      virtual 
      ~TorusFeatureItemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DeterminationMode_type > DeterminationMode_;
    };

    class QIF30_SYMBOL_DECL TorusFeatureDefinitionType: public ::xsd::qif30::SurfaceFeatureDefinitionBaseType
    {
      public:
      // InternalExternal
      //
      typedef ::xsd::qif30::InternalExternalEnumType InternalExternal_type;
      typedef ::xsd::cxx::tree::traits< InternalExternal_type, wchar_t > InternalExternal_traits;

      const InternalExternal_type&
      InternalExternal () const;

      InternalExternal_type&
      InternalExternal ();

      void
      InternalExternal (const InternalExternal_type& x);

      void
      InternalExternal (::std::unique_ptr< InternalExternal_type > p);

      // MinorDiameter
      //
      typedef ::xsd::qif30::LinearValueType MinorDiameter_type;
      typedef ::xsd::cxx::tree::traits< MinorDiameter_type, wchar_t > MinorDiameter_traits;

      const MinorDiameter_type&
      MinorDiameter () const;

      MinorDiameter_type&
      MinorDiameter ();

      void
      MinorDiameter (const MinorDiameter_type& x);

      void
      MinorDiameter (::std::unique_ptr< MinorDiameter_type > p);

      // MajorDiameter
      //
      typedef ::xsd::qif30::LinearValueType MajorDiameter_type;
      typedef ::xsd::cxx::tree::traits< MajorDiameter_type, wchar_t > MajorDiameter_traits;

      const MajorDiameter_type&
      MajorDiameter () const;

      MajorDiameter_type&
      MajorDiameter ();

      void
      MajorDiameter (const MajorDiameter_type& x);

      void
      MajorDiameter (::std::unique_ptr< MajorDiameter_type > p);

      // Constructors.
      //
      TorusFeatureDefinitionType ();

      TorusFeatureDefinitionType (const id_type&,
                                  const InternalExternal_type&,
                                  const MinorDiameter_type&,
                                  const MajorDiameter_type&);

      TorusFeatureDefinitionType (const id_type&,
                                  const InternalExternal_type&,
                                  ::std::unique_ptr< MinorDiameter_type >,
                                  ::std::unique_ptr< MajorDiameter_type >);

      TorusFeatureDefinitionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      TorusFeatureDefinitionType (const TorusFeatureDefinitionType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual TorusFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusFeatureDefinitionType&
      operator= (const TorusFeatureDefinitionType& x);

      virtual 
      ~TorusFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< InternalExternal_type > InternalExternal_;
      ::xsd::cxx::tree::one< MinorDiameter_type > MinorDiameter_;
      ::xsd::cxx::tree::one< MajorDiameter_type > MajorDiameter_;
    };

    class QIF30_SYMBOL_DECL TorusFeatureNominalType: public ::xsd::qif30::SurfaceFeatureNominalBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::PointType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // AxisVector
      //
      typedef ::xsd::qif30::UnitVectorType AxisVector_type;
      typedef ::xsd::cxx::tree::traits< AxisVector_type, wchar_t > AxisVector_traits;

      const AxisVector_type&
      AxisVector () const;

      AxisVector_type&
      AxisVector ();

      void
      AxisVector (const AxisVector_type& x);

      void
      AxisVector (::std::unique_ptr< AxisVector_type > p);

      // LatitudeLongitudeSweep
      //
      typedef ::xsd::qif30::LatitudeLongitudeSweepType LatitudeLongitudeSweep_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweep_type, wchar_t > LatitudeLongitudeSweep_traits;

      const LatitudeLongitudeSweep_optional&
      LatitudeLongitudeSweep () const;

      LatitudeLongitudeSweep_optional&
      LatitudeLongitudeSweep ();

      void
      LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x);

      void
      LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x);

      void
      LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > p);

      // Constructed
      //
      typedef ::xsd::qif30::TorusConstructionMethodType Constructed_type;
      typedef ::xsd::cxx::tree::optional< Constructed_type > Constructed_optional;
      typedef ::xsd::cxx::tree::traits< Constructed_type, wchar_t > Constructed_traits;

      const Constructed_optional&
      Constructed () const;

      Constructed_optional&
      Constructed ();

      void
      Constructed (const Constructed_type& x);

      void
      Constructed (const Constructed_optional& x);

      void
      Constructed (::std::unique_ptr< Constructed_type > p);

      // Constructors.
      //
      TorusFeatureNominalType ();

      TorusFeatureNominalType (const id_type&,
                               const FeatureDefinitionId_type&,
                               const Location_type&,
                               const AxisVector_type&);

      TorusFeatureNominalType (const id_type&,
                               ::std::unique_ptr< FeatureDefinitionId_type >,
                               ::std::unique_ptr< Location_type >,
                               ::std::unique_ptr< AxisVector_type >);

      TorusFeatureNominalType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      TorusFeatureNominalType (const TorusFeatureNominalType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual TorusFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusFeatureNominalType&
      operator= (const TorusFeatureNominalType& x);

      virtual 
      ~TorusFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< AxisVector_type > AxisVector_;
      LatitudeLongitudeSweep_optional LatitudeLongitudeSweep_;
      Constructed_optional Constructed_;
    };

    class QIF30_SYMBOL_DECL TorusFeatureMeasurementType: public ::xsd::qif30::SurfaceFeatureMeasurementBaseType
    {
      public:
      // Location
      //
      typedef ::xsd::qif30::MeasuredPointType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // AxisVector
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType AxisVector_type;
      typedef ::xsd::cxx::tree::optional< AxisVector_type > AxisVector_optional;
      typedef ::xsd::cxx::tree::traits< AxisVector_type, wchar_t > AxisVector_traits;

      const AxisVector_optional&
      AxisVector () const;

      AxisVector_optional&
      AxisVector ();

      void
      AxisVector (const AxisVector_type& x);

      void
      AxisVector (const AxisVector_optional& x);

      void
      AxisVector (::std::unique_ptr< AxisVector_type > p);

      // MinorDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MinorDiameter_type;
      typedef ::xsd::cxx::tree::optional< MinorDiameter_type > MinorDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MinorDiameter_type, wchar_t > MinorDiameter_traits;

      const MinorDiameter_optional&
      MinorDiameter () const;

      MinorDiameter_optional&
      MinorDiameter ();

      void
      MinorDiameter (const MinorDiameter_type& x);

      void
      MinorDiameter (const MinorDiameter_optional& x);

      void
      MinorDiameter (::std::unique_ptr< MinorDiameter_type > p);

      // MajorDiameter
      //
      typedef ::xsd::qif30::MeasuredLinearValueType MajorDiameter_type;
      typedef ::xsd::cxx::tree::optional< MajorDiameter_type > MajorDiameter_optional;
      typedef ::xsd::cxx::tree::traits< MajorDiameter_type, wchar_t > MajorDiameter_traits;

      const MajorDiameter_optional&
      MajorDiameter () const;

      MajorDiameter_optional&
      MajorDiameter ();

      void
      MajorDiameter (const MajorDiameter_type& x);

      void
      MajorDiameter (const MajorDiameter_optional& x);

      void
      MajorDiameter (::std::unique_ptr< MajorDiameter_type > p);

      // LatitudeLongitudeSweepMeasurementRange
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweepMeasurementRange_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweepMeasurementRange_type > LatitudeLongitudeSweepMeasurementRange_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweepMeasurementRange_type, wchar_t > LatitudeLongitudeSweepMeasurementRange_traits;

      const LatitudeLongitudeSweepMeasurementRange_optional&
      LatitudeLongitudeSweepMeasurementRange () const;

      LatitudeLongitudeSweepMeasurementRange_optional&
      LatitudeLongitudeSweepMeasurementRange ();

      void
      LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_type& x);

      void
      LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_optional& x);

      void
      LatitudeLongitudeSweepMeasurementRange (::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > p);

      // LatitudeLongitudeSweepFull
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweepFull_type;
      typedef ::xsd::cxx::tree::optional< LatitudeLongitudeSweepFull_type > LatitudeLongitudeSweepFull_optional;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweepFull_type, wchar_t > LatitudeLongitudeSweepFull_traits;

      const LatitudeLongitudeSweepFull_optional&
      LatitudeLongitudeSweepFull () const;

      LatitudeLongitudeSweepFull_optional&
      LatitudeLongitudeSweepFull ();

      void
      LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_type& x);

      void
      LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_optional& x);

      void
      LatitudeLongitudeSweepFull (::std::unique_ptr< LatitudeLongitudeSweepFull_type > p);

      // Form
      //
      typedef ::xsd::qif30::MeasuredLinearValueType Form_type;
      typedef ::xsd::cxx::tree::optional< Form_type > Form_optional;
      typedef ::xsd::cxx::tree::traits< Form_type, wchar_t > Form_traits;

      const Form_optional&
      Form () const;

      Form_optional&
      Form ();

      void
      Form (const Form_type& x);

      void
      Form (const Form_optional& x);

      void
      Form (::std::unique_ptr< Form_type > p);

      // Constructors.
      //
      TorusFeatureMeasurementType ();

      TorusFeatureMeasurementType (const id_type&);

      TorusFeatureMeasurementType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      TorusFeatureMeasurementType (const TorusFeatureMeasurementType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual TorusFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusFeatureMeasurementType&
      operator= (const TorusFeatureMeasurementType& x);

      virtual 
      ~TorusFeatureMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Location_optional Location_;
      AxisVector_optional AxisVector_;
      MinorDiameter_optional MinorDiameter_;
      MajorDiameter_optional MajorDiameter_;
      LatitudeLongitudeSweepMeasurementRange_optional LatitudeLongitudeSweepMeasurementRange_;
      LatitudeLongitudeSweepFull_optional LatitudeLongitudeSweepFull_;
      Form_optional Form_;
    };

    class QIF30_SYMBOL_DECL GroupFeatureItemType: public ::xsd::qif30::ShapeFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      GroupFeatureItemType ();

      GroupFeatureItemType (const id_type&,
                            const FeatureNominalId_type&,
                            const FeatureName_type&);

      GroupFeatureItemType (const id_type&,
                            ::std::unique_ptr< FeatureNominalId_type >,
                            const FeatureName_type&);

      GroupFeatureItemType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      GroupFeatureItemType (const GroupFeatureItemType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual GroupFeatureItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      GroupFeatureItemType&
      operator= (const GroupFeatureItemType&) = default;
#endif

      virtual 
      ~GroupFeatureItemType ();
    };

    class QIF30_SYMBOL_DECL GroupFeatureDefinitionType: public ::xsd::qif30::ShapeFeatureDefinitionBaseType
    {
      public:
      // IsProfileGroup
      //
      typedef ::xml_schema::boolean IsProfileGroup_type;
      typedef ::xsd::cxx::tree::optional< IsProfileGroup_type > IsProfileGroup_optional;
      typedef ::xsd::cxx::tree::traits< IsProfileGroup_type, wchar_t > IsProfileGroup_traits;

      const IsProfileGroup_optional&
      IsProfileGroup () const;

      IsProfileGroup_optional&
      IsProfileGroup ();

      void
      IsProfileGroup (const IsProfileGroup_type& x);

      void
      IsProfileGroup (const IsProfileGroup_optional& x);

      // IsRunoutGroup
      //
      typedef ::xml_schema::boolean IsRunoutGroup_type;
      typedef ::xsd::cxx::tree::optional< IsRunoutGroup_type > IsRunoutGroup_optional;
      typedef ::xsd::cxx::tree::traits< IsRunoutGroup_type, wchar_t > IsRunoutGroup_traits;

      const IsRunoutGroup_optional&
      IsRunoutGroup () const;

      IsRunoutGroup_optional&
      IsRunoutGroup ();

      void
      IsRunoutGroup (const IsRunoutGroup_type& x);

      void
      IsRunoutGroup (const IsRunoutGroup_optional& x);

      // IsCountersunkHole
      //
      typedef ::xml_schema::boolean IsCountersunkHole_type;
      typedef ::xsd::cxx::tree::optional< IsCountersunkHole_type > IsCountersunkHole_optional;
      typedef ::xsd::cxx::tree::traits< IsCountersunkHole_type, wchar_t > IsCountersunkHole_traits;

      const IsCountersunkHole_optional&
      IsCountersunkHole () const;

      IsCountersunkHole_optional&
      IsCountersunkHole ();

      void
      IsCountersunkHole (const IsCountersunkHole_type& x);

      void
      IsCountersunkHole (const IsCountersunkHole_optional& x);

      // IsCounterboredHole
      //
      typedef ::xml_schema::boolean IsCounterboredHole_type;
      typedef ::xsd::cxx::tree::optional< IsCounterboredHole_type > IsCounterboredHole_optional;
      typedef ::xsd::cxx::tree::traits< IsCounterboredHole_type, wchar_t > IsCounterboredHole_traits;

      const IsCounterboredHole_optional&
      IsCounterboredHole () const;

      IsCounterboredHole_optional&
      IsCounterboredHole ();

      void
      IsCounterboredHole (const IsCounterboredHole_type& x);

      void
      IsCounterboredHole (const IsCounterboredHole_optional& x);

      // IsSpotface
      //
      typedef ::xml_schema::boolean IsSpotface_type;
      typedef ::xsd::cxx::tree::optional< IsSpotface_type > IsSpotface_optional;
      typedef ::xsd::cxx::tree::traits< IsSpotface_type, wchar_t > IsSpotface_traits;

      const IsSpotface_optional&
      IsSpotface () const;

      IsSpotface_optional&
      IsSpotface ();

      void
      IsSpotface (const IsSpotface_type& x);

      void
      IsSpotface (const IsSpotface_optional& x);

      // Constructors.
      //
      GroupFeatureDefinitionType ();

      GroupFeatureDefinitionType (const id_type&);

      GroupFeatureDefinitionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      GroupFeatureDefinitionType (const GroupFeatureDefinitionType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual GroupFeatureDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GroupFeatureDefinitionType&
      operator= (const GroupFeatureDefinitionType& x);

      virtual 
      ~GroupFeatureDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      IsProfileGroup_optional IsProfileGroup_;
      IsRunoutGroup_optional IsRunoutGroup_;
      IsCountersunkHole_optional IsCountersunkHole_;
      IsCounterboredHole_optional IsCounterboredHole_;
      IsSpotface_optional IsSpotface_;
    };

    class QIF30_SYMBOL_DECL GroupFeatureNominalType: public ::xsd::qif30::ShapeFeatureNominalBaseType
    {
      public:
      // FeatureNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType FeatureNominalIds_type;
      typedef ::xsd::cxx::tree::traits< FeatureNominalIds_type, wchar_t > FeatureNominalIds_traits;

      const FeatureNominalIds_type&
      FeatureNominalIds () const;

      FeatureNominalIds_type&
      FeatureNominalIds ();

      void
      FeatureNominalIds (const FeatureNominalIds_type& x);

      void
      FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > p);

      // Constructors.
      //
      GroupFeatureNominalType ();

      GroupFeatureNominalType (const id_type&,
                               const FeatureDefinitionId_type&,
                               const FeatureNominalIds_type&);

      GroupFeatureNominalType (const id_type&,
                               ::std::unique_ptr< FeatureDefinitionId_type >,
                               ::std::unique_ptr< FeatureNominalIds_type >);

      GroupFeatureNominalType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      GroupFeatureNominalType (const GroupFeatureNominalType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual GroupFeatureNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GroupFeatureNominalType&
      operator= (const GroupFeatureNominalType& x);

      virtual 
      ~GroupFeatureNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureNominalIds_type > FeatureNominalIds_;
    };

    class QIF30_SYMBOL_DECL GroupFeatureMeasurementType: public ::xsd::qif30::ShapeFeatureMeasurementBaseType
    {
      public:
      // Constructors.
      //
      GroupFeatureMeasurementType ();

      GroupFeatureMeasurementType (const id_type&);

      GroupFeatureMeasurementType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      GroupFeatureMeasurementType (const GroupFeatureMeasurementType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual GroupFeatureMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      GroupFeatureMeasurementType&
      operator= (const GroupFeatureMeasurementType&) = default;
#endif

      virtual 
      ~GroupFeatureMeasurementType ();
    };

    class QIF30_SYMBOL_DECL PatternFeatureItemBaseType: public ::xsd::qif30::GroupFeatureItemType
    {
      public:
      // Constructors.
      //
      PatternFeatureItemBaseType ();

      PatternFeatureItemBaseType (const id_type&,
                                  const FeatureNominalId_type&,
                                  const FeatureName_type&);

      PatternFeatureItemBaseType (const id_type&,
                                  ::std::unique_ptr< FeatureNominalId_type >,
                                  const FeatureName_type&);

      PatternFeatureItemBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      PatternFeatureItemBaseType (const PatternFeatureItemBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual PatternFeatureItemBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PatternFeatureItemBaseType&
      operator= (const PatternFeatureItemBaseType&) = default;
#endif

      virtual 
      ~PatternFeatureItemBaseType ();
    };

    class QIF30_SYMBOL_DECL PatternFeatureDefinitionBaseType: public ::xsd::qif30::GroupFeatureDefinitionType
    {
      public:
      // Constructors.
      //
      PatternFeatureDefinitionBaseType ();

      PatternFeatureDefinitionBaseType (const id_type&);

      PatternFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      PatternFeatureDefinitionBaseType (const PatternFeatureDefinitionBaseType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual PatternFeatureDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PatternFeatureDefinitionBaseType&
      operator= (const PatternFeatureDefinitionBaseType&) = default;
#endif

      virtual 
      ~PatternFeatureDefinitionBaseType ();
    };

    class QIF30_SYMBOL_DECL PatternFeatureNominalBaseType: public ::xsd::qif30::GroupFeatureNominalType
    {
      public:
      // Constructors.
      //
      PatternFeatureNominalBaseType ();

      PatternFeatureNominalBaseType (const id_type&,
                                     const FeatureDefinitionId_type&,
                                     const FeatureNominalIds_type&);

      PatternFeatureNominalBaseType (const id_type&,
                                     ::std::unique_ptr< FeatureDefinitionId_type >,
                                     ::std::unique_ptr< FeatureNominalIds_type >);

      PatternFeatureNominalBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      PatternFeatureNominalBaseType (const PatternFeatureNominalBaseType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual PatternFeatureNominalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PatternFeatureNominalBaseType&
      operator= (const PatternFeatureNominalBaseType&) = default;
#endif

      virtual 
      ~PatternFeatureNominalBaseType ();
    };

    class QIF30_SYMBOL_DECL PatternFeatureLinearItemType: public ::xsd::qif30::PatternFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      PatternFeatureLinearItemType ();

      PatternFeatureLinearItemType (const id_type&,
                                    const FeatureNominalId_type&,
                                    const FeatureName_type&);

      PatternFeatureLinearItemType (const id_type&,
                                    ::std::unique_ptr< FeatureNominalId_type >,
                                    const FeatureName_type&);

      PatternFeatureLinearItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      PatternFeatureLinearItemType (const PatternFeatureLinearItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual PatternFeatureLinearItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PatternFeatureLinearItemType&
      operator= (const PatternFeatureLinearItemType&) = default;
#endif

      virtual 
      ~PatternFeatureLinearItemType ();
    };

    class QIF30_SYMBOL_DECL PatternFeatureLinearDefinitionType: public ::xsd::qif30::PatternFeatureDefinitionBaseType
    {
      public:
      // LineDirection
      //
      typedef ::xsd::qif30::UnitVectorType LineDirection_type;
      typedef ::xsd::cxx::tree::traits< LineDirection_type, wchar_t > LineDirection_traits;

      const LineDirection_type&
      LineDirection () const;

      LineDirection_type&
      LineDirection ();

      void
      LineDirection (const LineDirection_type& x);

      void
      LineDirection (::std::unique_ptr< LineDirection_type > p);

      // IncrementalDistance
      //
      typedef ::xsd::qif30::LinearValueType IncrementalDistance_type;
      typedef ::xsd::cxx::tree::traits< IncrementalDistance_type, wchar_t > IncrementalDistance_traits;

      const IncrementalDistance_type&
      IncrementalDistance () const;

      IncrementalDistance_type&
      IncrementalDistance ();

      void
      IncrementalDistance (const IncrementalDistance_type& x);

      void
      IncrementalDistance (::std::unique_ptr< IncrementalDistance_type > p);

      // FeatureDirection
      //
      typedef ::xsd::qif30::UnitVectorType FeatureDirection_type;
      typedef ::xsd::cxx::tree::optional< FeatureDirection_type > FeatureDirection_optional;
      typedef ::xsd::cxx::tree::traits< FeatureDirection_type, wchar_t > FeatureDirection_traits;

      const FeatureDirection_optional&
      FeatureDirection () const;

      FeatureDirection_optional&
      FeatureDirection ();

      void
      FeatureDirection (const FeatureDirection_type& x);

      void
      FeatureDirection (const FeatureDirection_optional& x);

      void
      FeatureDirection (::std::unique_ptr< FeatureDirection_type > p);

      // NumberOfFeatures
      //
      typedef ::xsd::qif30::NaturalType NumberOfFeatures_type;
      typedef ::xsd::cxx::tree::traits< NumberOfFeatures_type, wchar_t > NumberOfFeatures_traits;

      const NumberOfFeatures_type&
      NumberOfFeatures () const;

      NumberOfFeatures_type&
      NumberOfFeatures ();

      void
      NumberOfFeatures (const NumberOfFeatures_type& x);

      void
      NumberOfFeatures (::std::unique_ptr< NumberOfFeatures_type > p);

      // Constructors.
      //
      PatternFeatureLinearDefinitionType ();

      PatternFeatureLinearDefinitionType (const id_type&,
                                          const LineDirection_type&,
                                          const IncrementalDistance_type&,
                                          const NumberOfFeatures_type&);

      PatternFeatureLinearDefinitionType (const id_type&,
                                          ::std::unique_ptr< LineDirection_type >,
                                          ::std::unique_ptr< IncrementalDistance_type >,
                                          const NumberOfFeatures_type&);

      PatternFeatureLinearDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PatternFeatureLinearDefinitionType (const PatternFeatureLinearDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual PatternFeatureLinearDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PatternFeatureLinearDefinitionType&
      operator= (const PatternFeatureLinearDefinitionType& x);

      virtual 
      ~PatternFeatureLinearDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LineDirection_type > LineDirection_;
      ::xsd::cxx::tree::one< IncrementalDistance_type > IncrementalDistance_;
      FeatureDirection_optional FeatureDirection_;
      ::xsd::cxx::tree::one< NumberOfFeatures_type > NumberOfFeatures_;
    };

    class QIF30_SYMBOL_DECL PatternFeatureLinearNominalType: public ::xsd::qif30::PatternFeatureNominalBaseType
    {
      public:
      // FirstFeatureLocation
      //
      typedef ::xsd::qif30::QIFReferenceType FirstFeatureLocation_type;
      typedef ::xsd::cxx::tree::traits< FirstFeatureLocation_type, wchar_t > FirstFeatureLocation_traits;

      const FirstFeatureLocation_type&
      FirstFeatureLocation () const;

      FirstFeatureLocation_type&
      FirstFeatureLocation ();

      void
      FirstFeatureLocation (const FirstFeatureLocation_type& x);

      void
      FirstFeatureLocation (::std::unique_ptr< FirstFeatureLocation_type > p);

      // Constructors.
      //
      PatternFeatureLinearNominalType ();

      PatternFeatureLinearNominalType (const id_type&,
                                       const FeatureDefinitionId_type&,
                                       const FeatureNominalIds_type&,
                                       const FirstFeatureLocation_type&);

      PatternFeatureLinearNominalType (const id_type&,
                                       ::std::unique_ptr< FeatureDefinitionId_type >,
                                       ::std::unique_ptr< FeatureNominalIds_type >,
                                       ::std::unique_ptr< FirstFeatureLocation_type >);

      PatternFeatureLinearNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      PatternFeatureLinearNominalType (const PatternFeatureLinearNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual PatternFeatureLinearNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PatternFeatureLinearNominalType&
      operator= (const PatternFeatureLinearNominalType& x);

      virtual 
      ~PatternFeatureLinearNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FirstFeatureLocation_type > FirstFeatureLocation_;
    };

    class QIF30_SYMBOL_DECL PatternFeatureParallelogramItemType: public ::xsd::qif30::PatternFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      PatternFeatureParallelogramItemType ();

      PatternFeatureParallelogramItemType (const id_type&,
                                           const FeatureNominalId_type&,
                                           const FeatureName_type&);

      PatternFeatureParallelogramItemType (const id_type&,
                                           ::std::unique_ptr< FeatureNominalId_type >,
                                           const FeatureName_type&);

      PatternFeatureParallelogramItemType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      PatternFeatureParallelogramItemType (const PatternFeatureParallelogramItemType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual PatternFeatureParallelogramItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PatternFeatureParallelogramItemType&
      operator= (const PatternFeatureParallelogramItemType&) = default;
#endif

      virtual 
      ~PatternFeatureParallelogramItemType ();
    };

    class QIF30_SYMBOL_DECL PatternFeatureParallelogramDefinitionType: public ::xsd::qif30::PatternFeatureDefinitionBaseType
    {
      public:
      // AlongRowDirection
      //
      typedef ::xsd::qif30::VectorType AlongRowDirection_type;
      typedef ::xsd::cxx::tree::traits< AlongRowDirection_type, wchar_t > AlongRowDirection_traits;

      const AlongRowDirection_type&
      AlongRowDirection () const;

      AlongRowDirection_type&
      AlongRowDirection ();

      void
      AlongRowDirection (const AlongRowDirection_type& x);

      void
      AlongRowDirection (::std::unique_ptr< AlongRowDirection_type > p);

      // IncrementalRowDistance
      //
      typedef ::xsd::qif30::LinearValueType IncrementalRowDistance_type;
      typedef ::xsd::cxx::tree::traits< IncrementalRowDistance_type, wchar_t > IncrementalRowDistance_traits;

      const IncrementalRowDistance_type&
      IncrementalRowDistance () const;

      IncrementalRowDistance_type&
      IncrementalRowDistance ();

      void
      IncrementalRowDistance (const IncrementalRowDistance_type& x);

      void
      IncrementalRowDistance (::std::unique_ptr< IncrementalRowDistance_type > p);

      // BetweenRowDirection
      //
      typedef ::xsd::qif30::VectorType BetweenRowDirection_type;
      typedef ::xsd::cxx::tree::traits< BetweenRowDirection_type, wchar_t > BetweenRowDirection_traits;

      const BetweenRowDirection_type&
      BetweenRowDirection () const;

      BetweenRowDirection_type&
      BetweenRowDirection ();

      void
      BetweenRowDirection (const BetweenRowDirection_type& x);

      void
      BetweenRowDirection (::std::unique_ptr< BetweenRowDirection_type > p);

      // RowSeparationDistance
      //
      typedef ::xsd::qif30::LinearValueType RowSeparationDistance_type;
      typedef ::xsd::cxx::tree::traits< RowSeparationDistance_type, wchar_t > RowSeparationDistance_traits;

      const RowSeparationDistance_type&
      RowSeparationDistance () const;

      RowSeparationDistance_type&
      RowSeparationDistance ();

      void
      RowSeparationDistance (const RowSeparationDistance_type& x);

      void
      RowSeparationDistance (::std::unique_ptr< RowSeparationDistance_type > p);

      // FeatureDirection
      //
      typedef ::xsd::qif30::UnitVectorType FeatureDirection_type;
      typedef ::xsd::cxx::tree::optional< FeatureDirection_type > FeatureDirection_optional;
      typedef ::xsd::cxx::tree::traits< FeatureDirection_type, wchar_t > FeatureDirection_traits;

      const FeatureDirection_optional&
      FeatureDirection () const;

      FeatureDirection_optional&
      FeatureDirection ();

      void
      FeatureDirection (const FeatureDirection_type& x);

      void
      FeatureDirection (const FeatureDirection_optional& x);

      void
      FeatureDirection (::std::unique_ptr< FeatureDirection_type > p);

      // NumberOfFeaturesPerRow
      //
      typedef ::xsd::qif30::NaturalType NumberOfFeaturesPerRow_type;
      typedef ::xsd::cxx::tree::traits< NumberOfFeaturesPerRow_type, wchar_t > NumberOfFeaturesPerRow_traits;

      const NumberOfFeaturesPerRow_type&
      NumberOfFeaturesPerRow () const;

      NumberOfFeaturesPerRow_type&
      NumberOfFeaturesPerRow ();

      void
      NumberOfFeaturesPerRow (const NumberOfFeaturesPerRow_type& x);

      void
      NumberOfFeaturesPerRow (::std::unique_ptr< NumberOfFeaturesPerRow_type > p);

      // NumberOfRows
      //
      typedef ::xsd::qif30::NaturalType NumberOfRows_type;
      typedef ::xsd::cxx::tree::traits< NumberOfRows_type, wchar_t > NumberOfRows_traits;

      const NumberOfRows_type&
      NumberOfRows () const;

      NumberOfRows_type&
      NumberOfRows ();

      void
      NumberOfRows (const NumberOfRows_type& x);

      void
      NumberOfRows (::std::unique_ptr< NumberOfRows_type > p);

      // Constructors.
      //
      PatternFeatureParallelogramDefinitionType ();

      PatternFeatureParallelogramDefinitionType (const id_type&,
                                                 const AlongRowDirection_type&,
                                                 const IncrementalRowDistance_type&,
                                                 const BetweenRowDirection_type&,
                                                 const RowSeparationDistance_type&,
                                                 const NumberOfFeaturesPerRow_type&,
                                                 const NumberOfRows_type&);

      PatternFeatureParallelogramDefinitionType (const id_type&,
                                                 ::std::unique_ptr< AlongRowDirection_type >,
                                                 ::std::unique_ptr< IncrementalRowDistance_type >,
                                                 ::std::unique_ptr< BetweenRowDirection_type >,
                                                 ::std::unique_ptr< RowSeparationDistance_type >,
                                                 const NumberOfFeaturesPerRow_type&,
                                                 const NumberOfRows_type&);

      PatternFeatureParallelogramDefinitionType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      PatternFeatureParallelogramDefinitionType (const PatternFeatureParallelogramDefinitionType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual PatternFeatureParallelogramDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PatternFeatureParallelogramDefinitionType&
      operator= (const PatternFeatureParallelogramDefinitionType& x);

      virtual 
      ~PatternFeatureParallelogramDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AlongRowDirection_type > AlongRowDirection_;
      ::xsd::cxx::tree::one< IncrementalRowDistance_type > IncrementalRowDistance_;
      ::xsd::cxx::tree::one< BetweenRowDirection_type > BetweenRowDirection_;
      ::xsd::cxx::tree::one< RowSeparationDistance_type > RowSeparationDistance_;
      FeatureDirection_optional FeatureDirection_;
      ::xsd::cxx::tree::one< NumberOfFeaturesPerRow_type > NumberOfFeaturesPerRow_;
      ::xsd::cxx::tree::one< NumberOfRows_type > NumberOfRows_;
    };

    class QIF30_SYMBOL_DECL PatternFeatureParallelogramNominalType: public ::xsd::qif30::PatternFeatureNominalBaseType
    {
      public:
      // FirstFeatureLocation
      //
      typedef ::xsd::qif30::QIFReferenceType FirstFeatureLocation_type;
      typedef ::xsd::cxx::tree::traits< FirstFeatureLocation_type, wchar_t > FirstFeatureLocation_traits;

      const FirstFeatureLocation_type&
      FirstFeatureLocation () const;

      FirstFeatureLocation_type&
      FirstFeatureLocation ();

      void
      FirstFeatureLocation (const FirstFeatureLocation_type& x);

      void
      FirstFeatureLocation (::std::unique_ptr< FirstFeatureLocation_type > p);

      // Constructors.
      //
      PatternFeatureParallelogramNominalType ();

      PatternFeatureParallelogramNominalType (const id_type&,
                                              const FeatureDefinitionId_type&,
                                              const FeatureNominalIds_type&,
                                              const FirstFeatureLocation_type&);

      PatternFeatureParallelogramNominalType (const id_type&,
                                              ::std::unique_ptr< FeatureDefinitionId_type >,
                                              ::std::unique_ptr< FeatureNominalIds_type >,
                                              ::std::unique_ptr< FirstFeatureLocation_type >);

      PatternFeatureParallelogramNominalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      PatternFeatureParallelogramNominalType (const PatternFeatureParallelogramNominalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual PatternFeatureParallelogramNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PatternFeatureParallelogramNominalType&
      operator= (const PatternFeatureParallelogramNominalType& x);

      virtual 
      ~PatternFeatureParallelogramNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FirstFeatureLocation_type > FirstFeatureLocation_;
    };

    class QIF30_SYMBOL_DECL PatternFeatureCircularArcItemType: public ::xsd::qif30::PatternFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      PatternFeatureCircularArcItemType ();

      PatternFeatureCircularArcItemType (const id_type&,
                                         const FeatureNominalId_type&,
                                         const FeatureName_type&);

      PatternFeatureCircularArcItemType (const id_type&,
                                         ::std::unique_ptr< FeatureNominalId_type >,
                                         const FeatureName_type&);

      PatternFeatureCircularArcItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      PatternFeatureCircularArcItemType (const PatternFeatureCircularArcItemType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual PatternFeatureCircularArcItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PatternFeatureCircularArcItemType&
      operator= (const PatternFeatureCircularArcItemType&) = default;
#endif

      virtual 
      ~PatternFeatureCircularArcItemType ();
    };

    class QIF30_SYMBOL_DECL PatternFeatureCircularArcDefinitionType: public ::xsd::qif30::PatternFeatureDefinitionBaseType
    {
      public:
      // ArcRadius
      //
      typedef ::xsd::qif30::LinearValueType ArcRadius_type;
      typedef ::xsd::cxx::tree::traits< ArcRadius_type, wchar_t > ArcRadius_traits;

      const ArcRadius_type&
      ArcRadius () const;

      ArcRadius_type&
      ArcRadius ();

      void
      ArcRadius (const ArcRadius_type& x);

      void
      ArcRadius (::std::unique_ptr< ArcRadius_type > p);

      // IncrementalArc
      //
      typedef ::xsd::qif30::AngularValueType IncrementalArc_type;
      typedef ::xsd::cxx::tree::traits< IncrementalArc_type, wchar_t > IncrementalArc_traits;

      const IncrementalArc_type&
      IncrementalArc () const;

      IncrementalArc_type&
      IncrementalArc ();

      void
      IncrementalArc (const IncrementalArc_type& x);

      void
      IncrementalArc (::std::unique_ptr< IncrementalArc_type > p);

      // FeatureDirection
      //
      typedef ::xsd::qif30::UnitVectorType FeatureDirection_type;
      typedef ::xsd::cxx::tree::optional< FeatureDirection_type > FeatureDirection_optional;
      typedef ::xsd::cxx::tree::traits< FeatureDirection_type, wchar_t > FeatureDirection_traits;

      const FeatureDirection_optional&
      FeatureDirection () const;

      FeatureDirection_optional&
      FeatureDirection ();

      void
      FeatureDirection (const FeatureDirection_type& x);

      void
      FeatureDirection (const FeatureDirection_optional& x);

      void
      FeatureDirection (::std::unique_ptr< FeatureDirection_type > p);

      // NumberOfFeatures
      //
      typedef ::xsd::qif30::NaturalType NumberOfFeatures_type;
      typedef ::xsd::cxx::tree::traits< NumberOfFeatures_type, wchar_t > NumberOfFeatures_traits;

      const NumberOfFeatures_type&
      NumberOfFeatures () const;

      NumberOfFeatures_type&
      NumberOfFeatures ();

      void
      NumberOfFeatures (const NumberOfFeatures_type& x);

      void
      NumberOfFeatures (::std::unique_ptr< NumberOfFeatures_type > p);

      // Constructors.
      //
      PatternFeatureCircularArcDefinitionType ();

      PatternFeatureCircularArcDefinitionType (const id_type&,
                                               const ArcRadius_type&,
                                               const IncrementalArc_type&,
                                               const NumberOfFeatures_type&);

      PatternFeatureCircularArcDefinitionType (const id_type&,
                                               ::std::unique_ptr< ArcRadius_type >,
                                               ::std::unique_ptr< IncrementalArc_type >,
                                               const NumberOfFeatures_type&);

      PatternFeatureCircularArcDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      PatternFeatureCircularArcDefinitionType (const PatternFeatureCircularArcDefinitionType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual PatternFeatureCircularArcDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PatternFeatureCircularArcDefinitionType&
      operator= (const PatternFeatureCircularArcDefinitionType& x);

      virtual 
      ~PatternFeatureCircularArcDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ArcRadius_type > ArcRadius_;
      ::xsd::cxx::tree::one< IncrementalArc_type > IncrementalArc_;
      FeatureDirection_optional FeatureDirection_;
      ::xsd::cxx::tree::one< NumberOfFeatures_type > NumberOfFeatures_;
    };

    class QIF30_SYMBOL_DECL PatternFeatureCircularArcNominalType: public ::xsd::qif30::PatternFeatureNominalBaseType
    {
      public:
      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Center
      //
      typedef ::xsd::qif30::PointType Center_type;
      typedef ::xsd::cxx::tree::traits< Center_type, wchar_t > Center_traits;

      const Center_type&
      Center () const;

      Center_type&
      Center ();

      void
      Center (const Center_type& x);

      void
      Center (::std::unique_ptr< Center_type > p);

      // FirstFeatureLocation
      //
      typedef ::xsd::qif30::QIFReferenceType FirstFeatureLocation_type;
      typedef ::xsd::cxx::tree::traits< FirstFeatureLocation_type, wchar_t > FirstFeatureLocation_traits;

      const FirstFeatureLocation_type&
      FirstFeatureLocation () const;

      FirstFeatureLocation_type&
      FirstFeatureLocation ();

      void
      FirstFeatureLocation (const FirstFeatureLocation_type& x);

      void
      FirstFeatureLocation (::std::unique_ptr< FirstFeatureLocation_type > p);

      // Constructors.
      //
      PatternFeatureCircularArcNominalType ();

      PatternFeatureCircularArcNominalType (const id_type&,
                                            const FeatureDefinitionId_type&,
                                            const FeatureNominalIds_type&,
                                            const Normal_type&,
                                            const Center_type&,
                                            const FirstFeatureLocation_type&);

      PatternFeatureCircularArcNominalType (const id_type&,
                                            ::std::unique_ptr< FeatureDefinitionId_type >,
                                            ::std::unique_ptr< FeatureNominalIds_type >,
                                            ::std::unique_ptr< Normal_type >,
                                            ::std::unique_ptr< Center_type >,
                                            ::std::unique_ptr< FirstFeatureLocation_type >);

      PatternFeatureCircularArcNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      PatternFeatureCircularArcNominalType (const PatternFeatureCircularArcNominalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual PatternFeatureCircularArcNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PatternFeatureCircularArcNominalType&
      operator= (const PatternFeatureCircularArcNominalType& x);

      virtual 
      ~PatternFeatureCircularArcNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      ::xsd::cxx::tree::one< Center_type > Center_;
      ::xsd::cxx::tree::one< FirstFeatureLocation_type > FirstFeatureLocation_;
    };

    class QIF30_SYMBOL_DECL PatternFeatureCircleItemType: public ::xsd::qif30::PatternFeatureItemBaseType
    {
      public:
      // Constructors.
      //
      PatternFeatureCircleItemType ();

      PatternFeatureCircleItemType (const id_type&,
                                    const FeatureNominalId_type&,
                                    const FeatureName_type&);

      PatternFeatureCircleItemType (const id_type&,
                                    ::std::unique_ptr< FeatureNominalId_type >,
                                    const FeatureName_type&);

      PatternFeatureCircleItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      PatternFeatureCircleItemType (const PatternFeatureCircleItemType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual PatternFeatureCircleItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PatternFeatureCircleItemType&
      operator= (const PatternFeatureCircleItemType&) = default;
#endif

      virtual 
      ~PatternFeatureCircleItemType ();
    };

    class QIF30_SYMBOL_DECL PatternFeatureCircleDefinitionType: public ::xsd::qif30::PatternFeatureDefinitionBaseType
    {
      public:
      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // FeatureDirection
      //
      typedef ::xsd::qif30::UnitVectorType FeatureDirection_type;
      typedef ::xsd::cxx::tree::optional< FeatureDirection_type > FeatureDirection_optional;
      typedef ::xsd::cxx::tree::traits< FeatureDirection_type, wchar_t > FeatureDirection_traits;

      const FeatureDirection_optional&
      FeatureDirection () const;

      FeatureDirection_optional&
      FeatureDirection ();

      void
      FeatureDirection (const FeatureDirection_type& x);

      void
      FeatureDirection (const FeatureDirection_optional& x);

      void
      FeatureDirection (::std::unique_ptr< FeatureDirection_type > p);

      // NumberOfFeatures
      //
      typedef ::xsd::qif30::NaturalType NumberOfFeatures_type;
      typedef ::xsd::cxx::tree::traits< NumberOfFeatures_type, wchar_t > NumberOfFeatures_traits;

      const NumberOfFeatures_type&
      NumberOfFeatures () const;

      NumberOfFeatures_type&
      NumberOfFeatures ();

      void
      NumberOfFeatures (const NumberOfFeatures_type& x);

      void
      NumberOfFeatures (::std::unique_ptr< NumberOfFeatures_type > p);

      // Constructors.
      //
      PatternFeatureCircleDefinitionType ();

      PatternFeatureCircleDefinitionType (const id_type&,
                                          const Diameter_type&,
                                          const NumberOfFeatures_type&);

      PatternFeatureCircleDefinitionType (const id_type&,
                                          ::std::unique_ptr< Diameter_type >,
                                          const NumberOfFeatures_type&);

      PatternFeatureCircleDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      PatternFeatureCircleDefinitionType (const PatternFeatureCircleDefinitionType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual PatternFeatureCircleDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PatternFeatureCircleDefinitionType&
      operator= (const PatternFeatureCircleDefinitionType& x);

      virtual 
      ~PatternFeatureCircleDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      FeatureDirection_optional FeatureDirection_;
      ::xsd::cxx::tree::one< NumberOfFeatures_type > NumberOfFeatures_;
    };

    class QIF30_SYMBOL_DECL PatternFeatureCircleNominalType: public ::xsd::qif30::PatternFeatureNominalBaseType
    {
      public:
      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Center
      //
      typedef ::xsd::qif30::PointType Center_type;
      typedef ::xsd::cxx::tree::traits< Center_type, wchar_t > Center_traits;

      const Center_type&
      Center () const;

      Center_type&
      Center ();

      void
      Center (const Center_type& x);

      void
      Center (::std::unique_ptr< Center_type > p);

      // FirstFeatureLocation
      //
      typedef ::xsd::qif30::QIFReferenceType FirstFeatureLocation_type;
      typedef ::xsd::cxx::tree::traits< FirstFeatureLocation_type, wchar_t > FirstFeatureLocation_traits;

      const FirstFeatureLocation_type&
      FirstFeatureLocation () const;

      FirstFeatureLocation_type&
      FirstFeatureLocation ();

      void
      FirstFeatureLocation (const FirstFeatureLocation_type& x);

      void
      FirstFeatureLocation (::std::unique_ptr< FirstFeatureLocation_type > p);

      // Constructors.
      //
      PatternFeatureCircleNominalType ();

      PatternFeatureCircleNominalType (const id_type&,
                                       const FeatureDefinitionId_type&,
                                       const FeatureNominalIds_type&,
                                       const Normal_type&,
                                       const Center_type&,
                                       const FirstFeatureLocation_type&);

      PatternFeatureCircleNominalType (const id_type&,
                                       ::std::unique_ptr< FeatureDefinitionId_type >,
                                       ::std::unique_ptr< FeatureNominalIds_type >,
                                       ::std::unique_ptr< Normal_type >,
                                       ::std::unique_ptr< Center_type >,
                                       ::std::unique_ptr< FirstFeatureLocation_type >);

      PatternFeatureCircleNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      PatternFeatureCircleNominalType (const PatternFeatureCircleNominalType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual PatternFeatureCircleNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PatternFeatureCircleNominalType&
      operator= (const PatternFeatureCircleNominalType& x);

      virtual 
      ~PatternFeatureCircleNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      ::xsd::cxx::tree::one< Center_type > Center_;
      ::xsd::cxx::tree::one< FirstFeatureLocation_type > FirstFeatureLocation_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Label
      //
      typedef ::xml_schema::token Label_type;
      typedef ::xsd::cxx::tree::optional< Label_type > Label_optional;
      typedef ::xsd::cxx::tree::traits< Label_type, wchar_t > Label_traits;

      const Label_optional&
      Label () const;

      Label_optional&
      Label ();

      void
      Label (const Label_type& x);

      void
      Label (const Label_optional& x);

      void
      Label (::std::unique_ptr< Label_type > p);

      // SurfaceFeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType SurfaceFeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< SurfaceFeatureNominalId_type > SurfaceFeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceFeatureNominalId_type, wchar_t > SurfaceFeatureNominalId_traits;

      const SurfaceFeatureNominalId_optional&
      SurfaceFeatureNominalId () const;

      SurfaceFeatureNominalId_optional&
      SurfaceFeatureNominalId ();

      void
      SurfaceFeatureNominalId (const SurfaceFeatureNominalId_type& x);

      void
      SurfaceFeatureNominalId (const SurfaceFeatureNominalId_optional& x);

      void
      SurfaceFeatureNominalId (::std::unique_ptr< SurfaceFeatureNominalId_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      FeatureZoneBaseType ();

      FeatureZoneBaseType (const id_type&);

      FeatureZoneBaseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FeatureZoneBaseType (const FeatureZoneBaseType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual FeatureZoneBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FeatureZoneBaseType&
      operator= (const FeatureZoneBaseType& x);

      virtual 
      ~FeatureZoneBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Label_optional Label_;
      SurfaceFeatureNominalId_optional SurfaceFeatureNominalId_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL FeatureZonePointType: public ::xsd::qif30::FeatureZoneBaseType
    {
      public:
      // VertexId
      //
      typedef ::xsd::qif30::QIFReferenceFullType VertexId_type;
      typedef ::xsd::cxx::tree::optional< VertexId_type > VertexId_optional;
      typedef ::xsd::cxx::tree::traits< VertexId_type, wchar_t > VertexId_traits;

      const VertexId_optional&
      VertexId () const;

      VertexId_optional&
      VertexId ();

      void
      VertexId (const VertexId_type& x);

      void
      VertexId (const VertexId_optional& x);

      void
      VertexId (::std::unique_ptr< VertexId_type > p);

      // PointId
      //
      typedef ::xsd::qif30::QIFReferenceFullType PointId_type;
      typedef ::xsd::cxx::tree::optional< PointId_type > PointId_optional;
      typedef ::xsd::cxx::tree::traits< PointId_type, wchar_t > PointId_traits;

      const PointId_optional&
      PointId () const;

      PointId_optional&
      PointId ();

      void
      PointId (const PointId_type& x);

      void
      PointId (const PointId_optional& x);

      void
      PointId (::std::unique_ptr< PointId_type > p);

      // Point
      //
      typedef ::xsd::qif30::PointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::unique_ptr< Point_type > p);

      // Constructors.
      //
      FeatureZonePointType ();

      FeatureZonePointType (const id_type&,
                            const Point_type&);

      FeatureZonePointType (const id_type&,
                            ::std::unique_ptr< Point_type >);

      FeatureZonePointType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      FeatureZonePointType (const FeatureZonePointType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual FeatureZonePointType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZonePointType&
      operator= (const FeatureZonePointType& x);

      virtual 
      ~FeatureZonePointType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      VertexId_optional VertexId_;
      PointId_optional PointId_;
      ::xsd::cxx::tree::one< Point_type > Point_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneCurveBaseType: public ::xsd::qif30::FeatureZoneBaseType
    {
      public:
      // EdgeIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType EdgeIds_type;
      typedef ::xsd::cxx::tree::optional< EdgeIds_type > EdgeIds_optional;
      typedef ::xsd::cxx::tree::traits< EdgeIds_type, wchar_t > EdgeIds_traits;

      const EdgeIds_optional&
      EdgeIds () const;

      EdgeIds_optional&
      EdgeIds ();

      void
      EdgeIds (const EdgeIds_type& x);

      void
      EdgeIds (const EdgeIds_optional& x);

      void
      EdgeIds (::std::unique_ptr< EdgeIds_type > p);

      // CurveIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType CurveIds_type;
      typedef ::xsd::cxx::tree::optional< CurveIds_type > CurveIds_optional;
      typedef ::xsd::cxx::tree::traits< CurveIds_type, wchar_t > CurveIds_traits;

      const CurveIds_optional&
      CurveIds () const;

      CurveIds_optional&
      CurveIds ();

      void
      CurveIds (const CurveIds_type& x);

      void
      CurveIds (const CurveIds_optional& x);

      void
      CurveIds (::std::unique_ptr< CurveIds_type > p);

      // Constructors.
      //
      FeatureZoneCurveBaseType ();

      FeatureZoneCurveBaseType (const id_type&);

      FeatureZoneCurveBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      FeatureZoneCurveBaseType (const FeatureZoneCurveBaseType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual FeatureZoneCurveBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FeatureZoneCurveBaseType&
      operator= (const FeatureZoneCurveBaseType& x);

      virtual 
      ~FeatureZoneCurveBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      EdgeIds_optional EdgeIds_;
      CurveIds_optional CurveIds_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneCurveLineType: public ::xsd::qif30::FeatureZoneCurveBaseType
    {
      public:
      // Line
      //
      typedef ::xsd::qif30::LineSegmentType Line_type;
      typedef ::xsd::cxx::tree::traits< Line_type, wchar_t > Line_traits;

      const Line_type&
      Line () const;

      Line_type&
      Line ();

      void
      Line (const Line_type& x);

      void
      Line (::std::unique_ptr< Line_type > p);

      // Constructors.
      //
      FeatureZoneCurveLineType ();

      FeatureZoneCurveLineType (const id_type&,
                                const Line_type&);

      FeatureZoneCurveLineType (const id_type&,
                                ::std::unique_ptr< Line_type >);

      FeatureZoneCurveLineType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      FeatureZoneCurveLineType (const FeatureZoneCurveLineType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual FeatureZoneCurveLineType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneCurveLineType&
      operator= (const FeatureZoneCurveLineType& x);

      virtual 
      ~FeatureZoneCurveLineType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Line_type > Line_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneCurveCircularType: public ::xsd::qif30::FeatureZoneCurveBaseType
    {
      public:
      // Circle
      //
      typedef ::xsd::qif30::CircleType Circle_type;
      typedef ::xsd::cxx::tree::traits< Circle_type, wchar_t > Circle_traits;

      const Circle_type&
      Circle () const;

      Circle_type&
      Circle ();

      void
      Circle (const Circle_type& x);

      void
      Circle (::std::unique_ptr< Circle_type > p);

      // Constructors.
      //
      FeatureZoneCurveCircularType ();

      FeatureZoneCurveCircularType (const id_type&,
                                    const Circle_type&);

      FeatureZoneCurveCircularType (const id_type&,
                                    ::std::unique_ptr< Circle_type >);

      FeatureZoneCurveCircularType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      FeatureZoneCurveCircularType (const FeatureZoneCurveCircularType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual FeatureZoneCurveCircularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneCurveCircularType&
      operator= (const FeatureZoneCurveCircularType& x);

      virtual 
      ~FeatureZoneCurveCircularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Circle_type > Circle_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneCurveIrregularType: public ::xsd::qif30::FeatureZoneCurveBaseType
    {
      public:
      // CurvePoints
      //
      typedef ::xsd::qif30::PolyLineType CurvePoints_type;
      typedef ::xsd::cxx::tree::traits< CurvePoints_type, wchar_t > CurvePoints_traits;

      const CurvePoints_type&
      CurvePoints () const;

      CurvePoints_type&
      CurvePoints ();

      void
      CurvePoints (const CurvePoints_type& x);

      void
      CurvePoints (::std::unique_ptr< CurvePoints_type > p);

      // Constructors.
      //
      FeatureZoneCurveIrregularType ();

      FeatureZoneCurveIrregularType (const id_type&,
                                     const CurvePoints_type&);

      FeatureZoneCurveIrregularType (const id_type&,
                                     ::std::unique_ptr< CurvePoints_type >);

      FeatureZoneCurveIrregularType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      FeatureZoneCurveIrregularType (const FeatureZoneCurveIrregularType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual FeatureZoneCurveIrregularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneCurveIrregularType&
      operator= (const FeatureZoneCurveIrregularType& x);

      virtual 
      ~FeatureZoneCurveIrregularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CurvePoints_type > CurvePoints_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneAreaBaseType: public ::xsd::qif30::FeatureZoneBaseType
    {
      public:
      // FaceIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType FaceIds_type;
      typedef ::xsd::cxx::tree::optional< FaceIds_type > FaceIds_optional;
      typedef ::xsd::cxx::tree::traits< FaceIds_type, wchar_t > FaceIds_traits;

      const FaceIds_optional&
      FaceIds () const;

      FaceIds_optional&
      FaceIds ();

      void
      FaceIds (const FaceIds_type& x);

      void
      FaceIds (const FaceIds_optional& x);

      void
      FaceIds (::std::unique_ptr< FaceIds_type > p);

      // EdgeIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType EdgeIds_type;
      typedef ::xsd::cxx::tree::optional< EdgeIds_type > EdgeIds_optional;
      typedef ::xsd::cxx::tree::traits< EdgeIds_type, wchar_t > EdgeIds_traits;

      const EdgeIds_optional&
      EdgeIds () const;

      EdgeIds_optional&
      EdgeIds ();

      void
      EdgeIds (const EdgeIds_type& x);

      void
      EdgeIds (const EdgeIds_optional& x);

      void
      EdgeIds (::std::unique_ptr< EdgeIds_type > p);

      // Constructors.
      //
      FeatureZoneAreaBaseType ();

      FeatureZoneAreaBaseType (const id_type&);

      FeatureZoneAreaBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      FeatureZoneAreaBaseType (const FeatureZoneAreaBaseType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual FeatureZoneAreaBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FeatureZoneAreaBaseType&
      operator= (const FeatureZoneAreaBaseType& x);

      virtual 
      ~FeatureZoneAreaBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FaceIds_optional FaceIds_;
      EdgeIds_optional EdgeIds_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneAreaCircularType: public ::xsd::qif30::FeatureZoneAreaBaseType
    {
      public:
      // Circle
      //
      typedef ::xsd::qif30::CircleType Circle_type;
      typedef ::xsd::cxx::tree::traits< Circle_type, wchar_t > Circle_traits;

      const Circle_type&
      Circle () const;

      Circle_type&
      Circle ();

      void
      Circle (const Circle_type& x);

      void
      Circle (::std::unique_ptr< Circle_type > p);

      // Constructors.
      //
      FeatureZoneAreaCircularType ();

      FeatureZoneAreaCircularType (const id_type&,
                                   const Circle_type&);

      FeatureZoneAreaCircularType (const id_type&,
                                   ::std::unique_ptr< Circle_type >);

      FeatureZoneAreaCircularType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      FeatureZoneAreaCircularType (const FeatureZoneAreaCircularType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual FeatureZoneAreaCircularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneAreaCircularType&
      operator= (const FeatureZoneAreaCircularType& x);

      virtual 
      ~FeatureZoneAreaCircularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Circle_type > Circle_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneAreaRectangularType: public ::xsd::qif30::FeatureZoneAreaBaseType
    {
      public:
      // Rectangle
      //
      typedef ::xsd::qif30::RectangleType Rectangle_type;
      typedef ::xsd::cxx::tree::traits< Rectangle_type, wchar_t > Rectangle_traits;

      const Rectangle_type&
      Rectangle () const;

      Rectangle_type&
      Rectangle ();

      void
      Rectangle (const Rectangle_type& x);

      void
      Rectangle (::std::unique_ptr< Rectangle_type > p);

      // Constructors.
      //
      FeatureZoneAreaRectangularType ();

      FeatureZoneAreaRectangularType (const id_type&,
                                      const Rectangle_type&);

      FeatureZoneAreaRectangularType (const id_type&,
                                      ::std::unique_ptr< Rectangle_type >);

      FeatureZoneAreaRectangularType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      FeatureZoneAreaRectangularType (const FeatureZoneAreaRectangularType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual FeatureZoneAreaRectangularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneAreaRectangularType&
      operator= (const FeatureZoneAreaRectangularType& x);

      virtual 
      ~FeatureZoneAreaRectangularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Rectangle_type > Rectangle_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneAreaIrregularType: public ::xsd::qif30::FeatureZoneAreaBaseType
    {
      public:
      // Constructors.
      //
      FeatureZoneAreaIrregularType ();

      FeatureZoneAreaIrregularType (const id_type&);

      FeatureZoneAreaIrregularType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      FeatureZoneAreaIrregularType (const FeatureZoneAreaIrregularType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual FeatureZoneAreaIrregularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FeatureZoneAreaIrregularType&
      operator= (const FeatureZoneAreaIrregularType&) = default;
#endif

      virtual 
      ~FeatureZoneAreaIrregularType ();
    };

    class QIF30_SYMBOL_DECL FeatureZoneAreaCylindricalType: public ::xsd::qif30::FeatureZoneAreaBaseType
    {
      public:
      // Cylinder
      //
      typedef ::xsd::qif30::CylinderType Cylinder_type;
      typedef ::xsd::cxx::tree::traits< Cylinder_type, wchar_t > Cylinder_traits;

      const Cylinder_type&
      Cylinder () const;

      Cylinder_type&
      Cylinder ();

      void
      Cylinder (const Cylinder_type& x);

      void
      Cylinder (::std::unique_ptr< Cylinder_type > p);

      // Constructors.
      //
      FeatureZoneAreaCylindricalType ();

      FeatureZoneAreaCylindricalType (const id_type&,
                                      const Cylinder_type&);

      FeatureZoneAreaCylindricalType (const id_type&,
                                      ::std::unique_ptr< Cylinder_type >);

      FeatureZoneAreaCylindricalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      FeatureZoneAreaCylindricalType (const FeatureZoneAreaCylindricalType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual FeatureZoneAreaCylindricalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneAreaCylindricalType&
      operator= (const FeatureZoneAreaCylindricalType& x);

      virtual 
      ~FeatureZoneAreaCylindricalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Cylinder_type > Cylinder_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneAreaBetweenType: public ::xsd::qif30::FeatureZoneAreaBaseType
    {
      public:
      // FromPointZoneId
      //
      typedef ::xsd::qif30::QIFReferenceFullType FromPointZoneId_type;
      typedef ::xsd::cxx::tree::optional< FromPointZoneId_type > FromPointZoneId_optional;
      typedef ::xsd::cxx::tree::traits< FromPointZoneId_type, wchar_t > FromPointZoneId_traits;

      const FromPointZoneId_optional&
      FromPointZoneId () const;

      FromPointZoneId_optional&
      FromPointZoneId ();

      void
      FromPointZoneId (const FromPointZoneId_type& x);

      void
      FromPointZoneId (const FromPointZoneId_optional& x);

      void
      FromPointZoneId (::std::unique_ptr< FromPointZoneId_type > p);

      // FromCurveZoneId
      //
      typedef ::xsd::qif30::QIFReferenceFullType FromCurveZoneId_type;
      typedef ::xsd::cxx::tree::optional< FromCurveZoneId_type > FromCurveZoneId_optional;
      typedef ::xsd::cxx::tree::traits< FromCurveZoneId_type, wchar_t > FromCurveZoneId_traits;

      const FromCurveZoneId_optional&
      FromCurveZoneId () const;

      FromCurveZoneId_optional&
      FromCurveZoneId ();

      void
      FromCurveZoneId (const FromCurveZoneId_type& x);

      void
      FromCurveZoneId (const FromCurveZoneId_optional& x);

      void
      FromCurveZoneId (::std::unique_ptr< FromCurveZoneId_type > p);

      // ToPointZoneId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ToPointZoneId_type;
      typedef ::xsd::cxx::tree::optional< ToPointZoneId_type > ToPointZoneId_optional;
      typedef ::xsd::cxx::tree::traits< ToPointZoneId_type, wchar_t > ToPointZoneId_traits;

      const ToPointZoneId_optional&
      ToPointZoneId () const;

      ToPointZoneId_optional&
      ToPointZoneId ();

      void
      ToPointZoneId (const ToPointZoneId_type& x);

      void
      ToPointZoneId (const ToPointZoneId_optional& x);

      void
      ToPointZoneId (::std::unique_ptr< ToPointZoneId_type > p);

      // ToCurveZoneId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ToCurveZoneId_type;
      typedef ::xsd::cxx::tree::optional< ToCurveZoneId_type > ToCurveZoneId_optional;
      typedef ::xsd::cxx::tree::traits< ToCurveZoneId_type, wchar_t > ToCurveZoneId_traits;

      const ToCurveZoneId_optional&
      ToCurveZoneId () const;

      ToCurveZoneId_optional&
      ToCurveZoneId ();

      void
      ToCurveZoneId (const ToCurveZoneId_type& x);

      void
      ToCurveZoneId (const ToCurveZoneId_optional& x);

      void
      ToCurveZoneId (::std::unique_ptr< ToCurveZoneId_type > p);

      // StartDirection
      //
      typedef ::xsd::qif30::UnitVectorType StartDirection_type;
      typedef ::xsd::cxx::tree::optional< StartDirection_type > StartDirection_optional;
      typedef ::xsd::cxx::tree::traits< StartDirection_type, wchar_t > StartDirection_traits;

      const StartDirection_optional&
      StartDirection () const;

      StartDirection_optional&
      StartDirection ();

      void
      StartDirection (const StartDirection_type& x);

      void
      StartDirection (const StartDirection_optional& x);

      void
      StartDirection (::std::unique_ptr< StartDirection_type > p);

      // PlaneNormal
      //
      typedef ::xsd::qif30::UnitVectorType PlaneNormal_type;
      typedef ::xsd::cxx::tree::optional< PlaneNormal_type > PlaneNormal_optional;
      typedef ::xsd::cxx::tree::traits< PlaneNormal_type, wchar_t > PlaneNormal_traits;

      const PlaneNormal_optional&
      PlaneNormal () const;

      PlaneNormal_optional&
      PlaneNormal ();

      void
      PlaneNormal (const PlaneNormal_type& x);

      void
      PlaneNormal (const PlaneNormal_optional& x);

      void
      PlaneNormal (::std::unique_ptr< PlaneNormal_type > p);

      // Constructors.
      //
      FeatureZoneAreaBetweenType ();

      FeatureZoneAreaBetweenType (const id_type&);

      FeatureZoneAreaBetweenType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      FeatureZoneAreaBetweenType (const FeatureZoneAreaBetweenType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual FeatureZoneAreaBetweenType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneAreaBetweenType&
      operator= (const FeatureZoneAreaBetweenType& x);

      virtual 
      ~FeatureZoneAreaBetweenType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FromPointZoneId_optional FromPointZoneId_;
      FromCurveZoneId_optional FromCurveZoneId_;
      ToPointZoneId_optional ToPointZoneId_;
      ToCurveZoneId_optional ToCurveZoneId_;
      StartDirection_optional StartDirection_;
      PlaneNormal_optional PlaneNormal_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneAreaSphericalType: public ::xsd::qif30::FeatureZoneAreaBaseType
    {
      public:
      // Sphere
      //
      typedef ::xsd::qif30::SphereType Sphere_type;
      typedef ::xsd::cxx::tree::traits< Sphere_type, wchar_t > Sphere_traits;

      const Sphere_type&
      Sphere () const;

      Sphere_type&
      Sphere ();

      void
      Sphere (const Sphere_type& x);

      void
      Sphere (::std::unique_ptr< Sphere_type > p);

      // Constructors.
      //
      FeatureZoneAreaSphericalType ();

      FeatureZoneAreaSphericalType (const id_type&,
                                    const Sphere_type&);

      FeatureZoneAreaSphericalType (const id_type&,
                                    ::std::unique_ptr< Sphere_type >);

      FeatureZoneAreaSphericalType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      FeatureZoneAreaSphericalType (const FeatureZoneAreaSphericalType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual FeatureZoneAreaSphericalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneAreaSphericalType&
      operator= (const FeatureZoneAreaSphericalType& x);

      virtual 
      ~FeatureZoneAreaSphericalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Sphere_type > Sphere_;
    };

    class QIF30_SYMBOL_DECL FeatureAspectsListsType: public ::xml_schema::type
    {
      public:
      // FeatureDefinitions
      //
      typedef ::xsd::qif30::FeatureDefinitionsType FeatureDefinitions_type;
      typedef ::xsd::cxx::tree::optional< FeatureDefinitions_type > FeatureDefinitions_optional;
      typedef ::xsd::cxx::tree::traits< FeatureDefinitions_type, wchar_t > FeatureDefinitions_traits;

      const FeatureDefinitions_optional&
      FeatureDefinitions () const;

      FeatureDefinitions_optional&
      FeatureDefinitions ();

      void
      FeatureDefinitions (const FeatureDefinitions_type& x);

      void
      FeatureDefinitions (const FeatureDefinitions_optional& x);

      void
      FeatureDefinitions (::std::unique_ptr< FeatureDefinitions_type > p);

      // FeatureNominals
      //
      typedef ::xsd::qif30::FeatureNominalsType FeatureNominals_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominals_type > FeatureNominals_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominals_type, wchar_t > FeatureNominals_traits;

      const FeatureNominals_optional&
      FeatureNominals () const;

      FeatureNominals_optional&
      FeatureNominals ();

      void
      FeatureNominals (const FeatureNominals_type& x);

      void
      FeatureNominals (const FeatureNominals_optional& x);

      void
      FeatureNominals (::std::unique_ptr< FeatureNominals_type > p);

      // FeatureItems
      //
      typedef ::xsd::qif30::FeatureItemsType FeatureItems_type;
      typedef ::xsd::cxx::tree::optional< FeatureItems_type > FeatureItems_optional;
      typedef ::xsd::cxx::tree::traits< FeatureItems_type, wchar_t > FeatureItems_traits;

      const FeatureItems_optional&
      FeatureItems () const;

      FeatureItems_optional&
      FeatureItems ();

      void
      FeatureItems (const FeatureItems_type& x);

      void
      FeatureItems (const FeatureItems_optional& x);

      void
      FeatureItems (::std::unique_ptr< FeatureItems_type > p);

      // NominalPointSets
      //
      typedef ::xsd::qif30::NominalPointSetListType NominalPointSets_type;
      typedef ::xsd::cxx::tree::optional< NominalPointSets_type > NominalPointSets_optional;
      typedef ::xsd::cxx::tree::traits< NominalPointSets_type, wchar_t > NominalPointSets_traits;

      const NominalPointSets_optional&
      NominalPointSets () const;

      NominalPointSets_optional&
      NominalPointSets ();

      void
      NominalPointSets (const NominalPointSets_type& x);

      void
      NominalPointSets (const NominalPointSets_optional& x);

      void
      NominalPointSets (::std::unique_ptr< NominalPointSets_type > p);

      // Constructors.
      //
      FeatureAspectsListsType ();

      FeatureAspectsListsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      FeatureAspectsListsType (const FeatureAspectsListsType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual FeatureAspectsListsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureAspectsListsType&
      operator= (const FeatureAspectsListsType& x);

      virtual 
      ~FeatureAspectsListsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureDefinitions_optional FeatureDefinitions_;
      FeatureNominals_optional FeatureNominals_;
      FeatureItems_optional FeatureItems_;
      NominalPointSets_optional NominalPointSets_;
    };

    class QIF30_SYMBOL_DECL FeatureDefinitionsType: public ::xml_schema::type
    {
      public:
      // FeatureDefinition
      //
      typedef ::xsd::qif30::FeatureDefinitionBaseType FeatureDefinition_type;
      typedef ::xsd::cxx::tree::sequence< FeatureDefinition_type > FeatureDefinition_sequence;
      typedef xsd::cxx::tree::sequence< FeatureDefinition_type >::iterator FeatureDefinition_iterator;
      typedef xsd::cxx::tree::sequence< FeatureDefinition_type >::const_iterator FeatureDefinition_const_iterator;
      typedef ::xsd::cxx::tree::traits< FeatureDefinition_type, wchar_t > FeatureDefinition_traits;

      const FeatureDefinition_sequence&
      FeatureDefinition () const;

      FeatureDefinition_sequence&
      FeatureDefinition ();

      void
      FeatureDefinition (const FeatureDefinition_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FeatureDefinitionsType ();

      FeatureDefinitionsType (const n_type&);

      FeatureDefinitionsType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      FeatureDefinitionsType (const FeatureDefinitionsType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual FeatureDefinitionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureDefinitionsType&
      operator= (const FeatureDefinitionsType& x);

      virtual 
      ~FeatureDefinitionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureDefinition_sequence FeatureDefinition_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FeatureNominalsType: public ::xml_schema::type
    {
      public:
      // FeatureNominal
      //
      typedef ::xsd::qif30::FeatureNominalBaseType FeatureNominal_type;
      typedef ::xsd::cxx::tree::sequence< FeatureNominal_type > FeatureNominal_sequence;
      typedef xsd::cxx::tree::sequence< FeatureNominal_type >::iterator FeatureNominal_iterator;
      typedef xsd::cxx::tree::sequence< FeatureNominal_type >::const_iterator FeatureNominal_const_iterator;
      typedef ::xsd::cxx::tree::traits< FeatureNominal_type, wchar_t > FeatureNominal_traits;

      const FeatureNominal_sequence&
      FeatureNominal () const;

      FeatureNominal_sequence&
      FeatureNominal ();

      void
      FeatureNominal (const FeatureNominal_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FeatureNominalsType ();

      FeatureNominalsType (const n_type&);

      FeatureNominalsType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FeatureNominalsType (const FeatureNominalsType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual FeatureNominalsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureNominalsType&
      operator= (const FeatureNominalsType& x);

      virtual 
      ~FeatureNominalsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureNominal_sequence FeatureNominal_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FeatureItemsType: public ::xml_schema::type
    {
      public:
      // FeatureItem
      //
      typedef ::xsd::qif30::FeatureItemBaseType FeatureItem_type;
      typedef ::xsd::cxx::tree::sequence< FeatureItem_type > FeatureItem_sequence;
      typedef xsd::cxx::tree::sequence< FeatureItem_type >::iterator FeatureItem_iterator;
      typedef xsd::cxx::tree::sequence< FeatureItem_type >::const_iterator FeatureItem_const_iterator;
      typedef ::xsd::cxx::tree::traits< FeatureItem_type, wchar_t > FeatureItem_traits;

      const FeatureItem_sequence&
      FeatureItem () const;

      FeatureItem_sequence&
      FeatureItem ();

      void
      FeatureItem (const FeatureItem_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FeatureItemsType ();

      FeatureItemsType (const n_type&);

      FeatureItemsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      FeatureItemsType (const FeatureItemsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual FeatureItemsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureItemsType&
      operator= (const FeatureItemsType& x);

      virtual 
      ~FeatureItemsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureItem_sequence FeatureItem_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FeatureMeasurementsType: public ::xml_schema::type
    {
      public:
      // FeatureMeasurement
      //
      typedef ::xsd::qif30::FeatureMeasurementBaseType FeatureMeasurement_type;
      typedef ::xsd::cxx::tree::sequence< FeatureMeasurement_type > FeatureMeasurement_sequence;
      typedef xsd::cxx::tree::sequence< FeatureMeasurement_type >::iterator FeatureMeasurement_iterator;
      typedef xsd::cxx::tree::sequence< FeatureMeasurement_type >::const_iterator FeatureMeasurement_const_iterator;
      typedef ::xsd::cxx::tree::traits< FeatureMeasurement_type, wchar_t > FeatureMeasurement_traits;

      const FeatureMeasurement_sequence&
      FeatureMeasurement () const;

      FeatureMeasurement_sequence&
      FeatureMeasurement ();

      void
      FeatureMeasurement (const FeatureMeasurement_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FeatureMeasurementsType ();

      FeatureMeasurementsType (const n_type&);

      FeatureMeasurementsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      FeatureMeasurementsType (const FeatureMeasurementsType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual FeatureMeasurementsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureMeasurementsType&
      operator= (const FeatureMeasurementsType& x);

      virtual 
      ~FeatureMeasurementsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureMeasurement_sequence FeatureMeasurement_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FeatureZoneListType: public ::xml_schema::type
    {
      public:
      // FeatureZone
      //
      typedef ::xsd::qif30::FeatureZoneBaseType FeatureZone_type;
      typedef ::xsd::cxx::tree::sequence< FeatureZone_type > FeatureZone_sequence;
      typedef xsd::cxx::tree::sequence< FeatureZone_type >::iterator FeatureZone_iterator;
      typedef xsd::cxx::tree::sequence< FeatureZone_type >::const_iterator FeatureZone_const_iterator;
      typedef ::xsd::cxx::tree::traits< FeatureZone_type, wchar_t > FeatureZone_traits;

      const FeatureZone_sequence&
      FeatureZone () const;

      FeatureZone_sequence&
      FeatureZone ();

      void
      FeatureZone (const FeatureZone_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      FeatureZoneListType ();

      FeatureZoneListType (const n_type&);

      FeatureZoneListType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      FeatureZoneListType (const FeatureZoneListType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual FeatureZoneListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureZoneListType&
      operator= (const FeatureZoneListType& x);

      virtual 
      ~FeatureZoneListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      FeatureZone_sequence FeatureZone_;
      ::xsd::cxx::tree::one< n_type > n_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ShapeFeatureItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NonShapeFeatureItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ShapeFeatureDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NonShapeFeatureDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointSetNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NominalPointSetListType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ShapeFeatureNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NonShapeFeatureNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredPointSetsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointListType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredPointSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ShapeFeatureMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NonShapeFeatureMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SetFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SetFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SetFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConstructionMethodBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointRangeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointIndexType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BaseFeaturePointSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BaseFeaturePointListType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TransformationReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceFeatureItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceFeatureDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceFeatureNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceFeatureMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveFeatureItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveFeatureDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveFeatureNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveFeatureMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpecifiedFeatureItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpecifiedFeatureDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpecifiedFeatureNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpecifiedFeatureMeasurementBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleIntersectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleProjectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleTangentType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleTangentThroughType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleFromConeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircleFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcProjectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcIntersectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcExtractType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularArcFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConeFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalSegmentFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylinderFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricalSegmentFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EdgePointFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseProjectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseIntersectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipseFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcProjectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcIntersectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticalArcFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCircleFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ElongatedCylinderFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExtrudedCrossSectionFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineMidlineType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineIntersectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineProjectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinePerpendicularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineParallelType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineTangentThroughType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineExtractType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesIntersectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesProjectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelLinesFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesIntersectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesProjectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledLinesFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeParallelPlanesFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OppositeAngledPlanesFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveFeatureCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherCurveFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherNonShapeFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherNonShapeFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherNonShapeFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherNonShapeFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MarkingMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const MarkingMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const MarkingMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MarkingMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MarkingFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MarkingFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MarkingFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MarkingFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeFeatureCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherShapeFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceFeatureCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherSurfaceFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneMidplaneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneOffsetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlanePerpendicularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneParallelType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneTangentThroughType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneThroughType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneExtractType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PlaneFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveExtractType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DefiningPointsMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedCurveFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceExtractType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DefiningPointsNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDefinedSurfaceFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureIntersectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeaturePierceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureProjectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureFromConeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureCenterOfGravityType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureMidPointType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureMovePointType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureMovePointVectorType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureMovePointAxisType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureExtremeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphereFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalSegmentFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceOfRevolutionFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureFromCylinderType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadedFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidalSegmentFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusConstructionMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusBestFitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusRecompType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusCopyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusCastType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusFromScanType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusCheckedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusCheckedFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusMeasurementDeterminationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TorusFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GroupFeatureItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GroupFeatureDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GroupFeatureNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GroupFeatureMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureItemBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureDefinitionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureNominalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureLinearItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureLinearDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureLinearNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureParallelogramItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureParallelogramDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureParallelogramNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureCircularArcItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureCircularArcDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureCircularArcNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureCircleItemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureCircleDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PatternFeatureCircleNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZonePointType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneCurveBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneCurveLineType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneCurveCircularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneCurveIrregularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneAreaBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneAreaCircularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneAreaRectangularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneAreaIrregularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneAreaCylindricalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneAreaBetweenType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneAreaSphericalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureAspectsListsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureDefinitionsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureNominalsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureItemsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureMeasurementsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FeatureZoneListType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_FEATURES_HXX
