// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Geometry.hxx"

namespace xsd
{
  namespace qif30
  {
    // GeometrySetType
    //

    const GeometrySetType::PointSet_optional& GeometrySetType::
    PointSet () const
    {
      return this->PointSet_;
    }

    GeometrySetType::PointSet_optional& GeometrySetType::
    PointSet ()
    {
      return this->PointSet_;
    }

    void GeometrySetType::
    PointSet (const PointSet_type& x)
    {
      this->PointSet_.set (x);
    }

    void GeometrySetType::
    PointSet (const PointSet_optional& x)
    {
      this->PointSet_ = x;
    }

    void GeometrySetType::
    PointSet (::std::unique_ptr< PointSet_type > x)
    {
      this->PointSet_.set (std::move (x));
    }

    const GeometrySetType::Curve12Set_optional& GeometrySetType::
    Curve12Set () const
    {
      return this->Curve12Set_;
    }

    GeometrySetType::Curve12Set_optional& GeometrySetType::
    Curve12Set ()
    {
      return this->Curve12Set_;
    }

    void GeometrySetType::
    Curve12Set (const Curve12Set_type& x)
    {
      this->Curve12Set_.set (x);
    }

    void GeometrySetType::
    Curve12Set (const Curve12Set_optional& x)
    {
      this->Curve12Set_ = x;
    }

    void GeometrySetType::
    Curve12Set (::std::unique_ptr< Curve12Set_type > x)
    {
      this->Curve12Set_.set (std::move (x));
    }

    const GeometrySetType::Curve13Set_optional& GeometrySetType::
    Curve13Set () const
    {
      return this->Curve13Set_;
    }

    GeometrySetType::Curve13Set_optional& GeometrySetType::
    Curve13Set ()
    {
      return this->Curve13Set_;
    }

    void GeometrySetType::
    Curve13Set (const Curve13Set_type& x)
    {
      this->Curve13Set_.set (x);
    }

    void GeometrySetType::
    Curve13Set (const Curve13Set_optional& x)
    {
      this->Curve13Set_ = x;
    }

    void GeometrySetType::
    Curve13Set (::std::unique_ptr< Curve13Set_type > x)
    {
      this->Curve13Set_.set (std::move (x));
    }

    const GeometrySetType::SurfaceSet_optional& GeometrySetType::
    SurfaceSet () const
    {
      return this->SurfaceSet_;
    }

    GeometrySetType::SurfaceSet_optional& GeometrySetType::
    SurfaceSet ()
    {
      return this->SurfaceSet_;
    }

    void GeometrySetType::
    SurfaceSet (const SurfaceSet_type& x)
    {
      this->SurfaceSet_.set (x);
    }

    void GeometrySetType::
    SurfaceSet (const SurfaceSet_optional& x)
    {
      this->SurfaceSet_ = x;
    }

    void GeometrySetType::
    SurfaceSet (::std::unique_ptr< SurfaceSet_type > x)
    {
      this->SurfaceSet_.set (std::move (x));
    }

    const GeometrySetType::CurveMeshSet_optional& GeometrySetType::
    CurveMeshSet () const
    {
      return this->CurveMeshSet_;
    }

    GeometrySetType::CurveMeshSet_optional& GeometrySetType::
    CurveMeshSet ()
    {
      return this->CurveMeshSet_;
    }

    void GeometrySetType::
    CurveMeshSet (const CurveMeshSet_type& x)
    {
      this->CurveMeshSet_.set (x);
    }

    void GeometrySetType::
    CurveMeshSet (const CurveMeshSet_optional& x)
    {
      this->CurveMeshSet_ = x;
    }

    void GeometrySetType::
    CurveMeshSet (::std::unique_ptr< CurveMeshSet_type > x)
    {
      this->CurveMeshSet_.set (std::move (x));
    }

    const GeometrySetType::SurfaceMeshSet_optional& GeometrySetType::
    SurfaceMeshSet () const
    {
      return this->SurfaceMeshSet_;
    }

    GeometrySetType::SurfaceMeshSet_optional& GeometrySetType::
    SurfaceMeshSet ()
    {
      return this->SurfaceMeshSet_;
    }

    void GeometrySetType::
    SurfaceMeshSet (const SurfaceMeshSet_type& x)
    {
      this->SurfaceMeshSet_.set (x);
    }

    void GeometrySetType::
    SurfaceMeshSet (const SurfaceMeshSet_optional& x)
    {
      this->SurfaceMeshSet_ = x;
    }

    void GeometrySetType::
    SurfaceMeshSet (::std::unique_ptr< SurfaceMeshSet_type > x)
    {
      this->SurfaceMeshSet_.set (std::move (x));
    }


    // GeometryBaseType
    //


    // PointSetType
    //

    const PointSetType::Point_sequence& PointSetType::
    Point () const
    {
      return this->Point_;
    }

    PointSetType::Point_sequence& PointSetType::
    Point ()
    {
      return this->Point_;
    }

    void PointSetType::
    Point (const Point_sequence& s)
    {
      this->Point_ = s;
    }

    const PointSetType::n_type& PointSetType::
    n () const
    {
      return this->n_.get ();
    }

    PointSetType::n_type& PointSetType::
    n ()
    {
      return this->n_.get ();
    }

    void PointSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PointSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointEntityType
    //

    const PointEntityType::XYZ_type& PointEntityType::
    XYZ () const
    {
      return this->XYZ_.get ();
    }

    PointEntityType::XYZ_type& PointEntityType::
    XYZ ()
    {
      return this->XYZ_.get ();
    }

    void PointEntityType::
    XYZ (const XYZ_type& x)
    {
      this->XYZ_.set (x);
    }

    void PointEntityType::
    XYZ (::std::unique_ptr< XYZ_type > x)
    {
      this->XYZ_.set (std::move (x));
    }


    // Curve12SetType
    //

    const Curve12SetType::Curve12_sequence& Curve12SetType::
    Curve12 () const
    {
      return this->Curve12_;
    }

    Curve12SetType::Curve12_sequence& Curve12SetType::
    Curve12 ()
    {
      return this->Curve12_;
    }

    void Curve12SetType::
    Curve12 (const Curve12_sequence& s)
    {
      this->Curve12_ = s;
    }

    const Curve12SetType::n_type& Curve12SetType::
    n () const
    {
      return this->n_.get ();
    }

    Curve12SetType::n_type& Curve12SetType::
    n ()
    {
      return this->n_.get ();
    }

    void Curve12SetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void Curve12SetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // Curve13SetType
    //

    const Curve13SetType::Curve13_sequence& Curve13SetType::
    Curve13 () const
    {
      return this->Curve13_;
    }

    Curve13SetType::Curve13_sequence& Curve13SetType::
    Curve13 ()
    {
      return this->Curve13_;
    }

    void Curve13SetType::
    Curve13 (const Curve13_sequence& s)
    {
      this->Curve13_ = s;
    }

    const Curve13SetType::n_type& Curve13SetType::
    n () const
    {
      return this->n_.get ();
    }

    Curve13SetType::n_type& Curve13SetType::
    n ()
    {
      return this->n_.get ();
    }

    void Curve13SetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void Curve13SetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // Curve13CoreType
    //

    const Curve13CoreType::Curve13Core_type& Curve13CoreType::
    Curve13Core () const
    {
      return this->Curve13Core_.get ();
    }

    Curve13CoreType::Curve13Core_type& Curve13CoreType::
    Curve13Core ()
    {
      return this->Curve13Core_.get ();
    }

    void Curve13CoreType::
    Curve13Core (const Curve13Core_type& x)
    {
      this->Curve13Core_.set (x);
    }

    void Curve13CoreType::
    Curve13Core (::std::unique_ptr< Curve13Core_type > x)
    {
      this->Curve13Core_.set (std::move (x));
    }


    // CurveCoreBaseType
    //

    const CurveCoreBaseType::domain_type& CurveCoreBaseType::
    domain () const
    {
      return this->domain_.get ();
    }

    CurveCoreBaseType::domain_type& CurveCoreBaseType::
    domain ()
    {
      return this->domain_.get ();
    }

    void CurveCoreBaseType::
    domain (const domain_type& x)
    {
      this->domain_.set (x);
    }

    void CurveCoreBaseType::
    domain (::std::unique_ptr< domain_type > x)
    {
      this->domain_.set (std::move (x));
    }


    // Curve12BaseType
    //


    // Curve13BaseType
    //


    // Segment13CoreType
    //

    const Segment13CoreType::StartPoint_type& Segment13CoreType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    Segment13CoreType::StartPoint_type& Segment13CoreType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void Segment13CoreType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void Segment13CoreType::
    StartPoint (::std::unique_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (std::move (x));
    }

    const Segment13CoreType::EndPoint_type& Segment13CoreType::
    EndPoint () const
    {
      return this->EndPoint_.get ();
    }

    Segment13CoreType::EndPoint_type& Segment13CoreType::
    EndPoint ()
    {
      return this->EndPoint_.get ();
    }

    void Segment13CoreType::
    EndPoint (const EndPoint_type& x)
    {
      this->EndPoint_.set (x);
    }

    void Segment13CoreType::
    EndPoint (::std::unique_ptr< EndPoint_type > x)
    {
      this->EndPoint_.set (std::move (x));
    }


    // Segment12CoreType
    //

    const Segment12CoreType::StartPoint_type& Segment12CoreType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    Segment12CoreType::StartPoint_type& Segment12CoreType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void Segment12CoreType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void Segment12CoreType::
    StartPoint (::std::unique_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (std::move (x));
    }

    const Segment12CoreType::EndPoint_type& Segment12CoreType::
    EndPoint () const
    {
      return this->EndPoint_.get ();
    }

    Segment12CoreType::EndPoint_type& Segment12CoreType::
    EndPoint ()
    {
      return this->EndPoint_.get ();
    }

    void Segment12CoreType::
    EndPoint (const EndPoint_type& x)
    {
      this->EndPoint_.set (x);
    }

    void Segment12CoreType::
    EndPoint (::std::unique_ptr< EndPoint_type > x)
    {
      this->EndPoint_.set (std::move (x));
    }


    // Segment13Type
    //

    const Segment13Type::Segment13Core_type& Segment13Type::
    Segment13Core () const
    {
      return this->Segment13Core_.get ();
    }

    Segment13Type::Segment13Core_type& Segment13Type::
    Segment13Core ()
    {
      return this->Segment13Core_.get ();
    }

    void Segment13Type::
    Segment13Core (const Segment13Core_type& x)
    {
      this->Segment13Core_.set (x);
    }

    void Segment13Type::
    Segment13Core (::std::unique_ptr< Segment13Core_type > x)
    {
      this->Segment13Core_.set (std::move (x));
    }

    const Segment13Type::Transform_optional& Segment13Type::
    Transform () const
    {
      return this->Transform_;
    }

    Segment13Type::Transform_optional& Segment13Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Segment13Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Segment13Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Segment13Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Segment12Type
    //

    const Segment12Type::Segment12Core_type& Segment12Type::
    Segment12Core () const
    {
      return this->Segment12Core_.get ();
    }

    Segment12Type::Segment12Core_type& Segment12Type::
    Segment12Core ()
    {
      return this->Segment12Core_.get ();
    }

    void Segment12Type::
    Segment12Core (const Segment12Core_type& x)
    {
      this->Segment12Core_.set (x);
    }

    void Segment12Type::
    Segment12Core (::std::unique_ptr< Segment12Core_type > x)
    {
      this->Segment12Core_.set (std::move (x));
    }


    // ArcConicFormEnumType
    //

    ArcConicFormEnumType::
    ArcConicFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    ArcConicFormEnumType::
    ArcConicFormEnumType (value v)
    : ::xml_schema::string (_xsd_ArcConicFormEnumType_literals_[v])
    {
    }

    ArcConicFormEnumType::
    ArcConicFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    ArcConicFormEnumType::
    ArcConicFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    ArcConicFormEnumType::
    ArcConicFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ArcConicFormEnumType::
    ArcConicFormEnumType (const ArcConicFormEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ArcConicFormEnumType& ArcConicFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ArcConicFormEnumType_literals_[v]);

      return *this;
    }


    // ArcConic13CoreType
    //

    const ArcConic13CoreType::A_type& ArcConic13CoreType::
    A () const
    {
      return this->A_.get ();
    }

    ArcConic13CoreType::A_type& ArcConic13CoreType::
    A ()
    {
      return this->A_.get ();
    }

    void ArcConic13CoreType::
    A (const A_type& x)
    {
      this->A_.set (x);
    }

    const ArcConic13CoreType::B_type& ArcConic13CoreType::
    B () const
    {
      return this->B_.get ();
    }

    ArcConic13CoreType::B_type& ArcConic13CoreType::
    B ()
    {
      return this->B_.get ();
    }

    void ArcConic13CoreType::
    B (const B_type& x)
    {
      this->B_.set (x);
    }

    const ArcConic13CoreType::Center_type& ArcConic13CoreType::
    Center () const
    {
      return this->Center_.get ();
    }

    ArcConic13CoreType::Center_type& ArcConic13CoreType::
    Center ()
    {
      return this->Center_.get ();
    }

    void ArcConic13CoreType::
    Center (const Center_type& x)
    {
      this->Center_.set (x);
    }

    void ArcConic13CoreType::
    Center (::std::unique_ptr< Center_type > x)
    {
      this->Center_.set (std::move (x));
    }

    const ArcConic13CoreType::DirBeg_type& ArcConic13CoreType::
    DirBeg () const
    {
      return this->DirBeg_.get ();
    }

    ArcConic13CoreType::DirBeg_type& ArcConic13CoreType::
    DirBeg ()
    {
      return this->DirBeg_.get ();
    }

    void ArcConic13CoreType::
    DirBeg (const DirBeg_type& x)
    {
      this->DirBeg_.set (x);
    }

    void ArcConic13CoreType::
    DirBeg (::std::unique_ptr< DirBeg_type > x)
    {
      this->DirBeg_.set (std::move (x));
    }

    const ArcConic13CoreType::Normal_type& ArcConic13CoreType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    ArcConic13CoreType::Normal_type& ArcConic13CoreType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void ArcConic13CoreType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ArcConic13CoreType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const ArcConic13CoreType::form_type& ArcConic13CoreType::
    form () const
    {
      return this->form_.get ();
    }

    ArcConic13CoreType::form_type& ArcConic13CoreType::
    form ()
    {
      return this->form_.get ();
    }

    void ArcConic13CoreType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void ArcConic13CoreType::
    form (::std::unique_ptr< form_type > x)
    {
      this->form_.set (std::move (x));
    }


    // ArcConic12CoreType
    //

    const ArcConic12CoreType::A_type& ArcConic12CoreType::
    A () const
    {
      return this->A_.get ();
    }

    ArcConic12CoreType::A_type& ArcConic12CoreType::
    A ()
    {
      return this->A_.get ();
    }

    void ArcConic12CoreType::
    A (const A_type& x)
    {
      this->A_.set (x);
    }

    const ArcConic12CoreType::B_type& ArcConic12CoreType::
    B () const
    {
      return this->B_.get ();
    }

    ArcConic12CoreType::B_type& ArcConic12CoreType::
    B ()
    {
      return this->B_.get ();
    }

    void ArcConic12CoreType::
    B (const B_type& x)
    {
      this->B_.set (x);
    }

    const ArcConic12CoreType::Center_type& ArcConic12CoreType::
    Center () const
    {
      return this->Center_.get ();
    }

    ArcConic12CoreType::Center_type& ArcConic12CoreType::
    Center ()
    {
      return this->Center_.get ();
    }

    void ArcConic12CoreType::
    Center (const Center_type& x)
    {
      this->Center_.set (x);
    }

    void ArcConic12CoreType::
    Center (::std::unique_ptr< Center_type > x)
    {
      this->Center_.set (std::move (x));
    }

    const ArcConic12CoreType::DirBeg_type& ArcConic12CoreType::
    DirBeg () const
    {
      return this->DirBeg_.get ();
    }

    ArcConic12CoreType::DirBeg_type& ArcConic12CoreType::
    DirBeg ()
    {
      return this->DirBeg_.get ();
    }

    void ArcConic12CoreType::
    DirBeg (const DirBeg_type& x)
    {
      this->DirBeg_.set (x);
    }

    void ArcConic12CoreType::
    DirBeg (::std::unique_ptr< DirBeg_type > x)
    {
      this->DirBeg_.set (std::move (x));
    }

    const ArcConic12CoreType::form_type& ArcConic12CoreType::
    form () const
    {
      return this->form_.get ();
    }

    ArcConic12CoreType::form_type& ArcConic12CoreType::
    form ()
    {
      return this->form_.get ();
    }

    void ArcConic12CoreType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void ArcConic12CoreType::
    form (::std::unique_ptr< form_type > x)
    {
      this->form_.set (std::move (x));
    }

    const ArcConic12CoreType::turned_type& ArcConic12CoreType::
    turned () const
    {
      return this->turned_.get ();
    }

    ArcConic12CoreType::turned_type& ArcConic12CoreType::
    turned ()
    {
      return this->turned_.get ();
    }

    void ArcConic12CoreType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    ArcConic12CoreType::turned_type ArcConic12CoreType::
    turned_default_value ()
    {
      return turned_type (false);
    }


    // ArcConic12Type
    //

    const ArcConic12Type::ArcConic12Core_type& ArcConic12Type::
    ArcConic12Core () const
    {
      return this->ArcConic12Core_.get ();
    }

    ArcConic12Type::ArcConic12Core_type& ArcConic12Type::
    ArcConic12Core ()
    {
      return this->ArcConic12Core_.get ();
    }

    void ArcConic12Type::
    ArcConic12Core (const ArcConic12Core_type& x)
    {
      this->ArcConic12Core_.set (x);
    }

    void ArcConic12Type::
    ArcConic12Core (::std::unique_ptr< ArcConic12Core_type > x)
    {
      this->ArcConic12Core_.set (std::move (x));
    }


    // ArcConic13Type
    //

    const ArcConic13Type::ArcConic13Core_type& ArcConic13Type::
    ArcConic13Core () const
    {
      return this->ArcConic13Core_.get ();
    }

    ArcConic13Type::ArcConic13Core_type& ArcConic13Type::
    ArcConic13Core ()
    {
      return this->ArcConic13Core_.get ();
    }

    void ArcConic13Type::
    ArcConic13Core (const ArcConic13Core_type& x)
    {
      this->ArcConic13Core_.set (x);
    }

    void ArcConic13Type::
    ArcConic13Core (::std::unique_ptr< ArcConic13Core_type > x)
    {
      this->ArcConic13Core_.set (std::move (x));
    }

    const ArcConic13Type::Transform_optional& ArcConic13Type::
    Transform () const
    {
      return this->Transform_;
    }

    ArcConic13Type::Transform_optional& ArcConic13Type::
    Transform ()
    {
      return this->Transform_;
    }

    void ArcConic13Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ArcConic13Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ArcConic13Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // ArcCircular13CoreType
    //

    const ArcCircular13CoreType::Radius_type& ArcCircular13CoreType::
    Radius () const
    {
      return this->Radius_.get ();
    }

    ArcCircular13CoreType::Radius_type& ArcCircular13CoreType::
    Radius ()
    {
      return this->Radius_.get ();
    }

    void ArcCircular13CoreType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    const ArcCircular13CoreType::Center_type& ArcCircular13CoreType::
    Center () const
    {
      return this->Center_.get ();
    }

    ArcCircular13CoreType::Center_type& ArcCircular13CoreType::
    Center ()
    {
      return this->Center_.get ();
    }

    void ArcCircular13CoreType::
    Center (const Center_type& x)
    {
      this->Center_.set (x);
    }

    void ArcCircular13CoreType::
    Center (::std::unique_ptr< Center_type > x)
    {
      this->Center_.set (std::move (x));
    }

    const ArcCircular13CoreType::DirBeg_type& ArcCircular13CoreType::
    DirBeg () const
    {
      return this->DirBeg_.get ();
    }

    ArcCircular13CoreType::DirBeg_type& ArcCircular13CoreType::
    DirBeg ()
    {
      return this->DirBeg_.get ();
    }

    void ArcCircular13CoreType::
    DirBeg (const DirBeg_type& x)
    {
      this->DirBeg_.set (x);
    }

    void ArcCircular13CoreType::
    DirBeg (::std::unique_ptr< DirBeg_type > x)
    {
      this->DirBeg_.set (std::move (x));
    }

    const ArcCircular13CoreType::Normal_type& ArcCircular13CoreType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    ArcCircular13CoreType::Normal_type& ArcCircular13CoreType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void ArcCircular13CoreType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ArcCircular13CoreType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }


    // ArcCircular12CoreType
    //

    const ArcCircular12CoreType::Radius_type& ArcCircular12CoreType::
    Radius () const
    {
      return this->Radius_.get ();
    }

    ArcCircular12CoreType::Radius_type& ArcCircular12CoreType::
    Radius ()
    {
      return this->Radius_.get ();
    }

    void ArcCircular12CoreType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    const ArcCircular12CoreType::Center_type& ArcCircular12CoreType::
    Center () const
    {
      return this->Center_.get ();
    }

    ArcCircular12CoreType::Center_type& ArcCircular12CoreType::
    Center ()
    {
      return this->Center_.get ();
    }

    void ArcCircular12CoreType::
    Center (const Center_type& x)
    {
      this->Center_.set (x);
    }

    void ArcCircular12CoreType::
    Center (::std::unique_ptr< Center_type > x)
    {
      this->Center_.set (std::move (x));
    }

    const ArcCircular12CoreType::DirBeg_type& ArcCircular12CoreType::
    DirBeg () const
    {
      return this->DirBeg_.get ();
    }

    ArcCircular12CoreType::DirBeg_type& ArcCircular12CoreType::
    DirBeg ()
    {
      return this->DirBeg_.get ();
    }

    void ArcCircular12CoreType::
    DirBeg (const DirBeg_type& x)
    {
      this->DirBeg_.set (x);
    }

    void ArcCircular12CoreType::
    DirBeg (::std::unique_ptr< DirBeg_type > x)
    {
      this->DirBeg_.set (std::move (x));
    }

    const ArcCircular12CoreType::turned_type& ArcCircular12CoreType::
    turned () const
    {
      return this->turned_.get ();
    }

    ArcCircular12CoreType::turned_type& ArcCircular12CoreType::
    turned ()
    {
      return this->turned_.get ();
    }

    void ArcCircular12CoreType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    ArcCircular12CoreType::turned_type ArcCircular12CoreType::
    turned_default_value ()
    {
      return turned_type (false);
    }


    // ArcCircular13Type
    //

    const ArcCircular13Type::ArcCircular13Core_type& ArcCircular13Type::
    ArcCircular13Core () const
    {
      return this->ArcCircular13Core_.get ();
    }

    ArcCircular13Type::ArcCircular13Core_type& ArcCircular13Type::
    ArcCircular13Core ()
    {
      return this->ArcCircular13Core_.get ();
    }

    void ArcCircular13Type::
    ArcCircular13Core (const ArcCircular13Core_type& x)
    {
      this->ArcCircular13Core_.set (x);
    }

    void ArcCircular13Type::
    ArcCircular13Core (::std::unique_ptr< ArcCircular13Core_type > x)
    {
      this->ArcCircular13Core_.set (std::move (x));
    }

    const ArcCircular13Type::Transform_optional& ArcCircular13Type::
    Transform () const
    {
      return this->Transform_;
    }

    ArcCircular13Type::Transform_optional& ArcCircular13Type::
    Transform ()
    {
      return this->Transform_;
    }

    void ArcCircular13Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ArcCircular13Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ArcCircular13Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // ArcCircular12Type
    //

    const ArcCircular12Type::ArcCircular12Core_type& ArcCircular12Type::
    ArcCircular12Core () const
    {
      return this->ArcCircular12Core_.get ();
    }

    ArcCircular12Type::ArcCircular12Core_type& ArcCircular12Type::
    ArcCircular12Core ()
    {
      return this->ArcCircular12Core_.get ();
    }

    void ArcCircular12Type::
    ArcCircular12Core (const ArcCircular12Core_type& x)
    {
      this->ArcCircular12Core_.set (x);
    }

    void ArcCircular12Type::
    ArcCircular12Core (::std::unique_ptr< ArcCircular12Core_type > x)
    {
      this->ArcCircular12Core_.set (std::move (x));
    }


    // Nurbs12CoreType
    //

    const Nurbs12CoreType::Order_type& Nurbs12CoreType::
    Order () const
    {
      return this->Order_.get ();
    }

    Nurbs12CoreType::Order_type& Nurbs12CoreType::
    Order ()
    {
      return this->Order_.get ();
    }

    void Nurbs12CoreType::
    Order (const Order_type& x)
    {
      this->Order_.set (x);
    }

    void Nurbs12CoreType::
    Order (::std::unique_ptr< Order_type > x)
    {
      this->Order_.set (std::move (x));
    }

    const Nurbs12CoreType::Knots_type& Nurbs12CoreType::
    Knots () const
    {
      return this->Knots_.get ();
    }

    Nurbs12CoreType::Knots_type& Nurbs12CoreType::
    Knots ()
    {
      return this->Knots_.get ();
    }

    void Nurbs12CoreType::
    Knots (const Knots_type& x)
    {
      this->Knots_.set (x);
    }

    void Nurbs12CoreType::
    Knots (::std::unique_ptr< Knots_type > x)
    {
      this->Knots_.set (std::move (x));
    }

    const Nurbs12CoreType::CPs_optional& Nurbs12CoreType::
    CPs () const
    {
      return this->CPs_;
    }

    Nurbs12CoreType::CPs_optional& Nurbs12CoreType::
    CPs ()
    {
      return this->CPs_;
    }

    void Nurbs12CoreType::
    CPs (const CPs_type& x)
    {
      this->CPs_.set (x);
    }

    void Nurbs12CoreType::
    CPs (const CPs_optional& x)
    {
      this->CPs_ = x;
    }

    void Nurbs12CoreType::
    CPs (::std::unique_ptr< CPs_type > x)
    {
      this->CPs_.set (std::move (x));
    }

    const Nurbs12CoreType::CPsBinary_optional& Nurbs12CoreType::
    CPsBinary () const
    {
      return this->CPsBinary_;
    }

    Nurbs12CoreType::CPsBinary_optional& Nurbs12CoreType::
    CPsBinary ()
    {
      return this->CPsBinary_;
    }

    void Nurbs12CoreType::
    CPsBinary (const CPsBinary_type& x)
    {
      this->CPsBinary_.set (x);
    }

    void Nurbs12CoreType::
    CPsBinary (const CPsBinary_optional& x)
    {
      this->CPsBinary_ = x;
    }

    void Nurbs12CoreType::
    CPsBinary (::std::unique_ptr< CPsBinary_type > x)
    {
      this->CPsBinary_.set (std::move (x));
    }

    const Nurbs12CoreType::Weights_optional& Nurbs12CoreType::
    Weights () const
    {
      return this->Weights_;
    }

    Nurbs12CoreType::Weights_optional& Nurbs12CoreType::
    Weights ()
    {
      return this->Weights_;
    }

    void Nurbs12CoreType::
    Weights (const Weights_type& x)
    {
      this->Weights_.set (x);
    }

    void Nurbs12CoreType::
    Weights (const Weights_optional& x)
    {
      this->Weights_ = x;
    }

    void Nurbs12CoreType::
    Weights (::std::unique_ptr< Weights_type > x)
    {
      this->Weights_.set (std::move (x));
    }


    // Nurbs13CoreType
    //

    const Nurbs13CoreType::Order_type& Nurbs13CoreType::
    Order () const
    {
      return this->Order_.get ();
    }

    Nurbs13CoreType::Order_type& Nurbs13CoreType::
    Order ()
    {
      return this->Order_.get ();
    }

    void Nurbs13CoreType::
    Order (const Order_type& x)
    {
      this->Order_.set (x);
    }

    void Nurbs13CoreType::
    Order (::std::unique_ptr< Order_type > x)
    {
      this->Order_.set (std::move (x));
    }

    const Nurbs13CoreType::Knots_type& Nurbs13CoreType::
    Knots () const
    {
      return this->Knots_.get ();
    }

    Nurbs13CoreType::Knots_type& Nurbs13CoreType::
    Knots ()
    {
      return this->Knots_.get ();
    }

    void Nurbs13CoreType::
    Knots (const Knots_type& x)
    {
      this->Knots_.set (x);
    }

    void Nurbs13CoreType::
    Knots (::std::unique_ptr< Knots_type > x)
    {
      this->Knots_.set (std::move (x));
    }

    const Nurbs13CoreType::CPs_optional& Nurbs13CoreType::
    CPs () const
    {
      return this->CPs_;
    }

    Nurbs13CoreType::CPs_optional& Nurbs13CoreType::
    CPs ()
    {
      return this->CPs_;
    }

    void Nurbs13CoreType::
    CPs (const CPs_type& x)
    {
      this->CPs_.set (x);
    }

    void Nurbs13CoreType::
    CPs (const CPs_optional& x)
    {
      this->CPs_ = x;
    }

    void Nurbs13CoreType::
    CPs (::std::unique_ptr< CPs_type > x)
    {
      this->CPs_.set (std::move (x));
    }

    const Nurbs13CoreType::CPsBinary_optional& Nurbs13CoreType::
    CPsBinary () const
    {
      return this->CPsBinary_;
    }

    Nurbs13CoreType::CPsBinary_optional& Nurbs13CoreType::
    CPsBinary ()
    {
      return this->CPsBinary_;
    }

    void Nurbs13CoreType::
    CPsBinary (const CPsBinary_type& x)
    {
      this->CPsBinary_.set (x);
    }

    void Nurbs13CoreType::
    CPsBinary (const CPsBinary_optional& x)
    {
      this->CPsBinary_ = x;
    }

    void Nurbs13CoreType::
    CPsBinary (::std::unique_ptr< CPsBinary_type > x)
    {
      this->CPsBinary_.set (std::move (x));
    }

    const Nurbs13CoreType::Weights_optional& Nurbs13CoreType::
    Weights () const
    {
      return this->Weights_;
    }

    Nurbs13CoreType::Weights_optional& Nurbs13CoreType::
    Weights ()
    {
      return this->Weights_;
    }

    void Nurbs13CoreType::
    Weights (const Weights_type& x)
    {
      this->Weights_.set (x);
    }

    void Nurbs13CoreType::
    Weights (const Weights_optional& x)
    {
      this->Weights_ = x;
    }

    void Nurbs13CoreType::
    Weights (::std::unique_ptr< Weights_type > x)
    {
      this->Weights_.set (std::move (x));
    }


    // Nurbs12Type
    //

    const Nurbs12Type::Nurbs12Core_type& Nurbs12Type::
    Nurbs12Core () const
    {
      return this->Nurbs12Core_.get ();
    }

    Nurbs12Type::Nurbs12Core_type& Nurbs12Type::
    Nurbs12Core ()
    {
      return this->Nurbs12Core_.get ();
    }

    void Nurbs12Type::
    Nurbs12Core (const Nurbs12Core_type& x)
    {
      this->Nurbs12Core_.set (x);
    }

    void Nurbs12Type::
    Nurbs12Core (::std::unique_ptr< Nurbs12Core_type > x)
    {
      this->Nurbs12Core_.set (std::move (x));
    }


    // Nurbs13Type
    //

    const Nurbs13Type::Nurbs13Core_type& Nurbs13Type::
    Nurbs13Core () const
    {
      return this->Nurbs13Core_.get ();
    }

    Nurbs13Type::Nurbs13Core_type& Nurbs13Type::
    Nurbs13Core ()
    {
      return this->Nurbs13Core_.get ();
    }

    void Nurbs13Type::
    Nurbs13Core (const Nurbs13Core_type& x)
    {
      this->Nurbs13Core_.set (x);
    }

    void Nurbs13Type::
    Nurbs13Core (::std::unique_ptr< Nurbs13Core_type > x)
    {
      this->Nurbs13Core_.set (std::move (x));
    }

    const Nurbs13Type::Transform_optional& Nurbs13Type::
    Transform () const
    {
      return this->Transform_;
    }

    Nurbs13Type::Transform_optional& Nurbs13Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Nurbs13Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Nurbs13Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Nurbs13Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Spline13CoreType
    //

    const Spline13CoreType::Knots_type& Spline13CoreType::
    Knots () const
    {
      return this->Knots_.get ();
    }

    Spline13CoreType::Knots_type& Spline13CoreType::
    Knots ()
    {
      return this->Knots_.get ();
    }

    void Spline13CoreType::
    Knots (const Knots_type& x)
    {
      this->Knots_.set (x);
    }

    void Spline13CoreType::
    Knots (::std::unique_ptr< Knots_type > x)
    {
      this->Knots_.set (std::move (x));
    }

    const Spline13CoreType::Orders_type& Spline13CoreType::
    Orders () const
    {
      return this->Orders_.get ();
    }

    Spline13CoreType::Orders_type& Spline13CoreType::
    Orders ()
    {
      return this->Orders_.get ();
    }

    void Spline13CoreType::
    Orders (const Orders_type& x)
    {
      this->Orders_.set (x);
    }

    void Spline13CoreType::
    Orders (::std::unique_ptr< Orders_type > x)
    {
      this->Orders_.set (std::move (x));
    }

    const Spline13CoreType::Coefficients_type& Spline13CoreType::
    Coefficients () const
    {
      return this->Coefficients_.get ();
    }

    Spline13CoreType::Coefficients_type& Spline13CoreType::
    Coefficients ()
    {
      return this->Coefficients_.get ();
    }

    void Spline13CoreType::
    Coefficients (const Coefficients_type& x)
    {
      this->Coefficients_.set (x);
    }

    void Spline13CoreType::
    Coefficients (::std::unique_ptr< Coefficients_type > x)
    {
      this->Coefficients_.set (std::move (x));
    }

    const Spline13CoreType::normalized_type& Spline13CoreType::
    normalized () const
    {
      return this->normalized_.get ();
    }

    Spline13CoreType::normalized_type& Spline13CoreType::
    normalized ()
    {
      return this->normalized_.get ();
    }

    void Spline13CoreType::
    normalized (const normalized_type& x)
    {
      this->normalized_.set (x);
    }

    Spline13CoreType::normalized_type Spline13CoreType::
    normalized_default_value ()
    {
      return normalized_type (false);
    }


    // Spline12CoreType
    //

    const Spline12CoreType::Knots_type& Spline12CoreType::
    Knots () const
    {
      return this->Knots_.get ();
    }

    Spline12CoreType::Knots_type& Spline12CoreType::
    Knots ()
    {
      return this->Knots_.get ();
    }

    void Spline12CoreType::
    Knots (const Knots_type& x)
    {
      this->Knots_.set (x);
    }

    void Spline12CoreType::
    Knots (::std::unique_ptr< Knots_type > x)
    {
      this->Knots_.set (std::move (x));
    }

    const Spline12CoreType::Orders_type& Spline12CoreType::
    Orders () const
    {
      return this->Orders_.get ();
    }

    Spline12CoreType::Orders_type& Spline12CoreType::
    Orders ()
    {
      return this->Orders_.get ();
    }

    void Spline12CoreType::
    Orders (const Orders_type& x)
    {
      this->Orders_.set (x);
    }

    void Spline12CoreType::
    Orders (::std::unique_ptr< Orders_type > x)
    {
      this->Orders_.set (std::move (x));
    }

    const Spline12CoreType::Coefficients_type& Spline12CoreType::
    Coefficients () const
    {
      return this->Coefficients_.get ();
    }

    Spline12CoreType::Coefficients_type& Spline12CoreType::
    Coefficients ()
    {
      return this->Coefficients_.get ();
    }

    void Spline12CoreType::
    Coefficients (const Coefficients_type& x)
    {
      this->Coefficients_.set (x);
    }

    void Spline12CoreType::
    Coefficients (::std::unique_ptr< Coefficients_type > x)
    {
      this->Coefficients_.set (std::move (x));
    }

    const Spline12CoreType::normalized_type& Spline12CoreType::
    normalized () const
    {
      return this->normalized_.get ();
    }

    Spline12CoreType::normalized_type& Spline12CoreType::
    normalized ()
    {
      return this->normalized_.get ();
    }

    void Spline12CoreType::
    normalized (const normalized_type& x)
    {
      this->normalized_.set (x);
    }

    Spline12CoreType::normalized_type Spline12CoreType::
    normalized_default_value ()
    {
      return normalized_type (false);
    }


    // Spline13Type
    //

    const Spline13Type::Spline13Core_type& Spline13Type::
    Spline13Core () const
    {
      return this->Spline13Core_.get ();
    }

    Spline13Type::Spline13Core_type& Spline13Type::
    Spline13Core ()
    {
      return this->Spline13Core_.get ();
    }

    void Spline13Type::
    Spline13Core (const Spline13Core_type& x)
    {
      this->Spline13Core_.set (x);
    }

    void Spline13Type::
    Spline13Core (::std::unique_ptr< Spline13Core_type > x)
    {
      this->Spline13Core_.set (std::move (x));
    }

    const Spline13Type::Transform_optional& Spline13Type::
    Transform () const
    {
      return this->Transform_;
    }

    Spline13Type::Transform_optional& Spline13Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Spline13Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Spline13Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Spline13Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Spline12Type
    //

    const Spline12Type::Spline12Core_type& Spline12Type::
    Spline12Core () const
    {
      return this->Spline12Core_.get ();
    }

    Spline12Type::Spline12Core_type& Spline12Type::
    Spline12Core ()
    {
      return this->Spline12Core_.get ();
    }

    void Spline12Type::
    Spline12Core (const Spline12Core_type& x)
    {
      this->Spline12Core_.set (x);
    }

    void Spline12Type::
    Spline12Core (::std::unique_ptr< Spline12Core_type > x)
    {
      this->Spline12Core_.set (std::move (x));
    }


    // Curve12OrientedType
    //

    const Curve12OrientedType::Curve12Core_type& Curve12OrientedType::
    Curve12Core () const
    {
      return this->Curve12Core_.get ();
    }

    Curve12OrientedType::Curve12Core_type& Curve12OrientedType::
    Curve12Core ()
    {
      return this->Curve12Core_.get ();
    }

    void Curve12OrientedType::
    Curve12Core (const Curve12Core_type& x)
    {
      this->Curve12Core_.set (x);
    }

    void Curve12OrientedType::
    Curve12Core (::std::unique_ptr< Curve12Core_type > x)
    {
      this->Curve12Core_.set (std::move (x));
    }

    const Curve12OrientedType::turned_type& Curve12OrientedType::
    turned () const
    {
      return this->turned_.get ();
    }

    Curve12OrientedType::turned_type& Curve12OrientedType::
    turned ()
    {
      return this->turned_.get ();
    }

    void Curve12OrientedType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    Curve12OrientedType::turned_type Curve12OrientedType::
    turned_default_value ()
    {
      return turned_type (false);
    }


    // ArraySubCurve12Type
    //

    const ArraySubCurve12Type::SubCurve_sequence& ArraySubCurve12Type::
    SubCurve () const
    {
      return this->SubCurve_;
    }

    ArraySubCurve12Type::SubCurve_sequence& ArraySubCurve12Type::
    SubCurve ()
    {
      return this->SubCurve_;
    }

    void ArraySubCurve12Type::
    SubCurve (const SubCurve_sequence& s)
    {
      this->SubCurve_ = s;
    }

    const ArraySubCurve12Type::n_type& ArraySubCurve12Type::
    n () const
    {
      return this->n_.get ();
    }

    ArraySubCurve12Type::n_type& ArraySubCurve12Type::
    n ()
    {
      return this->n_.get ();
    }

    void ArraySubCurve12Type::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ArraySubCurve12Type::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // Aggregate12CoreType
    //

    const Aggregate12CoreType::SubCurves_type& Aggregate12CoreType::
    SubCurves () const
    {
      return this->SubCurves_.get ();
    }

    Aggregate12CoreType::SubCurves_type& Aggregate12CoreType::
    SubCurves ()
    {
      return this->SubCurves_.get ();
    }

    void Aggregate12CoreType::
    SubCurves (const SubCurves_type& x)
    {
      this->SubCurves_.set (x);
    }

    void Aggregate12CoreType::
    SubCurves (::std::unique_ptr< SubCurves_type > x)
    {
      this->SubCurves_.set (std::move (x));
    }


    // Curve13OrientedType
    //

    const Curve13OrientedType::Curve13Core_type& Curve13OrientedType::
    Curve13Core () const
    {
      return this->Curve13Core_.get ();
    }

    Curve13OrientedType::Curve13Core_type& Curve13OrientedType::
    Curve13Core ()
    {
      return this->Curve13Core_.get ();
    }

    void Curve13OrientedType::
    Curve13Core (const Curve13Core_type& x)
    {
      this->Curve13Core_.set (x);
    }

    void Curve13OrientedType::
    Curve13Core (::std::unique_ptr< Curve13Core_type > x)
    {
      this->Curve13Core_.set (std::move (x));
    }

    const Curve13OrientedType::turned_type& Curve13OrientedType::
    turned () const
    {
      return this->turned_.get ();
    }

    Curve13OrientedType::turned_type& Curve13OrientedType::
    turned ()
    {
      return this->turned_.get ();
    }

    void Curve13OrientedType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    Curve13OrientedType::turned_type Curve13OrientedType::
    turned_default_value ()
    {
      return turned_type (false);
    }


    // ArraySubCurve13Type
    //

    const ArraySubCurve13Type::SubCurve_sequence& ArraySubCurve13Type::
    SubCurve () const
    {
      return this->SubCurve_;
    }

    ArraySubCurve13Type::SubCurve_sequence& ArraySubCurve13Type::
    SubCurve ()
    {
      return this->SubCurve_;
    }

    void ArraySubCurve13Type::
    SubCurve (const SubCurve_sequence& s)
    {
      this->SubCurve_ = s;
    }

    const ArraySubCurve13Type::n_type& ArraySubCurve13Type::
    n () const
    {
      return this->n_.get ();
    }

    ArraySubCurve13Type::n_type& ArraySubCurve13Type::
    n ()
    {
      return this->n_.get ();
    }

    void ArraySubCurve13Type::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ArraySubCurve13Type::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // Aggregate13CoreType
    //

    const Aggregate13CoreType::SubCurves_type& Aggregate13CoreType::
    SubCurves () const
    {
      return this->SubCurves_.get ();
    }

    Aggregate13CoreType::SubCurves_type& Aggregate13CoreType::
    SubCurves ()
    {
      return this->SubCurves_.get ();
    }

    void Aggregate13CoreType::
    SubCurves (const SubCurves_type& x)
    {
      this->SubCurves_.set (x);
    }

    void Aggregate13CoreType::
    SubCurves (::std::unique_ptr< SubCurves_type > x)
    {
      this->SubCurves_.set (std::move (x));
    }


    // Aggregate12Type
    //

    const Aggregate12Type::Aggregate12Core_type& Aggregate12Type::
    Aggregate12Core () const
    {
      return this->Aggregate12Core_.get ();
    }

    Aggregate12Type::Aggregate12Core_type& Aggregate12Type::
    Aggregate12Core ()
    {
      return this->Aggregate12Core_.get ();
    }

    void Aggregate12Type::
    Aggregate12Core (const Aggregate12Core_type& x)
    {
      this->Aggregate12Core_.set (x);
    }

    void Aggregate12Type::
    Aggregate12Core (::std::unique_ptr< Aggregate12Core_type > x)
    {
      this->Aggregate12Core_.set (std::move (x));
    }


    // Aggregate13Type
    //

    const Aggregate13Type::Aggregate13Core_type& Aggregate13Type::
    Aggregate13Core () const
    {
      return this->Aggregate13Core_.get ();
    }

    Aggregate13Type::Aggregate13Core_type& Aggregate13Type::
    Aggregate13Core ()
    {
      return this->Aggregate13Core_.get ();
    }

    void Aggregate13Type::
    Aggregate13Core (const Aggregate13Core_type& x)
    {
      this->Aggregate13Core_.set (x);
    }

    void Aggregate13Type::
    Aggregate13Core (::std::unique_ptr< Aggregate13Core_type > x)
    {
      this->Aggregate13Core_.set (std::move (x));
    }

    const Aggregate13Type::Transform_optional& Aggregate13Type::
    Transform () const
    {
      return this->Transform_;
    }

    Aggregate13Type::Transform_optional& Aggregate13Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Aggregate13Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Aggregate13Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Aggregate13Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Polyline13CoreType
    //

    const Polyline13CoreType::Points_optional& Polyline13CoreType::
    Points () const
    {
      return this->Points_;
    }

    Polyline13CoreType::Points_optional& Polyline13CoreType::
    Points ()
    {
      return this->Points_;
    }

    void Polyline13CoreType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void Polyline13CoreType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void Polyline13CoreType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }

    const Polyline13CoreType::PointsBinary_optional& Polyline13CoreType::
    PointsBinary () const
    {
      return this->PointsBinary_;
    }

    Polyline13CoreType::PointsBinary_optional& Polyline13CoreType::
    PointsBinary ()
    {
      return this->PointsBinary_;
    }

    void Polyline13CoreType::
    PointsBinary (const PointsBinary_type& x)
    {
      this->PointsBinary_.set (x);
    }

    void Polyline13CoreType::
    PointsBinary (const PointsBinary_optional& x)
    {
      this->PointsBinary_ = x;
    }

    void Polyline13CoreType::
    PointsBinary (::std::unique_ptr< PointsBinary_type > x)
    {
      this->PointsBinary_.set (std::move (x));
    }


    // Polyline12CoreType
    //

    const Polyline12CoreType::Points_optional& Polyline12CoreType::
    Points () const
    {
      return this->Points_;
    }

    Polyline12CoreType::Points_optional& Polyline12CoreType::
    Points ()
    {
      return this->Points_;
    }

    void Polyline12CoreType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void Polyline12CoreType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void Polyline12CoreType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }

    const Polyline12CoreType::PointsBinary_optional& Polyline12CoreType::
    PointsBinary () const
    {
      return this->PointsBinary_;
    }

    Polyline12CoreType::PointsBinary_optional& Polyline12CoreType::
    PointsBinary ()
    {
      return this->PointsBinary_;
    }

    void Polyline12CoreType::
    PointsBinary (const PointsBinary_type& x)
    {
      this->PointsBinary_.set (x);
    }

    void Polyline12CoreType::
    PointsBinary (const PointsBinary_optional& x)
    {
      this->PointsBinary_ = x;
    }

    void Polyline12CoreType::
    PointsBinary (::std::unique_ptr< PointsBinary_type > x)
    {
      this->PointsBinary_.set (std::move (x));
    }


    // Polyline13Type
    //

    const Polyline13Type::Polyline13Core_type& Polyline13Type::
    Polyline13Core () const
    {
      return this->Polyline13Core_.get ();
    }

    Polyline13Type::Polyline13Core_type& Polyline13Type::
    Polyline13Core ()
    {
      return this->Polyline13Core_.get ();
    }

    void Polyline13Type::
    Polyline13Core (const Polyline13Core_type& x)
    {
      this->Polyline13Core_.set (x);
    }

    void Polyline13Type::
    Polyline13Core (::std::unique_ptr< Polyline13Core_type > x)
    {
      this->Polyline13Core_.set (std::move (x));
    }

    const Polyline13Type::Transform_optional& Polyline13Type::
    Transform () const
    {
      return this->Transform_;
    }

    Polyline13Type::Transform_optional& Polyline13Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Polyline13Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Polyline13Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Polyline13Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Polyline12Type
    //

    const Polyline12Type::Polyline12Core_type& Polyline12Type::
    Polyline12Core () const
    {
      return this->Polyline12Core_.get ();
    }

    Polyline12Type::Polyline12Core_type& Polyline12Type::
    Polyline12Core ()
    {
      return this->Polyline12Core_.get ();
    }

    void Polyline12Type::
    Polyline12Core (const Polyline12Core_type& x)
    {
      this->Polyline12Core_.set (x);
    }

    void Polyline12Type::
    Polyline12Core (::std::unique_ptr< Polyline12Core_type > x)
    {
      this->Polyline12Core_.set (std::move (x));
    }


    // SurfaceBaseType
    //


    // SurfaceSetType
    //

    const SurfaceSetType::Surface_sequence& SurfaceSetType::
    Surface () const
    {
      return this->Surface_;
    }

    SurfaceSetType::Surface_sequence& SurfaceSetType::
    Surface ()
    {
      return this->Surface_;
    }

    void SurfaceSetType::
    Surface (const Surface_sequence& s)
    {
      this->Surface_ = s;
    }

    const SurfaceSetType::n_type& SurfaceSetType::
    n () const
    {
      return this->n_.get ();
    }

    SurfaceSetType::n_type& SurfaceSetType::
    n ()
    {
      return this->n_.get ();
    }

    void SurfaceSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SurfaceSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SurfaceCoreType
    //

    const SurfaceCoreType::SurfaceCore_type& SurfaceCoreType::
    SurfaceCore () const
    {
      return this->SurfaceCore_.get ();
    }

    SurfaceCoreType::SurfaceCore_type& SurfaceCoreType::
    SurfaceCore ()
    {
      return this->SurfaceCore_.get ();
    }

    void SurfaceCoreType::
    SurfaceCore (const SurfaceCore_type& x)
    {
      this->SurfaceCore_.set (x);
    }

    void SurfaceCoreType::
    SurfaceCore (::std::unique_ptr< SurfaceCore_type > x)
    {
      this->SurfaceCore_.set (std::move (x));
    }


    // SurfaceCoreBaseType
    //

    const SurfaceCoreBaseType::form_optional& SurfaceCoreBaseType::
    form () const
    {
      return this->form_;
    }

    SurfaceCoreBaseType::form_optional& SurfaceCoreBaseType::
    form ()
    {
      return this->form_;
    }

    void SurfaceCoreBaseType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void SurfaceCoreBaseType::
    form (const form_optional& x)
    {
      this->form_ = x;
    }

    void SurfaceCoreBaseType::
    form (::std::unique_ptr< form_type > x)
    {
      this->form_.set (std::move (x));
    }


    // Attr23CoreEnumType
    //

    Attr23CoreEnumType::
    Attr23CoreEnumType ()
    : ::xml_schema::string ()
    {
    }

    Attr23CoreEnumType::
    Attr23CoreEnumType (value v)
    : ::xml_schema::string (_xsd_Attr23CoreEnumType_literals_[v])
    {
    }

    Attr23CoreEnumType::
    Attr23CoreEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    Attr23CoreEnumType::
    Attr23CoreEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    Attr23CoreEnumType::
    Attr23CoreEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    Attr23CoreEnumType::
    Attr23CoreEnumType (const Attr23CoreEnumType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    Attr23CoreEnumType& Attr23CoreEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_Attr23CoreEnumType_literals_[v]);

      return *this;
    }


    // Nurbs23CoreType
    //

    const Nurbs23CoreType::OrderU_type& Nurbs23CoreType::
    OrderU () const
    {
      return this->OrderU_.get ();
    }

    Nurbs23CoreType::OrderU_type& Nurbs23CoreType::
    OrderU ()
    {
      return this->OrderU_.get ();
    }

    void Nurbs23CoreType::
    OrderU (const OrderU_type& x)
    {
      this->OrderU_.set (x);
    }

    void Nurbs23CoreType::
    OrderU (::std::unique_ptr< OrderU_type > x)
    {
      this->OrderU_.set (std::move (x));
    }

    const Nurbs23CoreType::OrderV_type& Nurbs23CoreType::
    OrderV () const
    {
      return this->OrderV_.get ();
    }

    Nurbs23CoreType::OrderV_type& Nurbs23CoreType::
    OrderV ()
    {
      return this->OrderV_.get ();
    }

    void Nurbs23CoreType::
    OrderV (const OrderV_type& x)
    {
      this->OrderV_.set (x);
    }

    void Nurbs23CoreType::
    OrderV (::std::unique_ptr< OrderV_type > x)
    {
      this->OrderV_.set (std::move (x));
    }

    const Nurbs23CoreType::KnotsU_type& Nurbs23CoreType::
    KnotsU () const
    {
      return this->KnotsU_.get ();
    }

    Nurbs23CoreType::KnotsU_type& Nurbs23CoreType::
    KnotsU ()
    {
      return this->KnotsU_.get ();
    }

    void Nurbs23CoreType::
    KnotsU (const KnotsU_type& x)
    {
      this->KnotsU_.set (x);
    }

    void Nurbs23CoreType::
    KnotsU (::std::unique_ptr< KnotsU_type > x)
    {
      this->KnotsU_.set (std::move (x));
    }

    const Nurbs23CoreType::KnotsV_type& Nurbs23CoreType::
    KnotsV () const
    {
      return this->KnotsV_.get ();
    }

    Nurbs23CoreType::KnotsV_type& Nurbs23CoreType::
    KnotsV ()
    {
      return this->KnotsV_.get ();
    }

    void Nurbs23CoreType::
    KnotsV (const KnotsV_type& x)
    {
      this->KnotsV_.set (x);
    }

    void Nurbs23CoreType::
    KnotsV (::std::unique_ptr< KnotsV_type > x)
    {
      this->KnotsV_.set (std::move (x));
    }

    const Nurbs23CoreType::CPs_optional& Nurbs23CoreType::
    CPs () const
    {
      return this->CPs_;
    }

    Nurbs23CoreType::CPs_optional& Nurbs23CoreType::
    CPs ()
    {
      return this->CPs_;
    }

    void Nurbs23CoreType::
    CPs (const CPs_type& x)
    {
      this->CPs_.set (x);
    }

    void Nurbs23CoreType::
    CPs (const CPs_optional& x)
    {
      this->CPs_ = x;
    }

    void Nurbs23CoreType::
    CPs (::std::unique_ptr< CPs_type > x)
    {
      this->CPs_.set (std::move (x));
    }

    const Nurbs23CoreType::CPsBinary_optional& Nurbs23CoreType::
    CPsBinary () const
    {
      return this->CPsBinary_;
    }

    Nurbs23CoreType::CPsBinary_optional& Nurbs23CoreType::
    CPsBinary ()
    {
      return this->CPsBinary_;
    }

    void Nurbs23CoreType::
    CPsBinary (const CPsBinary_type& x)
    {
      this->CPsBinary_.set (x);
    }

    void Nurbs23CoreType::
    CPsBinary (const CPsBinary_optional& x)
    {
      this->CPsBinary_ = x;
    }

    void Nurbs23CoreType::
    CPsBinary (::std::unique_ptr< CPsBinary_type > x)
    {
      this->CPsBinary_.set (std::move (x));
    }

    const Nurbs23CoreType::Weights_optional& Nurbs23CoreType::
    Weights () const
    {
      return this->Weights_;
    }

    Nurbs23CoreType::Weights_optional& Nurbs23CoreType::
    Weights ()
    {
      return this->Weights_;
    }

    void Nurbs23CoreType::
    Weights (const Weights_type& x)
    {
      this->Weights_.set (x);
    }

    void Nurbs23CoreType::
    Weights (const Weights_optional& x)
    {
      this->Weights_ = x;
    }

    void Nurbs23CoreType::
    Weights (::std::unique_ptr< Weights_type > x)
    {
      this->Weights_.set (std::move (x));
    }


    // Nurbs23Type
    //

    const Nurbs23Type::Nurbs23Core_type& Nurbs23Type::
    Nurbs23Core () const
    {
      return this->Nurbs23Core_.get ();
    }

    Nurbs23Type::Nurbs23Core_type& Nurbs23Type::
    Nurbs23Core ()
    {
      return this->Nurbs23Core_.get ();
    }

    void Nurbs23Type::
    Nurbs23Core (const Nurbs23Core_type& x)
    {
      this->Nurbs23Core_.set (x);
    }

    void Nurbs23Type::
    Nurbs23Core (::std::unique_ptr< Nurbs23Core_type > x)
    {
      this->Nurbs23Core_.set (std::move (x));
    }

    const Nurbs23Type::Transform_optional& Nurbs23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Nurbs23Type::Transform_optional& Nurbs23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Nurbs23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Nurbs23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Nurbs23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Spline23CoreType
    //

    const Spline23CoreType::KnotsU_type& Spline23CoreType::
    KnotsU () const
    {
      return this->KnotsU_.get ();
    }

    Spline23CoreType::KnotsU_type& Spline23CoreType::
    KnotsU ()
    {
      return this->KnotsU_.get ();
    }

    void Spline23CoreType::
    KnotsU (const KnotsU_type& x)
    {
      this->KnotsU_.set (x);
    }

    void Spline23CoreType::
    KnotsU (::std::unique_ptr< KnotsU_type > x)
    {
      this->KnotsU_.set (std::move (x));
    }

    const Spline23CoreType::KnotsV_type& Spline23CoreType::
    KnotsV () const
    {
      return this->KnotsV_.get ();
    }

    Spline23CoreType::KnotsV_type& Spline23CoreType::
    KnotsV ()
    {
      return this->KnotsV_.get ();
    }

    void Spline23CoreType::
    KnotsV (const KnotsV_type& x)
    {
      this->KnotsV_.set (x);
    }

    void Spline23CoreType::
    KnotsV (::std::unique_ptr< KnotsV_type > x)
    {
      this->KnotsV_.set (std::move (x));
    }

    const Spline23CoreType::OrdersU_type& Spline23CoreType::
    OrdersU () const
    {
      return this->OrdersU_.get ();
    }

    Spline23CoreType::OrdersU_type& Spline23CoreType::
    OrdersU ()
    {
      return this->OrdersU_.get ();
    }

    void Spline23CoreType::
    OrdersU (const OrdersU_type& x)
    {
      this->OrdersU_.set (x);
    }

    void Spline23CoreType::
    OrdersU (::std::unique_ptr< OrdersU_type > x)
    {
      this->OrdersU_.set (std::move (x));
    }

    const Spline23CoreType::OrdersV_type& Spline23CoreType::
    OrdersV () const
    {
      return this->OrdersV_.get ();
    }

    Spline23CoreType::OrdersV_type& Spline23CoreType::
    OrdersV ()
    {
      return this->OrdersV_.get ();
    }

    void Spline23CoreType::
    OrdersV (const OrdersV_type& x)
    {
      this->OrdersV_.set (x);
    }

    void Spline23CoreType::
    OrdersV (::std::unique_ptr< OrdersV_type > x)
    {
      this->OrdersV_.set (std::move (x));
    }

    const Spline23CoreType::Coefficients_type& Spline23CoreType::
    Coefficients () const
    {
      return this->Coefficients_.get ();
    }

    Spline23CoreType::Coefficients_type& Spline23CoreType::
    Coefficients ()
    {
      return this->Coefficients_.get ();
    }

    void Spline23CoreType::
    Coefficients (const Coefficients_type& x)
    {
      this->Coefficients_.set (x);
    }

    void Spline23CoreType::
    Coefficients (::std::unique_ptr< Coefficients_type > x)
    {
      this->Coefficients_.set (std::move (x));
    }

    const Spline23CoreType::normalized_type& Spline23CoreType::
    normalized () const
    {
      return this->normalized_.get ();
    }

    Spline23CoreType::normalized_type& Spline23CoreType::
    normalized ()
    {
      return this->normalized_.get ();
    }

    void Spline23CoreType::
    normalized (const normalized_type& x)
    {
      this->normalized_.set (x);
    }

    Spline23CoreType::normalized_type Spline23CoreType::
    normalized_default_value ()
    {
      return normalized_type (false);
    }


    // Spline23Type
    //

    const Spline23Type::Spline23Core_type& Spline23Type::
    Spline23Core () const
    {
      return this->Spline23Core_.get ();
    }

    Spline23Type::Spline23Core_type& Spline23Type::
    Spline23Core ()
    {
      return this->Spline23Core_.get ();
    }

    void Spline23Type::
    Spline23Core (const Spline23Core_type& x)
    {
      this->Spline23Core_.set (x);
    }

    void Spline23Type::
    Spline23Core (::std::unique_ptr< Spline23Core_type > x)
    {
      this->Spline23Core_.set (std::move (x));
    }

    const Spline23Type::Transform_optional& Spline23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Spline23Type::Transform_optional& Spline23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Spline23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Spline23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Spline23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Revolution23CoreType
    //

    const Revolution23CoreType::Axis_type& Revolution23CoreType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    Revolution23CoreType::Axis_type& Revolution23CoreType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void Revolution23CoreType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void Revolution23CoreType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const Revolution23CoreType::Generatrix_type& Revolution23CoreType::
    Generatrix () const
    {
      return this->Generatrix_.get ();
    }

    Revolution23CoreType::Generatrix_type& Revolution23CoreType::
    Generatrix ()
    {
      return this->Generatrix_.get ();
    }

    void Revolution23CoreType::
    Generatrix (const Generatrix_type& x)
    {
      this->Generatrix_.set (x);
    }

    void Revolution23CoreType::
    Generatrix (::std::unique_ptr< Generatrix_type > x)
    {
      this->Generatrix_.set (std::move (x));
    }

    const Revolution23CoreType::angle_type& Revolution23CoreType::
    angle () const
    {
      return this->angle_.get ();
    }

    Revolution23CoreType::angle_type& Revolution23CoreType::
    angle ()
    {
      return this->angle_.get ();
    }

    void Revolution23CoreType::
    angle (const angle_type& x)
    {
      this->angle_.set (x);
    }

    void Revolution23CoreType::
    angle (::std::unique_ptr< angle_type > x)
    {
      this->angle_.set (std::move (x));
    }


    // Revolution23Type
    //

    const Revolution23Type::Revolution23Core_type& Revolution23Type::
    Revolution23Core () const
    {
      return this->Revolution23Core_.get ();
    }

    Revolution23Type::Revolution23Core_type& Revolution23Type::
    Revolution23Core ()
    {
      return this->Revolution23Core_.get ();
    }

    void Revolution23Type::
    Revolution23Core (const Revolution23Core_type& x)
    {
      this->Revolution23Core_.set (x);
    }

    void Revolution23Type::
    Revolution23Core (::std::unique_ptr< Revolution23Core_type > x)
    {
      this->Revolution23Core_.set (std::move (x));
    }

    const Revolution23Type::Transform_optional& Revolution23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Revolution23Type::Transform_optional& Revolution23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Revolution23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Revolution23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Revolution23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Extrude23CoreType
    //

    const Extrude23CoreType::TerminationPoint_type& Extrude23CoreType::
    TerminationPoint () const
    {
      return this->TerminationPoint_.get ();
    }

    Extrude23CoreType::TerminationPoint_type& Extrude23CoreType::
    TerminationPoint ()
    {
      return this->TerminationPoint_.get ();
    }

    void Extrude23CoreType::
    TerminationPoint (const TerminationPoint_type& x)
    {
      this->TerminationPoint_.set (x);
    }

    void Extrude23CoreType::
    TerminationPoint (::std::unique_ptr< TerminationPoint_type > x)
    {
      this->TerminationPoint_.set (std::move (x));
    }

    const Extrude23CoreType::Curve_type& Extrude23CoreType::
    Curve () const
    {
      return this->Curve_.get ();
    }

    Extrude23CoreType::Curve_type& Extrude23CoreType::
    Curve ()
    {
      return this->Curve_.get ();
    }

    void Extrude23CoreType::
    Curve (const Curve_type& x)
    {
      this->Curve_.set (x);
    }

    void Extrude23CoreType::
    Curve (::std::unique_ptr< Curve_type > x)
    {
      this->Curve_.set (std::move (x));
    }


    // Extrude23Type
    //

    const Extrude23Type::Extrude23Core_type& Extrude23Type::
    Extrude23Core () const
    {
      return this->Extrude23Core_.get ();
    }

    Extrude23Type::Extrude23Core_type& Extrude23Type::
    Extrude23Core ()
    {
      return this->Extrude23Core_.get ();
    }

    void Extrude23Type::
    Extrude23Core (const Extrude23Core_type& x)
    {
      this->Extrude23Core_.set (x);
    }

    void Extrude23Type::
    Extrude23Core (::std::unique_ptr< Extrude23Core_type > x)
    {
      this->Extrude23Core_.set (std::move (x));
    }

    const Extrude23Type::Transform_optional& Extrude23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Extrude23Type::Transform_optional& Extrude23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Extrude23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Extrude23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Extrude23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Ruled23CoreType
    //

    const Ruled23CoreType::Curve_sequence& Ruled23CoreType::
    Curve () const
    {
      return this->Curve_;
    }

    Ruled23CoreType::Curve_sequence& Ruled23CoreType::
    Curve ()
    {
      return this->Curve_;
    }

    void Ruled23CoreType::
    Curve (const Curve_sequence& s)
    {
      this->Curve_ = s;
    }

    const Ruled23CoreType::turnedSecondCurve_type& Ruled23CoreType::
    turnedSecondCurve () const
    {
      return this->turnedSecondCurve_.get ();
    }

    Ruled23CoreType::turnedSecondCurve_type& Ruled23CoreType::
    turnedSecondCurve ()
    {
      return this->turnedSecondCurve_.get ();
    }

    void Ruled23CoreType::
    turnedSecondCurve (const turnedSecondCurve_type& x)
    {
      this->turnedSecondCurve_.set (x);
    }

    Ruled23CoreType::turnedSecondCurve_type Ruled23CoreType::
    turnedSecondCurve_default_value ()
    {
      return turnedSecondCurve_type (false);
    }


    // Ruled23Type
    //

    const Ruled23Type::Ruled23Core_type& Ruled23Type::
    Ruled23Core () const
    {
      return this->Ruled23Core_.get ();
    }

    Ruled23Type::Ruled23Core_type& Ruled23Type::
    Ruled23Core ()
    {
      return this->Ruled23Core_.get ();
    }

    void Ruled23Type::
    Ruled23Core (const Ruled23Core_type& x)
    {
      this->Ruled23Core_.set (x);
    }

    void Ruled23Type::
    Ruled23Core (::std::unique_ptr< Ruled23Core_type > x)
    {
      this->Ruled23Core_.set (std::move (x));
    }

    const Ruled23Type::Transform_optional& Ruled23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Ruled23Type::Transform_optional& Ruled23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Ruled23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Ruled23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Ruled23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Offset23CoreType
    //

    const Offset23CoreType::Distance_type& Offset23CoreType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    Offset23CoreType::Distance_type& Offset23CoreType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void Offset23CoreType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    const Offset23CoreType::Surface_type& Offset23CoreType::
    Surface () const
    {
      return this->Surface_.get ();
    }

    Offset23CoreType::Surface_type& Offset23CoreType::
    Surface ()
    {
      return this->Surface_.get ();
    }

    void Offset23CoreType::
    Surface (const Surface_type& x)
    {
      this->Surface_.set (x);
    }

    void Offset23CoreType::
    Surface (::std::unique_ptr< Surface_type > x)
    {
      this->Surface_.set (std::move (x));
    }


    // Offset23Type
    //

    const Offset23Type::Offset23Core_type& Offset23Type::
    Offset23Core () const
    {
      return this->Offset23Core_.get ();
    }

    Offset23Type::Offset23Core_type& Offset23Type::
    Offset23Core ()
    {
      return this->Offset23Core_.get ();
    }

    void Offset23Type::
    Offset23Core (const Offset23Core_type& x)
    {
      this->Offset23Core_.set (x);
    }

    void Offset23Type::
    Offset23Core (::std::unique_ptr< Offset23Core_type > x)
    {
      this->Offset23Core_.set (std::move (x));
    }

    const Offset23Type::Transform_optional& Offset23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Offset23Type::Transform_optional& Offset23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Offset23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Offset23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Offset23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Plane23CoreType
    //

    const Plane23CoreType::Origin_type& Plane23CoreType::
    Origin () const
    {
      return this->Origin_.get ();
    }

    Plane23CoreType::Origin_type& Plane23CoreType::
    Origin ()
    {
      return this->Origin_.get ();
    }

    void Plane23CoreType::
    Origin (const Origin_type& x)
    {
      this->Origin_.set (x);
    }

    void Plane23CoreType::
    Origin (::std::unique_ptr< Origin_type > x)
    {
      this->Origin_.set (std::move (x));
    }

    const Plane23CoreType::DirU_type& Plane23CoreType::
    DirU () const
    {
      return this->DirU_.get ();
    }

    Plane23CoreType::DirU_type& Plane23CoreType::
    DirU ()
    {
      return this->DirU_.get ();
    }

    void Plane23CoreType::
    DirU (const DirU_type& x)
    {
      this->DirU_.set (x);
    }

    void Plane23CoreType::
    DirU (::std::unique_ptr< DirU_type > x)
    {
      this->DirU_.set (std::move (x));
    }

    const Plane23CoreType::DirV_type& Plane23CoreType::
    DirV () const
    {
      return this->DirV_.get ();
    }

    Plane23CoreType::DirV_type& Plane23CoreType::
    DirV ()
    {
      return this->DirV_.get ();
    }

    void Plane23CoreType::
    DirV (const DirV_type& x)
    {
      this->DirV_.set (x);
    }

    void Plane23CoreType::
    DirV (::std::unique_ptr< DirV_type > x)
    {
      this->DirV_.set (std::move (x));
    }

    const Plane23CoreType::domainU_type& Plane23CoreType::
    domainU () const
    {
      return this->domainU_.get ();
    }

    Plane23CoreType::domainU_type& Plane23CoreType::
    domainU ()
    {
      return this->domainU_.get ();
    }

    void Plane23CoreType::
    domainU (const domainU_type& x)
    {
      this->domainU_.set (x);
    }

    void Plane23CoreType::
    domainU (::std::unique_ptr< domainU_type > x)
    {
      this->domainU_.set (std::move (x));
    }

    const Plane23CoreType::domainV_type& Plane23CoreType::
    domainV () const
    {
      return this->domainV_.get ();
    }

    Plane23CoreType::domainV_type& Plane23CoreType::
    domainV ()
    {
      return this->domainV_.get ();
    }

    void Plane23CoreType::
    domainV (const domainV_type& x)
    {
      this->domainV_.set (x);
    }

    void Plane23CoreType::
    domainV (::std::unique_ptr< domainV_type > x)
    {
      this->domainV_.set (std::move (x));
    }


    // Plane23Type
    //

    const Plane23Type::Plane23Core_type& Plane23Type::
    Plane23Core () const
    {
      return this->Plane23Core_.get ();
    }

    Plane23Type::Plane23Core_type& Plane23Type::
    Plane23Core ()
    {
      return this->Plane23Core_.get ();
    }

    void Plane23Type::
    Plane23Core (const Plane23Core_type& x)
    {
      this->Plane23Core_.set (x);
    }

    void Plane23Type::
    Plane23Core (::std::unique_ptr< Plane23Core_type > x)
    {
      this->Plane23Core_.set (std::move (x));
    }

    const Plane23Type::Transform_optional& Plane23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Plane23Type::Transform_optional& Plane23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Plane23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Plane23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Plane23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Cone23CoreType
    //

    const Cone23CoreType::DiameterBottom_type& Cone23CoreType::
    DiameterBottom () const
    {
      return this->DiameterBottom_.get ();
    }

    Cone23CoreType::DiameterBottom_type& Cone23CoreType::
    DiameterBottom ()
    {
      return this->DiameterBottom_.get ();
    }

    void Cone23CoreType::
    DiameterBottom (const DiameterBottom_type& x)
    {
      this->DiameterBottom_.set (x);
    }

    const Cone23CoreType::DiameterTop_type& Cone23CoreType::
    DiameterTop () const
    {
      return this->DiameterTop_.get ();
    }

    Cone23CoreType::DiameterTop_type& Cone23CoreType::
    DiameterTop ()
    {
      return this->DiameterTop_.get ();
    }

    void Cone23CoreType::
    DiameterTop (const DiameterTop_type& x)
    {
      this->DiameterTop_.set (x);
    }

    const Cone23CoreType::Length_type& Cone23CoreType::
    Length () const
    {
      return this->Length_.get ();
    }

    Cone23CoreType::Length_type& Cone23CoreType::
    Length ()
    {
      return this->Length_.get ();
    }

    void Cone23CoreType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    const Cone23CoreType::Axis_type& Cone23CoreType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    Cone23CoreType::Axis_type& Cone23CoreType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void Cone23CoreType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void Cone23CoreType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const Cone23CoreType::Sweep_type& Cone23CoreType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    Cone23CoreType::Sweep_type& Cone23CoreType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void Cone23CoreType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void Cone23CoreType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const Cone23CoreType::turnedV_type& Cone23CoreType::
    turnedV () const
    {
      return this->turnedV_.get ();
    }

    Cone23CoreType::turnedV_type& Cone23CoreType::
    turnedV ()
    {
      return this->turnedV_.get ();
    }

    void Cone23CoreType::
    turnedV (const turnedV_type& x)
    {
      this->turnedV_.set (x);
    }

    Cone23CoreType::turnedV_type Cone23CoreType::
    turnedV_default_value ()
    {
      return turnedV_type (false);
    }

    const Cone23CoreType::scaleU_type& Cone23CoreType::
    scaleU () const
    {
      return this->scaleU_.get ();
    }

    Cone23CoreType::scaleU_type& Cone23CoreType::
    scaleU ()
    {
      return this->scaleU_.get ();
    }

    void Cone23CoreType::
    scaleU (const scaleU_type& x)
    {
      this->scaleU_.set (x);
    }

    void Cone23CoreType::
    scaleU (::std::unique_ptr< scaleU_type > x)
    {
      this->scaleU_.set (std::move (x));
    }

    Cone23CoreType::scaleU_type Cone23CoreType::
    scaleU_default_value ()
    {
      return scaleU_type (1.0);
    }

    const Cone23CoreType::scaleV_type& Cone23CoreType::
    scaleV () const
    {
      return this->scaleV_.get ();
    }

    Cone23CoreType::scaleV_type& Cone23CoreType::
    scaleV ()
    {
      return this->scaleV_.get ();
    }

    void Cone23CoreType::
    scaleV (const scaleV_type& x)
    {
      this->scaleV_.set (x);
    }

    void Cone23CoreType::
    scaleV (::std::unique_ptr< scaleV_type > x)
    {
      this->scaleV_.set (std::move (x));
    }

    Cone23CoreType::scaleV_type Cone23CoreType::
    scaleV_default_value ()
    {
      return scaleV_type (1.0);
    }


    // Cone23Type
    //

    const Cone23Type::Cone23Core_type& Cone23Type::
    Cone23Core () const
    {
      return this->Cone23Core_.get ();
    }

    Cone23Type::Cone23Core_type& Cone23Type::
    Cone23Core ()
    {
      return this->Cone23Core_.get ();
    }

    void Cone23Type::
    Cone23Core (const Cone23Core_type& x)
    {
      this->Cone23Core_.set (x);
    }

    void Cone23Type::
    Cone23Core (::std::unique_ptr< Cone23Core_type > x)
    {
      this->Cone23Core_.set (std::move (x));
    }

    const Cone23Type::Transform_optional& Cone23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Cone23Type::Transform_optional& Cone23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Cone23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Cone23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Cone23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Cylinder23CoreType
    //

    const Cylinder23CoreType::Diameter_type& Cylinder23CoreType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    Cylinder23CoreType::Diameter_type& Cylinder23CoreType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void Cylinder23CoreType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    const Cylinder23CoreType::Length_type& Cylinder23CoreType::
    Length () const
    {
      return this->Length_.get ();
    }

    Cylinder23CoreType::Length_type& Cylinder23CoreType::
    Length ()
    {
      return this->Length_.get ();
    }

    void Cylinder23CoreType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    const Cylinder23CoreType::Axis_type& Cylinder23CoreType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    Cylinder23CoreType::Axis_type& Cylinder23CoreType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void Cylinder23CoreType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void Cylinder23CoreType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const Cylinder23CoreType::Sweep_type& Cylinder23CoreType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    Cylinder23CoreType::Sweep_type& Cylinder23CoreType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void Cylinder23CoreType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void Cylinder23CoreType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const Cylinder23CoreType::turnedV_type& Cylinder23CoreType::
    turnedV () const
    {
      return this->turnedV_.get ();
    }

    Cylinder23CoreType::turnedV_type& Cylinder23CoreType::
    turnedV ()
    {
      return this->turnedV_.get ();
    }

    void Cylinder23CoreType::
    turnedV (const turnedV_type& x)
    {
      this->turnedV_.set (x);
    }

    Cylinder23CoreType::turnedV_type Cylinder23CoreType::
    turnedV_default_value ()
    {
      return turnedV_type (false);
    }

    const Cylinder23CoreType::scaleU_type& Cylinder23CoreType::
    scaleU () const
    {
      return this->scaleU_.get ();
    }

    Cylinder23CoreType::scaleU_type& Cylinder23CoreType::
    scaleU ()
    {
      return this->scaleU_.get ();
    }

    void Cylinder23CoreType::
    scaleU (const scaleU_type& x)
    {
      this->scaleU_.set (x);
    }

    void Cylinder23CoreType::
    scaleU (::std::unique_ptr< scaleU_type > x)
    {
      this->scaleU_.set (std::move (x));
    }

    Cylinder23CoreType::scaleU_type Cylinder23CoreType::
    scaleU_default_value ()
    {
      return scaleU_type (1.0);
    }

    const Cylinder23CoreType::scaleV_type& Cylinder23CoreType::
    scaleV () const
    {
      return this->scaleV_.get ();
    }

    Cylinder23CoreType::scaleV_type& Cylinder23CoreType::
    scaleV ()
    {
      return this->scaleV_.get ();
    }

    void Cylinder23CoreType::
    scaleV (const scaleV_type& x)
    {
      this->scaleV_.set (x);
    }

    void Cylinder23CoreType::
    scaleV (::std::unique_ptr< scaleV_type > x)
    {
      this->scaleV_.set (std::move (x));
    }

    Cylinder23CoreType::scaleV_type Cylinder23CoreType::
    scaleV_default_value ()
    {
      return scaleV_type (1.0);
    }


    // Cylinder23Type
    //

    const Cylinder23Type::Cylinder23Core_type& Cylinder23Type::
    Cylinder23Core () const
    {
      return this->Cylinder23Core_.get ();
    }

    Cylinder23Type::Cylinder23Core_type& Cylinder23Type::
    Cylinder23Core ()
    {
      return this->Cylinder23Core_.get ();
    }

    void Cylinder23Type::
    Cylinder23Core (const Cylinder23Core_type& x)
    {
      this->Cylinder23Core_.set (x);
    }

    void Cylinder23Type::
    Cylinder23Core (::std::unique_ptr< Cylinder23Core_type > x)
    {
      this->Cylinder23Core_.set (std::move (x));
    }

    const Cylinder23Type::Transform_optional& Cylinder23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Cylinder23Type::Transform_optional& Cylinder23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Cylinder23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Cylinder23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Cylinder23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Sphere23CoreType
    //

    const Sphere23CoreType::Diameter_type& Sphere23CoreType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    Sphere23CoreType::Diameter_type& Sphere23CoreType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void Sphere23CoreType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    const Sphere23CoreType::Location_type& Sphere23CoreType::
    Location () const
    {
      return this->Location_.get ();
    }

    Sphere23CoreType::Location_type& Sphere23CoreType::
    Location ()
    {
      return this->Location_.get ();
    }

    void Sphere23CoreType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void Sphere23CoreType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const Sphere23CoreType::LatitudeLongitudeSweep_type& Sphere23CoreType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    Sphere23CoreType::LatitudeLongitudeSweep_type& Sphere23CoreType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    void Sphere23CoreType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void Sphere23CoreType::
    LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (std::move (x));
    }

    const Sphere23CoreType::turnedV_type& Sphere23CoreType::
    turnedV () const
    {
      return this->turnedV_.get ();
    }

    Sphere23CoreType::turnedV_type& Sphere23CoreType::
    turnedV ()
    {
      return this->turnedV_.get ();
    }

    void Sphere23CoreType::
    turnedV (const turnedV_type& x)
    {
      this->turnedV_.set (x);
    }

    Sphere23CoreType::turnedV_type Sphere23CoreType::
    turnedV_default_value ()
    {
      return turnedV_type (false);
    }

    const Sphere23CoreType::scaleU_type& Sphere23CoreType::
    scaleU () const
    {
      return this->scaleU_.get ();
    }

    Sphere23CoreType::scaleU_type& Sphere23CoreType::
    scaleU ()
    {
      return this->scaleU_.get ();
    }

    void Sphere23CoreType::
    scaleU (const scaleU_type& x)
    {
      this->scaleU_.set (x);
    }

    void Sphere23CoreType::
    scaleU (::std::unique_ptr< scaleU_type > x)
    {
      this->scaleU_.set (std::move (x));
    }

    Sphere23CoreType::scaleU_type Sphere23CoreType::
    scaleU_default_value ()
    {
      return scaleU_type (1.0);
    }

    const Sphere23CoreType::scaleV_type& Sphere23CoreType::
    scaleV () const
    {
      return this->scaleV_.get ();
    }

    Sphere23CoreType::scaleV_type& Sphere23CoreType::
    scaleV ()
    {
      return this->scaleV_.get ();
    }

    void Sphere23CoreType::
    scaleV (const scaleV_type& x)
    {
      this->scaleV_.set (x);
    }

    void Sphere23CoreType::
    scaleV (::std::unique_ptr< scaleV_type > x)
    {
      this->scaleV_.set (std::move (x));
    }

    Sphere23CoreType::scaleV_type Sphere23CoreType::
    scaleV_default_value ()
    {
      return scaleV_type (1.0);
    }


    // Sphere23Type
    //

    const Sphere23Type::Sphere23Core_type& Sphere23Type::
    Sphere23Core () const
    {
      return this->Sphere23Core_.get ();
    }

    Sphere23Type::Sphere23Core_type& Sphere23Type::
    Sphere23Core ()
    {
      return this->Sphere23Core_.get ();
    }

    void Sphere23Type::
    Sphere23Core (const Sphere23Core_type& x)
    {
      this->Sphere23Core_.set (x);
    }

    void Sphere23Type::
    Sphere23Core (::std::unique_ptr< Sphere23Core_type > x)
    {
      this->Sphere23Core_.set (std::move (x));
    }

    const Sphere23Type::Transform_optional& Sphere23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Sphere23Type::Transform_optional& Sphere23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Sphere23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Sphere23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Sphere23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // Torus23CoreType
    //

    const Torus23CoreType::DiameterMinor_type& Torus23CoreType::
    DiameterMinor () const
    {
      return this->DiameterMinor_.get ();
    }

    Torus23CoreType::DiameterMinor_type& Torus23CoreType::
    DiameterMinor ()
    {
      return this->DiameterMinor_.get ();
    }

    void Torus23CoreType::
    DiameterMinor (const DiameterMinor_type& x)
    {
      this->DiameterMinor_.set (x);
    }

    const Torus23CoreType::DiameterMajor_type& Torus23CoreType::
    DiameterMajor () const
    {
      return this->DiameterMajor_.get ();
    }

    Torus23CoreType::DiameterMajor_type& Torus23CoreType::
    DiameterMajor ()
    {
      return this->DiameterMajor_.get ();
    }

    void Torus23CoreType::
    DiameterMajor (const DiameterMajor_type& x)
    {
      this->DiameterMajor_.set (x);
    }

    const Torus23CoreType::Axis_type& Torus23CoreType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    Torus23CoreType::Axis_type& Torus23CoreType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void Torus23CoreType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void Torus23CoreType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const Torus23CoreType::LatitudeLongitudeSweep_type& Torus23CoreType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    Torus23CoreType::LatitudeLongitudeSweep_type& Torus23CoreType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    void Torus23CoreType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void Torus23CoreType::
    LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (std::move (x));
    }

    const Torus23CoreType::turnedV_type& Torus23CoreType::
    turnedV () const
    {
      return this->turnedV_.get ();
    }

    Torus23CoreType::turnedV_type& Torus23CoreType::
    turnedV ()
    {
      return this->turnedV_.get ();
    }

    void Torus23CoreType::
    turnedV (const turnedV_type& x)
    {
      this->turnedV_.set (x);
    }

    Torus23CoreType::turnedV_type Torus23CoreType::
    turnedV_default_value ()
    {
      return turnedV_type (false);
    }

    const Torus23CoreType::offsetV_type& Torus23CoreType::
    offsetV () const
    {
      return this->offsetV_.get ();
    }

    Torus23CoreType::offsetV_type& Torus23CoreType::
    offsetV ()
    {
      return this->offsetV_.get ();
    }

    void Torus23CoreType::
    offsetV (const offsetV_type& x)
    {
      this->offsetV_.set (x);
    }

    Torus23CoreType::offsetV_type Torus23CoreType::
    offsetV_default_value ()
    {
      return offsetV_type (.0);
    }

    const Torus23CoreType::scaleU_type& Torus23CoreType::
    scaleU () const
    {
      return this->scaleU_.get ();
    }

    Torus23CoreType::scaleU_type& Torus23CoreType::
    scaleU ()
    {
      return this->scaleU_.get ();
    }

    void Torus23CoreType::
    scaleU (const scaleU_type& x)
    {
      this->scaleU_.set (x);
    }

    void Torus23CoreType::
    scaleU (::std::unique_ptr< scaleU_type > x)
    {
      this->scaleU_.set (std::move (x));
    }

    Torus23CoreType::scaleU_type Torus23CoreType::
    scaleU_default_value ()
    {
      return scaleU_type (1.0);
    }

    const Torus23CoreType::scaleV_type& Torus23CoreType::
    scaleV () const
    {
      return this->scaleV_.get ();
    }

    Torus23CoreType::scaleV_type& Torus23CoreType::
    scaleV ()
    {
      return this->scaleV_.get ();
    }

    void Torus23CoreType::
    scaleV (const scaleV_type& x)
    {
      this->scaleV_.set (x);
    }

    void Torus23CoreType::
    scaleV (::std::unique_ptr< scaleV_type > x)
    {
      this->scaleV_.set (std::move (x));
    }

    Torus23CoreType::scaleV_type Torus23CoreType::
    scaleV_default_value ()
    {
      return scaleV_type (1.0);
    }


    // Torus23Type
    //

    const Torus23Type::Torus23Core_type& Torus23Type::
    Torus23Core () const
    {
      return this->Torus23Core_.get ();
    }

    Torus23Type::Torus23Core_type& Torus23Type::
    Torus23Core ()
    {
      return this->Torus23Core_.get ();
    }

    void Torus23Type::
    Torus23Core (const Torus23Core_type& x)
    {
      this->Torus23Core_.set (x);
    }

    void Torus23Type::
    Torus23Core (::std::unique_ptr< Torus23Core_type > x)
    {
      this->Torus23Core_.set (std::move (x));
    }

    const Torus23Type::Transform_optional& Torus23Type::
    Transform () const
    {
      return this->Transform_;
    }

    Torus23Type::Transform_optional& Torus23Type::
    Transform ()
    {
      return this->Transform_;
    }

    void Torus23Type::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void Torus23Type::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void Torus23Type::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // CurveMeshSetType
    //

    const CurveMeshSetType::PathTriangulation_sequence& CurveMeshSetType::
    PathTriangulation () const
    {
      return this->PathTriangulation_;
    }

    CurveMeshSetType::PathTriangulation_sequence& CurveMeshSetType::
    PathTriangulation ()
    {
      return this->PathTriangulation_;
    }

    void CurveMeshSetType::
    PathTriangulation (const PathTriangulation_sequence& s)
    {
      this->PathTriangulation_ = s;
    }

    const CurveMeshSetType::n_type& CurveMeshSetType::
    n () const
    {
      return this->n_.get ();
    }

    CurveMeshSetType::n_type& CurveMeshSetType::
    n ()
    {
      return this->n_.get ();
    }

    void CurveMeshSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CurveMeshSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PathTriangulationCoreType
    //

    const PathTriangulationCoreType::Edges_optional& PathTriangulationCoreType::
    Edges () const
    {
      return this->Edges_;
    }

    PathTriangulationCoreType::Edges_optional& PathTriangulationCoreType::
    Edges ()
    {
      return this->Edges_;
    }

    void PathTriangulationCoreType::
    Edges (const Edges_type& x)
    {
      this->Edges_.set (x);
    }

    void PathTriangulationCoreType::
    Edges (const Edges_optional& x)
    {
      this->Edges_ = x;
    }

    void PathTriangulationCoreType::
    Edges (::std::unique_ptr< Edges_type > x)
    {
      this->Edges_.set (std::move (x));
    }

    const PathTriangulationCoreType::EdgesBinary_optional& PathTriangulationCoreType::
    EdgesBinary () const
    {
      return this->EdgesBinary_;
    }

    PathTriangulationCoreType::EdgesBinary_optional& PathTriangulationCoreType::
    EdgesBinary ()
    {
      return this->EdgesBinary_;
    }

    void PathTriangulationCoreType::
    EdgesBinary (const EdgesBinary_type& x)
    {
      this->EdgesBinary_.set (x);
    }

    void PathTriangulationCoreType::
    EdgesBinary (const EdgesBinary_optional& x)
    {
      this->EdgesBinary_ = x;
    }

    void PathTriangulationCoreType::
    EdgesBinary (::std::unique_ptr< EdgesBinary_type > x)
    {
      this->EdgesBinary_.set (std::move (x));
    }


    // PathTriangulationType
    //

    const PathTriangulationType::PathTriangulationCore_type& PathTriangulationType::
    PathTriangulationCore () const
    {
      return this->PathTriangulationCore_.get ();
    }

    PathTriangulationType::PathTriangulationCore_type& PathTriangulationType::
    PathTriangulationCore ()
    {
      return this->PathTriangulationCore_.get ();
    }

    void PathTriangulationType::
    PathTriangulationCore (const PathTriangulationCore_type& x)
    {
      this->PathTriangulationCore_.set (x);
    }

    void PathTriangulationType::
    PathTriangulationCore (::std::unique_ptr< PathTriangulationCore_type > x)
    {
      this->PathTriangulationCore_.set (std::move (x));
    }

    const PathTriangulationType::MeshTriangle_type& PathTriangulationType::
    MeshTriangle () const
    {
      return this->MeshTriangle_.get ();
    }

    PathTriangulationType::MeshTriangle_type& PathTriangulationType::
    MeshTriangle ()
    {
      return this->MeshTriangle_.get ();
    }

    void PathTriangulationType::
    MeshTriangle (const MeshTriangle_type& x)
    {
      this->MeshTriangle_.set (x);
    }

    void PathTriangulationType::
    MeshTriangle (::std::unique_ptr< MeshTriangle_type > x)
    {
      this->MeshTriangle_.set (std::move (x));
    }


    // SurfaceMeshSetType
    //

    const SurfaceMeshSetType::MeshTriangle_sequence& SurfaceMeshSetType::
    MeshTriangle () const
    {
      return this->MeshTriangle_;
    }

    SurfaceMeshSetType::MeshTriangle_sequence& SurfaceMeshSetType::
    MeshTriangle ()
    {
      return this->MeshTriangle_;
    }

    void SurfaceMeshSetType::
    MeshTriangle (const MeshTriangle_sequence& s)
    {
      this->MeshTriangle_ = s;
    }

    const SurfaceMeshSetType::n_type& SurfaceMeshSetType::
    n () const
    {
      return this->n_.get ();
    }

    SurfaceMeshSetType::n_type& SurfaceMeshSetType::
    n ()
    {
      return this->n_.get ();
    }

    void SurfaceMeshSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SurfaceMeshSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MeshTriangleCoreType
    //

    const MeshTriangleCoreType::Triangles_optional& MeshTriangleCoreType::
    Triangles () const
    {
      return this->Triangles_;
    }

    MeshTriangleCoreType::Triangles_optional& MeshTriangleCoreType::
    Triangles ()
    {
      return this->Triangles_;
    }

    void MeshTriangleCoreType::
    Triangles (const Triangles_type& x)
    {
      this->Triangles_.set (x);
    }

    void MeshTriangleCoreType::
    Triangles (const Triangles_optional& x)
    {
      this->Triangles_ = x;
    }

    void MeshTriangleCoreType::
    Triangles (::std::unique_ptr< Triangles_type > x)
    {
      this->Triangles_.set (std::move (x));
    }

    const MeshTriangleCoreType::TrianglesBinary_optional& MeshTriangleCoreType::
    TrianglesBinary () const
    {
      return this->TrianglesBinary_;
    }

    MeshTriangleCoreType::TrianglesBinary_optional& MeshTriangleCoreType::
    TrianglesBinary ()
    {
      return this->TrianglesBinary_;
    }

    void MeshTriangleCoreType::
    TrianglesBinary (const TrianglesBinary_type& x)
    {
      this->TrianglesBinary_.set (x);
    }

    void MeshTriangleCoreType::
    TrianglesBinary (const TrianglesBinary_optional& x)
    {
      this->TrianglesBinary_ = x;
    }

    void MeshTriangleCoreType::
    TrianglesBinary (::std::unique_ptr< TrianglesBinary_type > x)
    {
      this->TrianglesBinary_.set (std::move (x));
    }

    const MeshTriangleCoreType::Neighbours_optional& MeshTriangleCoreType::
    Neighbours () const
    {
      return this->Neighbours_;
    }

    MeshTriangleCoreType::Neighbours_optional& MeshTriangleCoreType::
    Neighbours ()
    {
      return this->Neighbours_;
    }

    void MeshTriangleCoreType::
    Neighbours (const Neighbours_type& x)
    {
      this->Neighbours_.set (x);
    }

    void MeshTriangleCoreType::
    Neighbours (const Neighbours_optional& x)
    {
      this->Neighbours_ = x;
    }

    void MeshTriangleCoreType::
    Neighbours (::std::unique_ptr< Neighbours_type > x)
    {
      this->Neighbours_.set (std::move (x));
    }

    const MeshTriangleCoreType::NeighboursBinary_optional& MeshTriangleCoreType::
    NeighboursBinary () const
    {
      return this->NeighboursBinary_;
    }

    MeshTriangleCoreType::NeighboursBinary_optional& MeshTriangleCoreType::
    NeighboursBinary ()
    {
      return this->NeighboursBinary_;
    }

    void MeshTriangleCoreType::
    NeighboursBinary (const NeighboursBinary_type& x)
    {
      this->NeighboursBinary_.set (x);
    }

    void MeshTriangleCoreType::
    NeighboursBinary (const NeighboursBinary_optional& x)
    {
      this->NeighboursBinary_ = x;
    }

    void MeshTriangleCoreType::
    NeighboursBinary (::std::unique_ptr< NeighboursBinary_type > x)
    {
      this->NeighboursBinary_.set (std::move (x));
    }

    const MeshTriangleCoreType::Vertices_optional& MeshTriangleCoreType::
    Vertices () const
    {
      return this->Vertices_;
    }

    MeshTriangleCoreType::Vertices_optional& MeshTriangleCoreType::
    Vertices ()
    {
      return this->Vertices_;
    }

    void MeshTriangleCoreType::
    Vertices (const Vertices_type& x)
    {
      this->Vertices_.set (x);
    }

    void MeshTriangleCoreType::
    Vertices (const Vertices_optional& x)
    {
      this->Vertices_ = x;
    }

    void MeshTriangleCoreType::
    Vertices (::std::unique_ptr< Vertices_type > x)
    {
      this->Vertices_.set (std::move (x));
    }

    const MeshTriangleCoreType::VerticesBinary_optional& MeshTriangleCoreType::
    VerticesBinary () const
    {
      return this->VerticesBinary_;
    }

    MeshTriangleCoreType::VerticesBinary_optional& MeshTriangleCoreType::
    VerticesBinary ()
    {
      return this->VerticesBinary_;
    }

    void MeshTriangleCoreType::
    VerticesBinary (const VerticesBinary_type& x)
    {
      this->VerticesBinary_.set (x);
    }

    void MeshTriangleCoreType::
    VerticesBinary (const VerticesBinary_optional& x)
    {
      this->VerticesBinary_ = x;
    }

    void MeshTriangleCoreType::
    VerticesBinary (::std::unique_ptr< VerticesBinary_type > x)
    {
      this->VerticesBinary_.set (std::move (x));
    }

    const MeshTriangleCoreType::Normals_optional& MeshTriangleCoreType::
    Normals () const
    {
      return this->Normals_;
    }

    MeshTriangleCoreType::Normals_optional& MeshTriangleCoreType::
    Normals ()
    {
      return this->Normals_;
    }

    void MeshTriangleCoreType::
    Normals (const Normals_type& x)
    {
      this->Normals_.set (x);
    }

    void MeshTriangleCoreType::
    Normals (const Normals_optional& x)
    {
      this->Normals_ = x;
    }

    void MeshTriangleCoreType::
    Normals (::std::unique_ptr< Normals_type > x)
    {
      this->Normals_.set (std::move (x));
    }

    const MeshTriangleCoreType::NormalsBinary_optional& MeshTriangleCoreType::
    NormalsBinary () const
    {
      return this->NormalsBinary_;
    }

    MeshTriangleCoreType::NormalsBinary_optional& MeshTriangleCoreType::
    NormalsBinary ()
    {
      return this->NormalsBinary_;
    }

    void MeshTriangleCoreType::
    NormalsBinary (const NormalsBinary_type& x)
    {
      this->NormalsBinary_.set (x);
    }

    void MeshTriangleCoreType::
    NormalsBinary (const NormalsBinary_optional& x)
    {
      this->NormalsBinary_ = x;
    }

    void MeshTriangleCoreType::
    NormalsBinary (::std::unique_ptr< NormalsBinary_type > x)
    {
      this->NormalsBinary_.set (std::move (x));
    }


    // TriangleVertexNormalType
    //

    const TriangleVertexNormalType::vertex_type& TriangleVertexNormalType::
    vertex () const
    {
      return this->vertex_.get ();
    }

    TriangleVertexNormalType::vertex_type& TriangleVertexNormalType::
    vertex ()
    {
      return this->vertex_.get ();
    }

    void TriangleVertexNormalType::
    vertex (const vertex_type& x)
    {
      this->vertex_.set (x);
    }

    void TriangleVertexNormalType::
    vertex (::std::unique_ptr< vertex_type > x)
    {
      this->vertex_.set (std::move (x));
    }


    // ArrayTriangleVertexNormalType
    //

    const ArrayTriangleVertexNormalType::NormalSpecial_sequence& ArrayTriangleVertexNormalType::
    NormalSpecial () const
    {
      return this->NormalSpecial_;
    }

    ArrayTriangleVertexNormalType::NormalSpecial_sequence& ArrayTriangleVertexNormalType::
    NormalSpecial ()
    {
      return this->NormalSpecial_;
    }

    void ArrayTriangleVertexNormalType::
    NormalSpecial (const NormalSpecial_sequence& s)
    {
      this->NormalSpecial_ = s;
    }

    const ArrayTriangleVertexNormalType::n_type& ArrayTriangleVertexNormalType::
    n () const
    {
      return this->n_.get ();
    }

    ArrayTriangleVertexNormalType::n_type& ArrayTriangleVertexNormalType::
    n ()
    {
      return this->n_.get ();
    }

    void ArrayTriangleVertexNormalType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ArrayTriangleVertexNormalType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MeshTriangleType
    //

    const MeshTriangleType::MeshTriangleCore_type& MeshTriangleType::
    MeshTriangleCore () const
    {
      return this->MeshTriangleCore_.get ();
    }

    MeshTriangleType::MeshTriangleCore_type& MeshTriangleType::
    MeshTriangleCore ()
    {
      return this->MeshTriangleCore_.get ();
    }

    void MeshTriangleType::
    MeshTriangleCore (const MeshTriangleCore_type& x)
    {
      this->MeshTriangleCore_.set (x);
    }

    void MeshTriangleType::
    MeshTriangleCore (::std::unique_ptr< MeshTriangleCore_type > x)
    {
      this->MeshTriangleCore_.set (std::move (x));
    }

    const MeshTriangleType::NormalsSpecial_optional& MeshTriangleType::
    NormalsSpecial () const
    {
      return this->NormalsSpecial_;
    }

    MeshTriangleType::NormalsSpecial_optional& MeshTriangleType::
    NormalsSpecial ()
    {
      return this->NormalsSpecial_;
    }

    void MeshTriangleType::
    NormalsSpecial (const NormalsSpecial_type& x)
    {
      this->NormalsSpecial_.set (x);
    }

    void MeshTriangleType::
    NormalsSpecial (const NormalsSpecial_optional& x)
    {
      this->NormalsSpecial_ = x;
    }

    void MeshTriangleType::
    NormalsSpecial (::std::unique_ptr< NormalsSpecial_type > x)
    {
      this->NormalsSpecial_.set (std::move (x));
    }

    const MeshTriangleType::NormalsSpecialBinary_optional& MeshTriangleType::
    NormalsSpecialBinary () const
    {
      return this->NormalsSpecialBinary_;
    }

    MeshTriangleType::NormalsSpecialBinary_optional& MeshTriangleType::
    NormalsSpecialBinary ()
    {
      return this->NormalsSpecialBinary_;
    }

    void MeshTriangleType::
    NormalsSpecialBinary (const NormalsSpecialBinary_type& x)
    {
      this->NormalsSpecialBinary_.set (x);
    }

    void MeshTriangleType::
    NormalsSpecialBinary (const NormalsSpecialBinary_optional& x)
    {
      this->NormalsSpecialBinary_ = x;
    }

    void MeshTriangleType::
    NormalsSpecialBinary (::std::unique_ptr< NormalsSpecialBinary_type > x)
    {
      this->NormalsSpecialBinary_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // GeometrySetType
    //

    GeometrySetType::
    GeometrySetType ()
    : ::xml_schema::type (),
      PointSet_ (this),
      Curve12Set_ (this),
      Curve13Set_ (this),
      SurfaceSet_ (this),
      CurveMeshSet_ (this),
      SurfaceMeshSet_ (this)
    {
    }

    GeometrySetType::
    GeometrySetType (const GeometrySetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSet_ (x.PointSet_, f, this),
      Curve12Set_ (x.Curve12Set_, f, this),
      Curve13Set_ (x.Curve13Set_, f, this),
      SurfaceSet_ (x.SurfaceSet_, f, this),
      CurveMeshSet_ (x.CurveMeshSet_, f, this),
      SurfaceMeshSet_ (x.SurfaceMeshSet_, f, this)
    {
    }

    GeometrySetType::
    GeometrySetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSet_ (this),
      Curve12Set_ (this),
      Curve13Set_ (this),
      SurfaceSet_ (this),
      CurveMeshSet_ (this),
      SurfaceMeshSet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void GeometrySetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSet
        //
        if (n.name () == L"PointSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointSet_type > r (
            PointSet_traits::create (i, f, this));

          if (!this->PointSet_)
          {
            this->PointSet_.set (::std::move (r));
            continue;
          }
        }

        // Curve12Set
        //
        if (n.name () == L"Curve12Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Curve12Set_type > r (
            Curve12Set_traits::create (i, f, this));

          if (!this->Curve12Set_)
          {
            this->Curve12Set_.set (::std::move (r));
            continue;
          }
        }

        // Curve13Set
        //
        if (n.name () == L"Curve13Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Curve13Set_type > r (
            Curve13Set_traits::create (i, f, this));

          if (!this->Curve13Set_)
          {
            this->Curve13Set_.set (::std::move (r));
            continue;
          }
        }

        // SurfaceSet
        //
        if (n.name () == L"SurfaceSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceSet_type > r (
            SurfaceSet_traits::create (i, f, this));

          if (!this->SurfaceSet_)
          {
            this->SurfaceSet_.set (::std::move (r));
            continue;
          }
        }

        // CurveMeshSet
        //
        if (n.name () == L"CurveMeshSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveMeshSet_type > r (
            CurveMeshSet_traits::create (i, f, this));

          if (!this->CurveMeshSet_)
          {
            this->CurveMeshSet_.set (::std::move (r));
            continue;
          }
        }

        // SurfaceMeshSet
        //
        if (n.name () == L"SurfaceMeshSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceMeshSet_type > r (
            SurfaceMeshSet_traits::create (i, f, this));

          if (!this->SurfaceMeshSet_)
          {
            this->SurfaceMeshSet_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    GeometrySetType* GeometrySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GeometrySetType (*this, f, c);
    }

    GeometrySetType& GeometrySetType::
    operator= (const GeometrySetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSet_ = x.PointSet_;
        this->Curve12Set_ = x.Curve12Set_;
        this->Curve13Set_ = x.Curve13Set_;
        this->SurfaceSet_ = x.SurfaceSet_;
        this->CurveMeshSet_ = x.CurveMeshSet_;
        this->SurfaceMeshSet_ = x.SurfaceMeshSet_;
      }

      return *this;
    }

    GeometrySetType::
    ~GeometrySetType ()
    {
    }

    // GeometryBaseType
    //

    GeometryBaseType::
    GeometryBaseType ()
    : ::xsd::qif30::NodeWithIdBaseType ()
    {
    }

    GeometryBaseType::
    GeometryBaseType (const id_type& id)
    : ::xsd::qif30::NodeWithIdBaseType (id)
    {
    }

    GeometryBaseType::
    GeometryBaseType (const GeometryBaseType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (x, f, c)
    {
    }

    GeometryBaseType::
    GeometryBaseType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::NodeWithIdBaseType (e, f, c)
    {
    }

    GeometryBaseType::
    ~GeometryBaseType ()
    {
    }

    // PointSetType
    //

    PointSetType::
    PointSetType ()
    : ::xml_schema::type (),
      Point_ (this),
      n_ (this)
    {
    }

    PointSetType::
    PointSetType (const n_type& n)
    : ::xml_schema::type (),
      Point_ (this),
      n_ (n, this)
    {
    }

    PointSetType::
    PointSetType (const PointSetType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PointSetType::
    PointSetType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          this->Point_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PointSetType* PointSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointSetType (*this, f, c);
    }

    PointSetType& PointSetType::
    operator= (const PointSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Point_ = x.Point_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PointSetType::
    ~PointSetType ()
    {
    }

    // PointEntityType
    //

    PointEntityType::
    PointEntityType ()
    : ::xsd::qif30::GeometryBaseType (),
      XYZ_ (this)
    {
    }

    PointEntityType::
    PointEntityType (const id_type& id,
                     const XYZ_type& XYZ)
    : ::xsd::qif30::GeometryBaseType (id),
      XYZ_ (XYZ, this)
    {
    }

    PointEntityType::
    PointEntityType (const PointEntityType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (x, f, c),
      XYZ_ (x.XYZ_, f, this)
    {
    }

    PointEntityType::
    PointEntityType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (e, f | ::xml_schema::flags::base, c),
      XYZ_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointEntityType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::GeometryBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XYZ
        //
        if (n.name () == L"XYZ" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XYZ_type > r (
            XYZ_traits::create (i, f, this));

          if (!XYZ_.present ())
          {
            this->XYZ_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!XYZ_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XYZ",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointEntityType* PointEntityType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointEntityType (*this, f, c);
    }

    PointEntityType& PointEntityType::
    operator= (const PointEntityType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::GeometryBaseType& > (*this) = x;
        this->XYZ_ = x.XYZ_;
      }

      return *this;
    }

    PointEntityType::
    ~PointEntityType ()
    {
    }

    // Curve12SetType
    //

    Curve12SetType::
    Curve12SetType ()
    : ::xml_schema::type (),
      Curve12_ (this),
      n_ (this)
    {
    }

    Curve12SetType::
    Curve12SetType (const n_type& n)
    : ::xml_schema::type (),
      Curve12_ (this),
      n_ (n, this)
    {
    }

    Curve12SetType::
    Curve12SetType (const Curve12SetType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Curve12_ (x.Curve12_, f, this),
      n_ (x.n_, f, this)
    {
    }

    Curve12SetType::
    Curve12SetType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Curve12_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Curve12SetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Curve12
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Curve12",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< Curve12_type > r (
              dynamic_cast< Curve12_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Curve12_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    Curve12SetType* Curve12SetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Curve12SetType (*this, f, c);
    }

    Curve12SetType& Curve12SetType::
    operator= (const Curve12SetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Curve12_ = x.Curve12_;
        this->n_ = x.n_;
      }

      return *this;
    }

    Curve12SetType::
    ~Curve12SetType ()
    {
    }

    // Curve13SetType
    //

    Curve13SetType::
    Curve13SetType ()
    : ::xml_schema::type (),
      Curve13_ (this),
      n_ (this)
    {
    }

    Curve13SetType::
    Curve13SetType (const n_type& n)
    : ::xml_schema::type (),
      Curve13_ (this),
      n_ (n, this)
    {
    }

    Curve13SetType::
    Curve13SetType (const Curve13SetType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Curve13_ (x.Curve13_, f, this),
      n_ (x.n_, f, this)
    {
    }

    Curve13SetType::
    Curve13SetType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Curve13_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Curve13SetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Curve13
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Curve13",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< Curve13_type > r (
              dynamic_cast< Curve13_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Curve13_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    Curve13SetType* Curve13SetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Curve13SetType (*this, f, c);
    }

    Curve13SetType& Curve13SetType::
    operator= (const Curve13SetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Curve13_ = x.Curve13_;
        this->n_ = x.n_;
      }

      return *this;
    }

    Curve13SetType::
    ~Curve13SetType ()
    {
    }

    // Curve13CoreType
    //

    Curve13CoreType::
    Curve13CoreType ()
    : ::xml_schema::type (),
      Curve13Core_ (this)
    {
    }

    Curve13CoreType::
    Curve13CoreType (const Curve13Core_type& Curve13Core)
    : ::xml_schema::type (),
      Curve13Core_ (Curve13Core, this)
    {
    }

    Curve13CoreType::
    Curve13CoreType (::std::unique_ptr< Curve13Core_type > Curve13Core)
    : ::xml_schema::type (),
      Curve13Core_ (std::move (Curve13Core), this)
    {
    }

    Curve13CoreType::
    Curve13CoreType (const Curve13CoreType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Curve13Core_ (x.Curve13Core_, f, this)
    {
    }

    Curve13CoreType::
    Curve13CoreType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Curve13Core_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Curve13CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Curve13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Curve13Core",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Curve13Core_.present ())
            {
              ::std::unique_ptr< Curve13Core_type > r (
                dynamic_cast< Curve13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Curve13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Curve13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Curve13Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Curve13CoreType* Curve13CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Curve13CoreType (*this, f, c);
    }

    Curve13CoreType& Curve13CoreType::
    operator= (const Curve13CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Curve13Core_ = x.Curve13Core_;
      }

      return *this;
    }

    Curve13CoreType::
    ~Curve13CoreType ()
    {
    }

    // CurveCoreBaseType
    //

    CurveCoreBaseType::
    CurveCoreBaseType ()
    : ::xml_schema::type (),
      domain_ (this)
    {
    }

    CurveCoreBaseType::
    CurveCoreBaseType (const domain_type& domain)
    : ::xml_schema::type (),
      domain_ (domain, this)
    {
    }

    CurveCoreBaseType::
    CurveCoreBaseType (const CurveCoreBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      domain_ (x.domain_, f, this)
    {
    }

    CurveCoreBaseType::
    CurveCoreBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      domain_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void CurveCoreBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"domain" && n.namespace_ ().empty ())
        {
          this->domain_.set (domain_traits::create (i, f, this));
          continue;
        }
      }

      if (!domain_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"domain",
          L"");
      }
    }

    CurveCoreBaseType& CurveCoreBaseType::
    operator= (const CurveCoreBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->domain_ = x.domain_;
      }

      return *this;
    }

    CurveCoreBaseType::
    ~CurveCoreBaseType ()
    {
    }

    // Curve12BaseType
    //

    Curve12BaseType::
    Curve12BaseType ()
    : ::xsd::qif30::GeometryBaseType ()
    {
    }

    Curve12BaseType::
    Curve12BaseType (const id_type& id)
    : ::xsd::qif30::GeometryBaseType (id)
    {
    }

    Curve12BaseType::
    Curve12BaseType (const Curve12BaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (x, f, c)
    {
    }

    Curve12BaseType::
    Curve12BaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (e, f, c)
    {
    }

    Curve12BaseType::
    ~Curve12BaseType ()
    {
    }

    // Curve13BaseType
    //

    Curve13BaseType::
    Curve13BaseType ()
    : ::xsd::qif30::GeometryBaseType ()
    {
    }

    Curve13BaseType::
    Curve13BaseType (const id_type& id)
    : ::xsd::qif30::GeometryBaseType (id)
    {
    }

    Curve13BaseType::
    Curve13BaseType (const Curve13BaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (x, f, c)
    {
    }

    Curve13BaseType::
    Curve13BaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (e, f, c)
    {
    }

    Curve13BaseType::
    ~Curve13BaseType ()
    {
    }

    // Segment13CoreType
    //

    Segment13CoreType::
    Segment13CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      StartPoint_ (this),
      EndPoint_ (this)
    {
    }

    Segment13CoreType::
    Segment13CoreType (const domain_type& domain,
                       const StartPoint_type& StartPoint,
                       const EndPoint_type& EndPoint)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      StartPoint_ (StartPoint, this),
      EndPoint_ (EndPoint, this)
    {
    }

    Segment13CoreType::
    Segment13CoreType (const Segment13CoreType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      EndPoint_ (x.EndPoint_, f, this)
    {
    }

    Segment13CoreType::
    Segment13CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (this),
      EndPoint_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Segment13CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StartPoint
        //
        if (n.name () == L"StartPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (::std::move (r));
            continue;
          }
        }

        // EndPoint
        //
        if (n.name () == L"EndPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndPoint_type > r (
            EndPoint_traits::create (i, f, this));

          if (!EndPoint_.present ())
          {
            this->EndPoint_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StartPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!EndPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndPoint",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Segment13CoreType* Segment13CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Segment13CoreType (*this, f, c);
    }

    Segment13CoreType& Segment13CoreType::
    operator= (const Segment13CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->StartPoint_ = x.StartPoint_;
        this->EndPoint_ = x.EndPoint_;
      }

      return *this;
    }

    Segment13CoreType::
    ~Segment13CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Segment13CoreType >
    _xsd_Segment13CoreType_type_factory_init (
      L"Segment13CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Segment12CoreType
    //

    Segment12CoreType::
    Segment12CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      StartPoint_ (this),
      EndPoint_ (this)
    {
    }

    Segment12CoreType::
    Segment12CoreType (const domain_type& domain,
                       const StartPoint_type& StartPoint,
                       const EndPoint_type& EndPoint)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      StartPoint_ (StartPoint, this),
      EndPoint_ (EndPoint, this)
    {
    }

    Segment12CoreType::
    Segment12CoreType (const Segment12CoreType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      EndPoint_ (x.EndPoint_, f, this)
    {
    }

    Segment12CoreType::
    Segment12CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (this),
      EndPoint_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Segment12CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StartPoint
        //
        if (n.name () == L"StartPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (::std::move (r));
            continue;
          }
        }

        // EndPoint
        //
        if (n.name () == L"EndPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndPoint_type > r (
            EndPoint_traits::create (i, f, this));

          if (!EndPoint_.present ())
          {
            this->EndPoint_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StartPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!EndPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndPoint",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Segment12CoreType* Segment12CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Segment12CoreType (*this, f, c);
    }

    Segment12CoreType& Segment12CoreType::
    operator= (const Segment12CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->StartPoint_ = x.StartPoint_;
        this->EndPoint_ = x.EndPoint_;
      }

      return *this;
    }

    Segment12CoreType::
    ~Segment12CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Segment12CoreType >
    _xsd_Segment12CoreType_type_factory_init (
      L"Segment12CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Segment13Type
    //

    Segment13Type::
    Segment13Type ()
    : ::xsd::qif30::Curve13BaseType (),
      Segment13Core_ (this),
      Transform_ (this)
    {
    }

    Segment13Type::
    Segment13Type (const id_type& id,
                   const Segment13Core_type& Segment13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Segment13Core_ (Segment13Core, this),
      Transform_ (this)
    {
    }

    Segment13Type::
    Segment13Type (const id_type& id,
                   ::std::unique_ptr< Segment13Core_type > Segment13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Segment13Core_ (std::move (Segment13Core), this),
      Transform_ (this)
    {
    }

    Segment13Type::
    Segment13Type (const Segment13Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (x, f, c),
      Segment13Core_ (x.Segment13Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Segment13Type::
    Segment13Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (e, f | ::xml_schema::flags::base, c),
      Segment13Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Segment13Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve13BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Segment13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Segment13Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Segment13Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Segment13Core_.present ())
            {
              ::std::unique_ptr< Segment13Core_type > r (
                dynamic_cast< Segment13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Segment13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Segment13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Segment13Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Segment13Type* Segment13Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Segment13Type (*this, f, c);
    }

    Segment13Type& Segment13Type::
    operator= (const Segment13Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve13BaseType& > (*this) = x;
        this->Segment13Core_ = x.Segment13Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Segment13Type::
    ~Segment13Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Segment13Type >
    _xsd_Segment13Type_type_factory_init (
      L"Segment13Type",
      L"http://qifstandards.org/xsd/qif3");

    // Segment12Type
    //

    Segment12Type::
    Segment12Type ()
    : ::xsd::qif30::Curve12BaseType (),
      Segment12Core_ (this)
    {
    }

    Segment12Type::
    Segment12Type (const id_type& id,
                   const Segment12Core_type& Segment12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Segment12Core_ (Segment12Core, this)
    {
    }

    Segment12Type::
    Segment12Type (const id_type& id,
                   ::std::unique_ptr< Segment12Core_type > Segment12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Segment12Core_ (std::move (Segment12Core), this)
    {
    }

    Segment12Type::
    Segment12Type (const Segment12Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (x, f, c),
      Segment12Core_ (x.Segment12Core_, f, this)
    {
    }

    Segment12Type::
    Segment12Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (e, f | ::xml_schema::flags::base, c),
      Segment12Core_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Segment12Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve12BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Segment12Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Segment12Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Segment12Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Segment12Core_.present ())
            {
              ::std::unique_ptr< Segment12Core_type > r (
                dynamic_cast< Segment12Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Segment12Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Segment12Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Segment12Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Segment12Type* Segment12Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Segment12Type (*this, f, c);
    }

    Segment12Type& Segment12Type::
    operator= (const Segment12Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve12BaseType& > (*this) = x;
        this->Segment12Core_ = x.Segment12Core_;
      }

      return *this;
    }

    Segment12Type::
    ~Segment12Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Segment12Type >
    _xsd_Segment12Type_type_factory_init (
      L"Segment12Type",
      L"http://qifstandards.org/xsd/qif3");

    // ArcConicFormEnumType
    //

    ArcConicFormEnumType::
    ArcConicFormEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ArcConicFormEnumType_convert ();
    }

    ArcConicFormEnumType::
    ArcConicFormEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ArcConicFormEnumType_convert ();
    }

    ArcConicFormEnumType::
    ArcConicFormEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ArcConicFormEnumType_convert ();
    }

    ArcConicFormEnumType* ArcConicFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcConicFormEnumType (*this, f, c);
    }

    ArcConicFormEnumType::value ArcConicFormEnumType::
    _xsd_ArcConicFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ArcConicFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ArcConicFormEnumType_indexes_,
                        _xsd_ArcConicFormEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ArcConicFormEnumType_indexes_ + 3 || _xsd_ArcConicFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ArcConicFormEnumType::
    _xsd_ArcConicFormEnumType_literals_[3] =
    {
      L"PARABOLA",
      L"ELLIPSE",
      L"HYPERBOLA"
    };

    const ArcConicFormEnumType::value ArcConicFormEnumType::
    _xsd_ArcConicFormEnumType_indexes_[3] =
    {
      ::xsd::qif30::ArcConicFormEnumType::ELLIPSE,
      ::xsd::qif30::ArcConicFormEnumType::HYPERBOLA,
      ::xsd::qif30::ArcConicFormEnumType::PARABOLA
    };

    // ArcConic13CoreType
    //

    ArcConic13CoreType::
    ArcConic13CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      A_ (this),
      B_ (this),
      Center_ (this),
      DirBeg_ (this),
      Normal_ (this),
      form_ (this)
    {
    }

    ArcConic13CoreType::
    ArcConic13CoreType (const domain_type& domain,
                        const A_type& A,
                        const B_type& B,
                        const Center_type& Center,
                        const DirBeg_type& DirBeg,
                        const Normal_type& Normal,
                        const form_type& form)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      A_ (A, this),
      B_ (B, this),
      Center_ (Center, this),
      DirBeg_ (DirBeg, this),
      Normal_ (Normal, this),
      form_ (form, this)
    {
    }

    ArcConic13CoreType::
    ArcConic13CoreType (const ArcConic13CoreType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      A_ (x.A_, f, this),
      B_ (x.B_, f, this),
      Center_ (x.Center_, f, this),
      DirBeg_ (x.DirBeg_, f, this),
      Normal_ (x.Normal_, f, this),
      form_ (x.form_, f, this)
    {
    }

    ArcConic13CoreType::
    ArcConic13CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      A_ (this),
      B_ (this),
      Center_ (this),
      DirBeg_ (this),
      Normal_ (this),
      form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcConic13CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // A
        //
        if (n.name () == L"A" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!A_.present ())
          {
            this->A_.set (A_traits::create (i, f, this));
            continue;
          }
        }

        // B
        //
        if (n.name () == L"B" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!B_.present ())
          {
            this->B_.set (B_traits::create (i, f, this));
            continue;
          }
        }

        // Center
        //
        if (n.name () == L"Center" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Center_type > r (
            Center_traits::create (i, f, this));

          if (!Center_.present ())
          {
            this->Center_.set (::std::move (r));
            continue;
          }
        }

        // DirBeg
        //
        if (n.name () == L"DirBeg" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirBeg_type > r (
            DirBeg_traits::create (i, f, this));

          if (!DirBeg_.present ())
          {
            this->DirBeg_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!A_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"A",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!B_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"B",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Center",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DirBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirBeg",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }
      }

      if (!form_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"form",
          L"");
      }
    }

    ArcConic13CoreType* ArcConic13CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcConic13CoreType (*this, f, c);
    }

    ArcConic13CoreType& ArcConic13CoreType::
    operator= (const ArcConic13CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->A_ = x.A_;
        this->B_ = x.B_;
        this->Center_ = x.Center_;
        this->DirBeg_ = x.DirBeg_;
        this->Normal_ = x.Normal_;
        this->form_ = x.form_;
      }

      return *this;
    }

    ArcConic13CoreType::
    ~ArcConic13CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArcConic13CoreType >
    _xsd_ArcConic13CoreType_type_factory_init (
      L"ArcConic13CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // ArcConic12CoreType
    //

    ArcConic12CoreType::
    ArcConic12CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      A_ (this),
      B_ (this),
      Center_ (this),
      DirBeg_ (this),
      form_ (this),
      turned_ (turned_default_value (), this)
    {
    }

    ArcConic12CoreType::
    ArcConic12CoreType (const domain_type& domain,
                        const A_type& A,
                        const B_type& B,
                        const Center_type& Center,
                        const DirBeg_type& DirBeg,
                        const form_type& form)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      A_ (A, this),
      B_ (B, this),
      Center_ (Center, this),
      DirBeg_ (DirBeg, this),
      form_ (form, this),
      turned_ (turned_default_value (), this)
    {
    }

    ArcConic12CoreType::
    ArcConic12CoreType (const ArcConic12CoreType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      A_ (x.A_, f, this),
      B_ (x.B_, f, this),
      Center_ (x.Center_, f, this),
      DirBeg_ (x.DirBeg_, f, this),
      form_ (x.form_, f, this),
      turned_ (x.turned_, f, this)
    {
    }

    ArcConic12CoreType::
    ArcConic12CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      A_ (this),
      B_ (this),
      Center_ (this),
      DirBeg_ (this),
      form_ (this),
      turned_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcConic12CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // A
        //
        if (n.name () == L"A" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!A_.present ())
          {
            this->A_.set (A_traits::create (i, f, this));
            continue;
          }
        }

        // B
        //
        if (n.name () == L"B" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!B_.present ())
          {
            this->B_.set (B_traits::create (i, f, this));
            continue;
          }
        }

        // Center
        //
        if (n.name () == L"Center" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Center_type > r (
            Center_traits::create (i, f, this));

          if (!Center_.present ())
          {
            this->Center_.set (::std::move (r));
            continue;
          }
        }

        // DirBeg
        //
        if (n.name () == L"DirBeg" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirBeg_type > r (
            DirBeg_traits::create (i, f, this));

          if (!DirBeg_.present ())
          {
            this->DirBeg_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!A_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"A",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!B_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"B",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Center",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DirBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirBeg",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }
      }

      if (!form_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"form",
          L"");
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    ArcConic12CoreType* ArcConic12CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcConic12CoreType (*this, f, c);
    }

    ArcConic12CoreType& ArcConic12CoreType::
    operator= (const ArcConic12CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->A_ = x.A_;
        this->B_ = x.B_;
        this->Center_ = x.Center_;
        this->DirBeg_ = x.DirBeg_;
        this->form_ = x.form_;
        this->turned_ = x.turned_;
      }

      return *this;
    }

    ArcConic12CoreType::
    ~ArcConic12CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArcConic12CoreType >
    _xsd_ArcConic12CoreType_type_factory_init (
      L"ArcConic12CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // ArcConic12Type
    //

    ArcConic12Type::
    ArcConic12Type ()
    : ::xsd::qif30::Curve12BaseType (),
      ArcConic12Core_ (this)
    {
    }

    ArcConic12Type::
    ArcConic12Type (const id_type& id,
                    const ArcConic12Core_type& ArcConic12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      ArcConic12Core_ (ArcConic12Core, this)
    {
    }

    ArcConic12Type::
    ArcConic12Type (const id_type& id,
                    ::std::unique_ptr< ArcConic12Core_type > ArcConic12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      ArcConic12Core_ (std::move (ArcConic12Core), this)
    {
    }

    ArcConic12Type::
    ArcConic12Type (const ArcConic12Type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (x, f, c),
      ArcConic12Core_ (x.ArcConic12Core_, f, this)
    {
    }

    ArcConic12Type::
    ArcConic12Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (e, f | ::xml_schema::flags::base, c),
      ArcConic12Core_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcConic12Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve12BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArcConic12Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArcConic12Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< ArcConic12Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArcConic12Core_.present ())
            {
              ::std::unique_ptr< ArcConic12Core_type > r (
                dynamic_cast< ArcConic12Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->ArcConic12Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!ArcConic12Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ArcConic12Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ArcConic12Type* ArcConic12Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcConic12Type (*this, f, c);
    }

    ArcConic12Type& ArcConic12Type::
    operator= (const ArcConic12Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve12BaseType& > (*this) = x;
        this->ArcConic12Core_ = x.ArcConic12Core_;
      }

      return *this;
    }

    ArcConic12Type::
    ~ArcConic12Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArcConic12Type >
    _xsd_ArcConic12Type_type_factory_init (
      L"ArcConic12Type",
      L"http://qifstandards.org/xsd/qif3");

    // ArcConic13Type
    //

    ArcConic13Type::
    ArcConic13Type ()
    : ::xsd::qif30::Curve13BaseType (),
      ArcConic13Core_ (this),
      Transform_ (this)
    {
    }

    ArcConic13Type::
    ArcConic13Type (const id_type& id,
                    const ArcConic13Core_type& ArcConic13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      ArcConic13Core_ (ArcConic13Core, this),
      Transform_ (this)
    {
    }

    ArcConic13Type::
    ArcConic13Type (const id_type& id,
                    ::std::unique_ptr< ArcConic13Core_type > ArcConic13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      ArcConic13Core_ (std::move (ArcConic13Core), this),
      Transform_ (this)
    {
    }

    ArcConic13Type::
    ArcConic13Type (const ArcConic13Type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (x, f, c),
      ArcConic13Core_ (x.ArcConic13Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ArcConic13Type::
    ArcConic13Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (e, f | ::xml_schema::flags::base, c),
      ArcConic13Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcConic13Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve13BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArcConic13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArcConic13Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< ArcConic13Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArcConic13Core_.present ())
            {
              ::std::unique_ptr< ArcConic13Core_type > r (
                dynamic_cast< ArcConic13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->ArcConic13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ArcConic13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ArcConic13Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ArcConic13Type* ArcConic13Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcConic13Type (*this, f, c);
    }

    ArcConic13Type& ArcConic13Type::
    operator= (const ArcConic13Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve13BaseType& > (*this) = x;
        this->ArcConic13Core_ = x.ArcConic13Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ArcConic13Type::
    ~ArcConic13Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArcConic13Type >
    _xsd_ArcConic13Type_type_factory_init (
      L"ArcConic13Type",
      L"http://qifstandards.org/xsd/qif3");

    // ArcCircular13CoreType
    //

    ArcCircular13CoreType::
    ArcCircular13CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      Radius_ (this),
      Center_ (this),
      DirBeg_ (this),
      Normal_ (this)
    {
    }

    ArcCircular13CoreType::
    ArcCircular13CoreType (const domain_type& domain,
                           const Radius_type& Radius,
                           const Center_type& Center,
                           const DirBeg_type& DirBeg,
                           const Normal_type& Normal)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Radius_ (Radius, this),
      Center_ (Center, this),
      DirBeg_ (DirBeg, this),
      Normal_ (Normal, this)
    {
    }

    ArcCircular13CoreType::
    ArcCircular13CoreType (const ArcCircular13CoreType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      Radius_ (x.Radius_, f, this),
      Center_ (x.Center_, f, this),
      DirBeg_ (x.DirBeg_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    ArcCircular13CoreType::
    ArcCircular13CoreType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Radius_ (this),
      Center_ (this),
      DirBeg_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcCircular13CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Radius
        //
        if (n.name () == L"Radius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Radius_.present ())
          {
            this->Radius_.set (Radius_traits::create (i, f, this));
            continue;
          }
        }

        // Center
        //
        if (n.name () == L"Center" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Center_type > r (
            Center_traits::create (i, f, this));

          if (!Center_.present ())
          {
            this->Center_.set (::std::move (r));
            continue;
          }
        }

        // DirBeg
        //
        if (n.name () == L"DirBeg" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirBeg_type > r (
            DirBeg_traits::create (i, f, this));

          if (!DirBeg_.present ())
          {
            this->DirBeg_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Radius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Radius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Center",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DirBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirBeg",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ArcCircular13CoreType* ArcCircular13CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCircular13CoreType (*this, f, c);
    }

    ArcCircular13CoreType& ArcCircular13CoreType::
    operator= (const ArcCircular13CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->Radius_ = x.Radius_;
        this->Center_ = x.Center_;
        this->DirBeg_ = x.DirBeg_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    ArcCircular13CoreType::
    ~ArcCircular13CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArcCircular13CoreType >
    _xsd_ArcCircular13CoreType_type_factory_init (
      L"ArcCircular13CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // ArcCircular12CoreType
    //

    ArcCircular12CoreType::
    ArcCircular12CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      Radius_ (this),
      Center_ (this),
      DirBeg_ (this),
      turned_ (turned_default_value (), this)
    {
    }

    ArcCircular12CoreType::
    ArcCircular12CoreType (const domain_type& domain,
                           const Radius_type& Radius,
                           const Center_type& Center,
                           const DirBeg_type& DirBeg)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Radius_ (Radius, this),
      Center_ (Center, this),
      DirBeg_ (DirBeg, this),
      turned_ (turned_default_value (), this)
    {
    }

    ArcCircular12CoreType::
    ArcCircular12CoreType (const ArcCircular12CoreType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      Radius_ (x.Radius_, f, this),
      Center_ (x.Center_, f, this),
      DirBeg_ (x.DirBeg_, f, this),
      turned_ (x.turned_, f, this)
    {
    }

    ArcCircular12CoreType::
    ArcCircular12CoreType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Radius_ (this),
      Center_ (this),
      DirBeg_ (this),
      turned_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcCircular12CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Radius
        //
        if (n.name () == L"Radius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Radius_.present ())
          {
            this->Radius_.set (Radius_traits::create (i, f, this));
            continue;
          }
        }

        // Center
        //
        if (n.name () == L"Center" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Center_type > r (
            Center_traits::create (i, f, this));

          if (!Center_.present ())
          {
            this->Center_.set (::std::move (r));
            continue;
          }
        }

        // DirBeg
        //
        if (n.name () == L"DirBeg" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirBeg_type > r (
            DirBeg_traits::create (i, f, this));

          if (!DirBeg_.present ())
          {
            this->DirBeg_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Radius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Radius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Center",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DirBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirBeg",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    ArcCircular12CoreType* ArcCircular12CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCircular12CoreType (*this, f, c);
    }

    ArcCircular12CoreType& ArcCircular12CoreType::
    operator= (const ArcCircular12CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->Radius_ = x.Radius_;
        this->Center_ = x.Center_;
        this->DirBeg_ = x.DirBeg_;
        this->turned_ = x.turned_;
      }

      return *this;
    }

    ArcCircular12CoreType::
    ~ArcCircular12CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArcCircular12CoreType >
    _xsd_ArcCircular12CoreType_type_factory_init (
      L"ArcCircular12CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // ArcCircular13Type
    //

    ArcCircular13Type::
    ArcCircular13Type ()
    : ::xsd::qif30::Curve13BaseType (),
      ArcCircular13Core_ (this),
      Transform_ (this)
    {
    }

    ArcCircular13Type::
    ArcCircular13Type (const id_type& id,
                       const ArcCircular13Core_type& ArcCircular13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      ArcCircular13Core_ (ArcCircular13Core, this),
      Transform_ (this)
    {
    }

    ArcCircular13Type::
    ArcCircular13Type (const id_type& id,
                       ::std::unique_ptr< ArcCircular13Core_type > ArcCircular13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      ArcCircular13Core_ (std::move (ArcCircular13Core), this),
      Transform_ (this)
    {
    }

    ArcCircular13Type::
    ArcCircular13Type (const ArcCircular13Type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (x, f, c),
      ArcCircular13Core_ (x.ArcCircular13Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ArcCircular13Type::
    ArcCircular13Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (e, f | ::xml_schema::flags::base, c),
      ArcCircular13Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcCircular13Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve13BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArcCircular13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArcCircular13Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< ArcCircular13Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArcCircular13Core_.present ())
            {
              ::std::unique_ptr< ArcCircular13Core_type > r (
                dynamic_cast< ArcCircular13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->ArcCircular13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ArcCircular13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ArcCircular13Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ArcCircular13Type* ArcCircular13Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCircular13Type (*this, f, c);
    }

    ArcCircular13Type& ArcCircular13Type::
    operator= (const ArcCircular13Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve13BaseType& > (*this) = x;
        this->ArcCircular13Core_ = x.ArcCircular13Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ArcCircular13Type::
    ~ArcCircular13Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArcCircular13Type >
    _xsd_ArcCircular13Type_type_factory_init (
      L"ArcCircular13Type",
      L"http://qifstandards.org/xsd/qif3");

    // ArcCircular12Type
    //

    ArcCircular12Type::
    ArcCircular12Type ()
    : ::xsd::qif30::Curve12BaseType (),
      ArcCircular12Core_ (this)
    {
    }

    ArcCircular12Type::
    ArcCircular12Type (const id_type& id,
                       const ArcCircular12Core_type& ArcCircular12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      ArcCircular12Core_ (ArcCircular12Core, this)
    {
    }

    ArcCircular12Type::
    ArcCircular12Type (const id_type& id,
                       ::std::unique_ptr< ArcCircular12Core_type > ArcCircular12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      ArcCircular12Core_ (std::move (ArcCircular12Core), this)
    {
    }

    ArcCircular12Type::
    ArcCircular12Type (const ArcCircular12Type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (x, f, c),
      ArcCircular12Core_ (x.ArcCircular12Core_, f, this)
    {
    }

    ArcCircular12Type::
    ArcCircular12Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (e, f | ::xml_schema::flags::base, c),
      ArcCircular12Core_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcCircular12Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve12BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArcCircular12Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArcCircular12Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< ArcCircular12Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArcCircular12Core_.present ())
            {
              ::std::unique_ptr< ArcCircular12Core_type > r (
                dynamic_cast< ArcCircular12Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->ArcCircular12Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!ArcCircular12Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ArcCircular12Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ArcCircular12Type* ArcCircular12Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCircular12Type (*this, f, c);
    }

    ArcCircular12Type& ArcCircular12Type::
    operator= (const ArcCircular12Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve12BaseType& > (*this) = x;
        this->ArcCircular12Core_ = x.ArcCircular12Core_;
      }

      return *this;
    }

    ArcCircular12Type::
    ~ArcCircular12Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArcCircular12Type >
    _xsd_ArcCircular12Type_type_factory_init (
      L"ArcCircular12Type",
      L"http://qifstandards.org/xsd/qif3");

    // Nurbs12CoreType
    //

    Nurbs12CoreType::
    Nurbs12CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      Order_ (this),
      Knots_ (this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs12CoreType::
    Nurbs12CoreType (const domain_type& domain,
                     const Order_type& Order,
                     const Knots_type& Knots)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Order_ (Order, this),
      Knots_ (Knots, this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs12CoreType::
    Nurbs12CoreType (const domain_type& domain,
                     const Order_type& Order,
                     ::std::unique_ptr< Knots_type > Knots)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Order_ (Order, this),
      Knots_ (std::move (Knots), this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs12CoreType::
    Nurbs12CoreType (const Nurbs12CoreType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      Order_ (x.Order_, f, this),
      Knots_ (x.Knots_, f, this),
      CPs_ (x.CPs_, f, this),
      CPsBinary_ (x.CPsBinary_, f, this),
      Weights_ (x.Weights_, f, this)
    {
    }

    Nurbs12CoreType::
    Nurbs12CoreType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Order_ (this),
      Knots_ (this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Nurbs12CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Order
        //
        if (n.name () == L"Order" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Order_type > r (
            Order_traits::create (i, f, this));

          if (!Order_.present ())
          {
            this->Order_.set (::std::move (r));
            continue;
          }
        }

        // Knots
        //
        if (n.name () == L"Knots" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Knots_type > r (
            Knots_traits::create (i, f, this));

          if (!Knots_.present ())
          {
            this->Knots_.set (::std::move (r));
            continue;
          }
        }

        // CPs
        //
        if (n.name () == L"CPs" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CPs_type > r (
            CPs_traits::create (i, f, this));

          if (!this->CPs_)
          {
            this->CPs_.set (::std::move (r));
            continue;
          }
        }

        // CPsBinary
        //
        if (n.name () == L"CPsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CPsBinary_type > r (
            CPsBinary_traits::create (i, f, this));

          if (!this->CPsBinary_)
          {
            this->CPsBinary_.set (::std::move (r));
            continue;
          }
        }

        // Weights
        //
        if (n.name () == L"Weights" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Weights_type > r (
            Weights_traits::create (i, f, this));

          if (!this->Weights_)
          {
            this->Weights_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Order_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Order",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Knots_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Knots",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Nurbs12CoreType* Nurbs12CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Nurbs12CoreType (*this, f, c);
    }

    Nurbs12CoreType& Nurbs12CoreType::
    operator= (const Nurbs12CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->Order_ = x.Order_;
        this->Knots_ = x.Knots_;
        this->CPs_ = x.CPs_;
        this->CPsBinary_ = x.CPsBinary_;
        this->Weights_ = x.Weights_;
      }

      return *this;
    }

    Nurbs12CoreType::
    ~Nurbs12CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Nurbs12CoreType >
    _xsd_Nurbs12CoreType_type_factory_init (
      L"Nurbs12CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Nurbs13CoreType
    //

    Nurbs13CoreType::
    Nurbs13CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      Order_ (this),
      Knots_ (this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs13CoreType::
    Nurbs13CoreType (const domain_type& domain,
                     const Order_type& Order,
                     const Knots_type& Knots)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Order_ (Order, this),
      Knots_ (Knots, this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs13CoreType::
    Nurbs13CoreType (const domain_type& domain,
                     const Order_type& Order,
                     ::std::unique_ptr< Knots_type > Knots)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Order_ (Order, this),
      Knots_ (std::move (Knots), this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs13CoreType::
    Nurbs13CoreType (const Nurbs13CoreType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      Order_ (x.Order_, f, this),
      Knots_ (x.Knots_, f, this),
      CPs_ (x.CPs_, f, this),
      CPsBinary_ (x.CPsBinary_, f, this),
      Weights_ (x.Weights_, f, this)
    {
    }

    Nurbs13CoreType::
    Nurbs13CoreType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Order_ (this),
      Knots_ (this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Nurbs13CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Order
        //
        if (n.name () == L"Order" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Order_type > r (
            Order_traits::create (i, f, this));

          if (!Order_.present ())
          {
            this->Order_.set (::std::move (r));
            continue;
          }
        }

        // Knots
        //
        if (n.name () == L"Knots" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Knots_type > r (
            Knots_traits::create (i, f, this));

          if (!Knots_.present ())
          {
            this->Knots_.set (::std::move (r));
            continue;
          }
        }

        // CPs
        //
        if (n.name () == L"CPs" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CPs_type > r (
            CPs_traits::create (i, f, this));

          if (!this->CPs_)
          {
            this->CPs_.set (::std::move (r));
            continue;
          }
        }

        // CPsBinary
        //
        if (n.name () == L"CPsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CPsBinary_type > r (
            CPsBinary_traits::create (i, f, this));

          if (!this->CPsBinary_)
          {
            this->CPsBinary_.set (::std::move (r));
            continue;
          }
        }

        // Weights
        //
        if (n.name () == L"Weights" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Weights_type > r (
            Weights_traits::create (i, f, this));

          if (!this->Weights_)
          {
            this->Weights_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Order_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Order",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Knots_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Knots",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Nurbs13CoreType* Nurbs13CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Nurbs13CoreType (*this, f, c);
    }

    Nurbs13CoreType& Nurbs13CoreType::
    operator= (const Nurbs13CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->Order_ = x.Order_;
        this->Knots_ = x.Knots_;
        this->CPs_ = x.CPs_;
        this->CPsBinary_ = x.CPsBinary_;
        this->Weights_ = x.Weights_;
      }

      return *this;
    }

    Nurbs13CoreType::
    ~Nurbs13CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Nurbs13CoreType >
    _xsd_Nurbs13CoreType_type_factory_init (
      L"Nurbs13CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Nurbs12Type
    //

    Nurbs12Type::
    Nurbs12Type ()
    : ::xsd::qif30::Curve12BaseType (),
      Nurbs12Core_ (this)
    {
    }

    Nurbs12Type::
    Nurbs12Type (const id_type& id,
                 const Nurbs12Core_type& Nurbs12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Nurbs12Core_ (Nurbs12Core, this)
    {
    }

    Nurbs12Type::
    Nurbs12Type (const id_type& id,
                 ::std::unique_ptr< Nurbs12Core_type > Nurbs12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Nurbs12Core_ (std::move (Nurbs12Core), this)
    {
    }

    Nurbs12Type::
    Nurbs12Type (const Nurbs12Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (x, f, c),
      Nurbs12Core_ (x.Nurbs12Core_, f, this)
    {
    }

    Nurbs12Type::
    Nurbs12Type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (e, f | ::xml_schema::flags::base, c),
      Nurbs12Core_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Nurbs12Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve12BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Nurbs12Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Nurbs12Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Nurbs12Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Nurbs12Core_.present ())
            {
              ::std::unique_ptr< Nurbs12Core_type > r (
                dynamic_cast< Nurbs12Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Nurbs12Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Nurbs12Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Nurbs12Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Nurbs12Type* Nurbs12Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Nurbs12Type (*this, f, c);
    }

    Nurbs12Type& Nurbs12Type::
    operator= (const Nurbs12Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve12BaseType& > (*this) = x;
        this->Nurbs12Core_ = x.Nurbs12Core_;
      }

      return *this;
    }

    Nurbs12Type::
    ~Nurbs12Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Nurbs12Type >
    _xsd_Nurbs12Type_type_factory_init (
      L"Nurbs12Type",
      L"http://qifstandards.org/xsd/qif3");

    // Nurbs13Type
    //

    Nurbs13Type::
    Nurbs13Type ()
    : ::xsd::qif30::Curve13BaseType (),
      Nurbs13Core_ (this),
      Transform_ (this)
    {
    }

    Nurbs13Type::
    Nurbs13Type (const id_type& id,
                 const Nurbs13Core_type& Nurbs13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Nurbs13Core_ (Nurbs13Core, this),
      Transform_ (this)
    {
    }

    Nurbs13Type::
    Nurbs13Type (const id_type& id,
                 ::std::unique_ptr< Nurbs13Core_type > Nurbs13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Nurbs13Core_ (std::move (Nurbs13Core), this),
      Transform_ (this)
    {
    }

    Nurbs13Type::
    Nurbs13Type (const Nurbs13Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (x, f, c),
      Nurbs13Core_ (x.Nurbs13Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Nurbs13Type::
    Nurbs13Type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (e, f | ::xml_schema::flags::base, c),
      Nurbs13Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Nurbs13Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve13BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Nurbs13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Nurbs13Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Nurbs13Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Nurbs13Core_.present ())
            {
              ::std::unique_ptr< Nurbs13Core_type > r (
                dynamic_cast< Nurbs13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Nurbs13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Nurbs13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Nurbs13Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Nurbs13Type* Nurbs13Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Nurbs13Type (*this, f, c);
    }

    Nurbs13Type& Nurbs13Type::
    operator= (const Nurbs13Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve13BaseType& > (*this) = x;
        this->Nurbs13Core_ = x.Nurbs13Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Nurbs13Type::
    ~Nurbs13Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Nurbs13Type >
    _xsd_Nurbs13Type_type_factory_init (
      L"Nurbs13Type",
      L"http://qifstandards.org/xsd/qif3");

    // Spline13CoreType
    //

    Spline13CoreType::
    Spline13CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      Knots_ (this),
      Orders_ (this),
      Coefficients_ (this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline13CoreType::
    Spline13CoreType (const domain_type& domain,
                      const Knots_type& Knots,
                      const Orders_type& Orders,
                      const Coefficients_type& Coefficients)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Knots_ (Knots, this),
      Orders_ (Orders, this),
      Coefficients_ (Coefficients, this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline13CoreType::
    Spline13CoreType (const domain_type& domain,
                      ::std::unique_ptr< Knots_type > Knots,
                      ::std::unique_ptr< Orders_type > Orders,
                      ::std::unique_ptr< Coefficients_type > Coefficients)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Knots_ (std::move (Knots), this),
      Orders_ (std::move (Orders), this),
      Coefficients_ (std::move (Coefficients), this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline13CoreType::
    Spline13CoreType (const Spline13CoreType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      Knots_ (x.Knots_, f, this),
      Orders_ (x.Orders_, f, this),
      Coefficients_ (x.Coefficients_, f, this),
      normalized_ (x.normalized_, f, this)
    {
    }

    Spline13CoreType::
    Spline13CoreType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Knots_ (this),
      Orders_ (this),
      Coefficients_ (this),
      normalized_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Spline13CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Knots
        //
        if (n.name () == L"Knots" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Knots_type > r (
            Knots_traits::create (i, f, this));

          if (!Knots_.present ())
          {
            this->Knots_.set (::std::move (r));
            continue;
          }
        }

        // Orders
        //
        if (n.name () == L"Orders" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Orders_type > r (
            Orders_traits::create (i, f, this));

          if (!Orders_.present ())
          {
            this->Orders_.set (::std::move (r));
            continue;
          }
        }

        // Coefficients
        //
        if (n.name () == L"Coefficients" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Coefficients_type > r (
            Coefficients_traits::create (i, f, this));

          if (!Coefficients_.present ())
          {
            this->Coefficients_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Knots_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Knots",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Orders_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Orders",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Coefficients_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Coefficients",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"normalized" && n.namespace_ ().empty ())
        {
          this->normalized_.set (normalized_traits::create (i, f, this));
          continue;
        }
      }

      if (!normalized_.present ())
      {
        this->normalized_.set (normalized_default_value ());
      }
    }

    Spline13CoreType* Spline13CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Spline13CoreType (*this, f, c);
    }

    Spline13CoreType& Spline13CoreType::
    operator= (const Spline13CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->Knots_ = x.Knots_;
        this->Orders_ = x.Orders_;
        this->Coefficients_ = x.Coefficients_;
        this->normalized_ = x.normalized_;
      }

      return *this;
    }

    Spline13CoreType::
    ~Spline13CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Spline13CoreType >
    _xsd_Spline13CoreType_type_factory_init (
      L"Spline13CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Spline12CoreType
    //

    Spline12CoreType::
    Spline12CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      Knots_ (this),
      Orders_ (this),
      Coefficients_ (this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline12CoreType::
    Spline12CoreType (const domain_type& domain,
                      const Knots_type& Knots,
                      const Orders_type& Orders,
                      const Coefficients_type& Coefficients)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Knots_ (Knots, this),
      Orders_ (Orders, this),
      Coefficients_ (Coefficients, this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline12CoreType::
    Spline12CoreType (const domain_type& domain,
                      ::std::unique_ptr< Knots_type > Knots,
                      ::std::unique_ptr< Orders_type > Orders,
                      ::std::unique_ptr< Coefficients_type > Coefficients)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Knots_ (std::move (Knots), this),
      Orders_ (std::move (Orders), this),
      Coefficients_ (std::move (Coefficients), this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline12CoreType::
    Spline12CoreType (const Spline12CoreType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      Knots_ (x.Knots_, f, this),
      Orders_ (x.Orders_, f, this),
      Coefficients_ (x.Coefficients_, f, this),
      normalized_ (x.normalized_, f, this)
    {
    }

    Spline12CoreType::
    Spline12CoreType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Knots_ (this),
      Orders_ (this),
      Coefficients_ (this),
      normalized_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Spline12CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Knots
        //
        if (n.name () == L"Knots" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Knots_type > r (
            Knots_traits::create (i, f, this));

          if (!Knots_.present ())
          {
            this->Knots_.set (::std::move (r));
            continue;
          }
        }

        // Orders
        //
        if (n.name () == L"Orders" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Orders_type > r (
            Orders_traits::create (i, f, this));

          if (!Orders_.present ())
          {
            this->Orders_.set (::std::move (r));
            continue;
          }
        }

        // Coefficients
        //
        if (n.name () == L"Coefficients" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Coefficients_type > r (
            Coefficients_traits::create (i, f, this));

          if (!Coefficients_.present ())
          {
            this->Coefficients_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Knots_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Knots",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Orders_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Orders",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Coefficients_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Coefficients",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"normalized" && n.namespace_ ().empty ())
        {
          this->normalized_.set (normalized_traits::create (i, f, this));
          continue;
        }
      }

      if (!normalized_.present ())
      {
        this->normalized_.set (normalized_default_value ());
      }
    }

    Spline12CoreType* Spline12CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Spline12CoreType (*this, f, c);
    }

    Spline12CoreType& Spline12CoreType::
    operator= (const Spline12CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->Knots_ = x.Knots_;
        this->Orders_ = x.Orders_;
        this->Coefficients_ = x.Coefficients_;
        this->normalized_ = x.normalized_;
      }

      return *this;
    }

    Spline12CoreType::
    ~Spline12CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Spline12CoreType >
    _xsd_Spline12CoreType_type_factory_init (
      L"Spline12CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Spline13Type
    //

    Spline13Type::
    Spline13Type ()
    : ::xsd::qif30::Curve13BaseType (),
      Spline13Core_ (this),
      Transform_ (this)
    {
    }

    Spline13Type::
    Spline13Type (const id_type& id,
                  const Spline13Core_type& Spline13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Spline13Core_ (Spline13Core, this),
      Transform_ (this)
    {
    }

    Spline13Type::
    Spline13Type (const id_type& id,
                  ::std::unique_ptr< Spline13Core_type > Spline13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Spline13Core_ (std::move (Spline13Core), this),
      Transform_ (this)
    {
    }

    Spline13Type::
    Spline13Type (const Spline13Type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (x, f, c),
      Spline13Core_ (x.Spline13Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Spline13Type::
    Spline13Type (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (e, f | ::xml_schema::flags::base, c),
      Spline13Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Spline13Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve13BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Spline13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Spline13Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Spline13Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Spline13Core_.present ())
            {
              ::std::unique_ptr< Spline13Core_type > r (
                dynamic_cast< Spline13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Spline13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Spline13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Spline13Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Spline13Type* Spline13Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Spline13Type (*this, f, c);
    }

    Spline13Type& Spline13Type::
    operator= (const Spline13Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve13BaseType& > (*this) = x;
        this->Spline13Core_ = x.Spline13Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Spline13Type::
    ~Spline13Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Spline13Type >
    _xsd_Spline13Type_type_factory_init (
      L"Spline13Type",
      L"http://qifstandards.org/xsd/qif3");

    // Spline12Type
    //

    Spline12Type::
    Spline12Type ()
    : ::xsd::qif30::Curve12BaseType (),
      Spline12Core_ (this)
    {
    }

    Spline12Type::
    Spline12Type (const id_type& id,
                  const Spline12Core_type& Spline12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Spline12Core_ (Spline12Core, this)
    {
    }

    Spline12Type::
    Spline12Type (const id_type& id,
                  ::std::unique_ptr< Spline12Core_type > Spline12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Spline12Core_ (std::move (Spline12Core), this)
    {
    }

    Spline12Type::
    Spline12Type (const Spline12Type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (x, f, c),
      Spline12Core_ (x.Spline12Core_, f, this)
    {
    }

    Spline12Type::
    Spline12Type (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (e, f | ::xml_schema::flags::base, c),
      Spline12Core_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Spline12Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve12BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Spline12Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Spline12Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Spline12Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Spline12Core_.present ())
            {
              ::std::unique_ptr< Spline12Core_type > r (
                dynamic_cast< Spline12Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Spline12Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Spline12Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Spline12Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Spline12Type* Spline12Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Spline12Type (*this, f, c);
    }

    Spline12Type& Spline12Type::
    operator= (const Spline12Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve12BaseType& > (*this) = x;
        this->Spline12Core_ = x.Spline12Core_;
      }

      return *this;
    }

    Spline12Type::
    ~Spline12Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Spline12Type >
    _xsd_Spline12Type_type_factory_init (
      L"Spline12Type",
      L"http://qifstandards.org/xsd/qif3");

    // Curve12OrientedType
    //

    Curve12OrientedType::
    Curve12OrientedType ()
    : ::xml_schema::type (),
      Curve12Core_ (this),
      turned_ (turned_default_value (), this)
    {
    }

    Curve12OrientedType::
    Curve12OrientedType (const Curve12Core_type& Curve12Core)
    : ::xml_schema::type (),
      Curve12Core_ (Curve12Core, this),
      turned_ (turned_default_value (), this)
    {
    }

    Curve12OrientedType::
    Curve12OrientedType (::std::unique_ptr< Curve12Core_type > Curve12Core)
    : ::xml_schema::type (),
      Curve12Core_ (std::move (Curve12Core), this),
      turned_ (turned_default_value (), this)
    {
    }

    Curve12OrientedType::
    Curve12OrientedType (const Curve12OrientedType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Curve12Core_ (x.Curve12Core_, f, this),
      turned_ (x.turned_, f, this)
    {
    }

    Curve12OrientedType::
    Curve12OrientedType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Curve12Core_ (this),
      turned_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Curve12OrientedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Curve12Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Curve12Core",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Curve12Core_.present ())
            {
              ::std::unique_ptr< Curve12Core_type > r (
                dynamic_cast< Curve12Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Curve12Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Curve12Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Curve12Core",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    Curve12OrientedType* Curve12OrientedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Curve12OrientedType (*this, f, c);
    }

    Curve12OrientedType& Curve12OrientedType::
    operator= (const Curve12OrientedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Curve12Core_ = x.Curve12Core_;
        this->turned_ = x.turned_;
      }

      return *this;
    }

    Curve12OrientedType::
    ~Curve12OrientedType ()
    {
    }

    // ArraySubCurve12Type
    //

    ArraySubCurve12Type::
    ArraySubCurve12Type ()
    : ::xml_schema::type (),
      SubCurve_ (this),
      n_ (this)
    {
    }

    ArraySubCurve12Type::
    ArraySubCurve12Type (const n_type& n)
    : ::xml_schema::type (),
      SubCurve_ (this),
      n_ (n, this)
    {
    }

    ArraySubCurve12Type::
    ArraySubCurve12Type (const ArraySubCurve12Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SubCurve_ (x.SubCurve_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ArraySubCurve12Type::
    ArraySubCurve12Type (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SubCurve_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArraySubCurve12Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SubCurve
        //
        if (n.name () == L"SubCurve" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubCurve_type > r (
            SubCurve_traits::create (i, f, this));

          this->SubCurve_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ArraySubCurve12Type* ArraySubCurve12Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArraySubCurve12Type (*this, f, c);
    }

    ArraySubCurve12Type& ArraySubCurve12Type::
    operator= (const ArraySubCurve12Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SubCurve_ = x.SubCurve_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ArraySubCurve12Type::
    ~ArraySubCurve12Type ()
    {
    }

    // Aggregate12CoreType
    //

    Aggregate12CoreType::
    Aggregate12CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      SubCurves_ (this)
    {
    }

    Aggregate12CoreType::
    Aggregate12CoreType (const domain_type& domain,
                         const SubCurves_type& SubCurves)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      SubCurves_ (SubCurves, this)
    {
    }

    Aggregate12CoreType::
    Aggregate12CoreType (const domain_type& domain,
                         ::std::unique_ptr< SubCurves_type > SubCurves)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      SubCurves_ (std::move (SubCurves), this)
    {
    }

    Aggregate12CoreType::
    Aggregate12CoreType (const Aggregate12CoreType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      SubCurves_ (x.SubCurves_, f, this)
    {
    }

    Aggregate12CoreType::
    Aggregate12CoreType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      SubCurves_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Aggregate12CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SubCurves
        //
        if (n.name () == L"SubCurves" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubCurves_type > r (
            SubCurves_traits::create (i, f, this));

          if (!SubCurves_.present ())
          {
            this->SubCurves_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SubCurves_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SubCurves",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Aggregate12CoreType* Aggregate12CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Aggregate12CoreType (*this, f, c);
    }

    Aggregate12CoreType& Aggregate12CoreType::
    operator= (const Aggregate12CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->SubCurves_ = x.SubCurves_;
      }

      return *this;
    }

    Aggregate12CoreType::
    ~Aggregate12CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Aggregate12CoreType >
    _xsd_Aggregate12CoreType_type_factory_init (
      L"Aggregate12CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Curve13OrientedType
    //

    Curve13OrientedType::
    Curve13OrientedType ()
    : ::xml_schema::type (),
      Curve13Core_ (this),
      turned_ (turned_default_value (), this)
    {
    }

    Curve13OrientedType::
    Curve13OrientedType (const Curve13Core_type& Curve13Core)
    : ::xml_schema::type (),
      Curve13Core_ (Curve13Core, this),
      turned_ (turned_default_value (), this)
    {
    }

    Curve13OrientedType::
    Curve13OrientedType (::std::unique_ptr< Curve13Core_type > Curve13Core)
    : ::xml_schema::type (),
      Curve13Core_ (std::move (Curve13Core), this),
      turned_ (turned_default_value (), this)
    {
    }

    Curve13OrientedType::
    Curve13OrientedType (const Curve13OrientedType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Curve13Core_ (x.Curve13Core_, f, this),
      turned_ (x.turned_, f, this)
    {
    }

    Curve13OrientedType::
    Curve13OrientedType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Curve13Core_ (this),
      turned_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Curve13OrientedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Curve13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Curve13Core",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Curve13Core_.present ())
            {
              ::std::unique_ptr< Curve13Core_type > r (
                dynamic_cast< Curve13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Curve13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Curve13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Curve13Core",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    Curve13OrientedType* Curve13OrientedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Curve13OrientedType (*this, f, c);
    }

    Curve13OrientedType& Curve13OrientedType::
    operator= (const Curve13OrientedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Curve13Core_ = x.Curve13Core_;
        this->turned_ = x.turned_;
      }

      return *this;
    }

    Curve13OrientedType::
    ~Curve13OrientedType ()
    {
    }

    // ArraySubCurve13Type
    //

    ArraySubCurve13Type::
    ArraySubCurve13Type ()
    : ::xml_schema::type (),
      SubCurve_ (this),
      n_ (this)
    {
    }

    ArraySubCurve13Type::
    ArraySubCurve13Type (const n_type& n)
    : ::xml_schema::type (),
      SubCurve_ (this),
      n_ (n, this)
    {
    }

    ArraySubCurve13Type::
    ArraySubCurve13Type (const ArraySubCurve13Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SubCurve_ (x.SubCurve_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ArraySubCurve13Type::
    ArraySubCurve13Type (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SubCurve_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArraySubCurve13Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SubCurve
        //
        if (n.name () == L"SubCurve" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubCurve_type > r (
            SubCurve_traits::create (i, f, this));

          this->SubCurve_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ArraySubCurve13Type* ArraySubCurve13Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArraySubCurve13Type (*this, f, c);
    }

    ArraySubCurve13Type& ArraySubCurve13Type::
    operator= (const ArraySubCurve13Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SubCurve_ = x.SubCurve_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ArraySubCurve13Type::
    ~ArraySubCurve13Type ()
    {
    }

    // Aggregate13CoreType
    //

    Aggregate13CoreType::
    Aggregate13CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      SubCurves_ (this)
    {
    }

    Aggregate13CoreType::
    Aggregate13CoreType (const domain_type& domain,
                         const SubCurves_type& SubCurves)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      SubCurves_ (SubCurves, this)
    {
    }

    Aggregate13CoreType::
    Aggregate13CoreType (const domain_type& domain,
                         ::std::unique_ptr< SubCurves_type > SubCurves)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      SubCurves_ (std::move (SubCurves), this)
    {
    }

    Aggregate13CoreType::
    Aggregate13CoreType (const Aggregate13CoreType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      SubCurves_ (x.SubCurves_, f, this)
    {
    }

    Aggregate13CoreType::
    Aggregate13CoreType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      SubCurves_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Aggregate13CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SubCurves
        //
        if (n.name () == L"SubCurves" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubCurves_type > r (
            SubCurves_traits::create (i, f, this));

          if (!SubCurves_.present ())
          {
            this->SubCurves_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SubCurves_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SubCurves",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Aggregate13CoreType* Aggregate13CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Aggregate13CoreType (*this, f, c);
    }

    Aggregate13CoreType& Aggregate13CoreType::
    operator= (const Aggregate13CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->SubCurves_ = x.SubCurves_;
      }

      return *this;
    }

    Aggregate13CoreType::
    ~Aggregate13CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Aggregate13CoreType >
    _xsd_Aggregate13CoreType_type_factory_init (
      L"Aggregate13CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Aggregate12Type
    //

    Aggregate12Type::
    Aggregate12Type ()
    : ::xsd::qif30::Curve12BaseType (),
      Aggregate12Core_ (this)
    {
    }

    Aggregate12Type::
    Aggregate12Type (const id_type& id,
                     const Aggregate12Core_type& Aggregate12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Aggregate12Core_ (Aggregate12Core, this)
    {
    }

    Aggregate12Type::
    Aggregate12Type (const id_type& id,
                     ::std::unique_ptr< Aggregate12Core_type > Aggregate12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Aggregate12Core_ (std::move (Aggregate12Core), this)
    {
    }

    Aggregate12Type::
    Aggregate12Type (const Aggregate12Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (x, f, c),
      Aggregate12Core_ (x.Aggregate12Core_, f, this)
    {
    }

    Aggregate12Type::
    Aggregate12Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (e, f | ::xml_schema::flags::base, c),
      Aggregate12Core_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Aggregate12Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve12BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Aggregate12Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Aggregate12Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Aggregate12Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Aggregate12Core_.present ())
            {
              ::std::unique_ptr< Aggregate12Core_type > r (
                dynamic_cast< Aggregate12Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Aggregate12Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Aggregate12Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Aggregate12Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Aggregate12Type* Aggregate12Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Aggregate12Type (*this, f, c);
    }

    Aggregate12Type& Aggregate12Type::
    operator= (const Aggregate12Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve12BaseType& > (*this) = x;
        this->Aggregate12Core_ = x.Aggregate12Core_;
      }

      return *this;
    }

    Aggregate12Type::
    ~Aggregate12Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Aggregate12Type >
    _xsd_Aggregate12Type_type_factory_init (
      L"Aggregate12Type",
      L"http://qifstandards.org/xsd/qif3");

    // Aggregate13Type
    //

    Aggregate13Type::
    Aggregate13Type ()
    : ::xsd::qif30::Curve13BaseType (),
      Aggregate13Core_ (this),
      Transform_ (this)
    {
    }

    Aggregate13Type::
    Aggregate13Type (const id_type& id,
                     const Aggregate13Core_type& Aggregate13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Aggregate13Core_ (Aggregate13Core, this),
      Transform_ (this)
    {
    }

    Aggregate13Type::
    Aggregate13Type (const id_type& id,
                     ::std::unique_ptr< Aggregate13Core_type > Aggregate13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Aggregate13Core_ (std::move (Aggregate13Core), this),
      Transform_ (this)
    {
    }

    Aggregate13Type::
    Aggregate13Type (const Aggregate13Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (x, f, c),
      Aggregate13Core_ (x.Aggregate13Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Aggregate13Type::
    Aggregate13Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (e, f | ::xml_schema::flags::base, c),
      Aggregate13Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Aggregate13Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve13BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Aggregate13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Aggregate13Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Aggregate13Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Aggregate13Core_.present ())
            {
              ::std::unique_ptr< Aggregate13Core_type > r (
                dynamic_cast< Aggregate13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Aggregate13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Aggregate13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Aggregate13Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Aggregate13Type* Aggregate13Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Aggregate13Type (*this, f, c);
    }

    Aggregate13Type& Aggregate13Type::
    operator= (const Aggregate13Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve13BaseType& > (*this) = x;
        this->Aggregate13Core_ = x.Aggregate13Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Aggregate13Type::
    ~Aggregate13Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Aggregate13Type >
    _xsd_Aggregate13Type_type_factory_init (
      L"Aggregate13Type",
      L"http://qifstandards.org/xsd/qif3");

    // Polyline13CoreType
    //

    Polyline13CoreType::
    Polyline13CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      Points_ (this),
      PointsBinary_ (this)
    {
    }

    Polyline13CoreType::
    Polyline13CoreType (const domain_type& domain)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Points_ (this),
      PointsBinary_ (this)
    {
    }

    Polyline13CoreType::
    Polyline13CoreType (const Polyline13CoreType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      Points_ (x.Points_, f, this),
      PointsBinary_ (x.PointsBinary_, f, this)
    {
    }

    Polyline13CoreType::
    Polyline13CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Points_ (this),
      PointsBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Polyline13CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        // PointsBinary
        //
        if (n.name () == L"PointsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsBinary_type > r (
            PointsBinary_traits::create (i, f, this));

          if (!this->PointsBinary_)
          {
            this->PointsBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Polyline13CoreType* Polyline13CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Polyline13CoreType (*this, f, c);
    }

    Polyline13CoreType& Polyline13CoreType::
    operator= (const Polyline13CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->Points_ = x.Points_;
        this->PointsBinary_ = x.PointsBinary_;
      }

      return *this;
    }

    Polyline13CoreType::
    ~Polyline13CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Polyline13CoreType >
    _xsd_Polyline13CoreType_type_factory_init (
      L"Polyline13CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Polyline12CoreType
    //

    Polyline12CoreType::
    Polyline12CoreType ()
    : ::xsd::qif30::CurveCoreBaseType (),
      Points_ (this),
      PointsBinary_ (this)
    {
    }

    Polyline12CoreType::
    Polyline12CoreType (const domain_type& domain)
    : ::xsd::qif30::CurveCoreBaseType (domain),
      Points_ (this),
      PointsBinary_ (this)
    {
    }

    Polyline12CoreType::
    Polyline12CoreType (const Polyline12CoreType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (x, f, c),
      Points_ (x.Points_, f, this),
      PointsBinary_ (x.PointsBinary_, f, this)
    {
    }

    Polyline12CoreType::
    Polyline12CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Points_ (this),
      PointsBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Polyline12CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        // PointsBinary
        //
        if (n.name () == L"PointsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsBinary_type > r (
            PointsBinary_traits::create (i, f, this));

          if (!this->PointsBinary_)
          {
            this->PointsBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Polyline12CoreType* Polyline12CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Polyline12CoreType (*this, f, c);
    }

    Polyline12CoreType& Polyline12CoreType::
    operator= (const Polyline12CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveCoreBaseType& > (*this) = x;
        this->Points_ = x.Points_;
        this->PointsBinary_ = x.PointsBinary_;
      }

      return *this;
    }

    Polyline12CoreType::
    ~Polyline12CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Polyline12CoreType >
    _xsd_Polyline12CoreType_type_factory_init (
      L"Polyline12CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Polyline13Type
    //

    Polyline13Type::
    Polyline13Type ()
    : ::xsd::qif30::Curve13BaseType (),
      Polyline13Core_ (this),
      Transform_ (this)
    {
    }

    Polyline13Type::
    Polyline13Type (const id_type& id,
                    const Polyline13Core_type& Polyline13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Polyline13Core_ (Polyline13Core, this),
      Transform_ (this)
    {
    }

    Polyline13Type::
    Polyline13Type (const id_type& id,
                    ::std::unique_ptr< Polyline13Core_type > Polyline13Core)
    : ::xsd::qif30::Curve13BaseType (id),
      Polyline13Core_ (std::move (Polyline13Core), this),
      Transform_ (this)
    {
    }

    Polyline13Type::
    Polyline13Type (const Polyline13Type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (x, f, c),
      Polyline13Core_ (x.Polyline13Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Polyline13Type::
    Polyline13Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::Curve13BaseType (e, f | ::xml_schema::flags::base, c),
      Polyline13Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Polyline13Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve13BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Polyline13Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Polyline13Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Polyline13Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Polyline13Core_.present ())
            {
              ::std::unique_ptr< Polyline13Core_type > r (
                dynamic_cast< Polyline13Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Polyline13Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Polyline13Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Polyline13Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Polyline13Type* Polyline13Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Polyline13Type (*this, f, c);
    }

    Polyline13Type& Polyline13Type::
    operator= (const Polyline13Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve13BaseType& > (*this) = x;
        this->Polyline13Core_ = x.Polyline13Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Polyline13Type::
    ~Polyline13Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Polyline13Type >
    _xsd_Polyline13Type_type_factory_init (
      L"Polyline13Type",
      L"http://qifstandards.org/xsd/qif3");

    // Polyline12Type
    //

    Polyline12Type::
    Polyline12Type ()
    : ::xsd::qif30::Curve12BaseType (),
      Polyline12Core_ (this)
    {
    }

    Polyline12Type::
    Polyline12Type (const id_type& id,
                    const Polyline12Core_type& Polyline12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Polyline12Core_ (Polyline12Core, this)
    {
    }

    Polyline12Type::
    Polyline12Type (const id_type& id,
                    ::std::unique_ptr< Polyline12Core_type > Polyline12Core)
    : ::xsd::qif30::Curve12BaseType (id),
      Polyline12Core_ (std::move (Polyline12Core), this)
    {
    }

    Polyline12Type::
    Polyline12Type (const Polyline12Type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (x, f, c),
      Polyline12Core_ (x.Polyline12Core_, f, this)
    {
    }

    Polyline12Type::
    Polyline12Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::Curve12BaseType (e, f | ::xml_schema::flags::base, c),
      Polyline12Core_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Polyline12Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::Curve12BaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Polyline12Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Polyline12Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Polyline12Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Polyline12Core_.present ())
            {
              ::std::unique_ptr< Polyline12Core_type > r (
                dynamic_cast< Polyline12Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Polyline12Core_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Polyline12Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Polyline12Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Polyline12Type* Polyline12Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Polyline12Type (*this, f, c);
    }

    Polyline12Type& Polyline12Type::
    operator= (const Polyline12Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::Curve12BaseType& > (*this) = x;
        this->Polyline12Core_ = x.Polyline12Core_;
      }

      return *this;
    }

    Polyline12Type::
    ~Polyline12Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Polyline12Type >
    _xsd_Polyline12Type_type_factory_init (
      L"Polyline12Type",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceBaseType
    //

    SurfaceBaseType::
    SurfaceBaseType ()
    : ::xsd::qif30::GeometryBaseType ()
    {
    }

    SurfaceBaseType::
    SurfaceBaseType (const id_type& id)
    : ::xsd::qif30::GeometryBaseType (id)
    {
    }

    SurfaceBaseType::
    SurfaceBaseType (const SurfaceBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (x, f, c)
    {
    }

    SurfaceBaseType::
    SurfaceBaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (e, f, c)
    {
    }

    SurfaceBaseType::
    ~SurfaceBaseType ()
    {
    }

    // SurfaceSetType
    //

    SurfaceSetType::
    SurfaceSetType ()
    : ::xml_schema::type (),
      Surface_ (this),
      n_ (this)
    {
    }

    SurfaceSetType::
    SurfaceSetType (const n_type& n)
    : ::xml_schema::type (),
      Surface_ (this),
      n_ (n, this)
    {
    }

    SurfaceSetType::
    SurfaceSetType (const SurfaceSetType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Surface_ (x.Surface_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SurfaceSetType::
    SurfaceSetType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Surface_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Surface
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Surface",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< Surface_type > r (
              dynamic_cast< Surface_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Surface_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SurfaceSetType* SurfaceSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceSetType (*this, f, c);
    }

    SurfaceSetType& SurfaceSetType::
    operator= (const SurfaceSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Surface_ = x.Surface_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SurfaceSetType::
    ~SurfaceSetType ()
    {
    }

    // SurfaceCoreType
    //

    SurfaceCoreType::
    SurfaceCoreType ()
    : ::xml_schema::type (),
      SurfaceCore_ (this)
    {
    }

    SurfaceCoreType::
    SurfaceCoreType (const SurfaceCore_type& SurfaceCore)
    : ::xml_schema::type (),
      SurfaceCore_ (SurfaceCore, this)
    {
    }

    SurfaceCoreType::
    SurfaceCoreType (::std::unique_ptr< SurfaceCore_type > SurfaceCore)
    : ::xml_schema::type (),
      SurfaceCore_ (std::move (SurfaceCore), this)
    {
    }

    SurfaceCoreType::
    SurfaceCoreType (const SurfaceCoreType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SurfaceCore_ (x.SurfaceCore_, f, this)
    {
    }

    SurfaceCoreType::
    SurfaceCoreType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SurfaceCore_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceCoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceCore
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"SurfaceCore",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!SurfaceCore_.present ())
            {
              ::std::unique_ptr< SurfaceCore_type > r (
                dynamic_cast< SurfaceCore_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->SurfaceCore_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!SurfaceCore_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceCore",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SurfaceCoreType* SurfaceCoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceCoreType (*this, f, c);
    }

    SurfaceCoreType& SurfaceCoreType::
    operator= (const SurfaceCoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SurfaceCore_ = x.SurfaceCore_;
      }

      return *this;
    }

    SurfaceCoreType::
    ~SurfaceCoreType ()
    {
    }

    // SurfaceCoreBaseType
    //

    SurfaceCoreBaseType::
    SurfaceCoreBaseType ()
    : ::xml_schema::type (),
      form_ (this)
    {
    }

    SurfaceCoreBaseType::
    SurfaceCoreBaseType (const SurfaceCoreBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      form_ (x.form_, f, this)
    {
    }

    SurfaceCoreBaseType::
    SurfaceCoreBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceCoreBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }
      }
    }

    SurfaceCoreBaseType& SurfaceCoreBaseType::
    operator= (const SurfaceCoreBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->form_ = x.form_;
      }

      return *this;
    }

    SurfaceCoreBaseType::
    ~SurfaceCoreBaseType ()
    {
    }

    // Attr23CoreEnumType
    //

    Attr23CoreEnumType::
    Attr23CoreEnumType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_Attr23CoreEnumType_convert ();
    }

    Attr23CoreEnumType::
    Attr23CoreEnumType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_Attr23CoreEnumType_convert ();
    }

    Attr23CoreEnumType::
    Attr23CoreEnumType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_Attr23CoreEnumType_convert ();
    }

    Attr23CoreEnumType* Attr23CoreEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Attr23CoreEnumType (*this, f, c);
    }

    Attr23CoreEnumType::value Attr23CoreEnumType::
    _xsd_Attr23CoreEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_Attr23CoreEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_Attr23CoreEnumType_indexes_,
                        _xsd_Attr23CoreEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_Attr23CoreEnumType_indexes_ + 6 || _xsd_Attr23CoreEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const Attr23CoreEnumType::
    _xsd_Attr23CoreEnumType_literals_[6] =
    {
      L"FREEFORM",
      L"CYLINDER",
      L"CONE",
      L"TORUS",
      L"SPHERE",
      L"PLANE"
    };

    const Attr23CoreEnumType::value Attr23CoreEnumType::
    _xsd_Attr23CoreEnumType_indexes_[6] =
    {
      ::xsd::qif30::Attr23CoreEnumType::CONE,
      ::xsd::qif30::Attr23CoreEnumType::CYLINDER,
      ::xsd::qif30::Attr23CoreEnumType::FREEFORM,
      ::xsd::qif30::Attr23CoreEnumType::PLANE,
      ::xsd::qif30::Attr23CoreEnumType::SPHERE,
      ::xsd::qif30::Attr23CoreEnumType::TORUS
    };

    // Nurbs23CoreType
    //

    Nurbs23CoreType::
    Nurbs23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      OrderU_ (this),
      OrderV_ (this),
      KnotsU_ (this),
      KnotsV_ (this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs23CoreType::
    Nurbs23CoreType (const OrderU_type& OrderU,
                     const OrderV_type& OrderV,
                     const KnotsU_type& KnotsU,
                     const KnotsV_type& KnotsV)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      OrderU_ (OrderU, this),
      OrderV_ (OrderV, this),
      KnotsU_ (KnotsU, this),
      KnotsV_ (KnotsV, this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs23CoreType::
    Nurbs23CoreType (const OrderU_type& OrderU,
                     const OrderV_type& OrderV,
                     ::std::unique_ptr< KnotsU_type > KnotsU,
                     ::std::unique_ptr< KnotsV_type > KnotsV)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      OrderU_ (OrderU, this),
      OrderV_ (OrderV, this),
      KnotsU_ (std::move (KnotsU), this),
      KnotsV_ (std::move (KnotsV), this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
    }

    Nurbs23CoreType::
    Nurbs23CoreType (const Nurbs23CoreType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      OrderU_ (x.OrderU_, f, this),
      OrderV_ (x.OrderV_, f, this),
      KnotsU_ (x.KnotsU_, f, this),
      KnotsV_ (x.KnotsV_, f, this),
      CPs_ (x.CPs_, f, this),
      CPsBinary_ (x.CPsBinary_, f, this),
      Weights_ (x.Weights_, f, this)
    {
    }

    Nurbs23CoreType::
    Nurbs23CoreType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      OrderU_ (this),
      OrderV_ (this),
      KnotsU_ (this),
      KnotsV_ (this),
      CPs_ (this),
      CPsBinary_ (this),
      Weights_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Nurbs23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // OrderU
        //
        if (n.name () == L"OrderU" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OrderU_type > r (
            OrderU_traits::create (i, f, this));

          if (!OrderU_.present ())
          {
            this->OrderU_.set (::std::move (r));
            continue;
          }
        }

        // OrderV
        //
        if (n.name () == L"OrderV" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OrderV_type > r (
            OrderV_traits::create (i, f, this));

          if (!OrderV_.present ())
          {
            this->OrderV_.set (::std::move (r));
            continue;
          }
        }

        // KnotsU
        //
        if (n.name () == L"KnotsU" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< KnotsU_type > r (
            KnotsU_traits::create (i, f, this));

          if (!KnotsU_.present ())
          {
            this->KnotsU_.set (::std::move (r));
            continue;
          }
        }

        // KnotsV
        //
        if (n.name () == L"KnotsV" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< KnotsV_type > r (
            KnotsV_traits::create (i, f, this));

          if (!KnotsV_.present ())
          {
            this->KnotsV_.set (::std::move (r));
            continue;
          }
        }

        // CPs
        //
        if (n.name () == L"CPs" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CPs_type > r (
            CPs_traits::create (i, f, this));

          if (!this->CPs_)
          {
            this->CPs_.set (::std::move (r));
            continue;
          }
        }

        // CPsBinary
        //
        if (n.name () == L"CPsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CPsBinary_type > r (
            CPsBinary_traits::create (i, f, this));

          if (!this->CPsBinary_)
          {
            this->CPsBinary_.set (::std::move (r));
            continue;
          }
        }

        // Weights
        //
        if (n.name () == L"Weights" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Weights_type > r (
            Weights_traits::create (i, f, this));

          if (!this->Weights_)
          {
            this->Weights_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!OrderU_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"OrderU",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!OrderV_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"OrderV",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!KnotsU_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"KnotsU",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!KnotsV_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"KnotsV",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Nurbs23CoreType* Nurbs23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Nurbs23CoreType (*this, f, c);
    }

    Nurbs23CoreType& Nurbs23CoreType::
    operator= (const Nurbs23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->OrderU_ = x.OrderU_;
        this->OrderV_ = x.OrderV_;
        this->KnotsU_ = x.KnotsU_;
        this->KnotsV_ = x.KnotsV_;
        this->CPs_ = x.CPs_;
        this->CPsBinary_ = x.CPsBinary_;
        this->Weights_ = x.Weights_;
      }

      return *this;
    }

    Nurbs23CoreType::
    ~Nurbs23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Nurbs23CoreType >
    _xsd_Nurbs23CoreType_type_factory_init (
      L"Nurbs23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Nurbs23Type
    //

    Nurbs23Type::
    Nurbs23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Nurbs23Core_ (this),
      Transform_ (this)
    {
    }

    Nurbs23Type::
    Nurbs23Type (const id_type& id,
                 const Nurbs23Core_type& Nurbs23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Nurbs23Core_ (Nurbs23Core, this),
      Transform_ (this)
    {
    }

    Nurbs23Type::
    Nurbs23Type (const id_type& id,
                 ::std::unique_ptr< Nurbs23Core_type > Nurbs23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Nurbs23Core_ (std::move (Nurbs23Core), this),
      Transform_ (this)
    {
    }

    Nurbs23Type::
    Nurbs23Type (const Nurbs23Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Nurbs23Core_ (x.Nurbs23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Nurbs23Type::
    Nurbs23Type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Nurbs23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Nurbs23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Nurbs23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Nurbs23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Nurbs23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Nurbs23Core_.present ())
            {
              ::std::unique_ptr< Nurbs23Core_type > r (
                dynamic_cast< Nurbs23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Nurbs23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Nurbs23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Nurbs23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Nurbs23Type* Nurbs23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Nurbs23Type (*this, f, c);
    }

    Nurbs23Type& Nurbs23Type::
    operator= (const Nurbs23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Nurbs23Core_ = x.Nurbs23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Nurbs23Type::
    ~Nurbs23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Nurbs23Type >
    _xsd_Nurbs23Type_type_factory_init (
      L"Nurbs23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Spline23CoreType
    //

    Spline23CoreType::
    Spline23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      KnotsU_ (this),
      KnotsV_ (this),
      OrdersU_ (this),
      OrdersV_ (this),
      Coefficients_ (this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline23CoreType::
    Spline23CoreType (const KnotsU_type& KnotsU,
                      const KnotsV_type& KnotsV,
                      const OrdersU_type& OrdersU,
                      const OrdersV_type& OrdersV,
                      const Coefficients_type& Coefficients)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      KnotsU_ (KnotsU, this),
      KnotsV_ (KnotsV, this),
      OrdersU_ (OrdersU, this),
      OrdersV_ (OrdersV, this),
      Coefficients_ (Coefficients, this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline23CoreType::
    Spline23CoreType (::std::unique_ptr< KnotsU_type > KnotsU,
                      ::std::unique_ptr< KnotsV_type > KnotsV,
                      ::std::unique_ptr< OrdersU_type > OrdersU,
                      ::std::unique_ptr< OrdersV_type > OrdersV,
                      ::std::unique_ptr< Coefficients_type > Coefficients)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      KnotsU_ (std::move (KnotsU), this),
      KnotsV_ (std::move (KnotsV), this),
      OrdersU_ (std::move (OrdersU), this),
      OrdersV_ (std::move (OrdersV), this),
      Coefficients_ (std::move (Coefficients), this),
      normalized_ (normalized_default_value (), this)
    {
    }

    Spline23CoreType::
    Spline23CoreType (const Spline23CoreType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      KnotsU_ (x.KnotsU_, f, this),
      KnotsV_ (x.KnotsV_, f, this),
      OrdersU_ (x.OrdersU_, f, this),
      OrdersV_ (x.OrdersV_, f, this),
      Coefficients_ (x.Coefficients_, f, this),
      normalized_ (x.normalized_, f, this)
    {
    }

    Spline23CoreType::
    Spline23CoreType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      KnotsU_ (this),
      KnotsV_ (this),
      OrdersU_ (this),
      OrdersV_ (this),
      Coefficients_ (this),
      normalized_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Spline23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // KnotsU
        //
        if (n.name () == L"KnotsU" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< KnotsU_type > r (
            KnotsU_traits::create (i, f, this));

          if (!KnotsU_.present ())
          {
            this->KnotsU_.set (::std::move (r));
            continue;
          }
        }

        // KnotsV
        //
        if (n.name () == L"KnotsV" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< KnotsV_type > r (
            KnotsV_traits::create (i, f, this));

          if (!KnotsV_.present ())
          {
            this->KnotsV_.set (::std::move (r));
            continue;
          }
        }

        // OrdersU
        //
        if (n.name () == L"OrdersU" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OrdersU_type > r (
            OrdersU_traits::create (i, f, this));

          if (!OrdersU_.present ())
          {
            this->OrdersU_.set (::std::move (r));
            continue;
          }
        }

        // OrdersV
        //
        if (n.name () == L"OrdersV" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OrdersV_type > r (
            OrdersV_traits::create (i, f, this));

          if (!OrdersV_.present ())
          {
            this->OrdersV_.set (::std::move (r));
            continue;
          }
        }

        // Coefficients
        //
        if (n.name () == L"Coefficients" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Coefficients_type > r (
            Coefficients_traits::create (i, f, this));

          if (!Coefficients_.present ())
          {
            this->Coefficients_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!KnotsU_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"KnotsU",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!KnotsV_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"KnotsV",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!OrdersU_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"OrdersU",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!OrdersV_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"OrdersV",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Coefficients_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Coefficients",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"normalized" && n.namespace_ ().empty ())
        {
          this->normalized_.set (normalized_traits::create (i, f, this));
          continue;
        }
      }

      if (!normalized_.present ())
      {
        this->normalized_.set (normalized_default_value ());
      }
    }

    Spline23CoreType* Spline23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Spline23CoreType (*this, f, c);
    }

    Spline23CoreType& Spline23CoreType::
    operator= (const Spline23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->KnotsU_ = x.KnotsU_;
        this->KnotsV_ = x.KnotsV_;
        this->OrdersU_ = x.OrdersU_;
        this->OrdersV_ = x.OrdersV_;
        this->Coefficients_ = x.Coefficients_;
        this->normalized_ = x.normalized_;
      }

      return *this;
    }

    Spline23CoreType::
    ~Spline23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Spline23CoreType >
    _xsd_Spline23CoreType_type_factory_init (
      L"Spline23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Spline23Type
    //

    Spline23Type::
    Spline23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Spline23Core_ (this),
      Transform_ (this)
    {
    }

    Spline23Type::
    Spline23Type (const id_type& id,
                  const Spline23Core_type& Spline23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Spline23Core_ (Spline23Core, this),
      Transform_ (this)
    {
    }

    Spline23Type::
    Spline23Type (const id_type& id,
                  ::std::unique_ptr< Spline23Core_type > Spline23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Spline23Core_ (std::move (Spline23Core), this),
      Transform_ (this)
    {
    }

    Spline23Type::
    Spline23Type (const Spline23Type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Spline23Core_ (x.Spline23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Spline23Type::
    Spline23Type (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Spline23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Spline23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Spline23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Spline23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Spline23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Spline23Core_.present ())
            {
              ::std::unique_ptr< Spline23Core_type > r (
                dynamic_cast< Spline23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Spline23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Spline23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Spline23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Spline23Type* Spline23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Spline23Type (*this, f, c);
    }

    Spline23Type& Spline23Type::
    operator= (const Spline23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Spline23Core_ = x.Spline23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Spline23Type::
    ~Spline23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Spline23Type >
    _xsd_Spline23Type_type_factory_init (
      L"Spline23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Revolution23CoreType
    //

    Revolution23CoreType::
    Revolution23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Axis_ (this),
      Generatrix_ (this),
      angle_ (this)
    {
    }

    Revolution23CoreType::
    Revolution23CoreType (const Axis_type& Axis,
                          const Generatrix_type& Generatrix,
                          const angle_type& angle)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Axis_ (Axis, this),
      Generatrix_ (Generatrix, this),
      angle_ (angle, this)
    {
    }

    Revolution23CoreType::
    Revolution23CoreType (::std::unique_ptr< Axis_type > Axis,
                          ::std::unique_ptr< Generatrix_type > Generatrix,
                          const angle_type& angle)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Axis_ (std::move (Axis), this),
      Generatrix_ (std::move (Generatrix), this),
      angle_ (angle, this)
    {
    }

    Revolution23CoreType::
    Revolution23CoreType (const Revolution23CoreType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Generatrix_ (x.Generatrix_, f, this),
      angle_ (x.angle_, f, this)
    {
    }

    Revolution23CoreType::
    Revolution23CoreType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Generatrix_ (this),
      angle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Revolution23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Generatrix
        //
        if (n.name () == L"Generatrix" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Generatrix_type > r (
            Generatrix_traits::create (i, f, this));

          if (!Generatrix_.present ())
          {
            this->Generatrix_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Generatrix_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Generatrix",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"angle" && n.namespace_ ().empty ())
        {
          this->angle_.set (angle_traits::create (i, f, this));
          continue;
        }
      }

      if (!angle_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"angle",
          L"");
      }
    }

    Revolution23CoreType* Revolution23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Revolution23CoreType (*this, f, c);
    }

    Revolution23CoreType& Revolution23CoreType::
    operator= (const Revolution23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Generatrix_ = x.Generatrix_;
        this->angle_ = x.angle_;
      }

      return *this;
    }

    Revolution23CoreType::
    ~Revolution23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Revolution23CoreType >
    _xsd_Revolution23CoreType_type_factory_init (
      L"Revolution23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Revolution23Type
    //

    Revolution23Type::
    Revolution23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Revolution23Core_ (this),
      Transform_ (this)
    {
    }

    Revolution23Type::
    Revolution23Type (const id_type& id,
                      const Revolution23Core_type& Revolution23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Revolution23Core_ (Revolution23Core, this),
      Transform_ (this)
    {
    }

    Revolution23Type::
    Revolution23Type (const id_type& id,
                      ::std::unique_ptr< Revolution23Core_type > Revolution23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Revolution23Core_ (std::move (Revolution23Core), this),
      Transform_ (this)
    {
    }

    Revolution23Type::
    Revolution23Type (const Revolution23Type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Revolution23Core_ (x.Revolution23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Revolution23Type::
    Revolution23Type (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Revolution23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Revolution23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Revolution23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Revolution23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Revolution23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Revolution23Core_.present ())
            {
              ::std::unique_ptr< Revolution23Core_type > r (
                dynamic_cast< Revolution23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Revolution23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Revolution23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Revolution23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Revolution23Type* Revolution23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Revolution23Type (*this, f, c);
    }

    Revolution23Type& Revolution23Type::
    operator= (const Revolution23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Revolution23Core_ = x.Revolution23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Revolution23Type::
    ~Revolution23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Revolution23Type >
    _xsd_Revolution23Type_type_factory_init (
      L"Revolution23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Extrude23CoreType
    //

    Extrude23CoreType::
    Extrude23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      TerminationPoint_ (this),
      Curve_ (this)
    {
    }

    Extrude23CoreType::
    Extrude23CoreType (const TerminationPoint_type& TerminationPoint,
                       const Curve_type& Curve)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      TerminationPoint_ (TerminationPoint, this),
      Curve_ (Curve, this)
    {
    }

    Extrude23CoreType::
    Extrude23CoreType (const TerminationPoint_type& TerminationPoint,
                       ::std::unique_ptr< Curve_type > Curve)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      TerminationPoint_ (TerminationPoint, this),
      Curve_ (std::move (Curve), this)
    {
    }

    Extrude23CoreType::
    Extrude23CoreType (const Extrude23CoreType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      TerminationPoint_ (x.TerminationPoint_, f, this),
      Curve_ (x.Curve_, f, this)
    {
    }

    Extrude23CoreType::
    Extrude23CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      TerminationPoint_ (this),
      Curve_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Extrude23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TerminationPoint
        //
        if (n.name () == L"TerminationPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TerminationPoint_type > r (
            TerminationPoint_traits::create (i, f, this));

          if (!TerminationPoint_.present ())
          {
            this->TerminationPoint_.set (::std::move (r));
            continue;
          }
        }

        // Curve
        //
        if (n.name () == L"Curve" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Curve_type > r (
            Curve_traits::create (i, f, this));

          if (!Curve_.present ())
          {
            this->Curve_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!TerminationPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TerminationPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Curve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Curve",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Extrude23CoreType* Extrude23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Extrude23CoreType (*this, f, c);
    }

    Extrude23CoreType& Extrude23CoreType::
    operator= (const Extrude23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->TerminationPoint_ = x.TerminationPoint_;
        this->Curve_ = x.Curve_;
      }

      return *this;
    }

    Extrude23CoreType::
    ~Extrude23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Extrude23CoreType >
    _xsd_Extrude23CoreType_type_factory_init (
      L"Extrude23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Extrude23Type
    //

    Extrude23Type::
    Extrude23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Extrude23Core_ (this),
      Transform_ (this)
    {
    }

    Extrude23Type::
    Extrude23Type (const id_type& id,
                   const Extrude23Core_type& Extrude23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Extrude23Core_ (Extrude23Core, this),
      Transform_ (this)
    {
    }

    Extrude23Type::
    Extrude23Type (const id_type& id,
                   ::std::unique_ptr< Extrude23Core_type > Extrude23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Extrude23Core_ (std::move (Extrude23Core), this),
      Transform_ (this)
    {
    }

    Extrude23Type::
    Extrude23Type (const Extrude23Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Extrude23Core_ (x.Extrude23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Extrude23Type::
    Extrude23Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Extrude23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Extrude23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Extrude23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Extrude23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Extrude23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Extrude23Core_.present ())
            {
              ::std::unique_ptr< Extrude23Core_type > r (
                dynamic_cast< Extrude23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extrude23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Extrude23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Extrude23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Extrude23Type* Extrude23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Extrude23Type (*this, f, c);
    }

    Extrude23Type& Extrude23Type::
    operator= (const Extrude23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Extrude23Core_ = x.Extrude23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Extrude23Type::
    ~Extrude23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Extrude23Type >
    _xsd_Extrude23Type_type_factory_init (
      L"Extrude23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Ruled23CoreType
    //

    Ruled23CoreType::
    Ruled23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Curve_ (this),
      turnedSecondCurve_ (turnedSecondCurve_default_value (), this)
    {
    }

    Ruled23CoreType::
    Ruled23CoreType (const Ruled23CoreType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      Curve_ (x.Curve_, f, this),
      turnedSecondCurve_ (x.turnedSecondCurve_, f, this)
    {
    }

    Ruled23CoreType::
    Ruled23CoreType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Curve_ (this),
      turnedSecondCurve_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Ruled23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Curve
        //
        if (n.name () == L"Curve" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Curve_type > r (
            Curve_traits::create (i, f, this));

          this->Curve_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turnedSecondCurve" && n.namespace_ ().empty ())
        {
          this->turnedSecondCurve_.set (turnedSecondCurve_traits::create (i, f, this));
          continue;
        }
      }

      if (!turnedSecondCurve_.present ())
      {
        this->turnedSecondCurve_.set (turnedSecondCurve_default_value ());
      }
    }

    Ruled23CoreType* Ruled23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Ruled23CoreType (*this, f, c);
    }

    Ruled23CoreType& Ruled23CoreType::
    operator= (const Ruled23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->Curve_ = x.Curve_;
        this->turnedSecondCurve_ = x.turnedSecondCurve_;
      }

      return *this;
    }

    Ruled23CoreType::
    ~Ruled23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Ruled23CoreType >
    _xsd_Ruled23CoreType_type_factory_init (
      L"Ruled23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Ruled23Type
    //

    Ruled23Type::
    Ruled23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Ruled23Core_ (this),
      Transform_ (this)
    {
    }

    Ruled23Type::
    Ruled23Type (const id_type& id,
                 const Ruled23Core_type& Ruled23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Ruled23Core_ (Ruled23Core, this),
      Transform_ (this)
    {
    }

    Ruled23Type::
    Ruled23Type (const id_type& id,
                 ::std::unique_ptr< Ruled23Core_type > Ruled23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Ruled23Core_ (std::move (Ruled23Core), this),
      Transform_ (this)
    {
    }

    Ruled23Type::
    Ruled23Type (const Ruled23Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Ruled23Core_ (x.Ruled23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Ruled23Type::
    Ruled23Type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Ruled23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Ruled23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Ruled23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Ruled23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Ruled23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Ruled23Core_.present ())
            {
              ::std::unique_ptr< Ruled23Core_type > r (
                dynamic_cast< Ruled23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Ruled23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Ruled23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Ruled23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Ruled23Type* Ruled23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Ruled23Type (*this, f, c);
    }

    Ruled23Type& Ruled23Type::
    operator= (const Ruled23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Ruled23Core_ = x.Ruled23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Ruled23Type::
    ~Ruled23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Ruled23Type >
    _xsd_Ruled23Type_type_factory_init (
      L"Ruled23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Offset23CoreType
    //

    Offset23CoreType::
    Offset23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Distance_ (this),
      Surface_ (this)
    {
    }

    Offset23CoreType::
    Offset23CoreType (const Distance_type& Distance,
                      const Surface_type& Surface)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Distance_ (Distance, this),
      Surface_ (Surface, this)
    {
    }

    Offset23CoreType::
    Offset23CoreType (const Distance_type& Distance,
                      ::std::unique_ptr< Surface_type > Surface)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Distance_ (Distance, this),
      Surface_ (std::move (Surface), this)
    {
    }

    Offset23CoreType::
    Offset23CoreType (const Offset23CoreType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      Distance_ (x.Distance_, f, this),
      Surface_ (x.Surface_, f, this)
    {
    }

    Offset23CoreType::
    Offset23CoreType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Distance_ (this),
      Surface_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Offset23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Distance
        //
        if (n.name () == L"Distance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Distance_.present ())
          {
            this->Distance_.set (Distance_traits::create (i, f, this));
            continue;
          }
        }

        // Surface
        //
        if (n.name () == L"Surface" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Surface_type > r (
            Surface_traits::create (i, f, this));

          if (!Surface_.present ())
          {
            this->Surface_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Distance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Surface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Surface",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Offset23CoreType* Offset23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Offset23CoreType (*this, f, c);
    }

    Offset23CoreType& Offset23CoreType::
    operator= (const Offset23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->Distance_ = x.Distance_;
        this->Surface_ = x.Surface_;
      }

      return *this;
    }

    Offset23CoreType::
    ~Offset23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Offset23CoreType >
    _xsd_Offset23CoreType_type_factory_init (
      L"Offset23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Offset23Type
    //

    Offset23Type::
    Offset23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Offset23Core_ (this),
      Transform_ (this)
    {
    }

    Offset23Type::
    Offset23Type (const id_type& id,
                  const Offset23Core_type& Offset23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Offset23Core_ (Offset23Core, this),
      Transform_ (this)
    {
    }

    Offset23Type::
    Offset23Type (const id_type& id,
                  ::std::unique_ptr< Offset23Core_type > Offset23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Offset23Core_ (std::move (Offset23Core), this),
      Transform_ (this)
    {
    }

    Offset23Type::
    Offset23Type (const Offset23Type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Offset23Core_ (x.Offset23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Offset23Type::
    Offset23Type (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Offset23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Offset23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Offset23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Offset23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Offset23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Offset23Core_.present ())
            {
              ::std::unique_ptr< Offset23Core_type > r (
                dynamic_cast< Offset23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Offset23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Offset23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Offset23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Offset23Type* Offset23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Offset23Type (*this, f, c);
    }

    Offset23Type& Offset23Type::
    operator= (const Offset23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Offset23Core_ = x.Offset23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Offset23Type::
    ~Offset23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Offset23Type >
    _xsd_Offset23Type_type_factory_init (
      L"Offset23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Plane23CoreType
    //

    Plane23CoreType::
    Plane23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Origin_ (this),
      DirU_ (this),
      DirV_ (this),
      domainU_ (this),
      domainV_ (this)
    {
    }

    Plane23CoreType::
    Plane23CoreType (const Origin_type& Origin,
                     const DirU_type& DirU,
                     const DirV_type& DirV,
                     const domainU_type& domainU,
                     const domainV_type& domainV)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Origin_ (Origin, this),
      DirU_ (DirU, this),
      DirV_ (DirV, this),
      domainU_ (domainU, this),
      domainV_ (domainV, this)
    {
    }

    Plane23CoreType::
    Plane23CoreType (const Plane23CoreType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      Origin_ (x.Origin_, f, this),
      DirU_ (x.DirU_, f, this),
      DirV_ (x.DirV_, f, this),
      domainU_ (x.domainU_, f, this),
      domainV_ (x.domainV_, f, this)
    {
    }

    Plane23CoreType::
    Plane23CoreType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Origin_ (this),
      DirU_ (this),
      DirV_ (this),
      domainU_ (this),
      domainV_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Plane23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Origin
        //
        if (n.name () == L"Origin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          if (!Origin_.present ())
          {
            this->Origin_.set (::std::move (r));
            continue;
          }
        }

        // DirU
        //
        if (n.name () == L"DirU" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirU_type > r (
            DirU_traits::create (i, f, this));

          if (!DirU_.present ())
          {
            this->DirU_.set (::std::move (r));
            continue;
          }
        }

        // DirV
        //
        if (n.name () == L"DirV" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirV_type > r (
            DirV_traits::create (i, f, this));

          if (!DirV_.present ())
          {
            this->DirV_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Origin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Origin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DirU_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirU",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DirV_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirV",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"domainU" && n.namespace_ ().empty ())
        {
          this->domainU_.set (domainU_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"domainV" && n.namespace_ ().empty ())
        {
          this->domainV_.set (domainV_traits::create (i, f, this));
          continue;
        }
      }

      if (!domainU_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"domainU",
          L"");
      }

      if (!domainV_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"domainV",
          L"");
      }
    }

    Plane23CoreType* Plane23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Plane23CoreType (*this, f, c);
    }

    Plane23CoreType& Plane23CoreType::
    operator= (const Plane23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->Origin_ = x.Origin_;
        this->DirU_ = x.DirU_;
        this->DirV_ = x.DirV_;
        this->domainU_ = x.domainU_;
        this->domainV_ = x.domainV_;
      }

      return *this;
    }

    Plane23CoreType::
    ~Plane23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Plane23CoreType >
    _xsd_Plane23CoreType_type_factory_init (
      L"Plane23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Plane23Type
    //

    Plane23Type::
    Plane23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Plane23Core_ (this),
      Transform_ (this)
    {
    }

    Plane23Type::
    Plane23Type (const id_type& id,
                 const Plane23Core_type& Plane23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Plane23Core_ (Plane23Core, this),
      Transform_ (this)
    {
    }

    Plane23Type::
    Plane23Type (const id_type& id,
                 ::std::unique_ptr< Plane23Core_type > Plane23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Plane23Core_ (std::move (Plane23Core), this),
      Transform_ (this)
    {
    }

    Plane23Type::
    Plane23Type (const Plane23Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Plane23Core_ (x.Plane23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Plane23Type::
    Plane23Type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Plane23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Plane23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Plane23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Plane23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Plane23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Plane23Core_.present ())
            {
              ::std::unique_ptr< Plane23Core_type > r (
                dynamic_cast< Plane23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Plane23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Plane23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Plane23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Plane23Type* Plane23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Plane23Type (*this, f, c);
    }

    Plane23Type& Plane23Type::
    operator= (const Plane23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Plane23Core_ = x.Plane23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Plane23Type::
    ~Plane23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Plane23Type >
    _xsd_Plane23Type_type_factory_init (
      L"Plane23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Cone23CoreType
    //

    Cone23CoreType::
    Cone23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      DiameterBottom_ (this),
      DiameterTop_ (this),
      Length_ (this),
      Axis_ (this),
      Sweep_ (this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Cone23CoreType::
    Cone23CoreType (const DiameterBottom_type& DiameterBottom,
                    const DiameterTop_type& DiameterTop,
                    const Length_type& Length,
                    const Axis_type& Axis,
                    const Sweep_type& Sweep)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      DiameterBottom_ (DiameterBottom, this),
      DiameterTop_ (DiameterTop, this),
      Length_ (Length, this),
      Axis_ (Axis, this),
      Sweep_ (Sweep, this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Cone23CoreType::
    Cone23CoreType (const DiameterBottom_type& DiameterBottom,
                    const DiameterTop_type& DiameterTop,
                    const Length_type& Length,
                    ::std::unique_ptr< Axis_type > Axis,
                    ::std::unique_ptr< Sweep_type > Sweep)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      DiameterBottom_ (DiameterBottom, this),
      DiameterTop_ (DiameterTop, this),
      Length_ (Length, this),
      Axis_ (std::move (Axis), this),
      Sweep_ (std::move (Sweep), this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Cone23CoreType::
    Cone23CoreType (const Cone23CoreType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      DiameterBottom_ (x.DiameterBottom_, f, this),
      DiameterTop_ (x.DiameterTop_, f, this),
      Length_ (x.Length_, f, this),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      turnedV_ (x.turnedV_, f, this),
      scaleU_ (x.scaleU_, f, this),
      scaleV_ (x.scaleV_, f, this)
    {
    }

    Cone23CoreType::
    Cone23CoreType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      DiameterBottom_ (this),
      DiameterTop_ (this),
      Length_ (this),
      Axis_ (this),
      Sweep_ (this),
      turnedV_ (this),
      scaleU_ (this),
      scaleV_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Cone23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DiameterBottom
        //
        if (n.name () == L"DiameterBottom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DiameterBottom_.present ())
          {
            this->DiameterBottom_.set (DiameterBottom_traits::create (i, f, this));
            continue;
          }
        }

        // DiameterTop
        //
        if (n.name () == L"DiameterTop" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DiameterTop_.present ())
          {
            this->DiameterTop_.set (DiameterTop_traits::create (i, f, this));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Length_.present ())
          {
            this->Length_.set (Length_traits::create (i, f, this));
            continue;
          }
        }

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DiameterBottom_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DiameterBottom",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DiameterTop_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DiameterTop",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Sweep",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turnedV" && n.namespace_ ().empty ())
        {
          this->turnedV_.set (turnedV_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"scaleU" && n.namespace_ ().empty ())
        {
          this->scaleU_.set (scaleU_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"scaleV" && n.namespace_ ().empty ())
        {
          this->scaleV_.set (scaleV_traits::create (i, f, this));
          continue;
        }
      }

      if (!turnedV_.present ())
      {
        this->turnedV_.set (turnedV_default_value ());
      }

      if (!scaleU_.present ())
      {
        this->scaleU_.set (scaleU_default_value ());
      }

      if (!scaleV_.present ())
      {
        this->scaleV_.set (scaleV_default_value ());
      }
    }

    Cone23CoreType* Cone23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Cone23CoreType (*this, f, c);
    }

    Cone23CoreType& Cone23CoreType::
    operator= (const Cone23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->DiameterBottom_ = x.DiameterBottom_;
        this->DiameterTop_ = x.DiameterTop_;
        this->Length_ = x.Length_;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->turnedV_ = x.turnedV_;
        this->scaleU_ = x.scaleU_;
        this->scaleV_ = x.scaleV_;
      }

      return *this;
    }

    Cone23CoreType::
    ~Cone23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Cone23CoreType >
    _xsd_Cone23CoreType_type_factory_init (
      L"Cone23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Cone23Type
    //

    Cone23Type::
    Cone23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Cone23Core_ (this),
      Transform_ (this)
    {
    }

    Cone23Type::
    Cone23Type (const id_type& id,
                const Cone23Core_type& Cone23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Cone23Core_ (Cone23Core, this),
      Transform_ (this)
    {
    }

    Cone23Type::
    Cone23Type (const id_type& id,
                ::std::unique_ptr< Cone23Core_type > Cone23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Cone23Core_ (std::move (Cone23Core), this),
      Transform_ (this)
    {
    }

    Cone23Type::
    Cone23Type (const Cone23Type& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Cone23Core_ (x.Cone23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Cone23Type::
    Cone23Type (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Cone23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Cone23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Cone23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Cone23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Cone23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Cone23Core_.present ())
            {
              ::std::unique_ptr< Cone23Core_type > r (
                dynamic_cast< Cone23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Cone23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Cone23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Cone23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Cone23Type* Cone23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Cone23Type (*this, f, c);
    }

    Cone23Type& Cone23Type::
    operator= (const Cone23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Cone23Core_ = x.Cone23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Cone23Type::
    ~Cone23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Cone23Type >
    _xsd_Cone23Type_type_factory_init (
      L"Cone23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Cylinder23CoreType
    //

    Cylinder23CoreType::
    Cylinder23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Diameter_ (this),
      Length_ (this),
      Axis_ (this),
      Sweep_ (this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Cylinder23CoreType::
    Cylinder23CoreType (const Diameter_type& Diameter,
                        const Length_type& Length,
                        const Axis_type& Axis,
                        const Sweep_type& Sweep)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Diameter_ (Diameter, this),
      Length_ (Length, this),
      Axis_ (Axis, this),
      Sweep_ (Sweep, this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Cylinder23CoreType::
    Cylinder23CoreType (const Diameter_type& Diameter,
                        const Length_type& Length,
                        ::std::unique_ptr< Axis_type > Axis,
                        ::std::unique_ptr< Sweep_type > Sweep)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Diameter_ (Diameter, this),
      Length_ (Length, this),
      Axis_ (std::move (Axis), this),
      Sweep_ (std::move (Sweep), this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Cylinder23CoreType::
    Cylinder23CoreType (const Cylinder23CoreType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      turnedV_ (x.turnedV_, f, this),
      scaleU_ (x.scaleU_, f, this),
      scaleV_ (x.scaleV_, f, this)
    {
    }

    Cylinder23CoreType::
    Cylinder23CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      Length_ (this),
      Axis_ (this),
      Sweep_ (this),
      turnedV_ (this),
      scaleU_ (this),
      scaleV_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Cylinder23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Diameter_.present ())
          {
            this->Diameter_.set (Diameter_traits::create (i, f, this));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Length_.present ())
          {
            this->Length_.set (Length_traits::create (i, f, this));
            continue;
          }
        }

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Sweep",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turnedV" && n.namespace_ ().empty ())
        {
          this->turnedV_.set (turnedV_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"scaleU" && n.namespace_ ().empty ())
        {
          this->scaleU_.set (scaleU_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"scaleV" && n.namespace_ ().empty ())
        {
          this->scaleV_.set (scaleV_traits::create (i, f, this));
          continue;
        }
      }

      if (!turnedV_.present ())
      {
        this->turnedV_.set (turnedV_default_value ());
      }

      if (!scaleU_.present ())
      {
        this->scaleU_.set (scaleU_default_value ());
      }

      if (!scaleV_.present ())
      {
        this->scaleV_.set (scaleV_default_value ());
      }
    }

    Cylinder23CoreType* Cylinder23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Cylinder23CoreType (*this, f, c);
    }

    Cylinder23CoreType& Cylinder23CoreType::
    operator= (const Cylinder23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->turnedV_ = x.turnedV_;
        this->scaleU_ = x.scaleU_;
        this->scaleV_ = x.scaleV_;
      }

      return *this;
    }

    Cylinder23CoreType::
    ~Cylinder23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Cylinder23CoreType >
    _xsd_Cylinder23CoreType_type_factory_init (
      L"Cylinder23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Cylinder23Type
    //

    Cylinder23Type::
    Cylinder23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Cylinder23Core_ (this),
      Transform_ (this)
    {
    }

    Cylinder23Type::
    Cylinder23Type (const id_type& id,
                    const Cylinder23Core_type& Cylinder23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Cylinder23Core_ (Cylinder23Core, this),
      Transform_ (this)
    {
    }

    Cylinder23Type::
    Cylinder23Type (const id_type& id,
                    ::std::unique_ptr< Cylinder23Core_type > Cylinder23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Cylinder23Core_ (std::move (Cylinder23Core), this),
      Transform_ (this)
    {
    }

    Cylinder23Type::
    Cylinder23Type (const Cylinder23Type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Cylinder23Core_ (x.Cylinder23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Cylinder23Type::
    Cylinder23Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Cylinder23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Cylinder23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Cylinder23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Cylinder23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Cylinder23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Cylinder23Core_.present ())
            {
              ::std::unique_ptr< Cylinder23Core_type > r (
                dynamic_cast< Cylinder23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Cylinder23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Cylinder23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Cylinder23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Cylinder23Type* Cylinder23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Cylinder23Type (*this, f, c);
    }

    Cylinder23Type& Cylinder23Type::
    operator= (const Cylinder23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Cylinder23Core_ = x.Cylinder23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Cylinder23Type::
    ~Cylinder23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Cylinder23Type >
    _xsd_Cylinder23Type_type_factory_init (
      L"Cylinder23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Sphere23CoreType
    //

    Sphere23CoreType::
    Sphere23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Diameter_ (this),
      Location_ (this),
      LatitudeLongitudeSweep_ (this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Sphere23CoreType::
    Sphere23CoreType (const Diameter_type& Diameter,
                      const Location_type& Location,
                      const LatitudeLongitudeSweep_type& LatitudeLongitudeSweep)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Diameter_ (Diameter, this),
      Location_ (Location, this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Sphere23CoreType::
    Sphere23CoreType (const Diameter_type& Diameter,
                      const Location_type& Location,
                      ::std::unique_ptr< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      Diameter_ (Diameter, this),
      Location_ (Location, this),
      LatitudeLongitudeSweep_ (std::move (LatitudeLongitudeSweep), this),
      turnedV_ (turnedV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Sphere23CoreType::
    Sphere23CoreType (const Sphere23CoreType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      Location_ (x.Location_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      turnedV_ (x.turnedV_, f, this),
      scaleU_ (x.scaleU_, f, this),
      scaleV_ (x.scaleV_, f, this)
    {
    }

    Sphere23CoreType::
    Sphere23CoreType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      Location_ (this),
      LatitudeLongitudeSweep_ (this),
      turnedV_ (this),
      scaleU_ (this),
      scaleV_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Sphere23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Diameter_.present ())
          {
            this->Diameter_.set (Diameter_traits::create (i, f, this));
            continue;
          }
        }

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == L"LatitudeLongitudeSweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!LatitudeLongitudeSweep_.present ())
          {
            this->LatitudeLongitudeSweep_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!LatitudeLongitudeSweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LatitudeLongitudeSweep",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turnedV" && n.namespace_ ().empty ())
        {
          this->turnedV_.set (turnedV_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"scaleU" && n.namespace_ ().empty ())
        {
          this->scaleU_.set (scaleU_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"scaleV" && n.namespace_ ().empty ())
        {
          this->scaleV_.set (scaleV_traits::create (i, f, this));
          continue;
        }
      }

      if (!turnedV_.present ())
      {
        this->turnedV_.set (turnedV_default_value ());
      }

      if (!scaleU_.present ())
      {
        this->scaleU_.set (scaleU_default_value ());
      }

      if (!scaleV_.present ())
      {
        this->scaleV_.set (scaleV_default_value ());
      }
    }

    Sphere23CoreType* Sphere23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Sphere23CoreType (*this, f, c);
    }

    Sphere23CoreType& Sphere23CoreType::
    operator= (const Sphere23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->Location_ = x.Location_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->turnedV_ = x.turnedV_;
        this->scaleU_ = x.scaleU_;
        this->scaleV_ = x.scaleV_;
      }

      return *this;
    }

    Sphere23CoreType::
    ~Sphere23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Sphere23CoreType >
    _xsd_Sphere23CoreType_type_factory_init (
      L"Sphere23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Sphere23Type
    //

    Sphere23Type::
    Sphere23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Sphere23Core_ (this),
      Transform_ (this)
    {
    }

    Sphere23Type::
    Sphere23Type (const id_type& id,
                  const Sphere23Core_type& Sphere23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Sphere23Core_ (Sphere23Core, this),
      Transform_ (this)
    {
    }

    Sphere23Type::
    Sphere23Type (const id_type& id,
                  ::std::unique_ptr< Sphere23Core_type > Sphere23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Sphere23Core_ (std::move (Sphere23Core), this),
      Transform_ (this)
    {
    }

    Sphere23Type::
    Sphere23Type (const Sphere23Type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Sphere23Core_ (x.Sphere23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Sphere23Type::
    Sphere23Type (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Sphere23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Sphere23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Sphere23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Sphere23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Sphere23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Sphere23Core_.present ())
            {
              ::std::unique_ptr< Sphere23Core_type > r (
                dynamic_cast< Sphere23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Sphere23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Sphere23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Sphere23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Sphere23Type* Sphere23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Sphere23Type (*this, f, c);
    }

    Sphere23Type& Sphere23Type::
    operator= (const Sphere23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Sphere23Core_ = x.Sphere23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Sphere23Type::
    ~Sphere23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Sphere23Type >
    _xsd_Sphere23Type_type_factory_init (
      L"Sphere23Type",
      L"http://qifstandards.org/xsd/qif3");

    // Torus23CoreType
    //

    Torus23CoreType::
    Torus23CoreType ()
    : ::xsd::qif30::SurfaceCoreBaseType (),
      DiameterMinor_ (this),
      DiameterMajor_ (this),
      Axis_ (this),
      LatitudeLongitudeSweep_ (this),
      turnedV_ (turnedV_default_value (), this),
      offsetV_ (offsetV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Torus23CoreType::
    Torus23CoreType (const DiameterMinor_type& DiameterMinor,
                     const DiameterMajor_type& DiameterMajor,
                     const Axis_type& Axis,
                     const LatitudeLongitudeSweep_type& LatitudeLongitudeSweep)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      DiameterMinor_ (DiameterMinor, this),
      DiameterMajor_ (DiameterMajor, this),
      Axis_ (Axis, this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, this),
      turnedV_ (turnedV_default_value (), this),
      offsetV_ (offsetV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Torus23CoreType::
    Torus23CoreType (const DiameterMinor_type& DiameterMinor,
                     const DiameterMajor_type& DiameterMajor,
                     ::std::unique_ptr< Axis_type > Axis,
                     ::std::unique_ptr< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep)
    : ::xsd::qif30::SurfaceCoreBaseType (),
      DiameterMinor_ (DiameterMinor, this),
      DiameterMajor_ (DiameterMajor, this),
      Axis_ (std::move (Axis), this),
      LatitudeLongitudeSweep_ (std::move (LatitudeLongitudeSweep), this),
      turnedV_ (turnedV_default_value (), this),
      offsetV_ (offsetV_default_value (), this),
      scaleU_ (scaleU_default_value (), this),
      scaleV_ (scaleV_default_value (), this)
    {
    }

    Torus23CoreType::
    Torus23CoreType (const Torus23CoreType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (x, f, c),
      DiameterMinor_ (x.DiameterMinor_, f, this),
      DiameterMajor_ (x.DiameterMajor_, f, this),
      Axis_ (x.Axis_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      turnedV_ (x.turnedV_, f, this),
      offsetV_ (x.offsetV_, f, this),
      scaleU_ (x.scaleU_, f, this),
      scaleV_ (x.scaleV_, f, this)
    {
    }

    Torus23CoreType::
    Torus23CoreType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceCoreBaseType (e, f | ::xml_schema::flags::base, c),
      DiameterMinor_ (this),
      DiameterMajor_ (this),
      Axis_ (this),
      LatitudeLongitudeSweep_ (this),
      turnedV_ (this),
      offsetV_ (this),
      scaleU_ (this),
      scaleV_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Torus23CoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceCoreBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DiameterMinor
        //
        if (n.name () == L"DiameterMinor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DiameterMinor_.present ())
          {
            this->DiameterMinor_.set (DiameterMinor_traits::create (i, f, this));
            continue;
          }
        }

        // DiameterMajor
        //
        if (n.name () == L"DiameterMajor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!DiameterMajor_.present ())
          {
            this->DiameterMajor_.set (DiameterMajor_traits::create (i, f, this));
            continue;
          }
        }

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == L"LatitudeLongitudeSweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!LatitudeLongitudeSweep_.present ())
          {
            this->LatitudeLongitudeSweep_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DiameterMinor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DiameterMinor",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DiameterMajor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DiameterMajor",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!LatitudeLongitudeSweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LatitudeLongitudeSweep",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turnedV" && n.namespace_ ().empty ())
        {
          this->turnedV_.set (turnedV_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"offsetV" && n.namespace_ ().empty ())
        {
          this->offsetV_.set (offsetV_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"scaleU" && n.namespace_ ().empty ())
        {
          this->scaleU_.set (scaleU_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"scaleV" && n.namespace_ ().empty ())
        {
          this->scaleV_.set (scaleV_traits::create (i, f, this));
          continue;
        }
      }

      if (!turnedV_.present ())
      {
        this->turnedV_.set (turnedV_default_value ());
      }

      if (!offsetV_.present ())
      {
        this->offsetV_.set (offsetV_default_value ());
      }

      if (!scaleU_.present ())
      {
        this->scaleU_.set (scaleU_default_value ());
      }

      if (!scaleV_.present ())
      {
        this->scaleV_.set (scaleV_default_value ());
      }
    }

    Torus23CoreType* Torus23CoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Torus23CoreType (*this, f, c);
    }

    Torus23CoreType& Torus23CoreType::
    operator= (const Torus23CoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceCoreBaseType& > (*this) = x;
        this->DiameterMinor_ = x.DiameterMinor_;
        this->DiameterMajor_ = x.DiameterMajor_;
        this->Axis_ = x.Axis_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->turnedV_ = x.turnedV_;
        this->offsetV_ = x.offsetV_;
        this->scaleU_ = x.scaleU_;
        this->scaleV_ = x.scaleV_;
      }

      return *this;
    }

    Torus23CoreType::
    ~Torus23CoreType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Torus23CoreType >
    _xsd_Torus23CoreType_type_factory_init (
      L"Torus23CoreType",
      L"http://qifstandards.org/xsd/qif3");

    // Torus23Type
    //

    Torus23Type::
    Torus23Type ()
    : ::xsd::qif30::SurfaceBaseType (),
      Torus23Core_ (this),
      Transform_ (this)
    {
    }

    Torus23Type::
    Torus23Type (const id_type& id,
                 const Torus23Core_type& Torus23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Torus23Core_ (Torus23Core, this),
      Transform_ (this)
    {
    }

    Torus23Type::
    Torus23Type (const id_type& id,
                 ::std::unique_ptr< Torus23Core_type > Torus23Core)
    : ::xsd::qif30::SurfaceBaseType (id),
      Torus23Core_ (std::move (Torus23Core), this),
      Transform_ (this)
    {
    }

    Torus23Type::
    Torus23Type (const Torus23Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (x, f, c),
      Torus23Core_ (x.Torus23Core_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    Torus23Type::
    Torus23Type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceBaseType (e, f | ::xml_schema::flags::base, c),
      Torus23Core_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Torus23Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Torus23Core
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Torus23Core",
              L"http://qifstandards.org/xsd/qif3",
              &::xsd::cxx::tree::factory_impl< Torus23Core_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Torus23Core_.present ())
            {
              ::std::unique_ptr< Torus23Core_type > r (
                dynamic_cast< Torus23Core_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Torus23Core_.set (::std::move (r));
              continue;
            }
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Torus23Core_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Torus23Core",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    Torus23Type* Torus23Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Torus23Type (*this, f, c);
    }

    Torus23Type& Torus23Type::
    operator= (const Torus23Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceBaseType& > (*this) = x;
        this->Torus23Core_ = x.Torus23Core_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    Torus23Type::
    ~Torus23Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Torus23Type >
    _xsd_Torus23Type_type_factory_init (
      L"Torus23Type",
      L"http://qifstandards.org/xsd/qif3");

    // CurveMeshSetType
    //

    CurveMeshSetType::
    CurveMeshSetType ()
    : ::xml_schema::type (),
      PathTriangulation_ (this),
      n_ (this)
    {
    }

    CurveMeshSetType::
    CurveMeshSetType (const n_type& n)
    : ::xml_schema::type (),
      PathTriangulation_ (this),
      n_ (n, this)
    {
    }

    CurveMeshSetType::
    CurveMeshSetType (const CurveMeshSetType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PathTriangulation_ (x.PathTriangulation_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CurveMeshSetType::
    CurveMeshSetType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PathTriangulation_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CurveMeshSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PathTriangulation
        //
        if (n.name () == L"PathTriangulation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PathTriangulation_type > r (
            PathTriangulation_traits::create (i, f, this));

          this->PathTriangulation_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CurveMeshSetType* CurveMeshSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CurveMeshSetType (*this, f, c);
    }

    CurveMeshSetType& CurveMeshSetType::
    operator= (const CurveMeshSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PathTriangulation_ = x.PathTriangulation_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CurveMeshSetType::
    ~CurveMeshSetType ()
    {
    }

    // PathTriangulationCoreType
    //

    PathTriangulationCoreType::
    PathTriangulationCoreType ()
    : ::xml_schema::type (),
      Edges_ (this),
      EdgesBinary_ (this)
    {
    }

    PathTriangulationCoreType::
    PathTriangulationCoreType (const PathTriangulationCoreType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Edges_ (x.Edges_, f, this),
      EdgesBinary_ (x.EdgesBinary_, f, this)
    {
    }

    PathTriangulationCoreType::
    PathTriangulationCoreType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Edges_ (this),
      EdgesBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PathTriangulationCoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Edges
        //
        if (n.name () == L"Edges" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Edges_type > r (
            Edges_traits::create (i, f, this));

          if (!this->Edges_)
          {
            this->Edges_.set (::std::move (r));
            continue;
          }
        }

        // EdgesBinary
        //
        if (n.name () == L"EdgesBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgesBinary_type > r (
            EdgesBinary_traits::create (i, f, this));

          if (!this->EdgesBinary_)
          {
            this->EdgesBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PathTriangulationCoreType* PathTriangulationCoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PathTriangulationCoreType (*this, f, c);
    }

    PathTriangulationCoreType& PathTriangulationCoreType::
    operator= (const PathTriangulationCoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Edges_ = x.Edges_;
        this->EdgesBinary_ = x.EdgesBinary_;
      }

      return *this;
    }

    PathTriangulationCoreType::
    ~PathTriangulationCoreType ()
    {
    }

    // PathTriangulationType
    //

    PathTriangulationType::
    PathTriangulationType ()
    : ::xsd::qif30::GeometryBaseType (),
      PathTriangulationCore_ (this),
      MeshTriangle_ (this)
    {
    }

    PathTriangulationType::
    PathTriangulationType (const id_type& id,
                           const PathTriangulationCore_type& PathTriangulationCore,
                           const MeshTriangle_type& MeshTriangle)
    : ::xsd::qif30::GeometryBaseType (id),
      PathTriangulationCore_ (PathTriangulationCore, this),
      MeshTriangle_ (MeshTriangle, this)
    {
    }

    PathTriangulationType::
    PathTriangulationType (const id_type& id,
                           ::std::unique_ptr< PathTriangulationCore_type > PathTriangulationCore,
                           ::std::unique_ptr< MeshTriangle_type > MeshTriangle)
    : ::xsd::qif30::GeometryBaseType (id),
      PathTriangulationCore_ (std::move (PathTriangulationCore), this),
      MeshTriangle_ (std::move (MeshTriangle), this)
    {
    }

    PathTriangulationType::
    PathTriangulationType (const PathTriangulationType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (x, f, c),
      PathTriangulationCore_ (x.PathTriangulationCore_, f, this),
      MeshTriangle_ (x.MeshTriangle_, f, this)
    {
    }

    PathTriangulationType::
    PathTriangulationType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (e, f | ::xml_schema::flags::base, c),
      PathTriangulationCore_ (this),
      MeshTriangle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PathTriangulationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::GeometryBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PathTriangulationCore
        //
        if (n.name () == L"PathTriangulationCore" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PathTriangulationCore_type > r (
            PathTriangulationCore_traits::create (i, f, this));

          if (!PathTriangulationCore_.present ())
          {
            this->PathTriangulationCore_.set (::std::move (r));
            continue;
          }
        }

        // MeshTriangle
        //
        if (n.name () == L"MeshTriangle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeshTriangle_type > r (
            MeshTriangle_traits::create (i, f, this));

          if (!MeshTriangle_.present ())
          {
            this->MeshTriangle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PathTriangulationCore_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PathTriangulationCore",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MeshTriangle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MeshTriangle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PathTriangulationType* PathTriangulationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PathTriangulationType (*this, f, c);
    }

    PathTriangulationType& PathTriangulationType::
    operator= (const PathTriangulationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::GeometryBaseType& > (*this) = x;
        this->PathTriangulationCore_ = x.PathTriangulationCore_;
        this->MeshTriangle_ = x.MeshTriangle_;
      }

      return *this;
    }

    PathTriangulationType::
    ~PathTriangulationType ()
    {
    }

    // SurfaceMeshSetType
    //

    SurfaceMeshSetType::
    SurfaceMeshSetType ()
    : ::xml_schema::type (),
      MeshTriangle_ (this),
      n_ (this)
    {
    }

    SurfaceMeshSetType::
    SurfaceMeshSetType (const n_type& n)
    : ::xml_schema::type (),
      MeshTriangle_ (this),
      n_ (n, this)
    {
    }

    SurfaceMeshSetType::
    SurfaceMeshSetType (const SurfaceMeshSetType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeshTriangle_ (x.MeshTriangle_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SurfaceMeshSetType::
    SurfaceMeshSetType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeshTriangle_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceMeshSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeshTriangle
        //
        if (n.name () == L"MeshTriangle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeshTriangle_type > r (
            MeshTriangle_traits::create (i, f, this));

          this->MeshTriangle_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SurfaceMeshSetType* SurfaceMeshSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceMeshSetType (*this, f, c);
    }

    SurfaceMeshSetType& SurfaceMeshSetType::
    operator= (const SurfaceMeshSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeshTriangle_ = x.MeshTriangle_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SurfaceMeshSetType::
    ~SurfaceMeshSetType ()
    {
    }

    // MeshTriangleCoreType
    //

    MeshTriangleCoreType::
    MeshTriangleCoreType ()
    : ::xml_schema::type (),
      Triangles_ (this),
      TrianglesBinary_ (this),
      Neighbours_ (this),
      NeighboursBinary_ (this),
      Vertices_ (this),
      VerticesBinary_ (this),
      Normals_ (this),
      NormalsBinary_ (this)
    {
    }

    MeshTriangleCoreType::
    MeshTriangleCoreType (const MeshTriangleCoreType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Triangles_ (x.Triangles_, f, this),
      TrianglesBinary_ (x.TrianglesBinary_, f, this),
      Neighbours_ (x.Neighbours_, f, this),
      NeighboursBinary_ (x.NeighboursBinary_, f, this),
      Vertices_ (x.Vertices_, f, this),
      VerticesBinary_ (x.VerticesBinary_, f, this),
      Normals_ (x.Normals_, f, this),
      NormalsBinary_ (x.NormalsBinary_, f, this)
    {
    }

    MeshTriangleCoreType::
    MeshTriangleCoreType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Triangles_ (this),
      TrianglesBinary_ (this),
      Neighbours_ (this),
      NeighboursBinary_ (this),
      Vertices_ (this),
      VerticesBinary_ (this),
      Normals_ (this),
      NormalsBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeshTriangleCoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Triangles
        //
        if (n.name () == L"Triangles" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Triangles_type > r (
            Triangles_traits::create (i, f, this));

          if (!this->Triangles_)
          {
            this->Triangles_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesBinary
        //
        if (n.name () == L"TrianglesBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesBinary_type > r (
            TrianglesBinary_traits::create (i, f, this));

          if (!this->TrianglesBinary_)
          {
            this->TrianglesBinary_.set (::std::move (r));
            continue;
          }
        }

        // Neighbours
        //
        if (n.name () == L"Neighbours" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Neighbours_type > r (
            Neighbours_traits::create (i, f, this));

          if (!this->Neighbours_)
          {
            this->Neighbours_.set (::std::move (r));
            continue;
          }
        }

        // NeighboursBinary
        //
        if (n.name () == L"NeighboursBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NeighboursBinary_type > r (
            NeighboursBinary_traits::create (i, f, this));

          if (!this->NeighboursBinary_)
          {
            this->NeighboursBinary_.set (::std::move (r));
            continue;
          }
        }

        // Vertices
        //
        if (n.name () == L"Vertices" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vertices_type > r (
            Vertices_traits::create (i, f, this));

          if (!this->Vertices_)
          {
            this->Vertices_.set (::std::move (r));
            continue;
          }
        }

        // VerticesBinary
        //
        if (n.name () == L"VerticesBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VerticesBinary_type > r (
            VerticesBinary_traits::create (i, f, this));

          if (!this->VerticesBinary_)
          {
            this->VerticesBinary_.set (::std::move (r));
            continue;
          }
        }

        // Normals
        //
        if (n.name () == L"Normals" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normals_type > r (
            Normals_traits::create (i, f, this));

          if (!this->Normals_)
          {
            this->Normals_.set (::std::move (r));
            continue;
          }
        }

        // NormalsBinary
        //
        if (n.name () == L"NormalsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NormalsBinary_type > r (
            NormalsBinary_traits::create (i, f, this));

          if (!this->NormalsBinary_)
          {
            this->NormalsBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MeshTriangleCoreType* MeshTriangleCoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeshTriangleCoreType (*this, f, c);
    }

    MeshTriangleCoreType& MeshTriangleCoreType::
    operator= (const MeshTriangleCoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Triangles_ = x.Triangles_;
        this->TrianglesBinary_ = x.TrianglesBinary_;
        this->Neighbours_ = x.Neighbours_;
        this->NeighboursBinary_ = x.NeighboursBinary_;
        this->Vertices_ = x.Vertices_;
        this->VerticesBinary_ = x.VerticesBinary_;
        this->Normals_ = x.Normals_;
        this->NormalsBinary_ = x.NormalsBinary_;
      }

      return *this;
    }

    MeshTriangleCoreType::
    ~MeshTriangleCoreType ()
    {
    }

    // TriangleVertexNormalType
    //

    TriangleVertexNormalType::
    TriangleVertexNormalType ()
    : ::xsd::qif30::UnitVectorType (),
      vertex_ (this)
    {
    }

    TriangleVertexNormalType::
    TriangleVertexNormalType (const vertex_type& vertex)
    : ::xsd::qif30::UnitVectorType (),
      vertex_ (vertex, this)
    {
    }

    TriangleVertexNormalType::
    TriangleVertexNormalType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base,
                              const vertex_type& vertex)
    : ::xsd::qif30::UnitVectorType (_xsd_ListDoubleType_base),
      vertex_ (vertex, this)
    {
    }

    TriangleVertexNormalType::
    TriangleVertexNormalType (const TriangleVertexNormalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::UnitVectorType (x, f, c),
      vertex_ (x.vertex_, f, this)
    {
    }

    TriangleVertexNormalType::
    TriangleVertexNormalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::UnitVectorType (e, f | ::xml_schema::flags::base, c),
      vertex_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TriangleVertexNormalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::UnitVectorType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"vertex" && n.namespace_ ().empty ())
        {
          this->vertex_.set (vertex_traits::create (i, f, this));
          continue;
        }
      }

      if (!vertex_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"vertex",
          L"");
      }
    }

    TriangleVertexNormalType* TriangleVertexNormalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TriangleVertexNormalType (*this, f, c);
    }

    TriangleVertexNormalType& TriangleVertexNormalType::
    operator= (const TriangleVertexNormalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UnitVectorType& > (*this) = x;
        this->vertex_ = x.vertex_;
      }

      return *this;
    }

    TriangleVertexNormalType::
    ~TriangleVertexNormalType ()
    {
    }

    // ArrayTriangleVertexNormalType
    //

    ArrayTriangleVertexNormalType::
    ArrayTriangleVertexNormalType ()
    : ::xml_schema::type (),
      NormalSpecial_ (this),
      n_ (this)
    {
    }

    ArrayTriangleVertexNormalType::
    ArrayTriangleVertexNormalType (const n_type& n)
    : ::xml_schema::type (),
      NormalSpecial_ (this),
      n_ (n, this)
    {
    }

    ArrayTriangleVertexNormalType::
    ArrayTriangleVertexNormalType (const ArrayTriangleVertexNormalType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NormalSpecial_ (x.NormalSpecial_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ArrayTriangleVertexNormalType::
    ArrayTriangleVertexNormalType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NormalSpecial_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArrayTriangleVertexNormalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NormalSpecial
        //
        if (n.name () == L"NormalSpecial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NormalSpecial_type > r (
            NormalSpecial_traits::create (i, f, this));

          this->NormalSpecial_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ArrayTriangleVertexNormalType* ArrayTriangleVertexNormalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayTriangleVertexNormalType (*this, f, c);
    }

    ArrayTriangleVertexNormalType& ArrayTriangleVertexNormalType::
    operator= (const ArrayTriangleVertexNormalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NormalSpecial_ = x.NormalSpecial_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ArrayTriangleVertexNormalType::
    ~ArrayTriangleVertexNormalType ()
    {
    }

    // MeshTriangleType
    //

    MeshTriangleType::
    MeshTriangleType ()
    : ::xsd::qif30::GeometryBaseType (),
      MeshTriangleCore_ (this),
      NormalsSpecial_ (this),
      NormalsSpecialBinary_ (this)
    {
    }

    MeshTriangleType::
    MeshTriangleType (const id_type& id,
                      const MeshTriangleCore_type& MeshTriangleCore)
    : ::xsd::qif30::GeometryBaseType (id),
      MeshTriangleCore_ (MeshTriangleCore, this),
      NormalsSpecial_ (this),
      NormalsSpecialBinary_ (this)
    {
    }

    MeshTriangleType::
    MeshTriangleType (const id_type& id,
                      ::std::unique_ptr< MeshTriangleCore_type > MeshTriangleCore)
    : ::xsd::qif30::GeometryBaseType (id),
      MeshTriangleCore_ (std::move (MeshTriangleCore), this),
      NormalsSpecial_ (this),
      NormalsSpecialBinary_ (this)
    {
    }

    MeshTriangleType::
    MeshTriangleType (const MeshTriangleType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (x, f, c),
      MeshTriangleCore_ (x.MeshTriangleCore_, f, this),
      NormalsSpecial_ (x.NormalsSpecial_, f, this),
      NormalsSpecialBinary_ (x.NormalsSpecialBinary_, f, this)
    {
    }

    MeshTriangleType::
    MeshTriangleType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::GeometryBaseType (e, f | ::xml_schema::flags::base, c),
      MeshTriangleCore_ (this),
      NormalsSpecial_ (this),
      NormalsSpecialBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeshTriangleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::GeometryBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeshTriangleCore
        //
        if (n.name () == L"MeshTriangleCore" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeshTriangleCore_type > r (
            MeshTriangleCore_traits::create (i, f, this));

          if (!MeshTriangleCore_.present ())
          {
            this->MeshTriangleCore_.set (::std::move (r));
            continue;
          }
        }

        // NormalsSpecial
        //
        if (n.name () == L"NormalsSpecial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NormalsSpecial_type > r (
            NormalsSpecial_traits::create (i, f, this));

          if (!this->NormalsSpecial_)
          {
            this->NormalsSpecial_.set (::std::move (r));
            continue;
          }
        }

        // NormalsSpecialBinary
        //
        if (n.name () == L"NormalsSpecialBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NormalsSpecialBinary_type > r (
            NormalsSpecialBinary_traits::create (i, f, this));

          if (!this->NormalsSpecialBinary_)
          {
            this->NormalsSpecialBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!MeshTriangleCore_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MeshTriangleCore",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MeshTriangleType* MeshTriangleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeshTriangleType (*this, f, c);
    }

    MeshTriangleType& MeshTriangleType::
    operator= (const MeshTriangleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::GeometryBaseType& > (*this) = x;
        this->MeshTriangleCore_ = x.MeshTriangleCore_;
        this->NormalsSpecial_ = x.NormalsSpecial_;
        this->NormalsSpecialBinary_ = x.NormalsSpecialBinary_;
      }

      return *this;
    }

    MeshTriangleType::
    ~MeshTriangleType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Segment13Core_element_factory_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Segment13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Segment13CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Segment12Core_element_factory_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Segment12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Segment12CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Segment13_element_factory_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Segment13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Segment13Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Segment12_element_factory_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Segment12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Segment12Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArcConic13Core_element_factory_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcConic13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArcConic13CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArcConic12Core_element_factory_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcConic12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArcConic12CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArcConic13_element_factory_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcConic13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArcConic13Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArcConic12_element_factory_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcConic12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArcConic12Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArcCircular13Core_element_factory_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcCircular13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArcCircular13CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArcCircular12Core_element_factory_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcCircular12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArcCircular12CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArcCircular13_element_factory_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcCircular13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArcCircular13Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArcCircular12_element_factory_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcCircular12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArcCircular12Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Nurbs12Core_element_factory_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Nurbs12CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Nurbs13Core_element_factory_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Nurbs13CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Nurbs13_element_factory_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Nurbs13Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Nurbs12_element_factory_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Nurbs12Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Spline13Core_element_factory_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Spline13CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Spline12Core_element_factory_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Spline12CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Spline13_element_factory_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Spline13Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Spline12_element_factory_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Spline12Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Aggregate12Core_element_factory_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Aggregate12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Aggregate12CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Aggregate13Core_element_factory_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Aggregate13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Aggregate13CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Aggregate12_element_factory_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Aggregate12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Aggregate12Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Aggregate13_element_factory_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Aggregate13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Aggregate13Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Polyline13Core_element_factory_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Polyline13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Polyline13CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Polyline12Core_element_factory_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Polyline12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Polyline12CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Polyline13_element_factory_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Polyline13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Polyline13Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Polyline12_element_factory_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Polyline12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Polyline12Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Nurbs23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Nurbs23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Nurbs23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Nurbs23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Spline23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Spline23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Spline23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Spline23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Revolution23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Revolution23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Revolution23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Revolution23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Revolution23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Revolution23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Extrude23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Extrude23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Extrude23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Extrude23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Extrude23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Extrude23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Ruled23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Ruled23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Ruled23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Ruled23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Ruled23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Ruled23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Offset23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Offset23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Offset23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Offset23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Offset23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Offset23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Plane23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Plane23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Plane23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Plane23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Plane23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Plane23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cone23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Cone23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Cone23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cone23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Cone23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Cone23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cylinder23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Cylinder23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Cylinder23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Cylinder23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Cylinder23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Cylinder23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Sphere23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Sphere23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Sphere23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Sphere23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Sphere23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Sphere23Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Torus23Core_element_factory_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Torus23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Torus23CoreType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Torus23_element_factory_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Torus23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::Torus23Type >);
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const GeometrySetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSet
      //
      if (i.PointSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointSet ();
      }

      // Curve12Set
      //
      if (i.Curve12Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Curve12Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Curve12Set ();
      }

      // Curve13Set
      //
      if (i.Curve13Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Curve13Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Curve13Set ();
      }

      // SurfaceSet
      //
      if (i.SurfaceSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfaceSet ();
      }

      // CurveMeshSet
      //
      if (i.CurveMeshSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveMeshSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CurveMeshSet ();
      }

      // SurfaceMeshSet
      //
      if (i.SurfaceMeshSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceMeshSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfaceMeshSet ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const GeometryBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::NodeWithIdBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Point
      //
      for (PointSetType::Point_const_iterator
           b (i.Point ().begin ()), n (i.Point ().end ());
           b != n; ++b)
      {
        const PointSetType::Point_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointEntityType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometryBaseType& > (i);

      // XYZ
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XYZ",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XYZ ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Curve12SetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Curve12
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (Curve12SetType::Curve12_const_iterator
             b (i.Curve12 ().begin ()), n (i.Curve12 ().end ());
             b != n; ++b)
        {
          const Curve12SetType::Curve12_type& x (*b);

          if (typeid (Curve12SetType::Curve12_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Curve12",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Curve12",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Curve13SetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Curve13
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (Curve13SetType::Curve13_const_iterator
             b (i.Curve13 ().begin ()), n (i.Curve13 ().end ());
             b != n; ++b)
        {
          const Curve13SetType::Curve13_type& x (*b);

          if (typeid (Curve13SetType::Curve13_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Curve13",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Curve13",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Curve13CoreType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Curve13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Curve13CoreType::Curve13Core_type& x (i.Curve13Core ());
        if (typeid (Curve13CoreType::Curve13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Curve13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Curve13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CurveCoreBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // domain
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"domain",
            e));

        a << i.domain ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Curve12BaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometryBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const Curve13BaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometryBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const Segment13CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // StartPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StartPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.StartPoint ();
      }

      // EndPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndPoint ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Segment13CoreType >
    _xsd_Segment13CoreType_type_serializer_init (
      L"Segment13CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Segment12CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // StartPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StartPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.StartPoint ();
      }

      // EndPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndPoint ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Segment12CoreType >
    _xsd_Segment12CoreType_type_serializer_init (
      L"Segment12CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Segment13Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve13BaseType& > (i);

      // Segment13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Segment13Type::Segment13Core_type& x (i.Segment13Core ());
        if (typeid (Segment13Type::Segment13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Segment13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Segment13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Segment13Type >
    _xsd_Segment13Type_type_serializer_init (
      L"Segment13Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Segment12Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve12BaseType& > (i);

      // Segment12Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Segment12Type::Segment12Core_type& x (i.Segment12Core ());
        if (typeid (Segment12Type::Segment12Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Segment12Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Segment12Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Segment12Type >
    _xsd_Segment12Type_type_serializer_init (
      L"Segment12Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArcConicFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ArcConicFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ArcConicFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ArcConic13CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // A
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"A",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.A ());
      }

      // B
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"B",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.B ());
      }

      // Center
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Center",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Center ();
      }

      // DirBeg
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirBeg",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirBeg ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // form
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"form",
            e));

        a << i.form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArcConic13CoreType >
    _xsd_ArcConic13CoreType_type_serializer_init (
      L"ArcConic13CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArcConic12CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // A
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"A",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.A ());
      }

      // B
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"B",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.B ());
      }

      // Center
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Center",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Center ();
      }

      // DirBeg
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirBeg",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirBeg ();
      }

      // form
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"form",
            e));

        a << i.form ();
      }

      // turned
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turned",
            e));

        a << i.turned ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArcConic12CoreType >
    _xsd_ArcConic12CoreType_type_serializer_init (
      L"ArcConic12CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArcConic12Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve12BaseType& > (i);

      // ArcConic12Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ArcConic12Type::ArcConic12Core_type& x (i.ArcConic12Core ());
        if (typeid (ArcConic12Type::ArcConic12Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ArcConic12Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"ArcConic12Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArcConic12Type >
    _xsd_ArcConic12Type_type_serializer_init (
      L"ArcConic12Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArcConic13Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve13BaseType& > (i);

      // ArcConic13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ArcConic13Type::ArcConic13Core_type& x (i.ArcConic13Core ());
        if (typeid (ArcConic13Type::ArcConic13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ArcConic13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"ArcConic13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArcConic13Type >
    _xsd_ArcConic13Type_type_serializer_init (
      L"ArcConic13Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArcCircular13CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // Radius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Radius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Radius ());
      }

      // Center
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Center",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Center ();
      }

      // DirBeg
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirBeg",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirBeg ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArcCircular13CoreType >
    _xsd_ArcCircular13CoreType_type_serializer_init (
      L"ArcCircular13CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArcCircular12CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // Radius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Radius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Radius ());
      }

      // Center
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Center",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Center ();
      }

      // DirBeg
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirBeg",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirBeg ();
      }

      // turned
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turned",
            e));

        a << i.turned ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArcCircular12CoreType >
    _xsd_ArcCircular12CoreType_type_serializer_init (
      L"ArcCircular12CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArcCircular13Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve13BaseType& > (i);

      // ArcCircular13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ArcCircular13Type::ArcCircular13Core_type& x (i.ArcCircular13Core ());
        if (typeid (ArcCircular13Type::ArcCircular13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ArcCircular13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"ArcCircular13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArcCircular13Type >
    _xsd_ArcCircular13Type_type_serializer_init (
      L"ArcCircular13Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArcCircular12Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve12BaseType& > (i);

      // ArcCircular12Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ArcCircular12Type::ArcCircular12Core_type& x (i.ArcCircular12Core ());
        if (typeid (ArcCircular12Type::ArcCircular12Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ArcCircular12Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"ArcCircular12Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArcCircular12Type >
    _xsd_ArcCircular12Type_type_serializer_init (
      L"ArcCircular12Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Nurbs12CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // Order
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Order",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Order ();
      }

      // Knots
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Knots",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Knots ();
      }

      // CPs
      //
      if (i.CPs ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CPs",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CPs ();
      }

      // CPsBinary
      //
      if (i.CPsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CPsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CPsBinary ();
      }

      // Weights
      //
      if (i.Weights ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Weights",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Weights ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Nurbs12CoreType >
    _xsd_Nurbs12CoreType_type_serializer_init (
      L"Nurbs12CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Nurbs13CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // Order
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Order",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Order ();
      }

      // Knots
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Knots",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Knots ();
      }

      // CPs
      //
      if (i.CPs ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CPs",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CPs ();
      }

      // CPsBinary
      //
      if (i.CPsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CPsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CPsBinary ();
      }

      // Weights
      //
      if (i.Weights ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Weights",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Weights ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Nurbs13CoreType >
    _xsd_Nurbs13CoreType_type_serializer_init (
      L"Nurbs13CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Nurbs12Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve12BaseType& > (i);

      // Nurbs12Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Nurbs12Type::Nurbs12Core_type& x (i.Nurbs12Core ());
        if (typeid (Nurbs12Type::Nurbs12Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Nurbs12Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Nurbs12Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Nurbs12Type >
    _xsd_Nurbs12Type_type_serializer_init (
      L"Nurbs12Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Nurbs13Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve13BaseType& > (i);

      // Nurbs13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Nurbs13Type::Nurbs13Core_type& x (i.Nurbs13Core ());
        if (typeid (Nurbs13Type::Nurbs13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Nurbs13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Nurbs13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Nurbs13Type >
    _xsd_Nurbs13Type_type_serializer_init (
      L"Nurbs13Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Spline13CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // Knots
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Knots",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Knots ();
      }

      // Orders
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Orders",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Orders ();
      }

      // Coefficients
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Coefficients",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Coefficients ();
      }

      // normalized
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"normalized",
            e));

        a << i.normalized ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Spline13CoreType >
    _xsd_Spline13CoreType_type_serializer_init (
      L"Spline13CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Spline12CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // Knots
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Knots",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Knots ();
      }

      // Orders
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Orders",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Orders ();
      }

      // Coefficients
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Coefficients",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Coefficients ();
      }

      // normalized
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"normalized",
            e));

        a << i.normalized ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Spline12CoreType >
    _xsd_Spline12CoreType_type_serializer_init (
      L"Spline12CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Spline13Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve13BaseType& > (i);

      // Spline13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Spline13Type::Spline13Core_type& x (i.Spline13Core ());
        if (typeid (Spline13Type::Spline13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Spline13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Spline13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Spline13Type >
    _xsd_Spline13Type_type_serializer_init (
      L"Spline13Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Spline12Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve12BaseType& > (i);

      // Spline12Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Spline12Type::Spline12Core_type& x (i.Spline12Core ());
        if (typeid (Spline12Type::Spline12Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Spline12Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Spline12Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Spline12Type >
    _xsd_Spline12Type_type_serializer_init (
      L"Spline12Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Curve12OrientedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Curve12Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Curve12OrientedType::Curve12Core_type& x (i.Curve12Core ());
        if (typeid (Curve12OrientedType::Curve12Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Curve12Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Curve12Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // turned
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turned",
            e));

        a << i.turned ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArraySubCurve12Type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SubCurve
      //
      for (ArraySubCurve12Type::SubCurve_const_iterator
           b (i.SubCurve ().begin ()), n (i.SubCurve ().end ());
           b != n; ++b)
      {
        const ArraySubCurve12Type::SubCurve_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubCurve",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Aggregate12CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // SubCurves
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubCurves",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SubCurves ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Aggregate12CoreType >
    _xsd_Aggregate12CoreType_type_serializer_init (
      L"Aggregate12CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Curve13OrientedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Curve13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Curve13OrientedType::Curve13Core_type& x (i.Curve13Core ());
        if (typeid (Curve13OrientedType::Curve13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Curve13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Curve13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // turned
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turned",
            e));

        a << i.turned ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArraySubCurve13Type& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SubCurve
      //
      for (ArraySubCurve13Type::SubCurve_const_iterator
           b (i.SubCurve ().begin ()), n (i.SubCurve ().end ());
           b != n; ++b)
      {
        const ArraySubCurve13Type::SubCurve_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubCurve",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Aggregate13CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // SubCurves
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubCurves",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SubCurves ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Aggregate13CoreType >
    _xsd_Aggregate13CoreType_type_serializer_init (
      L"Aggregate13CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Aggregate12Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve12BaseType& > (i);

      // Aggregate12Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Aggregate12Type::Aggregate12Core_type& x (i.Aggregate12Core ());
        if (typeid (Aggregate12Type::Aggregate12Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Aggregate12Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Aggregate12Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Aggregate12Type >
    _xsd_Aggregate12Type_type_serializer_init (
      L"Aggregate12Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Aggregate13Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve13BaseType& > (i);

      // Aggregate13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Aggregate13Type::Aggregate13Core_type& x (i.Aggregate13Core ());
        if (typeid (Aggregate13Type::Aggregate13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Aggregate13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Aggregate13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Aggregate13Type >
    _xsd_Aggregate13Type_type_serializer_init (
      L"Aggregate13Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Polyline13CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // Points
      //
      if (i.Points ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Points ();
      }

      // PointsBinary
      //
      if (i.PointsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsBinary ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Polyline13CoreType >
    _xsd_Polyline13CoreType_type_serializer_init (
      L"Polyline13CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Polyline12CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveCoreBaseType& > (i);

      // Points
      //
      if (i.Points ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Points ();
      }

      // PointsBinary
      //
      if (i.PointsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsBinary ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Polyline12CoreType >
    _xsd_Polyline12CoreType_type_serializer_init (
      L"Polyline12CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Polyline13Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve13BaseType& > (i);

      // Polyline13Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Polyline13Type::Polyline13Core_type& x (i.Polyline13Core ());
        if (typeid (Polyline13Type::Polyline13Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Polyline13Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Polyline13Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Polyline13Type >
    _xsd_Polyline13Type_type_serializer_init (
      L"Polyline13Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Polyline12Type& i)
    {
      e << static_cast< const ::xsd::qif30::Curve12BaseType& > (i);

      // Polyline12Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Polyline12Type::Polyline12Core_type& x (i.Polyline12Core ());
        if (typeid (Polyline12Type::Polyline12Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Polyline12Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Polyline12Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Polyline12Type >
    _xsd_Polyline12Type_type_serializer_init (
      L"Polyline12Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometryBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Surface
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SurfaceSetType::Surface_const_iterator
             b (i.Surface ().begin ()), n (i.Surface ().end ());
             b != n; ++b)
        {
          const SurfaceSetType::Surface_type& x (*b);

          if (typeid (SurfaceSetType::Surface_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Surface",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Surface",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceCoreType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SurfaceCore
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const SurfaceCoreType::SurfaceCore_type& x (i.SurfaceCore ());
        if (typeid (SurfaceCoreType::SurfaceCore_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"SurfaceCore",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"SurfaceCore",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceCoreBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // form
      //
      if (i.form ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"form",
            e));

        a << *i.form ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const Attr23CoreEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const Attr23CoreEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const Attr23CoreEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const Nurbs23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // OrderU
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OrderU",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.OrderU ();
      }

      // OrderV
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OrderV",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.OrderV ();
      }

      // KnotsU
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"KnotsU",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.KnotsU ();
      }

      // KnotsV
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"KnotsV",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.KnotsV ();
      }

      // CPs
      //
      if (i.CPs ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CPs",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CPs ();
      }

      // CPsBinary
      //
      if (i.CPsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CPsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CPsBinary ();
      }

      // Weights
      //
      if (i.Weights ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Weights",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Weights ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Nurbs23CoreType >
    _xsd_Nurbs23CoreType_type_serializer_init (
      L"Nurbs23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Nurbs23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Nurbs23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Nurbs23Type::Nurbs23Core_type& x (i.Nurbs23Core ());
        if (typeid (Nurbs23Type::Nurbs23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Nurbs23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Nurbs23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Nurbs23Type >
    _xsd_Nurbs23Type_type_serializer_init (
      L"Nurbs23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Spline23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // KnotsU
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"KnotsU",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.KnotsU ();
      }

      // KnotsV
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"KnotsV",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.KnotsV ();
      }

      // OrdersU
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OrdersU",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.OrdersU ();
      }

      // OrdersV
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OrdersV",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.OrdersV ();
      }

      // Coefficients
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Coefficients",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Coefficients ();
      }

      // normalized
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"normalized",
            e));

        a << i.normalized ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Spline23CoreType >
    _xsd_Spline23CoreType_type_serializer_init (
      L"Spline23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Spline23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Spline23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Spline23Type::Spline23Core_type& x (i.Spline23Core ());
        if (typeid (Spline23Type::Spline23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Spline23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Spline23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Spline23Type >
    _xsd_Spline23Type_type_serializer_init (
      L"Spline23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Revolution23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Generatrix
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Generatrix",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Generatrix ();
      }

      // angle
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"angle",
            e));

        a << i.angle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Revolution23CoreType >
    _xsd_Revolution23CoreType_type_serializer_init (
      L"Revolution23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Revolution23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Revolution23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Revolution23Type::Revolution23Core_type& x (i.Revolution23Core ());
        if (typeid (Revolution23Type::Revolution23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Revolution23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Revolution23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Revolution23Type >
    _xsd_Revolution23Type_type_serializer_init (
      L"Revolution23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Extrude23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // TerminationPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TerminationPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TerminationPoint ();
      }

      // Curve
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Curve",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Curve ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Extrude23CoreType >
    _xsd_Extrude23CoreType_type_serializer_init (
      L"Extrude23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Extrude23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Extrude23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Extrude23Type::Extrude23Core_type& x (i.Extrude23Core ());
        if (typeid (Extrude23Type::Extrude23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Extrude23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Extrude23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Extrude23Type >
    _xsd_Extrude23Type_type_serializer_init (
      L"Extrude23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Ruled23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // Curve
      //
      for (Ruled23CoreType::Curve_const_iterator
           b (i.Curve ().begin ()), n (i.Curve ().end ());
           b != n; ++b)
      {
        const Ruled23CoreType::Curve_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Curve",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // turnedSecondCurve
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turnedSecondCurve",
            e));

        a << i.turnedSecondCurve ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Ruled23CoreType >
    _xsd_Ruled23CoreType_type_serializer_init (
      L"Ruled23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Ruled23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Ruled23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Ruled23Type::Ruled23Core_type& x (i.Ruled23Core ());
        if (typeid (Ruled23Type::Ruled23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Ruled23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Ruled23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Ruled23Type >
    _xsd_Ruled23Type_type_serializer_init (
      L"Ruled23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Offset23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // Distance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Distance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Distance ());
      }

      // Surface
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Surface",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Surface ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Offset23CoreType >
    _xsd_Offset23CoreType_type_serializer_init (
      L"Offset23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Offset23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Offset23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Offset23Type::Offset23Core_type& x (i.Offset23Core ());
        if (typeid (Offset23Type::Offset23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Offset23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Offset23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Offset23Type >
    _xsd_Offset23Type_type_serializer_init (
      L"Offset23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Plane23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // Origin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Origin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Origin ();
      }

      // DirU
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirU",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirU ();
      }

      // DirV
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirV",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirV ();
      }

      // domainU
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"domainU",
            e));

        a << i.domainU ();
      }

      // domainV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"domainV",
            e));

        a << i.domainV ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Plane23CoreType >
    _xsd_Plane23CoreType_type_serializer_init (
      L"Plane23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Plane23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Plane23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Plane23Type::Plane23Core_type& x (i.Plane23Core ());
        if (typeid (Plane23Type::Plane23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Plane23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Plane23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Plane23Type >
    _xsd_Plane23Type_type_serializer_init (
      L"Plane23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Cone23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // DiameterBottom
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterBottom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.DiameterBottom ());
      }

      // DiameterTop
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterTop",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.DiameterTop ());
      }

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Length ());
      }

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Sweep ();
      }

      // turnedV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turnedV",
            e));

        a << i.turnedV ();
      }

      // scaleU
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"scaleU",
            e));

        a << i.scaleU ();
      }

      // scaleV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"scaleV",
            e));

        a << i.scaleV ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Cone23CoreType >
    _xsd_Cone23CoreType_type_serializer_init (
      L"Cone23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Cone23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Cone23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Cone23Type::Cone23Core_type& x (i.Cone23Core ());
        if (typeid (Cone23Type::Cone23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Cone23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Cone23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Cone23Type >
    _xsd_Cone23Type_type_serializer_init (
      L"Cone23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Cylinder23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Diameter ());
      }

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Length ());
      }

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Sweep ();
      }

      // turnedV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turnedV",
            e));

        a << i.turnedV ();
      }

      // scaleU
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"scaleU",
            e));

        a << i.scaleU ();
      }

      // scaleV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"scaleV",
            e));

        a << i.scaleV ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Cylinder23CoreType >
    _xsd_Cylinder23CoreType_type_serializer_init (
      L"Cylinder23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Cylinder23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Cylinder23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Cylinder23Type::Cylinder23Core_type& x (i.Cylinder23Core ());
        if (typeid (Cylinder23Type::Cylinder23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Cylinder23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Cylinder23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Cylinder23Type >
    _xsd_Cylinder23Type_type_serializer_init (
      L"Cylinder23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Sphere23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.Diameter ());
      }

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // LatitudeLongitudeSweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LatitudeLongitudeSweep ();
      }

      // turnedV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turnedV",
            e));

        a << i.turnedV ();
      }

      // scaleU
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"scaleU",
            e));

        a << i.scaleU ();
      }

      // scaleV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"scaleV",
            e));

        a << i.scaleV ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Sphere23CoreType >
    _xsd_Sphere23CoreType_type_serializer_init (
      L"Sphere23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Sphere23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Sphere23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Sphere23Type::Sphere23Core_type& x (i.Sphere23Core ());
        if (typeid (Sphere23Type::Sphere23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Sphere23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Sphere23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Sphere23Type >
    _xsd_Sphere23Type_type_serializer_init (
      L"Sphere23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Torus23CoreType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceCoreBaseType& > (i);

      // DiameterMinor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMinor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.DiameterMinor ());
      }

      // DiameterMajor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMajor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(i.DiameterMajor ());
      }

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // LatitudeLongitudeSweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LatitudeLongitudeSweep ();
      }

      // turnedV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turnedV",
            e));

        a << i.turnedV ();
      }

      // offsetV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"offsetV",
            e));

        a << ::xml_schema::as_double(i.offsetV ());
      }

      // scaleU
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"scaleU",
            e));

        a << i.scaleU ();
      }

      // scaleV
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"scaleV",
            e));

        a << i.scaleV ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Torus23CoreType >
    _xsd_Torus23CoreType_type_serializer_init (
      L"Torus23CoreType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const Torus23Type& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceBaseType& > (i);

      // Torus23Core
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Torus23Type::Torus23Core_type& x (i.Torus23Core ());
        if (typeid (Torus23Type::Torus23Core_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Torus23Core",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Torus23Core",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Torus23Type >
    _xsd_Torus23Type_type_serializer_init (
      L"Torus23Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CurveMeshSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PathTriangulation
      //
      for (CurveMeshSetType::PathTriangulation_const_iterator
           b (i.PathTriangulation ().begin ()), n (i.PathTriangulation ().end ());
           b != n; ++b)
      {
        const CurveMeshSetType::PathTriangulation_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PathTriangulation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PathTriangulationCoreType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Edges
      //
      if (i.Edges ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Edges",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Edges ();
      }

      // EdgesBinary
      //
      if (i.EdgesBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgesBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EdgesBinary ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PathTriangulationType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometryBaseType& > (i);

      // PathTriangulationCore
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PathTriangulationCore",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PathTriangulationCore ();
      }

      // MeshTriangle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeshTriangle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MeshTriangle ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceMeshSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeshTriangle
      //
      for (SurfaceMeshSetType::MeshTriangle_const_iterator
           b (i.MeshTriangle ().begin ()), n (i.MeshTriangle ().end ());
           b != n; ++b)
      {
        const SurfaceMeshSetType::MeshTriangle_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeshTriangle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeshTriangleCoreType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Triangles
      //
      if (i.Triangles ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Triangles",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Triangles ();
      }

      // TrianglesBinary
      //
      if (i.TrianglesBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesBinary ();
      }

      // Neighbours
      //
      if (i.Neighbours ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Neighbours",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Neighbours ();
      }

      // NeighboursBinary
      //
      if (i.NeighboursBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NeighboursBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NeighboursBinary ();
      }

      // Vertices
      //
      if (i.Vertices ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vertices",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Vertices ();
      }

      // VerticesBinary
      //
      if (i.VerticesBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VerticesBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VerticesBinary ();
      }

      // Normals
      //
      if (i.Normals ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normals",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normals ();
      }

      // NormalsBinary
      //
      if (i.NormalsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NormalsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NormalsBinary ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TriangleVertexNormalType& i)
    {
      e << static_cast< const ::xsd::qif30::UnitVectorType& > (i);

      // vertex
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"vertex",
            e));

        a << i.vertex ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayTriangleVertexNormalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NormalSpecial
      //
      for (ArrayTriangleVertexNormalType::NormalSpecial_const_iterator
           b (i.NormalSpecial ().begin ()), n (i.NormalSpecial ().end ());
           b != n; ++b)
      {
        const ArrayTriangleVertexNormalType::NormalSpecial_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NormalSpecial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeshTriangleType& i)
    {
      e << static_cast< const ::xsd::qif30::GeometryBaseType& > (i);

      // MeshTriangleCore
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeshTriangleCore",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MeshTriangleCore ();
      }

      // NormalsSpecial
      //
      if (i.NormalsSpecial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NormalsSpecial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NormalsSpecial ();
      }

      // NormalsSpecialBinary
      //
      if (i.NormalsSpecialBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NormalsSpecialBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NormalsSpecialBinary ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Segment13CoreType >
    _xsd_Segment13Core_element_serializer_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Segment13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Segment13CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Segment12CoreType >
    _xsd_Segment12Core_element_serializer_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Segment12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Segment12CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Segment13Type >
    _xsd_Segment13_element_serializer_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Segment13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Segment13Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Segment12Type >
    _xsd_Segment12_element_serializer_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Segment12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Segment12Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArcConic13CoreType >
    _xsd_ArcConic13Core_element_serializer_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcConic13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArcConic13CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArcConic12CoreType >
    _xsd_ArcConic12Core_element_serializer_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcConic12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArcConic12CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArcConic13Type >
    _xsd_ArcConic13_element_serializer_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcConic13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArcConic13Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArcConic12Type >
    _xsd_ArcConic12_element_serializer_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcConic12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArcConic12Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArcCircular13CoreType >
    _xsd_ArcCircular13Core_element_serializer_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcCircular13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArcCircular13CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArcCircular12CoreType >
    _xsd_ArcCircular12Core_element_serializer_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcCircular12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArcCircular12CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArcCircular13Type >
    _xsd_ArcCircular13_element_serializer_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcCircular13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArcCircular13Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArcCircular12Type >
    _xsd_ArcCircular12_element_serializer_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"ArcCircular12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArcCircular12Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Nurbs12CoreType >
    _xsd_Nurbs12Core_element_serializer_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Nurbs12CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Nurbs13CoreType >
    _xsd_Nurbs13Core_element_serializer_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Nurbs13CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Nurbs13Type >
    _xsd_Nurbs13_element_serializer_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Nurbs13Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Nurbs12Type >
    _xsd_Nurbs12_element_serializer_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Nurbs12Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Spline13CoreType >
    _xsd_Spline13Core_element_serializer_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Spline13CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Spline12CoreType >
    _xsd_Spline12Core_element_serializer_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Spline12CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Spline13Type >
    _xsd_Spline13_element_serializer_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Spline13Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Spline12Type >
    _xsd_Spline12_element_serializer_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Spline12Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Aggregate12CoreType >
    _xsd_Aggregate12Core_element_serializer_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Aggregate12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Aggregate12CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Aggregate13CoreType >
    _xsd_Aggregate13Core_element_serializer_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Aggregate13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Aggregate13CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Aggregate12Type >
    _xsd_Aggregate12_element_serializer_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Aggregate12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Aggregate12Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Aggregate13Type >
    _xsd_Aggregate13_element_serializer_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Aggregate13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Aggregate13Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Polyline13CoreType >
    _xsd_Polyline13Core_element_serializer_init (
      L"Curve13Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Polyline13Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Polyline13CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Polyline12CoreType >
    _xsd_Polyline12Core_element_serializer_init (
      L"Curve12Core",
      L"http://qifstandards.org/xsd/qif3",
      L"Polyline12Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Polyline12CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Polyline13Type >
    _xsd_Polyline13_element_serializer_init (
      L"Curve13",
      L"http://qifstandards.org/xsd/qif3",
      L"Polyline13",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Polyline13Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Polyline12Type >
    _xsd_Polyline12_element_serializer_init (
      L"Curve12",
      L"http://qifstandards.org/xsd/qif3",
      L"Polyline12",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Polyline12Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Nurbs23CoreType >
    _xsd_Nurbs23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Nurbs23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Nurbs23Type >
    _xsd_Nurbs23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Nurbs23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Nurbs23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Spline23CoreType >
    _xsd_Spline23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Spline23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Spline23Type >
    _xsd_Spline23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Spline23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Spline23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Revolution23CoreType >
    _xsd_Revolution23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Revolution23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Revolution23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Revolution23Type >
    _xsd_Revolution23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Revolution23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Revolution23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Extrude23CoreType >
    _xsd_Extrude23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Extrude23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Extrude23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Extrude23Type >
    _xsd_Extrude23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Extrude23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Extrude23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Ruled23CoreType >
    _xsd_Ruled23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Ruled23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Ruled23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Ruled23Type >
    _xsd_Ruled23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Ruled23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Ruled23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Offset23CoreType >
    _xsd_Offset23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Offset23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Offset23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Offset23Type >
    _xsd_Offset23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Offset23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Offset23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Plane23CoreType >
    _xsd_Plane23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Plane23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Plane23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Plane23Type >
    _xsd_Plane23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Plane23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Plane23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Cone23CoreType >
    _xsd_Cone23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Cone23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Cone23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Cone23Type >
    _xsd_Cone23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Cone23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Cone23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Cylinder23CoreType >
    _xsd_Cylinder23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Cylinder23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Cylinder23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Cylinder23Type >
    _xsd_Cylinder23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Cylinder23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Cylinder23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Sphere23CoreType >
    _xsd_Sphere23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Sphere23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Sphere23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Sphere23Type >
    _xsd_Sphere23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Sphere23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Sphere23Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Torus23CoreType >
    _xsd_Torus23Core_element_serializer_init (
      L"SurfaceCore",
      L"http://qifstandards.org/xsd/qif3",
      L"Torus23Core",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Torus23CoreType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::Torus23Type >
    _xsd_Torus23_element_serializer_init (
      L"Surface",
      L"http://qifstandards.org/xsd/qif3",
      L"Torus23",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::Torus23Type >);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

