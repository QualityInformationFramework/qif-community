// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "GenericExpressions.hxx"

namespace xsd
{
  namespace qif30
  {
    // BooleanExpressionBaseType
    //


    // NotType
    //

    const NotType::BooleanExpression_type& NotType::
    BooleanExpression () const
    {
      return this->BooleanExpression_.get ();
    }

    NotType::BooleanExpression_type& NotType::
    BooleanExpression ()
    {
      return this->BooleanExpression_.get ();
    }

    void NotType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void NotType::
    BooleanExpression (::std::unique_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (std::move (x));
    }


    // BinaryBooleanExpressionBaseType
    //

    const BinaryBooleanExpressionBaseType::BooleanExpression_sequence& BinaryBooleanExpressionBaseType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    BinaryBooleanExpressionBaseType::BooleanExpression_sequence& BinaryBooleanExpressionBaseType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void BinaryBooleanExpressionBaseType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }


    // AndType
    //

    const AndType::BooleanExpression_sequence& AndType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    AndType::BooleanExpression_sequence& AndType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void AndType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }

    const AndType::n_type& AndType::
    n () const
    {
      return this->n_.get ();
    }

    AndType::n_type& AndType::
    n ()
    {
      return this->n_.get ();
    }

    void AndType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AndType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // OrType
    //

    const OrType::BooleanExpression_sequence& OrType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    OrType::BooleanExpression_sequence& OrType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void OrType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }

    const OrType::n_type& OrType::
    n () const
    {
      return this->n_.get ();
    }

    OrType::n_type& OrType::
    n ()
    {
      return this->n_.get ();
    }

    void OrType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void OrType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // BooleanEqualType
    //


    // ConstantIsType
    //

    const ConstantIsType::val_type& ConstantIsType::
    val () const
    {
      return this->val_.get ();
    }

    ConstantIsType::val_type& ConstantIsType::
    val ()
    {
      return this->val_.get ();
    }

    void ConstantIsType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }

    void ConstantIsType::
    val (::std::unique_ptr< val_type > x)
    {
      this->val_.set (std::move (x));
    }


    // ArithmeticComparisonBaseType
    //

    const ArithmeticComparisonBaseType::ArithmeticExpression_sequence& ArithmeticComparisonBaseType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_;
    }

    ArithmeticComparisonBaseType::ArithmeticExpression_sequence& ArithmeticComparisonBaseType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_;
    }

    void ArithmeticComparisonBaseType::
    ArithmeticExpression (const ArithmeticExpression_sequence& s)
    {
      this->ArithmeticExpression_ = s;
    }


    // ArithmeticEqualType
    //


    // GreaterThanType
    //


    // GreaterOrEqualType
    //


    // LessThanType
    //


    // LessOrEqualType
    //


    // TokenEqualType
    //

    const TokenEqualType::TokenExpression_sequence& TokenEqualType::
    TokenExpression () const
    {
      return this->TokenExpression_;
    }

    TokenEqualType::TokenExpression_sequence& TokenEqualType::
    TokenExpression ()
    {
      return this->TokenExpression_;
    }

    void TokenEqualType::
    TokenExpression (const TokenExpression_sequence& s)
    {
      this->TokenExpression_ = s;
    }


    // BooleanConstantEnumType
    //

    BooleanConstantEnumType::
    BooleanConstantEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_BooleanConstantEnumType_literals_[v])
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const BooleanConstantEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    BooleanConstantEnumType& BooleanConstantEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_BooleanConstantEnumType_literals_[v]);

      return *this;
    }


    // ArithmeticExpressionBaseType
    //


    // ArithmeticConstantType
    //

    const ArithmeticConstantType::val_type& ArithmeticConstantType::
    val () const
    {
      return this->val_.get ();
    }

    ArithmeticConstantType::val_type& ArithmeticConstantType::
    val ()
    {
      return this->val_.get ();
    }

    void ArithmeticConstantType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }


    // NegateType
    //

    const NegateType::ArithmeticExpression_type& NegateType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_.get ();
    }

    NegateType::ArithmeticExpression_type& NegateType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_.get ();
    }

    void NegateType::
    ArithmeticExpression (const ArithmeticExpression_type& x)
    {
      this->ArithmeticExpression_.set (x);
    }

    void NegateType::
    ArithmeticExpression (::std::unique_ptr< ArithmeticExpression_type > x)
    {
      this->ArithmeticExpression_.set (std::move (x));
    }


    // BinaryArithmeticExpressionBaseType
    //

    const BinaryArithmeticExpressionBaseType::ArithmeticExpression_sequence& BinaryArithmeticExpressionBaseType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_;
    }

    BinaryArithmeticExpressionBaseType::ArithmeticExpression_sequence& BinaryArithmeticExpressionBaseType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_;
    }

    void BinaryArithmeticExpressionBaseType::
    ArithmeticExpression (const ArithmeticExpression_sequence& s)
    {
      this->ArithmeticExpression_ = s;
    }


    // PolyadicArithmeticExpressionBaseType
    //

    const PolyadicArithmeticExpressionBaseType::ArithmeticExpression_sequence& PolyadicArithmeticExpressionBaseType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_;
    }

    PolyadicArithmeticExpressionBaseType::ArithmeticExpression_sequence& PolyadicArithmeticExpressionBaseType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_;
    }

    void PolyadicArithmeticExpressionBaseType::
    ArithmeticExpression (const ArithmeticExpression_sequence& s)
    {
      this->ArithmeticExpression_ = s;
    }


    // PlusType
    //


    // MaxType
    //


    // MinType
    //


    // MinusType
    //


    // TimesType
    //


    // DividedByType
    //


    // TokenExpressionBaseType
    //


    // TokenConstantType
    //

    const TokenConstantType::val_type& TokenConstantType::
    val () const
    {
      return this->val_.get ();
    }

    TokenConstantType::val_type& TokenConstantType::
    val ()
    {
      return this->val_.get ();
    }

    void TokenConstantType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }

    void TokenConstantType::
    val (::std::unique_ptr< val_type > x)
    {
      this->val_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // BooleanExpressionBaseType
    //

    BooleanExpressionBaseType::
    BooleanExpressionBaseType ()
    : ::xml_schema::type ()
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const BooleanExpressionBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    BooleanExpressionBaseType::
    ~BooleanExpressionBaseType ()
    {
    }

    // NotType
    //

    NotType::
    NotType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      BooleanExpression_ (this)
    {
    }

    NotType::
    NotType (const BooleanExpression_type& BooleanExpression)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      BooleanExpression_ (BooleanExpression, this)
    {
    }

    NotType::
    NotType (::std::unique_ptr< BooleanExpression_type > BooleanExpression)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      BooleanExpression_ (std::move (BooleanExpression), this)
    {
    }

    NotType::
    NotType (const NotType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    NotType::
    NotType (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NotType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BooleanExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!BooleanExpression_.present ())
            {
              ::std::unique_ptr< BooleanExpression_type > r (
                dynamic_cast< BooleanExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BooleanExpression_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!BooleanExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BooleanExpression",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    NotType* NotType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotType (*this, f, c);
    }

    NotType& NotType::
    operator= (const NotType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    NotType::
    ~NotType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NotType >
    _xsd_NotType_type_factory_init (
      L"NotType",
      L"http://qifstandards.org/xsd/qif3");

    // BinaryBooleanExpressionBaseType
    //

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      BooleanExpression_ (this)
    {
    }

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType (const BinaryBooleanExpressionBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BinaryBooleanExpressionBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BooleanExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->BooleanExpression_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    BinaryBooleanExpressionBaseType& BinaryBooleanExpressionBaseType::
    operator= (const BinaryBooleanExpressionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    BinaryBooleanExpressionBaseType::
    ~BinaryBooleanExpressionBaseType ()
    {
    }

    // AndType
    //

    AndType::
    AndType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      BooleanExpression_ (this),
      n_ (this)
    {
    }

    AndType::
    AndType (const n_type& n)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      BooleanExpression_ (this),
      n_ (n, this)
    {
    }

    AndType::
    AndType (const AndType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AndType::
    AndType (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AndType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BooleanExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->BooleanExpression_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AndType* AndType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AndType (*this, f, c);
    }

    AndType& AndType::
    operator= (const AndType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AndType::
    ~AndType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AndType >
    _xsd_AndType_type_factory_init (
      L"AndType",
      L"http://qifstandards.org/xsd/qif3");

    // OrType
    //

    OrType::
    OrType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      BooleanExpression_ (this),
      n_ (this)
    {
    }

    OrType::
    OrType (const n_type& n)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      BooleanExpression_ (this),
      n_ (n, this)
    {
    }

    OrType::
    OrType (const OrType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this),
      n_ (x.n_, f, this)
    {
    }

    OrType::
    OrType (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OrType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BooleanExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->BooleanExpression_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    OrType* OrType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrType (*this, f, c);
    }

    OrType& OrType::
    operator= (const OrType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
        this->n_ = x.n_;
      }

      return *this;
    }

    OrType::
    ~OrType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OrType >
    _xsd_OrType_type_factory_init (
      L"OrType",
      L"http://qifstandards.org/xsd/qif3");

    // BooleanEqualType
    //

    BooleanEqualType::
    BooleanEqualType ()
    : ::xsd::qif30::BinaryBooleanExpressionBaseType ()
    {
    }

    BooleanEqualType::
    BooleanEqualType (const BooleanEqualType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::BinaryBooleanExpressionBaseType (x, f, c)
    {
    }

    BooleanEqualType::
    BooleanEqualType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::BinaryBooleanExpressionBaseType (e, f, c)
    {
    }

    BooleanEqualType* BooleanEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BooleanEqualType (*this, f, c);
    }

    BooleanEqualType::
    ~BooleanEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, BooleanEqualType >
    _xsd_BooleanEqualType_type_factory_init (
      L"BooleanEqualType",
      L"http://qifstandards.org/xsd/qif3");

    // ConstantIsType
    //

    ConstantIsType::
    ConstantIsType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (this)
    {
    }

    ConstantIsType::
    ConstantIsType (const val_type& val)
    : ::xsd::qif30::BooleanExpressionBaseType (),
      val_ (val, this)
    {
    }

    ConstantIsType::
    ConstantIsType (const ConstantIsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    ConstantIsType::
    ConstantIsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ConstantIsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"val",
          L"");
      }
    }

    ConstantIsType* ConstantIsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConstantIsType (*this, f, c);
    }

    ConstantIsType& ConstantIsType::
    operator= (const ConstantIsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    ConstantIsType::
    ~ConstantIsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConstantIsType >
    _xsd_ConstantIsType_type_factory_init (
      L"ConstantIsType",
      L"http://qifstandards.org/xsd/qif3");

    // ArithmeticComparisonBaseType
    //

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      ArithmeticExpression_ (this)
    {
    }

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType (const ArithmeticComparisonBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArithmeticComparisonBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArithmeticExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ArithmeticExpression_type > r (
              dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ArithmeticExpression_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ArithmeticComparisonBaseType& ArithmeticComparisonBaseType::
    operator= (const ArithmeticComparisonBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    ArithmeticComparisonBaseType::
    ~ArithmeticComparisonBaseType ()
    {
    }

    // ArithmeticEqualType
    //

    ArithmeticEqualType::
    ArithmeticEqualType ()
    : ::xsd::qif30::ArithmeticComparisonBaseType ()
    {
    }

    ArithmeticEqualType::
    ArithmeticEqualType (const ArithmeticEqualType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    ArithmeticEqualType::
    ArithmeticEqualType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    ArithmeticEqualType* ArithmeticEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticEqualType (*this, f, c);
    }

    ArithmeticEqualType::
    ~ArithmeticEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArithmeticEqualType >
    _xsd_ArithmeticEqualType_type_factory_init (
      L"ArithmeticEqualType",
      L"http://qifstandards.org/xsd/qif3");

    // GreaterThanType
    //

    GreaterThanType::
    GreaterThanType ()
    : ::xsd::qif30::ArithmeticComparisonBaseType ()
    {
    }

    GreaterThanType::
    GreaterThanType (const GreaterThanType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    GreaterThanType::
    GreaterThanType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    GreaterThanType* GreaterThanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GreaterThanType (*this, f, c);
    }

    GreaterThanType::
    ~GreaterThanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GreaterThanType >
    _xsd_GreaterThanType_type_factory_init (
      L"GreaterThanType",
      L"http://qifstandards.org/xsd/qif3");

    // GreaterOrEqualType
    //

    GreaterOrEqualType::
    GreaterOrEqualType ()
    : ::xsd::qif30::ArithmeticComparisonBaseType ()
    {
    }

    GreaterOrEqualType::
    GreaterOrEqualType (const GreaterOrEqualType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    GreaterOrEqualType::
    GreaterOrEqualType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    GreaterOrEqualType* GreaterOrEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GreaterOrEqualType (*this, f, c);
    }

    GreaterOrEqualType::
    ~GreaterOrEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GreaterOrEqualType >
    _xsd_GreaterOrEqualType_type_factory_init (
      L"GreaterOrEqualType",
      L"http://qifstandards.org/xsd/qif3");

    // LessThanType
    //

    LessThanType::
    LessThanType ()
    : ::xsd::qif30::ArithmeticComparisonBaseType ()
    {
    }

    LessThanType::
    LessThanType (const LessThanType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    LessThanType::
    LessThanType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    LessThanType* LessThanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LessThanType (*this, f, c);
    }

    LessThanType::
    ~LessThanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LessThanType >
    _xsd_LessThanType_type_factory_init (
      L"LessThanType",
      L"http://qifstandards.org/xsd/qif3");

    // LessOrEqualType
    //

    LessOrEqualType::
    LessOrEqualType ()
    : ::xsd::qif30::ArithmeticComparisonBaseType ()
    {
    }

    LessOrEqualType::
    LessOrEqualType (const LessOrEqualType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    LessOrEqualType::
    LessOrEqualType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    LessOrEqualType* LessOrEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LessOrEqualType (*this, f, c);
    }

    LessOrEqualType::
    ~LessOrEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LessOrEqualType >
    _xsd_LessOrEqualType_type_factory_init (
      L"LessOrEqualType",
      L"http://qifstandards.org/xsd/qif3");

    // TokenEqualType
    //

    TokenEqualType::
    TokenEqualType ()
    : ::xsd::qif30::BooleanExpressionBaseType (),
      TokenExpression_ (this)
    {
    }

    TokenEqualType::
    TokenEqualType (const TokenEqualType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (x, f, c),
      TokenExpression_ (x.TokenExpression_, f, this)
    {
    }

    TokenEqualType::
    TokenEqualType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      TokenExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TokenEqualType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TokenExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"TokenExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< TokenExpression_type > r (
              dynamic_cast< TokenExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->TokenExpression_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TokenEqualType* TokenEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TokenEqualType (*this, f, c);
    }

    TokenEqualType& TokenEqualType::
    operator= (const TokenEqualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::BooleanExpressionBaseType& > (*this) = x;
        this->TokenExpression_ = x.TokenExpression_;
      }

      return *this;
    }

    TokenEqualType::
    ~TokenEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TokenEqualType >
    _xsd_TokenEqualType_type_factory_init (
      L"TokenEqualType",
      L"http://qifstandards.org/xsd/qif3");

    // BooleanConstantEnumType
    //

    BooleanConstantEnumType::
    BooleanConstantEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType* BooleanConstantEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BooleanConstantEnumType (*this, f, c);
    }

    BooleanConstantEnumType::value BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_BooleanConstantEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_BooleanConstantEnumType_indexes_,
                        _xsd_BooleanConstantEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_BooleanConstantEnumType_indexes_ + 2 || _xsd_BooleanConstantEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_literals_[2] =
    {
      L"QIF_TRUE",
      L"QIF_FALSE"
    };

    const BooleanConstantEnumType::value BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_indexes_[2] =
    {
      ::xsd::qif30::BooleanConstantEnumType::QIF_FALSE,
      ::xsd::qif30::BooleanConstantEnumType::QIF_TRUE
    };

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Not_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Not",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::NotType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConstantIs_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ConstantIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConstantIsType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_And_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"And",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AndType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Or_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Or",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OrType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_BooleanEqual_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"BooleanEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::BooleanEqualType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArithmeticEqual_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArithmeticEqualType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GreaterThan_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"GreaterThan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GreaterThanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GreaterOrEqual_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"GreaterOrEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GreaterOrEqualType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LessThan_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"LessThan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LessThanType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LessOrEqual_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"LessOrEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LessOrEqualType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TokenEqual_element_factory_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"TokenEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TokenEqualType >);


    // ArithmeticExpressionBaseType
    //

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType ()
    : ::xml_schema::type ()
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ArithmeticExpressionBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ~ArithmeticExpressionBaseType ()
    {
    }

    // ArithmeticConstantType
    //

    ArithmeticConstantType::
    ArithmeticConstantType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      val_ (this)
    {
    }

    ArithmeticConstantType::
    ArithmeticConstantType (const val_type& val)
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      val_ (val, this)
    {
    }

    ArithmeticConstantType::
    ArithmeticConstantType (const ArithmeticConstantType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    ArithmeticConstantType::
    ArithmeticConstantType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArithmeticConstantType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"val",
          L"");
      }
    }

    ArithmeticConstantType* ArithmeticConstantType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticConstantType (*this, f, c);
    }

    ArithmeticConstantType& ArithmeticConstantType::
    operator= (const ArithmeticConstantType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    ArithmeticConstantType::
    ~ArithmeticConstantType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArithmeticConstantType >
    _xsd_ArithmeticConstantType_type_factory_init (
      L"ArithmeticConstantType",
      L"http://qifstandards.org/xsd/qif3");

    // NegateType
    //

    NegateType::
    NegateType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (this)
    {
    }

    NegateType::
    NegateType (const ArithmeticExpression_type& ArithmeticExpression)
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (ArithmeticExpression, this)
    {
    }

    NegateType::
    NegateType (::std::unique_ptr< ArithmeticExpression_type > ArithmeticExpression)
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (std::move (ArithmeticExpression), this)
    {
    }

    NegateType::
    NegateType (const NegateType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    NegateType::
    NegateType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NegateType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArithmeticExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArithmeticExpression_.present ())
            {
              ::std::unique_ptr< ArithmeticExpression_type > r (
                dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->ArithmeticExpression_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!ArithmeticExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ArithmeticExpression",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    NegateType* NegateType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NegateType (*this, f, c);
    }

    NegateType& NegateType::
    operator= (const NegateType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    NegateType::
    ~NegateType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NegateType >
    _xsd_NegateType_type_factory_init (
      L"NegateType",
      L"http://qifstandards.org/xsd/qif3");

    // BinaryArithmeticExpressionBaseType
    //

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (this)
    {
    }

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType (const BinaryArithmeticExpressionBaseType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BinaryArithmeticExpressionBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArithmeticExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ArithmeticExpression_type > r (
              dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ArithmeticExpression_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    BinaryArithmeticExpressionBaseType& BinaryArithmeticExpressionBaseType::
    operator= (const BinaryArithmeticExpressionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    BinaryArithmeticExpressionBaseType::
    ~BinaryArithmeticExpressionBaseType ()
    {
    }

    // PolyadicArithmeticExpressionBaseType
    //

    PolyadicArithmeticExpressionBaseType::
    PolyadicArithmeticExpressionBaseType ()
    : ::xsd::qif30::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (this)
    {
    }

    PolyadicArithmeticExpressionBaseType::
    PolyadicArithmeticExpressionBaseType (const PolyadicArithmeticExpressionBaseType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    PolyadicArithmeticExpressionBaseType::
    PolyadicArithmeticExpressionBaseType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PolyadicArithmeticExpressionBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArithmeticExpression
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ArithmeticExpression_type > r (
              dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ArithmeticExpression_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PolyadicArithmeticExpressionBaseType& PolyadicArithmeticExpressionBaseType::
    operator= (const PolyadicArithmeticExpressionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArithmeticExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    PolyadicArithmeticExpressionBaseType::
    ~PolyadicArithmeticExpressionBaseType ()
    {
    }

    // PlusType
    //

    PlusType::
    PlusType ()
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType ()
    {
    }

    PlusType::
    PlusType (const PlusType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType (x, f, c)
    {
    }

    PlusType::
    PlusType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType (e, f, c)
    {
    }

    PlusType* PlusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlusType (*this, f, c);
    }

    PlusType::
    ~PlusType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PlusType >
    _xsd_PlusType_type_factory_init (
      L"PlusType",
      L"http://qifstandards.org/xsd/qif3");

    // MaxType
    //

    MaxType::
    MaxType ()
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType ()
    {
    }

    MaxType::
    MaxType (const MaxType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType (x, f, c)
    {
    }

    MaxType::
    MaxType (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType (e, f, c)
    {
    }

    MaxType* MaxType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaxType (*this, f, c);
    }

    MaxType::
    ~MaxType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MaxType >
    _xsd_MaxType_type_factory_init (
      L"MaxType",
      L"http://qifstandards.org/xsd/qif3");

    // MinType
    //

    MinType::
    MinType ()
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType ()
    {
    }

    MinType::
    MinType (const MinType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType (x, f, c)
    {
    }

    MinType::
    MinType (const xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType (e, f, c)
    {
    }

    MinType* MinType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MinType (*this, f, c);
    }

    MinType::
    ~MinType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MinType >
    _xsd_MinType_type_factory_init (
      L"MinType",
      L"http://qifstandards.org/xsd/qif3");

    // MinusType
    //

    MinusType::
    MinusType ()
    : ::xsd::qif30::BinaryArithmeticExpressionBaseType ()
    {
    }

    MinusType::
    MinusType (const MinusType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    MinusType::
    MinusType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    MinusType* MinusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MinusType (*this, f, c);
    }

    MinusType::
    ~MinusType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MinusType >
    _xsd_MinusType_type_factory_init (
      L"MinusType",
      L"http://qifstandards.org/xsd/qif3");

    // TimesType
    //

    TimesType::
    TimesType ()
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType ()
    {
    }

    TimesType::
    TimesType (const TimesType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType (x, f, c)
    {
    }

    TimesType::
    TimesType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::PolyadicArithmeticExpressionBaseType (e, f, c)
    {
    }

    TimesType* TimesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimesType (*this, f, c);
    }

    TimesType::
    ~TimesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TimesType >
    _xsd_TimesType_type_factory_init (
      L"TimesType",
      L"http://qifstandards.org/xsd/qif3");

    // DividedByType
    //

    DividedByType::
    DividedByType ()
    : ::xsd::qif30::BinaryArithmeticExpressionBaseType ()
    {
    }

    DividedByType::
    DividedByType (const DividedByType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    DividedByType::
    DividedByType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    DividedByType* DividedByType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DividedByType (*this, f, c);
    }

    DividedByType::
    ~DividedByType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DividedByType >
    _xsd_DividedByType_type_factory_init (
      L"DividedByType",
      L"http://qifstandards.org/xsd/qif3");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ArithmeticConstant_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticConstant",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ArithmeticConstantType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Plus_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Plus",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PlusType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Max_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Max",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MaxType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Min_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Min",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MinType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Minus_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Minus",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MinusType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Negate_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Negate",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::NegateType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Times_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Times",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TimesType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_DividedBy_element_factory_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"DividedBy",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::DividedByType >);


    // TokenExpressionBaseType
    //

    TokenExpressionBaseType::
    TokenExpressionBaseType ()
    : ::xml_schema::type ()
    {
    }

    TokenExpressionBaseType::
    TokenExpressionBaseType (const TokenExpressionBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    TokenExpressionBaseType::
    TokenExpressionBaseType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    TokenExpressionBaseType::
    TokenExpressionBaseType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    TokenExpressionBaseType::
    TokenExpressionBaseType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    TokenExpressionBaseType::
    ~TokenExpressionBaseType ()
    {
    }

    // TokenConstantType
    //

    TokenConstantType::
    TokenConstantType ()
    : ::xsd::qif30::TokenExpressionBaseType (),
      val_ (this)
    {
    }

    TokenConstantType::
    TokenConstantType (const val_type& val)
    : ::xsd::qif30::TokenExpressionBaseType (),
      val_ (val, this)
    {
    }

    TokenConstantType::
    TokenConstantType (const TokenConstantType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::TokenExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    TokenConstantType::
    TokenConstantType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::TokenExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TokenConstantType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"val",
          L"");
      }
    }

    TokenConstantType* TokenConstantType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TokenConstantType (*this, f, c);
    }

    TokenConstantType& TokenConstantType::
    operator= (const TokenConstantType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TokenExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    TokenConstantType::
    ~TokenConstantType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TokenConstantType >
    _xsd_TokenConstantType_type_factory_init (
      L"TokenConstantType",
      L"http://qifstandards.org/xsd/qif3");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TokenConstant_element_factory_init (
      L"TokenExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"TokenConstant",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TokenConstantType >);
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const BooleanExpressionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const BooleanExpressionBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const BooleanExpressionBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const NotType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const NotType::BooleanExpression_type& x (i.BooleanExpression ());
        if (typeid (NotType::BooleanExpression_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"BooleanExpression",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NotType >
    _xsd_NotType_type_serializer_init (
      L"NotType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const BinaryBooleanExpressionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (BinaryBooleanExpressionBaseType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          const BinaryBooleanExpressionBaseType::BooleanExpression_type& x (*b);

          if (typeid (BinaryBooleanExpressionBaseType::BooleanExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BooleanExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AndType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AndType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          const AndType::BooleanExpression_type& x (*b);

          if (typeid (AndType::BooleanExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BooleanExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AndType >
    _xsd_AndType_type_serializer_init (
      L"AndType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OrType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (OrType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          const OrType::BooleanExpression_type& x (*b);

          if (typeid (OrType::BooleanExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BooleanExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BooleanExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OrType >
    _xsd_OrType_type_serializer_init (
      L"OrType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const BooleanEqualType& i)
    {
      e << static_cast< const ::xsd::qif30::BinaryBooleanExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, BooleanEqualType >
    _xsd_BooleanEqualType_type_serializer_init (
      L"BooleanEqualType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConstantIsType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // val
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"val",
            e));

        a << i.val ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConstantIsType >
    _xsd_ConstantIsType_type_serializer_init (
      L"ConstantIsType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ArithmeticComparisonBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ArithmeticComparisonBaseType::ArithmeticExpression_const_iterator
             b (i.ArithmeticExpression ().begin ()), n (i.ArithmeticExpression ().end ());
             b != n; ++b)
        {
          const ArithmeticComparisonBaseType::ArithmeticExpression_type& x (*b);

          if (typeid (ArithmeticComparisonBaseType::ArithmeticExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ArithmeticExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArithmeticEqualType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArithmeticEqualType >
    _xsd_ArithmeticEqualType_type_serializer_init (
      L"ArithmeticEqualType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GreaterThanType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GreaterThanType >
    _xsd_GreaterThanType_type_serializer_init (
      L"GreaterThanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GreaterOrEqualType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GreaterOrEqualType >
    _xsd_GreaterOrEqualType_type_serializer_init (
      L"GreaterOrEqualType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LessThanType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LessThanType >
    _xsd_LessThanType_type_serializer_init (
      L"LessThanType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LessOrEqualType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LessOrEqualType >
    _xsd_LessOrEqualType_type_serializer_init (
      L"LessOrEqualType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TokenEqualType& i)
    {
      e << static_cast< const ::xsd::qif30::BooleanExpressionBaseType& > (i);

      // TokenExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (TokenEqualType::TokenExpression_const_iterator
             b (i.TokenExpression ().begin ()), n (i.TokenExpression ().end ());
             b != n; ++b)
        {
          const TokenEqualType::TokenExpression_type& x (*b);

          if (typeid (TokenEqualType::TokenExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"TokenExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"TokenExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TokenEqualType >
    _xsd_TokenEqualType_type_serializer_init (
      L"TokenEqualType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const BooleanConstantEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const BooleanConstantEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const BooleanConstantEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::NotType >
    _xsd_Not_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Not",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::NotType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConstantIsType >
    _xsd_ConstantIs_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ConstantIs",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConstantIsType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AndType >
    _xsd_And_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"And",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AndType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OrType >
    _xsd_Or_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Or",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OrType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::BooleanEqualType >
    _xsd_BooleanEqual_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"BooleanEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::BooleanEqualType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArithmeticEqualType >
    _xsd_ArithmeticEqual_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArithmeticEqualType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GreaterThanType >
    _xsd_GreaterThan_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"GreaterThan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GreaterThanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GreaterOrEqualType >
    _xsd_GreaterOrEqual_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"GreaterOrEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GreaterOrEqualType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LessThanType >
    _xsd_LessThan_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"LessThan",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LessThanType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LessOrEqualType >
    _xsd_LessOrEqual_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"LessOrEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LessOrEqualType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TokenEqualType >
    _xsd_TokenEqual_element_serializer_init (
      L"BooleanExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"TokenEqual",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TokenEqualType >);


    void
    operator<< (xercesc::DOMElement& e, const ArithmeticExpressionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const ArithmeticExpressionBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const ArithmeticExpressionBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const ArithmeticConstantType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);

      // val
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"val",
            e));

        a << ::xml_schema::as_decimal(i.val ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArithmeticConstantType >
    _xsd_ArithmeticConstantType_type_serializer_init (
      L"ArithmeticConstantType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const NegateType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const NegateType::ArithmeticExpression_type& x (i.ArithmeticExpression ());
        if (typeid (NegateType::ArithmeticExpression_type) == typeid (x))
        {
          xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"ArithmeticExpression",
            L"http://qifstandards.org/xsd/qif3",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NegateType >
    _xsd_NegateType_type_serializer_init (
      L"NegateType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const BinaryArithmeticExpressionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (BinaryArithmeticExpressionBaseType::ArithmeticExpression_const_iterator
             b (i.ArithmeticExpression ().begin ()), n (i.ArithmeticExpression ().end ());
             b != n; ++b)
        {
          const BinaryArithmeticExpressionBaseType::ArithmeticExpression_type& x (*b);

          if (typeid (BinaryArithmeticExpressionBaseType::ArithmeticExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ArithmeticExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PolyadicArithmeticExpressionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ArithmeticExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (PolyadicArithmeticExpressionBaseType::ArithmeticExpression_const_iterator
             b (i.ArithmeticExpression ().begin ()), n (i.ArithmeticExpression ().end ());
             b != n; ++b)
        {
          const PolyadicArithmeticExpressionBaseType::ArithmeticExpression_type& x (*b);

          if (typeid (PolyadicArithmeticExpressionBaseType::ArithmeticExpression_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ArithmeticExpression",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"ArithmeticExpression",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlusType& i)
    {
      e << static_cast< const ::xsd::qif30::PolyadicArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PlusType >
    _xsd_PlusType_type_serializer_init (
      L"PlusType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MaxType& i)
    {
      e << static_cast< const ::xsd::qif30::PolyadicArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MaxType >
    _xsd_MaxType_type_serializer_init (
      L"MaxType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MinType& i)
    {
      e << static_cast< const ::xsd::qif30::PolyadicArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MinType >
    _xsd_MinType_type_serializer_init (
      L"MinType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MinusType& i)
    {
      e << static_cast< const ::xsd::qif30::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MinusType >
    _xsd_MinusType_type_serializer_init (
      L"MinusType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TimesType& i)
    {
      e << static_cast< const ::xsd::qif30::PolyadicArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TimesType >
    _xsd_TimesType_type_serializer_init (
      L"TimesType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DividedByType& i)
    {
      e << static_cast< const ::xsd::qif30::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DividedByType >
    _xsd_DividedByType_type_serializer_init (
      L"DividedByType",
      L"http://qifstandards.org/xsd/qif3");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ArithmeticConstantType >
    _xsd_ArithmeticConstant_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"ArithmeticConstant",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ArithmeticConstantType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PlusType >
    _xsd_Plus_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Plus",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PlusType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MaxType >
    _xsd_Max_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Max",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MaxType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MinType >
    _xsd_Min_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Min",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MinType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MinusType >
    _xsd_Minus_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Minus",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MinusType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::NegateType >
    _xsd_Negate_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Negate",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::NegateType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TimesType >
    _xsd_Times_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"Times",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TimesType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::DividedByType >
    _xsd_DividedBy_element_serializer_init (
      L"ArithmeticExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"DividedBy",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::DividedByType >);


    void
    operator<< (xercesc::DOMElement& e, const TokenExpressionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const TokenExpressionBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const TokenExpressionBaseType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const TokenConstantType& i)
    {
      e << static_cast< const ::xsd::qif30::TokenExpressionBaseType& > (i);

      // val
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"val",
            e));

        a << i.val ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TokenConstantType >
    _xsd_TokenConstantType_type_serializer_init (
      L"TokenConstantType",
      L"http://qifstandards.org/xsd/qif3");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TokenConstantType >
    _xsd_TokenConstant_element_serializer_init (
      L"TokenExpression",
      L"http://qifstandards.org/xsd/qif3",
      L"TokenConstant",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TokenConstantType >);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

