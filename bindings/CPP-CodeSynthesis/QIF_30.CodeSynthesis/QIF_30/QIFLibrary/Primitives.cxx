// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Primitives.hxx"

namespace xsd
{
  namespace qif30
  {
    // BinaryDataType
    //

    const BinaryDataType::count_type& BinaryDataType::
    count () const
    {
      return this->count_.get ();
    }

    BinaryDataType::count_type& BinaryDataType::
    count ()
    {
      return this->count_.get ();
    }

    void BinaryDataType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void BinaryDataType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }


    // ListIntType
    //

    ListIntType::
    ListIntType ()
    : ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t > (this)
    {
    }

    ListIntType::
    ListIntType (size_type n, const ::xml_schema::integer& x)
    : ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t > (n, x, this)
    {
    }

    ListIntType::
    ListIntType (const ListIntType& o,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t > (o, f, this)
    {
    }

    // I2Type
    //


    // I3Type
    //


    // ListDoubleType
    //

    ListDoubleType::
    ListDoubleType ()
    : ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ > (this)
    {
    }

    ListDoubleType::
    ListDoubleType (size_type n, const ::xml_schema::double_& x)
    : ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
    {
    }

    ListDoubleType::
    ListDoubleType (const ListDoubleType& o,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
    {
    }

    // ListBooleanType
    //

    ListBooleanType::
    ListBooleanType ()
    : ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t > (this)
    {
    }

    ListBooleanType::
    ListBooleanType (size_type n, const ::xml_schema::boolean& x)
    : ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t > (n, x, this)
    {
    }

    ListBooleanType::
    ListBooleanType (const ListBooleanType& o,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t > (o, f, this)
    {
    }

    // ListDateTimeType
    //

    ListDateTimeType::
    ListDateTimeType ()
    : ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t > (this)
    {
    }

    ListDateTimeType::
    ListDateTimeType (size_type n, const ::xml_schema::date_time& x)
    : ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t > (n, x, this)
    {
    }

    ListDateTimeType::
    ListDateTimeType (const ListDateTimeType& o,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t > (o, f, this)
    {
    }

    // ListTokenType
    //

    ListTokenType::
    ListTokenType ()
    : ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t > (this)
    {
    }

    ListTokenType::
    ListTokenType (size_type n, const ::xml_schema::nmtoken& x)
    : ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t > (n, x, this)
    {
    }

    ListTokenType::
    ListTokenType (const ListTokenType& o,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t > (o, f, this)
    {
    }

    // D3Type
    //


    // D2Type
    //


    // DoublePositiveType
    //


    // Point2dSimpleType
    //


    // UnitVector2dSimpleType
    //


    // ParameterRangeType
    //


    // PointSimpleType
    //


    // VectorSimpleType
    //


    // UnitVectorSimpleType
    //


    // ValidityEnumType
    //

    ValidityEnumType::
    ValidityEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    ValidityEnumType::
    ValidityEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ValidityEnumType_literals_[v])
    {
    }

    ValidityEnumType::
    ValidityEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ValidityEnumType::
    ValidityEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ValidityEnumType::
    ValidityEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ValidityEnumType::
    ValidityEnumType (const ValidityEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ValidityEnumType& ValidityEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ValidityEnumType_literals_[v]);

      return *this;
    }


    // PointType
    //

    const PointType::linearUnit_optional& PointType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    PointType::linearUnit_optional& PointType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void PointType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void PointType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void PointType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const PointType::decimalPlaces_optional& PointType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    PointType::decimalPlaces_optional& PointType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void PointType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void PointType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const PointType::significantFigures_optional& PointType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    PointType::significantFigures_optional& PointType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void PointType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void PointType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const PointType::validity_optional& PointType::
    validity () const
    {
      return this->validity_;
    }

    PointType::validity_optional& PointType::
    validity ()
    {
      return this->validity_;
    }

    void PointType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void PointType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void PointType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const PointType::xDecimalPlaces_optional& PointType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    PointType::xDecimalPlaces_optional& PointType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void PointType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void PointType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const PointType::xSignificantFigures_optional& PointType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    PointType::xSignificantFigures_optional& PointType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void PointType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void PointType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const PointType::xValidity_optional& PointType::
    xValidity () const
    {
      return this->xValidity_;
    }

    PointType::xValidity_optional& PointType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void PointType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void PointType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void PointType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const PointType::yDecimalPlaces_optional& PointType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    PointType::yDecimalPlaces_optional& PointType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void PointType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void PointType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const PointType::ySignificantFigures_optional& PointType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    PointType::ySignificantFigures_optional& PointType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void PointType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void PointType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const PointType::yValidity_optional& PointType::
    yValidity () const
    {
      return this->yValidity_;
    }

    PointType::yValidity_optional& PointType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void PointType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void PointType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void PointType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const PointType::zDecimalPlaces_optional& PointType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    PointType::zDecimalPlaces_optional& PointType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void PointType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void PointType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const PointType::zSignificantFigures_optional& PointType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    PointType::zSignificantFigures_optional& PointType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void PointType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void PointType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const PointType::zValidity_optional& PointType::
    zValidity () const
    {
      return this->zValidity_;
    }

    PointType::zValidity_optional& PointType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void PointType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void PointType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void PointType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }


    // VectorType
    //

    const VectorType::linearUnit_optional& VectorType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    VectorType::linearUnit_optional& VectorType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void VectorType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void VectorType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void VectorType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const VectorType::decimalPlaces_optional& VectorType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    VectorType::decimalPlaces_optional& VectorType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void VectorType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void VectorType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const VectorType::significantFigures_optional& VectorType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    VectorType::significantFigures_optional& VectorType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void VectorType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void VectorType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const VectorType::validity_optional& VectorType::
    validity () const
    {
      return this->validity_;
    }

    VectorType::validity_optional& VectorType::
    validity ()
    {
      return this->validity_;
    }

    void VectorType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void VectorType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void VectorType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const VectorType::xDecimalPlaces_optional& VectorType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    VectorType::xDecimalPlaces_optional& VectorType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void VectorType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void VectorType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const VectorType::xSignificantFigures_optional& VectorType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    VectorType::xSignificantFigures_optional& VectorType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void VectorType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void VectorType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const VectorType::xValidity_optional& VectorType::
    xValidity () const
    {
      return this->xValidity_;
    }

    VectorType::xValidity_optional& VectorType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void VectorType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void VectorType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void VectorType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const VectorType::yDecimalPlaces_optional& VectorType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    VectorType::yDecimalPlaces_optional& VectorType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void VectorType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void VectorType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const VectorType::ySignificantFigures_optional& VectorType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    VectorType::ySignificantFigures_optional& VectorType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void VectorType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void VectorType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const VectorType::yValidity_optional& VectorType::
    yValidity () const
    {
      return this->yValidity_;
    }

    VectorType::yValidity_optional& VectorType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void VectorType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void VectorType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void VectorType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const VectorType::zDecimalPlaces_optional& VectorType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    VectorType::zDecimalPlaces_optional& VectorType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void VectorType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void VectorType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const VectorType::zSignificantFigures_optional& VectorType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    VectorType::zSignificantFigures_optional& VectorType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void VectorType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void VectorType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const VectorType::zValidity_optional& VectorType::
    zValidity () const
    {
      return this->zValidity_;
    }

    VectorType::zValidity_optional& VectorType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void VectorType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void VectorType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void VectorType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }


    // UnitVectorType
    //

    const UnitVectorType::linearUnit_optional& UnitVectorType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    UnitVectorType::linearUnit_optional& UnitVectorType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void UnitVectorType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void UnitVectorType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void UnitVectorType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const UnitVectorType::decimalPlaces_optional& UnitVectorType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    UnitVectorType::decimalPlaces_optional& UnitVectorType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void UnitVectorType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void UnitVectorType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const UnitVectorType::significantFigures_optional& UnitVectorType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    UnitVectorType::significantFigures_optional& UnitVectorType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void UnitVectorType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void UnitVectorType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const UnitVectorType::validity_optional& UnitVectorType::
    validity () const
    {
      return this->validity_;
    }

    UnitVectorType::validity_optional& UnitVectorType::
    validity ()
    {
      return this->validity_;
    }

    void UnitVectorType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void UnitVectorType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void UnitVectorType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const UnitVectorType::xDecimalPlaces_optional& UnitVectorType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    UnitVectorType::xDecimalPlaces_optional& UnitVectorType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void UnitVectorType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void UnitVectorType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const UnitVectorType::xSignificantFigures_optional& UnitVectorType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    UnitVectorType::xSignificantFigures_optional& UnitVectorType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void UnitVectorType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void UnitVectorType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const UnitVectorType::xValidity_optional& UnitVectorType::
    xValidity () const
    {
      return this->xValidity_;
    }

    UnitVectorType::xValidity_optional& UnitVectorType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void UnitVectorType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void UnitVectorType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void UnitVectorType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const UnitVectorType::yDecimalPlaces_optional& UnitVectorType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    UnitVectorType::yDecimalPlaces_optional& UnitVectorType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void UnitVectorType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void UnitVectorType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const UnitVectorType::ySignificantFigures_optional& UnitVectorType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    UnitVectorType::ySignificantFigures_optional& UnitVectorType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void UnitVectorType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void UnitVectorType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const UnitVectorType::yValidity_optional& UnitVectorType::
    yValidity () const
    {
      return this->yValidity_;
    }

    UnitVectorType::yValidity_optional& UnitVectorType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void UnitVectorType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void UnitVectorType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void UnitVectorType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const UnitVectorType::zDecimalPlaces_optional& UnitVectorType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    UnitVectorType::zDecimalPlaces_optional& UnitVectorType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void UnitVectorType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void UnitVectorType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const UnitVectorType::zSignificantFigures_optional& UnitVectorType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    UnitVectorType::zSignificantFigures_optional& UnitVectorType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void UnitVectorType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void UnitVectorType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const UnitVectorType::zValidity_optional& UnitVectorType::
    zValidity () const
    {
      return this->zValidity_;
    }

    UnitVectorType::zValidity_optional& UnitVectorType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void UnitVectorType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void UnitVectorType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void UnitVectorType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }


    // ArrayPoint2dType
    //

    const ArrayPoint2dType::count_type& ArrayPoint2dType::
    count () const
    {
      return this->count_.get ();
    }

    ArrayPoint2dType::count_type& ArrayPoint2dType::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayPoint2dType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayPoint2dType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }


    // ArrayPointType
    //

    const ArrayPointType::count_type& ArrayPointType::
    count () const
    {
      return this->count_.get ();
    }

    ArrayPointType::count_type& ArrayPointType::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayPointType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayPointType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }

    const ArrayPointType::linearUnit_optional& ArrayPointType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    ArrayPointType::linearUnit_optional& ArrayPointType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void ArrayPointType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void ArrayPointType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void ArrayPointType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const ArrayPointType::decimalPlaces_optional& ArrayPointType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    ArrayPointType::decimalPlaces_optional& ArrayPointType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void ArrayPointType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void ArrayPointType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const ArrayPointType::significantFigures_optional& ArrayPointType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    ArrayPointType::significantFigures_optional& ArrayPointType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void ArrayPointType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void ArrayPointType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const ArrayPointType::validity_optional& ArrayPointType::
    validity () const
    {
      return this->validity_;
    }

    ArrayPointType::validity_optional& ArrayPointType::
    validity ()
    {
      return this->validity_;
    }

    void ArrayPointType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void ArrayPointType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void ArrayPointType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const ArrayPointType::xDecimalPlaces_optional& ArrayPointType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    ArrayPointType::xDecimalPlaces_optional& ArrayPointType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void ArrayPointType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void ArrayPointType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const ArrayPointType::xSignificantFigures_optional& ArrayPointType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    ArrayPointType::xSignificantFigures_optional& ArrayPointType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void ArrayPointType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void ArrayPointType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const ArrayPointType::xValidity_optional& ArrayPointType::
    xValidity () const
    {
      return this->xValidity_;
    }

    ArrayPointType::xValidity_optional& ArrayPointType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void ArrayPointType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void ArrayPointType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void ArrayPointType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const ArrayPointType::yDecimalPlaces_optional& ArrayPointType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    ArrayPointType::yDecimalPlaces_optional& ArrayPointType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void ArrayPointType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void ArrayPointType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const ArrayPointType::ySignificantFigures_optional& ArrayPointType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    ArrayPointType::ySignificantFigures_optional& ArrayPointType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void ArrayPointType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void ArrayPointType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const ArrayPointType::yValidity_optional& ArrayPointType::
    yValidity () const
    {
      return this->yValidity_;
    }

    ArrayPointType::yValidity_optional& ArrayPointType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void ArrayPointType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void ArrayPointType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void ArrayPointType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const ArrayPointType::zDecimalPlaces_optional& ArrayPointType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    ArrayPointType::zDecimalPlaces_optional& ArrayPointType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void ArrayPointType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void ArrayPointType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const ArrayPointType::zSignificantFigures_optional& ArrayPointType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    ArrayPointType::zSignificantFigures_optional& ArrayPointType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void ArrayPointType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void ArrayPointType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const ArrayPointType::zValidity_optional& ArrayPointType::
    zValidity () const
    {
      return this->zValidity_;
    }

    ArrayPointType::zValidity_optional& ArrayPointType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void ArrayPointType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void ArrayPointType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void ArrayPointType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }


    // ArrayUnitVectorType
    //

    const ArrayUnitVectorType::count_type& ArrayUnitVectorType::
    count () const
    {
      return this->count_.get ();
    }

    ArrayUnitVectorType::count_type& ArrayUnitVectorType::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayUnitVectorType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayUnitVectorType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }

    const ArrayUnitVectorType::linearUnit_optional& ArrayUnitVectorType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    ArrayUnitVectorType::linearUnit_optional& ArrayUnitVectorType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void ArrayUnitVectorType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void ArrayUnitVectorType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void ArrayUnitVectorType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const ArrayUnitVectorType::decimalPlaces_optional& ArrayUnitVectorType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    ArrayUnitVectorType::decimalPlaces_optional& ArrayUnitVectorType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void ArrayUnitVectorType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void ArrayUnitVectorType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const ArrayUnitVectorType::significantFigures_optional& ArrayUnitVectorType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    ArrayUnitVectorType::significantFigures_optional& ArrayUnitVectorType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void ArrayUnitVectorType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void ArrayUnitVectorType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const ArrayUnitVectorType::validity_optional& ArrayUnitVectorType::
    validity () const
    {
      return this->validity_;
    }

    ArrayUnitVectorType::validity_optional& ArrayUnitVectorType::
    validity ()
    {
      return this->validity_;
    }

    void ArrayUnitVectorType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void ArrayUnitVectorType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void ArrayUnitVectorType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const ArrayUnitVectorType::xDecimalPlaces_optional& ArrayUnitVectorType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    ArrayUnitVectorType::xDecimalPlaces_optional& ArrayUnitVectorType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void ArrayUnitVectorType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void ArrayUnitVectorType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const ArrayUnitVectorType::xSignificantFigures_optional& ArrayUnitVectorType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    ArrayUnitVectorType::xSignificantFigures_optional& ArrayUnitVectorType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void ArrayUnitVectorType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void ArrayUnitVectorType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const ArrayUnitVectorType::xValidity_optional& ArrayUnitVectorType::
    xValidity () const
    {
      return this->xValidity_;
    }

    ArrayUnitVectorType::xValidity_optional& ArrayUnitVectorType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void ArrayUnitVectorType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void ArrayUnitVectorType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void ArrayUnitVectorType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const ArrayUnitVectorType::yDecimalPlaces_optional& ArrayUnitVectorType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    ArrayUnitVectorType::yDecimalPlaces_optional& ArrayUnitVectorType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void ArrayUnitVectorType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void ArrayUnitVectorType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const ArrayUnitVectorType::ySignificantFigures_optional& ArrayUnitVectorType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    ArrayUnitVectorType::ySignificantFigures_optional& ArrayUnitVectorType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void ArrayUnitVectorType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void ArrayUnitVectorType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const ArrayUnitVectorType::yValidity_optional& ArrayUnitVectorType::
    yValidity () const
    {
      return this->yValidity_;
    }

    ArrayUnitVectorType::yValidity_optional& ArrayUnitVectorType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void ArrayUnitVectorType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void ArrayUnitVectorType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void ArrayUnitVectorType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const ArrayUnitVectorType::zDecimalPlaces_optional& ArrayUnitVectorType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    ArrayUnitVectorType::zDecimalPlaces_optional& ArrayUnitVectorType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void ArrayUnitVectorType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void ArrayUnitVectorType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const ArrayUnitVectorType::zSignificantFigures_optional& ArrayUnitVectorType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    ArrayUnitVectorType::zSignificantFigures_optional& ArrayUnitVectorType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void ArrayUnitVectorType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void ArrayUnitVectorType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const ArrayUnitVectorType::zValidity_optional& ArrayUnitVectorType::
    zValidity () const
    {
      return this->zValidity_;
    }

    ArrayUnitVectorType::zValidity_optional& ArrayUnitVectorType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void ArrayUnitVectorType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void ArrayUnitVectorType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void ArrayUnitVectorType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }


    // PolyLineType
    //


    // PlaneType
    //

    const PlaneType::Point_type& PlaneType::
    Point () const
    {
      return this->Point_.get ();
    }

    PlaneType::Point_type& PlaneType::
    Point ()
    {
      return this->Point_.get ();
    }

    void PlaneType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void PlaneType::
    Point (::std::unique_ptr< Point_type > x)
    {
      this->Point_.set (std::move (x));
    }

    const PlaneType::Normal_type& PlaneType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    PlaneType::Normal_type& PlaneType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void PlaneType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PlaneType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }


    // PlaneXType
    //

    const PlaneXType::Direction_type& PlaneXType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    PlaneXType::Direction_type& PlaneXType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void PlaneXType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void PlaneXType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }


    // AxisType
    //

    const AxisType::AxisPoint_type& AxisType::
    AxisPoint () const
    {
      return this->AxisPoint_.get ();
    }

    AxisType::AxisPoint_type& AxisType::
    AxisPoint ()
    {
      return this->AxisPoint_.get ();
    }

    void AxisType::
    AxisPoint (const AxisPoint_type& x)
    {
      this->AxisPoint_.set (x);
    }

    void AxisType::
    AxisPoint (::std::unique_ptr< AxisPoint_type > x)
    {
      this->AxisPoint_.set (std::move (x));
    }

    const AxisType::Direction_type& AxisType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    AxisType::Direction_type& AxisType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void AxisType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void AxisType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }


    // TransformRotationType
    //

    const TransformRotationType::XDirection_type& TransformRotationType::
    XDirection () const
    {
      return this->XDirection_.get ();
    }

    TransformRotationType::XDirection_type& TransformRotationType::
    XDirection ()
    {
      return this->XDirection_.get ();
    }

    void TransformRotationType::
    XDirection (const XDirection_type& x)
    {
      this->XDirection_.set (x);
    }

    void TransformRotationType::
    XDirection (::std::unique_ptr< XDirection_type > x)
    {
      this->XDirection_.set (std::move (x));
    }

    const TransformRotationType::YDirection_type& TransformRotationType::
    YDirection () const
    {
      return this->YDirection_.get ();
    }

    TransformRotationType::YDirection_type& TransformRotationType::
    YDirection ()
    {
      return this->YDirection_.get ();
    }

    void TransformRotationType::
    YDirection (const YDirection_type& x)
    {
      this->YDirection_.set (x);
    }

    void TransformRotationType::
    YDirection (::std::unique_ptr< YDirection_type > x)
    {
      this->YDirection_.set (std::move (x));
    }

    const TransformRotationType::ZDirection_type& TransformRotationType::
    ZDirection () const
    {
      return this->ZDirection_.get ();
    }

    TransformRotationType::ZDirection_type& TransformRotationType::
    ZDirection ()
    {
      return this->ZDirection_.get ();
    }

    void TransformRotationType::
    ZDirection (const ZDirection_type& x)
    {
      this->ZDirection_.set (x);
    }

    void TransformRotationType::
    ZDirection (::std::unique_ptr< ZDirection_type > x)
    {
      this->ZDirection_.set (std::move (x));
    }


    // CoordinateSystemCoreType
    //

    const CoordinateSystemCoreType::Rotation_optional& CoordinateSystemCoreType::
    Rotation () const
    {
      return this->Rotation_;
    }

    CoordinateSystemCoreType::Rotation_optional& CoordinateSystemCoreType::
    Rotation ()
    {
      return this->Rotation_;
    }

    void CoordinateSystemCoreType::
    Rotation (const Rotation_type& x)
    {
      this->Rotation_.set (x);
    }

    void CoordinateSystemCoreType::
    Rotation (const Rotation_optional& x)
    {
      this->Rotation_ = x;
    }

    void CoordinateSystemCoreType::
    Rotation (::std::unique_ptr< Rotation_type > x)
    {
      this->Rotation_.set (std::move (x));
    }

    const CoordinateSystemCoreType::Origin_optional& CoordinateSystemCoreType::
    Origin () const
    {
      return this->Origin_;
    }

    CoordinateSystemCoreType::Origin_optional& CoordinateSystemCoreType::
    Origin ()
    {
      return this->Origin_;
    }

    void CoordinateSystemCoreType::
    Origin (const Origin_type& x)
    {
      this->Origin_.set (x);
    }

    void CoordinateSystemCoreType::
    Origin (const Origin_optional& x)
    {
      this->Origin_ = x;
    }

    void CoordinateSystemCoreType::
    Origin (::std::unique_ptr< Origin_type > x)
    {
      this->Origin_.set (std::move (x));
    }


    // TransformMatrixType
    //

    const TransformMatrixType::linearUnit_optional& TransformMatrixType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    TransformMatrixType::linearUnit_optional& TransformMatrixType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void TransformMatrixType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void TransformMatrixType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void TransformMatrixType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const TransformMatrixType::decimalPlaces_optional& TransformMatrixType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    TransformMatrixType::decimalPlaces_optional& TransformMatrixType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void TransformMatrixType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void TransformMatrixType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const TransformMatrixType::significantFigures_optional& TransformMatrixType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    TransformMatrixType::significantFigures_optional& TransformMatrixType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void TransformMatrixType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void TransformMatrixType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const TransformMatrixType::validity_optional& TransformMatrixType::
    validity () const
    {
      return this->validity_;
    }

    TransformMatrixType::validity_optional& TransformMatrixType::
    validity ()
    {
      return this->validity_;
    }

    void TransformMatrixType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void TransformMatrixType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void TransformMatrixType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const TransformMatrixType::xDecimalPlaces_optional& TransformMatrixType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    TransformMatrixType::xDecimalPlaces_optional& TransformMatrixType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void TransformMatrixType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void TransformMatrixType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const TransformMatrixType::xSignificantFigures_optional& TransformMatrixType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    TransformMatrixType::xSignificantFigures_optional& TransformMatrixType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void TransformMatrixType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void TransformMatrixType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const TransformMatrixType::xValidity_optional& TransformMatrixType::
    xValidity () const
    {
      return this->xValidity_;
    }

    TransformMatrixType::xValidity_optional& TransformMatrixType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void TransformMatrixType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void TransformMatrixType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void TransformMatrixType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const TransformMatrixType::yDecimalPlaces_optional& TransformMatrixType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    TransformMatrixType::yDecimalPlaces_optional& TransformMatrixType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void TransformMatrixType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void TransformMatrixType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const TransformMatrixType::ySignificantFigures_optional& TransformMatrixType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    TransformMatrixType::ySignificantFigures_optional& TransformMatrixType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void TransformMatrixType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void TransformMatrixType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const TransformMatrixType::yValidity_optional& TransformMatrixType::
    yValidity () const
    {
      return this->yValidity_;
    }

    TransformMatrixType::yValidity_optional& TransformMatrixType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void TransformMatrixType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void TransformMatrixType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void TransformMatrixType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const TransformMatrixType::zDecimalPlaces_optional& TransformMatrixType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    TransformMatrixType::zDecimalPlaces_optional& TransformMatrixType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void TransformMatrixType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void TransformMatrixType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const TransformMatrixType::zSignificantFigures_optional& TransformMatrixType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    TransformMatrixType::zSignificantFigures_optional& TransformMatrixType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void TransformMatrixType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void TransformMatrixType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const TransformMatrixType::zValidity_optional& TransformMatrixType::
    zValidity () const
    {
      return this->zValidity_;
    }

    TransformMatrixType::zValidity_optional& TransformMatrixType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void TransformMatrixType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void TransformMatrixType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void TransformMatrixType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }


    // LineSegmentType
    //

    const LineSegmentType::StartPoint_type& LineSegmentType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    LineSegmentType::StartPoint_type& LineSegmentType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void LineSegmentType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void LineSegmentType::
    StartPoint (::std::unique_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (std::move (x));
    }

    const LineSegmentType::EndPoint_type& LineSegmentType::
    EndPoint () const
    {
      return this->EndPoint_.get ();
    }

    LineSegmentType::EndPoint_type& LineSegmentType::
    EndPoint ()
    {
      return this->EndPoint_.get ();
    }

    void LineSegmentType::
    EndPoint (const EndPoint_type& x)
    {
      this->EndPoint_.set (x);
    }

    void LineSegmentType::
    EndPoint (::std::unique_ptr< EndPoint_type > x)
    {
      this->EndPoint_.set (std::move (x));
    }

    const LineSegmentType::linearUnit_optional& LineSegmentType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    LineSegmentType::linearUnit_optional& LineSegmentType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void LineSegmentType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void LineSegmentType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void LineSegmentType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const LineSegmentType::decimalPlaces_optional& LineSegmentType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    LineSegmentType::decimalPlaces_optional& LineSegmentType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void LineSegmentType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void LineSegmentType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const LineSegmentType::significantFigures_optional& LineSegmentType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    LineSegmentType::significantFigures_optional& LineSegmentType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void LineSegmentType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void LineSegmentType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const LineSegmentType::validity_optional& LineSegmentType::
    validity () const
    {
      return this->validity_;
    }

    LineSegmentType::validity_optional& LineSegmentType::
    validity ()
    {
      return this->validity_;
    }

    void LineSegmentType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void LineSegmentType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void LineSegmentType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const LineSegmentType::xDecimalPlaces_optional& LineSegmentType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    LineSegmentType::xDecimalPlaces_optional& LineSegmentType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void LineSegmentType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void LineSegmentType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const LineSegmentType::xSignificantFigures_optional& LineSegmentType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    LineSegmentType::xSignificantFigures_optional& LineSegmentType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void LineSegmentType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void LineSegmentType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const LineSegmentType::xValidity_optional& LineSegmentType::
    xValidity () const
    {
      return this->xValidity_;
    }

    LineSegmentType::xValidity_optional& LineSegmentType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void LineSegmentType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void LineSegmentType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void LineSegmentType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const LineSegmentType::yDecimalPlaces_optional& LineSegmentType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    LineSegmentType::yDecimalPlaces_optional& LineSegmentType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void LineSegmentType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void LineSegmentType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const LineSegmentType::ySignificantFigures_optional& LineSegmentType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    LineSegmentType::ySignificantFigures_optional& LineSegmentType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void LineSegmentType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void LineSegmentType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const LineSegmentType::yValidity_optional& LineSegmentType::
    yValidity () const
    {
      return this->yValidity_;
    }

    LineSegmentType::yValidity_optional& LineSegmentType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void LineSegmentType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void LineSegmentType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void LineSegmentType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const LineSegmentType::zDecimalPlaces_optional& LineSegmentType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    LineSegmentType::zDecimalPlaces_optional& LineSegmentType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void LineSegmentType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void LineSegmentType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const LineSegmentType::zSignificantFigures_optional& LineSegmentType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    LineSegmentType::zSignificantFigures_optional& LineSegmentType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void LineSegmentType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void LineSegmentType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const LineSegmentType::zValidity_optional& LineSegmentType::
    zValidity () const
    {
      return this->zValidity_;
    }

    LineSegmentType::zValidity_optional& LineSegmentType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void LineSegmentType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void LineSegmentType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void LineSegmentType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }


    // LineSegment2dType
    //

    const LineSegment2dType::StartPoint_type& LineSegment2dType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    LineSegment2dType::StartPoint_type& LineSegment2dType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void LineSegment2dType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void LineSegment2dType::
    StartPoint (::std::unique_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (std::move (x));
    }

    const LineSegment2dType::EndPoint_type& LineSegment2dType::
    EndPoint () const
    {
      return this->EndPoint_.get ();
    }

    LineSegment2dType::EndPoint_type& LineSegment2dType::
    EndPoint ()
    {
      return this->EndPoint_.get ();
    }

    void LineSegment2dType::
    EndPoint (const EndPoint_type& x)
    {
      this->EndPoint_.set (x);
    }

    void LineSegment2dType::
    EndPoint (::std::unique_ptr< EndPoint_type > x)
    {
      this->EndPoint_.set (std::move (x));
    }


    // LatitudeLongitudeSweepType
    //

    const LatitudeLongitudeSweepType::DirMeridianPrime_type& LatitudeLongitudeSweepType::
    DirMeridianPrime () const
    {
      return this->DirMeridianPrime_.get ();
    }

    LatitudeLongitudeSweepType::DirMeridianPrime_type& LatitudeLongitudeSweepType::
    DirMeridianPrime ()
    {
      return this->DirMeridianPrime_.get ();
    }

    void LatitudeLongitudeSweepType::
    DirMeridianPrime (const DirMeridianPrime_type& x)
    {
      this->DirMeridianPrime_.set (x);
    }

    void LatitudeLongitudeSweepType::
    DirMeridianPrime (::std::unique_ptr< DirMeridianPrime_type > x)
    {
      this->DirMeridianPrime_.set (std::move (x));
    }

    const LatitudeLongitudeSweepType::DomainLatitude_type& LatitudeLongitudeSweepType::
    DomainLatitude () const
    {
      return this->DomainLatitude_.get ();
    }

    LatitudeLongitudeSweepType::DomainLatitude_type& LatitudeLongitudeSweepType::
    DomainLatitude ()
    {
      return this->DomainLatitude_.get ();
    }

    void LatitudeLongitudeSweepType::
    DomainLatitude (const DomainLatitude_type& x)
    {
      this->DomainLatitude_.set (x);
    }

    void LatitudeLongitudeSweepType::
    DomainLatitude (::std::unique_ptr< DomainLatitude_type > x)
    {
      this->DomainLatitude_.set (std::move (x));
    }

    const LatitudeLongitudeSweepType::DomainLongitude_type& LatitudeLongitudeSweepType::
    DomainLongitude () const
    {
      return this->DomainLongitude_.get ();
    }

    LatitudeLongitudeSweepType::DomainLongitude_type& LatitudeLongitudeSweepType::
    DomainLongitude ()
    {
      return this->DomainLongitude_.get ();
    }

    void LatitudeLongitudeSweepType::
    DomainLongitude (const DomainLongitude_type& x)
    {
      this->DomainLongitude_.set (x);
    }

    void LatitudeLongitudeSweepType::
    DomainLongitude (::std::unique_ptr< DomainLongitude_type > x)
    {
      this->DomainLongitude_.set (std::move (x));
    }


    // OrientedLatitudeLongitudeSweepType
    //

    const OrientedLatitudeLongitudeSweepType::DirNorthPole_type& OrientedLatitudeLongitudeSweepType::
    DirNorthPole () const
    {
      return this->DirNorthPole_.get ();
    }

    OrientedLatitudeLongitudeSweepType::DirNorthPole_type& OrientedLatitudeLongitudeSweepType::
    DirNorthPole ()
    {
      return this->DirNorthPole_.get ();
    }

    void OrientedLatitudeLongitudeSweepType::
    DirNorthPole (const DirNorthPole_type& x)
    {
      this->DirNorthPole_.set (x);
    }

    void OrientedLatitudeLongitudeSweepType::
    DirNorthPole (::std::unique_ptr< DirNorthPole_type > x)
    {
      this->DirNorthPole_.set (std::move (x));
    }


    // SweepType
    //

    const SweepType::DirBeg_type& SweepType::
    DirBeg () const
    {
      return this->DirBeg_.get ();
    }

    SweepType::DirBeg_type& SweepType::
    DirBeg ()
    {
      return this->DirBeg_.get ();
    }

    void SweepType::
    DirBeg (const DirBeg_type& x)
    {
      this->DirBeg_.set (x);
    }

    void SweepType::
    DirBeg (::std::unique_ptr< DirBeg_type > x)
    {
      this->DirBeg_.set (std::move (x));
    }

    const SweepType::DomainAngle_type& SweepType::
    DomainAngle () const
    {
      return this->DomainAngle_.get ();
    }

    SweepType::DomainAngle_type& SweepType::
    DomainAngle ()
    {
      return this->DomainAngle_.get ();
    }

    void SweepType::
    DomainAngle (const DomainAngle_type& x)
    {
      this->DomainAngle_.set (x);
    }

    void SweepType::
    DomainAngle (::std::unique_ptr< DomainAngle_type > x)
    {
      this->DomainAngle_.set (std::move (x));
    }


    // AngleRangeType
    //

    const AngleRangeType::angularUnit_optional& AngleRangeType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    AngleRangeType::angularUnit_optional& AngleRangeType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void AngleRangeType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void AngleRangeType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void AngleRangeType::
    angularUnit (::std::unique_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (std::move (x));
    }


    // QIFIdAndReferenceBaseType
    //


    // QIFIdType
    //


    // QIFReferenceBaseType
    //


    // QIFReferenceSimpleType
    //


    // QIFReferenceType
    //

    const QIFReferenceType::xId_optional& QIFReferenceType::
    xId () const
    {
      return this->xId_;
    }

    QIFReferenceType::xId_optional& QIFReferenceType::
    xId ()
    {
      return this->xId_;
    }

    void QIFReferenceType::
    xId (const xId_type& x)
    {
      this->xId_.set (x);
    }

    void QIFReferenceType::
    xId (const xId_optional& x)
    {
      this->xId_ = x;
    }

    void QIFReferenceType::
    xId (::std::unique_ptr< xId_type > x)
    {
      this->xId_.set (std::move (x));
    }


    // ListQIFReferenceSimpleType
    //

    ListQIFReferenceSimpleType::
    ListQIFReferenceSimpleType ()
    : ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t > (this)
    {
    }

    ListQIFReferenceSimpleType::
    ListQIFReferenceSimpleType (size_type n, const ::xsd::qif30::QIFReferenceSimpleType& x)
    : ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t > (n, x, this)
    {
    }

    ListQIFReferenceSimpleType::
    ListQIFReferenceSimpleType (const ListQIFReferenceSimpleType& o,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t > (o, f, this)
    {
    }

    // ListQIFReferenceType
    //

    const ListQIFReferenceType::Ids_optional& ListQIFReferenceType::
    Ids () const
    {
      return this->Ids_;
    }

    ListQIFReferenceType::Ids_optional& ListQIFReferenceType::
    Ids ()
    {
      return this->Ids_;
    }

    void ListQIFReferenceType::
    Ids (const Ids_type& x)
    {
      this->Ids_.set (x);
    }

    void ListQIFReferenceType::
    Ids (const Ids_optional& x)
    {
      this->Ids_ = x;
    }

    void ListQIFReferenceType::
    Ids (::std::unique_ptr< Ids_type > x)
    {
      this->Ids_.set (std::move (x));
    }

    const ListQIFReferenceType::Id_optional& ListQIFReferenceType::
    Id () const
    {
      return this->Id_;
    }

    ListQIFReferenceType::Id_optional& ListQIFReferenceType::
    Id ()
    {
      return this->Id_;
    }

    void ListQIFReferenceType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ListQIFReferenceType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void ListQIFReferenceType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }

    const ListQIFReferenceType::XIds_optional& ListQIFReferenceType::
    XIds () const
    {
      return this->XIds_;
    }

    ListQIFReferenceType::XIds_optional& ListQIFReferenceType::
    XIds ()
    {
      return this->XIds_;
    }

    void ListQIFReferenceType::
    XIds (const XIds_type& x)
    {
      this->XIds_.set (x);
    }

    void ListQIFReferenceType::
    XIds (const XIds_optional& x)
    {
      this->XIds_ = x;
    }

    void ListQIFReferenceType::
    XIds (::std::unique_ptr< XIds_type > x)
    {
      this->XIds_.set (std::move (x));
    }

    const ListQIFReferenceType::n_type& ListQIFReferenceType::
    n () const
    {
      return this->n_.get ();
    }

    ListQIFReferenceType::n_type& ListQIFReferenceType::
    n ()
    {
      return this->n_.get ();
    }

    void ListQIFReferenceType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ListQIFReferenceType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ListQIFReferenceFullType
    //

    const ListQIFReferenceFullType::asmPathId_optional& ListQIFReferenceFullType::
    asmPathId () const
    {
      return this->asmPathId_;
    }

    ListQIFReferenceFullType::asmPathId_optional& ListQIFReferenceFullType::
    asmPathId ()
    {
      return this->asmPathId_;
    }

    void ListQIFReferenceFullType::
    asmPathId (const asmPathId_type& x)
    {
      this->asmPathId_.set (x);
    }

    void ListQIFReferenceFullType::
    asmPathId (const asmPathId_optional& x)
    {
      this->asmPathId_ = x;
    }

    void ListQIFReferenceFullType::
    asmPathId (::std::unique_ptr< asmPathId_type > x)
    {
      this->asmPathId_.set (std::move (x));
    }

    const ListQIFReferenceFullType::asmPathXId_optional& ListQIFReferenceFullType::
    asmPathXId () const
    {
      return this->asmPathXId_;
    }

    ListQIFReferenceFullType::asmPathXId_optional& ListQIFReferenceFullType::
    asmPathXId ()
    {
      return this->asmPathXId_;
    }

    void ListQIFReferenceFullType::
    asmPathXId (const asmPathXId_type& x)
    {
      this->asmPathXId_.set (x);
    }

    void ListQIFReferenceFullType::
    asmPathXId (const asmPathXId_optional& x)
    {
      this->asmPathXId_ = x;
    }

    void ListQIFReferenceFullType::
    asmPathXId (::std::unique_ptr< asmPathXId_type > x)
    {
      this->asmPathXId_.set (std::move (x));
    }


    // ArrayBinaryQIFReferenceType
    //

    const ArrayBinaryQIFReferenceType::Ids_optional& ArrayBinaryQIFReferenceType::
    Ids () const
    {
      return this->Ids_;
    }

    ArrayBinaryQIFReferenceType::Ids_optional& ArrayBinaryQIFReferenceType::
    Ids ()
    {
      return this->Ids_;
    }

    void ArrayBinaryQIFReferenceType::
    Ids (const Ids_type& x)
    {
      this->Ids_.set (x);
    }

    void ArrayBinaryQIFReferenceType::
    Ids (const Ids_optional& x)
    {
      this->Ids_ = x;
    }

    void ArrayBinaryQIFReferenceType::
    Ids (::std::unique_ptr< Ids_type > x)
    {
      this->Ids_.set (std::move (x));
    }

    const ArrayBinaryQIFReferenceType::Id_optional& ArrayBinaryQIFReferenceType::
    Id () const
    {
      return this->Id_;
    }

    ArrayBinaryQIFReferenceType::Id_optional& ArrayBinaryQIFReferenceType::
    Id ()
    {
      return this->Id_;
    }

    void ArrayBinaryQIFReferenceType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ArrayBinaryQIFReferenceType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void ArrayBinaryQIFReferenceType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }

    const ArrayBinaryQIFReferenceType::XIds_optional& ArrayBinaryQIFReferenceType::
    XIds () const
    {
      return this->XIds_;
    }

    ArrayBinaryQIFReferenceType::XIds_optional& ArrayBinaryQIFReferenceType::
    XIds ()
    {
      return this->XIds_;
    }

    void ArrayBinaryQIFReferenceType::
    XIds (const XIds_type& x)
    {
      this->XIds_.set (x);
    }

    void ArrayBinaryQIFReferenceType::
    XIds (const XIds_optional& x)
    {
      this->XIds_ = x;
    }

    void ArrayBinaryQIFReferenceType::
    XIds (::std::unique_ptr< XIds_type > x)
    {
      this->XIds_.set (std::move (x));
    }


    // ArrayBinaryQIFReferenceFullType
    //

    const ArrayBinaryQIFReferenceFullType::asmPathId_optional& ArrayBinaryQIFReferenceFullType::
    asmPathId () const
    {
      return this->asmPathId_;
    }

    ArrayBinaryQIFReferenceFullType::asmPathId_optional& ArrayBinaryQIFReferenceFullType::
    asmPathId ()
    {
      return this->asmPathId_;
    }

    void ArrayBinaryQIFReferenceFullType::
    asmPathId (const asmPathId_type& x)
    {
      this->asmPathId_.set (x);
    }

    void ArrayBinaryQIFReferenceFullType::
    asmPathId (const asmPathId_optional& x)
    {
      this->asmPathId_ = x;
    }

    void ArrayBinaryQIFReferenceFullType::
    asmPathId (::std::unique_ptr< asmPathId_type > x)
    {
      this->asmPathId_.set (std::move (x));
    }

    const ArrayBinaryQIFReferenceFullType::asmPathXId_optional& ArrayBinaryQIFReferenceFullType::
    asmPathXId () const
    {
      return this->asmPathXId_;
    }

    ArrayBinaryQIFReferenceFullType::asmPathXId_optional& ArrayBinaryQIFReferenceFullType::
    asmPathXId ()
    {
      return this->asmPathXId_;
    }

    void ArrayBinaryQIFReferenceFullType::
    asmPathXId (const asmPathXId_type& x)
    {
      this->asmPathXId_.set (x);
    }

    void ArrayBinaryQIFReferenceFullType::
    asmPathXId (const asmPathXId_optional& x)
    {
      this->asmPathXId_ = x;
    }

    void ArrayBinaryQIFReferenceFullType::
    asmPathXId (::std::unique_ptr< asmPathXId_type > x)
    {
      this->asmPathXId_.set (std::move (x));
    }


    // QIFReferenceActiveType
    //

    const QIFReferenceActiveType::active_type& QIFReferenceActiveType::
    active () const
    {
      return this->active_.get ();
    }

    QIFReferenceActiveType::active_type& QIFReferenceActiveType::
    active ()
    {
      return this->active_.get ();
    }

    void QIFReferenceActiveType::
    active (const active_type& x)
    {
      this->active_.set (x);
    }

    QIFReferenceActiveType::active_type QIFReferenceActiveType::
    active_default_value ()
    {
      return active_type (false);
    }


    // QIFReferenceFullType
    //

    const QIFReferenceFullType::asmPathId_optional& QIFReferenceFullType::
    asmPathId () const
    {
      return this->asmPathId_;
    }

    QIFReferenceFullType::asmPathId_optional& QIFReferenceFullType::
    asmPathId ()
    {
      return this->asmPathId_;
    }

    void QIFReferenceFullType::
    asmPathId (const asmPathId_type& x)
    {
      this->asmPathId_.set (x);
    }

    void QIFReferenceFullType::
    asmPathId (const asmPathId_optional& x)
    {
      this->asmPathId_ = x;
    }

    void QIFReferenceFullType::
    asmPathId (::std::unique_ptr< asmPathId_type > x)
    {
      this->asmPathId_.set (std::move (x));
    }

    const QIFReferenceFullType::asmPathXId_optional& QIFReferenceFullType::
    asmPathXId () const
    {
      return this->asmPathXId_;
    }

    QIFReferenceFullType::asmPathXId_optional& QIFReferenceFullType::
    asmPathXId ()
    {
      return this->asmPathXId_;
    }

    void QIFReferenceFullType::
    asmPathXId (const asmPathXId_type& x)
    {
      this->asmPathXId_.set (x);
    }

    void QIFReferenceFullType::
    asmPathXId (const asmPathXId_optional& x)
    {
      this->asmPathXId_ = x;
    }

    void QIFReferenceFullType::
    asmPathXId (::std::unique_ptr< asmPathXId_type > x)
    {
      this->asmPathXId_.set (std::move (x));
    }


    // ElementReferenceType
    //

    const ElementReferenceType::Id_type& ElementReferenceType::
    Id () const
    {
      return this->Id_.get ();
    }

    ElementReferenceType::Id_type& ElementReferenceType::
    Id ()
    {
      return this->Id_.get ();
    }

    void ElementReferenceType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ElementReferenceType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // ElementReferenceFullType
    //

    const ElementReferenceFullType::Id_type& ElementReferenceFullType::
    Id () const
    {
      return this->Id_.get ();
    }

    ElementReferenceFullType::Id_type& ElementReferenceFullType::
    Id ()
    {
      return this->Id_.get ();
    }

    void ElementReferenceFullType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ElementReferenceFullType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // D4Type
    //


    // NaturalType
    //


    // ListNaturalType
    //

    ListNaturalType::
    ListNaturalType ()
    : ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t > (this)
    {
    }

    ListNaturalType::
    ListNaturalType (size_type n, const ::xsd::qif30::NaturalType& x)
    : ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t > (n, x, this)
    {
    }

    ListNaturalType::
    ListNaturalType (const ListNaturalType& o,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t > (o, f, this)
    {
    }

    // Natural2Type
    //


    // ArrayNaturalType
    //

    const ArrayNaturalType::count_type& ArrayNaturalType::
    count () const
    {
      return this->count_.get ();
    }

    ArrayNaturalType::count_type& ArrayNaturalType::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayNaturalType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayNaturalType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }


    // FractionType
    //

    const FractionType::Numerator_type& FractionType::
    Numerator () const
    {
      return this->Numerator_.get ();
    }

    FractionType::Numerator_type& FractionType::
    Numerator ()
    {
      return this->Numerator_.get ();
    }

    void FractionType::
    Numerator (const Numerator_type& x)
    {
      this->Numerator_.set (x);
    }

    void FractionType::
    Numerator (::std::unique_ptr< Numerator_type > x)
    {
      this->Numerator_.set (std::move (x));
    }

    const FractionType::Denominator_type& FractionType::
    Denominator () const
    {
      return this->Denominator_.get ();
    }

    FractionType::Denominator_type& FractionType::
    Denominator ()
    {
      return this->Denominator_.get ();
    }

    void FractionType::
    Denominator (const Denominator_type& x)
    {
      this->Denominator_.set (x);
    }

    void FractionType::
    Denominator (::std::unique_ptr< Denominator_type > x)
    {
      this->Denominator_.set (std::move (x));
    }


    // ArrayReferenceType
    //

    const ArrayReferenceType::Id_sequence& ArrayReferenceType::
    Id () const
    {
      return this->Id_;
    }

    ArrayReferenceType::Id_sequence& ArrayReferenceType::
    Id ()
    {
      return this->Id_;
    }

    void ArrayReferenceType::
    Id (const Id_sequence& s)
    {
      this->Id_ = s;
    }

    const ArrayReferenceType::n_type& ArrayReferenceType::
    n () const
    {
      return this->n_.get ();
    }

    ArrayReferenceType::n_type& ArrayReferenceType::
    n ()
    {
      return this->n_.get ();
    }

    void ArrayReferenceType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ArrayReferenceType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ArrayReferenceActiveType
    //

    const ArrayReferenceActiveType::Id_sequence& ArrayReferenceActiveType::
    Id () const
    {
      return this->Id_;
    }

    ArrayReferenceActiveType::Id_sequence& ArrayReferenceActiveType::
    Id ()
    {
      return this->Id_;
    }

    void ArrayReferenceActiveType::
    Id (const Id_sequence& s)
    {
      this->Id_ = s;
    }

    const ArrayReferenceActiveType::n_type& ArrayReferenceActiveType::
    n () const
    {
      return this->n_.get ();
    }

    ArrayReferenceActiveType::n_type& ArrayReferenceActiveType::
    n ()
    {
      return this->n_.get ();
    }

    void ArrayReferenceActiveType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ArrayReferenceActiveType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ArrayReferenceFullType
    //

    const ArrayReferenceFullType::Id_sequence& ArrayReferenceFullType::
    Id () const
    {
      return this->Id_;
    }

    ArrayReferenceFullType::Id_sequence& ArrayReferenceFullType::
    Id ()
    {
      return this->Id_;
    }

    void ArrayReferenceFullType::
    Id (const Id_sequence& s)
    {
      this->Id_ = s;
    }

    const ArrayReferenceFullType::n_type& ArrayReferenceFullType::
    n () const
    {
      return this->n_.get ();
    }

    ArrayReferenceFullType::n_type& ArrayReferenceFullType::
    n ()
    {
      return this->n_.get ();
    }

    void ArrayReferenceFullType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ArrayReferenceFullType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // QIFFeaturePairType
    //

    const QIFFeaturePairType::FirstFeature_type& QIFFeaturePairType::
    FirstFeature () const
    {
      return this->FirstFeature_.get ();
    }

    QIFFeaturePairType::FirstFeature_type& QIFFeaturePairType::
    FirstFeature ()
    {
      return this->FirstFeature_.get ();
    }

    void QIFFeaturePairType::
    FirstFeature (const FirstFeature_type& x)
    {
      this->FirstFeature_.set (x);
    }

    void QIFFeaturePairType::
    FirstFeature (::std::unique_ptr< FirstFeature_type > x)
    {
      this->FirstFeature_.set (std::move (x));
    }

    const QIFFeaturePairType::SecondFeature_type& QIFFeaturePairType::
    SecondFeature () const
    {
      return this->SecondFeature_.get ();
    }

    QIFFeaturePairType::SecondFeature_type& QIFFeaturePairType::
    SecondFeature ()
    {
      return this->SecondFeature_.get ();
    }

    void QIFFeaturePairType::
    SecondFeature (const SecondFeature_type& x)
    {
      this->SecondFeature_.set (x);
    }

    void QIFFeaturePairType::
    SecondFeature (::std::unique_ptr< SecondFeature_type > x)
    {
      this->SecondFeature_.set (std::move (x));
    }

    const QIFFeaturePairType::FirstFeatureZone_optional& QIFFeaturePairType::
    FirstFeatureZone () const
    {
      return this->FirstFeatureZone_;
    }

    QIFFeaturePairType::FirstFeatureZone_optional& QIFFeaturePairType::
    FirstFeatureZone ()
    {
      return this->FirstFeatureZone_;
    }

    void QIFFeaturePairType::
    FirstFeatureZone (const FirstFeatureZone_type& x)
    {
      this->FirstFeatureZone_.set (x);
    }

    void QIFFeaturePairType::
    FirstFeatureZone (const FirstFeatureZone_optional& x)
    {
      this->FirstFeatureZone_ = x;
    }

    void QIFFeaturePairType::
    FirstFeatureZone (::std::unique_ptr< FirstFeatureZone_type > x)
    {
      this->FirstFeatureZone_.set (std::move (x));
    }

    const QIFFeaturePairType::SecondFeatureZone_optional& QIFFeaturePairType::
    SecondFeatureZone () const
    {
      return this->SecondFeatureZone_;
    }

    QIFFeaturePairType::SecondFeatureZone_optional& QIFFeaturePairType::
    SecondFeatureZone ()
    {
      return this->SecondFeatureZone_;
    }

    void QIFFeaturePairType::
    SecondFeatureZone (const SecondFeatureZone_type& x)
    {
      this->SecondFeatureZone_.set (x);
    }

    void QIFFeaturePairType::
    SecondFeatureZone (const SecondFeatureZone_optional& x)
    {
      this->SecondFeatureZone_ = x;
    }

    void QIFFeaturePairType::
    SecondFeatureZone (::std::unique_ptr< SecondFeatureZone_type > x)
    {
      this->SecondFeatureZone_.set (std::move (x));
    }


    // ArrayPairReferenceFullType
    //

    const ArrayPairReferenceFullType::FeaturePair_sequence& ArrayPairReferenceFullType::
    FeaturePair () const
    {
      return this->FeaturePair_;
    }

    ArrayPairReferenceFullType::FeaturePair_sequence& ArrayPairReferenceFullType::
    FeaturePair ()
    {
      return this->FeaturePair_;
    }

    void ArrayPairReferenceFullType::
    FeaturePair (const FeaturePair_sequence& s)
    {
      this->FeaturePair_ = s;
    }

    const ArrayPairReferenceFullType::n_type& ArrayPairReferenceFullType::
    n () const
    {
      return this->n_.get ();
    }

    ArrayPairReferenceFullType::n_type& ArrayPairReferenceFullType::
    n ()
    {
      return this->n_.get ();
    }

    void ArrayPairReferenceFullType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ArrayPairReferenceFullType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ListUnsignedByteType
    //

    ListUnsignedByteType::
    ListUnsignedByteType ()
    : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t > (this)
    {
    }

    ListUnsignedByteType::
    ListUnsignedByteType (size_type n, const ::xml_schema::unsigned_byte& x)
    : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t > (n, x, this)
    {
    }

    ListUnsignedByteType::
    ListUnsignedByteType (const ListUnsignedByteType& o,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t > (o, f, this)
    {
    }

    // QPIdType
    //


    // QPIdReferenceType
    //


    // QPIdFullReferenceType
    //

    const QPIdFullReferenceType::ItemQPId_type& QPIdFullReferenceType::
    ItemQPId () const
    {
      return this->ItemQPId_.get ();
    }

    QPIdFullReferenceType::ItemQPId_type& QPIdFullReferenceType::
    ItemQPId ()
    {
      return this->ItemQPId_.get ();
    }

    void QPIdFullReferenceType::
    ItemQPId (const ItemQPId_type& x)
    {
      this->ItemQPId_.set (x);
    }

    void QPIdFullReferenceType::
    ItemQPId (::std::unique_ptr< ItemQPId_type > x)
    {
      this->ItemQPId_.set (std::move (x));
    }

    const QPIdFullReferenceType::DocumentQPId_sequence& QPIdFullReferenceType::
    DocumentQPId () const
    {
      return this->DocumentQPId_;
    }

    QPIdFullReferenceType::DocumentQPId_sequence& QPIdFullReferenceType::
    DocumentQPId ()
    {
      return this->DocumentQPId_;
    }

    void QPIdFullReferenceType::
    DocumentQPId (const DocumentQPId_sequence& s)
    {
      this->DocumentQPId_ = s;
    }


    // ArrayQPIdFullReferenceType
    //

    const ArrayQPIdFullReferenceType::QPId_sequence& ArrayQPIdFullReferenceType::
    QPId () const
    {
      return this->QPId_;
    }

    ArrayQPIdFullReferenceType::QPId_sequence& ArrayQPIdFullReferenceType::
    QPId ()
    {
      return this->QPId_;
    }

    void ArrayQPIdFullReferenceType::
    QPId (const QPId_sequence& s)
    {
      this->QPId_ = s;
    }

    const ArrayQPIdFullReferenceType::n_type& ArrayQPIdFullReferenceType::
    n () const
    {
      return this->n_.get ();
    }

    ArrayQPIdFullReferenceType::n_type& ArrayQPIdFullReferenceType::
    n ()
    {
      return this->n_.get ();
    }

    void ArrayQPIdFullReferenceType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ArrayQPIdFullReferenceType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ArrayUnsignedByteType
    //

    const ArrayUnsignedByteType::count_type& ArrayUnsignedByteType::
    count () const
    {
      return this->count_.get ();
    }

    ArrayUnsignedByteType::count_type& ArrayUnsignedByteType::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayUnsignedByteType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayUnsignedByteType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }


    // ArrayIntType
    //

    const ArrayIntType::count_type& ArrayIntType::
    count () const
    {
      return this->count_.get ();
    }

    ArrayIntType::count_type& ArrayIntType::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayIntType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayIntType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }


    // ArrayI2Type
    //

    const ArrayI2Type::count_type& ArrayI2Type::
    count () const
    {
      return this->count_.get ();
    }

    ArrayI2Type::count_type& ArrayI2Type::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayI2Type::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayI2Type::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }


    // ArrayI3Type
    //

    const ArrayI3Type::count_type& ArrayI3Type::
    count () const
    {
      return this->count_.get ();
    }

    ArrayI3Type::count_type& ArrayI3Type::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayI3Type::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayI3Type::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }


    // ArrayDoubleType
    //

    const ArrayDoubleType::count_type& ArrayDoubleType::
    count () const
    {
      return this->count_.get ();
    }

    ArrayDoubleType::count_type& ArrayDoubleType::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayDoubleType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayDoubleType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }


    // ArrayBinaryType
    //

    const ArrayBinaryType::count_type& ArrayBinaryType::
    count () const
    {
      return this->count_.get ();
    }

    ArrayBinaryType::count_type& ArrayBinaryType::
    count ()
    {
      return this->count_.get ();
    }

    void ArrayBinaryType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void ArrayBinaryType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }

    const ArrayBinaryType::sizeElement_type& ArrayBinaryType::
    sizeElement () const
    {
      return this->sizeElement_.get ();
    }

    ArrayBinaryType::sizeElement_type& ArrayBinaryType::
    sizeElement ()
    {
      return this->sizeElement_.get ();
    }

    void ArrayBinaryType::
    sizeElement (const sizeElement_type& x)
    {
      this->sizeElement_.set (x);
    }


    // AttributesType
    //

    const AttributesType::Attribute_sequence& AttributesType::
    Attribute () const
    {
      return this->Attribute_;
    }

    AttributesType::Attribute_sequence& AttributesType::
    Attribute ()
    {
      return this->Attribute_;
    }

    void AttributesType::
    Attribute (const Attribute_sequence& s)
    {
      this->Attribute_ = s;
    }

    const AttributesType::n_type& AttributesType::
    n () const
    {
      return this->n_.get ();
    }

    AttributesType::n_type& AttributesType::
    n ()
    {
      return this->n_.get ();
    }

    void AttributesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void AttributesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // AttributeBaseType
    //

    const AttributeBaseType::name_type& AttributeBaseType::
    name () const
    {
      return this->name_.get ();
    }

    AttributeBaseType::name_type& AttributeBaseType::
    name ()
    {
      return this->name_.get ();
    }

    void AttributeBaseType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void AttributeBaseType::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }


    // AttributeBoolType
    //

    const AttributeBoolType::value_type& AttributeBoolType::
    value () const
    {
      return this->value_.get ();
    }

    AttributeBoolType::value_type& AttributeBoolType::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeBoolType::
    value (const value_type& x)
    {
      this->value_.set (x);
    }


    // AttributeStrType
    //

    const AttributeStrType::value_type& AttributeStrType::
    value () const
    {
      return this->value_.get ();
    }

    AttributeStrType::value_type& AttributeStrType::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeStrType::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeStrType::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }


    // AttributeTimeType
    //

    const AttributeTimeType::value_type& AttributeTimeType::
    value () const
    {
      return this->value_.get ();
    }

    AttributeTimeType::value_type& AttributeTimeType::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeTimeType::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeTimeType::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }


    // AttributeQPIdType
    //

    const AttributeQPIdType::Value_type& AttributeQPIdType::
    Value () const
    {
      return this->Value_.get ();
    }

    AttributeQPIdType::Value_type& AttributeQPIdType::
    Value ()
    {
      return this->Value_.get ();
    }

    void AttributeQPIdType::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void AttributeQPIdType::
    Value (::std::unique_ptr< Value_type > x)
    {
      this->Value_.set (std::move (x));
    }


    // AttributeI1Type
    //

    const AttributeI1Type::value_type& AttributeI1Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeI1Type::value_type& AttributeI1Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeI1Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }


    // AttributeI2Type
    //

    const AttributeI2Type::value_type& AttributeI2Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeI2Type::value_type& AttributeI2Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeI2Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeI2Type::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }


    // AttributeI3Type
    //

    const AttributeI3Type::value_type& AttributeI3Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeI3Type::value_type& AttributeI3Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeI3Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeI3Type::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }


    // AttributeD1Type
    //

    const AttributeD1Type::value_type& AttributeD1Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeD1Type::value_type& AttributeD1Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeD1Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }


    // AttributeD2Type
    //

    const AttributeD2Type::value_type& AttributeD2Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeD2Type::value_type& AttributeD2Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeD2Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeD2Type::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }


    // AttributeD3Type
    //

    const AttributeD3Type::value_type& AttributeD3Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeD3Type::value_type& AttributeD3Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeD3Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeD3Type::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }


    // AttributeUserType
    //

    const AttributeUserType::UserDataXML_optional& AttributeUserType::
    UserDataXML () const
    {
      return this->UserDataXML_;
    }

    AttributeUserType::UserDataXML_optional& AttributeUserType::
    UserDataXML ()
    {
      return this->UserDataXML_;
    }

    void AttributeUserType::
    UserDataXML (const UserDataXML_type& x)
    {
      this->UserDataXML_.set (x);
    }

    void AttributeUserType::
    UserDataXML (const UserDataXML_optional& x)
    {
      this->UserDataXML_ = x;
    }

    void AttributeUserType::
    UserDataXML (::std::unique_ptr< UserDataXML_type > x)
    {
      this->UserDataXML_.set (std::move (x));
    }

    const AttributeUserType::UserDataBinary_optional& AttributeUserType::
    UserDataBinary () const
    {
      return this->UserDataBinary_;
    }

    AttributeUserType::UserDataBinary_optional& AttributeUserType::
    UserDataBinary ()
    {
      return this->UserDataBinary_;
    }

    void AttributeUserType::
    UserDataBinary (const UserDataBinary_type& x)
    {
      this->UserDataBinary_.set (x);
    }

    void AttributeUserType::
    UserDataBinary (const UserDataBinary_optional& x)
    {
      this->UserDataBinary_ = x;
    }

    void AttributeUserType::
    UserDataBinary (::std::unique_ptr< UserDataBinary_type > x)
    {
      this->UserDataBinary_.set (std::move (x));
    }

    const AttributeUserType::nameUserAttribute_type& AttributeUserType::
    nameUserAttribute () const
    {
      return this->nameUserAttribute_.get ();
    }

    AttributeUserType::nameUserAttribute_type& AttributeUserType::
    nameUserAttribute ()
    {
      return this->nameUserAttribute_.get ();
    }

    void AttributeUserType::
    nameUserAttribute (const nameUserAttribute_type& x)
    {
      this->nameUserAttribute_.set (x);
    }

    void AttributeUserType::
    nameUserAttribute (::std::unique_ptr< nameUserAttribute_type > x)
    {
      this->nameUserAttribute_.set (std::move (x));
    }


    // UserDataXMLType
    //


    // ValidationPointsType
    //

    const ValidationPointsType::Points_optional& ValidationPointsType::
    Points () const
    {
      return this->Points_;
    }

    ValidationPointsType::Points_optional& ValidationPointsType::
    Points ()
    {
      return this->Points_;
    }

    void ValidationPointsType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void ValidationPointsType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void ValidationPointsType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }

    const ValidationPointsType::PointsBinary_optional& ValidationPointsType::
    PointsBinary () const
    {
      return this->PointsBinary_;
    }

    ValidationPointsType::PointsBinary_optional& ValidationPointsType::
    PointsBinary ()
    {
      return this->PointsBinary_;
    }

    void ValidationPointsType::
    PointsBinary (const PointsBinary_type& x)
    {
      this->PointsBinary_.set (x);
    }

    void ValidationPointsType::
    PointsBinary (const PointsBinary_optional& x)
    {
      this->PointsBinary_ = x;
    }

    void ValidationPointsType::
    PointsBinary (::std::unique_ptr< PointsBinary_type > x)
    {
      this->PointsBinary_.set (std::move (x));
    }

    const ValidationPointsType::Directions_optional& ValidationPointsType::
    Directions () const
    {
      return this->Directions_;
    }

    ValidationPointsType::Directions_optional& ValidationPointsType::
    Directions ()
    {
      return this->Directions_;
    }

    void ValidationPointsType::
    Directions (const Directions_type& x)
    {
      this->Directions_.set (x);
    }

    void ValidationPointsType::
    Directions (const Directions_optional& x)
    {
      this->Directions_ = x;
    }

    void ValidationPointsType::
    Directions (::std::unique_ptr< Directions_type > x)
    {
      this->Directions_.set (std::move (x));
    }

    const ValidationPointsType::DirectionsBinary_optional& ValidationPointsType::
    DirectionsBinary () const
    {
      return this->DirectionsBinary_;
    }

    ValidationPointsType::DirectionsBinary_optional& ValidationPointsType::
    DirectionsBinary ()
    {
      return this->DirectionsBinary_;
    }

    void ValidationPointsType::
    DirectionsBinary (const DirectionsBinary_type& x)
    {
      this->DirectionsBinary_.set (x);
    }

    void ValidationPointsType::
    DirectionsBinary (const DirectionsBinary_optional& x)
    {
      this->DirectionsBinary_ = x;
    }

    void ValidationPointsType::
    DirectionsBinary (::std::unique_ptr< DirectionsBinary_type > x)
    {
      this->DirectionsBinary_.set (std::move (x));
    }


    // BoundingBoxAxisAlignedType
    //

    const BoundingBoxAxisAlignedType::PointMin_type& BoundingBoxAxisAlignedType::
    PointMin () const
    {
      return this->PointMin_.get ();
    }

    BoundingBoxAxisAlignedType::PointMin_type& BoundingBoxAxisAlignedType::
    PointMin ()
    {
      return this->PointMin_.get ();
    }

    void BoundingBoxAxisAlignedType::
    PointMin (const PointMin_type& x)
    {
      this->PointMin_.set (x);
    }

    void BoundingBoxAxisAlignedType::
    PointMin (::std::unique_ptr< PointMin_type > x)
    {
      this->PointMin_.set (std::move (x));
    }

    const BoundingBoxAxisAlignedType::PointMax_type& BoundingBoxAxisAlignedType::
    PointMax () const
    {
      return this->PointMax_.get ();
    }

    BoundingBoxAxisAlignedType::PointMax_type& BoundingBoxAxisAlignedType::
    PointMax ()
    {
      return this->PointMax_.get ();
    }

    void BoundingBoxAxisAlignedType::
    PointMax (const PointMax_type& x)
    {
      this->PointMax_.set (x);
    }

    void BoundingBoxAxisAlignedType::
    PointMax (::std::unique_ptr< PointMax_type > x)
    {
      this->PointMax_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // BinaryDataType
    //

    BinaryDataType::
    BinaryDataType ()
    : ::xml_schema::base64_binary (),
      count_ (this)
    {
    }

    BinaryDataType::
    BinaryDataType (const count_type& count)
    : ::xml_schema::base64_binary (),
      count_ (count, this)
    {
    }

    BinaryDataType::
    BinaryDataType (const ::xml_schema::base64_binary& _xsd_base64_binary_base,
                    const count_type& count)
    : ::xml_schema::base64_binary (_xsd_base64_binary_base),
      count_ (count, this)
    {
    }

    BinaryDataType::
    BinaryDataType (const BinaryDataType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::base64_binary (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    BinaryDataType::
    BinaryDataType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::base64_binary (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void BinaryDataType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    BinaryDataType* BinaryDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BinaryDataType (*this, f, c);
    }

    BinaryDataType& BinaryDataType::
    operator= (const BinaryDataType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::base64_binary& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    BinaryDataType::
    ~BinaryDataType ()
    {
    }

    // ListIntType
    //

    ListIntType::
    ListIntType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t > (e, f, this)
    {
    }

    ListIntType::
    ListIntType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t > (a, f, this)
    {
    }

    ListIntType::
    ListIntType (const ::std::wstring& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t > (s, e, f, this)
    {
    }

    ListIntType* ListIntType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListIntType (*this, f, c);
    }

    ListIntType::
    ~ListIntType ()
    {
    }

    // I2Type
    //

    I2Type::
    I2Type ()
    : ::xsd::qif30::ListIntType ()
    {
    }

    I2Type::
    I2Type (const ::xsd::qif30::ListIntType& _xsd_ListIntType_base)
    : ::xsd::qif30::ListIntType (_xsd_ListIntType_base)
    {
    }

    I2Type::
    I2Type (const I2Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (x, f, c)
    {
    }

    I2Type::
    I2Type (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (e, f, c)
    {
    }

    I2Type::
    I2Type (const xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (a, f, c)
    {
    }

    I2Type::
    I2Type (const ::std::wstring& s,
            const xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (s, e, f, c)
    {
    }

    I2Type* I2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class I2Type (*this, f, c);
    }

    I2Type::
    ~I2Type ()
    {
    }

    // I3Type
    //

    I3Type::
    I3Type ()
    : ::xsd::qif30::ListIntType ()
    {
    }

    I3Type::
    I3Type (const ::xsd::qif30::ListIntType& _xsd_ListIntType_base)
    : ::xsd::qif30::ListIntType (_xsd_ListIntType_base)
    {
    }

    I3Type::
    I3Type (const I3Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (x, f, c)
    {
    }

    I3Type::
    I3Type (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (e, f, c)
    {
    }

    I3Type::
    I3Type (const xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (a, f, c)
    {
    }

    I3Type::
    I3Type (const ::std::wstring& s,
            const xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (s, e, f, c)
    {
    }

    I3Type* I3Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class I3Type (*this, f, c);
    }

    I3Type::
    ~I3Type ()
    {
    }

    // ListDoubleType
    //

    ListDoubleType::
    ListDoubleType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
    {
    }

    ListDoubleType::
    ListDoubleType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
    {
    }

    ListDoubleType::
    ListDoubleType (const ::std::wstring& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
    {
    }

    ListDoubleType* ListDoubleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListDoubleType (*this, f, c);
    }

    ListDoubleType::
    ~ListDoubleType ()
    {
    }

    // ListBooleanType
    //

    ListBooleanType::
    ListBooleanType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t > (e, f, this)
    {
    }

    ListBooleanType::
    ListBooleanType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t > (a, f, this)
    {
    }

    ListBooleanType::
    ListBooleanType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t > (s, e, f, this)
    {
    }

    ListBooleanType* ListBooleanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListBooleanType (*this, f, c);
    }

    ListBooleanType::
    ~ListBooleanType ()
    {
    }

    // ListDateTimeType
    //

    ListDateTimeType::
    ListDateTimeType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t > (e, f, this)
    {
    }

    ListDateTimeType::
    ListDateTimeType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t > (a, f, this)
    {
    }

    ListDateTimeType::
    ListDateTimeType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t > (s, e, f, this)
    {
    }

    ListDateTimeType* ListDateTimeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListDateTimeType (*this, f, c);
    }

    ListDateTimeType::
    ~ListDateTimeType ()
    {
    }

    // ListTokenType
    //

    ListTokenType::
    ListTokenType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t > (e, f, this)
    {
    }

    ListTokenType::
    ListTokenType (const xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t > (a, f, this)
    {
    }

    ListTokenType::
    ListTokenType (const ::std::wstring& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t > (s, e, f, this)
    {
    }

    ListTokenType* ListTokenType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListTokenType (*this, f, c);
    }

    ListTokenType::
    ~ListTokenType ()
    {
    }

    // D3Type
    //

    D3Type::
    D3Type ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    D3Type::
    D3Type (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    D3Type::
    D3Type (const D3Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    D3Type::
    D3Type (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    D3Type::
    D3Type (const xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    D3Type::
    D3Type (const ::std::wstring& s,
            const xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    D3Type* D3Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class D3Type (*this, f, c);
    }

    D3Type::
    ~D3Type ()
    {
    }

    // D2Type
    //

    D2Type::
    D2Type ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    D2Type::
    D2Type (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    D2Type::
    D2Type (const D2Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    D2Type::
    D2Type (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    D2Type::
    D2Type (const xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    D2Type::
    D2Type (const ::std::wstring& s,
            const xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    D2Type* D2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class D2Type (*this, f, c);
    }

    D2Type::
    ~D2Type ()
    {
    }

    // DoublePositiveType
    //

    DoublePositiveType::
    DoublePositiveType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > ()
    {
    }

    DoublePositiveType::
    DoublePositiveType (const ::xml_schema::double_& _xsd_double__base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
    {
    }

    DoublePositiveType::
    DoublePositiveType (const DoublePositiveType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
    {
    }

    DoublePositiveType::
    DoublePositiveType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
    {
    }

    DoublePositiveType::
    DoublePositiveType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
    {
    }

    DoublePositiveType::
    DoublePositiveType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
    {
    }

    DoublePositiveType* DoublePositiveType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DoublePositiveType (*this, f, c);
    }

    DoublePositiveType::
    ~DoublePositiveType ()
    {
    }

    // Point2dSimpleType
    //

    Point2dSimpleType::
    Point2dSimpleType ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const Point2dSimpleType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    Point2dSimpleType* Point2dSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Point2dSimpleType (*this, f, c);
    }

    Point2dSimpleType::
    ~Point2dSimpleType ()
    {
    }

    // UnitVector2dSimpleType
    //

    UnitVector2dSimpleType::
    UnitVector2dSimpleType ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const UnitVector2dSimpleType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    UnitVector2dSimpleType* UnitVector2dSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitVector2dSimpleType (*this, f, c);
    }

    UnitVector2dSimpleType::
    ~UnitVector2dSimpleType ()
    {
    }

    // ParameterRangeType
    //

    ParameterRangeType::
    ParameterRangeType ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    ParameterRangeType::
    ParameterRangeType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    ParameterRangeType::
    ParameterRangeType (const ParameterRangeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    ParameterRangeType::
    ParameterRangeType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    ParameterRangeType::
    ParameterRangeType (const xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    ParameterRangeType::
    ParameterRangeType (const ::std::wstring& s,
                        const xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    ParameterRangeType* ParameterRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParameterRangeType (*this, f, c);
    }

    ParameterRangeType::
    ~ParameterRangeType ()
    {
    }

    // PointSimpleType
    //

    PointSimpleType::
    PointSimpleType ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    PointSimpleType::
    PointSimpleType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    PointSimpleType::
    PointSimpleType (const PointSimpleType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    PointSimpleType::
    PointSimpleType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    PointSimpleType::
    PointSimpleType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    PointSimpleType::
    PointSimpleType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    PointSimpleType* PointSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointSimpleType (*this, f, c);
    }

    PointSimpleType::
    ~PointSimpleType ()
    {
    }

    // VectorSimpleType
    //

    VectorSimpleType::
    VectorSimpleType ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    VectorSimpleType::
    VectorSimpleType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    VectorSimpleType::
    VectorSimpleType (const VectorSimpleType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    VectorSimpleType::
    VectorSimpleType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    VectorSimpleType::
    VectorSimpleType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    VectorSimpleType::
    VectorSimpleType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    VectorSimpleType* VectorSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VectorSimpleType (*this, f, c);
    }

    VectorSimpleType::
    ~VectorSimpleType ()
    {
    }

    // UnitVectorSimpleType
    //

    UnitVectorSimpleType::
    UnitVectorSimpleType ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const UnitVectorSimpleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    UnitVectorSimpleType* UnitVectorSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitVectorSimpleType (*this, f, c);
    }

    UnitVectorSimpleType::
    ~UnitVectorSimpleType ()
    {
    }

    // ValidityEnumType
    //

    ValidityEnumType::
    ValidityEnumType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ValidityEnumType_convert ();
    }

    ValidityEnumType::
    ValidityEnumType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ValidityEnumType_convert ();
    }

    ValidityEnumType::
    ValidityEnumType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ValidityEnumType_convert ();
    }

    ValidityEnumType* ValidityEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidityEnumType (*this, f, c);
    }

    ValidityEnumType::value ValidityEnumType::
    _xsd_ValidityEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ValidityEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ValidityEnumType_indexes_,
                        _xsd_ValidityEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ValidityEnumType_indexes_ + 5 || _xsd_ValidityEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ValidityEnumType::
    _xsd_ValidityEnumType_literals_[5] =
    {
      L"REPORTED",
      L"DUMMY",
      L"MOOT",
      L"DERIVED",
      L"SET"
    };

    const ValidityEnumType::value ValidityEnumType::
    _xsd_ValidityEnumType_indexes_[5] =
    {
      ::xsd::qif30::ValidityEnumType::DERIVED,
      ::xsd::qif30::ValidityEnumType::DUMMY,
      ::xsd::qif30::ValidityEnumType::MOOT,
      ::xsd::qif30::ValidityEnumType::REPORTED,
      ::xsd::qif30::ValidityEnumType::SET
    };

    // PointType
    //

    PointType::
    PointType ()
    : ::xsd::qif30::PointSimpleType (),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    PointType::
    PointType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::PointSimpleType (_xsd_ListDoubleType_base),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    PointType::
    PointType (const PointType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::PointSimpleType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    PointType::
    PointType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::PointSimpleType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void PointType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }
    }

    PointType* PointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointType (*this, f, c);
    }

    PointType& PointType::
    operator= (const PointType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointSimpleType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    PointType::
    ~PointType ()
    {
    }

    // VectorType
    //

    VectorType::
    VectorType ()
    : ::xsd::qif30::VectorSimpleType (),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    VectorType::
    VectorType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::VectorSimpleType (_xsd_ListDoubleType_base),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    VectorType::
    VectorType (const VectorType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::VectorSimpleType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    VectorType::
    VectorType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::VectorSimpleType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void VectorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }
    }

    VectorType* VectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VectorType (*this, f, c);
    }

    VectorType& VectorType::
    operator= (const VectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::VectorSimpleType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    VectorType::
    ~VectorType ()
    {
    }

    // UnitVectorType
    //

    UnitVectorType::
    UnitVectorType ()
    : ::xsd::qif30::UnitVectorSimpleType (),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    UnitVectorType::
    UnitVectorType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::UnitVectorSimpleType (_xsd_ListDoubleType_base),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    UnitVectorType::
    UnitVectorType (const UnitVectorType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UnitVectorSimpleType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    UnitVectorType::
    UnitVectorType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::UnitVectorSimpleType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void UnitVectorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }
    }

    UnitVectorType* UnitVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitVectorType (*this, f, c);
    }

    UnitVectorType& UnitVectorType::
    operator= (const UnitVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::UnitVectorSimpleType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    UnitVectorType::
    ~UnitVectorType ()
    {
    }

    // ArrayPoint2dType
    //

    ArrayPoint2dType::
    ArrayPoint2dType ()
    : ::xsd::qif30::ListDoubleType (),
      count_ (this)
    {
    }

    ArrayPoint2dType::
    ArrayPoint2dType (const count_type& count)
    : ::xsd::qif30::ListDoubleType (),
      count_ (count, this)
    {
    }

    ArrayPoint2dType::
    ArrayPoint2dType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base,
                      const count_type& count)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base),
      count_ (count, this)
    {
    }

    ArrayPoint2dType::
    ArrayPoint2dType (const ArrayPoint2dType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    ArrayPoint2dType::
    ArrayPoint2dType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayPoint2dType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayPoint2dType* ArrayPoint2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayPoint2dType (*this, f, c);
    }

    ArrayPoint2dType& ArrayPoint2dType::
    operator= (const ArrayPoint2dType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListDoubleType& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    ArrayPoint2dType::
    ~ArrayPoint2dType ()
    {
    }

    // ArrayPointType
    //

    ArrayPointType::
    ArrayPointType ()
    : ::xsd::qif30::ListDoubleType (),
      count_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    ArrayPointType::
    ArrayPointType (const count_type& count)
    : ::xsd::qif30::ListDoubleType (),
      count_ (count, this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    ArrayPointType::
    ArrayPointType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base,
                    const count_type& count)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base),
      count_ (count, this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    ArrayPointType::
    ArrayPointType (const ArrayPointType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c),
      count_ (x.count_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    ArrayPointType::
    ArrayPointType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f | ::xml_schema::flags::base, c),
      count_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayPointType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayPointType* ArrayPointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayPointType (*this, f, c);
    }

    ArrayPointType& ArrayPointType::
    operator= (const ArrayPointType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListDoubleType& > (*this) = x;
        this->count_ = x.count_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    ArrayPointType::
    ~ArrayPointType ()
    {
    }

    // ArrayUnitVectorType
    //

    ArrayUnitVectorType::
    ArrayUnitVectorType ()
    : ::xsd::qif30::ListDoubleType (),
      count_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    ArrayUnitVectorType::
    ArrayUnitVectorType (const count_type& count)
    : ::xsd::qif30::ListDoubleType (),
      count_ (count, this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    ArrayUnitVectorType::
    ArrayUnitVectorType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base,
                         const count_type& count)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base),
      count_ (count, this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    ArrayUnitVectorType::
    ArrayUnitVectorType (const ArrayUnitVectorType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c),
      count_ (x.count_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    ArrayUnitVectorType::
    ArrayUnitVectorType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f | ::xml_schema::flags::base, c),
      count_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayUnitVectorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayUnitVectorType* ArrayUnitVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayUnitVectorType (*this, f, c);
    }

    ArrayUnitVectorType& ArrayUnitVectorType::
    operator= (const ArrayUnitVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListDoubleType& > (*this) = x;
        this->count_ = x.count_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    ArrayUnitVectorType::
    ~ArrayUnitVectorType ()
    {
    }

    // PolyLineType
    //

    PolyLineType::
    PolyLineType ()
    : ::xsd::qif30::ArrayPointType ()
    {
    }

    PolyLineType::
    PolyLineType (const count_type& count)
    : ::xsd::qif30::ArrayPointType (count)
    {
    }

    PolyLineType::
    PolyLineType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base,
                  const count_type& count)
    : ::xsd::qif30::ArrayPointType (_xsd_ListDoubleType_base,
                                    count)
    {
    }

    PolyLineType::
    PolyLineType (const PolyLineType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ArrayPointType (x, f, c)
    {
    }

    PolyLineType::
    PolyLineType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ArrayPointType (e, f, c)
    {
    }

    PolyLineType* PolyLineType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PolyLineType (*this, f, c);
    }

    PolyLineType::
    ~PolyLineType ()
    {
    }

    // PlaneType
    //

    PlaneType::
    PlaneType ()
    : ::xml_schema::type (),
      Point_ (this),
      Normal_ (this)
    {
    }

    PlaneType::
    PlaneType (const Point_type& Point,
               const Normal_type& Normal)
    : ::xml_schema::type (),
      Point_ (Point, this),
      Normal_ (Normal, this)
    {
    }

    PlaneType::
    PlaneType (::std::unique_ptr< Point_type > Point,
               ::std::unique_ptr< Normal_type > Normal)
    : ::xml_schema::type (),
      Point_ (std::move (Point), this),
      Normal_ (std::move (Normal), this)
    {
    }

    PlaneType::
    PlaneType (const PlaneType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    PlaneType::
    PlaneType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Point",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneType* PlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneType (*this, f, c);
    }

    PlaneType& PlaneType::
    operator= (const PlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Point_ = x.Point_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    PlaneType::
    ~PlaneType ()
    {
    }

    // PlaneXType
    //

    PlaneXType::
    PlaneXType ()
    : ::xsd::qif30::PlaneType (),
      Direction_ (this)
    {
    }

    PlaneXType::
    PlaneXType (const Point_type& Point,
                const Normal_type& Normal,
                const Direction_type& Direction)
    : ::xsd::qif30::PlaneType (Point,
                               Normal),
      Direction_ (Direction, this)
    {
    }

    PlaneXType::
    PlaneXType (::std::unique_ptr< Point_type > Point,
                ::std::unique_ptr< Normal_type > Normal,
                ::std::unique_ptr< Direction_type > Direction)
    : ::xsd::qif30::PlaneType (std::move (Point),
                               std::move (Normal)),
      Direction_ (std::move (Direction), this)
    {
    }

    PlaneXType::
    PlaneXType (const PlaneXType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::PlaneType (x, f, c),
      Direction_ (x.Direction_, f, this)
    {
    }

    PlaneXType::
    PlaneXType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::PlaneType (e, f | ::xml_schema::flags::base, c),
      Direction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneXType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PlaneType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Direction",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneXType* PlaneXType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneXType (*this, f, c);
    }

    PlaneXType& PlaneXType::
    operator= (const PlaneXType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PlaneType& > (*this) = x;
        this->Direction_ = x.Direction_;
      }

      return *this;
    }

    PlaneXType::
    ~PlaneXType ()
    {
    }

    // AxisType
    //

    AxisType::
    AxisType ()
    : ::xml_schema::type (),
      AxisPoint_ (this),
      Direction_ (this)
    {
    }

    AxisType::
    AxisType (const AxisPoint_type& AxisPoint,
              const Direction_type& Direction)
    : ::xml_schema::type (),
      AxisPoint_ (AxisPoint, this),
      Direction_ (Direction, this)
    {
    }

    AxisType::
    AxisType (::std::unique_ptr< AxisPoint_type > AxisPoint,
              ::std::unique_ptr< Direction_type > Direction)
    : ::xml_schema::type (),
      AxisPoint_ (std::move (AxisPoint), this),
      Direction_ (std::move (Direction), this)
    {
    }

    AxisType::
    AxisType (const AxisType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AxisPoint_ (x.AxisPoint_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    AxisType::
    AxisType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AxisPoint_ (this),
      Direction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AxisType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AxisPoint
        //
        if (n.name () == L"AxisPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisPoint_type > r (
            AxisPoint_traits::create (i, f, this));

          if (!AxisPoint_.present ())
          {
            this->AxisPoint_.set (::std::move (r));
            continue;
          }
        }

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AxisPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AxisPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Direction",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AxisType* AxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AxisType (*this, f, c);
    }

    AxisType& AxisType::
    operator= (const AxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AxisPoint_ = x.AxisPoint_;
        this->Direction_ = x.Direction_;
      }

      return *this;
    }

    AxisType::
    ~AxisType ()
    {
    }

    // TransformRotationType
    //

    TransformRotationType::
    TransformRotationType ()
    : ::xml_schema::type (),
      XDirection_ (this),
      YDirection_ (this),
      ZDirection_ (this)
    {
    }

    TransformRotationType::
    TransformRotationType (const XDirection_type& XDirection,
                           const YDirection_type& YDirection,
                           const ZDirection_type& ZDirection)
    : ::xml_schema::type (),
      XDirection_ (XDirection, this),
      YDirection_ (YDirection, this),
      ZDirection_ (ZDirection, this)
    {
    }

    TransformRotationType::
    TransformRotationType (const TransformRotationType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XDirection_ (x.XDirection_, f, this),
      YDirection_ (x.YDirection_, f, this),
      ZDirection_ (x.ZDirection_, f, this)
    {
    }

    TransformRotationType::
    TransformRotationType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XDirection_ (this),
      YDirection_ (this),
      ZDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TransformRotationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XDirection
        //
        if (n.name () == L"XDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XDirection_type > r (
            XDirection_traits::create (i, f, this));

          if (!XDirection_.present ())
          {
            this->XDirection_.set (::std::move (r));
            continue;
          }
        }

        // YDirection
        //
        if (n.name () == L"YDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< YDirection_type > r (
            YDirection_traits::create (i, f, this));

          if (!YDirection_.present ())
          {
            this->YDirection_.set (::std::move (r));
            continue;
          }
        }

        // ZDirection
        //
        if (n.name () == L"ZDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ZDirection_type > r (
            ZDirection_traits::create (i, f, this));

          if (!ZDirection_.present ())
          {
            this->ZDirection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!XDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"XDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!YDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"YDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ZDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ZDirection",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TransformRotationType* TransformRotationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformRotationType (*this, f, c);
    }

    TransformRotationType& TransformRotationType::
    operator= (const TransformRotationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XDirection_ = x.XDirection_;
        this->YDirection_ = x.YDirection_;
        this->ZDirection_ = x.ZDirection_;
      }

      return *this;
    }

    TransformRotationType::
    ~TransformRotationType ()
    {
    }

    // CoordinateSystemCoreType
    //

    CoordinateSystemCoreType::
    CoordinateSystemCoreType ()
    : ::xml_schema::type (),
      Rotation_ (this),
      Origin_ (this)
    {
    }

    CoordinateSystemCoreType::
    CoordinateSystemCoreType (const CoordinateSystemCoreType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Rotation_ (x.Rotation_, f, this),
      Origin_ (x.Origin_, f, this)
    {
    }

    CoordinateSystemCoreType::
    CoordinateSystemCoreType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Rotation_ (this),
      Origin_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoordinateSystemCoreType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Rotation
        //
        if (n.name () == L"Rotation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Rotation_type > r (
            Rotation_traits::create (i, f, this));

          if (!this->Rotation_)
          {
            this->Rotation_.set (::std::move (r));
            continue;
          }
        }

        // Origin
        //
        if (n.name () == L"Origin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          if (!this->Origin_)
          {
            this->Origin_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CoordinateSystemCoreType* CoordinateSystemCoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemCoreType (*this, f, c);
    }

    CoordinateSystemCoreType& CoordinateSystemCoreType::
    operator= (const CoordinateSystemCoreType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Rotation_ = x.Rotation_;
        this->Origin_ = x.Origin_;
      }

      return *this;
    }

    CoordinateSystemCoreType::
    ~CoordinateSystemCoreType ()
    {
    }

    // TransformMatrixType
    //

    TransformMatrixType::
    TransformMatrixType ()
    : ::xsd::qif30::CoordinateSystemCoreType (),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    TransformMatrixType::
    TransformMatrixType (const TransformMatrixType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CoordinateSystemCoreType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    TransformMatrixType::
    TransformMatrixType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CoordinateSystemCoreType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TransformMatrixType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CoordinateSystemCoreType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }
    }

    TransformMatrixType* TransformMatrixType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformMatrixType (*this, f, c);
    }

    TransformMatrixType& TransformMatrixType::
    operator= (const TransformMatrixType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CoordinateSystemCoreType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    TransformMatrixType::
    ~TransformMatrixType ()
    {
    }

    // LineSegmentType
    //

    LineSegmentType::
    LineSegmentType ()
    : ::xml_schema::type (),
      StartPoint_ (this),
      EndPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    LineSegmentType::
    LineSegmentType (const StartPoint_type& StartPoint,
                     const EndPoint_type& EndPoint)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, this),
      EndPoint_ (EndPoint, this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    LineSegmentType::
    LineSegmentType (const LineSegmentType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      EndPoint_ (x.EndPoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    LineSegmentType::
    LineSegmentType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (this),
      EndPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LineSegmentType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StartPoint
        //
        if (n.name () == L"StartPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (::std::move (r));
            continue;
          }
        }

        // EndPoint
        //
        if (n.name () == L"EndPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndPoint_type > r (
            EndPoint_traits::create (i, f, this));

          if (!EndPoint_.present ())
          {
            this->EndPoint_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StartPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!EndPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }
    }

    LineSegmentType* LineSegmentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineSegmentType (*this, f, c);
    }

    LineSegmentType& LineSegmentType::
    operator= (const LineSegmentType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StartPoint_ = x.StartPoint_;
        this->EndPoint_ = x.EndPoint_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    LineSegmentType::
    ~LineSegmentType ()
    {
    }

    // LineSegment2dType
    //

    LineSegment2dType::
    LineSegment2dType ()
    : ::xml_schema::type (),
      StartPoint_ (this),
      EndPoint_ (this)
    {
    }

    LineSegment2dType::
    LineSegment2dType (const StartPoint_type& StartPoint,
                       const EndPoint_type& EndPoint)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, this),
      EndPoint_ (EndPoint, this)
    {
    }

    LineSegment2dType::
    LineSegment2dType (const LineSegment2dType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      EndPoint_ (x.EndPoint_, f, this)
    {
    }

    LineSegment2dType::
    LineSegment2dType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (this),
      EndPoint_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineSegment2dType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StartPoint
        //
        if (n.name () == L"StartPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (::std::move (r));
            continue;
          }
        }

        // EndPoint
        //
        if (n.name () == L"EndPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndPoint_type > r (
            EndPoint_traits::create (i, f, this));

          if (!EndPoint_.present ())
          {
            this->EndPoint_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StartPoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!EndPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndPoint",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineSegment2dType* LineSegment2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineSegment2dType (*this, f, c);
    }

    LineSegment2dType& LineSegment2dType::
    operator= (const LineSegment2dType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StartPoint_ = x.StartPoint_;
        this->EndPoint_ = x.EndPoint_;
      }

      return *this;
    }

    LineSegment2dType::
    ~LineSegment2dType ()
    {
    }

    // LatitudeLongitudeSweepType
    //

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType ()
    : ::xml_schema::type (),
      DirMeridianPrime_ (this),
      DomainLatitude_ (this),
      DomainLongitude_ (this)
    {
    }

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType (const DirMeridianPrime_type& DirMeridianPrime,
                                const DomainLatitude_type& DomainLatitude,
                                const DomainLongitude_type& DomainLongitude)
    : ::xml_schema::type (),
      DirMeridianPrime_ (DirMeridianPrime, this),
      DomainLatitude_ (DomainLatitude, this),
      DomainLongitude_ (DomainLongitude, this)
    {
    }

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType (::std::unique_ptr< DirMeridianPrime_type > DirMeridianPrime,
                                ::std::unique_ptr< DomainLatitude_type > DomainLatitude,
                                ::std::unique_ptr< DomainLongitude_type > DomainLongitude)
    : ::xml_schema::type (),
      DirMeridianPrime_ (std::move (DirMeridianPrime), this),
      DomainLatitude_ (std::move (DomainLatitude), this),
      DomainLongitude_ (std::move (DomainLongitude), this)
    {
    }

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType (const LatitudeLongitudeSweepType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DirMeridianPrime_ (x.DirMeridianPrime_, f, this),
      DomainLatitude_ (x.DomainLatitude_, f, this),
      DomainLongitude_ (x.DomainLongitude_, f, this)
    {
    }

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DirMeridianPrime_ (this),
      DomainLatitude_ (this),
      DomainLongitude_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LatitudeLongitudeSweepType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DirMeridianPrime
        //
        if (n.name () == L"DirMeridianPrime" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirMeridianPrime_type > r (
            DirMeridianPrime_traits::create (i, f, this));

          if (!DirMeridianPrime_.present ())
          {
            this->DirMeridianPrime_.set (::std::move (r));
            continue;
          }
        }

        // DomainLatitude
        //
        if (n.name () == L"DomainLatitude" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DomainLatitude_type > r (
            DomainLatitude_traits::create (i, f, this));

          if (!DomainLatitude_.present ())
          {
            this->DomainLatitude_.set (::std::move (r));
            continue;
          }
        }

        // DomainLongitude
        //
        if (n.name () == L"DomainLongitude" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DomainLongitude_type > r (
            DomainLongitude_traits::create (i, f, this));

          if (!DomainLongitude_.present ())
          {
            this->DomainLongitude_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DirMeridianPrime_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirMeridianPrime",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DomainLatitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DomainLatitude",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DomainLongitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DomainLongitude",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LatitudeLongitudeSweepType* LatitudeLongitudeSweepType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LatitudeLongitudeSweepType (*this, f, c);
    }

    LatitudeLongitudeSweepType& LatitudeLongitudeSweepType::
    operator= (const LatitudeLongitudeSweepType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DirMeridianPrime_ = x.DirMeridianPrime_;
        this->DomainLatitude_ = x.DomainLatitude_;
        this->DomainLongitude_ = x.DomainLongitude_;
      }

      return *this;
    }

    LatitudeLongitudeSweepType::
    ~LatitudeLongitudeSweepType ()
    {
    }

    // OrientedLatitudeLongitudeSweepType
    //

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType ()
    : ::xsd::qif30::LatitudeLongitudeSweepType (),
      DirNorthPole_ (this)
    {
    }

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType (const DirMeridianPrime_type& DirMeridianPrime,
                                        const DomainLatitude_type& DomainLatitude,
                                        const DomainLongitude_type& DomainLongitude,
                                        const DirNorthPole_type& DirNorthPole)
    : ::xsd::qif30::LatitudeLongitudeSweepType (DirMeridianPrime,
                                                DomainLatitude,
                                                DomainLongitude),
      DirNorthPole_ (DirNorthPole, this)
    {
    }

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType (::std::unique_ptr< DirMeridianPrime_type > DirMeridianPrime,
                                        ::std::unique_ptr< DomainLatitude_type > DomainLatitude,
                                        ::std::unique_ptr< DomainLongitude_type > DomainLongitude,
                                        ::std::unique_ptr< DirNorthPole_type > DirNorthPole)
    : ::xsd::qif30::LatitudeLongitudeSweepType (std::move (DirMeridianPrime),
                                                std::move (DomainLatitude),
                                                std::move (DomainLongitude)),
      DirNorthPole_ (std::move (DirNorthPole), this)
    {
    }

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType (const OrientedLatitudeLongitudeSweepType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::LatitudeLongitudeSweepType (x, f, c),
      DirNorthPole_ (x.DirNorthPole_, f, this)
    {
    }

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::LatitudeLongitudeSweepType (e, f | ::xml_schema::flags::base, c),
      DirNorthPole_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrientedLatitudeLongitudeSweepType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LatitudeLongitudeSweepType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DirNorthPole
        //
        if (n.name () == L"DirNorthPole" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirNorthPole_type > r (
            DirNorthPole_traits::create (i, f, this));

          if (!DirNorthPole_.present ())
          {
            this->DirNorthPole_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DirNorthPole_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirNorthPole",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OrientedLatitudeLongitudeSweepType* OrientedLatitudeLongitudeSweepType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrientedLatitudeLongitudeSweepType (*this, f, c);
    }

    OrientedLatitudeLongitudeSweepType& OrientedLatitudeLongitudeSweepType::
    operator= (const OrientedLatitudeLongitudeSweepType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LatitudeLongitudeSweepType& > (*this) = x;
        this->DirNorthPole_ = x.DirNorthPole_;
      }

      return *this;
    }

    OrientedLatitudeLongitudeSweepType::
    ~OrientedLatitudeLongitudeSweepType ()
    {
    }

    // SweepType
    //

    SweepType::
    SweepType ()
    : ::xml_schema::type (),
      DirBeg_ (this),
      DomainAngle_ (this)
    {
    }

    SweepType::
    SweepType (const DirBeg_type& DirBeg,
               const DomainAngle_type& DomainAngle)
    : ::xml_schema::type (),
      DirBeg_ (DirBeg, this),
      DomainAngle_ (DomainAngle, this)
    {
    }

    SweepType::
    SweepType (::std::unique_ptr< DirBeg_type > DirBeg,
               ::std::unique_ptr< DomainAngle_type > DomainAngle)
    : ::xml_schema::type (),
      DirBeg_ (std::move (DirBeg), this),
      DomainAngle_ (std::move (DomainAngle), this)
    {
    }

    SweepType::
    SweepType (const SweepType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DirBeg_ (x.DirBeg_, f, this),
      DomainAngle_ (x.DomainAngle_, f, this)
    {
    }

    SweepType::
    SweepType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DirBeg_ (this),
      DomainAngle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SweepType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DirBeg
        //
        if (n.name () == L"DirBeg" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirBeg_type > r (
            DirBeg_traits::create (i, f, this));

          if (!DirBeg_.present ())
          {
            this->DirBeg_.set (::std::move (r));
            continue;
          }
        }

        // DomainAngle
        //
        if (n.name () == L"DomainAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DomainAngle_type > r (
            DomainAngle_traits::create (i, f, this));

          if (!DomainAngle_.present ())
          {
            this->DomainAngle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DirBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DirBeg",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DomainAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DomainAngle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SweepType* SweepType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SweepType (*this, f, c);
    }

    SweepType& SweepType::
    operator= (const SweepType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DirBeg_ = x.DirBeg_;
        this->DomainAngle_ = x.DomainAngle_;
      }

      return *this;
    }

    SweepType::
    ~SweepType ()
    {
    }

    // AngleRangeType
    //

    AngleRangeType::
    AngleRangeType ()
    : ::xsd::qif30::D2Type (),
      angularUnit_ (this)
    {
    }

    AngleRangeType::
    AngleRangeType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::D2Type (_xsd_ListDoubleType_base),
      angularUnit_ (this)
    {
    }

    AngleRangeType::
    AngleRangeType (const AngleRangeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::D2Type (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    AngleRangeType::
    AngleRangeType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::D2Type (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AngleRangeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    AngleRangeType* AngleRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleRangeType (*this, f, c);
    }

    AngleRangeType& AngleRangeType::
    operator= (const AngleRangeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::D2Type& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    AngleRangeType::
    ~AngleRangeType ()
    {
    }

    // QIFIdAndReferenceBaseType
    //

    QIFIdAndReferenceBaseType::
    QIFIdAndReferenceBaseType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > ()
    {
    }

    QIFIdAndReferenceBaseType::
    QIFIdAndReferenceBaseType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
    {
    }

    QIFIdAndReferenceBaseType::
    QIFIdAndReferenceBaseType (const QIFIdAndReferenceBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (x, f, c)
    {
    }

    QIFIdAndReferenceBaseType::
    QIFIdAndReferenceBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (e, f, c)
    {
    }

    QIFIdAndReferenceBaseType::
    QIFIdAndReferenceBaseType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (a, f, c)
    {
    }

    QIFIdAndReferenceBaseType::
    QIFIdAndReferenceBaseType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    QIFIdAndReferenceBaseType* QIFIdAndReferenceBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFIdAndReferenceBaseType (*this, f, c);
    }

    QIFIdAndReferenceBaseType::
    ~QIFIdAndReferenceBaseType ()
    {
    }

    // QIFIdType
    //

    QIFIdType::
    QIFIdType ()
    : ::xsd::qif30::QIFIdAndReferenceBaseType ()
    {
    }

    QIFIdType::
    QIFIdType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (_xsd_unsigned_int_base)
    {
    }

    QIFIdType::
    QIFIdType (const QIFIdType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (x, f, c)
    {
    }

    QIFIdType::
    QIFIdType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (e, f, c)
    {
    }

    QIFIdType::
    QIFIdType (const xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (a, f, c)
    {
    }

    QIFIdType::
    QIFIdType (const ::std::wstring& s,
               const xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (s, e, f, c)
    {
    }

    QIFIdType* QIFIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFIdType (*this, f, c);
    }

    QIFIdType::
    ~QIFIdType ()
    {
    }

    // QIFReferenceBaseType
    //

    QIFReferenceBaseType::
    QIFReferenceBaseType ()
    : ::xsd::qif30::QIFIdAndReferenceBaseType ()
    {
    }

    QIFReferenceBaseType::
    QIFReferenceBaseType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (_xsd_unsigned_int_base)
    {
    }

    QIFReferenceBaseType::
    QIFReferenceBaseType (const QIFReferenceBaseType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (x, f, c)
    {
    }

    QIFReferenceBaseType::
    QIFReferenceBaseType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (e, f, c)
    {
    }

    QIFReferenceBaseType::
    QIFReferenceBaseType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (a, f, c)
    {
    }

    QIFReferenceBaseType::
    QIFReferenceBaseType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::QIFIdAndReferenceBaseType (s, e, f, c)
    {
    }

    QIFReferenceBaseType* QIFReferenceBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFReferenceBaseType (*this, f, c);
    }

    QIFReferenceBaseType::
    ~QIFReferenceBaseType ()
    {
    }

    // QIFReferenceSimpleType
    //

    QIFReferenceSimpleType::
    QIFReferenceSimpleType ()
    : ::xsd::qif30::QIFReferenceBaseType ()
    {
    }

    QIFReferenceSimpleType::
    QIFReferenceSimpleType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif30::QIFReferenceBaseType (_xsd_unsigned_int_base)
    {
    }

    QIFReferenceSimpleType::
    QIFReferenceSimpleType (const QIFReferenceSimpleType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceBaseType (x, f, c)
    {
    }

    QIFReferenceSimpleType::
    QIFReferenceSimpleType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceBaseType (e, f, c)
    {
    }

    QIFReferenceSimpleType::
    QIFReferenceSimpleType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceBaseType (a, f, c)
    {
    }

    QIFReferenceSimpleType::
    QIFReferenceSimpleType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceBaseType (s, e, f, c)
    {
    }

    QIFReferenceSimpleType* QIFReferenceSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFReferenceSimpleType (*this, f, c);
    }

    QIFReferenceSimpleType::
    ~QIFReferenceSimpleType ()
    {
    }

    // QIFReferenceType
    //

    QIFReferenceType::
    QIFReferenceType ()
    : ::xsd::qif30::QIFReferenceBaseType (),
      xId_ (this)
    {
    }

    QIFReferenceType::
    QIFReferenceType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif30::QIFReferenceBaseType (_xsd_unsigned_int_base),
      xId_ (this)
    {
    }

    QIFReferenceType::
    QIFReferenceType (const QIFReferenceType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceBaseType (x, f, c),
      xId_ (x.xId_, f, this)
    {
    }

    QIFReferenceType::
    QIFReferenceType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceBaseType (e, f | ::xml_schema::flags::base, c),
      xId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void QIFReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"xId" && n.namespace_ ().empty ())
        {
          this->xId_.set (xId_traits::create (i, f, this));
          continue;
        }
      }
    }

    QIFReferenceType* QIFReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFReferenceType (*this, f, c);
    }

    QIFReferenceType& QIFReferenceType::
    operator= (const QIFReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::QIFReferenceBaseType& > (*this) = x;
        this->xId_ = x.xId_;
      }

      return *this;
    }

    QIFReferenceType::
    ~QIFReferenceType ()
    {
    }

    // ListQIFReferenceSimpleType
    //

    ListQIFReferenceSimpleType::
    ListQIFReferenceSimpleType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t > (e, f, this)
    {
    }

    ListQIFReferenceSimpleType::
    ListQIFReferenceSimpleType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t > (a, f, this)
    {
    }

    ListQIFReferenceSimpleType::
    ListQIFReferenceSimpleType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t > (s, e, f, this)
    {
    }

    ListQIFReferenceSimpleType* ListQIFReferenceSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListQIFReferenceSimpleType (*this, f, c);
    }

    ListQIFReferenceSimpleType::
    ~ListQIFReferenceSimpleType ()
    {
    }

    // ListQIFReferenceType
    //

    ListQIFReferenceType::
    ListQIFReferenceType ()
    : ::xml_schema::type (),
      Ids_ (this),
      Id_ (this),
      XIds_ (this),
      n_ (this)
    {
    }

    ListQIFReferenceType::
    ListQIFReferenceType (const n_type& n)
    : ::xml_schema::type (),
      Ids_ (this),
      Id_ (this),
      XIds_ (this),
      n_ (n, this)
    {
    }

    ListQIFReferenceType::
    ListQIFReferenceType (const ListQIFReferenceType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Ids_ (x.Ids_, f, this),
      Id_ (x.Id_, f, this),
      XIds_ (x.XIds_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ListQIFReferenceType::
    ListQIFReferenceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Ids_ (this),
      Id_ (this),
      XIds_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ListQIFReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Ids
        //
        if (n.name () == L"Ids" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Ids_type > r (
            Ids_traits::create (i, f, this));

          if (!this->Ids_)
          {
            this->Ids_.set (::std::move (r));
            continue;
          }
        }

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          if (!this->Id_)
          {
            this->Id_.set (::std::move (r));
            continue;
          }
        }

        // XIds
        //
        if (n.name () == L"XIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XIds_type > r (
            XIds_traits::create (i, f, this));

          if (!this->XIds_)
          {
            this->XIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ListQIFReferenceType* ListQIFReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListQIFReferenceType (*this, f, c);
    }

    ListQIFReferenceType& ListQIFReferenceType::
    operator= (const ListQIFReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Ids_ = x.Ids_;
        this->Id_ = x.Id_;
        this->XIds_ = x.XIds_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ListQIFReferenceType::
    ~ListQIFReferenceType ()
    {
    }

    // ListQIFReferenceFullType
    //

    ListQIFReferenceFullType::
    ListQIFReferenceFullType ()
    : ::xsd::qif30::ListQIFReferenceType (),
      asmPathId_ (this),
      asmPathXId_ (this)
    {
    }

    ListQIFReferenceFullType::
    ListQIFReferenceFullType (const n_type& n)
    : ::xsd::qif30::ListQIFReferenceType (n),
      asmPathId_ (this),
      asmPathXId_ (this)
    {
    }

    ListQIFReferenceFullType::
    ListQIFReferenceFullType (const ListQIFReferenceFullType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ListQIFReferenceType (x, f, c),
      asmPathId_ (x.asmPathId_, f, this),
      asmPathXId_ (x.asmPathXId_, f, this)
    {
    }

    ListQIFReferenceFullType::
    ListQIFReferenceFullType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ListQIFReferenceType (e, f | ::xml_schema::flags::base, c),
      asmPathId_ (this),
      asmPathXId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ListQIFReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ListQIFReferenceType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"asmPathId" && n.namespace_ ().empty ())
        {
          this->asmPathId_.set (asmPathId_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"asmPathXId" && n.namespace_ ().empty ())
        {
          this->asmPathXId_.set (asmPathXId_traits::create (i, f, this));
          continue;
        }
      }
    }

    ListQIFReferenceFullType* ListQIFReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListQIFReferenceFullType (*this, f, c);
    }

    ListQIFReferenceFullType& ListQIFReferenceFullType::
    operator= (const ListQIFReferenceFullType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListQIFReferenceType& > (*this) = x;
        this->asmPathId_ = x.asmPathId_;
        this->asmPathXId_ = x.asmPathXId_;
      }

      return *this;
    }

    ListQIFReferenceFullType::
    ~ListQIFReferenceFullType ()
    {
    }

    // ArrayBinaryQIFReferenceType
    //

    ArrayBinaryQIFReferenceType::
    ArrayBinaryQIFReferenceType ()
    : ::xml_schema::type (),
      Ids_ (this),
      Id_ (this),
      XIds_ (this)
    {
    }

    ArrayBinaryQIFReferenceType::
    ArrayBinaryQIFReferenceType (const ArrayBinaryQIFReferenceType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Ids_ (x.Ids_, f, this),
      Id_ (x.Id_, f, this),
      XIds_ (x.XIds_, f, this)
    {
    }

    ArrayBinaryQIFReferenceType::
    ArrayBinaryQIFReferenceType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Ids_ (this),
      Id_ (this),
      XIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArrayBinaryQIFReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Ids
        //
        if (n.name () == L"Ids" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Ids_type > r (
            Ids_traits::create (i, f, this));

          if (!this->Ids_)
          {
            this->Ids_.set (::std::move (r));
            continue;
          }
        }

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          if (!this->Id_)
          {
            this->Id_.set (::std::move (r));
            continue;
          }
        }

        // XIds
        //
        if (n.name () == L"XIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XIds_type > r (
            XIds_traits::create (i, f, this));

          if (!this->XIds_)
          {
            this->XIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ArrayBinaryQIFReferenceType* ArrayBinaryQIFReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayBinaryQIFReferenceType (*this, f, c);
    }

    ArrayBinaryQIFReferenceType& ArrayBinaryQIFReferenceType::
    operator= (const ArrayBinaryQIFReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Ids_ = x.Ids_;
        this->Id_ = x.Id_;
        this->XIds_ = x.XIds_;
      }

      return *this;
    }

    ArrayBinaryQIFReferenceType::
    ~ArrayBinaryQIFReferenceType ()
    {
    }

    // ArrayBinaryQIFReferenceFullType
    //

    ArrayBinaryQIFReferenceFullType::
    ArrayBinaryQIFReferenceFullType ()
    : ::xsd::qif30::ArrayBinaryQIFReferenceType (),
      asmPathId_ (this),
      asmPathXId_ (this)
    {
    }

    ArrayBinaryQIFReferenceFullType::
    ArrayBinaryQIFReferenceFullType (const ArrayBinaryQIFReferenceFullType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ArrayBinaryQIFReferenceType (x, f, c),
      asmPathId_ (x.asmPathId_, f, this),
      asmPathXId_ (x.asmPathXId_, f, this)
    {
    }

    ArrayBinaryQIFReferenceFullType::
    ArrayBinaryQIFReferenceFullType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ArrayBinaryQIFReferenceType (e, f | ::xml_schema::flags::base, c),
      asmPathId_ (this),
      asmPathXId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArrayBinaryQIFReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ArrayBinaryQIFReferenceType::parse (p, f);

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"asmPathId" && n.namespace_ ().empty ())
        {
          this->asmPathId_.set (asmPathId_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"asmPathXId" && n.namespace_ ().empty ())
        {
          this->asmPathXId_.set (asmPathXId_traits::create (i, f, this));
          continue;
        }
      }
    }

    ArrayBinaryQIFReferenceFullType* ArrayBinaryQIFReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayBinaryQIFReferenceFullType (*this, f, c);
    }

    ArrayBinaryQIFReferenceFullType& ArrayBinaryQIFReferenceFullType::
    operator= (const ArrayBinaryQIFReferenceFullType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ArrayBinaryQIFReferenceType& > (*this) = x;
        this->asmPathId_ = x.asmPathId_;
        this->asmPathXId_ = x.asmPathXId_;
      }

      return *this;
    }

    ArrayBinaryQIFReferenceFullType::
    ~ArrayBinaryQIFReferenceFullType ()
    {
    }

    // QIFReferenceActiveType
    //

    QIFReferenceActiveType::
    QIFReferenceActiveType ()
    : ::xsd::qif30::QIFReferenceType (),
      active_ (active_default_value (), this)
    {
    }

    QIFReferenceActiveType::
    QIFReferenceActiveType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif30::QIFReferenceType (_xsd_unsigned_int_base),
      active_ (active_default_value (), this)
    {
    }

    QIFReferenceActiveType::
    QIFReferenceActiveType (const QIFReferenceActiveType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceType (x, f, c),
      active_ (x.active_, f, this)
    {
    }

    QIFReferenceActiveType::
    QIFReferenceActiveType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceType (e, f | ::xml_schema::flags::base, c),
      active_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void QIFReferenceActiveType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::QIFReferenceType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"active" && n.namespace_ ().empty ())
        {
          this->active_.set (active_traits::create (i, f, this));
          continue;
        }
      }

      if (!active_.present ())
      {
        this->active_.set (active_default_value ());
      }
    }

    QIFReferenceActiveType* QIFReferenceActiveType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFReferenceActiveType (*this, f, c);
    }

    QIFReferenceActiveType& QIFReferenceActiveType::
    operator= (const QIFReferenceActiveType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::QIFReferenceType& > (*this) = x;
        this->active_ = x.active_;
      }

      return *this;
    }

    QIFReferenceActiveType::
    ~QIFReferenceActiveType ()
    {
    }

    // QIFReferenceFullType
    //

    QIFReferenceFullType::
    QIFReferenceFullType ()
    : ::xsd::qif30::QIFReferenceType (),
      asmPathId_ (this),
      asmPathXId_ (this)
    {
    }

    QIFReferenceFullType::
    QIFReferenceFullType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif30::QIFReferenceType (_xsd_unsigned_int_base),
      asmPathId_ (this),
      asmPathXId_ (this)
    {
    }

    QIFReferenceFullType::
    QIFReferenceFullType (const QIFReferenceFullType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceType (x, f, c),
      asmPathId_ (x.asmPathId_, f, this),
      asmPathXId_ (x.asmPathXId_, f, this)
    {
    }

    QIFReferenceFullType::
    QIFReferenceFullType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::QIFReferenceType (e, f | ::xml_schema::flags::base, c),
      asmPathId_ (this),
      asmPathXId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void QIFReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::QIFReferenceType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"asmPathId" && n.namespace_ ().empty ())
        {
          this->asmPathId_.set (asmPathId_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"asmPathXId" && n.namespace_ ().empty ())
        {
          this->asmPathXId_.set (asmPathXId_traits::create (i, f, this));
          continue;
        }
      }
    }

    QIFReferenceFullType* QIFReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFReferenceFullType (*this, f, c);
    }

    QIFReferenceFullType& QIFReferenceFullType::
    operator= (const QIFReferenceFullType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::QIFReferenceType& > (*this) = x;
        this->asmPathId_ = x.asmPathId_;
        this->asmPathXId_ = x.asmPathXId_;
      }

      return *this;
    }

    QIFReferenceFullType::
    ~QIFReferenceFullType ()
    {
    }

    // ElementReferenceType
    //

    ElementReferenceType::
    ElementReferenceType ()
    : ::xml_schema::type (),
      Id_ (this)
    {
    }

    ElementReferenceType::
    ElementReferenceType (const Id_type& Id)
    : ::xml_schema::type (),
      Id_ (Id, this)
    {
    }

    ElementReferenceType::
    ElementReferenceType (::std::unique_ptr< Id_type > Id)
    : ::xml_schema::type (),
      Id_ (std::move (Id), this)
    {
    }

    ElementReferenceType::
    ElementReferenceType (const ElementReferenceType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this)
    {
    }

    ElementReferenceType::
    ElementReferenceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElementReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          if (!Id_.present ())
          {
            this->Id_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Id",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElementReferenceType* ElementReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElementReferenceType (*this, f, c);
    }

    ElementReferenceType& ElementReferenceType::
    operator= (const ElementReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    ElementReferenceType::
    ~ElementReferenceType ()
    {
    }

    // ElementReferenceFullType
    //

    ElementReferenceFullType::
    ElementReferenceFullType ()
    : ::xml_schema::type (),
      Id_ (this)
    {
    }

    ElementReferenceFullType::
    ElementReferenceFullType (const Id_type& Id)
    : ::xml_schema::type (),
      Id_ (Id, this)
    {
    }

    ElementReferenceFullType::
    ElementReferenceFullType (::std::unique_ptr< Id_type > Id)
    : ::xml_schema::type (),
      Id_ (std::move (Id), this)
    {
    }

    ElementReferenceFullType::
    ElementReferenceFullType (const ElementReferenceFullType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this)
    {
    }

    ElementReferenceFullType::
    ElementReferenceFullType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElementReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          if (!Id_.present ())
          {
            this->Id_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Id",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElementReferenceFullType* ElementReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElementReferenceFullType (*this, f, c);
    }

    ElementReferenceFullType& ElementReferenceFullType::
    operator= (const ElementReferenceFullType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    ElementReferenceFullType::
    ~ElementReferenceFullType ()
    {
    }

    // D4Type
    //

    D4Type::
    D4Type ()
    : ::xsd::qif30::ListDoubleType ()
    {
    }

    D4Type::
    D4Type (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    D4Type::
    D4Type (const D4Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c)
    {
    }

    D4Type::
    D4Type (const xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f, c)
    {
    }

    D4Type::
    D4Type (const xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (a, f, c)
    {
    }

    D4Type::
    D4Type (const ::std::wstring& s,
            const xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (s, e, f, c)
    {
    }

    D4Type* D4Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class D4Type (*this, f, c);
    }

    D4Type::
    ~D4Type ()
    {
    }

    // NaturalType
    //

    NaturalType::
    NaturalType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > ()
    {
    }

    NaturalType::
    NaturalType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
    {
    }

    NaturalType::
    NaturalType (const NaturalType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (x, f, c)
    {
    }

    NaturalType::
    NaturalType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (e, f, c)
    {
    }

    NaturalType::
    NaturalType (const xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (a, f, c)
    {
    }

    NaturalType::
    NaturalType (const ::std::wstring& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    NaturalType* NaturalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NaturalType (*this, f, c);
    }

    NaturalType::
    ~NaturalType ()
    {
    }

    // ListNaturalType
    //

    ListNaturalType::
    ListNaturalType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t > (e, f, this)
    {
    }

    ListNaturalType::
    ListNaturalType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t > (a, f, this)
    {
    }

    ListNaturalType::
    ListNaturalType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t > (s, e, f, this)
    {
    }

    ListNaturalType* ListNaturalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListNaturalType (*this, f, c);
    }

    ListNaturalType::
    ~ListNaturalType ()
    {
    }

    // Natural2Type
    //

    Natural2Type::
    Natural2Type ()
    : ::xsd::qif30::ListNaturalType ()
    {
    }

    Natural2Type::
    Natural2Type (const ::xsd::qif30::ListNaturalType& _xsd_ListNaturalType_base)
    : ::xsd::qif30::ListNaturalType (_xsd_ListNaturalType_base)
    {
    }

    Natural2Type::
    Natural2Type (const Natural2Type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ListNaturalType (x, f, c)
    {
    }

    Natural2Type::
    Natural2Type (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ListNaturalType (e, f, c)
    {
    }

    Natural2Type::
    Natural2Type (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ListNaturalType (a, f, c)
    {
    }

    Natural2Type::
    Natural2Type (const ::std::wstring& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ListNaturalType (s, e, f, c)
    {
    }

    Natural2Type* Natural2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Natural2Type (*this, f, c);
    }

    Natural2Type::
    ~Natural2Type ()
    {
    }

    // ArrayNaturalType
    //

    ArrayNaturalType::
    ArrayNaturalType ()
    : ::xsd::qif30::ListNaturalType (),
      count_ (this)
    {
    }

    ArrayNaturalType::
    ArrayNaturalType (const count_type& count)
    : ::xsd::qif30::ListNaturalType (),
      count_ (count, this)
    {
    }

    ArrayNaturalType::
    ArrayNaturalType (const ::xsd::qif30::ListNaturalType& _xsd_ListNaturalType_base,
                      const count_type& count)
    : ::xsd::qif30::ListNaturalType (_xsd_ListNaturalType_base),
      count_ (count, this)
    {
    }

    ArrayNaturalType::
    ArrayNaturalType (const ArrayNaturalType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ListNaturalType (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    ArrayNaturalType::
    ArrayNaturalType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ListNaturalType (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayNaturalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayNaturalType* ArrayNaturalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayNaturalType (*this, f, c);
    }

    ArrayNaturalType& ArrayNaturalType::
    operator= (const ArrayNaturalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListNaturalType& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    ArrayNaturalType::
    ~ArrayNaturalType ()
    {
    }

    // FractionType
    //

    FractionType::
    FractionType ()
    : ::xml_schema::type (),
      Numerator_ (this),
      Denominator_ (this)
    {
    }

    FractionType::
    FractionType (const Numerator_type& Numerator,
                  const Denominator_type& Denominator)
    : ::xml_schema::type (),
      Numerator_ (Numerator, this),
      Denominator_ (Denominator, this)
    {
    }

    FractionType::
    FractionType (const FractionType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Numerator_ (x.Numerator_, f, this),
      Denominator_ (x.Denominator_, f, this)
    {
    }

    FractionType::
    FractionType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Numerator_ (this),
      Denominator_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FractionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Numerator
        //
        if (n.name () == L"Numerator" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Numerator_type > r (
            Numerator_traits::create (i, f, this));

          if (!Numerator_.present ())
          {
            this->Numerator_.set (::std::move (r));
            continue;
          }
        }

        // Denominator
        //
        if (n.name () == L"Denominator" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Denominator_type > r (
            Denominator_traits::create (i, f, this));

          if (!Denominator_.present ())
          {
            this->Denominator_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Numerator_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Numerator",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Denominator_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Denominator",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FractionType* FractionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FractionType (*this, f, c);
    }

    FractionType& FractionType::
    operator= (const FractionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Numerator_ = x.Numerator_;
        this->Denominator_ = x.Denominator_;
      }

      return *this;
    }

    FractionType::
    ~FractionType ()
    {
    }

    // ArrayReferenceType
    //

    ArrayReferenceType::
    ArrayReferenceType ()
    : ::xml_schema::type (),
      Id_ (this),
      n_ (this)
    {
    }

    ArrayReferenceType::
    ArrayReferenceType (const n_type& n)
    : ::xml_schema::type (),
      Id_ (this),
      n_ (n, this)
    {
    }

    ArrayReferenceType::
    ArrayReferenceType (const ArrayReferenceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ArrayReferenceType::
    ArrayReferenceType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArrayReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          this->Id_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ArrayReferenceType* ArrayReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayReferenceType (*this, f, c);
    }

    ArrayReferenceType& ArrayReferenceType::
    operator= (const ArrayReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Id_ = x.Id_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ArrayReferenceType::
    ~ArrayReferenceType ()
    {
    }

    // ArrayReferenceActiveType
    //

    ArrayReferenceActiveType::
    ArrayReferenceActiveType ()
    : ::xml_schema::type (),
      Id_ (this),
      n_ (this)
    {
    }

    ArrayReferenceActiveType::
    ArrayReferenceActiveType (const n_type& n)
    : ::xml_schema::type (),
      Id_ (this),
      n_ (n, this)
    {
    }

    ArrayReferenceActiveType::
    ArrayReferenceActiveType (const ArrayReferenceActiveType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ArrayReferenceActiveType::
    ArrayReferenceActiveType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArrayReferenceActiveType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          this->Id_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ArrayReferenceActiveType* ArrayReferenceActiveType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayReferenceActiveType (*this, f, c);
    }

    ArrayReferenceActiveType& ArrayReferenceActiveType::
    operator= (const ArrayReferenceActiveType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Id_ = x.Id_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ArrayReferenceActiveType::
    ~ArrayReferenceActiveType ()
    {
    }

    // ArrayReferenceFullType
    //

    ArrayReferenceFullType::
    ArrayReferenceFullType ()
    : ::xml_schema::type (),
      Id_ (this),
      n_ (this)
    {
    }

    ArrayReferenceFullType::
    ArrayReferenceFullType (const n_type& n)
    : ::xml_schema::type (),
      Id_ (this),
      n_ (n, this)
    {
    }

    ArrayReferenceFullType::
    ArrayReferenceFullType (const ArrayReferenceFullType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ArrayReferenceFullType::
    ArrayReferenceFullType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArrayReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Id
        //
        if (n.name () == L"Id" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          this->Id_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ArrayReferenceFullType* ArrayReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayReferenceFullType (*this, f, c);
    }

    ArrayReferenceFullType& ArrayReferenceFullType::
    operator= (const ArrayReferenceFullType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Id_ = x.Id_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ArrayReferenceFullType::
    ~ArrayReferenceFullType ()
    {
    }

    // QIFFeaturePairType
    //

    QIFFeaturePairType::
    QIFFeaturePairType ()
    : ::xml_schema::type (),
      FirstFeature_ (this),
      SecondFeature_ (this),
      FirstFeatureZone_ (this),
      SecondFeatureZone_ (this)
    {
    }

    QIFFeaturePairType::
    QIFFeaturePairType (const FirstFeature_type& FirstFeature,
                        const SecondFeature_type& SecondFeature)
    : ::xml_schema::type (),
      FirstFeature_ (FirstFeature, this),
      SecondFeature_ (SecondFeature, this),
      FirstFeatureZone_ (this),
      SecondFeatureZone_ (this)
    {
    }

    QIFFeaturePairType::
    QIFFeaturePairType (::std::unique_ptr< FirstFeature_type > FirstFeature,
                        ::std::unique_ptr< SecondFeature_type > SecondFeature)
    : ::xml_schema::type (),
      FirstFeature_ (std::move (FirstFeature), this),
      SecondFeature_ (std::move (SecondFeature), this),
      FirstFeatureZone_ (this),
      SecondFeatureZone_ (this)
    {
    }

    QIFFeaturePairType::
    QIFFeaturePairType (const QIFFeaturePairType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FirstFeature_ (x.FirstFeature_, f, this),
      SecondFeature_ (x.SecondFeature_, f, this),
      FirstFeatureZone_ (x.FirstFeatureZone_, f, this),
      SecondFeatureZone_ (x.SecondFeatureZone_, f, this)
    {
    }

    QIFFeaturePairType::
    QIFFeaturePairType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FirstFeature_ (this),
      SecondFeature_ (this),
      FirstFeatureZone_ (this),
      SecondFeatureZone_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void QIFFeaturePairType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FirstFeature
        //
        if (n.name () == L"FirstFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FirstFeature_type > r (
            FirstFeature_traits::create (i, f, this));

          if (!FirstFeature_.present ())
          {
            this->FirstFeature_.set (::std::move (r));
            continue;
          }
        }

        // SecondFeature
        //
        if (n.name () == L"SecondFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondFeature_type > r (
            SecondFeature_traits::create (i, f, this));

          if (!SecondFeature_.present ())
          {
            this->SecondFeature_.set (::std::move (r));
            continue;
          }
        }

        // FirstFeatureZone
        //
        if (n.name () == L"FirstFeatureZone" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FirstFeatureZone_type > r (
            FirstFeatureZone_traits::create (i, f, this));

          if (!this->FirstFeatureZone_)
          {
            this->FirstFeatureZone_.set (::std::move (r));
            continue;
          }
        }

        // SecondFeatureZone
        //
        if (n.name () == L"SecondFeatureZone" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SecondFeatureZone_type > r (
            SecondFeatureZone_traits::create (i, f, this));

          if (!this->SecondFeatureZone_)
          {
            this->SecondFeatureZone_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FirstFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FirstFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SecondFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SecondFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    QIFFeaturePairType* QIFFeaturePairType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFFeaturePairType (*this, f, c);
    }

    QIFFeaturePairType& QIFFeaturePairType::
    operator= (const QIFFeaturePairType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FirstFeature_ = x.FirstFeature_;
        this->SecondFeature_ = x.SecondFeature_;
        this->FirstFeatureZone_ = x.FirstFeatureZone_;
        this->SecondFeatureZone_ = x.SecondFeatureZone_;
      }

      return *this;
    }

    QIFFeaturePairType::
    ~QIFFeaturePairType ()
    {
    }

    // ArrayPairReferenceFullType
    //

    ArrayPairReferenceFullType::
    ArrayPairReferenceFullType ()
    : ::xml_schema::type (),
      FeaturePair_ (this),
      n_ (this)
    {
    }

    ArrayPairReferenceFullType::
    ArrayPairReferenceFullType (const n_type& n)
    : ::xml_schema::type (),
      FeaturePair_ (this),
      n_ (n, this)
    {
    }

    ArrayPairReferenceFullType::
    ArrayPairReferenceFullType (const ArrayPairReferenceFullType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeaturePair_ (x.FeaturePair_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ArrayPairReferenceFullType::
    ArrayPairReferenceFullType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeaturePair_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArrayPairReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeaturePair
        //
        if (n.name () == L"FeaturePair" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeaturePair_type > r (
            FeaturePair_traits::create (i, f, this));

          this->FeaturePair_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ArrayPairReferenceFullType* ArrayPairReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayPairReferenceFullType (*this, f, c);
    }

    ArrayPairReferenceFullType& ArrayPairReferenceFullType::
    operator= (const ArrayPairReferenceFullType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeaturePair_ = x.FeaturePair_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ArrayPairReferenceFullType::
    ~ArrayPairReferenceFullType ()
    {
    }

    // ListUnsignedByteType
    //

    ListUnsignedByteType::
    ListUnsignedByteType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t > (e, f, this)
    {
    }

    ListUnsignedByteType::
    ListUnsignedByteType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t > (a, f, this)
    {
    }

    ListUnsignedByteType::
    ListUnsignedByteType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t > (s, e, f, this)
    {
    }

    ListUnsignedByteType* ListUnsignedByteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListUnsignedByteType (*this, f, c);
    }

    ListUnsignedByteType::
    ~ListUnsignedByteType ()
    {
    }

    // QPIdType
    //

    QPIdType::
    QPIdType ()
    : ::xml_schema::token ()
    {
    }

    QPIdType::
    QPIdType (const wchar_t* _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdType::
    QPIdType (const ::std::wstring& _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdType::
    QPIdType (const ::xml_schema::token& _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdType::
    QPIdType (const QPIdType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::token (x, f, c)
    {
    }

    QPIdType::
    QPIdType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::token (e, f, c)
    {
    }

    QPIdType::
    QPIdType (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::token (a, f, c)
    {
    }

    QPIdType::
    QPIdType (const ::std::wstring& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::token (s, e, f, c)
    {
    }

    QPIdType* QPIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QPIdType (*this, f, c);
    }

    QPIdType::
    ~QPIdType ()
    {
    }

    // QPIdReferenceType
    //

    QPIdReferenceType::
    QPIdReferenceType ()
    : ::xml_schema::token ()
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const wchar_t* _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const ::std::wstring& _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const ::xml_schema::token& _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const QPIdReferenceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::token (x, f, c)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::token (e, f, c)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::token (a, f, c)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::token (s, e, f, c)
    {
    }

    QPIdReferenceType* QPIdReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QPIdReferenceType (*this, f, c);
    }

    QPIdReferenceType::
    ~QPIdReferenceType ()
    {
    }

    // QPIdFullReferenceType
    //

    QPIdFullReferenceType::
    QPIdFullReferenceType ()
    : ::xml_schema::type (),
      ItemQPId_ (this),
      DocumentQPId_ (this)
    {
    }

    QPIdFullReferenceType::
    QPIdFullReferenceType (const ItemQPId_type& ItemQPId)
    : ::xml_schema::type (),
      ItemQPId_ (ItemQPId, this),
      DocumentQPId_ (this)
    {
    }

    QPIdFullReferenceType::
    QPIdFullReferenceType (const QPIdFullReferenceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ItemQPId_ (x.ItemQPId_, f, this),
      DocumentQPId_ (x.DocumentQPId_, f, this)
    {
    }

    QPIdFullReferenceType::
    QPIdFullReferenceType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ItemQPId_ (this),
      DocumentQPId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void QPIdFullReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ItemQPId
        //
        if (n.name () == L"ItemQPId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ItemQPId_type > r (
            ItemQPId_traits::create (i, f, this));

          if (!ItemQPId_.present ())
          {
            this->ItemQPId_.set (::std::move (r));
            continue;
          }
        }

        // DocumentQPId
        //
        if (n.name () == L"DocumentQPId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DocumentQPId_type > r (
            DocumentQPId_traits::create (i, f, this));

          this->DocumentQPId_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!ItemQPId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ItemQPId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    QPIdFullReferenceType* QPIdFullReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QPIdFullReferenceType (*this, f, c);
    }

    QPIdFullReferenceType& QPIdFullReferenceType::
    operator= (const QPIdFullReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ItemQPId_ = x.ItemQPId_;
        this->DocumentQPId_ = x.DocumentQPId_;
      }

      return *this;
    }

    QPIdFullReferenceType::
    ~QPIdFullReferenceType ()
    {
    }

    // ArrayQPIdFullReferenceType
    //

    ArrayQPIdFullReferenceType::
    ArrayQPIdFullReferenceType ()
    : ::xml_schema::type (),
      QPId_ (this),
      n_ (this)
    {
    }

    ArrayQPIdFullReferenceType::
    ArrayQPIdFullReferenceType (const n_type& n)
    : ::xml_schema::type (),
      QPId_ (this),
      n_ (n, this)
    {
    }

    ArrayQPIdFullReferenceType::
    ArrayQPIdFullReferenceType (const ArrayQPIdFullReferenceType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      QPId_ (x.QPId_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ArrayQPIdFullReferenceType::
    ArrayQPIdFullReferenceType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      QPId_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArrayQPIdFullReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // QPId
        //
        if (n.name () == L"QPId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< QPId_type > r (
            QPId_traits::create (i, f, this));

          this->QPId_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ArrayQPIdFullReferenceType* ArrayQPIdFullReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayQPIdFullReferenceType (*this, f, c);
    }

    ArrayQPIdFullReferenceType& ArrayQPIdFullReferenceType::
    operator= (const ArrayQPIdFullReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->QPId_ = x.QPId_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ArrayQPIdFullReferenceType::
    ~ArrayQPIdFullReferenceType ()
    {
    }

    // ArrayUnsignedByteType
    //

    ArrayUnsignedByteType::
    ArrayUnsignedByteType ()
    : ::xsd::qif30::ListUnsignedByteType (),
      count_ (this)
    {
    }

    ArrayUnsignedByteType::
    ArrayUnsignedByteType (const count_type& count)
    : ::xsd::qif30::ListUnsignedByteType (),
      count_ (count, this)
    {
    }

    ArrayUnsignedByteType::
    ArrayUnsignedByteType (const ::xsd::qif30::ListUnsignedByteType& _xsd_ListUnsignedByteType_base,
                           const count_type& count)
    : ::xsd::qif30::ListUnsignedByteType (_xsd_ListUnsignedByteType_base),
      count_ (count, this)
    {
    }

    ArrayUnsignedByteType::
    ArrayUnsignedByteType (const ArrayUnsignedByteType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ListUnsignedByteType (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    ArrayUnsignedByteType::
    ArrayUnsignedByteType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ListUnsignedByteType (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayUnsignedByteType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayUnsignedByteType* ArrayUnsignedByteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayUnsignedByteType (*this, f, c);
    }

    ArrayUnsignedByteType& ArrayUnsignedByteType::
    operator= (const ArrayUnsignedByteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListUnsignedByteType& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    ArrayUnsignedByteType::
    ~ArrayUnsignedByteType ()
    {
    }

    // ArrayIntType
    //

    ArrayIntType::
    ArrayIntType ()
    : ::xsd::qif30::ListIntType (),
      count_ (this)
    {
    }

    ArrayIntType::
    ArrayIntType (const count_type& count)
    : ::xsd::qif30::ListIntType (),
      count_ (count, this)
    {
    }

    ArrayIntType::
    ArrayIntType (const ::xsd::qif30::ListIntType& _xsd_ListIntType_base,
                  const count_type& count)
    : ::xsd::qif30::ListIntType (_xsd_ListIntType_base),
      count_ (count, this)
    {
    }

    ArrayIntType::
    ArrayIntType (const ArrayIntType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    ArrayIntType::
    ArrayIntType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayIntType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayIntType* ArrayIntType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayIntType (*this, f, c);
    }

    ArrayIntType& ArrayIntType::
    operator= (const ArrayIntType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListIntType& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    ArrayIntType::
    ~ArrayIntType ()
    {
    }

    // ArrayI2Type
    //

    ArrayI2Type::
    ArrayI2Type ()
    : ::xsd::qif30::ListIntType (),
      count_ (this)
    {
    }

    ArrayI2Type::
    ArrayI2Type (const count_type& count)
    : ::xsd::qif30::ListIntType (),
      count_ (count, this)
    {
    }

    ArrayI2Type::
    ArrayI2Type (const ::xsd::qif30::ListIntType& _xsd_ListIntType_base,
                 const count_type& count)
    : ::xsd::qif30::ListIntType (_xsd_ListIntType_base),
      count_ (count, this)
    {
    }

    ArrayI2Type::
    ArrayI2Type (const ArrayI2Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    ArrayI2Type::
    ArrayI2Type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayI2Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayI2Type* ArrayI2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayI2Type (*this, f, c);
    }

    ArrayI2Type& ArrayI2Type::
    operator= (const ArrayI2Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListIntType& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    ArrayI2Type::
    ~ArrayI2Type ()
    {
    }

    // ArrayI3Type
    //

    ArrayI3Type::
    ArrayI3Type ()
    : ::xsd::qif30::ListIntType (),
      count_ (this)
    {
    }

    ArrayI3Type::
    ArrayI3Type (const count_type& count)
    : ::xsd::qif30::ListIntType (),
      count_ (count, this)
    {
    }

    ArrayI3Type::
    ArrayI3Type (const ::xsd::qif30::ListIntType& _xsd_ListIntType_base,
                 const count_type& count)
    : ::xsd::qif30::ListIntType (_xsd_ListIntType_base),
      count_ (count, this)
    {
    }

    ArrayI3Type::
    ArrayI3Type (const ArrayI3Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    ArrayI3Type::
    ArrayI3Type (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif30::ListIntType (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayI3Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayI3Type* ArrayI3Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayI3Type (*this, f, c);
    }

    ArrayI3Type& ArrayI3Type::
    operator= (const ArrayI3Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListIntType& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    ArrayI3Type::
    ~ArrayI3Type ()
    {
    }

    // ArrayDoubleType
    //

    ArrayDoubleType::
    ArrayDoubleType ()
    : ::xsd::qif30::ListDoubleType (),
      count_ (this)
    {
    }

    ArrayDoubleType::
    ArrayDoubleType (const count_type& count)
    : ::xsd::qif30::ListDoubleType (),
      count_ (count, this)
    {
    }

    ArrayDoubleType::
    ArrayDoubleType (const ::xsd::qif30::ListDoubleType& _xsd_ListDoubleType_base,
                     const count_type& count)
    : ::xsd::qif30::ListDoubleType (_xsd_ListDoubleType_base),
      count_ (count, this)
    {
    }

    ArrayDoubleType::
    ArrayDoubleType (const ArrayDoubleType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    ArrayDoubleType::
    ArrayDoubleType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ListDoubleType (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayDoubleType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }
    }

    ArrayDoubleType* ArrayDoubleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayDoubleType (*this, f, c);
    }

    ArrayDoubleType& ArrayDoubleType::
    operator= (const ArrayDoubleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ListDoubleType& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    ArrayDoubleType::
    ~ArrayDoubleType ()
    {
    }

    // ArrayBinaryType
    //

    ArrayBinaryType::
    ArrayBinaryType ()
    : ::xml_schema::base64_binary (),
      count_ (this),
      sizeElement_ (this)
    {
    }

    ArrayBinaryType::
    ArrayBinaryType (const count_type& count,
                     const sizeElement_type& sizeElement)
    : ::xml_schema::base64_binary (),
      count_ (count, this),
      sizeElement_ (sizeElement, this)
    {
    }

    ArrayBinaryType::
    ArrayBinaryType (const ::xml_schema::base64_binary& _xsd_base64_binary_base,
                     const count_type& count,
                     const sizeElement_type& sizeElement)
    : ::xml_schema::base64_binary (_xsd_base64_binary_base),
      count_ (count, this),
      sizeElement_ (sizeElement, this)
    {
    }

    ArrayBinaryType::
    ArrayBinaryType (const ArrayBinaryType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::base64_binary (x, f, c),
      count_ (x.count_, f, this),
      sizeElement_ (x.sizeElement_, f, this)
    {
    }

    ArrayBinaryType::
    ArrayBinaryType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::base64_binary (e, f | ::xml_schema::flags::base, c),
      count_ (this),
      sizeElement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArrayBinaryType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"sizeElement" && n.namespace_ ().empty ())
        {
          this->sizeElement_.set (sizeElement_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }

      if (!sizeElement_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"sizeElement",
          L"");
      }
    }

    ArrayBinaryType* ArrayBinaryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayBinaryType (*this, f, c);
    }

    ArrayBinaryType& ArrayBinaryType::
    operator= (const ArrayBinaryType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::base64_binary& > (*this) = x;
        this->count_ = x.count_;
        this->sizeElement_ = x.sizeElement_;
      }

      return *this;
    }

    ArrayBinaryType::
    ~ArrayBinaryType ()
    {
    }

    // AttributesType
    //

    AttributesType::
    AttributesType ()
    : ::xml_schema::type (),
      Attribute_ (this),
      n_ (this)
    {
    }

    AttributesType::
    AttributesType (const n_type& n)
    : ::xml_schema::type (),
      Attribute_ (this),
      n_ (n, this)
    {
    }

    AttributesType::
    AttributesType (const AttributesType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attribute_ (x.Attribute_, f, this),
      n_ (x.n_, f, this)
    {
    }

    AttributesType::
    AttributesType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attribute_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AttributesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attribute
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"Attribute",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< Attribute_type > r (
              dynamic_cast< Attribute_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Attribute_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    AttributesType* AttributesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributesType (*this, f, c);
    }

    AttributesType& AttributesType::
    operator= (const AttributesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attribute_ = x.Attribute_;
        this->n_ = x.n_;
      }

      return *this;
    }

    AttributesType::
    ~AttributesType ()
    {
    }

    // AttributeBaseType
    //

    AttributeBaseType::
    AttributeBaseType ()
    : ::xml_schema::type (),
      name_ (this)
    {
    }

    AttributeBaseType::
    AttributeBaseType (const name_type& name)
    : ::xml_schema::type (),
      name_ (name, this)
    {
    }

    AttributeBaseType::
    AttributeBaseType (const AttributeBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this)
    {
    }

    AttributeBaseType::
    AttributeBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"name",
          L"");
      }
    }

    AttributeBaseType& AttributeBaseType::
    operator= (const AttributeBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
      }

      return *this;
    }

    AttributeBaseType::
    ~AttributeBaseType ()
    {
    }

    // AttributeBoolType
    //

    AttributeBoolType::
    AttributeBoolType ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeBoolType::
    AttributeBoolType (const name_type& name,
                       const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeBoolType::
    AttributeBoolType (const AttributeBoolType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeBoolType::
    AttributeBoolType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeBoolType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeBoolType* AttributeBoolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeBoolType (*this, f, c);
    }

    AttributeBoolType& AttributeBoolType::
    operator= (const AttributeBoolType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeBoolType::
    ~AttributeBoolType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeBoolType >
    _xsd_AttributeBoolType_type_factory_init (
      L"AttributeBoolType",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeStrType
    //

    AttributeStrType::
    AttributeStrType ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeStrType::
    AttributeStrType (const name_type& name,
                      const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeStrType::
    AttributeStrType (const AttributeStrType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeStrType::
    AttributeStrType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeStrType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeStrType* AttributeStrType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeStrType (*this, f, c);
    }

    AttributeStrType& AttributeStrType::
    operator= (const AttributeStrType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeStrType::
    ~AttributeStrType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeStrType >
    _xsd_AttributeStrType_type_factory_init (
      L"AttributeStrType",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeTimeType
    //

    AttributeTimeType::
    AttributeTimeType ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeTimeType::
    AttributeTimeType (const name_type& name,
                       const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeTimeType::
    AttributeTimeType (const AttributeTimeType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeTimeType::
    AttributeTimeType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeTimeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeTimeType* AttributeTimeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeTimeType (*this, f, c);
    }

    AttributeTimeType& AttributeTimeType::
    operator= (const AttributeTimeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeTimeType::
    ~AttributeTimeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeTimeType >
    _xsd_AttributeTimeType_type_factory_init (
      L"AttributeTimeType",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeQPIdType
    //

    AttributeQPIdType::
    AttributeQPIdType ()
    : ::xsd::qif30::AttributeBaseType (),
      Value_ (this)
    {
    }

    AttributeQPIdType::
    AttributeQPIdType (const name_type& name,
                       const Value_type& Value)
    : ::xsd::qif30::AttributeBaseType (name),
      Value_ (Value, this)
    {
    }

    AttributeQPIdType::
    AttributeQPIdType (const AttributeQPIdType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      Value_ (x.Value_, f, this)
    {
    }

    AttributeQPIdType::
    AttributeQPIdType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      Value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AttributeQPIdType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Value
        //
        if (n.name () == L"Value" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Value_type > r (
            Value_traits::create (i, f, this));

          if (!Value_.present ())
          {
            this->Value_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Value",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AttributeQPIdType* AttributeQPIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeQPIdType (*this, f, c);
    }

    AttributeQPIdType& AttributeQPIdType::
    operator= (const AttributeQPIdType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->Value_ = x.Value_;
      }

      return *this;
    }

    AttributeQPIdType::
    ~AttributeQPIdType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeQPIdType >
    _xsd_AttributeQPIdType_type_factory_init (
      L"AttributeQPIdType",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeI1Type
    //

    AttributeI1Type::
    AttributeI1Type ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeI1Type::
    AttributeI1Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeI1Type::
    AttributeI1Type (const AttributeI1Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeI1Type::
    AttributeI1Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeI1Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeI1Type* AttributeI1Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeI1Type (*this, f, c);
    }

    AttributeI1Type& AttributeI1Type::
    operator= (const AttributeI1Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeI1Type::
    ~AttributeI1Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeI1Type >
    _xsd_AttributeI1Type_type_factory_init (
      L"AttributeI1Type",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeI2Type
    //

    AttributeI2Type::
    AttributeI2Type ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeI2Type::
    AttributeI2Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeI2Type::
    AttributeI2Type (const AttributeI2Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeI2Type::
    AttributeI2Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeI2Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeI2Type* AttributeI2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeI2Type (*this, f, c);
    }

    AttributeI2Type& AttributeI2Type::
    operator= (const AttributeI2Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeI2Type::
    ~AttributeI2Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeI2Type >
    _xsd_AttributeI2Type_type_factory_init (
      L"AttributeI2Type",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeI3Type
    //

    AttributeI3Type::
    AttributeI3Type ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeI3Type::
    AttributeI3Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeI3Type::
    AttributeI3Type (const AttributeI3Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeI3Type::
    AttributeI3Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeI3Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeI3Type* AttributeI3Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeI3Type (*this, f, c);
    }

    AttributeI3Type& AttributeI3Type::
    operator= (const AttributeI3Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeI3Type::
    ~AttributeI3Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeI3Type >
    _xsd_AttributeI3Type_type_factory_init (
      L"AttributeI3Type",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeD1Type
    //

    AttributeD1Type::
    AttributeD1Type ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeD1Type::
    AttributeD1Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeD1Type::
    AttributeD1Type (const AttributeD1Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeD1Type::
    AttributeD1Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeD1Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeD1Type* AttributeD1Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeD1Type (*this, f, c);
    }

    AttributeD1Type& AttributeD1Type::
    operator= (const AttributeD1Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeD1Type::
    ~AttributeD1Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeD1Type >
    _xsd_AttributeD1Type_type_factory_init (
      L"AttributeD1Type",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeD2Type
    //

    AttributeD2Type::
    AttributeD2Type ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeD2Type::
    AttributeD2Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeD2Type::
    AttributeD2Type (const AttributeD2Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeD2Type::
    AttributeD2Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeD2Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeD2Type* AttributeD2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeD2Type (*this, f, c);
    }

    AttributeD2Type& AttributeD2Type::
    operator= (const AttributeD2Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeD2Type::
    ~AttributeD2Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeD2Type >
    _xsd_AttributeD2Type_type_factory_init (
      L"AttributeD2Type",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeD3Type
    //

    AttributeD3Type::
    AttributeD3Type ()
    : ::xsd::qif30::AttributeBaseType (),
      value_ (this)
    {
    }

    AttributeD3Type::
    AttributeD3Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif30::AttributeBaseType (name),
      value_ (value, this)
    {
    }

    AttributeD3Type::
    AttributeD3Type (const AttributeD3Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeD3Type::
    AttributeD3Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AttributeD3Type::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"value",
          L"");
      }
    }

    AttributeD3Type* AttributeD3Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeD3Type (*this, f, c);
    }

    AttributeD3Type& AttributeD3Type::
    operator= (const AttributeD3Type& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    AttributeD3Type::
    ~AttributeD3Type ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeD3Type >
    _xsd_AttributeD3Type_type_factory_init (
      L"AttributeD3Type",
      L"http://qifstandards.org/xsd/qif3");

    // AttributeUserType
    //

    AttributeUserType::
    AttributeUserType ()
    : ::xsd::qif30::AttributeBaseType (),
      UserDataXML_ (this),
      UserDataBinary_ (this),
      nameUserAttribute_ (this)
    {
    }

    AttributeUserType::
    AttributeUserType (const name_type& name,
                       const nameUserAttribute_type& nameUserAttribute)
    : ::xsd::qif30::AttributeBaseType (name),
      UserDataXML_ (this),
      UserDataBinary_ (this),
      nameUserAttribute_ (nameUserAttribute, this)
    {
    }

    AttributeUserType::
    AttributeUserType (const AttributeUserType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (x, f, c),
      UserDataXML_ (x.UserDataXML_, f, this),
      UserDataBinary_ (x.UserDataBinary_, f, this),
      nameUserAttribute_ (x.nameUserAttribute_, f, this)
    {
    }

    AttributeUserType::
    AttributeUserType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      UserDataXML_ (this),
      UserDataBinary_ (this),
      nameUserAttribute_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AttributeUserType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::AttributeBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // UserDataXML
        //
        if (n.name () == L"UserDataXML" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDataXML_type > r (
            UserDataXML_traits::create (i, f, this));

          if (!this->UserDataXML_)
          {
            this->UserDataXML_.set (::std::move (r));
            continue;
          }
        }

        // UserDataBinary
        //
        if (n.name () == L"UserDataBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDataBinary_type > r (
            UserDataBinary_traits::create (i, f, this));

          if (!this->UserDataBinary_)
          {
            this->UserDataBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"nameUserAttribute" && n.namespace_ ().empty ())
        {
          this->nameUserAttribute_.set (nameUserAttribute_traits::create (i, f, this));
          continue;
        }
      }

      if (!nameUserAttribute_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"nameUserAttribute",
          L"");
      }
    }

    AttributeUserType* AttributeUserType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeUserType (*this, f, c);
    }

    AttributeUserType& AttributeUserType::
    operator= (const AttributeUserType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::AttributeBaseType& > (*this) = x;
        this->UserDataXML_ = x.UserDataXML_;
        this->UserDataBinary_ = x.UserDataBinary_;
        this->nameUserAttribute_ = x.nameUserAttribute_;
      }

      return *this;
    }

    AttributeUserType::
    ~AttributeUserType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeUserType >
    _xsd_AttributeUserType_type_factory_init (
      L"AttributeUserType",
      L"http://qifstandards.org/xsd/qif3");

    // UserDataXMLType
    //

    UserDataXMLType::
    UserDataXMLType ()
    : ::xml_schema::type ()
    {
    }

    UserDataXMLType::
    UserDataXMLType (const UserDataXMLType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    UserDataXMLType::
    UserDataXMLType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDataXMLType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        break;
      }
    }

    UserDataXMLType* UserDataXMLType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDataXMLType (*this, f, c);
    }

    UserDataXMLType::
    ~UserDataXMLType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeBool_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeBool",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeBoolType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeStr_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeStr",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeStrType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeTime_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeTime",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeTimeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeQPId_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeQPId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeQPIdType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeI1_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeI1",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeI1Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeI2_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeI2",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeI2Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeI3_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeI3",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeI3Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeD1_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeD1",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeD1Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeD2_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeD2",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeD2Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeD3_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeD3",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeD3Type >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_AttributeUser_element_factory_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeUser",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::AttributeUserType >);


    // ValidationPointsType
    //

    ValidationPointsType::
    ValidationPointsType ()
    : ::xml_schema::type (),
      Points_ (this),
      PointsBinary_ (this),
      Directions_ (this),
      DirectionsBinary_ (this)
    {
    }

    ValidationPointsType::
    ValidationPointsType (const ValidationPointsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Points_ (x.Points_, f, this),
      PointsBinary_ (x.PointsBinary_, f, this),
      Directions_ (x.Directions_, f, this),
      DirectionsBinary_ (x.DirectionsBinary_, f, this)
    {
    }

    ValidationPointsType::
    ValidationPointsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Points_ (this),
      PointsBinary_ (this),
      Directions_ (this),
      DirectionsBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ValidationPointsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        // PointsBinary
        //
        if (n.name () == L"PointsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsBinary_type > r (
            PointsBinary_traits::create (i, f, this));

          if (!this->PointsBinary_)
          {
            this->PointsBinary_.set (::std::move (r));
            continue;
          }
        }

        // Directions
        //
        if (n.name () == L"Directions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Directions_type > r (
            Directions_traits::create (i, f, this));

          if (!this->Directions_)
          {
            this->Directions_.set (::std::move (r));
            continue;
          }
        }

        // DirectionsBinary
        //
        if (n.name () == L"DirectionsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirectionsBinary_type > r (
            DirectionsBinary_traits::create (i, f, this));

          if (!this->DirectionsBinary_)
          {
            this->DirectionsBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ValidationPointsType* ValidationPointsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidationPointsType (*this, f, c);
    }

    ValidationPointsType& ValidationPointsType::
    operator= (const ValidationPointsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Points_ = x.Points_;
        this->PointsBinary_ = x.PointsBinary_;
        this->Directions_ = x.Directions_;
        this->DirectionsBinary_ = x.DirectionsBinary_;
      }

      return *this;
    }

    ValidationPointsType::
    ~ValidationPointsType ()
    {
    }

    // BoundingBoxAxisAlignedType
    //

    BoundingBoxAxisAlignedType::
    BoundingBoxAxisAlignedType ()
    : ::xml_schema::type (),
      PointMin_ (this),
      PointMax_ (this)
    {
    }

    BoundingBoxAxisAlignedType::
    BoundingBoxAxisAlignedType (const PointMin_type& PointMin,
                                const PointMax_type& PointMax)
    : ::xml_schema::type (),
      PointMin_ (PointMin, this),
      PointMax_ (PointMax, this)
    {
    }

    BoundingBoxAxisAlignedType::
    BoundingBoxAxisAlignedType (const BoundingBoxAxisAlignedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointMin_ (x.PointMin_, f, this),
      PointMax_ (x.PointMax_, f, this)
    {
    }

    BoundingBoxAxisAlignedType::
    BoundingBoxAxisAlignedType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointMin_ (this),
      PointMax_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BoundingBoxAxisAlignedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointMin
        //
        if (n.name () == L"PointMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointMin_type > r (
            PointMin_traits::create (i, f, this));

          if (!PointMin_.present ())
          {
            this->PointMin_.set (::std::move (r));
            continue;
          }
        }

        // PointMax
        //
        if (n.name () == L"PointMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointMax_type > r (
            PointMax_traits::create (i, f, this));

          if (!PointMax_.present ())
          {
            this->PointMax_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PointMin_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointMin",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointMax_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointMax",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    BoundingBoxAxisAlignedType* BoundingBoxAxisAlignedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BoundingBoxAxisAlignedType (*this, f, c);
    }

    BoundingBoxAxisAlignedType& BoundingBoxAxisAlignedType::
    operator= (const BoundingBoxAxisAlignedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointMin_ = x.PointMin_;
        this->PointMax_ = x.PointMax_;
      }

      return *this;
    }

    BoundingBoxAxisAlignedType::
    ~BoundingBoxAxisAlignedType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const BinaryDataType& i)
    {
      e << static_cast< const ::xml_schema::base64_binary& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ListIntType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListIntType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListIntType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::integer, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const I2Type& i)
    {
      e << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const I2Type& i)
    {
      a << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const I2Type& i)
    {
      l << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const I3Type& i)
    {
      e << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const I3Type& i)
    {
      a << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const I3Type& i)
    {
      l << static_cast< const ::xsd::qif30::ListIntType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListDoubleType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListDoubleType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListDoubleType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::double_, wchar_t, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListBooleanType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListBooleanType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListBooleanType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::boolean, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListDateTimeType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListDateTimeType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListDateTimeType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::date_time, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListTokenType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListTokenType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListTokenType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::nmtoken, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const D3Type& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const D3Type& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const D3Type& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const D2Type& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const D2Type& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const D2Type& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DoublePositiveType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DoublePositiveType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DoublePositiveType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const Point2dSimpleType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const Point2dSimpleType& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const Point2dSimpleType& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const UnitVector2dSimpleType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const UnitVector2dSimpleType& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const UnitVector2dSimpleType& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ParameterRangeType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ParameterRangeType& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ParameterRangeType& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointSimpleType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const PointSimpleType& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PointSimpleType& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const VectorSimpleType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const VectorSimpleType& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const VectorSimpleType& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const UnitVectorSimpleType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const UnitVectorSimpleType& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const UnitVectorSimpleType& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ValidityEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ValidityEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ValidityEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointType& i)
    {
      e << static_cast< const ::xsd::qif30::PointSimpleType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VectorType& i)
    {
      e << static_cast< const ::xsd::qif30::VectorSimpleType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UnitVectorType& i)
    {
      e << static_cast< const ::xsd::qif30::UnitVectorSimpleType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayPoint2dType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayPointType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayUnitVectorType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PolyLineType& i)
    {
      e << static_cast< const ::xsd::qif30::ArrayPointType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Point
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Point ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneXType& i)
    {
      e << static_cast< const ::xsd::qif30::PlaneType& > (i);

      // Direction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Direction ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AxisType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AxisPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AxisPoint ();
      }

      // Direction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Direction ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TransformRotationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.XDirection ();
      }

      // YDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"YDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.YDirection ();
      }

      // ZDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ZDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ZDirection ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoordinateSystemCoreType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Rotation
      //
      if (i.Rotation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Rotation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Rotation ();
      }

      // Origin
      //
      if (i.Origin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Origin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Origin ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TransformMatrixType& i)
    {
      e << static_cast< const ::xsd::qif30::CoordinateSystemCoreType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineSegmentType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StartPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StartPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.StartPoint ();
      }

      // EndPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndPoint ();
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineSegment2dType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StartPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StartPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.StartPoint ();
      }

      // EndPoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndPoint ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LatitudeLongitudeSweepType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DirMeridianPrime
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirMeridianPrime",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirMeridianPrime ();
      }

      // DomainLatitude
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DomainLatitude",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DomainLatitude ();
      }

      // DomainLongitude
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DomainLongitude",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DomainLongitude ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OrientedLatitudeLongitudeSweepType& i)
    {
      e << static_cast< const ::xsd::qif30::LatitudeLongitudeSweepType& > (i);

      // DirNorthPole
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirNorthPole",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirNorthPole ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SweepType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DirBeg
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirBeg",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DirBeg ();
      }

      // DomainAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DomainAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DomainAngle ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AngleRangeType& i)
    {
      e << static_cast< const ::xsd::qif30::D2Type& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFIdAndReferenceBaseType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QIFIdAndReferenceBaseType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const QIFIdAndReferenceBaseType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFIdType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFIdAndReferenceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QIFIdType& i)
    {
      a << static_cast< const ::xsd::qif30::QIFIdAndReferenceBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const QIFIdType& i)
    {
      l << static_cast< const ::xsd::qif30::QIFIdAndReferenceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFReferenceBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFIdAndReferenceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QIFReferenceBaseType& i)
    {
      a << static_cast< const ::xsd::qif30::QIFIdAndReferenceBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const QIFReferenceBaseType& i)
    {
      l << static_cast< const ::xsd::qif30::QIFIdAndReferenceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFReferenceSimpleType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFReferenceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QIFReferenceSimpleType& i)
    {
      a << static_cast< const ::xsd::qif30::QIFReferenceBaseType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const QIFReferenceSimpleType& i)
    {
      l << static_cast< const ::xsd::qif30::QIFReferenceBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFReferenceType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFReferenceBaseType& > (i);

      // xId
      //
      if (i.xId ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xId",
            e));

        a << *i.xId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ListQIFReferenceSimpleType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListQIFReferenceSimpleType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListQIFReferenceSimpleType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::QIFReferenceSimpleType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListQIFReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Ids
      //
      if (i.Ids ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Ids",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Ids ();
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Id ();
      }

      // XIds
      //
      if (i.XIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.XIds ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ListQIFReferenceFullType& i)
    {
      e << static_cast< const ::xsd::qif30::ListQIFReferenceType& > (i);

      // asmPathId
      //
      if (i.asmPathId ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"asmPathId",
            e));

        a << *i.asmPathId ();
      }

      // asmPathXId
      //
      if (i.asmPathXId ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"asmPathXId",
            e));

        a << *i.asmPathXId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayBinaryQIFReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Ids
      //
      if (i.Ids ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Ids",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Ids ();
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Id ();
      }

      // XIds
      //
      if (i.XIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.XIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayBinaryQIFReferenceFullType& i)
    {
      e << static_cast< const ::xsd::qif30::ArrayBinaryQIFReferenceType& > (i);

      // asmPathId
      //
      if (i.asmPathId ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"asmPathId",
            e));

        a << *i.asmPathId ();
      }

      // asmPathXId
      //
      if (i.asmPathXId ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"asmPathXId",
            e));

        a << *i.asmPathXId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFReferenceActiveType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFReferenceType& > (i);

      // active
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"active",
            e));

        a << i.active ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFReferenceFullType& i)
    {
      e << static_cast< const ::xsd::qif30::QIFReferenceType& > (i);

      // asmPathId
      //
      if (i.asmPathId ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"asmPathId",
            e));

        a << *i.asmPathId ();
      }

      // asmPathXId
      //
      if (i.asmPathXId ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"asmPathXId",
            e));

        a << *i.asmPathXId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElementReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Id
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElementReferenceFullType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Id
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const D4Type& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const D4Type& i)
    {
      a << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const D4Type& i)
    {
      l << static_cast< const ::xsd::qif30::ListDoubleType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const NaturalType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const NaturalType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const NaturalType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ListNaturalType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListNaturalType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListNaturalType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xsd::qif30::NaturalType, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const Natural2Type& i)
    {
      e << static_cast< const ::xsd::qif30::ListNaturalType& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const Natural2Type& i)
    {
      a << static_cast< const ::xsd::qif30::ListNaturalType& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const Natural2Type& i)
    {
      l << static_cast< const ::xsd::qif30::ListNaturalType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayNaturalType& i)
    {
      e << static_cast< const ::xsd::qif30::ListNaturalType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FractionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Numerator
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Numerator",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Numerator ();
      }

      // Denominator
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Denominator",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Denominator ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Id
      //
      for (ArrayReferenceType::Id_const_iterator
           b (i.Id ().begin ()), n (i.Id ().end ());
           b != n; ++b)
      {
        const ArrayReferenceType::Id_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayReferenceActiveType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Id
      //
      for (ArrayReferenceActiveType::Id_const_iterator
           b (i.Id ().begin ()), n (i.Id ().end ());
           b != n; ++b)
      {
        const ArrayReferenceActiveType::Id_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayReferenceFullType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Id
      //
      for (ArrayReferenceFullType::Id_const_iterator
           b (i.Id ().begin ()), n (i.Id ().end ());
           b != n; ++b)
      {
        const ArrayReferenceFullType::Id_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Id",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const QIFFeaturePairType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FirstFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FirstFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FirstFeature ();
      }

      // SecondFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SecondFeature ();
      }

      // FirstFeatureZone
      //
      if (i.FirstFeatureZone ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FirstFeatureZone",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FirstFeatureZone ();
      }

      // SecondFeatureZone
      //
      if (i.SecondFeatureZone ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SecondFeatureZone",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SecondFeatureZone ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayPairReferenceFullType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeaturePair
      //
      for (ArrayPairReferenceFullType::FeaturePair_const_iterator
           b (i.FeaturePair ().begin ()), n (i.FeaturePair ().end ());
           b != n; ++b)
      {
        const ArrayPairReferenceFullType::FeaturePair_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeaturePair",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ListUnsignedByteType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ListUnsignedByteType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ListUnsignedByteType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, wchar_t >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QPIdType& i)
    {
      e << static_cast< const ::xml_schema::token& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QPIdType& i)
    {
      a << static_cast< const ::xml_schema::token& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const QPIdType& i)
    {
      l << static_cast< const ::xml_schema::token& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QPIdReferenceType& i)
    {
      e << static_cast< const ::xml_schema::token& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const QPIdReferenceType& i)
    {
      a << static_cast< const ::xml_schema::token& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const QPIdReferenceType& i)
    {
      l << static_cast< const ::xml_schema::token& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const QPIdFullReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ItemQPId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ItemQPId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ItemQPId ();
      }

      // DocumentQPId
      //
      for (QPIdFullReferenceType::DocumentQPId_const_iterator
           b (i.DocumentQPId ().begin ()), n (i.DocumentQPId ().end ());
           b != n; ++b)
      {
        const QPIdFullReferenceType::DocumentQPId_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DocumentQPId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayQPIdFullReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // QPId
      //
      for (ArrayQPIdFullReferenceType::QPId_const_iterator
           b (i.QPId ().begin ()), n (i.QPId ().end ());
           b != n; ++b)
      {
        const ArrayQPIdFullReferenceType::QPId_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"QPId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayUnsignedByteType& i)
    {
      e << static_cast< const ::xsd::qif30::ListUnsignedByteType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayIntType& i)
    {
      e << static_cast< const ::xsd::qif30::ListIntType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayI2Type& i)
    {
      e << static_cast< const ::xsd::qif30::ListIntType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayI3Type& i)
    {
      e << static_cast< const ::xsd::qif30::ListIntType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayDoubleType& i)
    {
      e << static_cast< const ::xsd::qif30::ListDoubleType& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ArrayBinaryType& i)
    {
      e << static_cast< const ::xml_schema::base64_binary& > (i);

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }

      // sizeElement
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"sizeElement",
            e));

        a << i.sizeElement ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AttributesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attribute
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributesType::Attribute_const_iterator
             b (i.Attribute ().begin ()), n (i.Attribute ().end ());
             b != n; ++b)
        {
          const AttributesType::Attribute_type& x (*b);

          if (typeid (AttributesType::Attribute_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Attribute",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Attribute",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AttributeBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // name
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"name",
            e));

        a << i.name ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AttributeBoolType& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << i.value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeBoolType >
    _xsd_AttributeBoolType_type_serializer_init (
      L"AttributeBoolType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeStrType& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << i.value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeStrType >
    _xsd_AttributeStrType_type_serializer_init (
      L"AttributeStrType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeTimeType& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << i.value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeTimeType >
    _xsd_AttributeTimeType_type_serializer_init (
      L"AttributeTimeType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeQPIdType& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // Value
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Value",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeQPIdType >
    _xsd_AttributeQPIdType_type_serializer_init (
      L"AttributeQPIdType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeI1Type& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << i.value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeI1Type >
    _xsd_AttributeI1Type_type_serializer_init (
      L"AttributeI1Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeI2Type& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << i.value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeI2Type >
    _xsd_AttributeI2Type_type_serializer_init (
      L"AttributeI2Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeI3Type& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << i.value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeI3Type >
    _xsd_AttributeI3Type_type_serializer_init (
      L"AttributeI3Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeD1Type& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << ::xml_schema::as_double(i.value ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeD1Type >
    _xsd_AttributeD1Type_type_serializer_init (
      L"AttributeD1Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeD2Type& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << i.value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeD2Type >
    _xsd_AttributeD2Type_type_serializer_init (
      L"AttributeD2Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeD3Type& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // value
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"value",
            e));

        a << i.value ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeD3Type >
    _xsd_AttributeD3Type_type_serializer_init (
      L"AttributeD3Type",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const AttributeUserType& i)
    {
      e << static_cast< const ::xsd::qif30::AttributeBaseType& > (i);

      // UserDataXML
      //
      if (i.UserDataXML ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDataXML",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDataXML ();
      }

      // UserDataBinary
      //
      if (i.UserDataBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDataBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDataBinary ();
      }

      // nameUserAttribute
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"nameUserAttribute",
            e));

        a << i.nameUserAttribute ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeUserType >
    _xsd_AttributeUserType_type_serializer_init (
      L"AttributeUserType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const UserDataXMLType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeBoolType >
    _xsd_AttributeBool_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeBool",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeBoolType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeStrType >
    _xsd_AttributeStr_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeStr",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeStrType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeTimeType >
    _xsd_AttributeTime_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeTime",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeTimeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeQPIdType >
    _xsd_AttributeQPId_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeQPId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeQPIdType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeI1Type >
    _xsd_AttributeI1_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeI1",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeI1Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeI2Type >
    _xsd_AttributeI2_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeI2",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeI2Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeI3Type >
    _xsd_AttributeI3_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeI3",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeI3Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeD1Type >
    _xsd_AttributeD1_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeD1",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeD1Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeD2Type >
    _xsd_AttributeD2_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeD2",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeD2Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeD3Type >
    _xsd_AttributeD3_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeD3",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeD3Type >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::AttributeUserType >
    _xsd_AttributeUser_element_serializer_init (
      L"Attribute",
      L"http://qifstandards.org/xsd/qif3",
      L"AttributeUser",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::AttributeUserType >);


    void
    operator<< (xercesc::DOMElement& e, const ValidationPointsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Points
      //
      if (i.Points ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Points ();
      }

      // PointsBinary
      //
      if (i.PointsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsBinary ();
      }

      // Directions
      //
      if (i.Directions ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Directions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Directions ();
      }

      // DirectionsBinary
      //
      if (i.DirectionsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirectionsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DirectionsBinary ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BoundingBoxAxisAlignedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointMin
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointMin ();
      }

      // PointMax
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointMax ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

