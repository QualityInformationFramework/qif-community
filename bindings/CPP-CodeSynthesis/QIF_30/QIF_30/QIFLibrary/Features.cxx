// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Features.hxx"

namespace xsd
{
  namespace qif30
  {
    // FeatureBaseType
    //

    const FeatureBaseType::Attributes_optional& FeatureBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    FeatureBaseType::Attributes_optional& FeatureBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void FeatureBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void FeatureBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void FeatureBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const FeatureBaseType::id_type& FeatureBaseType::
    id () const
    {
      return this->id_.get ();
    }

    FeatureBaseType::id_type& FeatureBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void FeatureBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // FeatureItemBaseType
    //

    const FeatureItemBaseType::FeatureNominalId_type& FeatureItemBaseType::
    FeatureNominalId () const
    {
      return this->FeatureNominalId_.get ();
    }

    FeatureItemBaseType::FeatureNominalId_type& FeatureItemBaseType::
    FeatureNominalId ()
    {
      return this->FeatureNominalId_.get ();
    }

    void FeatureItemBaseType::
    FeatureNominalId (const FeatureNominalId_type& x)
    {
      this->FeatureNominalId_.set (x);
    }

    void FeatureItemBaseType::
    FeatureNominalId (::std::unique_ptr< FeatureNominalId_type > x)
    {
      this->FeatureNominalId_.set (std::move (x));
    }

    const FeatureItemBaseType::ParentFeatureItemId_optional& FeatureItemBaseType::
    ParentFeatureItemId () const
    {
      return this->ParentFeatureItemId_;
    }

    FeatureItemBaseType::ParentFeatureItemId_optional& FeatureItemBaseType::
    ParentFeatureItemId ()
    {
      return this->ParentFeatureItemId_;
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (const ParentFeatureItemId_type& x)
    {
      this->ParentFeatureItemId_.set (x);
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (const ParentFeatureItemId_optional& x)
    {
      this->ParentFeatureItemId_ = x;
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (::std::unique_ptr< ParentFeatureItemId_type > x)
    {
      this->ParentFeatureItemId_.set (std::move (x));
    }

    const FeatureItemBaseType::FeatureName_type& FeatureItemBaseType::
    FeatureName () const
    {
      return this->FeatureName_.get ();
    }

    FeatureItemBaseType::FeatureName_type& FeatureItemBaseType::
    FeatureName ()
    {
      return this->FeatureName_.get ();
    }

    void FeatureItemBaseType::
    FeatureName (const FeatureName_type& x)
    {
      this->FeatureName_.set (x);
    }

    void FeatureItemBaseType::
    FeatureName (::std::unique_ptr< FeatureName_type > x)
    {
      this->FeatureName_.set (std::move (x));
    }

    const FeatureItemBaseType::UUID_optional& FeatureItemBaseType::
    UUID () const
    {
      return this->UUID_;
    }

    FeatureItemBaseType::UUID_optional& FeatureItemBaseType::
    UUID ()
    {
      return this->UUID_;
    }

    void FeatureItemBaseType::
    UUID (const UUID_type& x)
    {
      this->UUID_.set (x);
    }

    void FeatureItemBaseType::
    UUID (const UUID_optional& x)
    {
      this->UUID_ = x;
    }

    void FeatureItemBaseType::
    UUID (::std::unique_ptr< UUID_type > x)
    {
      this->UUID_.set (std::move (x));
    }

    const FeatureItemBaseType::NotableEventIds_optional& FeatureItemBaseType::
    NotableEventIds () const
    {
      return this->NotableEventIds_;
    }

    FeatureItemBaseType::NotableEventIds_optional& FeatureItemBaseType::
    NotableEventIds ()
    {
      return this->NotableEventIds_;
    }

    void FeatureItemBaseType::
    NotableEventIds (const NotableEventIds_type& x)
    {
      this->NotableEventIds_.set (x);
    }

    void FeatureItemBaseType::
    NotableEventIds (const NotableEventIds_optional& x)
    {
      this->NotableEventIds_ = x;
    }

    void FeatureItemBaseType::
    NotableEventIds (::std::unique_ptr< NotableEventIds_type > x)
    {
      this->NotableEventIds_.set (std::move (x));
    }

    const FeatureItemBaseType::CoordinateSystemId_optional& FeatureItemBaseType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_;
    }

    FeatureItemBaseType::CoordinateSystemId_optional& FeatureItemBaseType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_;
    }

    void FeatureItemBaseType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void FeatureItemBaseType::
    CoordinateSystemId (const CoordinateSystemId_optional& x)
    {
      this->CoordinateSystemId_ = x;
    }

    void FeatureItemBaseType::
    CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (std::move (x));
    }


    // ShapeFeatureItemBaseType
    //

    const ShapeFeatureItemBaseType::PointList_optional& ShapeFeatureItemBaseType::
    PointList () const
    {
      return this->PointList_;
    }

    ShapeFeatureItemBaseType::PointList_optional& ShapeFeatureItemBaseType::
    PointList ()
    {
      return this->PointList_;
    }

    void ShapeFeatureItemBaseType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void ShapeFeatureItemBaseType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void ShapeFeatureItemBaseType::
    PointList (::std::unique_ptr< PointList_type > x)
    {
      this->PointList_.set (std::move (x));
    }

    const ShapeFeatureItemBaseType::SubstituteFeatureAlgorithm_optional& ShapeFeatureItemBaseType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ShapeFeatureItemBaseType::SubstituteFeatureAlgorithm_optional& ShapeFeatureItemBaseType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ShapeFeatureItemBaseType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ShapeFeatureItemBaseType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ShapeFeatureItemBaseType::
    SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (std::move (x));
    }

    const ShapeFeatureItemBaseType::VirtualMeasurement_optional& ShapeFeatureItemBaseType::
    VirtualMeasurement () const
    {
      return this->VirtualMeasurement_;
    }

    ShapeFeatureItemBaseType::VirtualMeasurement_optional& ShapeFeatureItemBaseType::
    VirtualMeasurement ()
    {
      return this->VirtualMeasurement_;
    }

    void ShapeFeatureItemBaseType::
    VirtualMeasurement (const VirtualMeasurement_type& x)
    {
      this->VirtualMeasurement_.set (x);
    }

    void ShapeFeatureItemBaseType::
    VirtualMeasurement (const VirtualMeasurement_optional& x)
    {
      this->VirtualMeasurement_ = x;
    }

    void ShapeFeatureItemBaseType::
    VirtualMeasurement (::std::unique_ptr< VirtualMeasurement_type > x)
    {
      this->VirtualMeasurement_.set (std::move (x));
    }


    // NonShapeFeatureItemBaseType
    //


    // FeatureDefinitionBaseType
    //


    // ShapeFeatureDefinitionBaseType
    //


    // NonShapeFeatureDefinitionBaseType
    //


    // PointSetNominalType
    //

    const PointSetNominalType::MeasurePoint_sequence& PointSetNominalType::
    MeasurePoint () const
    {
      return this->MeasurePoint_;
    }

    PointSetNominalType::MeasurePoint_sequence& PointSetNominalType::
    MeasurePoint ()
    {
      return this->MeasurePoint_;
    }

    void PointSetNominalType::
    MeasurePoint (const MeasurePoint_sequence& s)
    {
      this->MeasurePoint_ = s;
    }

    const PointSetNominalType::linearUnit_optional& PointSetNominalType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    PointSetNominalType::linearUnit_optional& PointSetNominalType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void PointSetNominalType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void PointSetNominalType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void PointSetNominalType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const PointSetNominalType::decimalPlaces_optional& PointSetNominalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    PointSetNominalType::decimalPlaces_optional& PointSetNominalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void PointSetNominalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void PointSetNominalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const PointSetNominalType::significantFigures_optional& PointSetNominalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    PointSetNominalType::significantFigures_optional& PointSetNominalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void PointSetNominalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void PointSetNominalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const PointSetNominalType::validity_optional& PointSetNominalType::
    validity () const
    {
      return this->validity_;
    }

    PointSetNominalType::validity_optional& PointSetNominalType::
    validity ()
    {
      return this->validity_;
    }

    void PointSetNominalType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void PointSetNominalType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void PointSetNominalType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const PointSetNominalType::xDecimalPlaces_optional& PointSetNominalType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    PointSetNominalType::xDecimalPlaces_optional& PointSetNominalType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void PointSetNominalType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void PointSetNominalType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const PointSetNominalType::xSignificantFigures_optional& PointSetNominalType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    PointSetNominalType::xSignificantFigures_optional& PointSetNominalType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void PointSetNominalType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void PointSetNominalType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const PointSetNominalType::xValidity_optional& PointSetNominalType::
    xValidity () const
    {
      return this->xValidity_;
    }

    PointSetNominalType::xValidity_optional& PointSetNominalType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void PointSetNominalType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void PointSetNominalType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void PointSetNominalType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const PointSetNominalType::yDecimalPlaces_optional& PointSetNominalType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    PointSetNominalType::yDecimalPlaces_optional& PointSetNominalType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void PointSetNominalType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void PointSetNominalType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const PointSetNominalType::ySignificantFigures_optional& PointSetNominalType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    PointSetNominalType::ySignificantFigures_optional& PointSetNominalType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void PointSetNominalType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void PointSetNominalType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const PointSetNominalType::yValidity_optional& PointSetNominalType::
    yValidity () const
    {
      return this->yValidity_;
    }

    PointSetNominalType::yValidity_optional& PointSetNominalType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void PointSetNominalType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void PointSetNominalType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void PointSetNominalType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const PointSetNominalType::zDecimalPlaces_optional& PointSetNominalType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    PointSetNominalType::zDecimalPlaces_optional& PointSetNominalType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void PointSetNominalType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void PointSetNominalType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const PointSetNominalType::zSignificantFigures_optional& PointSetNominalType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    PointSetNominalType::zSignificantFigures_optional& PointSetNominalType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void PointSetNominalType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void PointSetNominalType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const PointSetNominalType::zValidity_optional& PointSetNominalType::
    zValidity () const
    {
      return this->zValidity_;
    }

    PointSetNominalType::zValidity_optional& PointSetNominalType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void PointSetNominalType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void PointSetNominalType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void PointSetNominalType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }

    const PointSetNominalType::n_type& PointSetNominalType::
    n () const
    {
      return this->n_.get ();
    }

    PointSetNominalType::n_type& PointSetNominalType::
    n ()
    {
      return this->n_.get ();
    }

    void PointSetNominalType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PointSetNominalType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }

    const PointSetNominalType::id_type& PointSetNominalType::
    id () const
    {
      return this->id_.get ();
    }

    PointSetNominalType::id_type& PointSetNominalType::
    id ()
    {
      return this->id_.get ();
    }

    void PointSetNominalType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void PointSetNominalType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // NominalPointSetListType
    //

    const NominalPointSetListType::NominalPointSet_sequence& NominalPointSetListType::
    NominalPointSet () const
    {
      return this->NominalPointSet_;
    }

    NominalPointSetListType::NominalPointSet_sequence& NominalPointSetListType::
    NominalPointSet ()
    {
      return this->NominalPointSet_;
    }

    void NominalPointSetListType::
    NominalPointSet (const NominalPointSet_sequence& s)
    {
      this->NominalPointSet_ = s;
    }

    const NominalPointSetListType::n_type& NominalPointSetListType::
    n () const
    {
      return this->n_.get ();
    }

    NominalPointSetListType::n_type& NominalPointSetListType::
    n ()
    {
      return this->n_.get ();
    }

    void NominalPointSetListType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void NominalPointSetListType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FeatureNominalBaseType
    //

    const FeatureNominalBaseType::Name_optional& FeatureNominalBaseType::
    Name () const
    {
      return this->Name_;
    }

    FeatureNominalBaseType::Name_optional& FeatureNominalBaseType::
    Name ()
    {
      return this->Name_;
    }

    void FeatureNominalBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void FeatureNominalBaseType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void FeatureNominalBaseType::
    Name (::std::unique_ptr< Name_type > x)
    {
      this->Name_.set (std::move (x));
    }

    const FeatureNominalBaseType::UUID_optional& FeatureNominalBaseType::
    UUID () const
    {
      return this->UUID_;
    }

    FeatureNominalBaseType::UUID_optional& FeatureNominalBaseType::
    UUID ()
    {
      return this->UUID_;
    }

    void FeatureNominalBaseType::
    UUID (const UUID_type& x)
    {
      this->UUID_.set (x);
    }

    void FeatureNominalBaseType::
    UUID (const UUID_optional& x)
    {
      this->UUID_ = x;
    }

    void FeatureNominalBaseType::
    UUID (::std::unique_ptr< UUID_type > x)
    {
      this->UUID_.set (std::move (x));
    }

    const FeatureNominalBaseType::FeatureDefinitionId_type& FeatureNominalBaseType::
    FeatureDefinitionId () const
    {
      return this->FeatureDefinitionId_.get ();
    }

    FeatureNominalBaseType::FeatureDefinitionId_type& FeatureNominalBaseType::
    FeatureDefinitionId ()
    {
      return this->FeatureDefinitionId_.get ();
    }

    void FeatureNominalBaseType::
    FeatureDefinitionId (const FeatureDefinitionId_type& x)
    {
      this->FeatureDefinitionId_.set (x);
    }

    void FeatureNominalBaseType::
    FeatureDefinitionId (::std::unique_ptr< FeatureDefinitionId_type > x)
    {
      this->FeatureDefinitionId_.set (std::move (x));
    }

    const FeatureNominalBaseType::ParentFeatureNominalId_optional& FeatureNominalBaseType::
    ParentFeatureNominalId () const
    {
      return this->ParentFeatureNominalId_;
    }

    FeatureNominalBaseType::ParentFeatureNominalId_optional& FeatureNominalBaseType::
    ParentFeatureNominalId ()
    {
      return this->ParentFeatureNominalId_;
    }

    void FeatureNominalBaseType::
    ParentFeatureNominalId (const ParentFeatureNominalId_type& x)
    {
      this->ParentFeatureNominalId_.set (x);
    }

    void FeatureNominalBaseType::
    ParentFeatureNominalId (const ParentFeatureNominalId_optional& x)
    {
      this->ParentFeatureNominalId_ = x;
    }

    void FeatureNominalBaseType::
    ParentFeatureNominalId (::std::unique_ptr< ParentFeatureNominalId_type > x)
    {
      this->ParentFeatureNominalId_.set (std::move (x));
    }

    const FeatureNominalBaseType::EntityInternalIds_optional& FeatureNominalBaseType::
    EntityInternalIds () const
    {
      return this->EntityInternalIds_;
    }

    FeatureNominalBaseType::EntityInternalIds_optional& FeatureNominalBaseType::
    EntityInternalIds ()
    {
      return this->EntityInternalIds_;
    }

    void FeatureNominalBaseType::
    EntityInternalIds (const EntityInternalIds_type& x)
    {
      this->EntityInternalIds_.set (x);
    }

    void FeatureNominalBaseType::
    EntityInternalIds (const EntityInternalIds_optional& x)
    {
      this->EntityInternalIds_ = x;
    }

    void FeatureNominalBaseType::
    EntityInternalIds (::std::unique_ptr< EntityInternalIds_type > x)
    {
      this->EntityInternalIds_.set (std::move (x));
    }

    const FeatureNominalBaseType::EntityExternalIds_optional& FeatureNominalBaseType::
    EntityExternalIds () const
    {
      return this->EntityExternalIds_;
    }

    FeatureNominalBaseType::EntityExternalIds_optional& FeatureNominalBaseType::
    EntityExternalIds ()
    {
      return this->EntityExternalIds_;
    }

    void FeatureNominalBaseType::
    EntityExternalIds (const EntityExternalIds_type& x)
    {
      this->EntityExternalIds_.set (x);
    }

    void FeatureNominalBaseType::
    EntityExternalIds (const EntityExternalIds_optional& x)
    {
      this->EntityExternalIds_ = x;
    }

    void FeatureNominalBaseType::
    EntityExternalIds (::std::unique_ptr< EntityExternalIds_type > x)
    {
      this->EntityExternalIds_.set (std::move (x));
    }


    // ShapeFeatureNominalBaseType
    //

    const ShapeFeatureNominalBaseType::PointList_optional& ShapeFeatureNominalBaseType::
    PointList () const
    {
      return this->PointList_;
    }

    ShapeFeatureNominalBaseType::PointList_optional& ShapeFeatureNominalBaseType::
    PointList ()
    {
      return this->PointList_;
    }

    void ShapeFeatureNominalBaseType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void ShapeFeatureNominalBaseType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void ShapeFeatureNominalBaseType::
    PointList (::std::unique_ptr< PointList_type > x)
    {
      this->PointList_.set (std::move (x));
    }

    const ShapeFeatureNominalBaseType::SubstituteFeatureAlgorithm_optional& ShapeFeatureNominalBaseType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ShapeFeatureNominalBaseType::SubstituteFeatureAlgorithm_optional& ShapeFeatureNominalBaseType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ShapeFeatureNominalBaseType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ShapeFeatureNominalBaseType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ShapeFeatureNominalBaseType::
    SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (std::move (x));
    }


    // NonShapeFeatureNominalBaseType
    //


    // MeasuredPointSetsType
    //

    const MeasuredPointSetsType::MeasuredPointSet_sequence& MeasuredPointSetsType::
    MeasuredPointSet () const
    {
      return this->MeasuredPointSet_;
    }

    MeasuredPointSetsType::MeasuredPointSet_sequence& MeasuredPointSetsType::
    MeasuredPointSet ()
    {
      return this->MeasuredPointSet_;
    }

    void MeasuredPointSetsType::
    MeasuredPointSet (const MeasuredPointSet_sequence& s)
    {
      this->MeasuredPointSet_ = s;
    }

    const MeasuredPointSetsType::n_type& MeasuredPointSetsType::
    n () const
    {
      return this->n_.get ();
    }

    MeasuredPointSetsType::n_type& MeasuredPointSetsType::
    n ()
    {
      return this->n_.get ();
    }

    void MeasuredPointSetsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void MeasuredPointSetsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointListType
    //

    const PointListType::PointSetId_sequence& PointListType::
    PointSetId () const
    {
      return this->PointSetId_;
    }

    PointListType::PointSetId_sequence& PointListType::
    PointSetId ()
    {
      return this->PointSetId_;
    }

    void PointListType::
    PointSetId (const PointSetId_sequence& s)
    {
      this->PointSetId_ = s;
    }

    const PointListType::n_type& PointListType::
    n () const
    {
      return this->n_.get ();
    }

    PointListType::n_type& PointListType::
    n ()
    {
      return this->n_.get ();
    }

    void PointListType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PointListType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // MeasuredPointSetType
    //

    const MeasuredPointSetType::Attributes_optional& MeasuredPointSetType::
    Attributes () const
    {
      return this->Attributes_;
    }

    MeasuredPointSetType::Attributes_optional& MeasuredPointSetType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void MeasuredPointSetType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void MeasuredPointSetType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void MeasuredPointSetType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const MeasuredPointSetType::Units_optional& MeasuredPointSetType::
    Units () const
    {
      return this->Units_;
    }

    MeasuredPointSetType::Units_optional& MeasuredPointSetType::
    Units ()
    {
      return this->Units_;
    }

    void MeasuredPointSetType::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void MeasuredPointSetType::
    Units (const Units_optional& x)
    {
      this->Units_ = x;
    }

    void MeasuredPointSetType::
    Units (::std::unique_ptr< Units_type > x)
    {
      this->Units_.set (std::move (x));
    }

    const MeasuredPointSetType::CoordinateSystemId_optional& MeasuredPointSetType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_;
    }

    MeasuredPointSetType::CoordinateSystemId_optional& MeasuredPointSetType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_;
    }

    void MeasuredPointSetType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void MeasuredPointSetType::
    CoordinateSystemId (const CoordinateSystemId_optional& x)
    {
      this->CoordinateSystemId_ = x;
    }

    void MeasuredPointSetType::
    CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (std::move (x));
    }

    const MeasuredPointSetType::TranformId_optional& MeasuredPointSetType::
    TranformId () const
    {
      return this->TranformId_;
    }

    MeasuredPointSetType::TranformId_optional& MeasuredPointSetType::
    TranformId ()
    {
      return this->TranformId_;
    }

    void MeasuredPointSetType::
    TranformId (const TranformId_type& x)
    {
      this->TranformId_.set (x);
    }

    void MeasuredPointSetType::
    TranformId (const TranformId_optional& x)
    {
      this->TranformId_ = x;
    }

    void MeasuredPointSetType::
    TranformId (::std::unique_ptr< TranformId_type > x)
    {
      this->TranformId_.set (std::move (x));
    }

    const MeasuredPointSetType::Points_optional& MeasuredPointSetType::
    Points () const
    {
      return this->Points_;
    }

    MeasuredPointSetType::Points_optional& MeasuredPointSetType::
    Points ()
    {
      return this->Points_;
    }

    void MeasuredPointSetType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void MeasuredPointSetType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void MeasuredPointSetType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryPoints_optional& MeasuredPointSetType::
    BinaryPoints () const
    {
      return this->BinaryPoints_;
    }

    MeasuredPointSetType::BinaryPoints_optional& MeasuredPointSetType::
    BinaryPoints ()
    {
      return this->BinaryPoints_;
    }

    void MeasuredPointSetType::
    BinaryPoints (const BinaryPoints_type& x)
    {
      this->BinaryPoints_.set (x);
    }

    void MeasuredPointSetType::
    BinaryPoints (const BinaryPoints_optional& x)
    {
      this->BinaryPoints_ = x;
    }

    void MeasuredPointSetType::
    BinaryPoints (::std::unique_ptr< BinaryPoints_type > x)
    {
      this->BinaryPoints_.set (std::move (x));
    }

    const MeasuredPointSetType::Normals_optional& MeasuredPointSetType::
    Normals () const
    {
      return this->Normals_;
    }

    MeasuredPointSetType::Normals_optional& MeasuredPointSetType::
    Normals ()
    {
      return this->Normals_;
    }

    void MeasuredPointSetType::
    Normals (const Normals_type& x)
    {
      this->Normals_.set (x);
    }

    void MeasuredPointSetType::
    Normals (const Normals_optional& x)
    {
      this->Normals_ = x;
    }

    void MeasuredPointSetType::
    Normals (::std::unique_ptr< Normals_type > x)
    {
      this->Normals_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryNormals_optional& MeasuredPointSetType::
    BinaryNormals () const
    {
      return this->BinaryNormals_;
    }

    MeasuredPointSetType::BinaryNormals_optional& MeasuredPointSetType::
    BinaryNormals ()
    {
      return this->BinaryNormals_;
    }

    void MeasuredPointSetType::
    BinaryNormals (const BinaryNormals_type& x)
    {
      this->BinaryNormals_.set (x);
    }

    void MeasuredPointSetType::
    BinaryNormals (const BinaryNormals_optional& x)
    {
      this->BinaryNormals_ = x;
    }

    void MeasuredPointSetType::
    BinaryNormals (::std::unique_ptr< BinaryNormals_type > x)
    {
      this->BinaryNormals_.set (std::move (x));
    }

    const MeasuredPointSetType::Compensated_optional& MeasuredPointSetType::
    Compensated () const
    {
      return this->Compensated_;
    }

    MeasuredPointSetType::Compensated_optional& MeasuredPointSetType::
    Compensated ()
    {
      return this->Compensated_;
    }

    void MeasuredPointSetType::
    Compensated (const Compensated_type& x)
    {
      this->Compensated_.set (x);
    }

    void MeasuredPointSetType::
    Compensated (const Compensated_optional& x)
    {
      this->Compensated_ = x;
    }

    const MeasuredPointSetType::Compensations_optional& MeasuredPointSetType::
    Compensations () const
    {
      return this->Compensations_;
    }

    MeasuredPointSetType::Compensations_optional& MeasuredPointSetType::
    Compensations ()
    {
      return this->Compensations_;
    }

    void MeasuredPointSetType::
    Compensations (const Compensations_type& x)
    {
      this->Compensations_.set (x);
    }

    void MeasuredPointSetType::
    Compensations (const Compensations_optional& x)
    {
      this->Compensations_ = x;
    }

    void MeasuredPointSetType::
    Compensations (::std::unique_ptr< Compensations_type > x)
    {
      this->Compensations_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryCompensated_optional& MeasuredPointSetType::
    BinaryCompensated () const
    {
      return this->BinaryCompensated_;
    }

    MeasuredPointSetType::BinaryCompensated_optional& MeasuredPointSetType::
    BinaryCompensated ()
    {
      return this->BinaryCompensated_;
    }

    void MeasuredPointSetType::
    BinaryCompensated (const BinaryCompensated_type& x)
    {
      this->BinaryCompensated_.set (x);
    }

    void MeasuredPointSetType::
    BinaryCompensated (const BinaryCompensated_optional& x)
    {
      this->BinaryCompensated_ = x;
    }

    void MeasuredPointSetType::
    BinaryCompensated (::std::unique_ptr< BinaryCompensated_type > x)
    {
      this->BinaryCompensated_.set (std::move (x));
    }

    const MeasuredPointSetType::ProbeRadius_optional& MeasuredPointSetType::
    ProbeRadius () const
    {
      return this->ProbeRadius_;
    }

    MeasuredPointSetType::ProbeRadius_optional& MeasuredPointSetType::
    ProbeRadius ()
    {
      return this->ProbeRadius_;
    }

    void MeasuredPointSetType::
    ProbeRadius (const ProbeRadius_type& x)
    {
      this->ProbeRadius_.set (x);
    }

    void MeasuredPointSetType::
    ProbeRadius (const ProbeRadius_optional& x)
    {
      this->ProbeRadius_ = x;
    }

    const MeasuredPointSetType::ProbeRadii_optional& MeasuredPointSetType::
    ProbeRadii () const
    {
      return this->ProbeRadii_;
    }

    MeasuredPointSetType::ProbeRadii_optional& MeasuredPointSetType::
    ProbeRadii ()
    {
      return this->ProbeRadii_;
    }

    void MeasuredPointSetType::
    ProbeRadii (const ProbeRadii_type& x)
    {
      this->ProbeRadii_.set (x);
    }

    void MeasuredPointSetType::
    ProbeRadii (const ProbeRadii_optional& x)
    {
      this->ProbeRadii_ = x;
    }

    void MeasuredPointSetType::
    ProbeRadii (::std::unique_ptr< ProbeRadii_type > x)
    {
      this->ProbeRadii_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryProbeRadii_optional& MeasuredPointSetType::
    BinaryProbeRadii () const
    {
      return this->BinaryProbeRadii_;
    }

    MeasuredPointSetType::BinaryProbeRadii_optional& MeasuredPointSetType::
    BinaryProbeRadii ()
    {
      return this->BinaryProbeRadii_;
    }

    void MeasuredPointSetType::
    BinaryProbeRadii (const BinaryProbeRadii_type& x)
    {
      this->BinaryProbeRadii_.set (x);
    }

    void MeasuredPointSetType::
    BinaryProbeRadii (const BinaryProbeRadii_optional& x)
    {
      this->BinaryProbeRadii_ = x;
    }

    void MeasuredPointSetType::
    BinaryProbeRadii (::std::unique_ptr< BinaryProbeRadii_type > x)
    {
      this->BinaryProbeRadii_.set (std::move (x));
    }

    const MeasuredPointSetType::MeasurementDeviceId_optional& MeasuredPointSetType::
    MeasurementDeviceId () const
    {
      return this->MeasurementDeviceId_;
    }

    MeasuredPointSetType::MeasurementDeviceId_optional& MeasuredPointSetType::
    MeasurementDeviceId ()
    {
      return this->MeasurementDeviceId_;
    }

    void MeasuredPointSetType::
    MeasurementDeviceId (const MeasurementDeviceId_type& x)
    {
      this->MeasurementDeviceId_.set (x);
    }

    void MeasuredPointSetType::
    MeasurementDeviceId (const MeasurementDeviceId_optional& x)
    {
      this->MeasurementDeviceId_ = x;
    }

    void MeasuredPointSetType::
    MeasurementDeviceId (::std::unique_ptr< MeasurementDeviceId_type > x)
    {
      this->MeasurementDeviceId_.set (std::move (x));
    }

    const MeasuredPointSetType::SensorId_optional& MeasuredPointSetType::
    SensorId () const
    {
      return this->SensorId_;
    }

    MeasuredPointSetType::SensorId_optional& MeasuredPointSetType::
    SensorId ()
    {
      return this->SensorId_;
    }

    void MeasuredPointSetType::
    SensorId (const SensorId_type& x)
    {
      this->SensorId_.set (x);
    }

    void MeasuredPointSetType::
    SensorId (const SensorId_optional& x)
    {
      this->SensorId_ = x;
    }

    void MeasuredPointSetType::
    SensorId (::std::unique_ptr< SensorId_type > x)
    {
      this->SensorId_.set (std::move (x));
    }

    const MeasuredPointSetType::SensorIds_optional& MeasuredPointSetType::
    SensorIds () const
    {
      return this->SensorIds_;
    }

    MeasuredPointSetType::SensorIds_optional& MeasuredPointSetType::
    SensorIds ()
    {
      return this->SensorIds_;
    }

    void MeasuredPointSetType::
    SensorIds (const SensorIds_type& x)
    {
      this->SensorIds_.set (x);
    }

    void MeasuredPointSetType::
    SensorIds (const SensorIds_optional& x)
    {
      this->SensorIds_ = x;
    }

    void MeasuredPointSetType::
    SensorIds (::std::unique_ptr< SensorIds_type > x)
    {
      this->SensorIds_.set (std::move (x));
    }

    const MeasuredPointSetType::BinarySensorIds_optional& MeasuredPointSetType::
    BinarySensorIds () const
    {
      return this->BinarySensorIds_;
    }

    MeasuredPointSetType::BinarySensorIds_optional& MeasuredPointSetType::
    BinarySensorIds ()
    {
      return this->BinarySensorIds_;
    }

    void MeasuredPointSetType::
    BinarySensorIds (const BinarySensorIds_type& x)
    {
      this->BinarySensorIds_.set (x);
    }

    void MeasuredPointSetType::
    BinarySensorIds (const BinarySensorIds_optional& x)
    {
      this->BinarySensorIds_ = x;
    }

    void MeasuredPointSetType::
    BinarySensorIds (::std::unique_ptr< BinarySensorIds_type > x)
    {
      this->BinarySensorIds_.set (std::move (x));
    }

    const MeasuredPointSetType::TipId_optional& MeasuredPointSetType::
    TipId () const
    {
      return this->TipId_;
    }

    MeasuredPointSetType::TipId_optional& MeasuredPointSetType::
    TipId ()
    {
      return this->TipId_;
    }

    void MeasuredPointSetType::
    TipId (const TipId_type& x)
    {
      this->TipId_.set (x);
    }

    void MeasuredPointSetType::
    TipId (const TipId_optional& x)
    {
      this->TipId_ = x;
    }

    void MeasuredPointSetType::
    TipId (::std::unique_ptr< TipId_type > x)
    {
      this->TipId_.set (std::move (x));
    }

    const MeasuredPointSetType::TipIds_optional& MeasuredPointSetType::
    TipIds () const
    {
      return this->TipIds_;
    }

    MeasuredPointSetType::TipIds_optional& MeasuredPointSetType::
    TipIds ()
    {
      return this->TipIds_;
    }

    void MeasuredPointSetType::
    TipIds (const TipIds_type& x)
    {
      this->TipIds_.set (x);
    }

    void MeasuredPointSetType::
    TipIds (const TipIds_optional& x)
    {
      this->TipIds_ = x;
    }

    void MeasuredPointSetType::
    TipIds (::std::unique_ptr< TipIds_type > x)
    {
      this->TipIds_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryTipIds_optional& MeasuredPointSetType::
    BinaryTipIds () const
    {
      return this->BinaryTipIds_;
    }

    MeasuredPointSetType::BinaryTipIds_optional& MeasuredPointSetType::
    BinaryTipIds ()
    {
      return this->BinaryTipIds_;
    }

    void MeasuredPointSetType::
    BinaryTipIds (const BinaryTipIds_type& x)
    {
      this->BinaryTipIds_.set (x);
    }

    void MeasuredPointSetType::
    BinaryTipIds (const BinaryTipIds_optional& x)
    {
      this->BinaryTipIds_ = x;
    }

    void MeasuredPointSetType::
    BinaryTipIds (::std::unique_ptr< BinaryTipIds_type > x)
    {
      this->BinaryTipIds_.set (std::move (x));
    }

    const MeasuredPointSetType::MeasurePointNominalIds_optional& MeasuredPointSetType::
    MeasurePointNominalIds () const
    {
      return this->MeasurePointNominalIds_;
    }

    MeasuredPointSetType::MeasurePointNominalIds_optional& MeasuredPointSetType::
    MeasurePointNominalIds ()
    {
      return this->MeasurePointNominalIds_;
    }

    void MeasuredPointSetType::
    MeasurePointNominalIds (const MeasurePointNominalIds_type& x)
    {
      this->MeasurePointNominalIds_.set (x);
    }

    void MeasuredPointSetType::
    MeasurePointNominalIds (const MeasurePointNominalIds_optional& x)
    {
      this->MeasurePointNominalIds_ = x;
    }

    void MeasuredPointSetType::
    MeasurePointNominalIds (::std::unique_ptr< MeasurePointNominalIds_type > x)
    {
      this->MeasurePointNominalIds_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryMeasurePointNominalIds_optional& MeasuredPointSetType::
    BinaryMeasurePointNominalIds () const
    {
      return this->BinaryMeasurePointNominalIds_;
    }

    MeasuredPointSetType::BinaryMeasurePointNominalIds_optional& MeasuredPointSetType::
    BinaryMeasurePointNominalIds ()
    {
      return this->BinaryMeasurePointNominalIds_;
    }

    void MeasuredPointSetType::
    BinaryMeasurePointNominalIds (const BinaryMeasurePointNominalIds_type& x)
    {
      this->BinaryMeasurePointNominalIds_.set (x);
    }

    void MeasuredPointSetType::
    BinaryMeasurePointNominalIds (const BinaryMeasurePointNominalIds_optional& x)
    {
      this->BinaryMeasurePointNominalIds_ = x;
    }

    void MeasuredPointSetType::
    BinaryMeasurePointNominalIds (::std::unique_ptr< BinaryMeasurePointNominalIds_type > x)
    {
      this->BinaryMeasurePointNominalIds_.set (std::move (x));
    }

    const MeasuredPointSetType::TimeStamp_optional& MeasuredPointSetType::
    TimeStamp () const
    {
      return this->TimeStamp_;
    }

    MeasuredPointSetType::TimeStamp_optional& MeasuredPointSetType::
    TimeStamp ()
    {
      return this->TimeStamp_;
    }

    void MeasuredPointSetType::
    TimeStamp (const TimeStamp_type& x)
    {
      this->TimeStamp_.set (x);
    }

    void MeasuredPointSetType::
    TimeStamp (const TimeStamp_optional& x)
    {
      this->TimeStamp_ = x;
    }

    void MeasuredPointSetType::
    TimeStamp (::std::unique_ptr< TimeStamp_type > x)
    {
      this->TimeStamp_.set (std::move (x));
    }

    const MeasuredPointSetType::TimeStamps_optional& MeasuredPointSetType::
    TimeStamps () const
    {
      return this->TimeStamps_;
    }

    MeasuredPointSetType::TimeStamps_optional& MeasuredPointSetType::
    TimeStamps ()
    {
      return this->TimeStamps_;
    }

    void MeasuredPointSetType::
    TimeStamps (const TimeStamps_type& x)
    {
      this->TimeStamps_.set (x);
    }

    void MeasuredPointSetType::
    TimeStamps (const TimeStamps_optional& x)
    {
      this->TimeStamps_ = x;
    }

    void MeasuredPointSetType::
    TimeStamps (::std::unique_ptr< TimeStamps_type > x)
    {
      this->TimeStamps_.set (std::move (x));
    }

    const MeasuredPointSetType::Quality_optional& MeasuredPointSetType::
    Quality () const
    {
      return this->Quality_;
    }

    MeasuredPointSetType::Quality_optional& MeasuredPointSetType::
    Quality ()
    {
      return this->Quality_;
    }

    void MeasuredPointSetType::
    Quality (const Quality_type& x)
    {
      this->Quality_.set (x);
    }

    void MeasuredPointSetType::
    Quality (const Quality_optional& x)
    {
      this->Quality_ = x;
    }

    void MeasuredPointSetType::
    Quality (::std::unique_ptr< Quality_type > x)
    {
      this->Quality_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryQuality_optional& MeasuredPointSetType::
    BinaryQuality () const
    {
      return this->BinaryQuality_;
    }

    MeasuredPointSetType::BinaryQuality_optional& MeasuredPointSetType::
    BinaryQuality ()
    {
      return this->BinaryQuality_;
    }

    void MeasuredPointSetType::
    BinaryQuality (const BinaryQuality_type& x)
    {
      this->BinaryQuality_.set (x);
    }

    void MeasuredPointSetType::
    BinaryQuality (const BinaryQuality_optional& x)
    {
      this->BinaryQuality_ = x;
    }

    void MeasuredPointSetType::
    BinaryQuality (::std::unique_ptr< BinaryQuality_type > x)
    {
      this->BinaryQuality_.set (std::move (x));
    }

    const MeasuredPointSetType::Deviations_optional& MeasuredPointSetType::
    Deviations () const
    {
      return this->Deviations_;
    }

    MeasuredPointSetType::Deviations_optional& MeasuredPointSetType::
    Deviations ()
    {
      return this->Deviations_;
    }

    void MeasuredPointSetType::
    Deviations (const Deviations_type& x)
    {
      this->Deviations_.set (x);
    }

    void MeasuredPointSetType::
    Deviations (const Deviations_optional& x)
    {
      this->Deviations_ = x;
    }

    void MeasuredPointSetType::
    Deviations (::std::unique_ptr< Deviations_type > x)
    {
      this->Deviations_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryDeviations_optional& MeasuredPointSetType::
    BinaryDeviations () const
    {
      return this->BinaryDeviations_;
    }

    MeasuredPointSetType::BinaryDeviations_optional& MeasuredPointSetType::
    BinaryDeviations ()
    {
      return this->BinaryDeviations_;
    }

    void MeasuredPointSetType::
    BinaryDeviations (const BinaryDeviations_type& x)
    {
      this->BinaryDeviations_.set (x);
    }

    void MeasuredPointSetType::
    BinaryDeviations (const BinaryDeviations_optional& x)
    {
      this->BinaryDeviations_ = x;
    }

    void MeasuredPointSetType::
    BinaryDeviations (::std::unique_ptr< BinaryDeviations_type > x)
    {
      this->BinaryDeviations_.set (std::move (x));
    }

    const MeasuredPointSetType::Colors_optional& MeasuredPointSetType::
    Colors () const
    {
      return this->Colors_;
    }

    MeasuredPointSetType::Colors_optional& MeasuredPointSetType::
    Colors ()
    {
      return this->Colors_;
    }

    void MeasuredPointSetType::
    Colors (const Colors_type& x)
    {
      this->Colors_.set (x);
    }

    void MeasuredPointSetType::
    Colors (const Colors_optional& x)
    {
      this->Colors_ = x;
    }

    void MeasuredPointSetType::
    Colors (::std::unique_ptr< Colors_type > x)
    {
      this->Colors_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryColors_optional& MeasuredPointSetType::
    BinaryColors () const
    {
      return this->BinaryColors_;
    }

    MeasuredPointSetType::BinaryColors_optional& MeasuredPointSetType::
    BinaryColors ()
    {
      return this->BinaryColors_;
    }

    void MeasuredPointSetType::
    BinaryColors (const BinaryColors_type& x)
    {
      this->BinaryColors_.set (x);
    }

    void MeasuredPointSetType::
    BinaryColors (const BinaryColors_optional& x)
    {
      this->BinaryColors_ = x;
    }

    void MeasuredPointSetType::
    BinaryColors (::std::unique_ptr< BinaryColors_type > x)
    {
      this->BinaryColors_.set (std::move (x));
    }

    const MeasuredPointSetType::NumberOfFacets_optional& MeasuredPointSetType::
    NumberOfFacets () const
    {
      return this->NumberOfFacets_;
    }

    MeasuredPointSetType::NumberOfFacets_optional& MeasuredPointSetType::
    NumberOfFacets ()
    {
      return this->NumberOfFacets_;
    }

    void MeasuredPointSetType::
    NumberOfFacets (const NumberOfFacets_type& x)
    {
      this->NumberOfFacets_.set (x);
    }

    void MeasuredPointSetType::
    NumberOfFacets (const NumberOfFacets_optional& x)
    {
      this->NumberOfFacets_ = x;
    }

    void MeasuredPointSetType::
    NumberOfFacets (::std::unique_ptr< NumberOfFacets_type > x)
    {
      this->NumberOfFacets_.set (std::move (x));
    }

    const MeasuredPointSetType::PointIndices_optional& MeasuredPointSetType::
    PointIndices () const
    {
      return this->PointIndices_;
    }

    MeasuredPointSetType::PointIndices_optional& MeasuredPointSetType::
    PointIndices ()
    {
      return this->PointIndices_;
    }

    void MeasuredPointSetType::
    PointIndices (const PointIndices_type& x)
    {
      this->PointIndices_.set (x);
    }

    void MeasuredPointSetType::
    PointIndices (const PointIndices_optional& x)
    {
      this->PointIndices_ = x;
    }

    void MeasuredPointSetType::
    PointIndices (::std::unique_ptr< PointIndices_type > x)
    {
      this->PointIndices_.set (std::move (x));
    }

    const MeasuredPointSetType::BinaryPointIndices_optional& MeasuredPointSetType::
    BinaryPointIndices () const
    {
      return this->BinaryPointIndices_;
    }

    MeasuredPointSetType::BinaryPointIndices_optional& MeasuredPointSetType::
    BinaryPointIndices ()
    {
      return this->BinaryPointIndices_;
    }

    void MeasuredPointSetType::
    BinaryPointIndices (const BinaryPointIndices_type& x)
    {
      this->BinaryPointIndices_.set (x);
    }

    void MeasuredPointSetType::
    BinaryPointIndices (const BinaryPointIndices_optional& x)
    {
      this->BinaryPointIndices_ = x;
    }

    void MeasuredPointSetType::
    BinaryPointIndices (::std::unique_ptr< BinaryPointIndices_type > x)
    {
      this->BinaryPointIndices_.set (std::move (x));
    }

    const MeasuredPointSetType::count_type& MeasuredPointSetType::
    count () const
    {
      return this->count_.get ();
    }

    MeasuredPointSetType::count_type& MeasuredPointSetType::
    count ()
    {
      return this->count_.get ();
    }

    void MeasuredPointSetType::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    void MeasuredPointSetType::
    count (::std::unique_ptr< count_type > x)
    {
      this->count_.set (std::move (x));
    }

    const MeasuredPointSetType::linearUnit_optional& MeasuredPointSetType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    MeasuredPointSetType::linearUnit_optional& MeasuredPointSetType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void MeasuredPointSetType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void MeasuredPointSetType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void MeasuredPointSetType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const MeasuredPointSetType::decimalPlaces_optional& MeasuredPointSetType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    MeasuredPointSetType::decimalPlaces_optional& MeasuredPointSetType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void MeasuredPointSetType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void MeasuredPointSetType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const MeasuredPointSetType::significantFigures_optional& MeasuredPointSetType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    MeasuredPointSetType::significantFigures_optional& MeasuredPointSetType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void MeasuredPointSetType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void MeasuredPointSetType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const MeasuredPointSetType::validity_optional& MeasuredPointSetType::
    validity () const
    {
      return this->validity_;
    }

    MeasuredPointSetType::validity_optional& MeasuredPointSetType::
    validity ()
    {
      return this->validity_;
    }

    void MeasuredPointSetType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void MeasuredPointSetType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void MeasuredPointSetType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const MeasuredPointSetType::xDecimalPlaces_optional& MeasuredPointSetType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    MeasuredPointSetType::xDecimalPlaces_optional& MeasuredPointSetType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void MeasuredPointSetType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void MeasuredPointSetType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const MeasuredPointSetType::xSignificantFigures_optional& MeasuredPointSetType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    MeasuredPointSetType::xSignificantFigures_optional& MeasuredPointSetType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void MeasuredPointSetType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void MeasuredPointSetType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const MeasuredPointSetType::xValidity_optional& MeasuredPointSetType::
    xValidity () const
    {
      return this->xValidity_;
    }

    MeasuredPointSetType::xValidity_optional& MeasuredPointSetType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void MeasuredPointSetType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void MeasuredPointSetType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void MeasuredPointSetType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const MeasuredPointSetType::yDecimalPlaces_optional& MeasuredPointSetType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    MeasuredPointSetType::yDecimalPlaces_optional& MeasuredPointSetType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void MeasuredPointSetType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void MeasuredPointSetType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const MeasuredPointSetType::ySignificantFigures_optional& MeasuredPointSetType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    MeasuredPointSetType::ySignificantFigures_optional& MeasuredPointSetType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void MeasuredPointSetType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void MeasuredPointSetType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const MeasuredPointSetType::yValidity_optional& MeasuredPointSetType::
    yValidity () const
    {
      return this->yValidity_;
    }

    MeasuredPointSetType::yValidity_optional& MeasuredPointSetType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void MeasuredPointSetType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void MeasuredPointSetType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void MeasuredPointSetType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const MeasuredPointSetType::zDecimalPlaces_optional& MeasuredPointSetType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    MeasuredPointSetType::zDecimalPlaces_optional& MeasuredPointSetType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void MeasuredPointSetType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void MeasuredPointSetType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const MeasuredPointSetType::zSignificantFigures_optional& MeasuredPointSetType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    MeasuredPointSetType::zSignificantFigures_optional& MeasuredPointSetType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void MeasuredPointSetType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void MeasuredPointSetType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const MeasuredPointSetType::zValidity_optional& MeasuredPointSetType::
    zValidity () const
    {
      return this->zValidity_;
    }

    MeasuredPointSetType::zValidity_optional& MeasuredPointSetType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void MeasuredPointSetType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void MeasuredPointSetType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void MeasuredPointSetType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }

    const MeasuredPointSetType::combinedUncertainty_optional& MeasuredPointSetType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    MeasuredPointSetType::combinedUncertainty_optional& MeasuredPointSetType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void MeasuredPointSetType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void MeasuredPointSetType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const MeasuredPointSetType::meanError_optional& MeasuredPointSetType::
    meanError () const
    {
      return this->meanError_;
    }

    MeasuredPointSetType::meanError_optional& MeasuredPointSetType::
    meanError ()
    {
      return this->meanError_;
    }

    void MeasuredPointSetType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void MeasuredPointSetType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const MeasuredPointSetType::xCombinedUncertainty_optional& MeasuredPointSetType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    MeasuredPointSetType::xCombinedUncertainty_optional& MeasuredPointSetType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void MeasuredPointSetType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void MeasuredPointSetType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const MeasuredPointSetType::xMeanError_optional& MeasuredPointSetType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    MeasuredPointSetType::xMeanError_optional& MeasuredPointSetType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void MeasuredPointSetType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void MeasuredPointSetType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const MeasuredPointSetType::yCombinedUncertainty_optional& MeasuredPointSetType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    MeasuredPointSetType::yCombinedUncertainty_optional& MeasuredPointSetType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void MeasuredPointSetType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void MeasuredPointSetType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const MeasuredPointSetType::yMeanError_optional& MeasuredPointSetType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    MeasuredPointSetType::yMeanError_optional& MeasuredPointSetType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void MeasuredPointSetType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void MeasuredPointSetType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const MeasuredPointSetType::zCombinedUncertainty_optional& MeasuredPointSetType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    MeasuredPointSetType::zCombinedUncertainty_optional& MeasuredPointSetType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void MeasuredPointSetType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void MeasuredPointSetType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const MeasuredPointSetType::zMeanError_optional& MeasuredPointSetType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    MeasuredPointSetType::zMeanError_optional& MeasuredPointSetType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void MeasuredPointSetType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void MeasuredPointSetType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }

    const MeasuredPointSetType::id_type& MeasuredPointSetType::
    id () const
    {
      return this->id_.get ();
    }

    MeasuredPointSetType::id_type& MeasuredPointSetType::
    id ()
    {
      return this->id_.get ();
    }

    void MeasuredPointSetType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void MeasuredPointSetType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // FeatureMeasurementBaseType
    //

    const FeatureMeasurementBaseType::FeatureItemId_optional& FeatureMeasurementBaseType::
    FeatureItemId () const
    {
      return this->FeatureItemId_;
    }

    FeatureMeasurementBaseType::FeatureItemId_optional& FeatureMeasurementBaseType::
    FeatureItemId ()
    {
      return this->FeatureItemId_;
    }

    void FeatureMeasurementBaseType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void FeatureMeasurementBaseType::
    FeatureItemId (const FeatureItemId_optional& x)
    {
      this->FeatureItemId_ = x;
    }

    void FeatureMeasurementBaseType::
    FeatureItemId (::std::unique_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (std::move (x));
    }

    const FeatureMeasurementBaseType::FeatureName_optional& FeatureMeasurementBaseType::
    FeatureName () const
    {
      return this->FeatureName_;
    }

    FeatureMeasurementBaseType::FeatureName_optional& FeatureMeasurementBaseType::
    FeatureName ()
    {
      return this->FeatureName_;
    }

    void FeatureMeasurementBaseType::
    FeatureName (const FeatureName_type& x)
    {
      this->FeatureName_.set (x);
    }

    void FeatureMeasurementBaseType::
    FeatureName (const FeatureName_optional& x)
    {
      this->FeatureName_ = x;
    }

    void FeatureMeasurementBaseType::
    FeatureName (::std::unique_ptr< FeatureName_type > x)
    {
      this->FeatureName_.set (std::move (x));
    }

    const FeatureMeasurementBaseType::TimeStamp_optional& FeatureMeasurementBaseType::
    TimeStamp () const
    {
      return this->TimeStamp_;
    }

    FeatureMeasurementBaseType::TimeStamp_optional& FeatureMeasurementBaseType::
    TimeStamp ()
    {
      return this->TimeStamp_;
    }

    void FeatureMeasurementBaseType::
    TimeStamp (const TimeStamp_type& x)
    {
      this->TimeStamp_.set (x);
    }

    void FeatureMeasurementBaseType::
    TimeStamp (const TimeStamp_optional& x)
    {
      this->TimeStamp_ = x;
    }

    void FeatureMeasurementBaseType::
    TimeStamp (::std::unique_ptr< TimeStamp_type > x)
    {
      this->TimeStamp_.set (std::move (x));
    }

    const FeatureMeasurementBaseType::ActualComponentId_optional& FeatureMeasurementBaseType::
    ActualComponentId () const
    {
      return this->ActualComponentId_;
    }

    FeatureMeasurementBaseType::ActualComponentId_optional& FeatureMeasurementBaseType::
    ActualComponentId ()
    {
      return this->ActualComponentId_;
    }

    void FeatureMeasurementBaseType::
    ActualComponentId (const ActualComponentId_type& x)
    {
      this->ActualComponentId_.set (x);
    }

    void FeatureMeasurementBaseType::
    ActualComponentId (const ActualComponentId_optional& x)
    {
      this->ActualComponentId_ = x;
    }

    void FeatureMeasurementBaseType::
    ActualComponentId (::std::unique_ptr< ActualComponentId_type > x)
    {
      this->ActualComponentId_.set (std::move (x));
    }

    const FeatureMeasurementBaseType::ManufacturingProcessId_optional& FeatureMeasurementBaseType::
    ManufacturingProcessId () const
    {
      return this->ManufacturingProcessId_;
    }

    FeatureMeasurementBaseType::ManufacturingProcessId_optional& FeatureMeasurementBaseType::
    ManufacturingProcessId ()
    {
      return this->ManufacturingProcessId_;
    }

    void FeatureMeasurementBaseType::
    ManufacturingProcessId (const ManufacturingProcessId_type& x)
    {
      this->ManufacturingProcessId_.set (x);
    }

    void FeatureMeasurementBaseType::
    ManufacturingProcessId (const ManufacturingProcessId_optional& x)
    {
      this->ManufacturingProcessId_ = x;
    }

    void FeatureMeasurementBaseType::
    ManufacturingProcessId (::std::unique_ptr< ManufacturingProcessId_type > x)
    {
      this->ManufacturingProcessId_.set (std::move (x));
    }

    const FeatureMeasurementBaseType::MeasurementDeviceIds_optional& FeatureMeasurementBaseType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    FeatureMeasurementBaseType::MeasurementDeviceIds_optional& FeatureMeasurementBaseType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void FeatureMeasurementBaseType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void FeatureMeasurementBaseType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void FeatureMeasurementBaseType::
    MeasurementDeviceIds (::std::unique_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (std::move (x));
    }

    const FeatureMeasurementBaseType::ActualTransformId_optional& FeatureMeasurementBaseType::
    ActualTransformId () const
    {
      return this->ActualTransformId_;
    }

    FeatureMeasurementBaseType::ActualTransformId_optional& FeatureMeasurementBaseType::
    ActualTransformId ()
    {
      return this->ActualTransformId_;
    }

    void FeatureMeasurementBaseType::
    ActualTransformId (const ActualTransformId_type& x)
    {
      this->ActualTransformId_.set (x);
    }

    void FeatureMeasurementBaseType::
    ActualTransformId (const ActualTransformId_optional& x)
    {
      this->ActualTransformId_ = x;
    }

    void FeatureMeasurementBaseType::
    ActualTransformId (::std::unique_ptr< ActualTransformId_type > x)
    {
      this->ActualTransformId_.set (std::move (x));
    }

    const FeatureMeasurementBaseType::NotedEventIds_optional& FeatureMeasurementBaseType::
    NotedEventIds () const
    {
      return this->NotedEventIds_;
    }

    FeatureMeasurementBaseType::NotedEventIds_optional& FeatureMeasurementBaseType::
    NotedEventIds ()
    {
      return this->NotedEventIds_;
    }

    void FeatureMeasurementBaseType::
    NotedEventIds (const NotedEventIds_type& x)
    {
      this->NotedEventIds_.set (x);
    }

    void FeatureMeasurementBaseType::
    NotedEventIds (const NotedEventIds_optional& x)
    {
      this->NotedEventIds_ = x;
    }

    void FeatureMeasurementBaseType::
    NotedEventIds (::std::unique_ptr< NotedEventIds_type > x)
    {
      this->NotedEventIds_.set (std::move (x));
    }


    // ShapeFeatureMeasurementBaseType
    //

    const ShapeFeatureMeasurementBaseType::PointList_optional& ShapeFeatureMeasurementBaseType::
    PointList () const
    {
      return this->PointList_;
    }

    ShapeFeatureMeasurementBaseType::PointList_optional& ShapeFeatureMeasurementBaseType::
    PointList ()
    {
      return this->PointList_;
    }

    void ShapeFeatureMeasurementBaseType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void ShapeFeatureMeasurementBaseType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void ShapeFeatureMeasurementBaseType::
    PointList (::std::unique_ptr< PointList_type > x)
    {
      this->PointList_.set (std::move (x));
    }

    const ShapeFeatureMeasurementBaseType::SubstituteFeatureAlgorithm_optional& ShapeFeatureMeasurementBaseType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ShapeFeatureMeasurementBaseType::SubstituteFeatureAlgorithm_optional& ShapeFeatureMeasurementBaseType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ShapeFeatureMeasurementBaseType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ShapeFeatureMeasurementBaseType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ShapeFeatureMeasurementBaseType::
    SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (std::move (x));
    }

    const ShapeFeatureMeasurementBaseType::ProxyMeasurementId_optional& ShapeFeatureMeasurementBaseType::
    ProxyMeasurementId () const
    {
      return this->ProxyMeasurementId_;
    }

    ShapeFeatureMeasurementBaseType::ProxyMeasurementId_optional& ShapeFeatureMeasurementBaseType::
    ProxyMeasurementId ()
    {
      return this->ProxyMeasurementId_;
    }

    void ShapeFeatureMeasurementBaseType::
    ProxyMeasurementId (const ProxyMeasurementId_type& x)
    {
      this->ProxyMeasurementId_.set (x);
    }

    void ShapeFeatureMeasurementBaseType::
    ProxyMeasurementId (const ProxyMeasurementId_optional& x)
    {
      this->ProxyMeasurementId_ = x;
    }

    void ShapeFeatureMeasurementBaseType::
    ProxyMeasurementId (::std::unique_ptr< ProxyMeasurementId_type > x)
    {
      this->ProxyMeasurementId_.set (std::move (x));
    }


    // NonShapeFeatureMeasurementBaseType
    //


    // SetFeatureType
    //


    // MeasuredFeatureType
    //

    const MeasuredFeatureType::PointList_optional& MeasuredFeatureType::
    PointList () const
    {
      return this->PointList_;
    }

    MeasuredFeatureType::PointList_optional& MeasuredFeatureType::
    PointList ()
    {
      return this->PointList_;
    }

    void MeasuredFeatureType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void MeasuredFeatureType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void MeasuredFeatureType::
    PointList (::std::unique_ptr< PointList_type > x)
    {
      this->PointList_.set (std::move (x));
    }


    // ConstructionMethodBaseType
    //

    const ConstructionMethodBaseType::NominalsCalculated_optional& ConstructionMethodBaseType::
    NominalsCalculated () const
    {
      return this->NominalsCalculated_;
    }

    ConstructionMethodBaseType::NominalsCalculated_optional& ConstructionMethodBaseType::
    NominalsCalculated ()
    {
      return this->NominalsCalculated_;
    }

    void ConstructionMethodBaseType::
    NominalsCalculated (const NominalsCalculated_type& x)
    {
      this->NominalsCalculated_.set (x);
    }

    void ConstructionMethodBaseType::
    NominalsCalculated (const NominalsCalculated_optional& x)
    {
      this->NominalsCalculated_ = x;
    }


    // PointRangeType
    //

    const PointRangeType::Start_type& PointRangeType::
    Start () const
    {
      return this->Start_.get ();
    }

    PointRangeType::Start_type& PointRangeType::
    Start ()
    {
      return this->Start_.get ();
    }

    void PointRangeType::
    Start (const Start_type& x)
    {
      this->Start_.set (x);
    }

    void PointRangeType::
    Start (::std::unique_ptr< Start_type > x)
    {
      this->Start_.set (std::move (x));
    }

    const PointRangeType::Stop_type& PointRangeType::
    Stop () const
    {
      return this->Stop_.get ();
    }

    PointRangeType::Stop_type& PointRangeType::
    Stop ()
    {
      return this->Stop_.get ();
    }

    void PointRangeType::
    Stop (const Stop_type& x)
    {
      this->Stop_.set (x);
    }

    void PointRangeType::
    Stop (::std::unique_ptr< Stop_type > x)
    {
      this->Stop_.set (std::move (x));
    }


    // PointIndexType
    //

    const PointIndexType::Single_optional& PointIndexType::
    Single () const
    {
      return this->Single_;
    }

    PointIndexType::Single_optional& PointIndexType::
    Single ()
    {
      return this->Single_;
    }

    void PointIndexType::
    Single (const Single_type& x)
    {
      this->Single_.set (x);
    }

    void PointIndexType::
    Single (const Single_optional& x)
    {
      this->Single_ = x;
    }

    void PointIndexType::
    Single (::std::unique_ptr< Single_type > x)
    {
      this->Single_.set (std::move (x));
    }

    const PointIndexType::Range_optional& PointIndexType::
    Range () const
    {
      return this->Range_;
    }

    PointIndexType::Range_optional& PointIndexType::
    Range ()
    {
      return this->Range_;
    }

    void PointIndexType::
    Range (const Range_type& x)
    {
      this->Range_.set (x);
    }

    void PointIndexType::
    Range (const Range_optional& x)
    {
      this->Range_ = x;
    }

    void PointIndexType::
    Range (::std::unique_ptr< Range_type > x)
    {
      this->Range_.set (std::move (x));
    }

    const PointIndexType::All_optional& PointIndexType::
    All () const
    {
      return this->All_;
    }

    PointIndexType::All_optional& PointIndexType::
    All ()
    {
      return this->All_;
    }

    void PointIndexType::
    All (const All_type& x)
    {
      this->All_.set (x);
    }

    void PointIndexType::
    All (const All_optional& x)
    {
      this->All_ = x;
    }

    void PointIndexType::
    All (::std::unique_ptr< All_type > x)
    {
      this->All_.set (std::move (x));
    }

    const PointIndexType::All_type& PointIndexType::
    All_default_value ()
    {
      return All_default_value_;
    }


    // BaseFeaturePointSetType
    //

    const BaseFeaturePointSetType::FeatureId_type& BaseFeaturePointSetType::
    FeatureId () const
    {
      return this->FeatureId_.get ();
    }

    BaseFeaturePointSetType::FeatureId_type& BaseFeaturePointSetType::
    FeatureId ()
    {
      return this->FeatureId_.get ();
    }

    void BaseFeaturePointSetType::
    FeatureId (const FeatureId_type& x)
    {
      this->FeatureId_.set (x);
    }

    void BaseFeaturePointSetType::
    FeatureId (::std::unique_ptr< FeatureId_type > x)
    {
      this->FeatureId_.set (std::move (x));
    }

    const BaseFeaturePointSetType::PointIndex_type& BaseFeaturePointSetType::
    PointIndex () const
    {
      return this->PointIndex_.get ();
    }

    BaseFeaturePointSetType::PointIndex_type& BaseFeaturePointSetType::
    PointIndex ()
    {
      return this->PointIndex_.get ();
    }

    void BaseFeaturePointSetType::
    PointIndex (const PointIndex_type& x)
    {
      this->PointIndex_.set (x);
    }

    void BaseFeaturePointSetType::
    PointIndex (::std::unique_ptr< PointIndex_type > x)
    {
      this->PointIndex_.set (std::move (x));
    }

    const BaseFeaturePointSetType::ReferencedComponent_type& BaseFeaturePointSetType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    BaseFeaturePointSetType::ReferencedComponent_type& BaseFeaturePointSetType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void BaseFeaturePointSetType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void BaseFeaturePointSetType::
    ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (std::move (x));
    }

    const BaseFeaturePointSetType::SequenceNumber_type& BaseFeaturePointSetType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    BaseFeaturePointSetType::SequenceNumber_type& BaseFeaturePointSetType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void BaseFeaturePointSetType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void BaseFeaturePointSetType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }


    // BaseFeaturePointListType
    //

    const BaseFeaturePointListType::BaseFeaturePointSet_sequence& BaseFeaturePointListType::
    BaseFeaturePointSet () const
    {
      return this->BaseFeaturePointSet_;
    }

    BaseFeaturePointListType::BaseFeaturePointSet_sequence& BaseFeaturePointListType::
    BaseFeaturePointSet ()
    {
      return this->BaseFeaturePointSet_;
    }

    void BaseFeaturePointListType::
    BaseFeaturePointSet (const BaseFeaturePointSet_sequence& s)
    {
      this->BaseFeaturePointSet_ = s;
    }

    const BaseFeaturePointListType::n_type& BaseFeaturePointListType::
    n () const
    {
      return this->n_.get ();
    }

    BaseFeaturePointListType::n_type& BaseFeaturePointListType::
    n ()
    {
      return this->n_.get ();
    }

    void BaseFeaturePointListType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void BaseFeaturePointListType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // TransformationReferenceType
    //

    const TransformationReferenceType::ReferencedComponent_type& TransformationReferenceType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    TransformationReferenceType::ReferencedComponent_type& TransformationReferenceType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void TransformationReferenceType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void TransformationReferenceType::
    ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (std::move (x));
    }

    const TransformationReferenceType::CoordinateSystemId_type& TransformationReferenceType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_.get ();
    }

    TransformationReferenceType::CoordinateSystemId_type& TransformationReferenceType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_.get ();
    }

    void TransformationReferenceType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void TransformationReferenceType::
    CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (std::move (x));
    }

    const TransformationReferenceType::SequenceNumber_type& TransformationReferenceType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    TransformationReferenceType::SequenceNumber_type& TransformationReferenceType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void TransformationReferenceType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void TransformationReferenceType::
    SequenceNumber (::std::unique_ptr< SequenceNumber_type > x)
    {
      this->SequenceNumber_.set (std::move (x));
    }


    // SurfaceFeatureItemBaseType
    //


    // SurfaceFeatureDefinitionBaseType
    //


    // SurfaceFeatureNominalBaseType
    //


    // SurfaceFeatureMeasurementBaseType
    //


    // CurveFeatureItemBaseType
    //


    // CurveFeatureDefinitionBaseType
    //


    // CurveFeatureNominalBaseType
    //

    const CurveFeatureNominalBaseType::SurfaceFeatureNominalId_optional& CurveFeatureNominalBaseType::
    SurfaceFeatureNominalId () const
    {
      return this->SurfaceFeatureNominalId_;
    }

    CurveFeatureNominalBaseType::SurfaceFeatureNominalId_optional& CurveFeatureNominalBaseType::
    SurfaceFeatureNominalId ()
    {
      return this->SurfaceFeatureNominalId_;
    }

    void CurveFeatureNominalBaseType::
    SurfaceFeatureNominalId (const SurfaceFeatureNominalId_type& x)
    {
      this->SurfaceFeatureNominalId_.set (x);
    }

    void CurveFeatureNominalBaseType::
    SurfaceFeatureNominalId (const SurfaceFeatureNominalId_optional& x)
    {
      this->SurfaceFeatureNominalId_ = x;
    }

    void CurveFeatureNominalBaseType::
    SurfaceFeatureNominalId (::std::unique_ptr< SurfaceFeatureNominalId_type > x)
    {
      this->SurfaceFeatureNominalId_.set (std::move (x));
    }


    // CurveFeatureMeasurementBaseType
    //


    // PointFeatureItemBaseType
    //


    // PointFeatureDefinitionBaseType
    //


    // PointFeatureNominalBaseType
    //

    const PointFeatureNominalBaseType::SurfaceFeatureNominalId_optional& PointFeatureNominalBaseType::
    SurfaceFeatureNominalId () const
    {
      return this->SurfaceFeatureNominalId_;
    }

    PointFeatureNominalBaseType::SurfaceFeatureNominalId_optional& PointFeatureNominalBaseType::
    SurfaceFeatureNominalId ()
    {
      return this->SurfaceFeatureNominalId_;
    }

    void PointFeatureNominalBaseType::
    SurfaceFeatureNominalId (const SurfaceFeatureNominalId_type& x)
    {
      this->SurfaceFeatureNominalId_.set (x);
    }

    void PointFeatureNominalBaseType::
    SurfaceFeatureNominalId (const SurfaceFeatureNominalId_optional& x)
    {
      this->SurfaceFeatureNominalId_ = x;
    }

    void PointFeatureNominalBaseType::
    SurfaceFeatureNominalId (::std::unique_ptr< SurfaceFeatureNominalId_type > x)
    {
      this->SurfaceFeatureNominalId_.set (std::move (x));
    }

    const PointFeatureNominalBaseType::CurveFeatureNominalId_optional& PointFeatureNominalBaseType::
    CurveFeatureNominalId () const
    {
      return this->CurveFeatureNominalId_;
    }

    PointFeatureNominalBaseType::CurveFeatureNominalId_optional& PointFeatureNominalBaseType::
    CurveFeatureNominalId ()
    {
      return this->CurveFeatureNominalId_;
    }

    void PointFeatureNominalBaseType::
    CurveFeatureNominalId (const CurveFeatureNominalId_type& x)
    {
      this->CurveFeatureNominalId_.set (x);
    }

    void PointFeatureNominalBaseType::
    CurveFeatureNominalId (const CurveFeatureNominalId_optional& x)
    {
      this->CurveFeatureNominalId_ = x;
    }

    void PointFeatureNominalBaseType::
    CurveFeatureNominalId (::std::unique_ptr< CurveFeatureNominalId_type > x)
    {
      this->CurveFeatureNominalId_.set (std::move (x));
    }


    // PointFeatureMeasurementBaseType
    //


    // SpecifiedFeatureItemBaseType
    //


    // SpecifiedFeatureDefinitionBaseType
    //


    // SpecifiedFeatureNominalBaseType
    //


    // SpecifiedFeatureMeasurementBaseType
    //


    // CircleConstructionMethodType
    //

    const CircleConstructionMethodType::BestFit_optional& CircleConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CircleConstructionMethodType::BestFit_optional& CircleConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CircleConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CircleConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CircleConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const CircleConstructionMethodType::Recompensated_optional& CircleConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CircleConstructionMethodType::Recompensated_optional& CircleConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CircleConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CircleConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CircleConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const CircleConstructionMethodType::Intersection_optional& CircleConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    CircleConstructionMethodType::Intersection_optional& CircleConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void CircleConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void CircleConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void CircleConstructionMethodType::
    Intersection (::std::unique_ptr< Intersection_type > x)
    {
      this->Intersection_.set (std::move (x));
    }

    const CircleConstructionMethodType::Projection_optional& CircleConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    CircleConstructionMethodType::Projection_optional& CircleConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void CircleConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void CircleConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void CircleConstructionMethodType::
    Projection (::std::unique_ptr< Projection_type > x)
    {
      this->Projection_.set (std::move (x));
    }

    const CircleConstructionMethodType::Copy_optional& CircleConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CircleConstructionMethodType::Copy_optional& CircleConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CircleConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CircleConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CircleConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const CircleConstructionMethodType::Cast_optional& CircleConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CircleConstructionMethodType::Cast_optional& CircleConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CircleConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CircleConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CircleConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const CircleConstructionMethodType::Tangent_optional& CircleConstructionMethodType::
    Tangent () const
    {
      return this->Tangent_;
    }

    CircleConstructionMethodType::Tangent_optional& CircleConstructionMethodType::
    Tangent ()
    {
      return this->Tangent_;
    }

    void CircleConstructionMethodType::
    Tangent (const Tangent_type& x)
    {
      this->Tangent_.set (x);
    }

    void CircleConstructionMethodType::
    Tangent (const Tangent_optional& x)
    {
      this->Tangent_ = x;
    }

    void CircleConstructionMethodType::
    Tangent (::std::unique_ptr< Tangent_type > x)
    {
      this->Tangent_.set (std::move (x));
    }

    const CircleConstructionMethodType::TangentThrough_optional& CircleConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    CircleConstructionMethodType::TangentThrough_optional& CircleConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void CircleConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void CircleConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void CircleConstructionMethodType::
    TangentThrough (::std::unique_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (std::move (x));
    }

    const CircleConstructionMethodType::Transform_optional& CircleConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CircleConstructionMethodType::Transform_optional& CircleConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CircleConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CircleConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CircleConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const CircleConstructionMethodType::FromCone_optional& CircleConstructionMethodType::
    FromCone () const
    {
      return this->FromCone_;
    }

    CircleConstructionMethodType::FromCone_optional& CircleConstructionMethodType::
    FromCone ()
    {
      return this->FromCone_;
    }

    void CircleConstructionMethodType::
    FromCone (const FromCone_type& x)
    {
      this->FromCone_.set (x);
    }

    void CircleConstructionMethodType::
    FromCone (const FromCone_optional& x)
    {
      this->FromCone_ = x;
    }

    void CircleConstructionMethodType::
    FromCone (::std::unique_ptr< FromCone_type > x)
    {
      this->FromCone_.set (std::move (x));
    }

    const CircleConstructionMethodType::FromScan_optional& CircleConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    CircleConstructionMethodType::FromScan_optional& CircleConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void CircleConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void CircleConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void CircleConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // CircleBestFitType
    //

    const CircleBestFitType::BaseFeature_sequence& CircleBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CircleBestFitType::BaseFeature_sequence& CircleBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CircleBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const CircleBestFitType::n_type& CircleBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    CircleBestFitType::n_type& CircleBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void CircleBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CircleBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // CircleRecompType
    //

    const CircleRecompType::BaseFeaturePointList_type& CircleRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CircleRecompType::BaseFeaturePointList_type& CircleRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CircleRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CircleRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // CircleIntersectionType
    //

    const CircleIntersectionType::IntersectionFeature_sequence& CircleIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_;
    }

    CircleIntersectionType::IntersectionFeature_sequence& CircleIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_;
    }

    void CircleIntersectionType::
    IntersectionFeature (const IntersectionFeature_sequence& s)
    {
      this->IntersectionFeature_ = s;
    }


    // CircleProjectionType
    //

    const CircleProjectionType::ProjectionCircle_type& CircleProjectionType::
    ProjectionCircle () const
    {
      return this->ProjectionCircle_.get ();
    }

    CircleProjectionType::ProjectionCircle_type& CircleProjectionType::
    ProjectionCircle ()
    {
      return this->ProjectionCircle_.get ();
    }

    void CircleProjectionType::
    ProjectionCircle (const ProjectionCircle_type& x)
    {
      this->ProjectionCircle_.set (x);
    }

    void CircleProjectionType::
    ProjectionCircle (::std::unique_ptr< ProjectionCircle_type > x)
    {
      this->ProjectionCircle_.set (std::move (x));
    }

    const CircleProjectionType::ProjectionPlane_type& CircleProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    CircleProjectionType::ProjectionPlane_type& CircleProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void CircleProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void CircleProjectionType::
    ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (std::move (x));
    }


    // CircleCopyType
    //

    const CircleCopyType::BaseCircle_type& CircleCopyType::
    BaseCircle () const
    {
      return this->BaseCircle_.get ();
    }

    CircleCopyType::BaseCircle_type& CircleCopyType::
    BaseCircle ()
    {
      return this->BaseCircle_.get ();
    }

    void CircleCopyType::
    BaseCircle (const BaseCircle_type& x)
    {
      this->BaseCircle_.set (x);
    }

    void CircleCopyType::
    BaseCircle (::std::unique_ptr< BaseCircle_type > x)
    {
      this->BaseCircle_.set (std::move (x));
    }


    // CircleCastType
    //

    const CircleCastType::BaseFeature_type& CircleCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CircleCastType::BaseFeature_type& CircleCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CircleCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CircleCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // CircleTangentType
    //

    const CircleTangentType::TangentFeature_sequence& CircleTangentType::
    TangentFeature () const
    {
      return this->TangentFeature_;
    }

    CircleTangentType::TangentFeature_sequence& CircleTangentType::
    TangentFeature ()
    {
      return this->TangentFeature_;
    }

    void CircleTangentType::
    TangentFeature (const TangentFeature_sequence& s)
    {
      this->TangentFeature_ = s;
    }


    // CircleTangentThroughType
    //

    const CircleTangentThroughType::TangentFeature_type& CircleTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    CircleTangentThroughType::TangentFeature_type& CircleTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void CircleTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void CircleTangentThroughType::
    TangentFeature (::std::unique_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (std::move (x));
    }

    const CircleTangentThroughType::PointFeature_type& CircleTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    CircleTangentThroughType::PointFeature_type& CircleTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void CircleTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void CircleTangentThroughType::
    PointFeature (::std::unique_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (std::move (x));
    }


    // CircleTransformType
    //

    const CircleTransformType::BaseCircle_type& CircleTransformType::
    BaseCircle () const
    {
      return this->BaseCircle_.get ();
    }

    CircleTransformType::BaseCircle_type& CircleTransformType::
    BaseCircle ()
    {
      return this->BaseCircle_.get ();
    }

    void CircleTransformType::
    BaseCircle (const BaseCircle_type& x)
    {
      this->BaseCircle_.set (x);
    }

    void CircleTransformType::
    BaseCircle (::std::unique_ptr< BaseCircle_type > x)
    {
      this->BaseCircle_.set (std::move (x));
    }

    const CircleTransformType::Transformation_type& CircleTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CircleTransformType::Transformation_type& CircleTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CircleTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CircleTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // CircleFromConeType
    //

    const CircleFromConeType::Diameter_optional& CircleFromConeType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CircleFromConeType::Diameter_optional& CircleFromConeType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CircleFromConeType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFromConeType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CircleFromConeType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const CircleFromConeType::Distance_optional& CircleFromConeType::
    Distance () const
    {
      return this->Distance_;
    }

    CircleFromConeType::Distance_optional& CircleFromConeType::
    Distance ()
    {
      return this->Distance_;
    }

    void CircleFromConeType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void CircleFromConeType::
    Distance (const Distance_optional& x)
    {
      this->Distance_ = x;
    }

    void CircleFromConeType::
    Distance (::std::unique_ptr< Distance_type > x)
    {
      this->Distance_.set (std::move (x));
    }


    // CircleFromScanType
    //

    const CircleFromScanType::SurfaceFeature_type& CircleFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    CircleFromScanType::SurfaceFeature_type& CircleFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void CircleFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void CircleFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const CircleFromScanType::SearchRadius_type& CircleFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    CircleFromScanType::SearchRadius_type& CircleFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void CircleFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void CircleFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const CircleFromScanType::Depth_type& CircleFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    CircleFromScanType::Depth_type& CircleFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void CircleFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void CircleFromScanType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }


    // CircleCheckedType
    //

    const CircleCheckedType::Measured_optional& CircleCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CircleCheckedType::Measured_optional& CircleCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CircleCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CircleCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CircleCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const CircleCheckedType::Constructed_optional& CircleCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CircleCheckedType::Constructed_optional& CircleCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CircleCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CircleCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CircleCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // CircleCheckedFeatureType
    //

    const CircleCheckedFeatureType::CheckDetails_optional& CircleCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CircleCheckedFeatureType::CheckDetails_optional& CircleCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CircleCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CircleCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CircleCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // CircleMeasurementDeterminationType
    //

    const CircleMeasurementDeterminationType::Checked_optional& CircleMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CircleMeasurementDeterminationType::Checked_optional& CircleMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CircleMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CircleMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CircleMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const CircleMeasurementDeterminationType::Set_optional& CircleMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CircleMeasurementDeterminationType::Set_optional& CircleMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CircleMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CircleMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CircleMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // CircleFeatureItemType
    //

    const CircleFeatureItemType::DeterminationMode_type& CircleFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CircleFeatureItemType::DeterminationMode_type& CircleFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CircleFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CircleFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // CircleFeatureDefinitionType
    //

    const CircleFeatureDefinitionType::InternalExternal_type& CircleFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CircleFeatureDefinitionType::InternalExternal_type& CircleFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CircleFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CircleFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const CircleFeatureDefinitionType::Diameter_type& CircleFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CircleFeatureDefinitionType::Diameter_type& CircleFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CircleFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }


    // CircleFeatureNominalType
    //

    const CircleFeatureNominalType::Location_type& CircleFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    CircleFeatureNominalType::Location_type& CircleFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void CircleFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CircleFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const CircleFeatureNominalType::Normal_type& CircleFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    CircleFeatureNominalType::Normal_type& CircleFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void CircleFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircleFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const CircleFeatureNominalType::Sweep_optional& CircleFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    CircleFeatureNominalType::Sweep_optional& CircleFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void CircleFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CircleFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void CircleFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const CircleFeatureNominalType::Constructed_optional& CircleFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CircleFeatureNominalType::Constructed_optional& CircleFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CircleFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CircleFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CircleFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // CircleFeatureMeasurementType
    //

    const CircleFeatureMeasurementType::Location_optional& CircleFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    CircleFeatureMeasurementType::Location_optional& CircleFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void CircleFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CircleFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void CircleFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const CircleFeatureMeasurementType::Normal_optional& CircleFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    CircleFeatureMeasurementType::Normal_optional& CircleFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void CircleFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircleFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void CircleFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const CircleFeatureMeasurementType::Diameter_optional& CircleFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CircleFeatureMeasurementType::Diameter_optional& CircleFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CircleFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CircleFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const CircleFeatureMeasurementType::DiameterMin_optional& CircleFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CircleFeatureMeasurementType::DiameterMin_optional& CircleFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CircleFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CircleFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CircleFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const CircleFeatureMeasurementType::DiameterMax_optional& CircleFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CircleFeatureMeasurementType::DiameterMax_optional& CircleFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CircleFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CircleFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CircleFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const CircleFeatureMeasurementType::Form_optional& CircleFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    CircleFeatureMeasurementType::Form_optional& CircleFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void CircleFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CircleFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CircleFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }

    const CircleFeatureMeasurementType::SweepMeasurementRange_optional& CircleFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    CircleFeatureMeasurementType::SweepMeasurementRange_optional& CircleFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void CircleFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void CircleFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void CircleFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const CircleFeatureMeasurementType::SweepFull_optional& CircleFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    CircleFeatureMeasurementType::SweepFull_optional& CircleFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void CircleFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void CircleFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void CircleFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }


    // CircularArcConstructionMethodType
    //

    const CircularArcConstructionMethodType::BestFit_optional& CircularArcConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CircularArcConstructionMethodType::BestFit_optional& CircularArcConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CircularArcConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CircularArcConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CircularArcConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const CircularArcConstructionMethodType::Intersection_optional& CircularArcConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    CircularArcConstructionMethodType::Intersection_optional& CircularArcConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void CircularArcConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void CircularArcConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void CircularArcConstructionMethodType::
    Intersection (::std::unique_ptr< Intersection_type > x)
    {
      this->Intersection_.set (std::move (x));
    }

    const CircularArcConstructionMethodType::Recompensated_optional& CircularArcConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CircularArcConstructionMethodType::Recompensated_optional& CircularArcConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CircularArcConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CircularArcConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CircularArcConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const CircularArcConstructionMethodType::Projection_optional& CircularArcConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    CircularArcConstructionMethodType::Projection_optional& CircularArcConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void CircularArcConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void CircularArcConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void CircularArcConstructionMethodType::
    Projection (::std::unique_ptr< Projection_type > x)
    {
      this->Projection_.set (std::move (x));
    }

    const CircularArcConstructionMethodType::Copy_optional& CircularArcConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CircularArcConstructionMethodType::Copy_optional& CircularArcConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CircularArcConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CircularArcConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CircularArcConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const CircularArcConstructionMethodType::Cast_optional& CircularArcConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CircularArcConstructionMethodType::Cast_optional& CircularArcConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CircularArcConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CircularArcConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CircularArcConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const CircularArcConstructionMethodType::Transform_optional& CircularArcConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CircularArcConstructionMethodType::Transform_optional& CircularArcConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CircularArcConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CircularArcConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CircularArcConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const CircularArcConstructionMethodType::FromScan_optional& CircularArcConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    CircularArcConstructionMethodType::FromScan_optional& CircularArcConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void CircularArcConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void CircularArcConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void CircularArcConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }

    const CircularArcConstructionMethodType::Extract_optional& CircularArcConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    CircularArcConstructionMethodType::Extract_optional& CircularArcConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void CircularArcConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void CircularArcConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void CircularArcConstructionMethodType::
    Extract (::std::unique_ptr< Extract_type > x)
    {
      this->Extract_.set (std::move (x));
    }


    // CircularArcBestFitType
    //

    const CircularArcBestFitType::BaseFeature_sequence& CircularArcBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CircularArcBestFitType::BaseFeature_sequence& CircularArcBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CircularArcBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const CircularArcBestFitType::n_type& CircularArcBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    CircularArcBestFitType::n_type& CircularArcBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void CircularArcBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CircularArcBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // CircularArcRecompType
    //

    const CircularArcRecompType::BaseFeaturePointList_type& CircularArcRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CircularArcRecompType::BaseFeaturePointList_type& CircularArcRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CircularArcRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CircularArcRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // CircularArcProjectionType
    //

    const CircularArcProjectionType::ProjectionArc_type& CircularArcProjectionType::
    ProjectionArc () const
    {
      return this->ProjectionArc_.get ();
    }

    CircularArcProjectionType::ProjectionArc_type& CircularArcProjectionType::
    ProjectionArc ()
    {
      return this->ProjectionArc_.get ();
    }

    void CircularArcProjectionType::
    ProjectionArc (const ProjectionArc_type& x)
    {
      this->ProjectionArc_.set (x);
    }

    void CircularArcProjectionType::
    ProjectionArc (::std::unique_ptr< ProjectionArc_type > x)
    {
      this->ProjectionArc_.set (std::move (x));
    }

    const CircularArcProjectionType::ProjectionPlane_type& CircularArcProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    CircularArcProjectionType::ProjectionPlane_type& CircularArcProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void CircularArcProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void CircularArcProjectionType::
    ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (std::move (x));
    }


    // CircularArcCopyType
    //

    const CircularArcCopyType::BaseArc_type& CircularArcCopyType::
    BaseArc () const
    {
      return this->BaseArc_.get ();
    }

    CircularArcCopyType::BaseArc_type& CircularArcCopyType::
    BaseArc ()
    {
      return this->BaseArc_.get ();
    }

    void CircularArcCopyType::
    BaseArc (const BaseArc_type& x)
    {
      this->BaseArc_.set (x);
    }

    void CircularArcCopyType::
    BaseArc (::std::unique_ptr< BaseArc_type > x)
    {
      this->BaseArc_.set (std::move (x));
    }


    // CircularArcCastType
    //

    const CircularArcCastType::BaseFeature_type& CircularArcCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CircularArcCastType::BaseFeature_type& CircularArcCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CircularArcCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CircularArcCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // CircularArcTransformType
    //

    const CircularArcTransformType::BaseArc_type& CircularArcTransformType::
    BaseArc () const
    {
      return this->BaseArc_.get ();
    }

    CircularArcTransformType::BaseArc_type& CircularArcTransformType::
    BaseArc ()
    {
      return this->BaseArc_.get ();
    }

    void CircularArcTransformType::
    BaseArc (const BaseArc_type& x)
    {
      this->BaseArc_.set (x);
    }

    void CircularArcTransformType::
    BaseArc (::std::unique_ptr< BaseArc_type > x)
    {
      this->BaseArc_.set (std::move (x));
    }

    const CircularArcTransformType::Transformation_type& CircularArcTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CircularArcTransformType::Transformation_type& CircularArcTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CircularArcTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CircularArcTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // CircularArcFromScanType
    //

    const CircularArcFromScanType::SurfaceFeature_type& CircularArcFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    CircularArcFromScanType::SurfaceFeature_type& CircularArcFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void CircularArcFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void CircularArcFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const CircularArcFromScanType::SearchRadius_type& CircularArcFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    CircularArcFromScanType::SearchRadius_type& CircularArcFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void CircularArcFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void CircularArcFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const CircularArcFromScanType::Depth_type& CircularArcFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    CircularArcFromScanType::Depth_type& CircularArcFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void CircularArcFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void CircularArcFromScanType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }


    // CircularArcIntersectionType
    //

    const CircularArcIntersectionType::IntersectionFeature_sequence& CircularArcIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_;
    }

    CircularArcIntersectionType::IntersectionFeature_sequence& CircularArcIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_;
    }

    void CircularArcIntersectionType::
    IntersectionFeature (const IntersectionFeature_sequence& s)
    {
      this->IntersectionFeature_ = s;
    }


    // CircularArcExtractType
    //

    const CircularArcExtractType::CurveFeature_type& CircularArcExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    CircularArcExtractType::CurveFeature_type& CircularArcExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void CircularArcExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void CircularArcExtractType::
    CurveFeature (::std::unique_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (std::move (x));
    }


    // CircularArcCheckedType
    //

    const CircularArcCheckedType::Measured_optional& CircularArcCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CircularArcCheckedType::Measured_optional& CircularArcCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CircularArcCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CircularArcCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CircularArcCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const CircularArcCheckedType::Constructed_optional& CircularArcCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CircularArcCheckedType::Constructed_optional& CircularArcCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CircularArcCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CircularArcCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CircularArcCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // CircularArcCheckedFeatureType
    //

    const CircularArcCheckedFeatureType::CheckDetails_optional& CircularArcCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CircularArcCheckedFeatureType::CheckDetails_optional& CircularArcCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CircularArcCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CircularArcCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CircularArcCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // CircularArcMeasurementDeterminationType
    //

    const CircularArcMeasurementDeterminationType::Checked_optional& CircularArcMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CircularArcMeasurementDeterminationType::Checked_optional& CircularArcMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CircularArcMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CircularArcMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CircularArcMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const CircularArcMeasurementDeterminationType::Set_optional& CircularArcMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CircularArcMeasurementDeterminationType::Set_optional& CircularArcMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CircularArcMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CircularArcMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CircularArcMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // CircularArcFeatureItemType
    //

    const CircularArcFeatureItemType::DeterminationMode_type& CircularArcFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CircularArcFeatureItemType::DeterminationMode_type& CircularArcFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CircularArcFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CircularArcFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // CircularArcFeatureDefinitionType
    //

    const CircularArcFeatureDefinitionType::InternalExternal_type& CircularArcFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CircularArcFeatureDefinitionType::InternalExternal_type& CircularArcFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CircularArcFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CircularArcFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const CircularArcFeatureDefinitionType::Radius_type& CircularArcFeatureDefinitionType::
    Radius () const
    {
      return this->Radius_.get ();
    }

    CircularArcFeatureDefinitionType::Radius_type& CircularArcFeatureDefinitionType::
    Radius ()
    {
      return this->Radius_.get ();
    }

    void CircularArcFeatureDefinitionType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    void CircularArcFeatureDefinitionType::
    Radius (::std::unique_ptr< Radius_type > x)
    {
      this->Radius_.set (std::move (x));
    }


    // CircularArcFeatureNominalType
    //

    const CircularArcFeatureNominalType::Location_type& CircularArcFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    CircularArcFeatureNominalType::Location_type& CircularArcFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void CircularArcFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CircularArcFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const CircularArcFeatureNominalType::Sweep_type& CircularArcFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    CircularArcFeatureNominalType::Sweep_type& CircularArcFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void CircularArcFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CircularArcFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const CircularArcFeatureNominalType::Normal_type& CircularArcFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    CircularArcFeatureNominalType::Normal_type& CircularArcFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void CircularArcFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircularArcFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const CircularArcFeatureNominalType::Constructed_optional& CircularArcFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CircularArcFeatureNominalType::Constructed_optional& CircularArcFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CircularArcFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CircularArcFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CircularArcFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // CircularArcFeatureMeasurementType
    //

    const CircularArcFeatureMeasurementType::Location_optional& CircularArcFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    CircularArcFeatureMeasurementType::Location_optional& CircularArcFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void CircularArcFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CircularArcFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void CircularArcFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const CircularArcFeatureMeasurementType::Normal_optional& CircularArcFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    CircularArcFeatureMeasurementType::Normal_optional& CircularArcFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void CircularArcFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircularArcFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void CircularArcFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const CircularArcFeatureMeasurementType::Radius_optional& CircularArcFeatureMeasurementType::
    Radius () const
    {
      return this->Radius_;
    }

    CircularArcFeatureMeasurementType::Radius_optional& CircularArcFeatureMeasurementType::
    Radius ()
    {
      return this->Radius_;
    }

    void CircularArcFeatureMeasurementType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    void CircularArcFeatureMeasurementType::
    Radius (const Radius_optional& x)
    {
      this->Radius_ = x;
    }

    void CircularArcFeatureMeasurementType::
    Radius (::std::unique_ptr< Radius_type > x)
    {
      this->Radius_.set (std::move (x));
    }

    const CircularArcFeatureMeasurementType::RadiusMin_optional& CircularArcFeatureMeasurementType::
    RadiusMin () const
    {
      return this->RadiusMin_;
    }

    CircularArcFeatureMeasurementType::RadiusMin_optional& CircularArcFeatureMeasurementType::
    RadiusMin ()
    {
      return this->RadiusMin_;
    }

    void CircularArcFeatureMeasurementType::
    RadiusMin (const RadiusMin_type& x)
    {
      this->RadiusMin_.set (x);
    }

    void CircularArcFeatureMeasurementType::
    RadiusMin (const RadiusMin_optional& x)
    {
      this->RadiusMin_ = x;
    }

    void CircularArcFeatureMeasurementType::
    RadiusMin (::std::unique_ptr< RadiusMin_type > x)
    {
      this->RadiusMin_.set (std::move (x));
    }

    const CircularArcFeatureMeasurementType::RadiusMax_optional& CircularArcFeatureMeasurementType::
    RadiusMax () const
    {
      return this->RadiusMax_;
    }

    CircularArcFeatureMeasurementType::RadiusMax_optional& CircularArcFeatureMeasurementType::
    RadiusMax ()
    {
      return this->RadiusMax_;
    }

    void CircularArcFeatureMeasurementType::
    RadiusMax (const RadiusMax_type& x)
    {
      this->RadiusMax_.set (x);
    }

    void CircularArcFeatureMeasurementType::
    RadiusMax (const RadiusMax_optional& x)
    {
      this->RadiusMax_ = x;
    }

    void CircularArcFeatureMeasurementType::
    RadiusMax (::std::unique_ptr< RadiusMax_type > x)
    {
      this->RadiusMax_.set (std::move (x));
    }

    const CircularArcFeatureMeasurementType::SweepMeasurementRange_optional& CircularArcFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    CircularArcFeatureMeasurementType::SweepMeasurementRange_optional& CircularArcFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void CircularArcFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void CircularArcFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void CircularArcFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const CircularArcFeatureMeasurementType::SweepFull_optional& CircularArcFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    CircularArcFeatureMeasurementType::SweepFull_optional& CircularArcFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void CircularArcFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void CircularArcFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void CircularArcFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }

    const CircularArcFeatureMeasurementType::Form_optional& CircularArcFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    CircularArcFeatureMeasurementType::Form_optional& CircularArcFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void CircularArcFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CircularArcFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CircularArcFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // ConeConstructionMethodType
    //

    const ConeConstructionMethodType::BestFit_optional& ConeConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ConeConstructionMethodType::BestFit_optional& ConeConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ConeConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ConeConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ConeConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const ConeConstructionMethodType::Recompensated_optional& ConeConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ConeConstructionMethodType::Recompensated_optional& ConeConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ConeConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ConeConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ConeConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const ConeConstructionMethodType::Copy_optional& ConeConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ConeConstructionMethodType::Copy_optional& ConeConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ConeConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ConeConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ConeConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const ConeConstructionMethodType::Cast_optional& ConeConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ConeConstructionMethodType::Cast_optional& ConeConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ConeConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ConeConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ConeConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const ConeConstructionMethodType::Transform_optional& ConeConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ConeConstructionMethodType::Transform_optional& ConeConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ConeConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ConeConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ConeConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const ConeConstructionMethodType::FromScan_optional& ConeConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    ConeConstructionMethodType::FromScan_optional& ConeConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void ConeConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void ConeConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void ConeConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // ConeBestFitType
    //

    const ConeBestFitType::BaseFeature_sequence& ConeBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ConeBestFitType::BaseFeature_sequence& ConeBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ConeBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const ConeBestFitType::n_type& ConeBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    ConeBestFitType::n_type& ConeBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void ConeBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ConeBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ConeRecompType
    //

    const ConeRecompType::BaseFeaturePointList_type& ConeRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ConeRecompType::BaseFeaturePointList_type& ConeRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ConeRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ConeRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // ConeCopyType
    //

    const ConeCopyType::BaseCone_type& ConeCopyType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    ConeCopyType::BaseCone_type& ConeCopyType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void ConeCopyType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void ConeCopyType::
    BaseCone (::std::unique_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (std::move (x));
    }


    // ConeCastType
    //

    const ConeCastType::BaseFeature_type& ConeCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ConeCastType::BaseFeature_type& ConeCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ConeCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ConeCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // ConeTransformType
    //

    const ConeTransformType::BaseCone_type& ConeTransformType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    ConeTransformType::BaseCone_type& ConeTransformType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void ConeTransformType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void ConeTransformType::
    BaseCone (::std::unique_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (std::move (x));
    }

    const ConeTransformType::Transformation_type& ConeTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ConeTransformType::Transformation_type& ConeTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ConeTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ConeTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // ConeFromScanType
    //

    const ConeFromScanType::SurfaceFeature_type& ConeFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    ConeFromScanType::SurfaceFeature_type& ConeFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void ConeFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void ConeFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const ConeFromScanType::SearchRadius_type& ConeFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    ConeFromScanType::SearchRadius_type& ConeFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void ConeFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void ConeFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }


    // ConeCheckedType
    //

    const ConeCheckedType::Measured_optional& ConeCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ConeCheckedType::Measured_optional& ConeCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ConeCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ConeCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ConeCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const ConeCheckedType::Constructed_optional& ConeCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ConeCheckedType::Constructed_optional& ConeCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ConeCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ConeCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ConeCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ConeCheckedFeatureType
    //

    const ConeCheckedFeatureType::CheckDetails_optional& ConeCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ConeCheckedFeatureType::CheckDetails_optional& ConeCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ConeCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ConeCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ConeCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // ConeMeasurementDeterminationType
    //

    const ConeMeasurementDeterminationType::Checked_optional& ConeMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ConeMeasurementDeterminationType::Checked_optional& ConeMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ConeMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ConeMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ConeMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const ConeMeasurementDeterminationType::Set_optional& ConeMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ConeMeasurementDeterminationType::Set_optional& ConeMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ConeMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ConeMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ConeMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // ConeFeatureItemType
    //

    const ConeFeatureItemType::DeterminationMode_type& ConeFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ConeFeatureItemType::DeterminationMode_type& ConeFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ConeFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ConeFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // ConeFeatureDefinitionType
    //

    const ConeFeatureDefinitionType::InternalExternal_type& ConeFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ConeFeatureDefinitionType::InternalExternal_type& ConeFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ConeFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ConeFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const ConeFeatureDefinitionType::Diameter_type& ConeFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ConeFeatureDefinitionType::Diameter_type& ConeFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ConeFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConeFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ConeFeatureDefinitionType::HalfAngle_optional& ConeFeatureDefinitionType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConeFeatureDefinitionType::HalfAngle_optional& ConeFeatureDefinitionType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConeFeatureDefinitionType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConeFeatureDefinitionType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConeFeatureDefinitionType::
    HalfAngle (::std::unique_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (std::move (x));
    }

    const ConeFeatureDefinitionType::FullAngle_optional& ConeFeatureDefinitionType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConeFeatureDefinitionType::FullAngle_optional& ConeFeatureDefinitionType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConeFeatureDefinitionType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConeFeatureDefinitionType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConeFeatureDefinitionType::
    FullAngle (::std::unique_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (std::move (x));
    }

    const ConeFeatureDefinitionType::LargeEndDistance_optional& ConeFeatureDefinitionType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConeFeatureDefinitionType::LargeEndDistance_optional& ConeFeatureDefinitionType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (::std::unique_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (std::move (x));
    }

    const ConeFeatureDefinitionType::SmallEndDistance_optional& ConeFeatureDefinitionType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConeFeatureDefinitionType::SmallEndDistance_optional& ConeFeatureDefinitionType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (::std::unique_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (std::move (x));
    }


    // ConeFeatureNominalType
    //

    const ConeFeatureNominalType::Axis_type& ConeFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ConeFeatureNominalType::Axis_type& ConeFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ConeFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConeFeatureNominalType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const ConeFeatureNominalType::Sweep_optional& ConeFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ConeFeatureNominalType::Sweep_optional& ConeFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ConeFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConeFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ConeFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const ConeFeatureNominalType::Constructed_optional& ConeFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ConeFeatureNominalType::Constructed_optional& ConeFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ConeFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ConeFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ConeFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ConeFeatureMeasurementType
    //

    const ConeFeatureMeasurementType::Axis_optional& ConeFeatureMeasurementType::
    Axis () const
    {
      return this->Axis_;
    }

    ConeFeatureMeasurementType::Axis_optional& ConeFeatureMeasurementType::
    Axis ()
    {
      return this->Axis_;
    }

    void ConeFeatureMeasurementType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConeFeatureMeasurementType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ConeFeatureMeasurementType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::Diameter_optional& ConeFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ConeFeatureMeasurementType::Diameter_optional& ConeFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ConeFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConeFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ConeFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::DiameterMin_optional& ConeFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ConeFeatureMeasurementType::DiameterMin_optional& ConeFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ConeFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ConeFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ConeFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::DiameterMax_optional& ConeFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ConeFeatureMeasurementType::DiameterMax_optional& ConeFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ConeFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ConeFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ConeFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::HalfAngle_optional& ConeFeatureMeasurementType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConeFeatureMeasurementType::HalfAngle_optional& ConeFeatureMeasurementType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConeFeatureMeasurementType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConeFeatureMeasurementType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConeFeatureMeasurementType::
    HalfAngle (::std::unique_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::FullAngle_optional& ConeFeatureMeasurementType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConeFeatureMeasurementType::FullAngle_optional& ConeFeatureMeasurementType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConeFeatureMeasurementType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConeFeatureMeasurementType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConeFeatureMeasurementType::
    FullAngle (::std::unique_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::SmallEndDistance_optional& ConeFeatureMeasurementType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConeFeatureMeasurementType::SmallEndDistance_optional& ConeFeatureMeasurementType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConeFeatureMeasurementType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConeFeatureMeasurementType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConeFeatureMeasurementType::
    SmallEndDistance (::std::unique_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::LargeEndDistance_optional& ConeFeatureMeasurementType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConeFeatureMeasurementType::LargeEndDistance_optional& ConeFeatureMeasurementType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConeFeatureMeasurementType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConeFeatureMeasurementType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConeFeatureMeasurementType::
    LargeEndDistance (::std::unique_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::SweepMeasurementRange_optional& ConeFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    ConeFeatureMeasurementType::SweepMeasurementRange_optional& ConeFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void ConeFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void ConeFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void ConeFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::SweepFull_optional& ConeFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    ConeFeatureMeasurementType::SweepFull_optional& ConeFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void ConeFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void ConeFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void ConeFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }

    const ConeFeatureMeasurementType::Form_optional& ConeFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    ConeFeatureMeasurementType::Form_optional& ConeFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void ConeFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ConeFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ConeFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // ConicalSegmentConstructionMethodType
    //

    const ConicalSegmentConstructionMethodType::BestFit_optional& ConicalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ConicalSegmentConstructionMethodType::BestFit_optional& ConicalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const ConicalSegmentConstructionMethodType::Recompensated_optional& ConicalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ConicalSegmentConstructionMethodType::Recompensated_optional& ConicalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const ConicalSegmentConstructionMethodType::Copy_optional& ConicalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ConicalSegmentConstructionMethodType::Copy_optional& ConicalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ConicalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const ConicalSegmentConstructionMethodType::Cast_optional& ConicalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ConicalSegmentConstructionMethodType::Cast_optional& ConicalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ConicalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const ConicalSegmentConstructionMethodType::Transform_optional& ConicalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ConicalSegmentConstructionMethodType::Transform_optional& ConicalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ConicalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // ConicalSegmentBestFitType
    //

    const ConicalSegmentBestFitType::BaseFeature_sequence& ConicalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ConicalSegmentBestFitType::BaseFeature_sequence& ConicalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ConicalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const ConicalSegmentBestFitType::n_type& ConicalSegmentBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    ConicalSegmentBestFitType::n_type& ConicalSegmentBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void ConicalSegmentBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ConicalSegmentBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ConicalSegmentRecompType
    //

    const ConicalSegmentRecompType::BaseFeaturePointList_type& ConicalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ConicalSegmentRecompType::BaseFeaturePointList_type& ConicalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ConicalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ConicalSegmentRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // ConicalSegmentCopyType
    //

    const ConicalSegmentCopyType::BaseConicalSegment_type& ConicalSegmentCopyType::
    BaseConicalSegment () const
    {
      return this->BaseConicalSegment_.get ();
    }

    ConicalSegmentCopyType::BaseConicalSegment_type& ConicalSegmentCopyType::
    BaseConicalSegment ()
    {
      return this->BaseConicalSegment_.get ();
    }

    void ConicalSegmentCopyType::
    BaseConicalSegment (const BaseConicalSegment_type& x)
    {
      this->BaseConicalSegment_.set (x);
    }

    void ConicalSegmentCopyType::
    BaseConicalSegment (::std::unique_ptr< BaseConicalSegment_type > x)
    {
      this->BaseConicalSegment_.set (std::move (x));
    }


    // ConicalSegmentCastType
    //

    const ConicalSegmentCastType::BaseFeature_type& ConicalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ConicalSegmentCastType::BaseFeature_type& ConicalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ConicalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ConicalSegmentCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // ConicalSegmentTransformType
    //

    const ConicalSegmentTransformType::BaseConicalSegment_type& ConicalSegmentTransformType::
    BaseConicalSegment () const
    {
      return this->BaseConicalSegment_.get ();
    }

    ConicalSegmentTransformType::BaseConicalSegment_type& ConicalSegmentTransformType::
    BaseConicalSegment ()
    {
      return this->BaseConicalSegment_.get ();
    }

    void ConicalSegmentTransformType::
    BaseConicalSegment (const BaseConicalSegment_type& x)
    {
      this->BaseConicalSegment_.set (x);
    }

    void ConicalSegmentTransformType::
    BaseConicalSegment (::std::unique_ptr< BaseConicalSegment_type > x)
    {
      this->BaseConicalSegment_.set (std::move (x));
    }

    const ConicalSegmentTransformType::Transformation_type& ConicalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ConicalSegmentTransformType::Transformation_type& ConicalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ConicalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ConicalSegmentTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // ConicalSegmentCheckedType
    //

    const ConicalSegmentCheckedType::Measured_optional& ConicalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ConicalSegmentCheckedType::Measured_optional& ConicalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ConicalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ConicalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ConicalSegmentCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const ConicalSegmentCheckedType::Constructed_optional& ConicalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ConicalSegmentCheckedType::Constructed_optional& ConicalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ConicalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ConicalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ConicalSegmentCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ConicalSegmentCheckedFeatureType
    //

    const ConicalSegmentCheckedFeatureType::CheckDetails_optional& ConicalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ConicalSegmentCheckedFeatureType::CheckDetails_optional& ConicalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // ConicalSegmentMeasurementDeterminationType
    //

    const ConicalSegmentMeasurementDeterminationType::Checked_optional& ConicalSegmentMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ConicalSegmentMeasurementDeterminationType::Checked_optional& ConicalSegmentMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ConicalSegmentMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ConicalSegmentMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ConicalSegmentMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const ConicalSegmentMeasurementDeterminationType::Set_optional& ConicalSegmentMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ConicalSegmentMeasurementDeterminationType::Set_optional& ConicalSegmentMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ConicalSegmentMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ConicalSegmentMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ConicalSegmentMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // ConicalSegmentFeatureItemType
    //

    const ConicalSegmentFeatureItemType::DeterminationMode_type& ConicalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ConicalSegmentFeatureItemType::DeterminationMode_type& ConicalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ConicalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ConicalSegmentFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // ConicalSegmentFeatureDefinitionType
    //

    const ConicalSegmentFeatureDefinitionType::InternalExternal_type& ConicalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ConicalSegmentFeatureDefinitionType::InternalExternal_type& ConicalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ConicalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const ConicalSegmentFeatureDefinitionType::Diameter_type& ConicalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ConicalSegmentFeatureDefinitionType::Diameter_type& ConicalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ConicalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ConicalSegmentFeatureDefinitionType::HalfAngle_optional& ConicalSegmentFeatureDefinitionType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConicalSegmentFeatureDefinitionType::HalfAngle_optional& ConicalSegmentFeatureDefinitionType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (::std::unique_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (std::move (x));
    }

    const ConicalSegmentFeatureDefinitionType::FullAngle_optional& ConicalSegmentFeatureDefinitionType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConicalSegmentFeatureDefinitionType::FullAngle_optional& ConicalSegmentFeatureDefinitionType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (::std::unique_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (std::move (x));
    }

    const ConicalSegmentFeatureDefinitionType::LargeEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConicalSegmentFeatureDefinitionType::LargeEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (::std::unique_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (std::move (x));
    }

    const ConicalSegmentFeatureDefinitionType::SmallEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConicalSegmentFeatureDefinitionType::SmallEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (::std::unique_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (std::move (x));
    }


    // ConicalSegmentFeatureNominalType
    //

    const ConicalSegmentFeatureNominalType::Axis_type& ConicalSegmentFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ConicalSegmentFeatureNominalType::Axis_type& ConicalSegmentFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ConicalSegmentFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConicalSegmentFeatureNominalType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const ConicalSegmentFeatureNominalType::Sweep_type& ConicalSegmentFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    ConicalSegmentFeatureNominalType::Sweep_type& ConicalSegmentFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void ConicalSegmentFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConicalSegmentFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const ConicalSegmentFeatureNominalType::Constructed_optional& ConicalSegmentFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ConicalSegmentFeatureNominalType::Constructed_optional& ConicalSegmentFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ConicalSegmentFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ConicalSegmentFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ConicalSegmentFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ConicalSegmentFeatureMeasurementType
    //

    const ConicalSegmentFeatureMeasurementType::Axis_optional& ConicalSegmentFeatureMeasurementType::
    Axis () const
    {
      return this->Axis_;
    }

    ConicalSegmentFeatureMeasurementType::Axis_optional& ConicalSegmentFeatureMeasurementType::
    Axis ()
    {
      return this->Axis_;
    }

    void ConicalSegmentFeatureMeasurementType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::Diameter_optional& ConicalSegmentFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ConicalSegmentFeatureMeasurementType::Diameter_optional& ConicalSegmentFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ConicalSegmentFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::DiameterMin_optional& ConicalSegmentFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ConicalSegmentFeatureMeasurementType::DiameterMin_optional& ConicalSegmentFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ConicalSegmentFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::DiameterMax_optional& ConicalSegmentFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ConicalSegmentFeatureMeasurementType::DiameterMax_optional& ConicalSegmentFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ConicalSegmentFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::HalfAngle_optional& ConicalSegmentFeatureMeasurementType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConicalSegmentFeatureMeasurementType::HalfAngle_optional& ConicalSegmentFeatureMeasurementType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConicalSegmentFeatureMeasurementType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    HalfAngle (::std::unique_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::FullAngle_optional& ConicalSegmentFeatureMeasurementType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConicalSegmentFeatureMeasurementType::FullAngle_optional& ConicalSegmentFeatureMeasurementType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConicalSegmentFeatureMeasurementType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    FullAngle (::std::unique_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::SmallEndDistance_optional& ConicalSegmentFeatureMeasurementType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConicalSegmentFeatureMeasurementType::SmallEndDistance_optional& ConicalSegmentFeatureMeasurementType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConicalSegmentFeatureMeasurementType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    SmallEndDistance (::std::unique_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::LargeEndDistance_optional& ConicalSegmentFeatureMeasurementType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConicalSegmentFeatureMeasurementType::LargeEndDistance_optional& ConicalSegmentFeatureMeasurementType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConicalSegmentFeatureMeasurementType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    LargeEndDistance (::std::unique_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::SweepMeasurementRange_optional& ConicalSegmentFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    ConicalSegmentFeatureMeasurementType::SweepMeasurementRange_optional& ConicalSegmentFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void ConicalSegmentFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::SweepFull_optional& ConicalSegmentFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    ConicalSegmentFeatureMeasurementType::SweepFull_optional& ConicalSegmentFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void ConicalSegmentFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }

    const ConicalSegmentFeatureMeasurementType::Form_optional& ConicalSegmentFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    ConicalSegmentFeatureMeasurementType::Form_optional& ConicalSegmentFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void ConicalSegmentFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ConicalSegmentFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ConicalSegmentFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // CylinderConstructionMethodType
    //

    const CylinderConstructionMethodType::BestFit_optional& CylinderConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CylinderConstructionMethodType::BestFit_optional& CylinderConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CylinderConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CylinderConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CylinderConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const CylinderConstructionMethodType::Recompensated_optional& CylinderConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CylinderConstructionMethodType::Recompensated_optional& CylinderConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CylinderConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CylinderConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CylinderConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const CylinderConstructionMethodType::Copy_optional& CylinderConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CylinderConstructionMethodType::Copy_optional& CylinderConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CylinderConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CylinderConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CylinderConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const CylinderConstructionMethodType::Cast_optional& CylinderConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CylinderConstructionMethodType::Cast_optional& CylinderConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CylinderConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CylinderConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CylinderConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const CylinderConstructionMethodType::Transform_optional& CylinderConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CylinderConstructionMethodType::Transform_optional& CylinderConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CylinderConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CylinderConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CylinderConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const CylinderConstructionMethodType::FromScan_optional& CylinderConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    CylinderConstructionMethodType::FromScan_optional& CylinderConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void CylinderConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void CylinderConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void CylinderConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // CylinderBestFitType
    //

    const CylinderBestFitType::BaseFeature_sequence& CylinderBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CylinderBestFitType::BaseFeature_sequence& CylinderBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CylinderBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const CylinderBestFitType::n_type& CylinderBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    CylinderBestFitType::n_type& CylinderBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void CylinderBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CylinderBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // CylinderRecompType
    //

    const CylinderRecompType::BaseFeaturePointList_type& CylinderRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CylinderRecompType::BaseFeaturePointList_type& CylinderRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CylinderRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CylinderRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // CylinderCopyType
    //

    const CylinderCopyType::BaseCylinder_type& CylinderCopyType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    CylinderCopyType::BaseCylinder_type& CylinderCopyType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void CylinderCopyType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void CylinderCopyType::
    BaseCylinder (::std::unique_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (std::move (x));
    }


    // CylinderCastType
    //

    const CylinderCastType::BaseFeature_type& CylinderCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CylinderCastType::BaseFeature_type& CylinderCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CylinderCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CylinderCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // CylinderTransformType
    //

    const CylinderTransformType::BaseCylinder_type& CylinderTransformType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    CylinderTransformType::BaseCylinder_type& CylinderTransformType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void CylinderTransformType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void CylinderTransformType::
    BaseCylinder (::std::unique_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (std::move (x));
    }

    const CylinderTransformType::Transformation_type& CylinderTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CylinderTransformType::Transformation_type& CylinderTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CylinderTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CylinderTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // CylinderFromScanType
    //

    const CylinderFromScanType::SurfaceFeature_type& CylinderFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    CylinderFromScanType::SurfaceFeature_type& CylinderFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void CylinderFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void CylinderFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const CylinderFromScanType::SearchRadius_type& CylinderFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    CylinderFromScanType::SearchRadius_type& CylinderFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void CylinderFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void CylinderFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }


    // CylinderCheckedType
    //

    const CylinderCheckedType::Measured_optional& CylinderCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CylinderCheckedType::Measured_optional& CylinderCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CylinderCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CylinderCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CylinderCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const CylinderCheckedType::Constructed_optional& CylinderCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CylinderCheckedType::Constructed_optional& CylinderCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CylinderCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CylinderCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CylinderCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // CylinderCheckedFeatureType
    //

    const CylinderCheckedFeatureType::CheckDetails_optional& CylinderCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CylinderCheckedFeatureType::CheckDetails_optional& CylinderCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CylinderCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // CylinderMeasurementDeterminationType
    //

    const CylinderMeasurementDeterminationType::Checked_optional& CylinderMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CylinderMeasurementDeterminationType::Checked_optional& CylinderMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CylinderMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CylinderMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CylinderMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const CylinderMeasurementDeterminationType::Set_optional& CylinderMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CylinderMeasurementDeterminationType::Set_optional& CylinderMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CylinderMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CylinderMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CylinderMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // CylinderFeatureItemType
    //

    const CylinderFeatureItemType::DeterminationMode_type& CylinderFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CylinderFeatureItemType::DeterminationMode_type& CylinderFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CylinderFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CylinderFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // CylinderFeatureDefinitionType
    //

    const CylinderFeatureDefinitionType::InternalExternal_type& CylinderFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CylinderFeatureDefinitionType::InternalExternal_type& CylinderFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CylinderFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CylinderFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const CylinderFeatureDefinitionType::Diameter_type& CylinderFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CylinderFeatureDefinitionType::Diameter_type& CylinderFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CylinderFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const CylinderFeatureDefinitionType::Length_optional& CylinderFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    CylinderFeatureDefinitionType::Length_optional& CylinderFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void CylinderFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylinderFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const CylinderFeatureDefinitionType::Bottom_optional& CylinderFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    CylinderFeatureDefinitionType::Bottom_optional& CylinderFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void CylinderFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void CylinderFeatureDefinitionType::
    Bottom (::std::unique_ptr< Bottom_type > x)
    {
      this->Bottom_.set (std::move (x));
    }


    // CylinderFeatureNominalType
    //

    const CylinderFeatureNominalType::Axis_type& CylinderFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    CylinderFeatureNominalType::Axis_type& CylinderFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void CylinderFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylinderFeatureNominalType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const CylinderFeatureNominalType::Sweep_optional& CylinderFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    CylinderFeatureNominalType::Sweep_optional& CylinderFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void CylinderFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylinderFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void CylinderFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const CylinderFeatureNominalType::Constructed_optional& CylinderFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CylinderFeatureNominalType::Constructed_optional& CylinderFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CylinderFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CylinderFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CylinderFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // CylinderFeatureMeasurementType
    //

    const CylinderFeatureMeasurementType::Axis_optional& CylinderFeatureMeasurementType::
    Axis () const
    {
      return this->Axis_;
    }

    CylinderFeatureMeasurementType::Axis_optional& CylinderFeatureMeasurementType::
    Axis ()
    {
      return this->Axis_;
    }

    void CylinderFeatureMeasurementType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylinderFeatureMeasurementType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void CylinderFeatureMeasurementType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const CylinderFeatureMeasurementType::Diameter_optional& CylinderFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CylinderFeatureMeasurementType::Diameter_optional& CylinderFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CylinderFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylinderFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CylinderFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const CylinderFeatureMeasurementType::Length_optional& CylinderFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    CylinderFeatureMeasurementType::Length_optional& CylinderFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void CylinderFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylinderFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylinderFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const CylinderFeatureMeasurementType::DiameterMin_optional& CylinderFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CylinderFeatureMeasurementType::DiameterMin_optional& CylinderFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CylinderFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CylinderFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CylinderFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const CylinderFeatureMeasurementType::DiameterMax_optional& CylinderFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CylinderFeatureMeasurementType::DiameterMax_optional& CylinderFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CylinderFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CylinderFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CylinderFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const CylinderFeatureMeasurementType::SweepMeasurementRange_optional& CylinderFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    CylinderFeatureMeasurementType::SweepMeasurementRange_optional& CylinderFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void CylinderFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void CylinderFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void CylinderFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const CylinderFeatureMeasurementType::SweepFull_optional& CylinderFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    CylinderFeatureMeasurementType::SweepFull_optional& CylinderFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void CylinderFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void CylinderFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void CylinderFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }

    const CylinderFeatureMeasurementType::Form_optional& CylinderFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    CylinderFeatureMeasurementType::Form_optional& CylinderFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void CylinderFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CylinderFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CylinderFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // CylindricalSegmentConstructionMethodType
    //

    const CylindricalSegmentConstructionMethodType::BestFit_optional& CylindricalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CylindricalSegmentConstructionMethodType::BestFit_optional& CylindricalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const CylindricalSegmentConstructionMethodType::Recompensated_optional& CylindricalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CylindricalSegmentConstructionMethodType::Recompensated_optional& CylindricalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const CylindricalSegmentConstructionMethodType::Copy_optional& CylindricalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CylindricalSegmentConstructionMethodType::Copy_optional& CylindricalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const CylindricalSegmentConstructionMethodType::Cast_optional& CylindricalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CylindricalSegmentConstructionMethodType::Cast_optional& CylindricalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const CylindricalSegmentConstructionMethodType::Transform_optional& CylindricalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CylindricalSegmentConstructionMethodType::Transform_optional& CylindricalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // CylindricalSegmentBestFitType
    //

    const CylindricalSegmentBestFitType::BaseFeature_sequence& CylindricalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CylindricalSegmentBestFitType::BaseFeature_sequence& CylindricalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CylindricalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const CylindricalSegmentBestFitType::n_type& CylindricalSegmentBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    CylindricalSegmentBestFitType::n_type& CylindricalSegmentBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void CylindricalSegmentBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CylindricalSegmentBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // CylindricalSegmentRecompType
    //

    const CylindricalSegmentRecompType::BaseFeaturePointList_type& CylindricalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CylindricalSegmentRecompType::BaseFeaturePointList_type& CylindricalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CylindricalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CylindricalSegmentRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // CylindricalSegmentCopyType
    //

    const CylindricalSegmentCopyType::BaseCylindricalSegment_type& CylindricalSegmentCopyType::
    BaseCylindricalSegment () const
    {
      return this->BaseCylindricalSegment_.get ();
    }

    CylindricalSegmentCopyType::BaseCylindricalSegment_type& CylindricalSegmentCopyType::
    BaseCylindricalSegment ()
    {
      return this->BaseCylindricalSegment_.get ();
    }

    void CylindricalSegmentCopyType::
    BaseCylindricalSegment (const BaseCylindricalSegment_type& x)
    {
      this->BaseCylindricalSegment_.set (x);
    }

    void CylindricalSegmentCopyType::
    BaseCylindricalSegment (::std::unique_ptr< BaseCylindricalSegment_type > x)
    {
      this->BaseCylindricalSegment_.set (std::move (x));
    }


    // CylindricalSegmentCastType
    //

    const CylindricalSegmentCastType::BaseFeature_type& CylindricalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CylindricalSegmentCastType::BaseFeature_type& CylindricalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CylindricalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CylindricalSegmentCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // CylindricalSegmentTransformType
    //

    const CylindricalSegmentTransformType::BaseCylindricalSegment_type& CylindricalSegmentTransformType::
    BaseCylindricalSegment () const
    {
      return this->BaseCylindricalSegment_.get ();
    }

    CylindricalSegmentTransformType::BaseCylindricalSegment_type& CylindricalSegmentTransformType::
    BaseCylindricalSegment ()
    {
      return this->BaseCylindricalSegment_.get ();
    }

    void CylindricalSegmentTransformType::
    BaseCylindricalSegment (const BaseCylindricalSegment_type& x)
    {
      this->BaseCylindricalSegment_.set (x);
    }

    void CylindricalSegmentTransformType::
    BaseCylindricalSegment (::std::unique_ptr< BaseCylindricalSegment_type > x)
    {
      this->BaseCylindricalSegment_.set (std::move (x));
    }

    const CylindricalSegmentTransformType::Transformation_type& CylindricalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CylindricalSegmentTransformType::Transformation_type& CylindricalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CylindricalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CylindricalSegmentTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // CylindricalSegmentCheckedType
    //

    const CylindricalSegmentCheckedType::Measured_optional& CylindricalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CylindricalSegmentCheckedType::Measured_optional& CylindricalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CylindricalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CylindricalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CylindricalSegmentCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const CylindricalSegmentCheckedType::Constructed_optional& CylindricalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CylindricalSegmentCheckedType::Constructed_optional& CylindricalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CylindricalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CylindricalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CylindricalSegmentCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // CylindricalSegmentCheckedFeatureType
    //

    const CylindricalSegmentCheckedFeatureType::CheckDetails_optional& CylindricalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CylindricalSegmentCheckedFeatureType::CheckDetails_optional& CylindricalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // CylindricalSegmentMeasurementDeterminationType
    //

    const CylindricalSegmentMeasurementDeterminationType::Checked_optional& CylindricalSegmentMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CylindricalSegmentMeasurementDeterminationType::Checked_optional& CylindricalSegmentMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CylindricalSegmentMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CylindricalSegmentMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CylindricalSegmentMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const CylindricalSegmentMeasurementDeterminationType::Set_optional& CylindricalSegmentMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CylindricalSegmentMeasurementDeterminationType::Set_optional& CylindricalSegmentMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CylindricalSegmentMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CylindricalSegmentMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CylindricalSegmentMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // CylindricalSegmentFeatureItemType
    //

    const CylindricalSegmentFeatureItemType::DeterminationMode_type& CylindricalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CylindricalSegmentFeatureItemType::DeterminationMode_type& CylindricalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CylindricalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CylindricalSegmentFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // CylindricalSegmentFeatureDefinitionType
    //

    const CylindricalSegmentFeatureDefinitionType::InternalExternal_type& CylindricalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CylindricalSegmentFeatureDefinitionType::InternalExternal_type& CylindricalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CylindricalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const CylindricalSegmentFeatureDefinitionType::Diameter_type& CylindricalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CylindricalSegmentFeatureDefinitionType::Diameter_type& CylindricalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CylindricalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const CylindricalSegmentFeatureDefinitionType::Length_optional& CylindricalSegmentFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    CylindricalSegmentFeatureDefinitionType::Length_optional& CylindricalSegmentFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const CylindricalSegmentFeatureDefinitionType::Bottom_optional& CylindricalSegmentFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    CylindricalSegmentFeatureDefinitionType::Bottom_optional& CylindricalSegmentFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (::std::unique_ptr< Bottom_type > x)
    {
      this->Bottom_.set (std::move (x));
    }


    // CylindricalSegmentFeatureNominalType
    //

    const CylindricalSegmentFeatureNominalType::Axis_type& CylindricalSegmentFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    CylindricalSegmentFeatureNominalType::Axis_type& CylindricalSegmentFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void CylindricalSegmentFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylindricalSegmentFeatureNominalType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const CylindricalSegmentFeatureNominalType::Sweep_type& CylindricalSegmentFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    CylindricalSegmentFeatureNominalType::Sweep_type& CylindricalSegmentFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void CylindricalSegmentFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylindricalSegmentFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const CylindricalSegmentFeatureNominalType::Constructed_optional& CylindricalSegmentFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CylindricalSegmentFeatureNominalType::Constructed_optional& CylindricalSegmentFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CylindricalSegmentFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CylindricalSegmentFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CylindricalSegmentFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // CylindricalSegmentFeatureMeasurementType
    //

    const CylindricalSegmentFeatureMeasurementType::Axis_optional& CylindricalSegmentFeatureMeasurementType::
    Axis () const
    {
      return this->Axis_;
    }

    CylindricalSegmentFeatureMeasurementType::Axis_optional& CylindricalSegmentFeatureMeasurementType::
    Axis ()
    {
      return this->Axis_;
    }

    void CylindricalSegmentFeatureMeasurementType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylindricalSegmentFeatureMeasurementType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void CylindricalSegmentFeatureMeasurementType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const CylindricalSegmentFeatureMeasurementType::Diameter_optional& CylindricalSegmentFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CylindricalSegmentFeatureMeasurementType::Diameter_optional& CylindricalSegmentFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CylindricalSegmentFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylindricalSegmentFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CylindricalSegmentFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const CylindricalSegmentFeatureMeasurementType::Length_optional& CylindricalSegmentFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    CylindricalSegmentFeatureMeasurementType::Length_optional& CylindricalSegmentFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void CylindricalSegmentFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylindricalSegmentFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylindricalSegmentFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const CylindricalSegmentFeatureMeasurementType::DiameterMin_optional& CylindricalSegmentFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CylindricalSegmentFeatureMeasurementType::DiameterMin_optional& CylindricalSegmentFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CylindricalSegmentFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CylindricalSegmentFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CylindricalSegmentFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const CylindricalSegmentFeatureMeasurementType::DiameterMax_optional& CylindricalSegmentFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CylindricalSegmentFeatureMeasurementType::DiameterMax_optional& CylindricalSegmentFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CylindricalSegmentFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CylindricalSegmentFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CylindricalSegmentFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const CylindricalSegmentFeatureMeasurementType::SweepMeasurementRange_optional& CylindricalSegmentFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    CylindricalSegmentFeatureMeasurementType::SweepMeasurementRange_optional& CylindricalSegmentFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void CylindricalSegmentFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void CylindricalSegmentFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void CylindricalSegmentFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const CylindricalSegmentFeatureMeasurementType::SweepFull_optional& CylindricalSegmentFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    CylindricalSegmentFeatureMeasurementType::SweepFull_optional& CylindricalSegmentFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void CylindricalSegmentFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void CylindricalSegmentFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void CylindricalSegmentFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }

    const CylindricalSegmentFeatureMeasurementType::Form_optional& CylindricalSegmentFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    CylindricalSegmentFeatureMeasurementType::Form_optional& CylindricalSegmentFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void CylindricalSegmentFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CylindricalSegmentFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CylindricalSegmentFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // EdgePointConstructionMethodType
    //

    const EdgePointConstructionMethodType::Copy_optional& EdgePointConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    EdgePointConstructionMethodType::Copy_optional& EdgePointConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void EdgePointConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void EdgePointConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void EdgePointConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const EdgePointConstructionMethodType::Cast_optional& EdgePointConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    EdgePointConstructionMethodType::Cast_optional& EdgePointConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void EdgePointConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void EdgePointConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void EdgePointConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const EdgePointConstructionMethodType::Transform_optional& EdgePointConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    EdgePointConstructionMethodType::Transform_optional& EdgePointConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void EdgePointConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void EdgePointConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void EdgePointConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const EdgePointConstructionMethodType::FromScan_optional& EdgePointConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    EdgePointConstructionMethodType::FromScan_optional& EdgePointConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void EdgePointConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void EdgePointConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void EdgePointConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // EdgePointCopyType
    //

    const EdgePointCopyType::BaseEdgePoint_type& EdgePointCopyType::
    BaseEdgePoint () const
    {
      return this->BaseEdgePoint_.get ();
    }

    EdgePointCopyType::BaseEdgePoint_type& EdgePointCopyType::
    BaseEdgePoint ()
    {
      return this->BaseEdgePoint_.get ();
    }

    void EdgePointCopyType::
    BaseEdgePoint (const BaseEdgePoint_type& x)
    {
      this->BaseEdgePoint_.set (x);
    }

    void EdgePointCopyType::
    BaseEdgePoint (::std::unique_ptr< BaseEdgePoint_type > x)
    {
      this->BaseEdgePoint_.set (std::move (x));
    }


    // EdgePointCastType
    //

    const EdgePointCastType::BaseFeature_type& EdgePointCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    EdgePointCastType::BaseFeature_type& EdgePointCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void EdgePointCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void EdgePointCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // EdgePointTransformType
    //

    const EdgePointTransformType::BaseEdgePoint_type& EdgePointTransformType::
    BaseEdgePoint () const
    {
      return this->BaseEdgePoint_.get ();
    }

    EdgePointTransformType::BaseEdgePoint_type& EdgePointTransformType::
    BaseEdgePoint ()
    {
      return this->BaseEdgePoint_.get ();
    }

    void EdgePointTransformType::
    BaseEdgePoint (const BaseEdgePoint_type& x)
    {
      this->BaseEdgePoint_.set (x);
    }

    void EdgePointTransformType::
    BaseEdgePoint (::std::unique_ptr< BaseEdgePoint_type > x)
    {
      this->BaseEdgePoint_.set (std::move (x));
    }

    const EdgePointTransformType::Transformation_type& EdgePointTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    EdgePointTransformType::Transformation_type& EdgePointTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void EdgePointTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void EdgePointTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // EdgePointFromScanType
    //

    const EdgePointFromScanType::SurfaceFeature_type& EdgePointFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    EdgePointFromScanType::SurfaceFeature_type& EdgePointFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void EdgePointFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void EdgePointFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const EdgePointFromScanType::SearchRadius_type& EdgePointFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    EdgePointFromScanType::SearchRadius_type& EdgePointFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void EdgePointFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void EdgePointFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const EdgePointFromScanType::PatchRadius_type& EdgePointFromScanType::
    PatchRadius () const
    {
      return this->PatchRadius_.get ();
    }

    EdgePointFromScanType::PatchRadius_type& EdgePointFromScanType::
    PatchRadius ()
    {
      return this->PatchRadius_.get ();
    }

    void EdgePointFromScanType::
    PatchRadius (const PatchRadius_type& x)
    {
      this->PatchRadius_.set (x);
    }

    void EdgePointFromScanType::
    PatchRadius (::std::unique_ptr< PatchRadius_type > x)
    {
      this->PatchRadius_.set (std::move (x));
    }

    const EdgePointFromScanType::Distance_type& EdgePointFromScanType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    EdgePointFromScanType::Distance_type& EdgePointFromScanType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void EdgePointFromScanType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void EdgePointFromScanType::
    Distance (::std::unique_ptr< Distance_type > x)
    {
      this->Distance_.set (std::move (x));
    }

    const EdgePointFromScanType::Depth_type& EdgePointFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    EdgePointFromScanType::Depth_type& EdgePointFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void EdgePointFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void EdgePointFromScanType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }

    const EdgePointFromScanType::RetrievalMethod_type& EdgePointFromScanType::
    RetrievalMethod () const
    {
      return this->RetrievalMethod_.get ();
    }

    EdgePointFromScanType::RetrievalMethod_type& EdgePointFromScanType::
    RetrievalMethod ()
    {
      return this->RetrievalMethod_.get ();
    }

    void EdgePointFromScanType::
    RetrievalMethod (const RetrievalMethod_type& x)
    {
      this->RetrievalMethod_.set (x);
    }

    void EdgePointFromScanType::
    RetrievalMethod (::std::unique_ptr< RetrievalMethod_type > x)
    {
      this->RetrievalMethod_.set (std::move (x));
    }


    // EdgePointCheckedType
    //

    const EdgePointCheckedType::Measured_optional& EdgePointCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    EdgePointCheckedType::Measured_optional& EdgePointCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void EdgePointCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void EdgePointCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void EdgePointCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const EdgePointCheckedType::Constructed_optional& EdgePointCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EdgePointCheckedType::Constructed_optional& EdgePointCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EdgePointCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EdgePointCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EdgePointCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // EdgePointCheckedFeatureType
    //

    const EdgePointCheckedFeatureType::CheckDetails_optional& EdgePointCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    EdgePointCheckedFeatureType::CheckDetails_optional& EdgePointCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // EdgePointMeasurementDeterminationType
    //

    const EdgePointMeasurementDeterminationType::Checked_optional& EdgePointMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    EdgePointMeasurementDeterminationType::Checked_optional& EdgePointMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void EdgePointMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void EdgePointMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void EdgePointMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const EdgePointMeasurementDeterminationType::Set_optional& EdgePointMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    EdgePointMeasurementDeterminationType::Set_optional& EdgePointMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void EdgePointMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void EdgePointMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void EdgePointMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // EdgePointFeatureItemType
    //

    const EdgePointFeatureItemType::DeterminationMode_type& EdgePointFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    EdgePointFeatureItemType::DeterminationMode_type& EdgePointFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void EdgePointFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void EdgePointFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // EdgePointFeatureDefinitionType
    //

    const EdgePointFeatureDefinitionType::InternalExternal_type& EdgePointFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    EdgePointFeatureDefinitionType::InternalExternal_type& EdgePointFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void EdgePointFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void EdgePointFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }


    // EdgePointFeatureNominalType
    //

    const EdgePointFeatureNominalType::Location_type& EdgePointFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    EdgePointFeatureNominalType::Location_type& EdgePointFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void EdgePointFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void EdgePointFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const EdgePointFeatureNominalType::Normal_type& EdgePointFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    EdgePointFeatureNominalType::Normal_type& EdgePointFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void EdgePointFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EdgePointFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const EdgePointFeatureNominalType::AdjacentNormal_optional& EdgePointFeatureNominalType::
    AdjacentNormal () const
    {
      return this->AdjacentNormal_;
    }

    EdgePointFeatureNominalType::AdjacentNormal_optional& EdgePointFeatureNominalType::
    AdjacentNormal ()
    {
      return this->AdjacentNormal_;
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (const AdjacentNormal_type& x)
    {
      this->AdjacentNormal_.set (x);
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (const AdjacentNormal_optional& x)
    {
      this->AdjacentNormal_ = x;
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (::std::unique_ptr< AdjacentNormal_type > x)
    {
      this->AdjacentNormal_.set (std::move (x));
    }

    const EdgePointFeatureNominalType::Constructed_optional& EdgePointFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EdgePointFeatureNominalType::Constructed_optional& EdgePointFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EdgePointFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EdgePointFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EdgePointFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // EdgePointFeatureMeasurementType
    //

    const EdgePointFeatureMeasurementType::Location_optional& EdgePointFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    EdgePointFeatureMeasurementType::Location_optional& EdgePointFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void EdgePointFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void EdgePointFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void EdgePointFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const EdgePointFeatureMeasurementType::Normal_optional& EdgePointFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    EdgePointFeatureMeasurementType::Normal_optional& EdgePointFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void EdgePointFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EdgePointFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void EdgePointFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const EdgePointFeatureMeasurementType::AdjacentNormal_optional& EdgePointFeatureMeasurementType::
    AdjacentNormal () const
    {
      return this->AdjacentNormal_;
    }

    EdgePointFeatureMeasurementType::AdjacentNormal_optional& EdgePointFeatureMeasurementType::
    AdjacentNormal ()
    {
      return this->AdjacentNormal_;
    }

    void EdgePointFeatureMeasurementType::
    AdjacentNormal (const AdjacentNormal_type& x)
    {
      this->AdjacentNormal_.set (x);
    }

    void EdgePointFeatureMeasurementType::
    AdjacentNormal (const AdjacentNormal_optional& x)
    {
      this->AdjacentNormal_ = x;
    }

    void EdgePointFeatureMeasurementType::
    AdjacentNormal (::std::unique_ptr< AdjacentNormal_type > x)
    {
      this->AdjacentNormal_.set (std::move (x));
    }


    // EllipseConstructionMethodType
    //

    const EllipseConstructionMethodType::BestFit_optional& EllipseConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    EllipseConstructionMethodType::BestFit_optional& EllipseConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void EllipseConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void EllipseConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void EllipseConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const EllipseConstructionMethodType::Recompensated_optional& EllipseConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    EllipseConstructionMethodType::Recompensated_optional& EllipseConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void EllipseConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void EllipseConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void EllipseConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const EllipseConstructionMethodType::Intersection_optional& EllipseConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    EllipseConstructionMethodType::Intersection_optional& EllipseConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void EllipseConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void EllipseConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void EllipseConstructionMethodType::
    Intersection (::std::unique_ptr< Intersection_type > x)
    {
      this->Intersection_.set (std::move (x));
    }

    const EllipseConstructionMethodType::Projection_optional& EllipseConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    EllipseConstructionMethodType::Projection_optional& EllipseConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void EllipseConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void EllipseConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void EllipseConstructionMethodType::
    Projection (::std::unique_ptr< Projection_type > x)
    {
      this->Projection_.set (std::move (x));
    }

    const EllipseConstructionMethodType::Copy_optional& EllipseConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    EllipseConstructionMethodType::Copy_optional& EllipseConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void EllipseConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void EllipseConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void EllipseConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const EllipseConstructionMethodType::Cast_optional& EllipseConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    EllipseConstructionMethodType::Cast_optional& EllipseConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void EllipseConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void EllipseConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void EllipseConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const EllipseConstructionMethodType::Transform_optional& EllipseConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    EllipseConstructionMethodType::Transform_optional& EllipseConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void EllipseConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void EllipseConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void EllipseConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const EllipseConstructionMethodType::FromScan_optional& EllipseConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    EllipseConstructionMethodType::FromScan_optional& EllipseConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void EllipseConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void EllipseConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void EllipseConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // EllipseBestFitType
    //

    const EllipseBestFitType::BaseFeature_sequence& EllipseBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    EllipseBestFitType::BaseFeature_sequence& EllipseBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void EllipseBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const EllipseBestFitType::n_type& EllipseBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    EllipseBestFitType::n_type& EllipseBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void EllipseBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void EllipseBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // EllipseRecompType
    //

    const EllipseRecompType::BaseFeaturePointList_type& EllipseRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    EllipseRecompType::BaseFeaturePointList_type& EllipseRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void EllipseRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void EllipseRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // EllipseProjectionType
    //

    const EllipseProjectionType::ProjectionFeature_type& EllipseProjectionType::
    ProjectionFeature () const
    {
      return this->ProjectionFeature_.get ();
    }

    EllipseProjectionType::ProjectionFeature_type& EllipseProjectionType::
    ProjectionFeature ()
    {
      return this->ProjectionFeature_.get ();
    }

    void EllipseProjectionType::
    ProjectionFeature (const ProjectionFeature_type& x)
    {
      this->ProjectionFeature_.set (x);
    }

    void EllipseProjectionType::
    ProjectionFeature (::std::unique_ptr< ProjectionFeature_type > x)
    {
      this->ProjectionFeature_.set (std::move (x));
    }

    const EllipseProjectionType::ProjectionPlane_type& EllipseProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    EllipseProjectionType::ProjectionPlane_type& EllipseProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void EllipseProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void EllipseProjectionType::
    ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (std::move (x));
    }


    // EllipseIntersectionType
    //

    const EllipseIntersectionType::IntersectionPlane_type& EllipseIntersectionType::
    IntersectionPlane () const
    {
      return this->IntersectionPlane_.get ();
    }

    EllipseIntersectionType::IntersectionPlane_type& EllipseIntersectionType::
    IntersectionPlane ()
    {
      return this->IntersectionPlane_.get ();
    }

    void EllipseIntersectionType::
    IntersectionPlane (const IntersectionPlane_type& x)
    {
      this->IntersectionPlane_.set (x);
    }

    void EllipseIntersectionType::
    IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > x)
    {
      this->IntersectionPlane_.set (std::move (x));
    }

    const EllipseIntersectionType::IntersectionFeature_type& EllipseIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_.get ();
    }

    EllipseIntersectionType::IntersectionFeature_type& EllipseIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_.get ();
    }

    void EllipseIntersectionType::
    IntersectionFeature (const IntersectionFeature_type& x)
    {
      this->IntersectionFeature_.set (x);
    }

    void EllipseIntersectionType::
    IntersectionFeature (::std::unique_ptr< IntersectionFeature_type > x)
    {
      this->IntersectionFeature_.set (std::move (x));
    }


    // EllipseCopyType
    //

    const EllipseCopyType::BaseEllipse_type& EllipseCopyType::
    BaseEllipse () const
    {
      return this->BaseEllipse_.get ();
    }

    EllipseCopyType::BaseEllipse_type& EllipseCopyType::
    BaseEllipse ()
    {
      return this->BaseEllipse_.get ();
    }

    void EllipseCopyType::
    BaseEllipse (const BaseEllipse_type& x)
    {
      this->BaseEllipse_.set (x);
    }

    void EllipseCopyType::
    BaseEllipse (::std::unique_ptr< BaseEllipse_type > x)
    {
      this->BaseEllipse_.set (std::move (x));
    }


    // EllipseCastType
    //

    const EllipseCastType::BaseFeature_type& EllipseCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    EllipseCastType::BaseFeature_type& EllipseCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void EllipseCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void EllipseCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // EllipseTransformType
    //

    const EllipseTransformType::BaseEllipse_type& EllipseTransformType::
    BaseEllipse () const
    {
      return this->BaseEllipse_.get ();
    }

    EllipseTransformType::BaseEllipse_type& EllipseTransformType::
    BaseEllipse ()
    {
      return this->BaseEllipse_.get ();
    }

    void EllipseTransformType::
    BaseEllipse (const BaseEllipse_type& x)
    {
      this->BaseEllipse_.set (x);
    }

    void EllipseTransformType::
    BaseEllipse (::std::unique_ptr< BaseEllipse_type > x)
    {
      this->BaseEllipse_.set (std::move (x));
    }

    const EllipseTransformType::Transformation_type& EllipseTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    EllipseTransformType::Transformation_type& EllipseTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void EllipseTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void EllipseTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // EllipseFromScanType
    //

    const EllipseFromScanType::SurfaceFeature_type& EllipseFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    EllipseFromScanType::SurfaceFeature_type& EllipseFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void EllipseFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void EllipseFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const EllipseFromScanType::SearchRadius_type& EllipseFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    EllipseFromScanType::SearchRadius_type& EllipseFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void EllipseFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void EllipseFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const EllipseFromScanType::Depth_type& EllipseFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    EllipseFromScanType::Depth_type& EllipseFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void EllipseFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void EllipseFromScanType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }


    // EllipseCheckedType
    //

    const EllipseCheckedType::Measured_optional& EllipseCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    EllipseCheckedType::Measured_optional& EllipseCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void EllipseCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void EllipseCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void EllipseCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const EllipseCheckedType::Constructed_optional& EllipseCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EllipseCheckedType::Constructed_optional& EllipseCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EllipseCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EllipseCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EllipseCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // EllipseCheckedFeatureType
    //

    const EllipseCheckedFeatureType::CheckDetails_optional& EllipseCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    EllipseCheckedFeatureType::CheckDetails_optional& EllipseCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void EllipseCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void EllipseCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void EllipseCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // EllipseMeasurementDeterminationType
    //

    const EllipseMeasurementDeterminationType::Checked_optional& EllipseMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    EllipseMeasurementDeterminationType::Checked_optional& EllipseMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void EllipseMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void EllipseMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void EllipseMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const EllipseMeasurementDeterminationType::Set_optional& EllipseMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    EllipseMeasurementDeterminationType::Set_optional& EllipseMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void EllipseMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void EllipseMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void EllipseMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // EllipseFeatureItemType
    //

    const EllipseFeatureItemType::DeterminationMode_type& EllipseFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    EllipseFeatureItemType::DeterminationMode_type& EllipseFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void EllipseFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void EllipseFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // EllipseFeatureDefinitionType
    //

    const EllipseFeatureDefinitionType::InternalExternal_type& EllipseFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    EllipseFeatureDefinitionType::InternalExternal_type& EllipseFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void EllipseFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void EllipseFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const EllipseFeatureDefinitionType::MajorDiameter_type& EllipseFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    EllipseFeatureDefinitionType::MajorDiameter_type& EllipseFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void EllipseFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void EllipseFeatureDefinitionType::
    MajorDiameter (::std::unique_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (std::move (x));
    }

    const EllipseFeatureDefinitionType::MinorDiameter_type& EllipseFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    EllipseFeatureDefinitionType::MinorDiameter_type& EllipseFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void EllipseFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void EllipseFeatureDefinitionType::
    MinorDiameter (::std::unique_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (std::move (x));
    }


    // EllipseFeatureNominalType
    //

    const EllipseFeatureNominalType::Axis_type& EllipseFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    EllipseFeatureNominalType::Axis_type& EllipseFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void EllipseFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void EllipseFeatureNominalType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const EllipseFeatureNominalType::Normal_type& EllipseFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    EllipseFeatureNominalType::Normal_type& EllipseFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void EllipseFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EllipseFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const EllipseFeatureNominalType::Sweep_optional& EllipseFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    EllipseFeatureNominalType::Sweep_optional& EllipseFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void EllipseFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void EllipseFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void EllipseFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const EllipseFeatureNominalType::Constructed_optional& EllipseFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EllipseFeatureNominalType::Constructed_optional& EllipseFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EllipseFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EllipseFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EllipseFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // EllipseFeatureMeasurementType
    //

    const EllipseFeatureMeasurementType::Axis_optional& EllipseFeatureMeasurementType::
    Axis () const
    {
      return this->Axis_;
    }

    EllipseFeatureMeasurementType::Axis_optional& EllipseFeatureMeasurementType::
    Axis ()
    {
      return this->Axis_;
    }

    void EllipseFeatureMeasurementType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void EllipseFeatureMeasurementType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void EllipseFeatureMeasurementType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const EllipseFeatureMeasurementType::Normal_optional& EllipseFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    EllipseFeatureMeasurementType::Normal_optional& EllipseFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void EllipseFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EllipseFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void EllipseFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const EllipseFeatureMeasurementType::SweepMeasurementRange_optional& EllipseFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    EllipseFeatureMeasurementType::SweepMeasurementRange_optional& EllipseFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void EllipseFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void EllipseFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void EllipseFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const EllipseFeatureMeasurementType::SweepFull_optional& EllipseFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    EllipseFeatureMeasurementType::SweepFull_optional& EllipseFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void EllipseFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void EllipseFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void EllipseFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }

    const EllipseFeatureMeasurementType::MajorDiameter_optional& EllipseFeatureMeasurementType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    EllipseFeatureMeasurementType::MajorDiameter_optional& EllipseFeatureMeasurementType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void EllipseFeatureMeasurementType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void EllipseFeatureMeasurementType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void EllipseFeatureMeasurementType::
    MajorDiameter (::std::unique_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (std::move (x));
    }

    const EllipseFeatureMeasurementType::MinorDiameter_optional& EllipseFeatureMeasurementType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    EllipseFeatureMeasurementType::MinorDiameter_optional& EllipseFeatureMeasurementType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void EllipseFeatureMeasurementType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void EllipseFeatureMeasurementType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void EllipseFeatureMeasurementType::
    MinorDiameter (::std::unique_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (std::move (x));
    }

    const EllipseFeatureMeasurementType::Form_optional& EllipseFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    EllipseFeatureMeasurementType::Form_optional& EllipseFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void EllipseFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void EllipseFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void EllipseFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // EllipticalArcConstructionMethodType
    //

    const EllipticalArcConstructionMethodType::BestFit_optional& EllipticalArcConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    EllipticalArcConstructionMethodType::BestFit_optional& EllipticalArcConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void EllipticalArcConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void EllipticalArcConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void EllipticalArcConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const EllipticalArcConstructionMethodType::Recompensated_optional& EllipticalArcConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    EllipticalArcConstructionMethodType::Recompensated_optional& EllipticalArcConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void EllipticalArcConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void EllipticalArcConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void EllipticalArcConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const EllipticalArcConstructionMethodType::Intersection_optional& EllipticalArcConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    EllipticalArcConstructionMethodType::Intersection_optional& EllipticalArcConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void EllipticalArcConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void EllipticalArcConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void EllipticalArcConstructionMethodType::
    Intersection (::std::unique_ptr< Intersection_type > x)
    {
      this->Intersection_.set (std::move (x));
    }

    const EllipticalArcConstructionMethodType::Projection_optional& EllipticalArcConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    EllipticalArcConstructionMethodType::Projection_optional& EllipticalArcConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void EllipticalArcConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void EllipticalArcConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void EllipticalArcConstructionMethodType::
    Projection (::std::unique_ptr< Projection_type > x)
    {
      this->Projection_.set (std::move (x));
    }

    const EllipticalArcConstructionMethodType::Copy_optional& EllipticalArcConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    EllipticalArcConstructionMethodType::Copy_optional& EllipticalArcConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void EllipticalArcConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void EllipticalArcConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void EllipticalArcConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const EllipticalArcConstructionMethodType::Cast_optional& EllipticalArcConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    EllipticalArcConstructionMethodType::Cast_optional& EllipticalArcConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void EllipticalArcConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void EllipticalArcConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void EllipticalArcConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const EllipticalArcConstructionMethodType::Transform_optional& EllipticalArcConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    EllipticalArcConstructionMethodType::Transform_optional& EllipticalArcConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void EllipticalArcConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void EllipticalArcConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void EllipticalArcConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const EllipticalArcConstructionMethodType::FromScan_optional& EllipticalArcConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    EllipticalArcConstructionMethodType::FromScan_optional& EllipticalArcConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void EllipticalArcConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void EllipticalArcConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void EllipticalArcConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // EllipticalArcBestFitType
    //

    const EllipticalArcBestFitType::BaseFeature_sequence& EllipticalArcBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    EllipticalArcBestFitType::BaseFeature_sequence& EllipticalArcBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void EllipticalArcBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const EllipticalArcBestFitType::n_type& EllipticalArcBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    EllipticalArcBestFitType::n_type& EllipticalArcBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void EllipticalArcBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void EllipticalArcBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // EllipticalArcRecompType
    //

    const EllipticalArcRecompType::BaseFeaturePointList_type& EllipticalArcRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    EllipticalArcRecompType::BaseFeaturePointList_type& EllipticalArcRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void EllipticalArcRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void EllipticalArcRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // EllipticalArcProjectionType
    //

    const EllipticalArcProjectionType::ProjectionFeature_type& EllipticalArcProjectionType::
    ProjectionFeature () const
    {
      return this->ProjectionFeature_.get ();
    }

    EllipticalArcProjectionType::ProjectionFeature_type& EllipticalArcProjectionType::
    ProjectionFeature ()
    {
      return this->ProjectionFeature_.get ();
    }

    void EllipticalArcProjectionType::
    ProjectionFeature (const ProjectionFeature_type& x)
    {
      this->ProjectionFeature_.set (x);
    }

    void EllipticalArcProjectionType::
    ProjectionFeature (::std::unique_ptr< ProjectionFeature_type > x)
    {
      this->ProjectionFeature_.set (std::move (x));
    }

    const EllipticalArcProjectionType::ProjectionPlane_type& EllipticalArcProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    EllipticalArcProjectionType::ProjectionPlane_type& EllipticalArcProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void EllipticalArcProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void EllipticalArcProjectionType::
    ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (std::move (x));
    }


    // EllipticalArcIntersectionType
    //

    const EllipticalArcIntersectionType::IntersectionPlane_type& EllipticalArcIntersectionType::
    IntersectionPlane () const
    {
      return this->IntersectionPlane_.get ();
    }

    EllipticalArcIntersectionType::IntersectionPlane_type& EllipticalArcIntersectionType::
    IntersectionPlane ()
    {
      return this->IntersectionPlane_.get ();
    }

    void EllipticalArcIntersectionType::
    IntersectionPlane (const IntersectionPlane_type& x)
    {
      this->IntersectionPlane_.set (x);
    }

    void EllipticalArcIntersectionType::
    IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > x)
    {
      this->IntersectionPlane_.set (std::move (x));
    }

    const EllipticalArcIntersectionType::IntersectionFeature_type& EllipticalArcIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_.get ();
    }

    EllipticalArcIntersectionType::IntersectionFeature_type& EllipticalArcIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_.get ();
    }

    void EllipticalArcIntersectionType::
    IntersectionFeature (const IntersectionFeature_type& x)
    {
      this->IntersectionFeature_.set (x);
    }

    void EllipticalArcIntersectionType::
    IntersectionFeature (::std::unique_ptr< IntersectionFeature_type > x)
    {
      this->IntersectionFeature_.set (std::move (x));
    }


    // EllipticalArcCopyType
    //

    const EllipticalArcCopyType::BaseEllipticalArc_type& EllipticalArcCopyType::
    BaseEllipticalArc () const
    {
      return this->BaseEllipticalArc_.get ();
    }

    EllipticalArcCopyType::BaseEllipticalArc_type& EllipticalArcCopyType::
    BaseEllipticalArc ()
    {
      return this->BaseEllipticalArc_.get ();
    }

    void EllipticalArcCopyType::
    BaseEllipticalArc (const BaseEllipticalArc_type& x)
    {
      this->BaseEllipticalArc_.set (x);
    }

    void EllipticalArcCopyType::
    BaseEllipticalArc (::std::unique_ptr< BaseEllipticalArc_type > x)
    {
      this->BaseEllipticalArc_.set (std::move (x));
    }


    // EllipticalArcCastType
    //

    const EllipticalArcCastType::BaseFeature_type& EllipticalArcCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    EllipticalArcCastType::BaseFeature_type& EllipticalArcCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void EllipticalArcCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void EllipticalArcCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // EllipticalArcTransformType
    //

    const EllipticalArcTransformType::BaseEllipticalArc_type& EllipticalArcTransformType::
    BaseEllipticalArc () const
    {
      return this->BaseEllipticalArc_.get ();
    }

    EllipticalArcTransformType::BaseEllipticalArc_type& EllipticalArcTransformType::
    BaseEllipticalArc ()
    {
      return this->BaseEllipticalArc_.get ();
    }

    void EllipticalArcTransformType::
    BaseEllipticalArc (const BaseEllipticalArc_type& x)
    {
      this->BaseEllipticalArc_.set (x);
    }

    void EllipticalArcTransformType::
    BaseEllipticalArc (::std::unique_ptr< BaseEllipticalArc_type > x)
    {
      this->BaseEllipticalArc_.set (std::move (x));
    }

    const EllipticalArcTransformType::Transformation_type& EllipticalArcTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    EllipticalArcTransformType::Transformation_type& EllipticalArcTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void EllipticalArcTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void EllipticalArcTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // EllipticalArcFromScanType
    //

    const EllipticalArcFromScanType::SurfaceFeature_type& EllipticalArcFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    EllipticalArcFromScanType::SurfaceFeature_type& EllipticalArcFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void EllipticalArcFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void EllipticalArcFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const EllipticalArcFromScanType::SearchRadius_type& EllipticalArcFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    EllipticalArcFromScanType::SearchRadius_type& EllipticalArcFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void EllipticalArcFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void EllipticalArcFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const EllipticalArcFromScanType::Depth_type& EllipticalArcFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    EllipticalArcFromScanType::Depth_type& EllipticalArcFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void EllipticalArcFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void EllipticalArcFromScanType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }


    // EllipticalArcCheckedType
    //

    const EllipticalArcCheckedType::Measured_optional& EllipticalArcCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    EllipticalArcCheckedType::Measured_optional& EllipticalArcCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void EllipticalArcCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void EllipticalArcCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void EllipticalArcCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const EllipticalArcCheckedType::Constructed_optional& EllipticalArcCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EllipticalArcCheckedType::Constructed_optional& EllipticalArcCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EllipticalArcCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EllipticalArcCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EllipticalArcCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // EllipticalArcCheckedFeatureType
    //

    const EllipticalArcCheckedFeatureType::CheckDetails_optional& EllipticalArcCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    EllipticalArcCheckedFeatureType::CheckDetails_optional& EllipticalArcCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void EllipticalArcCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void EllipticalArcCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void EllipticalArcCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // EllipticalArcMeasurementDeterminationType
    //

    const EllipticalArcMeasurementDeterminationType::Checked_optional& EllipticalArcMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    EllipticalArcMeasurementDeterminationType::Checked_optional& EllipticalArcMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void EllipticalArcMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void EllipticalArcMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void EllipticalArcMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const EllipticalArcMeasurementDeterminationType::Set_optional& EllipticalArcMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    EllipticalArcMeasurementDeterminationType::Set_optional& EllipticalArcMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void EllipticalArcMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void EllipticalArcMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void EllipticalArcMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // EllipticalArcFeatureItemType
    //

    const EllipticalArcFeatureItemType::DeterminationMode_type& EllipticalArcFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    EllipticalArcFeatureItemType::DeterminationMode_type& EllipticalArcFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void EllipticalArcFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void EllipticalArcFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // EllipticalArcFeatureDefinitionType
    //

    const EllipticalArcFeatureDefinitionType::InternalExternal_type& EllipticalArcFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    EllipticalArcFeatureDefinitionType::InternalExternal_type& EllipticalArcFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void EllipticalArcFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void EllipticalArcFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const EllipticalArcFeatureDefinitionType::MajorDiameter_type& EllipticalArcFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    EllipticalArcFeatureDefinitionType::MajorDiameter_type& EllipticalArcFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void EllipticalArcFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void EllipticalArcFeatureDefinitionType::
    MajorDiameter (::std::unique_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (std::move (x));
    }

    const EllipticalArcFeatureDefinitionType::MinorDiameter_type& EllipticalArcFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    EllipticalArcFeatureDefinitionType::MinorDiameter_type& EllipticalArcFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void EllipticalArcFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void EllipticalArcFeatureDefinitionType::
    MinorDiameter (::std::unique_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (std::move (x));
    }


    // EllipticalArcFeatureNominalType
    //

    const EllipticalArcFeatureNominalType::Axis_type& EllipticalArcFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    EllipticalArcFeatureNominalType::Axis_type& EllipticalArcFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void EllipticalArcFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void EllipticalArcFeatureNominalType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const EllipticalArcFeatureNominalType::Normal_type& EllipticalArcFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    EllipticalArcFeatureNominalType::Normal_type& EllipticalArcFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void EllipticalArcFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EllipticalArcFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const EllipticalArcFeatureNominalType::Sweep_type& EllipticalArcFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    EllipticalArcFeatureNominalType::Sweep_type& EllipticalArcFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void EllipticalArcFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void EllipticalArcFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const EllipticalArcFeatureNominalType::Constructed_optional& EllipticalArcFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EllipticalArcFeatureNominalType::Constructed_optional& EllipticalArcFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EllipticalArcFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EllipticalArcFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EllipticalArcFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // EllipticalArcFeatureMeasurementType
    //

    const EllipticalArcFeatureMeasurementType::Axis_optional& EllipticalArcFeatureMeasurementType::
    Axis () const
    {
      return this->Axis_;
    }

    EllipticalArcFeatureMeasurementType::Axis_optional& EllipticalArcFeatureMeasurementType::
    Axis ()
    {
      return this->Axis_;
    }

    void EllipticalArcFeatureMeasurementType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void EllipticalArcFeatureMeasurementType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void EllipticalArcFeatureMeasurementType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const EllipticalArcFeatureMeasurementType::Normal_optional& EllipticalArcFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    EllipticalArcFeatureMeasurementType::Normal_optional& EllipticalArcFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void EllipticalArcFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EllipticalArcFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void EllipticalArcFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const EllipticalArcFeatureMeasurementType::SweepMeasurementRange_optional& EllipticalArcFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    EllipticalArcFeatureMeasurementType::SweepMeasurementRange_optional& EllipticalArcFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void EllipticalArcFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void EllipticalArcFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void EllipticalArcFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const EllipticalArcFeatureMeasurementType::SweepFull_optional& EllipticalArcFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    EllipticalArcFeatureMeasurementType::SweepFull_optional& EllipticalArcFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void EllipticalArcFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void EllipticalArcFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void EllipticalArcFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }

    const EllipticalArcFeatureMeasurementType::MajorDiameter_optional& EllipticalArcFeatureMeasurementType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    EllipticalArcFeatureMeasurementType::MajorDiameter_optional& EllipticalArcFeatureMeasurementType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void EllipticalArcFeatureMeasurementType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void EllipticalArcFeatureMeasurementType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void EllipticalArcFeatureMeasurementType::
    MajorDiameter (::std::unique_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (std::move (x));
    }

    const EllipticalArcFeatureMeasurementType::MinorDiameter_optional& EllipticalArcFeatureMeasurementType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    EllipticalArcFeatureMeasurementType::MinorDiameter_optional& EllipticalArcFeatureMeasurementType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void EllipticalArcFeatureMeasurementType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void EllipticalArcFeatureMeasurementType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void EllipticalArcFeatureMeasurementType::
    MinorDiameter (::std::unique_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (std::move (x));
    }

    const EllipticalArcFeatureMeasurementType::Form_optional& EllipticalArcFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    EllipticalArcFeatureMeasurementType::Form_optional& EllipticalArcFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void EllipticalArcFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void EllipticalArcFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void EllipticalArcFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // ElongatedCircleConstructionMethodType
    //

    const ElongatedCircleConstructionMethodType::BestFit_optional& ElongatedCircleConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ElongatedCircleConstructionMethodType::BestFit_optional& ElongatedCircleConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ElongatedCircleConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ElongatedCircleConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ElongatedCircleConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const ElongatedCircleConstructionMethodType::Recompensated_optional& ElongatedCircleConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ElongatedCircleConstructionMethodType::Recompensated_optional& ElongatedCircleConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ElongatedCircleConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ElongatedCircleConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ElongatedCircleConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const ElongatedCircleConstructionMethodType::Copy_optional& ElongatedCircleConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ElongatedCircleConstructionMethodType::Copy_optional& ElongatedCircleConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ElongatedCircleConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ElongatedCircleConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ElongatedCircleConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const ElongatedCircleConstructionMethodType::Cast_optional& ElongatedCircleConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ElongatedCircleConstructionMethodType::Cast_optional& ElongatedCircleConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ElongatedCircleConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ElongatedCircleConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ElongatedCircleConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const ElongatedCircleConstructionMethodType::Transform_optional& ElongatedCircleConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ElongatedCircleConstructionMethodType::Transform_optional& ElongatedCircleConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ElongatedCircleConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ElongatedCircleConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ElongatedCircleConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // ElongatedCircleBestFitType
    //

    const ElongatedCircleBestFitType::BaseFeature_sequence& ElongatedCircleBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ElongatedCircleBestFitType::BaseFeature_sequence& ElongatedCircleBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ElongatedCircleBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const ElongatedCircleBestFitType::n_type& ElongatedCircleBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    ElongatedCircleBestFitType::n_type& ElongatedCircleBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void ElongatedCircleBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ElongatedCircleBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ElongatedCircleRecompType
    //

    const ElongatedCircleRecompType::BaseFeaturePointList_type& ElongatedCircleRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ElongatedCircleRecompType::BaseFeaturePointList_type& ElongatedCircleRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ElongatedCircleRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ElongatedCircleRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // ElongatedCircleCopyType
    //

    const ElongatedCircleCopyType::BaseElongatedCircle_type& ElongatedCircleCopyType::
    BaseElongatedCircle () const
    {
      return this->BaseElongatedCircle_.get ();
    }

    ElongatedCircleCopyType::BaseElongatedCircle_type& ElongatedCircleCopyType::
    BaseElongatedCircle ()
    {
      return this->BaseElongatedCircle_.get ();
    }

    void ElongatedCircleCopyType::
    BaseElongatedCircle (const BaseElongatedCircle_type& x)
    {
      this->BaseElongatedCircle_.set (x);
    }

    void ElongatedCircleCopyType::
    BaseElongatedCircle (::std::unique_ptr< BaseElongatedCircle_type > x)
    {
      this->BaseElongatedCircle_.set (std::move (x));
    }


    // ElongatedCircleCastType
    //

    const ElongatedCircleCastType::BaseFeature_type& ElongatedCircleCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ElongatedCircleCastType::BaseFeature_type& ElongatedCircleCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ElongatedCircleCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ElongatedCircleCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // ElongatedCircleTransformType
    //

    const ElongatedCircleTransformType::BaseElongatedCircle_type& ElongatedCircleTransformType::
    BaseElongatedCircle () const
    {
      return this->BaseElongatedCircle_.get ();
    }

    ElongatedCircleTransformType::BaseElongatedCircle_type& ElongatedCircleTransformType::
    BaseElongatedCircle ()
    {
      return this->BaseElongatedCircle_.get ();
    }

    void ElongatedCircleTransformType::
    BaseElongatedCircle (const BaseElongatedCircle_type& x)
    {
      this->BaseElongatedCircle_.set (x);
    }

    void ElongatedCircleTransformType::
    BaseElongatedCircle (::std::unique_ptr< BaseElongatedCircle_type > x)
    {
      this->BaseElongatedCircle_.set (std::move (x));
    }

    const ElongatedCircleTransformType::Transformation_type& ElongatedCircleTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ElongatedCircleTransformType::Transformation_type& ElongatedCircleTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ElongatedCircleTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ElongatedCircleTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // ElongatedCircleCheckedType
    //

    const ElongatedCircleCheckedType::Measured_optional& ElongatedCircleCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ElongatedCircleCheckedType::Measured_optional& ElongatedCircleCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ElongatedCircleCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ElongatedCircleCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ElongatedCircleCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const ElongatedCircleCheckedType::Constructed_optional& ElongatedCircleCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ElongatedCircleCheckedType::Constructed_optional& ElongatedCircleCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ElongatedCircleCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ElongatedCircleCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ElongatedCircleCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ElongatedCircleCheckedFeatureType
    //

    const ElongatedCircleCheckedFeatureType::CheckDetails_optional& ElongatedCircleCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ElongatedCircleCheckedFeatureType::CheckDetails_optional& ElongatedCircleCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ElongatedCircleCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ElongatedCircleCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ElongatedCircleCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // ElongatedCircleMeasurementDeterminationType
    //

    const ElongatedCircleMeasurementDeterminationType::Checked_optional& ElongatedCircleMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ElongatedCircleMeasurementDeterminationType::Checked_optional& ElongatedCircleMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ElongatedCircleMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ElongatedCircleMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ElongatedCircleMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const ElongatedCircleMeasurementDeterminationType::Set_optional& ElongatedCircleMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ElongatedCircleMeasurementDeterminationType::Set_optional& ElongatedCircleMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ElongatedCircleMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ElongatedCircleMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ElongatedCircleMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // ElongatedCircleFeatureItemType
    //

    const ElongatedCircleFeatureItemType::DeterminationMode_type& ElongatedCircleFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ElongatedCircleFeatureItemType::DeterminationMode_type& ElongatedCircleFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ElongatedCircleFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ElongatedCircleFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // ElongatedCircleFeatureDefinitionType
    //

    const ElongatedCircleFeatureDefinitionType::InternalExternal_type& ElongatedCircleFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ElongatedCircleFeatureDefinitionType::InternalExternal_type& ElongatedCircleFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ElongatedCircleFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ElongatedCircleFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const ElongatedCircleFeatureDefinitionType::Diameter_type& ElongatedCircleFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ElongatedCircleFeatureDefinitionType::Diameter_type& ElongatedCircleFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ElongatedCircleFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ElongatedCircleFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ElongatedCircleFeatureDefinitionType::Length_type& ElongatedCircleFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    ElongatedCircleFeatureDefinitionType::Length_type& ElongatedCircleFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void ElongatedCircleFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ElongatedCircleFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }


    // ElongatedCircleFeatureNominalType
    //

    const ElongatedCircleFeatureNominalType::CenterLine_type& ElongatedCircleFeatureNominalType::
    CenterLine () const
    {
      return this->CenterLine_.get ();
    }

    ElongatedCircleFeatureNominalType::CenterLine_type& ElongatedCircleFeatureNominalType::
    CenterLine ()
    {
      return this->CenterLine_.get ();
    }

    void ElongatedCircleFeatureNominalType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void ElongatedCircleFeatureNominalType::
    CenterLine (::std::unique_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (std::move (x));
    }

    const ElongatedCircleFeatureNominalType::Normal_type& ElongatedCircleFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    ElongatedCircleFeatureNominalType::Normal_type& ElongatedCircleFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void ElongatedCircleFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ElongatedCircleFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const ElongatedCircleFeatureNominalType::Constructed_optional& ElongatedCircleFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ElongatedCircleFeatureNominalType::Constructed_optional& ElongatedCircleFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ElongatedCircleFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ElongatedCircleFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ElongatedCircleFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ElongatedCircleFeatureMeasurementType
    //

    const ElongatedCircleFeatureMeasurementType::Diameter_optional& ElongatedCircleFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ElongatedCircleFeatureMeasurementType::Diameter_optional& ElongatedCircleFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ElongatedCircleFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ElongatedCircleFeatureMeasurementType::DiameterMin_optional& ElongatedCircleFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ElongatedCircleFeatureMeasurementType::DiameterMin_optional& ElongatedCircleFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ElongatedCircleFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const ElongatedCircleFeatureMeasurementType::DiameterMax_optional& ElongatedCircleFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ElongatedCircleFeatureMeasurementType::DiameterMax_optional& ElongatedCircleFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ElongatedCircleFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const ElongatedCircleFeatureMeasurementType::CenterLine_optional& ElongatedCircleFeatureMeasurementType::
    CenterLine () const
    {
      return this->CenterLine_;
    }

    ElongatedCircleFeatureMeasurementType::CenterLine_optional& ElongatedCircleFeatureMeasurementType::
    CenterLine ()
    {
      return this->CenterLine_;
    }

    void ElongatedCircleFeatureMeasurementType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    CenterLine (const CenterLine_optional& x)
    {
      this->CenterLine_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    CenterLine (::std::unique_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (std::move (x));
    }

    const ElongatedCircleFeatureMeasurementType::Normal_optional& ElongatedCircleFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    ElongatedCircleFeatureMeasurementType::Normal_optional& ElongatedCircleFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void ElongatedCircleFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const ElongatedCircleFeatureMeasurementType::Length_optional& ElongatedCircleFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    ElongatedCircleFeatureMeasurementType::Length_optional& ElongatedCircleFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void ElongatedCircleFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const ElongatedCircleFeatureMeasurementType::LengthMax_optional& ElongatedCircleFeatureMeasurementType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    ElongatedCircleFeatureMeasurementType::LengthMax_optional& ElongatedCircleFeatureMeasurementType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void ElongatedCircleFeatureMeasurementType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    LengthMax (::std::unique_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (std::move (x));
    }

    const ElongatedCircleFeatureMeasurementType::LengthMin_optional& ElongatedCircleFeatureMeasurementType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    ElongatedCircleFeatureMeasurementType::LengthMin_optional& ElongatedCircleFeatureMeasurementType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void ElongatedCircleFeatureMeasurementType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    LengthMin (::std::unique_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (std::move (x));
    }

    const ElongatedCircleFeatureMeasurementType::Form_optional& ElongatedCircleFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    ElongatedCircleFeatureMeasurementType::Form_optional& ElongatedCircleFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void ElongatedCircleFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ElongatedCircleFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ElongatedCircleFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // ElongatedCylinderConstructionMethodType
    //

    const ElongatedCylinderConstructionMethodType::BestFit_optional& ElongatedCylinderConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ElongatedCylinderConstructionMethodType::BestFit_optional& ElongatedCylinderConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const ElongatedCylinderConstructionMethodType::Recompensated_optional& ElongatedCylinderConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ElongatedCylinderConstructionMethodType::Recompensated_optional& ElongatedCylinderConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const ElongatedCylinderConstructionMethodType::Copy_optional& ElongatedCylinderConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ElongatedCylinderConstructionMethodType::Copy_optional& ElongatedCylinderConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const ElongatedCylinderConstructionMethodType::Cast_optional& ElongatedCylinderConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ElongatedCylinderConstructionMethodType::Cast_optional& ElongatedCylinderConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const ElongatedCylinderConstructionMethodType::Transform_optional& ElongatedCylinderConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ElongatedCylinderConstructionMethodType::Transform_optional& ElongatedCylinderConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // ElongatedCylinderBestFitType
    //

    const ElongatedCylinderBestFitType::BaseFeature_sequence& ElongatedCylinderBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ElongatedCylinderBestFitType::BaseFeature_sequence& ElongatedCylinderBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ElongatedCylinderBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const ElongatedCylinderBestFitType::n_type& ElongatedCylinderBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    ElongatedCylinderBestFitType::n_type& ElongatedCylinderBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void ElongatedCylinderBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ElongatedCylinderBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ElongatedCylinderRecompType
    //

    const ElongatedCylinderRecompType::BaseFeaturePointList_type& ElongatedCylinderRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ElongatedCylinderRecompType::BaseFeaturePointList_type& ElongatedCylinderRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ElongatedCylinderRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ElongatedCylinderRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // ElongatedCylinderCopyType
    //

    const ElongatedCylinderCopyType::BaseElongatedCylinder_type& ElongatedCylinderCopyType::
    BaseElongatedCylinder () const
    {
      return this->BaseElongatedCylinder_.get ();
    }

    ElongatedCylinderCopyType::BaseElongatedCylinder_type& ElongatedCylinderCopyType::
    BaseElongatedCylinder ()
    {
      return this->BaseElongatedCylinder_.get ();
    }

    void ElongatedCylinderCopyType::
    BaseElongatedCylinder (const BaseElongatedCylinder_type& x)
    {
      this->BaseElongatedCylinder_.set (x);
    }

    void ElongatedCylinderCopyType::
    BaseElongatedCylinder (::std::unique_ptr< BaseElongatedCylinder_type > x)
    {
      this->BaseElongatedCylinder_.set (std::move (x));
    }


    // ElongatedCylinderCastType
    //

    const ElongatedCylinderCastType::BaseFeature_type& ElongatedCylinderCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ElongatedCylinderCastType::BaseFeature_type& ElongatedCylinderCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ElongatedCylinderCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ElongatedCylinderCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // ElongatedCylinderTransformType
    //

    const ElongatedCylinderTransformType::BaseElongatedCylinder_type& ElongatedCylinderTransformType::
    BaseElongatedCylinder () const
    {
      return this->BaseElongatedCylinder_.get ();
    }

    ElongatedCylinderTransformType::BaseElongatedCylinder_type& ElongatedCylinderTransformType::
    BaseElongatedCylinder ()
    {
      return this->BaseElongatedCylinder_.get ();
    }

    void ElongatedCylinderTransformType::
    BaseElongatedCylinder (const BaseElongatedCylinder_type& x)
    {
      this->BaseElongatedCylinder_.set (x);
    }

    void ElongatedCylinderTransformType::
    BaseElongatedCylinder (::std::unique_ptr< BaseElongatedCylinder_type > x)
    {
      this->BaseElongatedCylinder_.set (std::move (x));
    }

    const ElongatedCylinderTransformType::Transformation_type& ElongatedCylinderTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ElongatedCylinderTransformType::Transformation_type& ElongatedCylinderTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ElongatedCylinderTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ElongatedCylinderTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // ElongatedCylinderCheckedType
    //

    const ElongatedCylinderCheckedType::Measured_optional& ElongatedCylinderCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ElongatedCylinderCheckedType::Measured_optional& ElongatedCylinderCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ElongatedCylinderCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ElongatedCylinderCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ElongatedCylinderCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const ElongatedCylinderCheckedType::Constructed_optional& ElongatedCylinderCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ElongatedCylinderCheckedType::Constructed_optional& ElongatedCylinderCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ElongatedCylinderCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ElongatedCylinderCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ElongatedCylinderCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ElongatedCylinderCheckedFeatureType
    //

    const ElongatedCylinderCheckedFeatureType::CheckDetails_optional& ElongatedCylinderCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ElongatedCylinderCheckedFeatureType::CheckDetails_optional& ElongatedCylinderCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // ElongatedCylinderMeasurementDeterminationType
    //

    const ElongatedCylinderMeasurementDeterminationType::Checked_optional& ElongatedCylinderMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ElongatedCylinderMeasurementDeterminationType::Checked_optional& ElongatedCylinderMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ElongatedCylinderMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ElongatedCylinderMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ElongatedCylinderMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const ElongatedCylinderMeasurementDeterminationType::Set_optional& ElongatedCylinderMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ElongatedCylinderMeasurementDeterminationType::Set_optional& ElongatedCylinderMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ElongatedCylinderMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ElongatedCylinderMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ElongatedCylinderMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // ElongatedCylinderFeatureItemType
    //

    const ElongatedCylinderFeatureItemType::DeterminationMode_type& ElongatedCylinderFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ElongatedCylinderFeatureItemType::DeterminationMode_type& ElongatedCylinderFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ElongatedCylinderFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ElongatedCylinderFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // ElongatedCylinderFeatureDefinitionType
    //

    const ElongatedCylinderFeatureDefinitionType::InternalExternal_type& ElongatedCylinderFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::InternalExternal_type& ElongatedCylinderFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const ElongatedCylinderFeatureDefinitionType::Diameter_type& ElongatedCylinderFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::Diameter_type& ElongatedCylinderFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ElongatedCylinderFeatureDefinitionType::Length_type& ElongatedCylinderFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::Length_type& ElongatedCylinderFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const ElongatedCylinderFeatureDefinitionType::Depth_optional& ElongatedCylinderFeatureDefinitionType::
    Depth () const
    {
      return this->Depth_;
    }

    ElongatedCylinderFeatureDefinitionType::Depth_optional& ElongatedCylinderFeatureDefinitionType::
    Depth ()
    {
      return this->Depth_;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }


    // ElongatedCylinderFeatureNominalType
    //

    const ElongatedCylinderFeatureNominalType::CenterPlane_type& ElongatedCylinderFeatureNominalType::
    CenterPlane () const
    {
      return this->CenterPlane_.get ();
    }

    ElongatedCylinderFeatureNominalType::CenterPlane_type& ElongatedCylinderFeatureNominalType::
    CenterPlane ()
    {
      return this->CenterPlane_.get ();
    }

    void ElongatedCylinderFeatureNominalType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void ElongatedCylinderFeatureNominalType::
    CenterPlane (::std::unique_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (std::move (x));
    }

    const ElongatedCylinderFeatureNominalType::DepthVector_type& ElongatedCylinderFeatureNominalType::
    DepthVector () const
    {
      return this->DepthVector_.get ();
    }

    ElongatedCylinderFeatureNominalType::DepthVector_type& ElongatedCylinderFeatureNominalType::
    DepthVector ()
    {
      return this->DepthVector_.get ();
    }

    void ElongatedCylinderFeatureNominalType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void ElongatedCylinderFeatureNominalType::
    DepthVector (::std::unique_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (std::move (x));
    }

    const ElongatedCylinderFeatureNominalType::Constructed_optional& ElongatedCylinderFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ElongatedCylinderFeatureNominalType::Constructed_optional& ElongatedCylinderFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ElongatedCylinderFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ElongatedCylinderFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ElongatedCylinderFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ElongatedCylinderFeatureMeasurementType
    //

    const ElongatedCylinderFeatureMeasurementType::Diameter_optional& ElongatedCylinderFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ElongatedCylinderFeatureMeasurementType::Diameter_optional& ElongatedCylinderFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::DiameterMin_optional& ElongatedCylinderFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ElongatedCylinderFeatureMeasurementType::DiameterMin_optional& ElongatedCylinderFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::DiameterMax_optional& ElongatedCylinderFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ElongatedCylinderFeatureMeasurementType::DiameterMax_optional& ElongatedCylinderFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::CenterPlane_optional& ElongatedCylinderFeatureMeasurementType::
    CenterPlane () const
    {
      return this->CenterPlane_;
    }

    ElongatedCylinderFeatureMeasurementType::CenterPlane_optional& ElongatedCylinderFeatureMeasurementType::
    CenterPlane ()
    {
      return this->CenterPlane_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    CenterPlane (const CenterPlane_optional& x)
    {
      this->CenterPlane_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    CenterPlane (::std::unique_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::Length_optional& ElongatedCylinderFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    ElongatedCylinderFeatureMeasurementType::Length_optional& ElongatedCylinderFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::LengthMax_optional& ElongatedCylinderFeatureMeasurementType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    ElongatedCylinderFeatureMeasurementType::LengthMax_optional& ElongatedCylinderFeatureMeasurementType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    LengthMax (::std::unique_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::LengthMin_optional& ElongatedCylinderFeatureMeasurementType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    ElongatedCylinderFeatureMeasurementType::LengthMin_optional& ElongatedCylinderFeatureMeasurementType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    LengthMin (::std::unique_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::Depth_optional& ElongatedCylinderFeatureMeasurementType::
    Depth () const
    {
      return this->Depth_;
    }

    ElongatedCylinderFeatureMeasurementType::Depth_optional& ElongatedCylinderFeatureMeasurementType::
    Depth ()
    {
      return this->Depth_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::DepthMax_optional& ElongatedCylinderFeatureMeasurementType::
    DepthMax () const
    {
      return this->DepthMax_;
    }

    ElongatedCylinderFeatureMeasurementType::DepthMax_optional& ElongatedCylinderFeatureMeasurementType::
    DepthMax ()
    {
      return this->DepthMax_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthMax (const DepthMax_type& x)
    {
      this->DepthMax_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthMax (const DepthMax_optional& x)
    {
      this->DepthMax_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthMax (::std::unique_ptr< DepthMax_type > x)
    {
      this->DepthMax_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::DepthMin_optional& ElongatedCylinderFeatureMeasurementType::
    DepthMin () const
    {
      return this->DepthMin_;
    }

    ElongatedCylinderFeatureMeasurementType::DepthMin_optional& ElongatedCylinderFeatureMeasurementType::
    DepthMin ()
    {
      return this->DepthMin_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthMin (const DepthMin_type& x)
    {
      this->DepthMin_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthMin (const DepthMin_optional& x)
    {
      this->DepthMin_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthMin (::std::unique_ptr< DepthMin_type > x)
    {
      this->DepthMin_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::DepthVector_optional& ElongatedCylinderFeatureMeasurementType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    ElongatedCylinderFeatureMeasurementType::DepthVector_optional& ElongatedCylinderFeatureMeasurementType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    DepthVector (::std::unique_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (std::move (x));
    }

    const ElongatedCylinderFeatureMeasurementType::Form_optional& ElongatedCylinderFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    ElongatedCylinderFeatureMeasurementType::Form_optional& ElongatedCylinderFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void ElongatedCylinderFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ElongatedCylinderFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ElongatedCylinderFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // ExtrudedCrossSectionConstructionMethodType
    //

    const ExtrudedCrossSectionConstructionMethodType::BestFit_optional& ExtrudedCrossSectionConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ExtrudedCrossSectionConstructionMethodType::BestFit_optional& ExtrudedCrossSectionConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const ExtrudedCrossSectionConstructionMethodType::Recompensated_optional& ExtrudedCrossSectionConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ExtrudedCrossSectionConstructionMethodType::Recompensated_optional& ExtrudedCrossSectionConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const ExtrudedCrossSectionConstructionMethodType::Copy_optional& ExtrudedCrossSectionConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ExtrudedCrossSectionConstructionMethodType::Copy_optional& ExtrudedCrossSectionConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const ExtrudedCrossSectionConstructionMethodType::Cast_optional& ExtrudedCrossSectionConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ExtrudedCrossSectionConstructionMethodType::Cast_optional& ExtrudedCrossSectionConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const ExtrudedCrossSectionConstructionMethodType::Transform_optional& ExtrudedCrossSectionConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ExtrudedCrossSectionConstructionMethodType::Transform_optional& ExtrudedCrossSectionConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // ExtrudedCrossSectionBestFitType
    //

    const ExtrudedCrossSectionBestFitType::BaseFeature_sequence& ExtrudedCrossSectionBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ExtrudedCrossSectionBestFitType::BaseFeature_sequence& ExtrudedCrossSectionBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ExtrudedCrossSectionBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const ExtrudedCrossSectionBestFitType::n_type& ExtrudedCrossSectionBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    ExtrudedCrossSectionBestFitType::n_type& ExtrudedCrossSectionBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void ExtrudedCrossSectionBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ExtrudedCrossSectionBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ExtrudedCrossSectionRecompType
    //

    const ExtrudedCrossSectionRecompType::BaseFeaturePointList_type& ExtrudedCrossSectionRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ExtrudedCrossSectionRecompType::BaseFeaturePointList_type& ExtrudedCrossSectionRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ExtrudedCrossSectionRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ExtrudedCrossSectionRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // ExtrudedCrossSectionCopyType
    //

    const ExtrudedCrossSectionCopyType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection () const
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    ExtrudedCrossSectionCopyType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection ()
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    void ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection (const BaseExtrudedCrossSection_type& x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }

    void ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection (::std::unique_ptr< BaseExtrudedCrossSection_type > x)
    {
      this->BaseExtrudedCrossSection_.set (std::move (x));
    }


    // ExtrudedCrossSectionCastType
    //

    const ExtrudedCrossSectionCastType::BaseFeature_type& ExtrudedCrossSectionCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ExtrudedCrossSectionCastType::BaseFeature_type& ExtrudedCrossSectionCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ExtrudedCrossSectionCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ExtrudedCrossSectionCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // ExtrudedCrossSectionTransformType
    //

    const ExtrudedCrossSectionTransformType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection () const
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    ExtrudedCrossSectionTransformType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection ()
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    void ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection (const BaseExtrudedCrossSection_type& x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }

    void ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection (::std::unique_ptr< BaseExtrudedCrossSection_type > x)
    {
      this->BaseExtrudedCrossSection_.set (std::move (x));
    }

    const ExtrudedCrossSectionTransformType::Transformation_type& ExtrudedCrossSectionTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ExtrudedCrossSectionTransformType::Transformation_type& ExtrudedCrossSectionTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ExtrudedCrossSectionTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ExtrudedCrossSectionTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // ExtrudedCrossSectionCheckedType
    //

    const ExtrudedCrossSectionCheckedType::Measured_optional& ExtrudedCrossSectionCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ExtrudedCrossSectionCheckedType::Measured_optional& ExtrudedCrossSectionCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const ExtrudedCrossSectionCheckedType::Constructed_optional& ExtrudedCrossSectionCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ExtrudedCrossSectionCheckedType::Constructed_optional& ExtrudedCrossSectionCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ExtrudedCrossSectionCheckedFeatureType
    //

    const ExtrudedCrossSectionCheckedFeatureType::CheckDetails_optional& ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ExtrudedCrossSectionCheckedFeatureType::CheckDetails_optional& ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // ExtrudedCrossSectionMeasurementDeterminationType
    //

    const ExtrudedCrossSectionMeasurementDeterminationType::Checked_optional& ExtrudedCrossSectionMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ExtrudedCrossSectionMeasurementDeterminationType::Checked_optional& ExtrudedCrossSectionMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ExtrudedCrossSectionMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ExtrudedCrossSectionMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ExtrudedCrossSectionMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const ExtrudedCrossSectionMeasurementDeterminationType::Set_optional& ExtrudedCrossSectionMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ExtrudedCrossSectionMeasurementDeterminationType::Set_optional& ExtrudedCrossSectionMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ExtrudedCrossSectionMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ExtrudedCrossSectionMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ExtrudedCrossSectionMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // ExtrudedCrossSectionFeatureItemType
    //

    const ExtrudedCrossSectionFeatureItemType::DeterminationMode_type& ExtrudedCrossSectionFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ExtrudedCrossSectionFeatureItemType::DeterminationMode_type& ExtrudedCrossSectionFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ExtrudedCrossSectionFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ExtrudedCrossSectionFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // ExtrudedCrossSectionFeatureDefinitionType
    //

    const ExtrudedCrossSectionFeatureDefinitionType::InternalExternal_type& ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ExtrudedCrossSectionFeatureDefinitionType::InternalExternal_type& ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const ExtrudedCrossSectionFeatureDefinitionType::Length_type& ExtrudedCrossSectionFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    ExtrudedCrossSectionFeatureDefinitionType::Length_type& ExtrudedCrossSectionFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }


    // ExtrudedCrossSectionFeatureNominalType
    //

    const ExtrudedCrossSectionFeatureNominalType::Direction_type& ExtrudedCrossSectionFeatureNominalType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    ExtrudedCrossSectionFeatureNominalType::Direction_type& ExtrudedCrossSectionFeatureNominalType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }

    const ExtrudedCrossSectionFeatureNominalType::CrossSectionReferenceFeatureId_type& ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId () const
    {
      return this->CrossSectionReferenceFeatureId_.get ();
    }

    ExtrudedCrossSectionFeatureNominalType::CrossSectionReferenceFeatureId_type& ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId ()
    {
      return this->CrossSectionReferenceFeatureId_.get ();
    }

    void ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId (const CrossSectionReferenceFeatureId_type& x)
    {
      this->CrossSectionReferenceFeatureId_.set (x);
    }

    void ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId (::std::unique_ptr< CrossSectionReferenceFeatureId_type > x)
    {
      this->CrossSectionReferenceFeatureId_.set (std::move (x));
    }

    const ExtrudedCrossSectionFeatureNominalType::Constructed_optional& ExtrudedCrossSectionFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ExtrudedCrossSectionFeatureNominalType::Constructed_optional& ExtrudedCrossSectionFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ExtrudedCrossSectionFeatureMeasurementType
    //

    const ExtrudedCrossSectionFeatureMeasurementType::Direction_optional& ExtrudedCrossSectionFeatureMeasurementType::
    Direction () const
    {
      return this->Direction_;
    }

    ExtrudedCrossSectionFeatureMeasurementType::Direction_optional& ExtrudedCrossSectionFeatureMeasurementType::
    Direction ()
    {
      return this->Direction_;
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }

    const ExtrudedCrossSectionFeatureMeasurementType::Length_optional& ExtrudedCrossSectionFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    ExtrudedCrossSectionFeatureMeasurementType::Length_optional& ExtrudedCrossSectionFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const ExtrudedCrossSectionFeatureMeasurementType::Form_optional& ExtrudedCrossSectionFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    ExtrudedCrossSectionFeatureMeasurementType::Form_optional& ExtrudedCrossSectionFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // LineConstructionMethodType
    //

    const LineConstructionMethodType::BestFit_optional& LineConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    LineConstructionMethodType::BestFit_optional& LineConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void LineConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void LineConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void LineConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const LineConstructionMethodType::Recompensated_optional& LineConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    LineConstructionMethodType::Recompensated_optional& LineConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void LineConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void LineConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void LineConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const LineConstructionMethodType::Midline_optional& LineConstructionMethodType::
    Midline () const
    {
      return this->Midline_;
    }

    LineConstructionMethodType::Midline_optional& LineConstructionMethodType::
    Midline ()
    {
      return this->Midline_;
    }

    void LineConstructionMethodType::
    Midline (const Midline_type& x)
    {
      this->Midline_.set (x);
    }

    void LineConstructionMethodType::
    Midline (const Midline_optional& x)
    {
      this->Midline_ = x;
    }

    void LineConstructionMethodType::
    Midline (::std::unique_ptr< Midline_type > x)
    {
      this->Midline_.set (std::move (x));
    }

    const LineConstructionMethodType::Intersection_optional& LineConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    LineConstructionMethodType::Intersection_optional& LineConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void LineConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void LineConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void LineConstructionMethodType::
    Intersection (::std::unique_ptr< Intersection_type > x)
    {
      this->Intersection_.set (std::move (x));
    }

    const LineConstructionMethodType::Projection_optional& LineConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    LineConstructionMethodType::Projection_optional& LineConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void LineConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void LineConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void LineConstructionMethodType::
    Projection (::std::unique_ptr< Projection_type > x)
    {
      this->Projection_.set (std::move (x));
    }

    const LineConstructionMethodType::Perpendicular_optional& LineConstructionMethodType::
    Perpendicular () const
    {
      return this->Perpendicular_;
    }

    LineConstructionMethodType::Perpendicular_optional& LineConstructionMethodType::
    Perpendicular ()
    {
      return this->Perpendicular_;
    }

    void LineConstructionMethodType::
    Perpendicular (const Perpendicular_type& x)
    {
      this->Perpendicular_.set (x);
    }

    void LineConstructionMethodType::
    Perpendicular (const Perpendicular_optional& x)
    {
      this->Perpendicular_ = x;
    }

    void LineConstructionMethodType::
    Perpendicular (::std::unique_ptr< Perpendicular_type > x)
    {
      this->Perpendicular_.set (std::move (x));
    }

    const LineConstructionMethodType::Parallel_optional& LineConstructionMethodType::
    Parallel () const
    {
      return this->Parallel_;
    }

    LineConstructionMethodType::Parallel_optional& LineConstructionMethodType::
    Parallel ()
    {
      return this->Parallel_;
    }

    void LineConstructionMethodType::
    Parallel (const Parallel_type& x)
    {
      this->Parallel_.set (x);
    }

    void LineConstructionMethodType::
    Parallel (const Parallel_optional& x)
    {
      this->Parallel_ = x;
    }

    void LineConstructionMethodType::
    Parallel (::std::unique_ptr< Parallel_type > x)
    {
      this->Parallel_.set (std::move (x));
    }

    const LineConstructionMethodType::Copy_optional& LineConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    LineConstructionMethodType::Copy_optional& LineConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void LineConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void LineConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void LineConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const LineConstructionMethodType::Cast_optional& LineConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    LineConstructionMethodType::Cast_optional& LineConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void LineConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void LineConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void LineConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const LineConstructionMethodType::TangentThrough_optional& LineConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    LineConstructionMethodType::TangentThrough_optional& LineConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void LineConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void LineConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void LineConstructionMethodType::
    TangentThrough (::std::unique_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (std::move (x));
    }

    const LineConstructionMethodType::Transform_optional& LineConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    LineConstructionMethodType::Transform_optional& LineConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void LineConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void LineConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void LineConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const LineConstructionMethodType::Extract_optional& LineConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    LineConstructionMethodType::Extract_optional& LineConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void LineConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void LineConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void LineConstructionMethodType::
    Extract (::std::unique_ptr< Extract_type > x)
    {
      this->Extract_.set (std::move (x));
    }

    const LineConstructionMethodType::FromScan_optional& LineConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    LineConstructionMethodType::FromScan_optional& LineConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void LineConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void LineConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void LineConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // LineBestFitType
    //

    const LineBestFitType::BaseFeature_sequence& LineBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    LineBestFitType::BaseFeature_sequence& LineBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void LineBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const LineBestFitType::n_type& LineBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    LineBestFitType::n_type& LineBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void LineBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void LineBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // LineRecompType
    //

    const LineRecompType::BaseFeaturePointList_type& LineRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    LineRecompType::BaseFeaturePointList_type& LineRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void LineRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void LineRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // LineMidlineType
    //

    const LineMidlineType::BaseLine_sequence& LineMidlineType::
    BaseLine () const
    {
      return this->BaseLine_;
    }

    LineMidlineType::BaseLine_sequence& LineMidlineType::
    BaseLine ()
    {
      return this->BaseLine_;
    }

    void LineMidlineType::
    BaseLine (const BaseLine_sequence& s)
    {
      this->BaseLine_ = s;
    }


    // LineIntersectionType
    //

    const LineIntersectionType::IntersectionFeature_sequence& LineIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_;
    }

    LineIntersectionType::IntersectionFeature_sequence& LineIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_;
    }

    void LineIntersectionType::
    IntersectionFeature (const IntersectionFeature_sequence& s)
    {
      this->IntersectionFeature_ = s;
    }


    // LineProjectionType
    //

    const LineProjectionType::ProjectionPlane_type& LineProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    LineProjectionType::ProjectionPlane_type& LineProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void LineProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void LineProjectionType::
    ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (std::move (x));
    }

    const LineProjectionType::ProjectionLine_type& LineProjectionType::
    ProjectionLine () const
    {
      return this->ProjectionLine_.get ();
    }

    LineProjectionType::ProjectionLine_type& LineProjectionType::
    ProjectionLine ()
    {
      return this->ProjectionLine_.get ();
    }

    void LineProjectionType::
    ProjectionLine (const ProjectionLine_type& x)
    {
      this->ProjectionLine_.set (x);
    }

    void LineProjectionType::
    ProjectionLine (::std::unique_ptr< ProjectionLine_type > x)
    {
      this->ProjectionLine_.set (std::move (x));
    }


    // LinePerpendicularType
    //

    const LinePerpendicularType::PerpendicularFeature_type& LinePerpendicularType::
    PerpendicularFeature () const
    {
      return this->PerpendicularFeature_.get ();
    }

    LinePerpendicularType::PerpendicularFeature_type& LinePerpendicularType::
    PerpendicularFeature ()
    {
      return this->PerpendicularFeature_.get ();
    }

    void LinePerpendicularType::
    PerpendicularFeature (const PerpendicularFeature_type& x)
    {
      this->PerpendicularFeature_.set (x);
    }

    void LinePerpendicularType::
    PerpendicularFeature (::std::unique_ptr< PerpendicularFeature_type > x)
    {
      this->PerpendicularFeature_.set (std::move (x));
    }

    const LinePerpendicularType::PointFeature_type& LinePerpendicularType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LinePerpendicularType::PointFeature_type& LinePerpendicularType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LinePerpendicularType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LinePerpendicularType::
    PointFeature (::std::unique_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (std::move (x));
    }


    // LineParallelType
    //

    const LineParallelType::ParallelFeature_type& LineParallelType::
    ParallelFeature () const
    {
      return this->ParallelFeature_.get ();
    }

    LineParallelType::ParallelFeature_type& LineParallelType::
    ParallelFeature ()
    {
      return this->ParallelFeature_.get ();
    }

    void LineParallelType::
    ParallelFeature (const ParallelFeature_type& x)
    {
      this->ParallelFeature_.set (x);
    }

    void LineParallelType::
    ParallelFeature (::std::unique_ptr< ParallelFeature_type > x)
    {
      this->ParallelFeature_.set (std::move (x));
    }

    const LineParallelType::PointFeature_type& LineParallelType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LineParallelType::PointFeature_type& LineParallelType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LineParallelType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LineParallelType::
    PointFeature (::std::unique_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (std::move (x));
    }


    // LineCopyType
    //

    const LineCopyType::BaseLine_type& LineCopyType::
    BaseLine () const
    {
      return this->BaseLine_.get ();
    }

    LineCopyType::BaseLine_type& LineCopyType::
    BaseLine ()
    {
      return this->BaseLine_.get ();
    }

    void LineCopyType::
    BaseLine (const BaseLine_type& x)
    {
      this->BaseLine_.set (x);
    }

    void LineCopyType::
    BaseLine (::std::unique_ptr< BaseLine_type > x)
    {
      this->BaseLine_.set (std::move (x));
    }


    // LineCastType
    //

    const LineCastType::BaseFeature_type& LineCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    LineCastType::BaseFeature_type& LineCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void LineCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void LineCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // LineTangentThroughType
    //

    const LineTangentThroughType::TangentFeature_type& LineTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    LineTangentThroughType::TangentFeature_type& LineTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void LineTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void LineTangentThroughType::
    TangentFeature (::std::unique_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (std::move (x));
    }

    const LineTangentThroughType::PointFeature_type& LineTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LineTangentThroughType::PointFeature_type& LineTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LineTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LineTangentThroughType::
    PointFeature (::std::unique_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (std::move (x));
    }


    // LineTransformType
    //

    const LineTransformType::BaseLine_type& LineTransformType::
    BaseLine () const
    {
      return this->BaseLine_.get ();
    }

    LineTransformType::BaseLine_type& LineTransformType::
    BaseLine ()
    {
      return this->BaseLine_.get ();
    }

    void LineTransformType::
    BaseLine (const BaseLine_type& x)
    {
      this->BaseLine_.set (x);
    }

    void LineTransformType::
    BaseLine (::std::unique_ptr< BaseLine_type > x)
    {
      this->BaseLine_.set (std::move (x));
    }

    const LineTransformType::Transformation_type& LineTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    LineTransformType::Transformation_type& LineTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void LineTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void LineTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // LineFromScanType
    //

    const LineFromScanType::SurfaceFeature_type& LineFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    LineFromScanType::SurfaceFeature_type& LineFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void LineFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void LineFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const LineFromScanType::SearchRadius_type& LineFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    LineFromScanType::SearchRadius_type& LineFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void LineFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void LineFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }


    // LineExtractType
    //

    const LineExtractType::CurveFeature_type& LineExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    LineExtractType::CurveFeature_type& LineExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void LineExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void LineExtractType::
    CurveFeature (::std::unique_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (std::move (x));
    }


    // LineCheckedType
    //

    const LineCheckedType::Measured_optional& LineCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    LineCheckedType::Measured_optional& LineCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void LineCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void LineCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void LineCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const LineCheckedType::Constructed_optional& LineCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    LineCheckedType::Constructed_optional& LineCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void LineCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void LineCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void LineCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // LineCheckedFeatureType
    //

    const LineCheckedFeatureType::CheckDetails_optional& LineCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    LineCheckedFeatureType::CheckDetails_optional& LineCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void LineCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void LineCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void LineCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // LineMeasurementDeterminationType
    //

    const LineMeasurementDeterminationType::Checked_optional& LineMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    LineMeasurementDeterminationType::Checked_optional& LineMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void LineMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void LineMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void LineMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const LineMeasurementDeterminationType::Set_optional& LineMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    LineMeasurementDeterminationType::Set_optional& LineMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void LineMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void LineMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void LineMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // LineFeatureItemType
    //

    const LineFeatureItemType::DeterminationMode_type& LineFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    LineFeatureItemType::DeterminationMode_type& LineFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void LineFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void LineFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // LineFeatureDefinitionType
    //


    // LineFeatureNominalType
    //

    const LineFeatureNominalType::Location_type& LineFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    LineFeatureNominalType::Location_type& LineFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void LineFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void LineFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const LineFeatureNominalType::Direction_type& LineFeatureNominalType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    LineFeatureNominalType::Direction_type& LineFeatureNominalType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void LineFeatureNominalType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void LineFeatureNominalType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }

    const LineFeatureNominalType::Length_optional& LineFeatureNominalType::
    Length () const
    {
      return this->Length_;
    }

    LineFeatureNominalType::Length_optional& LineFeatureNominalType::
    Length ()
    {
      return this->Length_;
    }

    void LineFeatureNominalType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void LineFeatureNominalType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void LineFeatureNominalType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const LineFeatureNominalType::Normal_optional& LineFeatureNominalType::
    Normal () const
    {
      return this->Normal_;
    }

    LineFeatureNominalType::Normal_optional& LineFeatureNominalType::
    Normal ()
    {
      return this->Normal_;
    }

    void LineFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void LineFeatureNominalType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void LineFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const LineFeatureNominalType::Constructed_optional& LineFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    LineFeatureNominalType::Constructed_optional& LineFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void LineFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void LineFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void LineFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // LineFeatureMeasurementType
    //

    const LineFeatureMeasurementType::Location_optional& LineFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    LineFeatureMeasurementType::Location_optional& LineFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void LineFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void LineFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void LineFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const LineFeatureMeasurementType::Direction_optional& LineFeatureMeasurementType::
    Direction () const
    {
      return this->Direction_;
    }

    LineFeatureMeasurementType::Direction_optional& LineFeatureMeasurementType::
    Direction ()
    {
      return this->Direction_;
    }

    void LineFeatureMeasurementType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void LineFeatureMeasurementType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void LineFeatureMeasurementType::
    Direction (::std::unique_ptr< Direction_type > x)
    {
      this->Direction_.set (std::move (x));
    }

    const LineFeatureMeasurementType::Length_optional& LineFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    LineFeatureMeasurementType::Length_optional& LineFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void LineFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void LineFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void LineFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const LineFeatureMeasurementType::Normal_optional& LineFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    LineFeatureMeasurementType::Normal_optional& LineFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void LineFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void LineFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void LineFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const LineFeatureMeasurementType::Form_optional& LineFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    LineFeatureMeasurementType::Form_optional& LineFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void LineFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void LineFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void LineFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // OppositeParallelLinesConstructionMethodType
    //

    const OppositeParallelLinesConstructionMethodType::BestFit_optional& OppositeParallelLinesConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    OppositeParallelLinesConstructionMethodType::BestFit_optional& OppositeParallelLinesConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void OppositeParallelLinesConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void OppositeParallelLinesConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void OppositeParallelLinesConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const OppositeParallelLinesConstructionMethodType::Recompensated_optional& OppositeParallelLinesConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    OppositeParallelLinesConstructionMethodType::Recompensated_optional& OppositeParallelLinesConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void OppositeParallelLinesConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void OppositeParallelLinesConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void OppositeParallelLinesConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const OppositeParallelLinesConstructionMethodType::Intersection_optional& OppositeParallelLinesConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    OppositeParallelLinesConstructionMethodType::Intersection_optional& OppositeParallelLinesConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void OppositeParallelLinesConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void OppositeParallelLinesConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void OppositeParallelLinesConstructionMethodType::
    Intersection (::std::unique_ptr< Intersection_type > x)
    {
      this->Intersection_.set (std::move (x));
    }

    const OppositeParallelLinesConstructionMethodType::Projection_optional& OppositeParallelLinesConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    OppositeParallelLinesConstructionMethodType::Projection_optional& OppositeParallelLinesConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void OppositeParallelLinesConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void OppositeParallelLinesConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void OppositeParallelLinesConstructionMethodType::
    Projection (::std::unique_ptr< Projection_type > x)
    {
      this->Projection_.set (std::move (x));
    }

    const OppositeParallelLinesConstructionMethodType::Copy_optional& OppositeParallelLinesConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OppositeParallelLinesConstructionMethodType::Copy_optional& OppositeParallelLinesConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OppositeParallelLinesConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OppositeParallelLinesConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OppositeParallelLinesConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const OppositeParallelLinesConstructionMethodType::Cast_optional& OppositeParallelLinesConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    OppositeParallelLinesConstructionMethodType::Cast_optional& OppositeParallelLinesConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void OppositeParallelLinesConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void OppositeParallelLinesConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void OppositeParallelLinesConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const OppositeParallelLinesConstructionMethodType::Transform_optional& OppositeParallelLinesConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    OppositeParallelLinesConstructionMethodType::Transform_optional& OppositeParallelLinesConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void OppositeParallelLinesConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void OppositeParallelLinesConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void OppositeParallelLinesConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const OppositeParallelLinesConstructionMethodType::FromScan_optional& OppositeParallelLinesConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    OppositeParallelLinesConstructionMethodType::FromScan_optional& OppositeParallelLinesConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void OppositeParallelLinesConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void OppositeParallelLinesConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void OppositeParallelLinesConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // OppositeParallelLinesBestFitType
    //

    const OppositeParallelLinesBestFitType::BaseFeature_sequence& OppositeParallelLinesBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    OppositeParallelLinesBestFitType::BaseFeature_sequence& OppositeParallelLinesBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void OppositeParallelLinesBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const OppositeParallelLinesBestFitType::n_type& OppositeParallelLinesBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    OppositeParallelLinesBestFitType::n_type& OppositeParallelLinesBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void OppositeParallelLinesBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void OppositeParallelLinesBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // OppositeParallelLinesRecompType
    //

    const OppositeParallelLinesRecompType::BaseFeaturePointList_type& OppositeParallelLinesRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    OppositeParallelLinesRecompType::BaseFeaturePointList_type& OppositeParallelLinesRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void OppositeParallelLinesRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void OppositeParallelLinesRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // OppositeParallelLinesIntersectionType
    //

    const OppositeParallelLinesIntersectionType::IntersectionPlane_type& OppositeParallelLinesIntersectionType::
    IntersectionPlane () const
    {
      return this->IntersectionPlane_.get ();
    }

    OppositeParallelLinesIntersectionType::IntersectionPlane_type& OppositeParallelLinesIntersectionType::
    IntersectionPlane ()
    {
      return this->IntersectionPlane_.get ();
    }

    void OppositeParallelLinesIntersectionType::
    IntersectionPlane (const IntersectionPlane_type& x)
    {
      this->IntersectionPlane_.set (x);
    }

    void OppositeParallelLinesIntersectionType::
    IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > x)
    {
      this->IntersectionPlane_.set (std::move (x));
    }

    const OppositeParallelLinesIntersectionType::IntersectionFeature_type& OppositeParallelLinesIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_.get ();
    }

    OppositeParallelLinesIntersectionType::IntersectionFeature_type& OppositeParallelLinesIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_.get ();
    }

    void OppositeParallelLinesIntersectionType::
    IntersectionFeature (const IntersectionFeature_type& x)
    {
      this->IntersectionFeature_.set (x);
    }

    void OppositeParallelLinesIntersectionType::
    IntersectionFeature (::std::unique_ptr< IntersectionFeature_type > x)
    {
      this->IntersectionFeature_.set (std::move (x));
    }


    // OppositeParallelLinesProjectionType
    //

    const OppositeParallelLinesProjectionType::ProjectionPlane_type& OppositeParallelLinesProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    OppositeParallelLinesProjectionType::ProjectionPlane_type& OppositeParallelLinesProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void OppositeParallelLinesProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void OppositeParallelLinesProjectionType::
    ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (std::move (x));
    }

    const OppositeParallelLinesProjectionType::ProjectionOppositeParallelLines_type& OppositeParallelLinesProjectionType::
    ProjectionOppositeParallelLines () const
    {
      return this->ProjectionOppositeParallelLines_.get ();
    }

    OppositeParallelLinesProjectionType::ProjectionOppositeParallelLines_type& OppositeParallelLinesProjectionType::
    ProjectionOppositeParallelLines ()
    {
      return this->ProjectionOppositeParallelLines_.get ();
    }

    void OppositeParallelLinesProjectionType::
    ProjectionOppositeParallelLines (const ProjectionOppositeParallelLines_type& x)
    {
      this->ProjectionOppositeParallelLines_.set (x);
    }

    void OppositeParallelLinesProjectionType::
    ProjectionOppositeParallelLines (::std::unique_ptr< ProjectionOppositeParallelLines_type > x)
    {
      this->ProjectionOppositeParallelLines_.set (std::move (x));
    }


    // OppositeParallelLinesCopyType
    //

    const OppositeParallelLinesCopyType::BaseOppositeParallelLines_type& OppositeParallelLinesCopyType::
    BaseOppositeParallelLines () const
    {
      return this->BaseOppositeParallelLines_.get ();
    }

    OppositeParallelLinesCopyType::BaseOppositeParallelLines_type& OppositeParallelLinesCopyType::
    BaseOppositeParallelLines ()
    {
      return this->BaseOppositeParallelLines_.get ();
    }

    void OppositeParallelLinesCopyType::
    BaseOppositeParallelLines (const BaseOppositeParallelLines_type& x)
    {
      this->BaseOppositeParallelLines_.set (x);
    }

    void OppositeParallelLinesCopyType::
    BaseOppositeParallelLines (::std::unique_ptr< BaseOppositeParallelLines_type > x)
    {
      this->BaseOppositeParallelLines_.set (std::move (x));
    }


    // OppositeParallelLinesCastType
    //

    const OppositeParallelLinesCastType::BaseFeature_type& OppositeParallelLinesCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    OppositeParallelLinesCastType::BaseFeature_type& OppositeParallelLinesCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void OppositeParallelLinesCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void OppositeParallelLinesCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // OppositeParallelLinesTransformType
    //

    const OppositeParallelLinesTransformType::BaseOppositeParallelLines_type& OppositeParallelLinesTransformType::
    BaseOppositeParallelLines () const
    {
      return this->BaseOppositeParallelLines_.get ();
    }

    OppositeParallelLinesTransformType::BaseOppositeParallelLines_type& OppositeParallelLinesTransformType::
    BaseOppositeParallelLines ()
    {
      return this->BaseOppositeParallelLines_.get ();
    }

    void OppositeParallelLinesTransformType::
    BaseOppositeParallelLines (const BaseOppositeParallelLines_type& x)
    {
      this->BaseOppositeParallelLines_.set (x);
    }

    void OppositeParallelLinesTransformType::
    BaseOppositeParallelLines (::std::unique_ptr< BaseOppositeParallelLines_type > x)
    {
      this->BaseOppositeParallelLines_.set (std::move (x));
    }

    const OppositeParallelLinesTransformType::Transformation_type& OppositeParallelLinesTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    OppositeParallelLinesTransformType::Transformation_type& OppositeParallelLinesTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void OppositeParallelLinesTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void OppositeParallelLinesTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // OppositeParallelLinesFromScanType
    //

    const OppositeParallelLinesFromScanType::SurfaceFeature_type& OppositeParallelLinesFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    OppositeParallelLinesFromScanType::SurfaceFeature_type& OppositeParallelLinesFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void OppositeParallelLinesFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void OppositeParallelLinesFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const OppositeParallelLinesFromScanType::SearchRadius_type& OppositeParallelLinesFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    OppositeParallelLinesFromScanType::SearchRadius_type& OppositeParallelLinesFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void OppositeParallelLinesFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void OppositeParallelLinesFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const OppositeParallelLinesFromScanType::Depth_type& OppositeParallelLinesFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    OppositeParallelLinesFromScanType::Depth_type& OppositeParallelLinesFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void OppositeParallelLinesFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositeParallelLinesFromScanType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }


    // OppositeParallelLinesCheckedType
    //

    const OppositeParallelLinesCheckedType::Measured_optional& OppositeParallelLinesCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OppositeParallelLinesCheckedType::Measured_optional& OppositeParallelLinesCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OppositeParallelLinesCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OppositeParallelLinesCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OppositeParallelLinesCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const OppositeParallelLinesCheckedType::Constructed_optional& OppositeParallelLinesCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeParallelLinesCheckedType::Constructed_optional& OppositeParallelLinesCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeParallelLinesCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeParallelLinesCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeParallelLinesCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OppositeParallelLinesCheckedFeatureType
    //

    const OppositeParallelLinesCheckedFeatureType::CheckDetails_optional& OppositeParallelLinesCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OppositeParallelLinesCheckedFeatureType::CheckDetails_optional& OppositeParallelLinesCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OppositeParallelLinesCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OppositeParallelLinesCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OppositeParallelLinesCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // OppositeParallelLinesMeasurementDeterminationType
    //

    const OppositeParallelLinesMeasurementDeterminationType::Checked_optional& OppositeParallelLinesMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OppositeParallelLinesMeasurementDeterminationType::Checked_optional& OppositeParallelLinesMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OppositeParallelLinesMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OppositeParallelLinesMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OppositeParallelLinesMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const OppositeParallelLinesMeasurementDeterminationType::Set_optional& OppositeParallelLinesMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OppositeParallelLinesMeasurementDeterminationType::Set_optional& OppositeParallelLinesMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OppositeParallelLinesMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OppositeParallelLinesMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OppositeParallelLinesMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // OppositeParallelLinesFeatureItemType
    //

    const OppositeParallelLinesFeatureItemType::DeterminationMode_type& OppositeParallelLinesFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OppositeParallelLinesFeatureItemType::DeterminationMode_type& OppositeParallelLinesFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OppositeParallelLinesFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OppositeParallelLinesFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // OppositeParallelLinesFeatureDefinitionType
    //

    const OppositeParallelLinesFeatureDefinitionType::InternalExternal_type& OppositeParallelLinesFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    OppositeParallelLinesFeatureDefinitionType::InternalExternal_type& OppositeParallelLinesFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void OppositeParallelLinesFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void OppositeParallelLinesFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureDefinitionType::Width_type& OppositeParallelLinesFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    OppositeParallelLinesFeatureDefinitionType::Width_type& OppositeParallelLinesFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void OppositeParallelLinesFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeParallelLinesFeatureDefinitionType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureDefinitionType::Length_optional& OppositeParallelLinesFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    OppositeParallelLinesFeatureDefinitionType::Length_optional& OppositeParallelLinesFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeParallelLinesFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeParallelLinesFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeParallelLinesFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureDefinitionType::EndType_type& OppositeParallelLinesFeatureDefinitionType::
    EndType () const
    {
      return this->EndType_.get ();
    }

    OppositeParallelLinesFeatureDefinitionType::EndType_type& OppositeParallelLinesFeatureDefinitionType::
    EndType ()
    {
      return this->EndType_.get ();
    }

    void OppositeParallelLinesFeatureDefinitionType::
    EndType (const EndType_type& x)
    {
      this->EndType_.set (x);
    }

    void OppositeParallelLinesFeatureDefinitionType::
    EndType (::std::unique_ptr< EndType_type > x)
    {
      this->EndType_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureDefinitionType::SingleOpenEnd_optional& OppositeParallelLinesFeatureDefinitionType::
    SingleOpenEnd () const
    {
      return this->SingleOpenEnd_;
    }

    OppositeParallelLinesFeatureDefinitionType::SingleOpenEnd_optional& OppositeParallelLinesFeatureDefinitionType::
    SingleOpenEnd ()
    {
      return this->SingleOpenEnd_;
    }

    void OppositeParallelLinesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_type& x)
    {
      this->SingleOpenEnd_.set (x);
    }

    void OppositeParallelLinesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_optional& x)
    {
      this->SingleOpenEnd_ = x;
    }

    const OppositeParallelLinesFeatureDefinitionType::EndRadius1_optional& OppositeParallelLinesFeatureDefinitionType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeParallelLinesFeatureDefinitionType::EndRadius1_optional& OppositeParallelLinesFeatureDefinitionType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeParallelLinesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeParallelLinesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeParallelLinesFeatureDefinitionType::
    EndRadius1 (::std::unique_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureDefinitionType::EndRadius2_optional& OppositeParallelLinesFeatureDefinitionType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeParallelLinesFeatureDefinitionType::EndRadius2_optional& OppositeParallelLinesFeatureDefinitionType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeParallelLinesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeParallelLinesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeParallelLinesFeatureDefinitionType::
    EndRadius2 (::std::unique_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (std::move (x));
    }


    // OppositeParallelLinesFeatureNominalType
    //

    const OppositeParallelLinesFeatureNominalType::CenterLine_type& OppositeParallelLinesFeatureNominalType::
    CenterLine () const
    {
      return this->CenterLine_.get ();
    }

    OppositeParallelLinesFeatureNominalType::CenterLine_type& OppositeParallelLinesFeatureNominalType::
    CenterLine ()
    {
      return this->CenterLine_.get ();
    }

    void OppositeParallelLinesFeatureNominalType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void OppositeParallelLinesFeatureNominalType::
    CenterLine (::std::unique_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureNominalType::Normal_type& OppositeParallelLinesFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    OppositeParallelLinesFeatureNominalType::Normal_type& OppositeParallelLinesFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void OppositeParallelLinesFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void OppositeParallelLinesFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureNominalType::Constructed_optional& OppositeParallelLinesFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeParallelLinesFeatureNominalType::Constructed_optional& OppositeParallelLinesFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeParallelLinesFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeParallelLinesFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeParallelLinesFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OppositeParallelLinesFeatureMeasurementType
    //

    const OppositeParallelLinesFeatureMeasurementType::CenterLine_optional& OppositeParallelLinesFeatureMeasurementType::
    CenterLine () const
    {
      return this->CenterLine_;
    }

    OppositeParallelLinesFeatureMeasurementType::CenterLine_optional& OppositeParallelLinesFeatureMeasurementType::
    CenterLine ()
    {
      return this->CenterLine_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    CenterLine (const CenterLine_optional& x)
    {
      this->CenterLine_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    CenterLine (::std::unique_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::Normal_optional& OppositeParallelLinesFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    OppositeParallelLinesFeatureMeasurementType::Normal_optional& OppositeParallelLinesFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::Width_optional& OppositeParallelLinesFeatureMeasurementType::
    Width () const
    {
      return this->Width_;
    }

    OppositeParallelLinesFeatureMeasurementType::Width_optional& OppositeParallelLinesFeatureMeasurementType::
    Width ()
    {
      return this->Width_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::WidthMin_optional& OppositeParallelLinesFeatureMeasurementType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    OppositeParallelLinesFeatureMeasurementType::WidthMin_optional& OppositeParallelLinesFeatureMeasurementType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    WidthMin (::std::unique_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::WidthMax_optional& OppositeParallelLinesFeatureMeasurementType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    OppositeParallelLinesFeatureMeasurementType::WidthMax_optional& OppositeParallelLinesFeatureMeasurementType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    WidthMax (::std::unique_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::Length_optional& OppositeParallelLinesFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    OppositeParallelLinesFeatureMeasurementType::Length_optional& OppositeParallelLinesFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::LengthMin_optional& OppositeParallelLinesFeatureMeasurementType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    OppositeParallelLinesFeatureMeasurementType::LengthMin_optional& OppositeParallelLinesFeatureMeasurementType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    LengthMin (::std::unique_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::LengthMax_optional& OppositeParallelLinesFeatureMeasurementType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    OppositeParallelLinesFeatureMeasurementType::LengthMax_optional& OppositeParallelLinesFeatureMeasurementType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    LengthMax (::std::unique_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::EndRadius1_optional& OppositeParallelLinesFeatureMeasurementType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeParallelLinesFeatureMeasurementType::EndRadius1_optional& OppositeParallelLinesFeatureMeasurementType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    EndRadius1 (::std::unique_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::EndRadius2_optional& OppositeParallelLinesFeatureMeasurementType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeParallelLinesFeatureMeasurementType::EndRadius2_optional& OppositeParallelLinesFeatureMeasurementType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    EndRadius2 (::std::unique_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (std::move (x));
    }

    const OppositeParallelLinesFeatureMeasurementType::Form_optional& OppositeParallelLinesFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    OppositeParallelLinesFeatureMeasurementType::Form_optional& OppositeParallelLinesFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void OppositeParallelLinesFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // OppositeAngledLinesConstructionMethodType
    //

    const OppositeAngledLinesConstructionMethodType::BestFit_optional& OppositeAngledLinesConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    OppositeAngledLinesConstructionMethodType::BestFit_optional& OppositeAngledLinesConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void OppositeAngledLinesConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void OppositeAngledLinesConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void OppositeAngledLinesConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const OppositeAngledLinesConstructionMethodType::Recompensated_optional& OppositeAngledLinesConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    OppositeAngledLinesConstructionMethodType::Recompensated_optional& OppositeAngledLinesConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void OppositeAngledLinesConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void OppositeAngledLinesConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void OppositeAngledLinesConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const OppositeAngledLinesConstructionMethodType::Intersection_optional& OppositeAngledLinesConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    OppositeAngledLinesConstructionMethodType::Intersection_optional& OppositeAngledLinesConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void OppositeAngledLinesConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void OppositeAngledLinesConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void OppositeAngledLinesConstructionMethodType::
    Intersection (::std::unique_ptr< Intersection_type > x)
    {
      this->Intersection_.set (std::move (x));
    }

    const OppositeAngledLinesConstructionMethodType::Projection_optional& OppositeAngledLinesConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    OppositeAngledLinesConstructionMethodType::Projection_optional& OppositeAngledLinesConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void OppositeAngledLinesConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void OppositeAngledLinesConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void OppositeAngledLinesConstructionMethodType::
    Projection (::std::unique_ptr< Projection_type > x)
    {
      this->Projection_.set (std::move (x));
    }

    const OppositeAngledLinesConstructionMethodType::Copy_optional& OppositeAngledLinesConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OppositeAngledLinesConstructionMethodType::Copy_optional& OppositeAngledLinesConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OppositeAngledLinesConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OppositeAngledLinesConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OppositeAngledLinesConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const OppositeAngledLinesConstructionMethodType::Cast_optional& OppositeAngledLinesConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    OppositeAngledLinesConstructionMethodType::Cast_optional& OppositeAngledLinesConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void OppositeAngledLinesConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void OppositeAngledLinesConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void OppositeAngledLinesConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const OppositeAngledLinesConstructionMethodType::Transform_optional& OppositeAngledLinesConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    OppositeAngledLinesConstructionMethodType::Transform_optional& OppositeAngledLinesConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void OppositeAngledLinesConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void OppositeAngledLinesConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void OppositeAngledLinesConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const OppositeAngledLinesConstructionMethodType::FromScan_optional& OppositeAngledLinesConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    OppositeAngledLinesConstructionMethodType::FromScan_optional& OppositeAngledLinesConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void OppositeAngledLinesConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void OppositeAngledLinesConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void OppositeAngledLinesConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // OppositeAngledLinesBestFitType
    //

    const OppositeAngledLinesBestFitType::BaseFeature_sequence& OppositeAngledLinesBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    OppositeAngledLinesBestFitType::BaseFeature_sequence& OppositeAngledLinesBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void OppositeAngledLinesBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const OppositeAngledLinesBestFitType::n_type& OppositeAngledLinesBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    OppositeAngledLinesBestFitType::n_type& OppositeAngledLinesBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void OppositeAngledLinesBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void OppositeAngledLinesBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // OppositeAngledLinesRecompType
    //

    const OppositeAngledLinesRecompType::BaseFeaturePointList_type& OppositeAngledLinesRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    OppositeAngledLinesRecompType::BaseFeaturePointList_type& OppositeAngledLinesRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void OppositeAngledLinesRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void OppositeAngledLinesRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // OppositeAngledLinesIntersectionType
    //

    const OppositeAngledLinesIntersectionType::IntersectionPlane_type& OppositeAngledLinesIntersectionType::
    IntersectionPlane () const
    {
      return this->IntersectionPlane_.get ();
    }

    OppositeAngledLinesIntersectionType::IntersectionPlane_type& OppositeAngledLinesIntersectionType::
    IntersectionPlane ()
    {
      return this->IntersectionPlane_.get ();
    }

    void OppositeAngledLinesIntersectionType::
    IntersectionPlane (const IntersectionPlane_type& x)
    {
      this->IntersectionPlane_.set (x);
    }

    void OppositeAngledLinesIntersectionType::
    IntersectionPlane (::std::unique_ptr< IntersectionPlane_type > x)
    {
      this->IntersectionPlane_.set (std::move (x));
    }

    const OppositeAngledLinesIntersectionType::IntersectionFeature_type& OppositeAngledLinesIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_.get ();
    }

    OppositeAngledLinesIntersectionType::IntersectionFeature_type& OppositeAngledLinesIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_.get ();
    }

    void OppositeAngledLinesIntersectionType::
    IntersectionFeature (const IntersectionFeature_type& x)
    {
      this->IntersectionFeature_.set (x);
    }

    void OppositeAngledLinesIntersectionType::
    IntersectionFeature (::std::unique_ptr< IntersectionFeature_type > x)
    {
      this->IntersectionFeature_.set (std::move (x));
    }


    // OppositeAngledLinesProjectionType
    //

    const OppositeAngledLinesProjectionType::ProjectionPlane_type& OppositeAngledLinesProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    OppositeAngledLinesProjectionType::ProjectionPlane_type& OppositeAngledLinesProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void OppositeAngledLinesProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void OppositeAngledLinesProjectionType::
    ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (std::move (x));
    }

    const OppositeAngledLinesProjectionType::ProjectionOppositeAngledLines_type& OppositeAngledLinesProjectionType::
    ProjectionOppositeAngledLines () const
    {
      return this->ProjectionOppositeAngledLines_.get ();
    }

    OppositeAngledLinesProjectionType::ProjectionOppositeAngledLines_type& OppositeAngledLinesProjectionType::
    ProjectionOppositeAngledLines ()
    {
      return this->ProjectionOppositeAngledLines_.get ();
    }

    void OppositeAngledLinesProjectionType::
    ProjectionOppositeAngledLines (const ProjectionOppositeAngledLines_type& x)
    {
      this->ProjectionOppositeAngledLines_.set (x);
    }

    void OppositeAngledLinesProjectionType::
    ProjectionOppositeAngledLines (::std::unique_ptr< ProjectionOppositeAngledLines_type > x)
    {
      this->ProjectionOppositeAngledLines_.set (std::move (x));
    }


    // OppositeAngledLinesCopyType
    //

    const OppositeAngledLinesCopyType::BaseOppositeAngledLines_type& OppositeAngledLinesCopyType::
    BaseOppositeAngledLines () const
    {
      return this->BaseOppositeAngledLines_.get ();
    }

    OppositeAngledLinesCopyType::BaseOppositeAngledLines_type& OppositeAngledLinesCopyType::
    BaseOppositeAngledLines ()
    {
      return this->BaseOppositeAngledLines_.get ();
    }

    void OppositeAngledLinesCopyType::
    BaseOppositeAngledLines (const BaseOppositeAngledLines_type& x)
    {
      this->BaseOppositeAngledLines_.set (x);
    }

    void OppositeAngledLinesCopyType::
    BaseOppositeAngledLines (::std::unique_ptr< BaseOppositeAngledLines_type > x)
    {
      this->BaseOppositeAngledLines_.set (std::move (x));
    }


    // OppositeAngledLinesCastType
    //

    const OppositeAngledLinesCastType::BaseFeature_type& OppositeAngledLinesCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    OppositeAngledLinesCastType::BaseFeature_type& OppositeAngledLinesCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void OppositeAngledLinesCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void OppositeAngledLinesCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // OppositeAngledLinesTransformType
    //

    const OppositeAngledLinesTransformType::BaseOppositeAngledLines_type& OppositeAngledLinesTransformType::
    BaseOppositeAngledLines () const
    {
      return this->BaseOppositeAngledLines_.get ();
    }

    OppositeAngledLinesTransformType::BaseOppositeAngledLines_type& OppositeAngledLinesTransformType::
    BaseOppositeAngledLines ()
    {
      return this->BaseOppositeAngledLines_.get ();
    }

    void OppositeAngledLinesTransformType::
    BaseOppositeAngledLines (const BaseOppositeAngledLines_type& x)
    {
      this->BaseOppositeAngledLines_.set (x);
    }

    void OppositeAngledLinesTransformType::
    BaseOppositeAngledLines (::std::unique_ptr< BaseOppositeAngledLines_type > x)
    {
      this->BaseOppositeAngledLines_.set (std::move (x));
    }

    const OppositeAngledLinesTransformType::Transformation_type& OppositeAngledLinesTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    OppositeAngledLinesTransformType::Transformation_type& OppositeAngledLinesTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void OppositeAngledLinesTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void OppositeAngledLinesTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // OppositeAngledLinesFromScanType
    //

    const OppositeAngledLinesFromScanType::SurfaceFeature_type& OppositeAngledLinesFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    OppositeAngledLinesFromScanType::SurfaceFeature_type& OppositeAngledLinesFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void OppositeAngledLinesFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void OppositeAngledLinesFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const OppositeAngledLinesFromScanType::SearchRadius_type& OppositeAngledLinesFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    OppositeAngledLinesFromScanType::SearchRadius_type& OppositeAngledLinesFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void OppositeAngledLinesFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void OppositeAngledLinesFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const OppositeAngledLinesFromScanType::Depth_type& OppositeAngledLinesFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    OppositeAngledLinesFromScanType::Depth_type& OppositeAngledLinesFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void OppositeAngledLinesFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositeAngledLinesFromScanType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }


    // OppositeAngledLinesCheckedType
    //

    const OppositeAngledLinesCheckedType::Measured_optional& OppositeAngledLinesCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OppositeAngledLinesCheckedType::Measured_optional& OppositeAngledLinesCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OppositeAngledLinesCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OppositeAngledLinesCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OppositeAngledLinesCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const OppositeAngledLinesCheckedType::Constructed_optional& OppositeAngledLinesCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeAngledLinesCheckedType::Constructed_optional& OppositeAngledLinesCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeAngledLinesCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeAngledLinesCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeAngledLinesCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OppositeAngledLinesCheckedFeatureType
    //

    const OppositeAngledLinesCheckedFeatureType::CheckDetails_optional& OppositeAngledLinesCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OppositeAngledLinesCheckedFeatureType::CheckDetails_optional& OppositeAngledLinesCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OppositeAngledLinesCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OppositeAngledLinesCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OppositeAngledLinesCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // OppositeAngledLinesMeasurementDeterminationType
    //

    const OppositeAngledLinesMeasurementDeterminationType::Checked_optional& OppositeAngledLinesMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OppositeAngledLinesMeasurementDeterminationType::Checked_optional& OppositeAngledLinesMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OppositeAngledLinesMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OppositeAngledLinesMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OppositeAngledLinesMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const OppositeAngledLinesMeasurementDeterminationType::Set_optional& OppositeAngledLinesMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OppositeAngledLinesMeasurementDeterminationType::Set_optional& OppositeAngledLinesMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OppositeAngledLinesMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OppositeAngledLinesMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OppositeAngledLinesMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // OppositeAngledLinesFeatureItemType
    //

    const OppositeAngledLinesFeatureItemType::DeterminationMode_type& OppositeAngledLinesFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OppositeAngledLinesFeatureItemType::DeterminationMode_type& OppositeAngledLinesFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OppositeAngledLinesFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OppositeAngledLinesFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // OppositeAngledLinesFeatureDefinitionType
    //

    const OppositeAngledLinesFeatureDefinitionType::InternalExternal_type& OppositeAngledLinesFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    OppositeAngledLinesFeatureDefinitionType::InternalExternal_type& OppositeAngledLinesFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void OppositeAngledLinesFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void OppositeAngledLinesFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureDefinitionType::Width_type& OppositeAngledLinesFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    OppositeAngledLinesFeatureDefinitionType::Width_type& OppositeAngledLinesFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void OppositeAngledLinesFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeAngledLinesFeatureDefinitionType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureDefinitionType::Length_optional& OppositeAngledLinesFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    OppositeAngledLinesFeatureDefinitionType::Length_optional& OppositeAngledLinesFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeAngledLinesFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeAngledLinesFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeAngledLinesFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureDefinitionType::EndType_type& OppositeAngledLinesFeatureDefinitionType::
    EndType () const
    {
      return this->EndType_.get ();
    }

    OppositeAngledLinesFeatureDefinitionType::EndType_type& OppositeAngledLinesFeatureDefinitionType::
    EndType ()
    {
      return this->EndType_.get ();
    }

    void OppositeAngledLinesFeatureDefinitionType::
    EndType (const EndType_type& x)
    {
      this->EndType_.set (x);
    }

    void OppositeAngledLinesFeatureDefinitionType::
    EndType (::std::unique_ptr< EndType_type > x)
    {
      this->EndType_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureDefinitionType::TaperAngle_type& OppositeAngledLinesFeatureDefinitionType::
    TaperAngle () const
    {
      return this->TaperAngle_.get ();
    }

    OppositeAngledLinesFeatureDefinitionType::TaperAngle_type& OppositeAngledLinesFeatureDefinitionType::
    TaperAngle ()
    {
      return this->TaperAngle_.get ();
    }

    void OppositeAngledLinesFeatureDefinitionType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositeAngledLinesFeatureDefinitionType::
    TaperAngle (::std::unique_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureDefinitionType::SingleOpenEnd_optional& OppositeAngledLinesFeatureDefinitionType::
    SingleOpenEnd () const
    {
      return this->SingleOpenEnd_;
    }

    OppositeAngledLinesFeatureDefinitionType::SingleOpenEnd_optional& OppositeAngledLinesFeatureDefinitionType::
    SingleOpenEnd ()
    {
      return this->SingleOpenEnd_;
    }

    void OppositeAngledLinesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_type& x)
    {
      this->SingleOpenEnd_.set (x);
    }

    void OppositeAngledLinesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_optional& x)
    {
      this->SingleOpenEnd_ = x;
    }

    const OppositeAngledLinesFeatureDefinitionType::EndRadius1_optional& OppositeAngledLinesFeatureDefinitionType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeAngledLinesFeatureDefinitionType::EndRadius1_optional& OppositeAngledLinesFeatureDefinitionType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeAngledLinesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeAngledLinesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeAngledLinesFeatureDefinitionType::
    EndRadius1 (::std::unique_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureDefinitionType::EndRadius2_optional& OppositeAngledLinesFeatureDefinitionType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeAngledLinesFeatureDefinitionType::EndRadius2_optional& OppositeAngledLinesFeatureDefinitionType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeAngledLinesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeAngledLinesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeAngledLinesFeatureDefinitionType::
    EndRadius2 (::std::unique_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (std::move (x));
    }


    // OppositeAngledLinesFeatureNominalType
    //

    const OppositeAngledLinesFeatureNominalType::CenterLine_type& OppositeAngledLinesFeatureNominalType::
    CenterLine () const
    {
      return this->CenterLine_.get ();
    }

    OppositeAngledLinesFeatureNominalType::CenterLine_type& OppositeAngledLinesFeatureNominalType::
    CenterLine ()
    {
      return this->CenterLine_.get ();
    }

    void OppositeAngledLinesFeatureNominalType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void OppositeAngledLinesFeatureNominalType::
    CenterLine (::std::unique_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureNominalType::Normal_type& OppositeAngledLinesFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    OppositeAngledLinesFeatureNominalType::Normal_type& OppositeAngledLinesFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void OppositeAngledLinesFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void OppositeAngledLinesFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureNominalType::Constructed_optional& OppositeAngledLinesFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeAngledLinesFeatureNominalType::Constructed_optional& OppositeAngledLinesFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeAngledLinesFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeAngledLinesFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeAngledLinesFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OppositeAngledLinesFeatureMeasurementType
    //

    const OppositeAngledLinesFeatureMeasurementType::CenterLine_optional& OppositeAngledLinesFeatureMeasurementType::
    CenterLine () const
    {
      return this->CenterLine_;
    }

    OppositeAngledLinesFeatureMeasurementType::CenterLine_optional& OppositeAngledLinesFeatureMeasurementType::
    CenterLine ()
    {
      return this->CenterLine_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    CenterLine (const CenterLine_optional& x)
    {
      this->CenterLine_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    CenterLine (::std::unique_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::Normal_optional& OppositeAngledLinesFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    OppositeAngledLinesFeatureMeasurementType::Normal_optional& OppositeAngledLinesFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::Width_optional& OppositeAngledLinesFeatureMeasurementType::
    Width () const
    {
      return this->Width_;
    }

    OppositeAngledLinesFeatureMeasurementType::Width_optional& OppositeAngledLinesFeatureMeasurementType::
    Width ()
    {
      return this->Width_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::WidthMin_optional& OppositeAngledLinesFeatureMeasurementType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    OppositeAngledLinesFeatureMeasurementType::WidthMin_optional& OppositeAngledLinesFeatureMeasurementType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    WidthMin (::std::unique_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::WidthMax_optional& OppositeAngledLinesFeatureMeasurementType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    OppositeAngledLinesFeatureMeasurementType::WidthMax_optional& OppositeAngledLinesFeatureMeasurementType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    WidthMax (::std::unique_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::Length_optional& OppositeAngledLinesFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    OppositeAngledLinesFeatureMeasurementType::Length_optional& OppositeAngledLinesFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::LengthMin_optional& OppositeAngledLinesFeatureMeasurementType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    OppositeAngledLinesFeatureMeasurementType::LengthMin_optional& OppositeAngledLinesFeatureMeasurementType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    LengthMin (::std::unique_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::LengthMax_optional& OppositeAngledLinesFeatureMeasurementType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    OppositeAngledLinesFeatureMeasurementType::LengthMax_optional& OppositeAngledLinesFeatureMeasurementType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    LengthMax (::std::unique_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::TaperAngle_optional& OppositeAngledLinesFeatureMeasurementType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositeAngledLinesFeatureMeasurementType::TaperAngle_optional& OppositeAngledLinesFeatureMeasurementType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    TaperAngle (::std::unique_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::EndRadius1_optional& OppositeAngledLinesFeatureMeasurementType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeAngledLinesFeatureMeasurementType::EndRadius1_optional& OppositeAngledLinesFeatureMeasurementType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    EndRadius1 (::std::unique_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::EndRadius2_optional& OppositeAngledLinesFeatureMeasurementType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeAngledLinesFeatureMeasurementType::EndRadius2_optional& OppositeAngledLinesFeatureMeasurementType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    EndRadius2 (::std::unique_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (std::move (x));
    }

    const OppositeAngledLinesFeatureMeasurementType::Form_optional& OppositeAngledLinesFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    OppositeAngledLinesFeatureMeasurementType::Form_optional& OppositeAngledLinesFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void OppositeAngledLinesFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // OppositeParallelPlanesConstructionMethodType
    //

    const OppositeParallelPlanesConstructionMethodType::BestFit_optional& OppositeParallelPlanesConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    OppositeParallelPlanesConstructionMethodType::BestFit_optional& OppositeParallelPlanesConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void OppositeParallelPlanesConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void OppositeParallelPlanesConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void OppositeParallelPlanesConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const OppositeParallelPlanesConstructionMethodType::Recompensated_optional& OppositeParallelPlanesConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    OppositeParallelPlanesConstructionMethodType::Recompensated_optional& OppositeParallelPlanesConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void OppositeParallelPlanesConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void OppositeParallelPlanesConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void OppositeParallelPlanesConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const OppositeParallelPlanesConstructionMethodType::Copy_optional& OppositeParallelPlanesConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OppositeParallelPlanesConstructionMethodType::Copy_optional& OppositeParallelPlanesConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OppositeParallelPlanesConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OppositeParallelPlanesConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OppositeParallelPlanesConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const OppositeParallelPlanesConstructionMethodType::Cast_optional& OppositeParallelPlanesConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    OppositeParallelPlanesConstructionMethodType::Cast_optional& OppositeParallelPlanesConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void OppositeParallelPlanesConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void OppositeParallelPlanesConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void OppositeParallelPlanesConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const OppositeParallelPlanesConstructionMethodType::Transform_optional& OppositeParallelPlanesConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    OppositeParallelPlanesConstructionMethodType::Transform_optional& OppositeParallelPlanesConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void OppositeParallelPlanesConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void OppositeParallelPlanesConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void OppositeParallelPlanesConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const OppositeParallelPlanesConstructionMethodType::FromScan_optional& OppositeParallelPlanesConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    OppositeParallelPlanesConstructionMethodType::FromScan_optional& OppositeParallelPlanesConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void OppositeParallelPlanesConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void OppositeParallelPlanesConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void OppositeParallelPlanesConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // OppositeParallelPlanesBestFitType
    //

    const OppositeParallelPlanesBestFitType::BaseFeature_sequence& OppositeParallelPlanesBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    OppositeParallelPlanesBestFitType::BaseFeature_sequence& OppositeParallelPlanesBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void OppositeParallelPlanesBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const OppositeParallelPlanesBestFitType::n_type& OppositeParallelPlanesBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    OppositeParallelPlanesBestFitType::n_type& OppositeParallelPlanesBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void OppositeParallelPlanesBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void OppositeParallelPlanesBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // OppositeParallelPlanesRecompType
    //

    const OppositeParallelPlanesRecompType::BaseFeaturePointList_type& OppositeParallelPlanesRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    OppositeParallelPlanesRecompType::BaseFeaturePointList_type& OppositeParallelPlanesRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void OppositeParallelPlanesRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void OppositeParallelPlanesRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // OppositeParallelPlanesCopyType
    //

    const OppositeParallelPlanesCopyType::BaseOppositeParallelPlanes_type& OppositeParallelPlanesCopyType::
    BaseOppositeParallelPlanes () const
    {
      return this->BaseOppositeParallelPlanes_.get ();
    }

    OppositeParallelPlanesCopyType::BaseOppositeParallelPlanes_type& OppositeParallelPlanesCopyType::
    BaseOppositeParallelPlanes ()
    {
      return this->BaseOppositeParallelPlanes_.get ();
    }

    void OppositeParallelPlanesCopyType::
    BaseOppositeParallelPlanes (const BaseOppositeParallelPlanes_type& x)
    {
      this->BaseOppositeParallelPlanes_.set (x);
    }

    void OppositeParallelPlanesCopyType::
    BaseOppositeParallelPlanes (::std::unique_ptr< BaseOppositeParallelPlanes_type > x)
    {
      this->BaseOppositeParallelPlanes_.set (std::move (x));
    }


    // OppositeParallelPlanesCastType
    //

    const OppositeParallelPlanesCastType::BaseFeature_type& OppositeParallelPlanesCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    OppositeParallelPlanesCastType::BaseFeature_type& OppositeParallelPlanesCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void OppositeParallelPlanesCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void OppositeParallelPlanesCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // OppositeParallelPlanesTransformType
    //

    const OppositeParallelPlanesTransformType::BaseOppositeParallelPlanes_type& OppositeParallelPlanesTransformType::
    BaseOppositeParallelPlanes () const
    {
      return this->BaseOppositeParallelPlanes_.get ();
    }

    OppositeParallelPlanesTransformType::BaseOppositeParallelPlanes_type& OppositeParallelPlanesTransformType::
    BaseOppositeParallelPlanes ()
    {
      return this->BaseOppositeParallelPlanes_.get ();
    }

    void OppositeParallelPlanesTransformType::
    BaseOppositeParallelPlanes (const BaseOppositeParallelPlanes_type& x)
    {
      this->BaseOppositeParallelPlanes_.set (x);
    }

    void OppositeParallelPlanesTransformType::
    BaseOppositeParallelPlanes (::std::unique_ptr< BaseOppositeParallelPlanes_type > x)
    {
      this->BaseOppositeParallelPlanes_.set (std::move (x));
    }

    const OppositeParallelPlanesTransformType::Transformation_type& OppositeParallelPlanesTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    OppositeParallelPlanesTransformType::Transformation_type& OppositeParallelPlanesTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void OppositeParallelPlanesTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void OppositeParallelPlanesTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // OppositeParallelPlanesFromScanType
    //

    const OppositeParallelPlanesFromScanType::SurfaceFeature_type& OppositeParallelPlanesFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    OppositeParallelPlanesFromScanType::SurfaceFeature_type& OppositeParallelPlanesFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void OppositeParallelPlanesFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void OppositeParallelPlanesFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const OppositeParallelPlanesFromScanType::SearchRadius_type& OppositeParallelPlanesFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    OppositeParallelPlanesFromScanType::SearchRadius_type& OppositeParallelPlanesFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void OppositeParallelPlanesFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void OppositeParallelPlanesFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }


    // OppositeParallelPlanesCheckedType
    //

    const OppositeParallelPlanesCheckedType::Measured_optional& OppositeParallelPlanesCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OppositeParallelPlanesCheckedType::Measured_optional& OppositeParallelPlanesCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OppositeParallelPlanesCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OppositeParallelPlanesCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OppositeParallelPlanesCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const OppositeParallelPlanesCheckedType::Constructed_optional& OppositeParallelPlanesCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeParallelPlanesCheckedType::Constructed_optional& OppositeParallelPlanesCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeParallelPlanesCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeParallelPlanesCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeParallelPlanesCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OppositeParallelPlanesCheckedFeatureType
    //

    const OppositeParallelPlanesCheckedFeatureType::CheckDetails_optional& OppositeParallelPlanesCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OppositeParallelPlanesCheckedFeatureType::CheckDetails_optional& OppositeParallelPlanesCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OppositeParallelPlanesCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OppositeParallelPlanesCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OppositeParallelPlanesCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // OppositeParallelPlanesMeasurementDeterminationType
    //

    const OppositeParallelPlanesMeasurementDeterminationType::Checked_optional& OppositeParallelPlanesMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OppositeParallelPlanesMeasurementDeterminationType::Checked_optional& OppositeParallelPlanesMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OppositeParallelPlanesMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OppositeParallelPlanesMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OppositeParallelPlanesMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const OppositeParallelPlanesMeasurementDeterminationType::Set_optional& OppositeParallelPlanesMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OppositeParallelPlanesMeasurementDeterminationType::Set_optional& OppositeParallelPlanesMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OppositeParallelPlanesMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OppositeParallelPlanesMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OppositeParallelPlanesMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // OppositeParallelPlanesFeatureItemType
    //

    const OppositeParallelPlanesFeatureItemType::DeterminationMode_type& OppositeParallelPlanesFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OppositeParallelPlanesFeatureItemType::DeterminationMode_type& OppositeParallelPlanesFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OppositeParallelPlanesFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OppositeParallelPlanesFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // OppositeParallelPlanesFeatureDefinitionType
    //

    const OppositeParallelPlanesFeatureDefinitionType::InternalExternal_type& OppositeParallelPlanesFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    OppositeParallelPlanesFeatureDefinitionType::InternalExternal_type& OppositeParallelPlanesFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureDefinitionType::Width_type& OppositeParallelPlanesFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    OppositeParallelPlanesFeatureDefinitionType::Width_type& OppositeParallelPlanesFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureDefinitionType::Length_optional& OppositeParallelPlanesFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    OppositeParallelPlanesFeatureDefinitionType::Length_optional& OppositeParallelPlanesFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureDefinitionType::EndType_type& OppositeParallelPlanesFeatureDefinitionType::
    EndType () const
    {
      return this->EndType_.get ();
    }

    OppositeParallelPlanesFeatureDefinitionType::EndType_type& OppositeParallelPlanesFeatureDefinitionType::
    EndType ()
    {
      return this->EndType_.get ();
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    EndType (const EndType_type& x)
    {
      this->EndType_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    EndType (::std::unique_ptr< EndType_type > x)
    {
      this->EndType_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureDefinitionType::Depth_optional& OppositeParallelPlanesFeatureDefinitionType::
    Depth () const
    {
      return this->Depth_;
    }

    OppositeParallelPlanesFeatureDefinitionType::Depth_optional& OppositeParallelPlanesFeatureDefinitionType::
    Depth ()
    {
      return this->Depth_;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureDefinitionType::Bottom_optional& OppositeParallelPlanesFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    OppositeParallelPlanesFeatureDefinitionType::Bottom_optional& OppositeParallelPlanesFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    Bottom (::std::unique_ptr< Bottom_type > x)
    {
      this->Bottom_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureDefinitionType::SingleOpenEnd_optional& OppositeParallelPlanesFeatureDefinitionType::
    SingleOpenEnd () const
    {
      return this->SingleOpenEnd_;
    }

    OppositeParallelPlanesFeatureDefinitionType::SingleOpenEnd_optional& OppositeParallelPlanesFeatureDefinitionType::
    SingleOpenEnd ()
    {
      return this->SingleOpenEnd_;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_type& x)
    {
      this->SingleOpenEnd_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_optional& x)
    {
      this->SingleOpenEnd_ = x;
    }

    const OppositeParallelPlanesFeatureDefinitionType::EndRadius1_optional& OppositeParallelPlanesFeatureDefinitionType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeParallelPlanesFeatureDefinitionType::EndRadius1_optional& OppositeParallelPlanesFeatureDefinitionType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    EndRadius1 (::std::unique_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureDefinitionType::EndRadius2_optional& OppositeParallelPlanesFeatureDefinitionType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeParallelPlanesFeatureDefinitionType::EndRadius2_optional& OppositeParallelPlanesFeatureDefinitionType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    EndRadius2 (::std::unique_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (std::move (x));
    }


    // OppositeParallelPlanesFeatureNominalType
    //

    const OppositeParallelPlanesFeatureNominalType::CenterPlane_type& OppositeParallelPlanesFeatureNominalType::
    CenterPlane () const
    {
      return this->CenterPlane_.get ();
    }

    OppositeParallelPlanesFeatureNominalType::CenterPlane_type& OppositeParallelPlanesFeatureNominalType::
    CenterPlane ()
    {
      return this->CenterPlane_.get ();
    }

    void OppositeParallelPlanesFeatureNominalType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void OppositeParallelPlanesFeatureNominalType::
    CenterPlane (::std::unique_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureNominalType::LengthVector_optional& OppositeParallelPlanesFeatureNominalType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    OppositeParallelPlanesFeatureNominalType::LengthVector_optional& OppositeParallelPlanesFeatureNominalType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void OppositeParallelPlanesFeatureNominalType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void OppositeParallelPlanesFeatureNominalType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void OppositeParallelPlanesFeatureNominalType::
    LengthVector (::std::unique_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureNominalType::DepthVector_optional& OppositeParallelPlanesFeatureNominalType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    OppositeParallelPlanesFeatureNominalType::DepthVector_optional& OppositeParallelPlanesFeatureNominalType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void OppositeParallelPlanesFeatureNominalType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void OppositeParallelPlanesFeatureNominalType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void OppositeParallelPlanesFeatureNominalType::
    DepthVector (::std::unique_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureNominalType::Constructed_optional& OppositeParallelPlanesFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeParallelPlanesFeatureNominalType::Constructed_optional& OppositeParallelPlanesFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeParallelPlanesFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeParallelPlanesFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeParallelPlanesFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OppositeParallelPlanesFeatureMeasurementType
    //

    const OppositeParallelPlanesFeatureMeasurementType::CenterPlane_optional& OppositeParallelPlanesFeatureMeasurementType::
    CenterPlane () const
    {
      return this->CenterPlane_;
    }

    OppositeParallelPlanesFeatureMeasurementType::CenterPlane_optional& OppositeParallelPlanesFeatureMeasurementType::
    CenterPlane ()
    {
      return this->CenterPlane_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    CenterPlane (const CenterPlane_optional& x)
    {
      this->CenterPlane_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    CenterPlane (::std::unique_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::LengthVector_optional& OppositeParallelPlanesFeatureMeasurementType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    OppositeParallelPlanesFeatureMeasurementType::LengthVector_optional& OppositeParallelPlanesFeatureMeasurementType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthVector (::std::unique_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::DepthVector_optional& OppositeParallelPlanesFeatureMeasurementType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    OppositeParallelPlanesFeatureMeasurementType::DepthVector_optional& OppositeParallelPlanesFeatureMeasurementType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    DepthVector (::std::unique_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::Width_optional& OppositeParallelPlanesFeatureMeasurementType::
    Width () const
    {
      return this->Width_;
    }

    OppositeParallelPlanesFeatureMeasurementType::Width_optional& OppositeParallelPlanesFeatureMeasurementType::
    Width ()
    {
      return this->Width_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::WidthMin_optional& OppositeParallelPlanesFeatureMeasurementType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    OppositeParallelPlanesFeatureMeasurementType::WidthMin_optional& OppositeParallelPlanesFeatureMeasurementType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    WidthMin (::std::unique_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::WidthMax_optional& OppositeParallelPlanesFeatureMeasurementType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    OppositeParallelPlanesFeatureMeasurementType::WidthMax_optional& OppositeParallelPlanesFeatureMeasurementType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    WidthMax (::std::unique_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::Length_optional& OppositeParallelPlanesFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    OppositeParallelPlanesFeatureMeasurementType::Length_optional& OppositeParallelPlanesFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::LengthMin_optional& OppositeParallelPlanesFeatureMeasurementType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    OppositeParallelPlanesFeatureMeasurementType::LengthMin_optional& OppositeParallelPlanesFeatureMeasurementType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthMin (::std::unique_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::LengthMax_optional& OppositeParallelPlanesFeatureMeasurementType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    OppositeParallelPlanesFeatureMeasurementType::LengthMax_optional& OppositeParallelPlanesFeatureMeasurementType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    LengthMax (::std::unique_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::Depth_optional& OppositeParallelPlanesFeatureMeasurementType::
    Depth () const
    {
      return this->Depth_;
    }

    OppositeParallelPlanesFeatureMeasurementType::Depth_optional& OppositeParallelPlanesFeatureMeasurementType::
    Depth ()
    {
      return this->Depth_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::EndRadius1_optional& OppositeParallelPlanesFeatureMeasurementType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeParallelPlanesFeatureMeasurementType::EndRadius1_optional& OppositeParallelPlanesFeatureMeasurementType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    EndRadius1 (::std::unique_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::EndRadius2_optional& OppositeParallelPlanesFeatureMeasurementType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeParallelPlanesFeatureMeasurementType::EndRadius2_optional& OppositeParallelPlanesFeatureMeasurementType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    EndRadius2 (::std::unique_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (std::move (x));
    }

    const OppositeParallelPlanesFeatureMeasurementType::Form_optional& OppositeParallelPlanesFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    OppositeParallelPlanesFeatureMeasurementType::Form_optional& OppositeParallelPlanesFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // OppositeAngledPlanesConstructionMethodType
    //

    const OppositeAngledPlanesConstructionMethodType::BestFit_optional& OppositeAngledPlanesConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    OppositeAngledPlanesConstructionMethodType::BestFit_optional& OppositeAngledPlanesConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void OppositeAngledPlanesConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void OppositeAngledPlanesConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void OppositeAngledPlanesConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const OppositeAngledPlanesConstructionMethodType::Recompensated_optional& OppositeAngledPlanesConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    OppositeAngledPlanesConstructionMethodType::Recompensated_optional& OppositeAngledPlanesConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void OppositeAngledPlanesConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void OppositeAngledPlanesConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void OppositeAngledPlanesConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const OppositeAngledPlanesConstructionMethodType::Copy_optional& OppositeAngledPlanesConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OppositeAngledPlanesConstructionMethodType::Copy_optional& OppositeAngledPlanesConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OppositeAngledPlanesConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OppositeAngledPlanesConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OppositeAngledPlanesConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const OppositeAngledPlanesConstructionMethodType::Cast_optional& OppositeAngledPlanesConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    OppositeAngledPlanesConstructionMethodType::Cast_optional& OppositeAngledPlanesConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void OppositeAngledPlanesConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void OppositeAngledPlanesConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void OppositeAngledPlanesConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const OppositeAngledPlanesConstructionMethodType::Transform_optional& OppositeAngledPlanesConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    OppositeAngledPlanesConstructionMethodType::Transform_optional& OppositeAngledPlanesConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void OppositeAngledPlanesConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void OppositeAngledPlanesConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void OppositeAngledPlanesConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const OppositeAngledPlanesConstructionMethodType::FromScan_optional& OppositeAngledPlanesConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    OppositeAngledPlanesConstructionMethodType::FromScan_optional& OppositeAngledPlanesConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void OppositeAngledPlanesConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void OppositeAngledPlanesConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void OppositeAngledPlanesConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // OppositeAngledPlanesBestFitType
    //

    const OppositeAngledPlanesBestFitType::BaseFeature_sequence& OppositeAngledPlanesBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    OppositeAngledPlanesBestFitType::BaseFeature_sequence& OppositeAngledPlanesBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void OppositeAngledPlanesBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const OppositeAngledPlanesBestFitType::n_type& OppositeAngledPlanesBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    OppositeAngledPlanesBestFitType::n_type& OppositeAngledPlanesBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void OppositeAngledPlanesBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void OppositeAngledPlanesBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // OppositeAngledPlanesRecompType
    //

    const OppositeAngledPlanesRecompType::BaseFeaturePointList_type& OppositeAngledPlanesRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    OppositeAngledPlanesRecompType::BaseFeaturePointList_type& OppositeAngledPlanesRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void OppositeAngledPlanesRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void OppositeAngledPlanesRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // OppositeAngledPlanesCopyType
    //

    const OppositeAngledPlanesCopyType::BaseOppositeAngledPlanes_type& OppositeAngledPlanesCopyType::
    BaseOppositeAngledPlanes () const
    {
      return this->BaseOppositeAngledPlanes_.get ();
    }

    OppositeAngledPlanesCopyType::BaseOppositeAngledPlanes_type& OppositeAngledPlanesCopyType::
    BaseOppositeAngledPlanes ()
    {
      return this->BaseOppositeAngledPlanes_.get ();
    }

    void OppositeAngledPlanesCopyType::
    BaseOppositeAngledPlanes (const BaseOppositeAngledPlanes_type& x)
    {
      this->BaseOppositeAngledPlanes_.set (x);
    }

    void OppositeAngledPlanesCopyType::
    BaseOppositeAngledPlanes (::std::unique_ptr< BaseOppositeAngledPlanes_type > x)
    {
      this->BaseOppositeAngledPlanes_.set (std::move (x));
    }


    // OppositeAngledPlanesCastType
    //

    const OppositeAngledPlanesCastType::BaseFeature_type& OppositeAngledPlanesCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    OppositeAngledPlanesCastType::BaseFeature_type& OppositeAngledPlanesCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void OppositeAngledPlanesCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void OppositeAngledPlanesCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // OppositeAngledPlanesTransformType
    //

    const OppositeAngledPlanesTransformType::BaseOppositeAngledPlanes_type& OppositeAngledPlanesTransformType::
    BaseOppositeAngledPlanes () const
    {
      return this->BaseOppositeAngledPlanes_.get ();
    }

    OppositeAngledPlanesTransformType::BaseOppositeAngledPlanes_type& OppositeAngledPlanesTransformType::
    BaseOppositeAngledPlanes ()
    {
      return this->BaseOppositeAngledPlanes_.get ();
    }

    void OppositeAngledPlanesTransformType::
    BaseOppositeAngledPlanes (const BaseOppositeAngledPlanes_type& x)
    {
      this->BaseOppositeAngledPlanes_.set (x);
    }

    void OppositeAngledPlanesTransformType::
    BaseOppositeAngledPlanes (::std::unique_ptr< BaseOppositeAngledPlanes_type > x)
    {
      this->BaseOppositeAngledPlanes_.set (std::move (x));
    }

    const OppositeAngledPlanesTransformType::Transformation_type& OppositeAngledPlanesTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    OppositeAngledPlanesTransformType::Transformation_type& OppositeAngledPlanesTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void OppositeAngledPlanesTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void OppositeAngledPlanesTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // OppositeAngledPlanesFromScanType
    //

    const OppositeAngledPlanesFromScanType::SurfaceFeature_type& OppositeAngledPlanesFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    OppositeAngledPlanesFromScanType::SurfaceFeature_type& OppositeAngledPlanesFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void OppositeAngledPlanesFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void OppositeAngledPlanesFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const OppositeAngledPlanesFromScanType::SearchRadius_type& OppositeAngledPlanesFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    OppositeAngledPlanesFromScanType::SearchRadius_type& OppositeAngledPlanesFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void OppositeAngledPlanesFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void OppositeAngledPlanesFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }


    // OppositeAngledPlanesCheckedType
    //

    const OppositeAngledPlanesCheckedType::Measured_optional& OppositeAngledPlanesCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OppositeAngledPlanesCheckedType::Measured_optional& OppositeAngledPlanesCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OppositeAngledPlanesCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OppositeAngledPlanesCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OppositeAngledPlanesCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const OppositeAngledPlanesCheckedType::Constructed_optional& OppositeAngledPlanesCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeAngledPlanesCheckedType::Constructed_optional& OppositeAngledPlanesCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeAngledPlanesCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeAngledPlanesCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeAngledPlanesCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OppositeAngledPlanesCheckedFeatureType
    //

    const OppositeAngledPlanesCheckedFeatureType::CheckDetails_optional& OppositeAngledPlanesCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OppositeAngledPlanesCheckedFeatureType::CheckDetails_optional& OppositeAngledPlanesCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OppositeAngledPlanesCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OppositeAngledPlanesCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OppositeAngledPlanesCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // OppositeAngledPlanesMeasurementDeterminationType
    //

    const OppositeAngledPlanesMeasurementDeterminationType::Checked_optional& OppositeAngledPlanesMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OppositeAngledPlanesMeasurementDeterminationType::Checked_optional& OppositeAngledPlanesMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OppositeAngledPlanesMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OppositeAngledPlanesMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OppositeAngledPlanesMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const OppositeAngledPlanesMeasurementDeterminationType::Set_optional& OppositeAngledPlanesMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OppositeAngledPlanesMeasurementDeterminationType::Set_optional& OppositeAngledPlanesMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OppositeAngledPlanesMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OppositeAngledPlanesMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OppositeAngledPlanesMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // OppositeAngledPlanesFeatureItemType
    //

    const OppositeAngledPlanesFeatureItemType::DeterminationMode_type& OppositeAngledPlanesFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OppositeAngledPlanesFeatureItemType::DeterminationMode_type& OppositeAngledPlanesFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OppositeAngledPlanesFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OppositeAngledPlanesFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // OppositeAngledPlanesFeatureDefinitionType
    //

    const OppositeAngledPlanesFeatureDefinitionType::InternalExternal_type& OppositeAngledPlanesFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    OppositeAngledPlanesFeatureDefinitionType::InternalExternal_type& OppositeAngledPlanesFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::Width_type& OppositeAngledPlanesFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    OppositeAngledPlanesFeatureDefinitionType::Width_type& OppositeAngledPlanesFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::Length_optional& OppositeAngledPlanesFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    OppositeAngledPlanesFeatureDefinitionType::Length_optional& OppositeAngledPlanesFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::EndType_type& OppositeAngledPlanesFeatureDefinitionType::
    EndType () const
    {
      return this->EndType_.get ();
    }

    OppositeAngledPlanesFeatureDefinitionType::EndType_type& OppositeAngledPlanesFeatureDefinitionType::
    EndType ()
    {
      return this->EndType_.get ();
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    EndType (const EndType_type& x)
    {
      this->EndType_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    EndType (::std::unique_ptr< EndType_type > x)
    {
      this->EndType_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::Depth_optional& OppositeAngledPlanesFeatureDefinitionType::
    Depth () const
    {
      return this->Depth_;
    }

    OppositeAngledPlanesFeatureDefinitionType::Depth_optional& OppositeAngledPlanesFeatureDefinitionType::
    Depth ()
    {
      return this->Depth_;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::Bottom_optional& OppositeAngledPlanesFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    OppositeAngledPlanesFeatureDefinitionType::Bottom_optional& OppositeAngledPlanesFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    Bottom (::std::unique_ptr< Bottom_type > x)
    {
      this->Bottom_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::SingleOpenEnd_optional& OppositeAngledPlanesFeatureDefinitionType::
    SingleOpenEnd () const
    {
      return this->SingleOpenEnd_;
    }

    OppositeAngledPlanesFeatureDefinitionType::SingleOpenEnd_optional& OppositeAngledPlanesFeatureDefinitionType::
    SingleOpenEnd ()
    {
      return this->SingleOpenEnd_;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_type& x)
    {
      this->SingleOpenEnd_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_optional& x)
    {
      this->SingleOpenEnd_ = x;
    }

    const OppositeAngledPlanesFeatureDefinitionType::EndRadius1_optional& OppositeAngledPlanesFeatureDefinitionType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeAngledPlanesFeatureDefinitionType::EndRadius1_optional& OppositeAngledPlanesFeatureDefinitionType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    EndRadius1 (::std::unique_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::EndRadius2_optional& OppositeAngledPlanesFeatureDefinitionType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeAngledPlanesFeatureDefinitionType::EndRadius2_optional& OppositeAngledPlanesFeatureDefinitionType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    EndRadius2 (::std::unique_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::TaperAngle_optional& OppositeAngledPlanesFeatureDefinitionType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositeAngledPlanesFeatureDefinitionType::TaperAngle_optional& OppositeAngledPlanesFeatureDefinitionType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    TaperAngle (::std::unique_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureDefinitionType::DraftAngle_optional& OppositeAngledPlanesFeatureDefinitionType::
    DraftAngle () const
    {
      return this->DraftAngle_;
    }

    OppositeAngledPlanesFeatureDefinitionType::DraftAngle_optional& OppositeAngledPlanesFeatureDefinitionType::
    DraftAngle ()
    {
      return this->DraftAngle_;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    DraftAngle (const DraftAngle_type& x)
    {
      this->DraftAngle_.set (x);
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    DraftAngle (const DraftAngle_optional& x)
    {
      this->DraftAngle_ = x;
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    DraftAngle (::std::unique_ptr< DraftAngle_type > x)
    {
      this->DraftAngle_.set (std::move (x));
    }


    // OppositeAngledPlanesFeatureNominalType
    //

    const OppositeAngledPlanesFeatureNominalType::CenterPlane_type& OppositeAngledPlanesFeatureNominalType::
    CenterPlane () const
    {
      return this->CenterPlane_.get ();
    }

    OppositeAngledPlanesFeatureNominalType::CenterPlane_type& OppositeAngledPlanesFeatureNominalType::
    CenterPlane ()
    {
      return this->CenterPlane_.get ();
    }

    void OppositeAngledPlanesFeatureNominalType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void OppositeAngledPlanesFeatureNominalType::
    CenterPlane (::std::unique_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureNominalType::LengthVector_optional& OppositeAngledPlanesFeatureNominalType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    OppositeAngledPlanesFeatureNominalType::LengthVector_optional& OppositeAngledPlanesFeatureNominalType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void OppositeAngledPlanesFeatureNominalType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void OppositeAngledPlanesFeatureNominalType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void OppositeAngledPlanesFeatureNominalType::
    LengthVector (::std::unique_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureNominalType::DepthVector_optional& OppositeAngledPlanesFeatureNominalType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    OppositeAngledPlanesFeatureNominalType::DepthVector_optional& OppositeAngledPlanesFeatureNominalType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void OppositeAngledPlanesFeatureNominalType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void OppositeAngledPlanesFeatureNominalType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void OppositeAngledPlanesFeatureNominalType::
    DepthVector (::std::unique_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureNominalType::DraftVector_optional& OppositeAngledPlanesFeatureNominalType::
    DraftVector () const
    {
      return this->DraftVector_;
    }

    OppositeAngledPlanesFeatureNominalType::DraftVector_optional& OppositeAngledPlanesFeatureNominalType::
    DraftVector ()
    {
      return this->DraftVector_;
    }

    void OppositeAngledPlanesFeatureNominalType::
    DraftVector (const DraftVector_type& x)
    {
      this->DraftVector_.set (x);
    }

    void OppositeAngledPlanesFeatureNominalType::
    DraftVector (const DraftVector_optional& x)
    {
      this->DraftVector_ = x;
    }

    void OppositeAngledPlanesFeatureNominalType::
    DraftVector (::std::unique_ptr< DraftVector_type > x)
    {
      this->DraftVector_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureNominalType::Constructed_optional& OppositeAngledPlanesFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeAngledPlanesFeatureNominalType::Constructed_optional& OppositeAngledPlanesFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeAngledPlanesFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeAngledPlanesFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeAngledPlanesFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OppositeAngledPlanesFeatureMeasurementType
    //

    const OppositeAngledPlanesFeatureMeasurementType::CenterPlane_optional& OppositeAngledPlanesFeatureMeasurementType::
    CenterPlane () const
    {
      return this->CenterPlane_;
    }

    OppositeAngledPlanesFeatureMeasurementType::CenterPlane_optional& OppositeAngledPlanesFeatureMeasurementType::
    CenterPlane ()
    {
      return this->CenterPlane_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    CenterPlane (const CenterPlane_optional& x)
    {
      this->CenterPlane_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    CenterPlane (::std::unique_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::LengthVector_optional& OppositeAngledPlanesFeatureMeasurementType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    OppositeAngledPlanesFeatureMeasurementType::LengthVector_optional& OppositeAngledPlanesFeatureMeasurementType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthVector (::std::unique_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::DepthVector_optional& OppositeAngledPlanesFeatureMeasurementType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    OppositeAngledPlanesFeatureMeasurementType::DepthVector_optional& OppositeAngledPlanesFeatureMeasurementType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    DepthVector (::std::unique_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::Width_optional& OppositeAngledPlanesFeatureMeasurementType::
    Width () const
    {
      return this->Width_;
    }

    OppositeAngledPlanesFeatureMeasurementType::Width_optional& OppositeAngledPlanesFeatureMeasurementType::
    Width ()
    {
      return this->Width_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Width (::std::unique_ptr< Width_type > x)
    {
      this->Width_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::WidthMin_optional& OppositeAngledPlanesFeatureMeasurementType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    OppositeAngledPlanesFeatureMeasurementType::WidthMin_optional& OppositeAngledPlanesFeatureMeasurementType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    WidthMin (::std::unique_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::WidthMax_optional& OppositeAngledPlanesFeatureMeasurementType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    OppositeAngledPlanesFeatureMeasurementType::WidthMax_optional& OppositeAngledPlanesFeatureMeasurementType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    WidthMax (::std::unique_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::Length_optional& OppositeAngledPlanesFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    OppositeAngledPlanesFeatureMeasurementType::Length_optional& OppositeAngledPlanesFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::LengthMin_optional& OppositeAngledPlanesFeatureMeasurementType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    OppositeAngledPlanesFeatureMeasurementType::LengthMin_optional& OppositeAngledPlanesFeatureMeasurementType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthMin (::std::unique_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::LengthMax_optional& OppositeAngledPlanesFeatureMeasurementType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    OppositeAngledPlanesFeatureMeasurementType::LengthMax_optional& OppositeAngledPlanesFeatureMeasurementType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    LengthMax (::std::unique_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::Depth_optional& OppositeAngledPlanesFeatureMeasurementType::
    Depth () const
    {
      return this->Depth_;
    }

    OppositeAngledPlanesFeatureMeasurementType::Depth_optional& OppositeAngledPlanesFeatureMeasurementType::
    Depth ()
    {
      return this->Depth_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Depth (::std::unique_ptr< Depth_type > x)
    {
      this->Depth_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::TaperAngle_optional& OppositeAngledPlanesFeatureMeasurementType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositeAngledPlanesFeatureMeasurementType::TaperAngle_optional& OppositeAngledPlanesFeatureMeasurementType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    TaperAngle (::std::unique_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::DraftAngle_optional& OppositeAngledPlanesFeatureMeasurementType::
    DraftAngle () const
    {
      return this->DraftAngle_;
    }

    OppositeAngledPlanesFeatureMeasurementType::DraftAngle_optional& OppositeAngledPlanesFeatureMeasurementType::
    DraftAngle ()
    {
      return this->DraftAngle_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    DraftAngle (const DraftAngle_type& x)
    {
      this->DraftAngle_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    DraftAngle (const DraftAngle_optional& x)
    {
      this->DraftAngle_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    DraftAngle (::std::unique_ptr< DraftAngle_type > x)
    {
      this->DraftAngle_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::EndRadius1_optional& OppositeAngledPlanesFeatureMeasurementType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeAngledPlanesFeatureMeasurementType::EndRadius1_optional& OppositeAngledPlanesFeatureMeasurementType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    EndRadius1 (::std::unique_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::EndRadius2_optional& OppositeAngledPlanesFeatureMeasurementType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeAngledPlanesFeatureMeasurementType::EndRadius2_optional& OppositeAngledPlanesFeatureMeasurementType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    EndRadius2 (::std::unique_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (std::move (x));
    }

    const OppositeAngledPlanesFeatureMeasurementType::Form_optional& OppositeAngledPlanesFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    OppositeAngledPlanesFeatureMeasurementType::Form_optional& OppositeAngledPlanesFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // OtherCurveConstructionMethodType
    //

    const OtherCurveConstructionMethodType::Copy_optional& OtherCurveConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OtherCurveConstructionMethodType::Copy_optional& OtherCurveConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OtherCurveConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OtherCurveConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OtherCurveConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }


    // OtherCurveFeatureCopyType
    //

    const OtherCurveFeatureCopyType::BaseOtherCurveFeature_type& OtherCurveFeatureCopyType::
    BaseOtherCurveFeature () const
    {
      return this->BaseOtherCurveFeature_.get ();
    }

    OtherCurveFeatureCopyType::BaseOtherCurveFeature_type& OtherCurveFeatureCopyType::
    BaseOtherCurveFeature ()
    {
      return this->BaseOtherCurveFeature_.get ();
    }

    void OtherCurveFeatureCopyType::
    BaseOtherCurveFeature (const BaseOtherCurveFeature_type& x)
    {
      this->BaseOtherCurveFeature_.set (x);
    }

    void OtherCurveFeatureCopyType::
    BaseOtherCurveFeature (::std::unique_ptr< BaseOtherCurveFeature_type > x)
    {
      this->BaseOtherCurveFeature_.set (std::move (x));
    }


    // OtherCurveCheckedType
    //

    const OtherCurveCheckedType::Measured_optional& OtherCurveCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OtherCurveCheckedType::Measured_optional& OtherCurveCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OtherCurveCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OtherCurveCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OtherCurveCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const OtherCurveCheckedType::Constructed_optional& OtherCurveCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OtherCurveCheckedType::Constructed_optional& OtherCurveCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OtherCurveCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OtherCurveCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OtherCurveCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OtherCurveCheckedFeatureType
    //

    const OtherCurveCheckedFeatureType::CheckDetails_optional& OtherCurveCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OtherCurveCheckedFeatureType::CheckDetails_optional& OtherCurveCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OtherCurveCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OtherCurveCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OtherCurveCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // OtherCurveMeasurementDeterminationType
    //

    const OtherCurveMeasurementDeterminationType::Checked_optional& OtherCurveMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OtherCurveMeasurementDeterminationType::Checked_optional& OtherCurveMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OtherCurveMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OtherCurveMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OtherCurveMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const OtherCurveMeasurementDeterminationType::Set_optional& OtherCurveMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OtherCurveMeasurementDeterminationType::Set_optional& OtherCurveMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OtherCurveMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OtherCurveMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OtherCurveMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // OtherCurveFeatureItemType
    //

    const OtherCurveFeatureItemType::DeterminationMode_type& OtherCurveFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OtherCurveFeatureItemType::DeterminationMode_type& OtherCurveFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OtherCurveFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OtherCurveFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // OtherCurveFeatureDefinitionType
    //


    // OtherCurveFeatureNominalType
    //

    const OtherCurveFeatureNominalType::Constructed_optional& OtherCurveFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OtherCurveFeatureNominalType::Constructed_optional& OtherCurveFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OtherCurveFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OtherCurveFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OtherCurveFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OtherCurveFeatureMeasurementType
    //


    // OtherNonShapeFeatureItemType
    //


    // OtherNonShapeFeatureDefinitionType
    //

    const OtherNonShapeFeatureDefinitionType::Description_type& OtherNonShapeFeatureDefinitionType::
    Description () const
    {
      return this->Description_.get ();
    }

    OtherNonShapeFeatureDefinitionType::Description_type& OtherNonShapeFeatureDefinitionType::
    Description ()
    {
      return this->Description_.get ();
    }

    void OtherNonShapeFeatureDefinitionType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void OtherNonShapeFeatureDefinitionType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }


    // OtherNonShapeFeatureNominalType
    //

    const OtherNonShapeFeatureNominalType::ReferenceFeatureNominalIds_optional& OtherNonShapeFeatureNominalType::
    ReferenceFeatureNominalIds () const
    {
      return this->ReferenceFeatureNominalIds_;
    }

    OtherNonShapeFeatureNominalType::ReferenceFeatureNominalIds_optional& OtherNonShapeFeatureNominalType::
    ReferenceFeatureNominalIds ()
    {
      return this->ReferenceFeatureNominalIds_;
    }

    void OtherNonShapeFeatureNominalType::
    ReferenceFeatureNominalIds (const ReferenceFeatureNominalIds_type& x)
    {
      this->ReferenceFeatureNominalIds_.set (x);
    }

    void OtherNonShapeFeatureNominalType::
    ReferenceFeatureNominalIds (const ReferenceFeatureNominalIds_optional& x)
    {
      this->ReferenceFeatureNominalIds_ = x;
    }

    void OtherNonShapeFeatureNominalType::
    ReferenceFeatureNominalIds (::std::unique_ptr< ReferenceFeatureNominalIds_type > x)
    {
      this->ReferenceFeatureNominalIds_.set (std::move (x));
    }


    // OtherNonShapeFeatureMeasurementType
    //


    // MarkingMethodEnumType
    //

    MarkingMethodEnumType::
    MarkingMethodEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    MarkingMethodEnumType::
    MarkingMethodEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_MarkingMethodEnumType_literals_[v])
    {
    }

    MarkingMethodEnumType::
    MarkingMethodEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MarkingMethodEnumType::
    MarkingMethodEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MarkingMethodEnumType::
    MarkingMethodEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MarkingMethodEnumType::
    MarkingMethodEnumType (const MarkingMethodEnumType& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    MarkingMethodEnumType& MarkingMethodEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_MarkingMethodEnumType_literals_[v]);

      return *this;
    }


    // MarkingMethodType
    //

    const MarkingMethodType::MarkingMethodEnum_optional& MarkingMethodType::
    MarkingMethodEnum () const
    {
      return this->MarkingMethodEnum_;
    }

    MarkingMethodType::MarkingMethodEnum_optional& MarkingMethodType::
    MarkingMethodEnum ()
    {
      return this->MarkingMethodEnum_;
    }

    void MarkingMethodType::
    MarkingMethodEnum (const MarkingMethodEnum_type& x)
    {
      this->MarkingMethodEnum_.set (x);
    }

    void MarkingMethodType::
    MarkingMethodEnum (const MarkingMethodEnum_optional& x)
    {
      this->MarkingMethodEnum_ = x;
    }

    void MarkingMethodType::
    MarkingMethodEnum (::std::unique_ptr< MarkingMethodEnum_type > x)
    {
      this->MarkingMethodEnum_.set (std::move (x));
    }

    const MarkingMethodType::OtherMarkingMethod_optional& MarkingMethodType::
    OtherMarkingMethod () const
    {
      return this->OtherMarkingMethod_;
    }

    MarkingMethodType::OtherMarkingMethod_optional& MarkingMethodType::
    OtherMarkingMethod ()
    {
      return this->OtherMarkingMethod_;
    }

    void MarkingMethodType::
    OtherMarkingMethod (const OtherMarkingMethod_type& x)
    {
      this->OtherMarkingMethod_.set (x);
    }

    void MarkingMethodType::
    OtherMarkingMethod (const OtherMarkingMethod_optional& x)
    {
      this->OtherMarkingMethod_ = x;
    }

    void MarkingMethodType::
    OtherMarkingMethod (::std::unique_ptr< OtherMarkingMethod_type > x)
    {
      this->OtherMarkingMethod_.set (std::move (x));
    }


    // MarkingFeatureItemType
    //


    // MarkingFeatureDefinitionType
    //

    const MarkingFeatureDefinitionType::Text_type& MarkingFeatureDefinitionType::
    Text () const
    {
      return this->Text_.get ();
    }

    MarkingFeatureDefinitionType::Text_type& MarkingFeatureDefinitionType::
    Text ()
    {
      return this->Text_.get ();
    }

    void MarkingFeatureDefinitionType::
    Text (const Text_type& x)
    {
      this->Text_.set (x);
    }

    void MarkingFeatureDefinitionType::
    Text (::std::unique_ptr< Text_type > x)
    {
      this->Text_.set (std::move (x));
    }

    const MarkingFeatureDefinitionType::MarkingMethod_type& MarkingFeatureDefinitionType::
    MarkingMethod () const
    {
      return this->MarkingMethod_.get ();
    }

    MarkingFeatureDefinitionType::MarkingMethod_type& MarkingFeatureDefinitionType::
    MarkingMethod ()
    {
      return this->MarkingMethod_.get ();
    }

    void MarkingFeatureDefinitionType::
    MarkingMethod (const MarkingMethod_type& x)
    {
      this->MarkingMethod_.set (x);
    }

    void MarkingFeatureDefinitionType::
    MarkingMethod (::std::unique_ptr< MarkingMethod_type > x)
    {
      this->MarkingMethod_.set (std::move (x));
    }


    // MarkingFeatureNominalType
    //

    const MarkingFeatureNominalType::Location_type& MarkingFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    MarkingFeatureNominalType::Location_type& MarkingFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void MarkingFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void MarkingFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }


    // MarkingFeatureMeasurementType
    //

    const MarkingFeatureMeasurementType::Text_type& MarkingFeatureMeasurementType::
    Text () const
    {
      return this->Text_.get ();
    }

    MarkingFeatureMeasurementType::Text_type& MarkingFeatureMeasurementType::
    Text ()
    {
      return this->Text_.get ();
    }

    void MarkingFeatureMeasurementType::
    Text (const Text_type& x)
    {
      this->Text_.set (x);
    }

    void MarkingFeatureMeasurementType::
    Text (::std::unique_ptr< Text_type > x)
    {
      this->Text_.set (std::move (x));
    }

    const MarkingFeatureMeasurementType::Location_type& MarkingFeatureMeasurementType::
    Location () const
    {
      return this->Location_.get ();
    }

    MarkingFeatureMeasurementType::Location_type& MarkingFeatureMeasurementType::
    Location ()
    {
      return this->Location_.get ();
    }

    void MarkingFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void MarkingFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }


    // OtherShapeConstructionMethodType
    //

    const OtherShapeConstructionMethodType::Copy_optional& OtherShapeConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OtherShapeConstructionMethodType::Copy_optional& OtherShapeConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OtherShapeConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OtherShapeConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OtherShapeConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }


    // OtherShapeFeatureCopyType
    //

    const OtherShapeFeatureCopyType::BaseOtherShapeFeature_type& OtherShapeFeatureCopyType::
    BaseOtherShapeFeature () const
    {
      return this->BaseOtherShapeFeature_.get ();
    }

    OtherShapeFeatureCopyType::BaseOtherShapeFeature_type& OtherShapeFeatureCopyType::
    BaseOtherShapeFeature ()
    {
      return this->BaseOtherShapeFeature_.get ();
    }

    void OtherShapeFeatureCopyType::
    BaseOtherShapeFeature (const BaseOtherShapeFeature_type& x)
    {
      this->BaseOtherShapeFeature_.set (x);
    }

    void OtherShapeFeatureCopyType::
    BaseOtherShapeFeature (::std::unique_ptr< BaseOtherShapeFeature_type > x)
    {
      this->BaseOtherShapeFeature_.set (std::move (x));
    }


    // OtherShapeCheckedType
    //

    const OtherShapeCheckedType::Measured_optional& OtherShapeCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OtherShapeCheckedType::Measured_optional& OtherShapeCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OtherShapeCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OtherShapeCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OtherShapeCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const OtherShapeCheckedType::Constructed_optional& OtherShapeCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OtherShapeCheckedType::Constructed_optional& OtherShapeCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OtherShapeCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OtherShapeCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OtherShapeCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OtherShapeCheckedFeatureType
    //

    const OtherShapeCheckedFeatureType::CheckDetails_optional& OtherShapeCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OtherShapeCheckedFeatureType::CheckDetails_optional& OtherShapeCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OtherShapeCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OtherShapeCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OtherShapeCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // OtherShapeMeasurementDeterminationType
    //

    const OtherShapeMeasurementDeterminationType::Checked_optional& OtherShapeMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OtherShapeMeasurementDeterminationType::Checked_optional& OtherShapeMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OtherShapeMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OtherShapeMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OtherShapeMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const OtherShapeMeasurementDeterminationType::Set_optional& OtherShapeMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OtherShapeMeasurementDeterminationType::Set_optional& OtherShapeMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OtherShapeMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OtherShapeMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OtherShapeMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // OtherShapeFeatureItemType
    //

    const OtherShapeFeatureItemType::DeterminationMode_type& OtherShapeFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OtherShapeFeatureItemType::DeterminationMode_type& OtherShapeFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OtherShapeFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OtherShapeFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // OtherShapeFeatureDefinitionType
    //

    const OtherShapeFeatureDefinitionType::Description_type& OtherShapeFeatureDefinitionType::
    Description () const
    {
      return this->Description_.get ();
    }

    OtherShapeFeatureDefinitionType::Description_type& OtherShapeFeatureDefinitionType::
    Description ()
    {
      return this->Description_.get ();
    }

    void OtherShapeFeatureDefinitionType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void OtherShapeFeatureDefinitionType::
    Description (::std::unique_ptr< Description_type > x)
    {
      this->Description_.set (std::move (x));
    }


    // OtherShapeFeatureNominalType
    //

    const OtherShapeFeatureNominalType::Constructed_optional& OtherShapeFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OtherShapeFeatureNominalType::Constructed_optional& OtherShapeFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OtherShapeFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OtherShapeFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OtherShapeFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OtherShapeFeatureMeasurementType
    //


    // OtherSurfaceConstructionMethodType
    //

    const OtherSurfaceConstructionMethodType::Copy_optional& OtherSurfaceConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OtherSurfaceConstructionMethodType::Copy_optional& OtherSurfaceConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OtherSurfaceConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OtherSurfaceConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OtherSurfaceConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }


    // OtherSurfaceFeatureCopyType
    //

    const OtherSurfaceFeatureCopyType::BaseOtherSurfaceFeature_type& OtherSurfaceFeatureCopyType::
    BaseOtherSurfaceFeature () const
    {
      return this->BaseOtherSurfaceFeature_.get ();
    }

    OtherSurfaceFeatureCopyType::BaseOtherSurfaceFeature_type& OtherSurfaceFeatureCopyType::
    BaseOtherSurfaceFeature ()
    {
      return this->BaseOtherSurfaceFeature_.get ();
    }

    void OtherSurfaceFeatureCopyType::
    BaseOtherSurfaceFeature (const BaseOtherSurfaceFeature_type& x)
    {
      this->BaseOtherSurfaceFeature_.set (x);
    }

    void OtherSurfaceFeatureCopyType::
    BaseOtherSurfaceFeature (::std::unique_ptr< BaseOtherSurfaceFeature_type > x)
    {
      this->BaseOtherSurfaceFeature_.set (std::move (x));
    }


    // OtherSurfaceCheckedType
    //

    const OtherSurfaceCheckedType::Measured_optional& OtherSurfaceCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OtherSurfaceCheckedType::Measured_optional& OtherSurfaceCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OtherSurfaceCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OtherSurfaceCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OtherSurfaceCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const OtherSurfaceCheckedType::Constructed_optional& OtherSurfaceCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OtherSurfaceCheckedType::Constructed_optional& OtherSurfaceCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OtherSurfaceCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OtherSurfaceCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OtherSurfaceCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OtherSurfaceCheckedFeatureType
    //

    const OtherSurfaceCheckedFeatureType::CheckDetails_optional& OtherSurfaceCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OtherSurfaceCheckedFeatureType::CheckDetails_optional& OtherSurfaceCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OtherSurfaceCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OtherSurfaceCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OtherSurfaceCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // OtherSurfaceMeasurementDeterminationType
    //

    const OtherSurfaceMeasurementDeterminationType::Checked_optional& OtherSurfaceMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OtherSurfaceMeasurementDeterminationType::Checked_optional& OtherSurfaceMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OtherSurfaceMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OtherSurfaceMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OtherSurfaceMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const OtherSurfaceMeasurementDeterminationType::Set_optional& OtherSurfaceMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OtherSurfaceMeasurementDeterminationType::Set_optional& OtherSurfaceMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OtherSurfaceMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OtherSurfaceMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OtherSurfaceMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // OtherSurfaceFeatureItemType
    //

    const OtherSurfaceFeatureItemType::DeterminationMode_type& OtherSurfaceFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OtherSurfaceFeatureItemType::DeterminationMode_type& OtherSurfaceFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OtherSurfaceFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OtherSurfaceFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // OtherSurfaceFeatureDefinitionType
    //


    // OtherSurfaceFeatureNominalType
    //

    const OtherSurfaceFeatureNominalType::PolyLine_optional& OtherSurfaceFeatureNominalType::
    PolyLine () const
    {
      return this->PolyLine_;
    }

    OtherSurfaceFeatureNominalType::PolyLine_optional& OtherSurfaceFeatureNominalType::
    PolyLine ()
    {
      return this->PolyLine_;
    }

    void OtherSurfaceFeatureNominalType::
    PolyLine (const PolyLine_type& x)
    {
      this->PolyLine_.set (x);
    }

    void OtherSurfaceFeatureNominalType::
    PolyLine (const PolyLine_optional& x)
    {
      this->PolyLine_ = x;
    }

    void OtherSurfaceFeatureNominalType::
    PolyLine (::std::unique_ptr< PolyLine_type > x)
    {
      this->PolyLine_.set (std::move (x));
    }

    const OtherSurfaceFeatureNominalType::ClosedSurface_optional& OtherSurfaceFeatureNominalType::
    ClosedSurface () const
    {
      return this->ClosedSurface_;
    }

    OtherSurfaceFeatureNominalType::ClosedSurface_optional& OtherSurfaceFeatureNominalType::
    ClosedSurface ()
    {
      return this->ClosedSurface_;
    }

    void OtherSurfaceFeatureNominalType::
    ClosedSurface (const ClosedSurface_type& x)
    {
      this->ClosedSurface_.set (x);
    }

    void OtherSurfaceFeatureNominalType::
    ClosedSurface (const ClosedSurface_optional& x)
    {
      this->ClosedSurface_ = x;
    }

    void OtherSurfaceFeatureNominalType::
    ClosedSurface (::std::unique_ptr< ClosedSurface_type > x)
    {
      this->ClosedSurface_.set (std::move (x));
    }

    const OtherSurfaceFeatureNominalType::Constructed_optional& OtherSurfaceFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OtherSurfaceFeatureNominalType::Constructed_optional& OtherSurfaceFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OtherSurfaceFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OtherSurfaceFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OtherSurfaceFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // OtherSurfaceFeatureMeasurementType
    //

    const OtherSurfaceFeatureMeasurementType::PolyLine_optional& OtherSurfaceFeatureMeasurementType::
    PolyLine () const
    {
      return this->PolyLine_;
    }

    OtherSurfaceFeatureMeasurementType::PolyLine_optional& OtherSurfaceFeatureMeasurementType::
    PolyLine ()
    {
      return this->PolyLine_;
    }

    void OtherSurfaceFeatureMeasurementType::
    PolyLine (const PolyLine_type& x)
    {
      this->PolyLine_.set (x);
    }

    void OtherSurfaceFeatureMeasurementType::
    PolyLine (const PolyLine_optional& x)
    {
      this->PolyLine_ = x;
    }

    void OtherSurfaceFeatureMeasurementType::
    PolyLine (::std::unique_ptr< PolyLine_type > x)
    {
      this->PolyLine_.set (std::move (x));
    }


    // PlaneConstructionMethodType
    //

    const PlaneConstructionMethodType::BestFit_optional& PlaneConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PlaneConstructionMethodType::BestFit_optional& PlaneConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PlaneConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PlaneConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PlaneConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Recompensated_optional& PlaneConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PlaneConstructionMethodType::Recompensated_optional& PlaneConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PlaneConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PlaneConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PlaneConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Midplane_optional& PlaneConstructionMethodType::
    Midplane () const
    {
      return this->Midplane_;
    }

    PlaneConstructionMethodType::Midplane_optional& PlaneConstructionMethodType::
    Midplane ()
    {
      return this->Midplane_;
    }

    void PlaneConstructionMethodType::
    Midplane (const Midplane_type& x)
    {
      this->Midplane_.set (x);
    }

    void PlaneConstructionMethodType::
    Midplane (const Midplane_optional& x)
    {
      this->Midplane_ = x;
    }

    void PlaneConstructionMethodType::
    Midplane (::std::unique_ptr< Midplane_type > x)
    {
      this->Midplane_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Offset_optional& PlaneConstructionMethodType::
    Offset () const
    {
      return this->Offset_;
    }

    PlaneConstructionMethodType::Offset_optional& PlaneConstructionMethodType::
    Offset ()
    {
      return this->Offset_;
    }

    void PlaneConstructionMethodType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PlaneConstructionMethodType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void PlaneConstructionMethodType::
    Offset (::std::unique_ptr< Offset_type > x)
    {
      this->Offset_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Perpendicular_optional& PlaneConstructionMethodType::
    Perpendicular () const
    {
      return this->Perpendicular_;
    }

    PlaneConstructionMethodType::Perpendicular_optional& PlaneConstructionMethodType::
    Perpendicular ()
    {
      return this->Perpendicular_;
    }

    void PlaneConstructionMethodType::
    Perpendicular (const Perpendicular_type& x)
    {
      this->Perpendicular_.set (x);
    }

    void PlaneConstructionMethodType::
    Perpendicular (const Perpendicular_optional& x)
    {
      this->Perpendicular_ = x;
    }

    void PlaneConstructionMethodType::
    Perpendicular (::std::unique_ptr< Perpendicular_type > x)
    {
      this->Perpendicular_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Parallel_optional& PlaneConstructionMethodType::
    Parallel () const
    {
      return this->Parallel_;
    }

    PlaneConstructionMethodType::Parallel_optional& PlaneConstructionMethodType::
    Parallel ()
    {
      return this->Parallel_;
    }

    void PlaneConstructionMethodType::
    Parallel (const Parallel_type& x)
    {
      this->Parallel_.set (x);
    }

    void PlaneConstructionMethodType::
    Parallel (const Parallel_optional& x)
    {
      this->Parallel_ = x;
    }

    void PlaneConstructionMethodType::
    Parallel (::std::unique_ptr< Parallel_type > x)
    {
      this->Parallel_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Copy_optional& PlaneConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PlaneConstructionMethodType::Copy_optional& PlaneConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PlaneConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PlaneConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PlaneConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Cast_optional& PlaneConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    PlaneConstructionMethodType::Cast_optional& PlaneConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void PlaneConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void PlaneConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void PlaneConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const PlaneConstructionMethodType::TangentThrough_optional& PlaneConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    PlaneConstructionMethodType::TangentThrough_optional& PlaneConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void PlaneConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void PlaneConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void PlaneConstructionMethodType::
    TangentThrough (::std::unique_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Through_optional& PlaneConstructionMethodType::
    Through () const
    {
      return this->Through_;
    }

    PlaneConstructionMethodType::Through_optional& PlaneConstructionMethodType::
    Through ()
    {
      return this->Through_;
    }

    void PlaneConstructionMethodType::
    Through (const Through_type& x)
    {
      this->Through_.set (x);
    }

    void PlaneConstructionMethodType::
    Through (const Through_optional& x)
    {
      this->Through_ = x;
    }

    void PlaneConstructionMethodType::
    Through (::std::unique_ptr< Through_type > x)
    {
      this->Through_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Transform_optional& PlaneConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PlaneConstructionMethodType::Transform_optional& PlaneConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PlaneConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PlaneConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PlaneConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const PlaneConstructionMethodType::Extract_optional& PlaneConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PlaneConstructionMethodType::Extract_optional& PlaneConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PlaneConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PlaneConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PlaneConstructionMethodType::
    Extract (::std::unique_ptr< Extract_type > x)
    {
      this->Extract_.set (std::move (x));
    }


    // PlaneBestFitType
    //

    const PlaneBestFitType::BaseFeature_sequence& PlaneBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PlaneBestFitType::BaseFeature_sequence& PlaneBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PlaneBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const PlaneBestFitType::n_type& PlaneBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    PlaneBestFitType::n_type& PlaneBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void PlaneBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PlaneBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PlaneRecompType
    //

    const PlaneRecompType::BaseFeaturePointList_type& PlaneRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PlaneRecompType::BaseFeaturePointList_type& PlaneRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PlaneRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PlaneRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // PlaneMidplaneType
    //

    const PlaneMidplaneType::BasePlane_sequence& PlaneMidplaneType::
    BasePlane () const
    {
      return this->BasePlane_;
    }

    PlaneMidplaneType::BasePlane_sequence& PlaneMidplaneType::
    BasePlane ()
    {
      return this->BasePlane_;
    }

    void PlaneMidplaneType::
    BasePlane (const BasePlane_sequence& s)
    {
      this->BasePlane_ = s;
    }


    // PlaneOffsetType
    //

    const PlaneOffsetType::BasePlane_type& PlaneOffsetType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneOffsetType::BasePlane_type& PlaneOffsetType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneOffsetType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneOffsetType::
    BasePlane (::std::unique_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (std::move (x));
    }

    const PlaneOffsetType::Offset_type& PlaneOffsetType::
    Offset () const
    {
      return this->Offset_.get ();
    }

    PlaneOffsetType::Offset_type& PlaneOffsetType::
    Offset ()
    {
      return this->Offset_.get ();
    }

    void PlaneOffsetType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PlaneOffsetType::
    Offset (::std::unique_ptr< Offset_type > x)
    {
      this->Offset_.set (std::move (x));
    }


    // PlanePerpendicularType
    //

    const PlanePerpendicularType::PerpendicularFeature_type& PlanePerpendicularType::
    PerpendicularFeature () const
    {
      return this->PerpendicularFeature_.get ();
    }

    PlanePerpendicularType::PerpendicularFeature_type& PlanePerpendicularType::
    PerpendicularFeature ()
    {
      return this->PerpendicularFeature_.get ();
    }

    void PlanePerpendicularType::
    PerpendicularFeature (const PerpendicularFeature_type& x)
    {
      this->PerpendicularFeature_.set (x);
    }

    void PlanePerpendicularType::
    PerpendicularFeature (::std::unique_ptr< PerpendicularFeature_type > x)
    {
      this->PerpendicularFeature_.set (std::move (x));
    }

    const PlanePerpendicularType::PointFeature_type& PlanePerpendicularType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlanePerpendicularType::PointFeature_type& PlanePerpendicularType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlanePerpendicularType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlanePerpendicularType::
    PointFeature (::std::unique_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (std::move (x));
    }


    // PlaneParallelType
    //

    const PlaneParallelType::ParallelFeature_type& PlaneParallelType::
    ParallelFeature () const
    {
      return this->ParallelFeature_.get ();
    }

    PlaneParallelType::ParallelFeature_type& PlaneParallelType::
    ParallelFeature ()
    {
      return this->ParallelFeature_.get ();
    }

    void PlaneParallelType::
    ParallelFeature (const ParallelFeature_type& x)
    {
      this->ParallelFeature_.set (x);
    }

    void PlaneParallelType::
    ParallelFeature (::std::unique_ptr< ParallelFeature_type > x)
    {
      this->ParallelFeature_.set (std::move (x));
    }

    const PlaneParallelType::PointFeature_type& PlaneParallelType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlaneParallelType::PointFeature_type& PlaneParallelType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlaneParallelType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlaneParallelType::
    PointFeature (::std::unique_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (std::move (x));
    }


    // PlaneCopyType
    //

    const PlaneCopyType::BasePlane_type& PlaneCopyType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneCopyType::BasePlane_type& PlaneCopyType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneCopyType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneCopyType::
    BasePlane (::std::unique_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (std::move (x));
    }


    // PlaneCastType
    //

    const PlaneCastType::BaseFeature_type& PlaneCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PlaneCastType::BaseFeature_type& PlaneCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PlaneCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PlaneCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // PlaneTangentThroughType
    //

    const PlaneTangentThroughType::TangentFeature_type& PlaneTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    PlaneTangentThroughType::TangentFeature_type& PlaneTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void PlaneTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void PlaneTangentThroughType::
    TangentFeature (::std::unique_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (std::move (x));
    }

    const PlaneTangentThroughType::PointFeature_type& PlaneTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlaneTangentThroughType::PointFeature_type& PlaneTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlaneTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlaneTangentThroughType::
    PointFeature (::std::unique_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (std::move (x));
    }


    // PlaneThroughType
    //

    const PlaneThroughType::BaseFeature_sequence& PlaneThroughType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PlaneThroughType::BaseFeature_sequence& PlaneThroughType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PlaneThroughType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PlaneTransformType
    //

    const PlaneTransformType::BasePlane_type& PlaneTransformType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneTransformType::BasePlane_type& PlaneTransformType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneTransformType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneTransformType::
    BasePlane (::std::unique_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (std::move (x));
    }

    const PlaneTransformType::Transformation_type& PlaneTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PlaneTransformType::Transformation_type& PlaneTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PlaneTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PlaneTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // PlaneExtractType
    //

    const PlaneExtractType::SurfaceFeature_type& PlaneExtractType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PlaneExtractType::SurfaceFeature_type& PlaneExtractType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PlaneExtractType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PlaneExtractType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }


    // PlaneCheckedType
    //

    const PlaneCheckedType::Measured_optional& PlaneCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PlaneCheckedType::Measured_optional& PlaneCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PlaneCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PlaneCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PlaneCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const PlaneCheckedType::Constructed_optional& PlaneCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PlaneCheckedType::Constructed_optional& PlaneCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PlaneCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PlaneCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PlaneCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // PlaneCheckedFeatureType
    //

    const PlaneCheckedFeatureType::CheckDetails_optional& PlaneCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PlaneCheckedFeatureType::CheckDetails_optional& PlaneCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PlaneCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PlaneCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PlaneCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // PlaneMeasurementDeterminationType
    //

    const PlaneMeasurementDeterminationType::Checked_optional& PlaneMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PlaneMeasurementDeterminationType::Checked_optional& PlaneMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PlaneMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PlaneMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PlaneMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const PlaneMeasurementDeterminationType::Set_optional& PlaneMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PlaneMeasurementDeterminationType::Set_optional& PlaneMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PlaneMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PlaneMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PlaneMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // PlaneFeatureItemType
    //

    const PlaneFeatureItemType::DeterminationMode_type& PlaneFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PlaneFeatureItemType::DeterminationMode_type& PlaneFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PlaneFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PlaneFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // PlaneFeatureDefinitionType
    //


    // PlaneFeatureNominalType
    //

    const PlaneFeatureNominalType::Location_type& PlaneFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    PlaneFeatureNominalType::Location_type& PlaneFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void PlaneFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PlaneFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const PlaneFeatureNominalType::Normal_type& PlaneFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    PlaneFeatureNominalType::Normal_type& PlaneFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void PlaneFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PlaneFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const PlaneFeatureNominalType::PolyLine_optional& PlaneFeatureNominalType::
    PolyLine () const
    {
      return this->PolyLine_;
    }

    PlaneFeatureNominalType::PolyLine_optional& PlaneFeatureNominalType::
    PolyLine ()
    {
      return this->PolyLine_;
    }

    void PlaneFeatureNominalType::
    PolyLine (const PolyLine_type& x)
    {
      this->PolyLine_.set (x);
    }

    void PlaneFeatureNominalType::
    PolyLine (const PolyLine_optional& x)
    {
      this->PolyLine_ = x;
    }

    void PlaneFeatureNominalType::
    PolyLine (::std::unique_ptr< PolyLine_type > x)
    {
      this->PolyLine_.set (std::move (x));
    }

    const PlaneFeatureNominalType::Rectangle_optional& PlaneFeatureNominalType::
    Rectangle () const
    {
      return this->Rectangle_;
    }

    PlaneFeatureNominalType::Rectangle_optional& PlaneFeatureNominalType::
    Rectangle ()
    {
      return this->Rectangle_;
    }

    void PlaneFeatureNominalType::
    Rectangle (const Rectangle_type& x)
    {
      this->Rectangle_.set (x);
    }

    void PlaneFeatureNominalType::
    Rectangle (const Rectangle_optional& x)
    {
      this->Rectangle_ = x;
    }

    void PlaneFeatureNominalType::
    Rectangle (::std::unique_ptr< Rectangle_type > x)
    {
      this->Rectangle_.set (std::move (x));
    }

    const PlaneFeatureNominalType::Circle_optional& PlaneFeatureNominalType::
    Circle () const
    {
      return this->Circle_;
    }

    PlaneFeatureNominalType::Circle_optional& PlaneFeatureNominalType::
    Circle ()
    {
      return this->Circle_;
    }

    void PlaneFeatureNominalType::
    Circle (const Circle_type& x)
    {
      this->Circle_.set (x);
    }

    void PlaneFeatureNominalType::
    Circle (const Circle_optional& x)
    {
      this->Circle_ = x;
    }

    void PlaneFeatureNominalType::
    Circle (::std::unique_ptr< Circle_type > x)
    {
      this->Circle_.set (std::move (x));
    }

    const PlaneFeatureNominalType::Constructed_optional& PlaneFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PlaneFeatureNominalType::Constructed_optional& PlaneFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PlaneFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PlaneFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PlaneFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // PlaneFeatureMeasurementType
    //

    const PlaneFeatureMeasurementType::Location_optional& PlaneFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    PlaneFeatureMeasurementType::Location_optional& PlaneFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void PlaneFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PlaneFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PlaneFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const PlaneFeatureMeasurementType::Normal_optional& PlaneFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    PlaneFeatureMeasurementType::Normal_optional& PlaneFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void PlaneFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PlaneFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PlaneFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const PlaneFeatureMeasurementType::PolyLine_optional& PlaneFeatureMeasurementType::
    PolyLine () const
    {
      return this->PolyLine_;
    }

    PlaneFeatureMeasurementType::PolyLine_optional& PlaneFeatureMeasurementType::
    PolyLine ()
    {
      return this->PolyLine_;
    }

    void PlaneFeatureMeasurementType::
    PolyLine (const PolyLine_type& x)
    {
      this->PolyLine_.set (x);
    }

    void PlaneFeatureMeasurementType::
    PolyLine (const PolyLine_optional& x)
    {
      this->PolyLine_ = x;
    }

    void PlaneFeatureMeasurementType::
    PolyLine (::std::unique_ptr< PolyLine_type > x)
    {
      this->PolyLine_.set (std::move (x));
    }

    const PlaneFeatureMeasurementType::Form_optional& PlaneFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    PlaneFeatureMeasurementType::Form_optional& PlaneFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void PlaneFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PlaneFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PlaneFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // PointDefinedCurveConstructionMethodType
    //

    const PointDefinedCurveConstructionMethodType::BestFit_optional& PointDefinedCurveConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PointDefinedCurveConstructionMethodType::BestFit_optional& PointDefinedCurveConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const PointDefinedCurveConstructionMethodType::Recompensated_optional& PointDefinedCurveConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PointDefinedCurveConstructionMethodType::Recompensated_optional& PointDefinedCurveConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const PointDefinedCurveConstructionMethodType::Copy_optional& PointDefinedCurveConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointDefinedCurveConstructionMethodType::Copy_optional& PointDefinedCurveConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const PointDefinedCurveConstructionMethodType::Transform_optional& PointDefinedCurveConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointDefinedCurveConstructionMethodType::Transform_optional& PointDefinedCurveConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const PointDefinedCurveConstructionMethodType::FromScan_optional& PointDefinedCurveConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    PointDefinedCurveConstructionMethodType::FromScan_optional& PointDefinedCurveConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }

    const PointDefinedCurveConstructionMethodType::Extract_optional& PointDefinedCurveConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PointDefinedCurveConstructionMethodType::Extract_optional& PointDefinedCurveConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (::std::unique_ptr< Extract_type > x)
    {
      this->Extract_.set (std::move (x));
    }


    // PointDefinedCurveBestFitType
    //

    const PointDefinedCurveBestFitType::BaseFeature_sequence& PointDefinedCurveBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointDefinedCurveBestFitType::BaseFeature_sequence& PointDefinedCurveBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointDefinedCurveBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const PointDefinedCurveBestFitType::n_type& PointDefinedCurveBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    PointDefinedCurveBestFitType::n_type& PointDefinedCurveBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void PointDefinedCurveBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PointDefinedCurveBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointDefinedCurveRecompType
    //

    const PointDefinedCurveRecompType::BaseFeaturePointList_type& PointDefinedCurveRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PointDefinedCurveRecompType::BaseFeaturePointList_type& PointDefinedCurveRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PointDefinedCurveRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PointDefinedCurveRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // PointDefinedCurveCopyType
    //

    const PointDefinedCurveCopyType::BasePointDefinedCurve_type& PointDefinedCurveCopyType::
    BasePointDefinedCurve () const
    {
      return this->BasePointDefinedCurve_.get ();
    }

    PointDefinedCurveCopyType::BasePointDefinedCurve_type& PointDefinedCurveCopyType::
    BasePointDefinedCurve ()
    {
      return this->BasePointDefinedCurve_.get ();
    }

    void PointDefinedCurveCopyType::
    BasePointDefinedCurve (const BasePointDefinedCurve_type& x)
    {
      this->BasePointDefinedCurve_.set (x);
    }

    void PointDefinedCurveCopyType::
    BasePointDefinedCurve (::std::unique_ptr< BasePointDefinedCurve_type > x)
    {
      this->BasePointDefinedCurve_.set (std::move (x));
    }


    // PointDefinedCurveTransformType
    //

    const PointDefinedCurveTransformType::BasePointDefinedCurve_type& PointDefinedCurveTransformType::
    BasePointDefinedCurve () const
    {
      return this->BasePointDefinedCurve_.get ();
    }

    PointDefinedCurveTransformType::BasePointDefinedCurve_type& PointDefinedCurveTransformType::
    BasePointDefinedCurve ()
    {
      return this->BasePointDefinedCurve_.get ();
    }

    void PointDefinedCurveTransformType::
    BasePointDefinedCurve (const BasePointDefinedCurve_type& x)
    {
      this->BasePointDefinedCurve_.set (x);
    }

    void PointDefinedCurveTransformType::
    BasePointDefinedCurve (::std::unique_ptr< BasePointDefinedCurve_type > x)
    {
      this->BasePointDefinedCurve_.set (std::move (x));
    }

    const PointDefinedCurveTransformType::Transformation_type& PointDefinedCurveTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointDefinedCurveTransformType::Transformation_type& PointDefinedCurveTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointDefinedCurveTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointDefinedCurveTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // PointDefinedCurveFromScanType
    //

    const PointDefinedCurveFromScanType::SurfaceFeature_type& PointDefinedCurveFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointDefinedCurveFromScanType::SurfaceFeature_type& PointDefinedCurveFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointDefinedCurveFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointDefinedCurveFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const PointDefinedCurveFromScanType::SearchRadius_type& PointDefinedCurveFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    PointDefinedCurveFromScanType::SearchRadius_type& PointDefinedCurveFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void PointDefinedCurveFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void PointDefinedCurveFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }


    // PointDefinedCurveExtractType
    //

    const PointDefinedCurveExtractType::CurveFeature_type& PointDefinedCurveExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    PointDefinedCurveExtractType::CurveFeature_type& PointDefinedCurveExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void PointDefinedCurveExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void PointDefinedCurveExtractType::
    CurveFeature (::std::unique_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (std::move (x));
    }


    // PointDefinedCurveCheckedType
    //

    const PointDefinedCurveCheckedType::Measured_optional& PointDefinedCurveCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointDefinedCurveCheckedType::Measured_optional& PointDefinedCurveCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointDefinedCurveCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointDefinedCurveCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointDefinedCurveCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const PointDefinedCurveCheckedType::Constructed_optional& PointDefinedCurveCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointDefinedCurveCheckedType::Constructed_optional& PointDefinedCurveCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointDefinedCurveCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointDefinedCurveCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointDefinedCurveCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // PointDefinedCurveCheckedFeatureType
    //

    const PointDefinedCurveCheckedFeatureType::CheckDetails_optional& PointDefinedCurveCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointDefinedCurveCheckedFeatureType::CheckDetails_optional& PointDefinedCurveCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // PointDefinedCurveMeasurementDeterminationType
    //

    const PointDefinedCurveMeasurementDeterminationType::Checked_optional& PointDefinedCurveMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointDefinedCurveMeasurementDeterminationType::Checked_optional& PointDefinedCurveMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointDefinedCurveMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointDefinedCurveMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointDefinedCurveMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const PointDefinedCurveMeasurementDeterminationType::Set_optional& PointDefinedCurveMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointDefinedCurveMeasurementDeterminationType::Set_optional& PointDefinedCurveMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointDefinedCurveMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointDefinedCurveMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointDefinedCurveMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // PointDefinedCurveFeatureItemType
    //

    const PointDefinedCurveFeatureItemType::DeterminationMode_type& PointDefinedCurveFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointDefinedCurveFeatureItemType::DeterminationMode_type& PointDefinedCurveFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointDefinedCurveFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointDefinedCurveFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // PointDefinedCurveFeatureDefinitionType
    //


    // PointDefinedCurveFeatureNominalType
    //

    const PointDefinedCurveFeatureNominalType::DefiningPoints_type& PointDefinedCurveFeatureNominalType::
    DefiningPoints () const
    {
      return this->DefiningPoints_.get ();
    }

    PointDefinedCurveFeatureNominalType::DefiningPoints_type& PointDefinedCurveFeatureNominalType::
    DefiningPoints ()
    {
      return this->DefiningPoints_.get ();
    }

    void PointDefinedCurveFeatureNominalType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedCurveFeatureNominalType::
    DefiningPoints (::std::unique_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (std::move (x));
    }

    const PointDefinedCurveFeatureNominalType::Plane_optional& PointDefinedCurveFeatureNominalType::
    Plane () const
    {
      return this->Plane_;
    }

    PointDefinedCurveFeatureNominalType::Plane_optional& PointDefinedCurveFeatureNominalType::
    Plane ()
    {
      return this->Plane_;
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (const Plane_type& x)
    {
      this->Plane_.set (x);
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (const Plane_optional& x)
    {
      this->Plane_ = x;
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (::std::unique_ptr< Plane_type > x)
    {
      this->Plane_.set (std::move (x));
    }

    const PointDefinedCurveFeatureNominalType::Constructed_optional& PointDefinedCurveFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointDefinedCurveFeatureNominalType::Constructed_optional& PointDefinedCurveFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointDefinedCurveFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointDefinedCurveFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointDefinedCurveFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // DefiningPointsMeasurementType
    //

    const DefiningPointsMeasurementType::DefiningPoint_sequence& DefiningPointsMeasurementType::
    DefiningPoint () const
    {
      return this->DefiningPoint_;
    }

    DefiningPointsMeasurementType::DefiningPoint_sequence& DefiningPointsMeasurementType::
    DefiningPoint ()
    {
      return this->DefiningPoint_;
    }

    void DefiningPointsMeasurementType::
    DefiningPoint (const DefiningPoint_sequence& s)
    {
      this->DefiningPoint_ = s;
    }

    const DefiningPointsMeasurementType::linearUnit_optional& DefiningPointsMeasurementType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    DefiningPointsMeasurementType::linearUnit_optional& DefiningPointsMeasurementType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void DefiningPointsMeasurementType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void DefiningPointsMeasurementType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void DefiningPointsMeasurementType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const DefiningPointsMeasurementType::decimalPlaces_optional& DefiningPointsMeasurementType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    DefiningPointsMeasurementType::decimalPlaces_optional& DefiningPointsMeasurementType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void DefiningPointsMeasurementType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void DefiningPointsMeasurementType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const DefiningPointsMeasurementType::significantFigures_optional& DefiningPointsMeasurementType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    DefiningPointsMeasurementType::significantFigures_optional& DefiningPointsMeasurementType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void DefiningPointsMeasurementType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void DefiningPointsMeasurementType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const DefiningPointsMeasurementType::validity_optional& DefiningPointsMeasurementType::
    validity () const
    {
      return this->validity_;
    }

    DefiningPointsMeasurementType::validity_optional& DefiningPointsMeasurementType::
    validity ()
    {
      return this->validity_;
    }

    void DefiningPointsMeasurementType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void DefiningPointsMeasurementType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void DefiningPointsMeasurementType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const DefiningPointsMeasurementType::xDecimalPlaces_optional& DefiningPointsMeasurementType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    DefiningPointsMeasurementType::xDecimalPlaces_optional& DefiningPointsMeasurementType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void DefiningPointsMeasurementType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void DefiningPointsMeasurementType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const DefiningPointsMeasurementType::xSignificantFigures_optional& DefiningPointsMeasurementType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    DefiningPointsMeasurementType::xSignificantFigures_optional& DefiningPointsMeasurementType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void DefiningPointsMeasurementType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void DefiningPointsMeasurementType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const DefiningPointsMeasurementType::xValidity_optional& DefiningPointsMeasurementType::
    xValidity () const
    {
      return this->xValidity_;
    }

    DefiningPointsMeasurementType::xValidity_optional& DefiningPointsMeasurementType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void DefiningPointsMeasurementType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void DefiningPointsMeasurementType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void DefiningPointsMeasurementType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const DefiningPointsMeasurementType::yDecimalPlaces_optional& DefiningPointsMeasurementType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    DefiningPointsMeasurementType::yDecimalPlaces_optional& DefiningPointsMeasurementType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void DefiningPointsMeasurementType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void DefiningPointsMeasurementType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const DefiningPointsMeasurementType::ySignificantFigures_optional& DefiningPointsMeasurementType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    DefiningPointsMeasurementType::ySignificantFigures_optional& DefiningPointsMeasurementType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void DefiningPointsMeasurementType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void DefiningPointsMeasurementType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const DefiningPointsMeasurementType::yValidity_optional& DefiningPointsMeasurementType::
    yValidity () const
    {
      return this->yValidity_;
    }

    DefiningPointsMeasurementType::yValidity_optional& DefiningPointsMeasurementType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void DefiningPointsMeasurementType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void DefiningPointsMeasurementType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void DefiningPointsMeasurementType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const DefiningPointsMeasurementType::zDecimalPlaces_optional& DefiningPointsMeasurementType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    DefiningPointsMeasurementType::zDecimalPlaces_optional& DefiningPointsMeasurementType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void DefiningPointsMeasurementType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void DefiningPointsMeasurementType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const DefiningPointsMeasurementType::zSignificantFigures_optional& DefiningPointsMeasurementType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    DefiningPointsMeasurementType::zSignificantFigures_optional& DefiningPointsMeasurementType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void DefiningPointsMeasurementType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void DefiningPointsMeasurementType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const DefiningPointsMeasurementType::zValidity_optional& DefiningPointsMeasurementType::
    zValidity () const
    {
      return this->zValidity_;
    }

    DefiningPointsMeasurementType::zValidity_optional& DefiningPointsMeasurementType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void DefiningPointsMeasurementType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void DefiningPointsMeasurementType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void DefiningPointsMeasurementType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }

    const DefiningPointsMeasurementType::combinedUncertainty_optional& DefiningPointsMeasurementType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    DefiningPointsMeasurementType::combinedUncertainty_optional& DefiningPointsMeasurementType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void DefiningPointsMeasurementType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void DefiningPointsMeasurementType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const DefiningPointsMeasurementType::meanError_optional& DefiningPointsMeasurementType::
    meanError () const
    {
      return this->meanError_;
    }

    DefiningPointsMeasurementType::meanError_optional& DefiningPointsMeasurementType::
    meanError ()
    {
      return this->meanError_;
    }

    void DefiningPointsMeasurementType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void DefiningPointsMeasurementType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const DefiningPointsMeasurementType::xCombinedUncertainty_optional& DefiningPointsMeasurementType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    DefiningPointsMeasurementType::xCombinedUncertainty_optional& DefiningPointsMeasurementType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void DefiningPointsMeasurementType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void DefiningPointsMeasurementType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const DefiningPointsMeasurementType::xMeanError_optional& DefiningPointsMeasurementType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    DefiningPointsMeasurementType::xMeanError_optional& DefiningPointsMeasurementType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void DefiningPointsMeasurementType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void DefiningPointsMeasurementType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const DefiningPointsMeasurementType::yCombinedUncertainty_optional& DefiningPointsMeasurementType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    DefiningPointsMeasurementType::yCombinedUncertainty_optional& DefiningPointsMeasurementType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void DefiningPointsMeasurementType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void DefiningPointsMeasurementType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const DefiningPointsMeasurementType::yMeanError_optional& DefiningPointsMeasurementType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    DefiningPointsMeasurementType::yMeanError_optional& DefiningPointsMeasurementType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void DefiningPointsMeasurementType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void DefiningPointsMeasurementType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const DefiningPointsMeasurementType::zCombinedUncertainty_optional& DefiningPointsMeasurementType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    DefiningPointsMeasurementType::zCombinedUncertainty_optional& DefiningPointsMeasurementType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void DefiningPointsMeasurementType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void DefiningPointsMeasurementType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const DefiningPointsMeasurementType::zMeanError_optional& DefiningPointsMeasurementType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    DefiningPointsMeasurementType::zMeanError_optional& DefiningPointsMeasurementType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void DefiningPointsMeasurementType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void DefiningPointsMeasurementType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }

    const DefiningPointsMeasurementType::n_type& DefiningPointsMeasurementType::
    n () const
    {
      return this->n_.get ();
    }

    DefiningPointsMeasurementType::n_type& DefiningPointsMeasurementType::
    n ()
    {
      return this->n_.get ();
    }

    void DefiningPointsMeasurementType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DefiningPointsMeasurementType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointDefinedCurveFeatureMeasurementType
    //

    const PointDefinedCurveFeatureMeasurementType::DefiningPoints_optional& PointDefinedCurveFeatureMeasurementType::
    DefiningPoints () const
    {
      return this->DefiningPoints_;
    }

    PointDefinedCurveFeatureMeasurementType::DefiningPoints_optional& PointDefinedCurveFeatureMeasurementType::
    DefiningPoints ()
    {
      return this->DefiningPoints_;
    }

    void PointDefinedCurveFeatureMeasurementType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedCurveFeatureMeasurementType::
    DefiningPoints (const DefiningPoints_optional& x)
    {
      this->DefiningPoints_ = x;
    }

    void PointDefinedCurveFeatureMeasurementType::
    DefiningPoints (::std::unique_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (std::move (x));
    }

    const PointDefinedCurveFeatureMeasurementType::Plane_optional& PointDefinedCurveFeatureMeasurementType::
    Plane () const
    {
      return this->Plane_;
    }

    PointDefinedCurveFeatureMeasurementType::Plane_optional& PointDefinedCurveFeatureMeasurementType::
    Plane ()
    {
      return this->Plane_;
    }

    void PointDefinedCurveFeatureMeasurementType::
    Plane (const Plane_type& x)
    {
      this->Plane_.set (x);
    }

    void PointDefinedCurveFeatureMeasurementType::
    Plane (const Plane_optional& x)
    {
      this->Plane_ = x;
    }

    void PointDefinedCurveFeatureMeasurementType::
    Plane (::std::unique_ptr< Plane_type > x)
    {
      this->Plane_.set (std::move (x));
    }

    const PointDefinedCurveFeatureMeasurementType::Form_optional& PointDefinedCurveFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    PointDefinedCurveFeatureMeasurementType::Form_optional& PointDefinedCurveFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void PointDefinedCurveFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PointDefinedCurveFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PointDefinedCurveFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // PointDefinedSurfaceConstructionMethodType
    //

    const PointDefinedSurfaceConstructionMethodType::BestFit_optional& PointDefinedSurfaceConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PointDefinedSurfaceConstructionMethodType::BestFit_optional& PointDefinedSurfaceConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const PointDefinedSurfaceConstructionMethodType::Recompensated_optional& PointDefinedSurfaceConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PointDefinedSurfaceConstructionMethodType::Recompensated_optional& PointDefinedSurfaceConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const PointDefinedSurfaceConstructionMethodType::Copy_optional& PointDefinedSurfaceConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointDefinedSurfaceConstructionMethodType::Copy_optional& PointDefinedSurfaceConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const PointDefinedSurfaceConstructionMethodType::Transform_optional& PointDefinedSurfaceConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointDefinedSurfaceConstructionMethodType::Transform_optional& PointDefinedSurfaceConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const PointDefinedSurfaceConstructionMethodType::Extract_optional& PointDefinedSurfaceConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PointDefinedSurfaceConstructionMethodType::Extract_optional& PointDefinedSurfaceConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (::std::unique_ptr< Extract_type > x)
    {
      this->Extract_.set (std::move (x));
    }


    // PointDefinedSurfaceBestFitType
    //

    const PointDefinedSurfaceBestFitType::BaseFeature_sequence& PointDefinedSurfaceBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointDefinedSurfaceBestFitType::BaseFeature_sequence& PointDefinedSurfaceBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointDefinedSurfaceBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const PointDefinedSurfaceBestFitType::n_type& PointDefinedSurfaceBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    PointDefinedSurfaceBestFitType::n_type& PointDefinedSurfaceBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void PointDefinedSurfaceBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PointDefinedSurfaceBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointDefinedSurfaceRecompType
    //

    const PointDefinedSurfaceRecompType::BaseFeaturePointList_type& PointDefinedSurfaceRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PointDefinedSurfaceRecompType::BaseFeaturePointList_type& PointDefinedSurfaceRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PointDefinedSurfaceRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PointDefinedSurfaceRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // PointDefinedSurfaceCopyType
    //

    const PointDefinedSurfaceCopyType::BasePointDefinedSurface_type& PointDefinedSurfaceCopyType::
    BasePointDefinedSurface () const
    {
      return this->BasePointDefinedSurface_.get ();
    }

    PointDefinedSurfaceCopyType::BasePointDefinedSurface_type& PointDefinedSurfaceCopyType::
    BasePointDefinedSurface ()
    {
      return this->BasePointDefinedSurface_.get ();
    }

    void PointDefinedSurfaceCopyType::
    BasePointDefinedSurface (const BasePointDefinedSurface_type& x)
    {
      this->BasePointDefinedSurface_.set (x);
    }

    void PointDefinedSurfaceCopyType::
    BasePointDefinedSurface (::std::unique_ptr< BasePointDefinedSurface_type > x)
    {
      this->BasePointDefinedSurface_.set (std::move (x));
    }


    // PointDefinedSurfaceTransformType
    //

    const PointDefinedSurfaceTransformType::BasePointDefinedSurface_type& PointDefinedSurfaceTransformType::
    BasePointDefinedSurface () const
    {
      return this->BasePointDefinedSurface_.get ();
    }

    PointDefinedSurfaceTransformType::BasePointDefinedSurface_type& PointDefinedSurfaceTransformType::
    BasePointDefinedSurface ()
    {
      return this->BasePointDefinedSurface_.get ();
    }

    void PointDefinedSurfaceTransformType::
    BasePointDefinedSurface (const BasePointDefinedSurface_type& x)
    {
      this->BasePointDefinedSurface_.set (x);
    }

    void PointDefinedSurfaceTransformType::
    BasePointDefinedSurface (::std::unique_ptr< BasePointDefinedSurface_type > x)
    {
      this->BasePointDefinedSurface_.set (std::move (x));
    }

    const PointDefinedSurfaceTransformType::Transformation_type& PointDefinedSurfaceTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointDefinedSurfaceTransformType::Transformation_type& PointDefinedSurfaceTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointDefinedSurfaceTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointDefinedSurfaceTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // PointDefinedSurfaceExtractType
    //

    const PointDefinedSurfaceExtractType::SurfaceFeature_type& PointDefinedSurfaceExtractType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointDefinedSurfaceExtractType::SurfaceFeature_type& PointDefinedSurfaceExtractType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointDefinedSurfaceExtractType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointDefinedSurfaceExtractType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }


    // PointDefinedSurfaceCheckedType
    //

    const PointDefinedSurfaceCheckedType::Measured_optional& PointDefinedSurfaceCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointDefinedSurfaceCheckedType::Measured_optional& PointDefinedSurfaceCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointDefinedSurfaceCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointDefinedSurfaceCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointDefinedSurfaceCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const PointDefinedSurfaceCheckedType::Constructed_optional& PointDefinedSurfaceCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointDefinedSurfaceCheckedType::Constructed_optional& PointDefinedSurfaceCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // PointDefinedSurfaceCheckedFeatureType
    //

    const PointDefinedSurfaceCheckedFeatureType::CheckDetails_optional& PointDefinedSurfaceCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointDefinedSurfaceCheckedFeatureType::CheckDetails_optional& PointDefinedSurfaceCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // PointDefinedSurfaceMeasurementDeterminationType
    //

    const PointDefinedSurfaceMeasurementDeterminationType::Checked_optional& PointDefinedSurfaceMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointDefinedSurfaceMeasurementDeterminationType::Checked_optional& PointDefinedSurfaceMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointDefinedSurfaceMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointDefinedSurfaceMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointDefinedSurfaceMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const PointDefinedSurfaceMeasurementDeterminationType::Set_optional& PointDefinedSurfaceMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointDefinedSurfaceMeasurementDeterminationType::Set_optional& PointDefinedSurfaceMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointDefinedSurfaceMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointDefinedSurfaceMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointDefinedSurfaceMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // PointDefinedSurfaceFeatureItemType
    //

    const PointDefinedSurfaceFeatureItemType::DeterminationMode_type& PointDefinedSurfaceFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointDefinedSurfaceFeatureItemType::DeterminationMode_type& PointDefinedSurfaceFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointDefinedSurfaceFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointDefinedSurfaceFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // PointDefinedSurfaceFeatureDefinitionType
    //


    // DefiningPointsNominalType
    //

    const DefiningPointsNominalType::DefiningPoint_sequence& DefiningPointsNominalType::
    DefiningPoint () const
    {
      return this->DefiningPoint_;
    }

    DefiningPointsNominalType::DefiningPoint_sequence& DefiningPointsNominalType::
    DefiningPoint ()
    {
      return this->DefiningPoint_;
    }

    void DefiningPointsNominalType::
    DefiningPoint (const DefiningPoint_sequence& s)
    {
      this->DefiningPoint_ = s;
    }

    const DefiningPointsNominalType::linearUnit_optional& DefiningPointsNominalType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    DefiningPointsNominalType::linearUnit_optional& DefiningPointsNominalType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void DefiningPointsNominalType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void DefiningPointsNominalType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void DefiningPointsNominalType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }

    const DefiningPointsNominalType::decimalPlaces_optional& DefiningPointsNominalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    DefiningPointsNominalType::decimalPlaces_optional& DefiningPointsNominalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void DefiningPointsNominalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void DefiningPointsNominalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const DefiningPointsNominalType::significantFigures_optional& DefiningPointsNominalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    DefiningPointsNominalType::significantFigures_optional& DefiningPointsNominalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void DefiningPointsNominalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void DefiningPointsNominalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const DefiningPointsNominalType::validity_optional& DefiningPointsNominalType::
    validity () const
    {
      return this->validity_;
    }

    DefiningPointsNominalType::validity_optional& DefiningPointsNominalType::
    validity ()
    {
      return this->validity_;
    }

    void DefiningPointsNominalType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void DefiningPointsNominalType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void DefiningPointsNominalType::
    validity (::std::unique_ptr< validity_type > x)
    {
      this->validity_.set (std::move (x));
    }

    const DefiningPointsNominalType::xDecimalPlaces_optional& DefiningPointsNominalType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    DefiningPointsNominalType::xDecimalPlaces_optional& DefiningPointsNominalType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void DefiningPointsNominalType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void DefiningPointsNominalType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const DefiningPointsNominalType::xSignificantFigures_optional& DefiningPointsNominalType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    DefiningPointsNominalType::xSignificantFigures_optional& DefiningPointsNominalType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void DefiningPointsNominalType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void DefiningPointsNominalType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const DefiningPointsNominalType::xValidity_optional& DefiningPointsNominalType::
    xValidity () const
    {
      return this->xValidity_;
    }

    DefiningPointsNominalType::xValidity_optional& DefiningPointsNominalType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void DefiningPointsNominalType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void DefiningPointsNominalType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void DefiningPointsNominalType::
    xValidity (::std::unique_ptr< xValidity_type > x)
    {
      this->xValidity_.set (std::move (x));
    }

    const DefiningPointsNominalType::yDecimalPlaces_optional& DefiningPointsNominalType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    DefiningPointsNominalType::yDecimalPlaces_optional& DefiningPointsNominalType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void DefiningPointsNominalType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void DefiningPointsNominalType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const DefiningPointsNominalType::ySignificantFigures_optional& DefiningPointsNominalType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    DefiningPointsNominalType::ySignificantFigures_optional& DefiningPointsNominalType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void DefiningPointsNominalType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void DefiningPointsNominalType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const DefiningPointsNominalType::yValidity_optional& DefiningPointsNominalType::
    yValidity () const
    {
      return this->yValidity_;
    }

    DefiningPointsNominalType::yValidity_optional& DefiningPointsNominalType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void DefiningPointsNominalType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void DefiningPointsNominalType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void DefiningPointsNominalType::
    yValidity (::std::unique_ptr< yValidity_type > x)
    {
      this->yValidity_.set (std::move (x));
    }

    const DefiningPointsNominalType::zDecimalPlaces_optional& DefiningPointsNominalType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    DefiningPointsNominalType::zDecimalPlaces_optional& DefiningPointsNominalType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void DefiningPointsNominalType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void DefiningPointsNominalType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const DefiningPointsNominalType::zSignificantFigures_optional& DefiningPointsNominalType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    DefiningPointsNominalType::zSignificantFigures_optional& DefiningPointsNominalType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void DefiningPointsNominalType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void DefiningPointsNominalType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const DefiningPointsNominalType::zValidity_optional& DefiningPointsNominalType::
    zValidity () const
    {
      return this->zValidity_;
    }

    DefiningPointsNominalType::zValidity_optional& DefiningPointsNominalType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void DefiningPointsNominalType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void DefiningPointsNominalType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void DefiningPointsNominalType::
    zValidity (::std::unique_ptr< zValidity_type > x)
    {
      this->zValidity_.set (std::move (x));
    }

    const DefiningPointsNominalType::n_type& DefiningPointsNominalType::
    n () const
    {
      return this->n_.get ();
    }

    DefiningPointsNominalType::n_type& DefiningPointsNominalType::
    n ()
    {
      return this->n_.get ();
    }

    void DefiningPointsNominalType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void DefiningPointsNominalType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointDefinedSurfaceFeatureNominalType
    //

    const PointDefinedSurfaceFeatureNominalType::DefiningPoints_type& PointDefinedSurfaceFeatureNominalType::
    DefiningPoints () const
    {
      return this->DefiningPoints_.get ();
    }

    PointDefinedSurfaceFeatureNominalType::DefiningPoints_type& PointDefinedSurfaceFeatureNominalType::
    DefiningPoints ()
    {
      return this->DefiningPoints_.get ();
    }

    void PointDefinedSurfaceFeatureNominalType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedSurfaceFeatureNominalType::
    DefiningPoints (::std::unique_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (std::move (x));
    }

    const PointDefinedSurfaceFeatureNominalType::Constructed_optional& PointDefinedSurfaceFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointDefinedSurfaceFeatureNominalType::Constructed_optional& PointDefinedSurfaceFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointDefinedSurfaceFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointDefinedSurfaceFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointDefinedSurfaceFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // PointDefinedSurfaceFeatureMeasurementType
    //

    const PointDefinedSurfaceFeatureMeasurementType::DefiningPoints_optional& PointDefinedSurfaceFeatureMeasurementType::
    DefiningPoints () const
    {
      return this->DefiningPoints_;
    }

    PointDefinedSurfaceFeatureMeasurementType::DefiningPoints_optional& PointDefinedSurfaceFeatureMeasurementType::
    DefiningPoints ()
    {
      return this->DefiningPoints_;
    }

    void PointDefinedSurfaceFeatureMeasurementType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedSurfaceFeatureMeasurementType::
    DefiningPoints (const DefiningPoints_optional& x)
    {
      this->DefiningPoints_ = x;
    }

    void PointDefinedSurfaceFeatureMeasurementType::
    DefiningPoints (::std::unique_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (std::move (x));
    }

    const PointDefinedSurfaceFeatureMeasurementType::Form_optional& PointDefinedSurfaceFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    PointDefinedSurfaceFeatureMeasurementType::Form_optional& PointDefinedSurfaceFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void PointDefinedSurfaceFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PointDefinedSurfaceFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PointDefinedSurfaceFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // PointConstructionMethodType
    //

    const PointConstructionMethodType::Intersection_optional& PointConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    PointConstructionMethodType::Intersection_optional& PointConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void PointConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void PointConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void PointConstructionMethodType::
    Intersection (::std::unique_ptr< Intersection_type > x)
    {
      this->Intersection_.set (std::move (x));
    }

    const PointConstructionMethodType::Projection_optional& PointConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    PointConstructionMethodType::Projection_optional& PointConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void PointConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void PointConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void PointConstructionMethodType::
    Projection (::std::unique_ptr< Projection_type > x)
    {
      this->Projection_.set (std::move (x));
    }

    const PointConstructionMethodType::Copy_optional& PointConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointConstructionMethodType::Copy_optional& PointConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const PointConstructionMethodType::Cast_optional& PointConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    PointConstructionMethodType::Cast_optional& PointConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void PointConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void PointConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void PointConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const PointConstructionMethodType::Transform_optional& PointConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointConstructionMethodType::Transform_optional& PointConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const PointConstructionMethodType::FromCone_optional& PointConstructionMethodType::
    FromCone () const
    {
      return this->FromCone_;
    }

    PointConstructionMethodType::FromCone_optional& PointConstructionMethodType::
    FromCone ()
    {
      return this->FromCone_;
    }

    void PointConstructionMethodType::
    FromCone (const FromCone_type& x)
    {
      this->FromCone_.set (x);
    }

    void PointConstructionMethodType::
    FromCone (const FromCone_optional& x)
    {
      this->FromCone_ = x;
    }

    void PointConstructionMethodType::
    FromCone (::std::unique_ptr< FromCone_type > x)
    {
      this->FromCone_.set (std::move (x));
    }

    const PointConstructionMethodType::FromScan_optional& PointConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    PointConstructionMethodType::FromScan_optional& PointConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void PointConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void PointConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void PointConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }

    const PointConstructionMethodType::CenterOfGravity_optional& PointConstructionMethodType::
    CenterOfGravity () const
    {
      return this->CenterOfGravity_;
    }

    PointConstructionMethodType::CenterOfGravity_optional& PointConstructionMethodType::
    CenterOfGravity ()
    {
      return this->CenterOfGravity_;
    }

    void PointConstructionMethodType::
    CenterOfGravity (const CenterOfGravity_type& x)
    {
      this->CenterOfGravity_.set (x);
    }

    void PointConstructionMethodType::
    CenterOfGravity (const CenterOfGravity_optional& x)
    {
      this->CenterOfGravity_ = x;
    }

    void PointConstructionMethodType::
    CenterOfGravity (::std::unique_ptr< CenterOfGravity_type > x)
    {
      this->CenterOfGravity_.set (std::move (x));
    }

    const PointConstructionMethodType::Pierce_optional& PointConstructionMethodType::
    Pierce () const
    {
      return this->Pierce_;
    }

    PointConstructionMethodType::Pierce_optional& PointConstructionMethodType::
    Pierce ()
    {
      return this->Pierce_;
    }

    void PointConstructionMethodType::
    Pierce (const Pierce_type& x)
    {
      this->Pierce_.set (x);
    }

    void PointConstructionMethodType::
    Pierce (const Pierce_optional& x)
    {
      this->Pierce_ = x;
    }

    void PointConstructionMethodType::
    Pierce (::std::unique_ptr< Pierce_type > x)
    {
      this->Pierce_.set (std::move (x));
    }

    const PointConstructionMethodType::MidPoint_optional& PointConstructionMethodType::
    MidPoint () const
    {
      return this->MidPoint_;
    }

    PointConstructionMethodType::MidPoint_optional& PointConstructionMethodType::
    MidPoint ()
    {
      return this->MidPoint_;
    }

    void PointConstructionMethodType::
    MidPoint (const MidPoint_type& x)
    {
      this->MidPoint_.set (x);
    }

    void PointConstructionMethodType::
    MidPoint (const MidPoint_optional& x)
    {
      this->MidPoint_ = x;
    }

    void PointConstructionMethodType::
    MidPoint (::std::unique_ptr< MidPoint_type > x)
    {
      this->MidPoint_.set (std::move (x));
    }

    const PointConstructionMethodType::MovePoint_optional& PointConstructionMethodType::
    MovePoint () const
    {
      return this->MovePoint_;
    }

    PointConstructionMethodType::MovePoint_optional& PointConstructionMethodType::
    MovePoint ()
    {
      return this->MovePoint_;
    }

    void PointConstructionMethodType::
    MovePoint (const MovePoint_type& x)
    {
      this->MovePoint_.set (x);
    }

    void PointConstructionMethodType::
    MovePoint (const MovePoint_optional& x)
    {
      this->MovePoint_ = x;
    }

    void PointConstructionMethodType::
    MovePoint (::std::unique_ptr< MovePoint_type > x)
    {
      this->MovePoint_.set (std::move (x));
    }

    const PointConstructionMethodType::MovePointVector_optional& PointConstructionMethodType::
    MovePointVector () const
    {
      return this->MovePointVector_;
    }

    PointConstructionMethodType::MovePointVector_optional& PointConstructionMethodType::
    MovePointVector ()
    {
      return this->MovePointVector_;
    }

    void PointConstructionMethodType::
    MovePointVector (const MovePointVector_type& x)
    {
      this->MovePointVector_.set (x);
    }

    void PointConstructionMethodType::
    MovePointVector (const MovePointVector_optional& x)
    {
      this->MovePointVector_ = x;
    }

    void PointConstructionMethodType::
    MovePointVector (::std::unique_ptr< MovePointVector_type > x)
    {
      this->MovePointVector_.set (std::move (x));
    }

    const PointConstructionMethodType::MovePointAxis_optional& PointConstructionMethodType::
    MovePointAxis () const
    {
      return this->MovePointAxis_;
    }

    PointConstructionMethodType::MovePointAxis_optional& PointConstructionMethodType::
    MovePointAxis ()
    {
      return this->MovePointAxis_;
    }

    void PointConstructionMethodType::
    MovePointAxis (const MovePointAxis_type& x)
    {
      this->MovePointAxis_.set (x);
    }

    void PointConstructionMethodType::
    MovePointAxis (const MovePointAxis_optional& x)
    {
      this->MovePointAxis_ = x;
    }

    void PointConstructionMethodType::
    MovePointAxis (::std::unique_ptr< MovePointAxis_type > x)
    {
      this->MovePointAxis_.set (std::move (x));
    }

    const PointConstructionMethodType::Extreme_optional& PointConstructionMethodType::
    Extreme () const
    {
      return this->Extreme_;
    }

    PointConstructionMethodType::Extreme_optional& PointConstructionMethodType::
    Extreme ()
    {
      return this->Extreme_;
    }

    void PointConstructionMethodType::
    Extreme (const Extreme_type& x)
    {
      this->Extreme_.set (x);
    }

    void PointConstructionMethodType::
    Extreme (const Extreme_optional& x)
    {
      this->Extreme_ = x;
    }

    void PointConstructionMethodType::
    Extreme (::std::unique_ptr< Extreme_type > x)
    {
      this->Extreme_.set (std::move (x));
    }


    // PointFeatureIntersectionType
    //

    const PointFeatureIntersectionType::IntersectionFeature_sequence& PointFeatureIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_;
    }

    PointFeatureIntersectionType::IntersectionFeature_sequence& PointFeatureIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_;
    }

    void PointFeatureIntersectionType::
    IntersectionFeature (const IntersectionFeature_sequence& s)
    {
      this->IntersectionFeature_ = s;
    }


    // PointFeaturePierceType
    //

    const PointFeaturePierceType::SurfaceFeature_type& PointFeaturePierceType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointFeaturePierceType::SurfaceFeature_type& PointFeaturePierceType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointFeaturePierceType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointFeaturePierceType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const PointFeaturePierceType::CurveFeature_type& PointFeaturePierceType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    PointFeaturePierceType::CurveFeature_type& PointFeaturePierceType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void PointFeaturePierceType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void PointFeaturePierceType::
    CurveFeature (::std::unique_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (std::move (x));
    }


    // PointFeatureProjectionType
    //

    const PointFeatureProjectionType::ProjectionPlane_type& PointFeatureProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    PointFeatureProjectionType::ProjectionPlane_type& PointFeatureProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void PointFeatureProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void PointFeatureProjectionType::
    ProjectionPlane (::std::unique_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (std::move (x));
    }

    const PointFeatureProjectionType::ProjectionFeature_type& PointFeatureProjectionType::
    ProjectionFeature () const
    {
      return this->ProjectionFeature_.get ();
    }

    PointFeatureProjectionType::ProjectionFeature_type& PointFeatureProjectionType::
    ProjectionFeature ()
    {
      return this->ProjectionFeature_.get ();
    }

    void PointFeatureProjectionType::
    ProjectionFeature (const ProjectionFeature_type& x)
    {
      this->ProjectionFeature_.set (x);
    }

    void PointFeatureProjectionType::
    ProjectionFeature (::std::unique_ptr< ProjectionFeature_type > x)
    {
      this->ProjectionFeature_.set (std::move (x));
    }


    // PointFeatureFromConeType
    //

    const PointFeatureFromConeType::BaseCone_type& PointFeatureFromConeType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    PointFeatureFromConeType::BaseCone_type& PointFeatureFromConeType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void PointFeatureFromConeType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void PointFeatureFromConeType::
    BaseCone (::std::unique_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (std::move (x));
    }


    // PointFeatureCopyType
    //

    const PointFeatureCopyType::BasePointFeature_type& PointFeatureCopyType::
    BasePointFeature () const
    {
      return this->BasePointFeature_.get ();
    }

    PointFeatureCopyType::BasePointFeature_type& PointFeatureCopyType::
    BasePointFeature ()
    {
      return this->BasePointFeature_.get ();
    }

    void PointFeatureCopyType::
    BasePointFeature (const BasePointFeature_type& x)
    {
      this->BasePointFeature_.set (x);
    }

    void PointFeatureCopyType::
    BasePointFeature (::std::unique_ptr< BasePointFeature_type > x)
    {
      this->BasePointFeature_.set (std::move (x));
    }


    // PointFeatureTransformType
    //

    const PointFeatureTransformType::BasePointFeature_type& PointFeatureTransformType::
    BasePointFeature () const
    {
      return this->BasePointFeature_.get ();
    }

    PointFeatureTransformType::BasePointFeature_type& PointFeatureTransformType::
    BasePointFeature ()
    {
      return this->BasePointFeature_.get ();
    }

    void PointFeatureTransformType::
    BasePointFeature (const BasePointFeature_type& x)
    {
      this->BasePointFeature_.set (x);
    }

    void PointFeatureTransformType::
    BasePointFeature (::std::unique_ptr< BasePointFeature_type > x)
    {
      this->BasePointFeature_.set (std::move (x));
    }

    const PointFeatureTransformType::Transformation_type& PointFeatureTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointFeatureTransformType::Transformation_type& PointFeatureTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointFeatureTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointFeatureTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // PointFeatureFromScanType
    //

    const PointFeatureFromScanType::SurfaceFeature_type& PointFeatureFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointFeatureFromScanType::SurfaceFeature_type& PointFeatureFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointFeatureFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointFeatureFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const PointFeatureFromScanType::SearchRadius_type& PointFeatureFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    PointFeatureFromScanType::SearchRadius_type& PointFeatureFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void PointFeatureFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void PointFeatureFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const PointFeatureFromScanType::RetrievalMethod_type& PointFeatureFromScanType::
    RetrievalMethod () const
    {
      return this->RetrievalMethod_.get ();
    }

    PointFeatureFromScanType::RetrievalMethod_type& PointFeatureFromScanType::
    RetrievalMethod ()
    {
      return this->RetrievalMethod_.get ();
    }

    void PointFeatureFromScanType::
    RetrievalMethod (const RetrievalMethod_type& x)
    {
      this->RetrievalMethod_.set (x);
    }

    void PointFeatureFromScanType::
    RetrievalMethod (::std::unique_ptr< RetrievalMethod_type > x)
    {
      this->RetrievalMethod_.set (std::move (x));
    }


    // PointFeatureCenterOfGravityType
    //

    const PointFeatureCenterOfGravityType::BaseFeature_sequence& PointFeatureCenterOfGravityType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointFeatureCenterOfGravityType::BaseFeature_sequence& PointFeatureCenterOfGravityType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointFeatureCenterOfGravityType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const PointFeatureCenterOfGravityType::n_type& PointFeatureCenterOfGravityType::
    n () const
    {
      return this->n_.get ();
    }

    PointFeatureCenterOfGravityType::n_type& PointFeatureCenterOfGravityType::
    n ()
    {
      return this->n_.get ();
    }

    void PointFeatureCenterOfGravityType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PointFeatureCenterOfGravityType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointFeatureMidPointType
    //

    const PointFeatureMidPointType::BaseFeature_sequence& PointFeatureMidPointType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointFeatureMidPointType::BaseFeature_sequence& PointFeatureMidPointType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointFeatureMidPointType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointFeatureCastType
    //

    const PointFeatureCastType::BaseFeature_type& PointFeatureCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureCastType::BaseFeature_type& PointFeatureCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // PointFeatureMovePointType
    //

    const PointFeatureMovePointType::BaseFeature_type& PointFeatureMovePointType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureMovePointType::BaseFeature_type& PointFeatureMovePointType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureMovePointType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureMovePointType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }

    const PointFeatureMovePointType::Offset_optional& PointFeatureMovePointType::
    Offset () const
    {
      return this->Offset_;
    }

    PointFeatureMovePointType::Offset_optional& PointFeatureMovePointType::
    Offset ()
    {
      return this->Offset_;
    }

    void PointFeatureMovePointType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PointFeatureMovePointType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void PointFeatureMovePointType::
    Offset (::std::unique_ptr< Offset_type > x)
    {
      this->Offset_.set (std::move (x));
    }

    const PointFeatureMovePointType::DirectionalOffset_optional& PointFeatureMovePointType::
    DirectionalOffset () const
    {
      return this->DirectionalOffset_;
    }

    PointFeatureMovePointType::DirectionalOffset_optional& PointFeatureMovePointType::
    DirectionalOffset ()
    {
      return this->DirectionalOffset_;
    }

    void PointFeatureMovePointType::
    DirectionalOffset (const DirectionalOffset_type& x)
    {
      this->DirectionalOffset_.set (x);
    }

    void PointFeatureMovePointType::
    DirectionalOffset (const DirectionalOffset_optional& x)
    {
      this->DirectionalOffset_ = x;
    }

    void PointFeatureMovePointType::
    DirectionalOffset (::std::unique_ptr< DirectionalOffset_type > x)
    {
      this->DirectionalOffset_.set (std::move (x));
    }


    // PointFeatureMovePointVectorType
    //

    const PointFeatureMovePointVectorType::BaseFeature_type& PointFeatureMovePointVectorType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureMovePointVectorType::BaseFeature_type& PointFeatureMovePointVectorType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureMovePointVectorType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureMovePointVectorType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }

    const PointFeatureMovePointVectorType::Distance_type& PointFeatureMovePointVectorType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    PointFeatureMovePointVectorType::Distance_type& PointFeatureMovePointVectorType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void PointFeatureMovePointVectorType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void PointFeatureMovePointVectorType::
    Distance (::std::unique_ptr< Distance_type > x)
    {
      this->Distance_.set (std::move (x));
    }

    const PointFeatureMovePointVectorType::Vector_type& PointFeatureMovePointVectorType::
    Vector () const
    {
      return this->Vector_.get ();
    }

    PointFeatureMovePointVectorType::Vector_type& PointFeatureMovePointVectorType::
    Vector ()
    {
      return this->Vector_.get ();
    }

    void PointFeatureMovePointVectorType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void PointFeatureMovePointVectorType::
    Vector (::std::unique_ptr< Vector_type > x)
    {
      this->Vector_.set (std::move (x));
    }


    // PointFeatureMovePointAxisType
    //

    const PointFeatureMovePointAxisType::BaseLocationFeature_type& PointFeatureMovePointAxisType::
    BaseLocationFeature () const
    {
      return this->BaseLocationFeature_.get ();
    }

    PointFeatureMovePointAxisType::BaseLocationFeature_type& PointFeatureMovePointAxisType::
    BaseLocationFeature ()
    {
      return this->BaseLocationFeature_.get ();
    }

    void PointFeatureMovePointAxisType::
    BaseLocationFeature (const BaseLocationFeature_type& x)
    {
      this->BaseLocationFeature_.set (x);
    }

    void PointFeatureMovePointAxisType::
    BaseLocationFeature (::std::unique_ptr< BaseLocationFeature_type > x)
    {
      this->BaseLocationFeature_.set (std::move (x));
    }

    const PointFeatureMovePointAxisType::Distance_type& PointFeatureMovePointAxisType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    PointFeatureMovePointAxisType::Distance_type& PointFeatureMovePointAxisType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void PointFeatureMovePointAxisType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void PointFeatureMovePointAxisType::
    Distance (::std::unique_ptr< Distance_type > x)
    {
      this->Distance_.set (std::move (x));
    }

    const PointFeatureMovePointAxisType::BaseAxisFeature_type& PointFeatureMovePointAxisType::
    BaseAxisFeature () const
    {
      return this->BaseAxisFeature_.get ();
    }

    PointFeatureMovePointAxisType::BaseAxisFeature_type& PointFeatureMovePointAxisType::
    BaseAxisFeature ()
    {
      return this->BaseAxisFeature_.get ();
    }

    void PointFeatureMovePointAxisType::
    BaseAxisFeature (const BaseAxisFeature_type& x)
    {
      this->BaseAxisFeature_.set (x);
    }

    void PointFeatureMovePointAxisType::
    BaseAxisFeature (::std::unique_ptr< BaseAxisFeature_type > x)
    {
      this->BaseAxisFeature_.set (std::move (x));
    }


    // PointFeatureExtremeType
    //

    const PointFeatureExtremeType::BaseFeature_type& PointFeatureExtremeType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureExtremeType::BaseFeature_type& PointFeatureExtremeType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureExtremeType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureExtremeType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }

    const PointFeatureExtremeType::Minimum_type& PointFeatureExtremeType::
    Minimum () const
    {
      return this->Minimum_.get ();
    }

    PointFeatureExtremeType::Minimum_type& PointFeatureExtremeType::
    Minimum ()
    {
      return this->Minimum_.get ();
    }

    void PointFeatureExtremeType::
    Minimum (const Minimum_type& x)
    {
      this->Minimum_.set (x);
    }

    PointFeatureExtremeType::Minimum_type PointFeatureExtremeType::
    Minimum_default_value ()
    {
      return Minimum_type (false);
    }

    const PointFeatureExtremeType::BaseAxisFeature_optional& PointFeatureExtremeType::
    BaseAxisFeature () const
    {
      return this->BaseAxisFeature_;
    }

    PointFeatureExtremeType::BaseAxisFeature_optional& PointFeatureExtremeType::
    BaseAxisFeature ()
    {
      return this->BaseAxisFeature_;
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (const BaseAxisFeature_type& x)
    {
      this->BaseAxisFeature_.set (x);
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (const BaseAxisFeature_optional& x)
    {
      this->BaseAxisFeature_ = x;
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (::std::unique_ptr< BaseAxisFeature_type > x)
    {
      this->BaseAxisFeature_.set (std::move (x));
    }

    const PointFeatureExtremeType::Vector_optional& PointFeatureExtremeType::
    Vector () const
    {
      return this->Vector_;
    }

    PointFeatureExtremeType::Vector_optional& PointFeatureExtremeType::
    Vector ()
    {
      return this->Vector_;
    }

    void PointFeatureExtremeType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void PointFeatureExtremeType::
    Vector (const Vector_optional& x)
    {
      this->Vector_ = x;
    }

    void PointFeatureExtremeType::
    Vector (::std::unique_ptr< Vector_type > x)
    {
      this->Vector_.set (std::move (x));
    }

    const PointFeatureExtremeType::Radial_optional& PointFeatureExtremeType::
    Radial () const
    {
      return this->Radial_;
    }

    PointFeatureExtremeType::Radial_optional& PointFeatureExtremeType::
    Radial ()
    {
      return this->Radial_;
    }

    void PointFeatureExtremeType::
    Radial (const Radial_type& x)
    {
      this->Radial_.set (x);
    }

    void PointFeatureExtremeType::
    Radial (const Radial_optional& x)
    {
      this->Radial_ = x;
    }

    void PointFeatureExtremeType::
    Radial (::std::unique_ptr< Radial_type > x)
    {
      this->Radial_.set (std::move (x));
    }

    const PointFeatureExtremeType::Radial_type& PointFeatureExtremeType::
    Radial_default_value ()
    {
      return Radial_default_value_;
    }

    const PointFeatureExtremeType::Xaxis_optional& PointFeatureExtremeType::
    Xaxis () const
    {
      return this->Xaxis_;
    }

    PointFeatureExtremeType::Xaxis_optional& PointFeatureExtremeType::
    Xaxis ()
    {
      return this->Xaxis_;
    }

    void PointFeatureExtremeType::
    Xaxis (const Xaxis_type& x)
    {
      this->Xaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Xaxis (const Xaxis_optional& x)
    {
      this->Xaxis_ = x;
    }

    void PointFeatureExtremeType::
    Xaxis (::std::unique_ptr< Xaxis_type > x)
    {
      this->Xaxis_.set (std::move (x));
    }

    const PointFeatureExtremeType::Xaxis_type& PointFeatureExtremeType::
    Xaxis_default_value ()
    {
      return Xaxis_default_value_;
    }

    const PointFeatureExtremeType::Yaxis_optional& PointFeatureExtremeType::
    Yaxis () const
    {
      return this->Yaxis_;
    }

    PointFeatureExtremeType::Yaxis_optional& PointFeatureExtremeType::
    Yaxis ()
    {
      return this->Yaxis_;
    }

    void PointFeatureExtremeType::
    Yaxis (const Yaxis_type& x)
    {
      this->Yaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Yaxis (const Yaxis_optional& x)
    {
      this->Yaxis_ = x;
    }

    void PointFeatureExtremeType::
    Yaxis (::std::unique_ptr< Yaxis_type > x)
    {
      this->Yaxis_.set (std::move (x));
    }

    const PointFeatureExtremeType::Yaxis_type& PointFeatureExtremeType::
    Yaxis_default_value ()
    {
      return Yaxis_default_value_;
    }

    const PointFeatureExtremeType::Zaxis_optional& PointFeatureExtremeType::
    Zaxis () const
    {
      return this->Zaxis_;
    }

    PointFeatureExtremeType::Zaxis_optional& PointFeatureExtremeType::
    Zaxis ()
    {
      return this->Zaxis_;
    }

    void PointFeatureExtremeType::
    Zaxis (const Zaxis_type& x)
    {
      this->Zaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Zaxis (const Zaxis_optional& x)
    {
      this->Zaxis_ = x;
    }

    void PointFeatureExtremeType::
    Zaxis (::std::unique_ptr< Zaxis_type > x)
    {
      this->Zaxis_.set (std::move (x));
    }

    const PointFeatureExtremeType::Zaxis_type& PointFeatureExtremeType::
    Zaxis_default_value ()
    {
      return Zaxis_default_value_;
    }


    // PointCheckedType
    //

    const PointCheckedType::Measured_optional& PointCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointCheckedType::Measured_optional& PointCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const PointCheckedType::Constructed_optional& PointCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointCheckedType::Constructed_optional& PointCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // PointCheckedFeatureType
    //

    const PointCheckedFeatureType::CheckDetails_optional& PointCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointCheckedFeatureType::CheckDetails_optional& PointCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // PointMeasurementDeterminationType
    //

    const PointMeasurementDeterminationType::Checked_optional& PointMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointMeasurementDeterminationType::Checked_optional& PointMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const PointMeasurementDeterminationType::Set_optional& PointMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointMeasurementDeterminationType::Set_optional& PointMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // PointFeatureItemType
    //

    const PointFeatureItemType::DeterminationMode_type& PointFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointFeatureItemType::DeterminationMode_type& PointFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // PointFeatureDefinitionType
    //


    // PointFeatureNominalType
    //

    const PointFeatureNominalType::Location_type& PointFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    PointFeatureNominalType::Location_type& PointFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void PointFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PointFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const PointFeatureNominalType::Normal_optional& PointFeatureNominalType::
    Normal () const
    {
      return this->Normal_;
    }

    PointFeatureNominalType::Normal_optional& PointFeatureNominalType::
    Normal ()
    {
      return this->Normal_;
    }

    void PointFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PointFeatureNominalType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PointFeatureNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const PointFeatureNominalType::Constructed_optional& PointFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointFeatureNominalType::Constructed_optional& PointFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // PointFeatureMeasurementType
    //

    const PointFeatureMeasurementType::Location_optional& PointFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    PointFeatureMeasurementType::Location_optional& PointFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void PointFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PointFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PointFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const PointFeatureMeasurementType::Normal_optional& PointFeatureMeasurementType::
    Normal () const
    {
      return this->Normal_;
    }

    PointFeatureMeasurementType::Normal_optional& PointFeatureMeasurementType::
    Normal ()
    {
      return this->Normal_;
    }

    void PointFeatureMeasurementType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PointFeatureMeasurementType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PointFeatureMeasurementType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }


    // SphereConstructionMethodType
    //

    const SphereConstructionMethodType::BestFit_optional& SphereConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SphereConstructionMethodType::BestFit_optional& SphereConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SphereConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SphereConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SphereConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const SphereConstructionMethodType::Recompensated_optional& SphereConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SphereConstructionMethodType::Recompensated_optional& SphereConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SphereConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SphereConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SphereConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const SphereConstructionMethodType::Copy_optional& SphereConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SphereConstructionMethodType::Copy_optional& SphereConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SphereConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SphereConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SphereConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const SphereConstructionMethodType::Cast_optional& SphereConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SphereConstructionMethodType::Cast_optional& SphereConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SphereConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SphereConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SphereConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const SphereConstructionMethodType::Transform_optional& SphereConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SphereConstructionMethodType::Transform_optional& SphereConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SphereConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SphereConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SphereConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const SphereConstructionMethodType::FromScan_optional& SphereConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    SphereConstructionMethodType::FromScan_optional& SphereConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void SphereConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void SphereConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void SphereConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // SphereBestFitType
    //

    const SphereBestFitType::BaseFeature_sequence& SphereBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SphereBestFitType::BaseFeature_sequence& SphereBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SphereBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const SphereBestFitType::n_type& SphereBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    SphereBestFitType::n_type& SphereBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void SphereBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SphereBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SphereRecompType
    //

    const SphereRecompType::BaseFeaturePointList_type& SphereRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SphereRecompType::BaseFeaturePointList_type& SphereRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SphereRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SphereRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // SphereCopyType
    //

    const SphereCopyType::BaseSphere_type& SphereCopyType::
    BaseSphere () const
    {
      return this->BaseSphere_.get ();
    }

    SphereCopyType::BaseSphere_type& SphereCopyType::
    BaseSphere ()
    {
      return this->BaseSphere_.get ();
    }

    void SphereCopyType::
    BaseSphere (const BaseSphere_type& x)
    {
      this->BaseSphere_.set (x);
    }

    void SphereCopyType::
    BaseSphere (::std::unique_ptr< BaseSphere_type > x)
    {
      this->BaseSphere_.set (std::move (x));
    }


    // SphereCastType
    //

    const SphereCastType::BaseFeature_type& SphereCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SphereCastType::BaseFeature_type& SphereCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SphereCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SphereCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // SphereTransformType
    //

    const SphereTransformType::BaseSphere_type& SphereTransformType::
    BaseSphere () const
    {
      return this->BaseSphere_.get ();
    }

    SphereTransformType::BaseSphere_type& SphereTransformType::
    BaseSphere ()
    {
      return this->BaseSphere_.get ();
    }

    void SphereTransformType::
    BaseSphere (const BaseSphere_type& x)
    {
      this->BaseSphere_.set (x);
    }

    void SphereTransformType::
    BaseSphere (::std::unique_ptr< BaseSphere_type > x)
    {
      this->BaseSphere_.set (std::move (x));
    }

    const SphereTransformType::Transformation_type& SphereTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SphereTransformType::Transformation_type& SphereTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SphereTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SphereTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // SphereFromScanType
    //

    const SphereFromScanType::SurfaceFeature_type& SphereFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    SphereFromScanType::SurfaceFeature_type& SphereFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void SphereFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void SphereFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const SphereFromScanType::SearchRadius_type& SphereFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    SphereFromScanType::SearchRadius_type& SphereFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void SphereFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void SphereFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }

    const SphereFromScanType::Vector_optional& SphereFromScanType::
    Vector () const
    {
      return this->Vector_;
    }

    SphereFromScanType::Vector_optional& SphereFromScanType::
    Vector ()
    {
      return this->Vector_;
    }

    void SphereFromScanType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void SphereFromScanType::
    Vector (const Vector_optional& x)
    {
      this->Vector_ = x;
    }

    void SphereFromScanType::
    Vector (::std::unique_ptr< Vector_type > x)
    {
      this->Vector_.set (std::move (x));
    }


    // SphereCheckedType
    //

    const SphereCheckedType::Measured_optional& SphereCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SphereCheckedType::Measured_optional& SphereCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SphereCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SphereCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SphereCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const SphereCheckedType::Constructed_optional& SphereCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SphereCheckedType::Constructed_optional& SphereCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SphereCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SphereCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SphereCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // SphereCheckedFeatureType
    //

    const SphereCheckedFeatureType::CheckDetails_optional& SphereCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SphereCheckedFeatureType::CheckDetails_optional& SphereCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SphereCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SphereCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SphereCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // SphereMeasurementDeterminationType
    //

    const SphereMeasurementDeterminationType::Checked_optional& SphereMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SphereMeasurementDeterminationType::Checked_optional& SphereMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SphereMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SphereMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SphereMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const SphereMeasurementDeterminationType::Set_optional& SphereMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SphereMeasurementDeterminationType::Set_optional& SphereMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SphereMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SphereMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SphereMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // SphereFeatureItemType
    //

    const SphereFeatureItemType::DeterminationMode_type& SphereFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SphereFeatureItemType::DeterminationMode_type& SphereFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SphereFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SphereFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // SphereFeatureDefinitionType
    //

    const SphereFeatureDefinitionType::InternalExternal_type& SphereFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SphereFeatureDefinitionType::InternalExternal_type& SphereFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SphereFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SphereFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const SphereFeatureDefinitionType::Diameter_type& SphereFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    SphereFeatureDefinitionType::Diameter_type& SphereFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void SphereFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphereFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }


    // SphereFeatureNominalType
    //

    const SphereFeatureNominalType::Location_type& SphereFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    SphereFeatureNominalType::Location_type& SphereFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void SphereFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphereFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const SphereFeatureNominalType::LatitudeLongitudeSweep_optional& SphereFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    SphereFeatureNominalType::LatitudeLongitudeSweep_optional& SphereFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (std::move (x));
    }

    const SphereFeatureNominalType::Constructed_optional& SphereFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SphereFeatureNominalType::Constructed_optional& SphereFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SphereFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SphereFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SphereFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // SphereFeatureMeasurementType
    //

    const SphereFeatureMeasurementType::Location_optional& SphereFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    SphereFeatureMeasurementType::Location_optional& SphereFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void SphereFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphereFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void SphereFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const SphereFeatureMeasurementType::Diameter_optional& SphereFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    SphereFeatureMeasurementType::Diameter_optional& SphereFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void SphereFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphereFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void SphereFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const SphereFeatureMeasurementType::DiameterMin_optional& SphereFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    SphereFeatureMeasurementType::DiameterMin_optional& SphereFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void SphereFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void SphereFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void SphereFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const SphereFeatureMeasurementType::DiameterMax_optional& SphereFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    SphereFeatureMeasurementType::DiameterMax_optional& SphereFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void SphereFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void SphereFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void SphereFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const SphereFeatureMeasurementType::LatitudeLongitudeSweepMeasurementRange_optional& SphereFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange () const
    {
      return this->LatitudeLongitudeSweepMeasurementRange_;
    }

    SphereFeatureMeasurementType::LatitudeLongitudeSweepMeasurementRange_optional& SphereFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange ()
    {
      return this->LatitudeLongitudeSweepMeasurementRange_;
    }

    void SphereFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_type& x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_.set (x);
    }

    void SphereFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_optional& x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_ = x;
    }

    void SphereFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_.set (std::move (x));
    }

    const SphereFeatureMeasurementType::LatitudeLongitudeSweepFull_optional& SphereFeatureMeasurementType::
    LatitudeLongitudeSweepFull () const
    {
      return this->LatitudeLongitudeSweepFull_;
    }

    SphereFeatureMeasurementType::LatitudeLongitudeSweepFull_optional& SphereFeatureMeasurementType::
    LatitudeLongitudeSweepFull ()
    {
      return this->LatitudeLongitudeSweepFull_;
    }

    void SphereFeatureMeasurementType::
    LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_type& x)
    {
      this->LatitudeLongitudeSweepFull_.set (x);
    }

    void SphereFeatureMeasurementType::
    LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_optional& x)
    {
      this->LatitudeLongitudeSweepFull_ = x;
    }

    void SphereFeatureMeasurementType::
    LatitudeLongitudeSweepFull (::std::unique_ptr< LatitudeLongitudeSweepFull_type > x)
    {
      this->LatitudeLongitudeSweepFull_.set (std::move (x));
    }

    const SphereFeatureMeasurementType::Form_optional& SphereFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    SphereFeatureMeasurementType::Form_optional& SphereFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void SphereFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SphereFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SphereFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // SphericalSegmentConstructionMethodType
    //

    const SphericalSegmentConstructionMethodType::BestFit_optional& SphericalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SphericalSegmentConstructionMethodType::BestFit_optional& SphericalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const SphericalSegmentConstructionMethodType::Recompensated_optional& SphericalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SphericalSegmentConstructionMethodType::Recompensated_optional& SphericalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const SphericalSegmentConstructionMethodType::Copy_optional& SphericalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SphericalSegmentConstructionMethodType::Copy_optional& SphericalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SphericalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const SphericalSegmentConstructionMethodType::Cast_optional& SphericalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SphericalSegmentConstructionMethodType::Cast_optional& SphericalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SphericalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const SphericalSegmentConstructionMethodType::Transform_optional& SphericalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SphericalSegmentConstructionMethodType::Transform_optional& SphericalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SphericalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // SphericalSegmentBestFitType
    //

    const SphericalSegmentBestFitType::BaseFeature_sequence& SphericalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SphericalSegmentBestFitType::BaseFeature_sequence& SphericalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SphericalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const SphericalSegmentBestFitType::n_type& SphericalSegmentBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    SphericalSegmentBestFitType::n_type& SphericalSegmentBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void SphericalSegmentBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SphericalSegmentBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SphericalSegmentRecompType
    //

    const SphericalSegmentRecompType::BaseFeaturePointList_type& SphericalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SphericalSegmentRecompType::BaseFeaturePointList_type& SphericalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SphericalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SphericalSegmentRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // SphericalSegmentCopyType
    //

    const SphericalSegmentCopyType::BaseSphericalSegment_type& SphericalSegmentCopyType::
    BaseSphericalSegment () const
    {
      return this->BaseSphericalSegment_.get ();
    }

    SphericalSegmentCopyType::BaseSphericalSegment_type& SphericalSegmentCopyType::
    BaseSphericalSegment ()
    {
      return this->BaseSphericalSegment_.get ();
    }

    void SphericalSegmentCopyType::
    BaseSphericalSegment (const BaseSphericalSegment_type& x)
    {
      this->BaseSphericalSegment_.set (x);
    }

    void SphericalSegmentCopyType::
    BaseSphericalSegment (::std::unique_ptr< BaseSphericalSegment_type > x)
    {
      this->BaseSphericalSegment_.set (std::move (x));
    }


    // SphericalSegmentCastType
    //

    const SphericalSegmentCastType::BaseFeature_type& SphericalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SphericalSegmentCastType::BaseFeature_type& SphericalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SphericalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SphericalSegmentCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // SphericalSegmentTransformType
    //

    const SphericalSegmentTransformType::BaseSphericalSegment_type& SphericalSegmentTransformType::
    BaseSphericalSegment () const
    {
      return this->BaseSphericalSegment_.get ();
    }

    SphericalSegmentTransformType::BaseSphericalSegment_type& SphericalSegmentTransformType::
    BaseSphericalSegment ()
    {
      return this->BaseSphericalSegment_.get ();
    }

    void SphericalSegmentTransformType::
    BaseSphericalSegment (const BaseSphericalSegment_type& x)
    {
      this->BaseSphericalSegment_.set (x);
    }

    void SphericalSegmentTransformType::
    BaseSphericalSegment (::std::unique_ptr< BaseSphericalSegment_type > x)
    {
      this->BaseSphericalSegment_.set (std::move (x));
    }

    const SphericalSegmentTransformType::Transformation_type& SphericalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SphericalSegmentTransformType::Transformation_type& SphericalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SphericalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SphericalSegmentTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // SphericalSegmentCheckedType
    //

    const SphericalSegmentCheckedType::Measured_optional& SphericalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SphericalSegmentCheckedType::Measured_optional& SphericalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SphericalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SphericalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SphericalSegmentCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const SphericalSegmentCheckedType::Constructed_optional& SphericalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SphericalSegmentCheckedType::Constructed_optional& SphericalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SphericalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SphericalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SphericalSegmentCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // SphericalSegmentCheckedFeatureType
    //

    const SphericalSegmentCheckedFeatureType::CheckDetails_optional& SphericalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SphericalSegmentCheckedFeatureType::CheckDetails_optional& SphericalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // SphericalSegmentMeasurementDeterminationType
    //

    const SphericalSegmentMeasurementDeterminationType::Checked_optional& SphericalSegmentMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SphericalSegmentMeasurementDeterminationType::Checked_optional& SphericalSegmentMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SphericalSegmentMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SphericalSegmentMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SphericalSegmentMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const SphericalSegmentMeasurementDeterminationType::Set_optional& SphericalSegmentMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SphericalSegmentMeasurementDeterminationType::Set_optional& SphericalSegmentMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SphericalSegmentMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SphericalSegmentMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SphericalSegmentMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // SphericalSegmentFeatureItemType
    //

    const SphericalSegmentFeatureItemType::DeterminationMode_type& SphericalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SphericalSegmentFeatureItemType::DeterminationMode_type& SphericalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SphericalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SphericalSegmentFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // SphericalSegmentFeatureDefinitionType
    //

    const SphericalSegmentFeatureDefinitionType::InternalExternal_type& SphericalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SphericalSegmentFeatureDefinitionType::InternalExternal_type& SphericalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SphericalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SphericalSegmentFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const SphericalSegmentFeatureDefinitionType::Diameter_type& SphericalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    SphericalSegmentFeatureDefinitionType::Diameter_type& SphericalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void SphericalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphericalSegmentFeatureDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }


    // SphericalSegmentFeatureNominalType
    //

    const SphericalSegmentFeatureNominalType::Location_type& SphericalSegmentFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    SphericalSegmentFeatureNominalType::Location_type& SphericalSegmentFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void SphericalSegmentFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphericalSegmentFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const SphericalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    SphericalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    void SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (std::move (x));
    }

    const SphericalSegmentFeatureNominalType::Constructed_optional& SphericalSegmentFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SphericalSegmentFeatureNominalType::Constructed_optional& SphericalSegmentFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SphericalSegmentFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SphericalSegmentFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SphericalSegmentFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // SphericalSegmentFeatureMeasurementType
    //

    const SphericalSegmentFeatureMeasurementType::Location_optional& SphericalSegmentFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    SphericalSegmentFeatureMeasurementType::Location_optional& SphericalSegmentFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void SphericalSegmentFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphericalSegmentFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void SphericalSegmentFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const SphericalSegmentFeatureMeasurementType::Diameter_optional& SphericalSegmentFeatureMeasurementType::
    Diameter () const
    {
      return this->Diameter_;
    }

    SphericalSegmentFeatureMeasurementType::Diameter_optional& SphericalSegmentFeatureMeasurementType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void SphericalSegmentFeatureMeasurementType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphericalSegmentFeatureMeasurementType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void SphericalSegmentFeatureMeasurementType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const SphericalSegmentFeatureMeasurementType::DiameterMin_optional& SphericalSegmentFeatureMeasurementType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    SphericalSegmentFeatureMeasurementType::DiameterMin_optional& SphericalSegmentFeatureMeasurementType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void SphericalSegmentFeatureMeasurementType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void SphericalSegmentFeatureMeasurementType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void SphericalSegmentFeatureMeasurementType::
    DiameterMin (::std::unique_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (std::move (x));
    }

    const SphericalSegmentFeatureMeasurementType::DiameterMax_optional& SphericalSegmentFeatureMeasurementType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    SphericalSegmentFeatureMeasurementType::DiameterMax_optional& SphericalSegmentFeatureMeasurementType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void SphericalSegmentFeatureMeasurementType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void SphericalSegmentFeatureMeasurementType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void SphericalSegmentFeatureMeasurementType::
    DiameterMax (::std::unique_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (std::move (x));
    }

    const SphericalSegmentFeatureMeasurementType::LatitudeLongitudeSweepMeasurementRange_optional& SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange () const
    {
      return this->LatitudeLongitudeSweepMeasurementRange_;
    }

    SphericalSegmentFeatureMeasurementType::LatitudeLongitudeSweepMeasurementRange_optional& SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange ()
    {
      return this->LatitudeLongitudeSweepMeasurementRange_;
    }

    void SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_type& x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_.set (x);
    }

    void SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_optional& x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_ = x;
    }

    void SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_.set (std::move (x));
    }

    const SphericalSegmentFeatureMeasurementType::LatitudeLongitudeSweepFull_optional& SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull () const
    {
      return this->LatitudeLongitudeSweepFull_;
    }

    SphericalSegmentFeatureMeasurementType::LatitudeLongitudeSweepFull_optional& SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull ()
    {
      return this->LatitudeLongitudeSweepFull_;
    }

    void SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_type& x)
    {
      this->LatitudeLongitudeSweepFull_.set (x);
    }

    void SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_optional& x)
    {
      this->LatitudeLongitudeSweepFull_ = x;
    }

    void SphericalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull (::std::unique_ptr< LatitudeLongitudeSweepFull_type > x)
    {
      this->LatitudeLongitudeSweepFull_.set (std::move (x));
    }

    const SphericalSegmentFeatureMeasurementType::Form_optional& SphericalSegmentFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    SphericalSegmentFeatureMeasurementType::Form_optional& SphericalSegmentFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void SphericalSegmentFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SphericalSegmentFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SphericalSegmentFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // SurfaceOfRevolutionConstructionMethodType
    //

    const SurfaceOfRevolutionConstructionMethodType::BestFit_optional& SurfaceOfRevolutionConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SurfaceOfRevolutionConstructionMethodType::BestFit_optional& SurfaceOfRevolutionConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const SurfaceOfRevolutionConstructionMethodType::Recompensated_optional& SurfaceOfRevolutionConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SurfaceOfRevolutionConstructionMethodType::Recompensated_optional& SurfaceOfRevolutionConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const SurfaceOfRevolutionConstructionMethodType::Copy_optional& SurfaceOfRevolutionConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SurfaceOfRevolutionConstructionMethodType::Copy_optional& SurfaceOfRevolutionConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const SurfaceOfRevolutionConstructionMethodType::Cast_optional& SurfaceOfRevolutionConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SurfaceOfRevolutionConstructionMethodType::Cast_optional& SurfaceOfRevolutionConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const SurfaceOfRevolutionConstructionMethodType::Transform_optional& SurfaceOfRevolutionConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SurfaceOfRevolutionConstructionMethodType::Transform_optional& SurfaceOfRevolutionConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // SurfaceOfRevolutionBestFitType
    //

    const SurfaceOfRevolutionBestFitType::BaseFeature_sequence& SurfaceOfRevolutionBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SurfaceOfRevolutionBestFitType::BaseFeature_sequence& SurfaceOfRevolutionBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SurfaceOfRevolutionBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const SurfaceOfRevolutionBestFitType::n_type& SurfaceOfRevolutionBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    SurfaceOfRevolutionBestFitType::n_type& SurfaceOfRevolutionBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void SurfaceOfRevolutionBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void SurfaceOfRevolutionBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // SurfaceOfRevolutionRecompType
    //

    const SurfaceOfRevolutionRecompType::BaseFeaturePointList_type& SurfaceOfRevolutionRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SurfaceOfRevolutionRecompType::BaseFeaturePointList_type& SurfaceOfRevolutionRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SurfaceOfRevolutionRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SurfaceOfRevolutionRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // SurfaceOfRevolutionCopyType
    //

    const SurfaceOfRevolutionCopyType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution () const
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    SurfaceOfRevolutionCopyType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution ()
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    void SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution (const BaseSurfaceOfRevolution_type& x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }

    void SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution (::std::unique_ptr< BaseSurfaceOfRevolution_type > x)
    {
      this->BaseSurfaceOfRevolution_.set (std::move (x));
    }


    // SurfaceOfRevolutionCastType
    //

    const SurfaceOfRevolutionCastType::BaseFeature_type& SurfaceOfRevolutionCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SurfaceOfRevolutionCastType::BaseFeature_type& SurfaceOfRevolutionCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SurfaceOfRevolutionCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SurfaceOfRevolutionCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // SurfaceOfRevolutionTransformType
    //

    const SurfaceOfRevolutionTransformType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution () const
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    SurfaceOfRevolutionTransformType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution ()
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    void SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution (const BaseSurfaceOfRevolution_type& x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }

    void SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution (::std::unique_ptr< BaseSurfaceOfRevolution_type > x)
    {
      this->BaseSurfaceOfRevolution_.set (std::move (x));
    }

    const SurfaceOfRevolutionTransformType::Transformation_type& SurfaceOfRevolutionTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SurfaceOfRevolutionTransformType::Transformation_type& SurfaceOfRevolutionTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SurfaceOfRevolutionTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SurfaceOfRevolutionTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // SurfaceOfRevolutionCheckedType
    //

    const SurfaceOfRevolutionCheckedType::Measured_optional& SurfaceOfRevolutionCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SurfaceOfRevolutionCheckedType::Measured_optional& SurfaceOfRevolutionCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const SurfaceOfRevolutionCheckedType::Constructed_optional& SurfaceOfRevolutionCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SurfaceOfRevolutionCheckedType::Constructed_optional& SurfaceOfRevolutionCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // SurfaceOfRevolutionCheckedFeatureType
    //

    const SurfaceOfRevolutionCheckedFeatureType::CheckDetails_optional& SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SurfaceOfRevolutionCheckedFeatureType::CheckDetails_optional& SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // SurfaceOfRevolutionMeasurementDeterminationType
    //

    const SurfaceOfRevolutionMeasurementDeterminationType::Checked_optional& SurfaceOfRevolutionMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SurfaceOfRevolutionMeasurementDeterminationType::Checked_optional& SurfaceOfRevolutionMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SurfaceOfRevolutionMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SurfaceOfRevolutionMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SurfaceOfRevolutionMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const SurfaceOfRevolutionMeasurementDeterminationType::Set_optional& SurfaceOfRevolutionMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SurfaceOfRevolutionMeasurementDeterminationType::Set_optional& SurfaceOfRevolutionMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SurfaceOfRevolutionMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SurfaceOfRevolutionMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SurfaceOfRevolutionMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // SurfaceOfRevolutionFeatureItemType
    //

    const SurfaceOfRevolutionFeatureItemType::DeterminationMode_type& SurfaceOfRevolutionFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SurfaceOfRevolutionFeatureItemType::DeterminationMode_type& SurfaceOfRevolutionFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SurfaceOfRevolutionFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SurfaceOfRevolutionFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // SurfaceOfRevolutionFeatureDefinitionType
    //

    const SurfaceOfRevolutionFeatureDefinitionType::InternalExternal_type& SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SurfaceOfRevolutionFeatureDefinitionType::InternalExternal_type& SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const SurfaceOfRevolutionFeatureDefinitionType::Length_optional& SurfaceOfRevolutionFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    SurfaceOfRevolutionFeatureDefinitionType::Length_optional& SurfaceOfRevolutionFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }


    // SurfaceOfRevolutionFeatureNominalType
    //

    const SurfaceOfRevolutionFeatureNominalType::Axis_type& SurfaceOfRevolutionFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    SurfaceOfRevolutionFeatureNominalType::Axis_type& SurfaceOfRevolutionFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const SurfaceOfRevolutionFeatureNominalType::Sweep_optional& SurfaceOfRevolutionFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    SurfaceOfRevolutionFeatureNominalType::Sweep_optional& SurfaceOfRevolutionFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (::std::unique_ptr< Sweep_type > x)
    {
      this->Sweep_.set (std::move (x));
    }

    const SurfaceOfRevolutionFeatureNominalType::ReferenceFeatureNominalId_optional& SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId () const
    {
      return this->ReferenceFeatureNominalId_;
    }

    SurfaceOfRevolutionFeatureNominalType::ReferenceFeatureNominalId_optional& SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId ()
    {
      return this->ReferenceFeatureNominalId_;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId (const ReferenceFeatureNominalId_type& x)
    {
      this->ReferenceFeatureNominalId_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId (const ReferenceFeatureNominalId_optional& x)
    {
      this->ReferenceFeatureNominalId_ = x;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId (::std::unique_ptr< ReferenceFeatureNominalId_type > x)
    {
      this->ReferenceFeatureNominalId_.set (std::move (x));
    }

    const SurfaceOfRevolutionFeatureNominalType::Constructed_optional& SurfaceOfRevolutionFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SurfaceOfRevolutionFeatureNominalType::Constructed_optional& SurfaceOfRevolutionFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // SurfaceOfRevolutionFeatureMeasurementType
    //

    const SurfaceOfRevolutionFeatureMeasurementType::Axis_optional& SurfaceOfRevolutionFeatureMeasurementType::
    Axis () const
    {
      return this->Axis_;
    }

    SurfaceOfRevolutionFeatureMeasurementType::Axis_optional& SurfaceOfRevolutionFeatureMeasurementType::
    Axis ()
    {
      return this->Axis_;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const SurfaceOfRevolutionFeatureMeasurementType::SweepMeasurementRange_optional& SurfaceOfRevolutionFeatureMeasurementType::
    SweepMeasurementRange () const
    {
      return this->SweepMeasurementRange_;
    }

    SurfaceOfRevolutionFeatureMeasurementType::SweepMeasurementRange_optional& SurfaceOfRevolutionFeatureMeasurementType::
    SweepMeasurementRange ()
    {
      return this->SweepMeasurementRange_;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_type& x)
    {
      this->SweepMeasurementRange_.set (x);
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    SweepMeasurementRange (const SweepMeasurementRange_optional& x)
    {
      this->SweepMeasurementRange_ = x;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    SweepMeasurementRange (::std::unique_ptr< SweepMeasurementRange_type > x)
    {
      this->SweepMeasurementRange_.set (std::move (x));
    }

    const SurfaceOfRevolutionFeatureMeasurementType::SweepFull_optional& SurfaceOfRevolutionFeatureMeasurementType::
    SweepFull () const
    {
      return this->SweepFull_;
    }

    SurfaceOfRevolutionFeatureMeasurementType::SweepFull_optional& SurfaceOfRevolutionFeatureMeasurementType::
    SweepFull ()
    {
      return this->SweepFull_;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    SweepFull (const SweepFull_type& x)
    {
      this->SweepFull_.set (x);
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    SweepFull (const SweepFull_optional& x)
    {
      this->SweepFull_ = x;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    SweepFull (::std::unique_ptr< SweepFull_type > x)
    {
      this->SweepFull_.set (std::move (x));
    }

    const SurfaceOfRevolutionFeatureMeasurementType::Length_optional& SurfaceOfRevolutionFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    SurfaceOfRevolutionFeatureMeasurementType::Length_optional& SurfaceOfRevolutionFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const SurfaceOfRevolutionFeatureMeasurementType::Form_optional& SurfaceOfRevolutionFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    SurfaceOfRevolutionFeatureMeasurementType::Form_optional& SurfaceOfRevolutionFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // ThreadedFeatureConstructionMethodType
    //

    const ThreadedFeatureConstructionMethodType::BestFit_optional& ThreadedFeatureConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ThreadedFeatureConstructionMethodType::BestFit_optional& ThreadedFeatureConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const ThreadedFeatureConstructionMethodType::Recompensated_optional& ThreadedFeatureConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ThreadedFeatureConstructionMethodType::Recompensated_optional& ThreadedFeatureConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const ThreadedFeatureConstructionMethodType::Copy_optional& ThreadedFeatureConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ThreadedFeatureConstructionMethodType::Copy_optional& ThreadedFeatureConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const ThreadedFeatureConstructionMethodType::Cast_optional& ThreadedFeatureConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ThreadedFeatureConstructionMethodType::Cast_optional& ThreadedFeatureConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const ThreadedFeatureConstructionMethodType::Transform_optional& ThreadedFeatureConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ThreadedFeatureConstructionMethodType::Transform_optional& ThreadedFeatureConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const ThreadedFeatureConstructionMethodType::FromCylinder_optional& ThreadedFeatureConstructionMethodType::
    FromCylinder () const
    {
      return this->FromCylinder_;
    }

    ThreadedFeatureConstructionMethodType::FromCylinder_optional& ThreadedFeatureConstructionMethodType::
    FromCylinder ()
    {
      return this->FromCylinder_;
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (const FromCylinder_type& x)
    {
      this->FromCylinder_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (const FromCylinder_optional& x)
    {
      this->FromCylinder_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (::std::unique_ptr< FromCylinder_type > x)
    {
      this->FromCylinder_.set (std::move (x));
    }


    // ThreadedFeatureBestFitType
    //

    const ThreadedFeatureBestFitType::BaseFeature_sequence& ThreadedFeatureBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ThreadedFeatureBestFitType::BaseFeature_sequence& ThreadedFeatureBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ThreadedFeatureBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const ThreadedFeatureBestFitType::n_type& ThreadedFeatureBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    ThreadedFeatureBestFitType::n_type& ThreadedFeatureBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void ThreadedFeatureBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ThreadedFeatureBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ThreadedFeatureRecompType
    //

    const ThreadedFeatureRecompType::BaseFeaturePointList_type& ThreadedFeatureRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ThreadedFeatureRecompType::BaseFeaturePointList_type& ThreadedFeatureRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ThreadedFeatureRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ThreadedFeatureRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // ThreadedFeatureCopyType
    //

    const ThreadedFeatureCopyType::BaseThreadedFeature_type& ThreadedFeatureCopyType::
    BaseThreadedFeature () const
    {
      return this->BaseThreadedFeature_.get ();
    }

    ThreadedFeatureCopyType::BaseThreadedFeature_type& ThreadedFeatureCopyType::
    BaseThreadedFeature ()
    {
      return this->BaseThreadedFeature_.get ();
    }

    void ThreadedFeatureCopyType::
    BaseThreadedFeature (const BaseThreadedFeature_type& x)
    {
      this->BaseThreadedFeature_.set (x);
    }

    void ThreadedFeatureCopyType::
    BaseThreadedFeature (::std::unique_ptr< BaseThreadedFeature_type > x)
    {
      this->BaseThreadedFeature_.set (std::move (x));
    }


    // ThreadedFeatureCastType
    //

    const ThreadedFeatureCastType::BaseFeature_type& ThreadedFeatureCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ThreadedFeatureCastType::BaseFeature_type& ThreadedFeatureCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ThreadedFeatureCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ThreadedFeatureCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // ThreadedFeatureTransformType
    //

    const ThreadedFeatureTransformType::BaseThreadedFeature_type& ThreadedFeatureTransformType::
    BaseThreadedFeature () const
    {
      return this->BaseThreadedFeature_.get ();
    }

    ThreadedFeatureTransformType::BaseThreadedFeature_type& ThreadedFeatureTransformType::
    BaseThreadedFeature ()
    {
      return this->BaseThreadedFeature_.get ();
    }

    void ThreadedFeatureTransformType::
    BaseThreadedFeature (const BaseThreadedFeature_type& x)
    {
      this->BaseThreadedFeature_.set (x);
    }

    void ThreadedFeatureTransformType::
    BaseThreadedFeature (::std::unique_ptr< BaseThreadedFeature_type > x)
    {
      this->BaseThreadedFeature_.set (std::move (x));
    }

    const ThreadedFeatureTransformType::Transformation_type& ThreadedFeatureTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ThreadedFeatureTransformType::Transformation_type& ThreadedFeatureTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ThreadedFeatureTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ThreadedFeatureTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // ThreadedFeatureFromCylinderType
    //

    const ThreadedFeatureFromCylinderType::BaseCylinder_type& ThreadedFeatureFromCylinderType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    ThreadedFeatureFromCylinderType::BaseCylinder_type& ThreadedFeatureFromCylinderType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void ThreadedFeatureFromCylinderType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void ThreadedFeatureFromCylinderType::
    BaseCylinder (::std::unique_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (std::move (x));
    }

    const ThreadedFeatureFromCylinderType::Offset_optional& ThreadedFeatureFromCylinderType::
    Offset () const
    {
      return this->Offset_;
    }

    ThreadedFeatureFromCylinderType::Offset_optional& ThreadedFeatureFromCylinderType::
    Offset ()
    {
      return this->Offset_;
    }

    void ThreadedFeatureFromCylinderType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void ThreadedFeatureFromCylinderType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void ThreadedFeatureFromCylinderType::
    Offset (::std::unique_ptr< Offset_type > x)
    {
      this->Offset_.set (std::move (x));
    }


    // ThreadedFeatureCheckedType
    //

    const ThreadedFeatureCheckedType::Measured_optional& ThreadedFeatureCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ThreadedFeatureCheckedType::Measured_optional& ThreadedFeatureCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ThreadedFeatureCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ThreadedFeatureCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ThreadedFeatureCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const ThreadedFeatureCheckedType::Constructed_optional& ThreadedFeatureCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ThreadedFeatureCheckedType::Constructed_optional& ThreadedFeatureCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ThreadedFeatureCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ThreadedFeatureCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ThreadedFeatureCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ThreadedFeatureCheckedFeatureType
    //

    const ThreadedFeatureCheckedFeatureType::CheckDetails_optional& ThreadedFeatureCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ThreadedFeatureCheckedFeatureType::CheckDetails_optional& ThreadedFeatureCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // ThreadedFeatureMeasurementDeterminationType
    //

    const ThreadedFeatureMeasurementDeterminationType::Checked_optional& ThreadedFeatureMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ThreadedFeatureMeasurementDeterminationType::Checked_optional& ThreadedFeatureMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ThreadedFeatureMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ThreadedFeatureMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ThreadedFeatureMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const ThreadedFeatureMeasurementDeterminationType::Set_optional& ThreadedFeatureMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ThreadedFeatureMeasurementDeterminationType::Set_optional& ThreadedFeatureMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ThreadedFeatureMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ThreadedFeatureMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ThreadedFeatureMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // ThreadedFeatureItemType
    //

    const ThreadedFeatureItemType::DeterminationMode_type& ThreadedFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ThreadedFeatureItemType::DeterminationMode_type& ThreadedFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ThreadedFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ThreadedFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // ThreadedFeatureDefinitionType
    //

    const ThreadedFeatureDefinitionType::InternalExternal_type& ThreadedFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ThreadedFeatureDefinitionType::InternalExternal_type& ThreadedFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ThreadedFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const ThreadedFeatureDefinitionType::ThreadSpecificationId_type& ThreadedFeatureDefinitionType::
    ThreadSpecificationId () const
    {
      return this->ThreadSpecificationId_.get ();
    }

    ThreadedFeatureDefinitionType::ThreadSpecificationId_type& ThreadedFeatureDefinitionType::
    ThreadSpecificationId ()
    {
      return this->ThreadSpecificationId_.get ();
    }

    void ThreadedFeatureDefinitionType::
    ThreadSpecificationId (const ThreadSpecificationId_type& x)
    {
      this->ThreadSpecificationId_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    ThreadSpecificationId (::std::unique_ptr< ThreadSpecificationId_type > x)
    {
      this->ThreadSpecificationId_.set (std::move (x));
    }

    const ThreadedFeatureDefinitionType::Length_optional& ThreadedFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    ThreadedFeatureDefinitionType::Length_optional& ThreadedFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void ThreadedFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ThreadedFeatureDefinitionType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }

    const ThreadedFeatureDefinitionType::Bottom_optional& ThreadedFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    ThreadedFeatureDefinitionType::Bottom_optional& ThreadedFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void ThreadedFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void ThreadedFeatureDefinitionType::
    Bottom (::std::unique_ptr< Bottom_type > x)
    {
      this->Bottom_.set (std::move (x));
    }


    // ThreadedFeatureNominalType
    //

    const ThreadedFeatureNominalType::Axis_type& ThreadedFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ThreadedFeatureNominalType::Axis_type& ThreadedFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ThreadedFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ThreadedFeatureNominalType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const ThreadedFeatureNominalType::Constructed_optional& ThreadedFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ThreadedFeatureNominalType::Constructed_optional& ThreadedFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ThreadedFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ThreadedFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ThreadedFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ThreadedFeatureMeasurementType
    //

    const ThreadedFeatureMeasurementType::Axis_optional& ThreadedFeatureMeasurementType::
    Axis () const
    {
      return this->Axis_;
    }

    ThreadedFeatureMeasurementType::Axis_optional& ThreadedFeatureMeasurementType::
    Axis ()
    {
      return this->Axis_;
    }

    void ThreadedFeatureMeasurementType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ThreadedFeatureMeasurementType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ThreadedFeatureMeasurementType::
    Axis (::std::unique_ptr< Axis_type > x)
    {
      this->Axis_.set (std::move (x));
    }

    const ThreadedFeatureMeasurementType::PitchDiameter_optional& ThreadedFeatureMeasurementType::
    PitchDiameter () const
    {
      return this->PitchDiameter_;
    }

    ThreadedFeatureMeasurementType::PitchDiameter_optional& ThreadedFeatureMeasurementType::
    PitchDiameter ()
    {
      return this->PitchDiameter_;
    }

    void ThreadedFeatureMeasurementType::
    PitchDiameter (const PitchDiameter_type& x)
    {
      this->PitchDiameter_.set (x);
    }

    void ThreadedFeatureMeasurementType::
    PitchDiameter (const PitchDiameter_optional& x)
    {
      this->PitchDiameter_ = x;
    }

    void ThreadedFeatureMeasurementType::
    PitchDiameter (::std::unique_ptr< PitchDiameter_type > x)
    {
      this->PitchDiameter_.set (std::move (x));
    }

    const ThreadedFeatureMeasurementType::FunctionalSize_optional& ThreadedFeatureMeasurementType::
    FunctionalSize () const
    {
      return this->FunctionalSize_;
    }

    ThreadedFeatureMeasurementType::FunctionalSize_optional& ThreadedFeatureMeasurementType::
    FunctionalSize ()
    {
      return this->FunctionalSize_;
    }

    void ThreadedFeatureMeasurementType::
    FunctionalSize (const FunctionalSize_type& x)
    {
      this->FunctionalSize_.set (x);
    }

    void ThreadedFeatureMeasurementType::
    FunctionalSize (const FunctionalSize_optional& x)
    {
      this->FunctionalSize_ = x;
    }

    void ThreadedFeatureMeasurementType::
    FunctionalSize (::std::unique_ptr< FunctionalSize_type > x)
    {
      this->FunctionalSize_.set (std::move (x));
    }

    const ThreadedFeatureMeasurementType::Length_optional& ThreadedFeatureMeasurementType::
    Length () const
    {
      return this->Length_;
    }

    ThreadedFeatureMeasurementType::Length_optional& ThreadedFeatureMeasurementType::
    Length ()
    {
      return this->Length_;
    }

    void ThreadedFeatureMeasurementType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ThreadedFeatureMeasurementType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ThreadedFeatureMeasurementType::
    Length (::std::unique_ptr< Length_type > x)
    {
      this->Length_.set (std::move (x));
    }


    // ToroidalSegmentConstructionMethodType
    //

    const ToroidalSegmentConstructionMethodType::BestFit_optional& ToroidalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ToroidalSegmentConstructionMethodType::BestFit_optional& ToroidalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const ToroidalSegmentConstructionMethodType::Recompensated_optional& ToroidalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ToroidalSegmentConstructionMethodType::Recompensated_optional& ToroidalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const ToroidalSegmentConstructionMethodType::Copy_optional& ToroidalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ToroidalSegmentConstructionMethodType::Copy_optional& ToroidalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const ToroidalSegmentConstructionMethodType::Cast_optional& ToroidalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ToroidalSegmentConstructionMethodType::Cast_optional& ToroidalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const ToroidalSegmentConstructionMethodType::Transform_optional& ToroidalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ToroidalSegmentConstructionMethodType::Transform_optional& ToroidalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // ToroidalSegmentBestFitType
    //

    const ToroidalSegmentBestFitType::BaseFeature_sequence& ToroidalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ToroidalSegmentBestFitType::BaseFeature_sequence& ToroidalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ToroidalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const ToroidalSegmentBestFitType::n_type& ToroidalSegmentBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    ToroidalSegmentBestFitType::n_type& ToroidalSegmentBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void ToroidalSegmentBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ToroidalSegmentBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ToroidalSegmentRecompType
    //

    const ToroidalSegmentRecompType::BaseFeaturePointList_type& ToroidalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ToroidalSegmentRecompType::BaseFeaturePointList_type& ToroidalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ToroidalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ToroidalSegmentRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // ToroidalSegmentCopyType
    //

    const ToroidalSegmentCopyType::BaseToroidalSegment_type& ToroidalSegmentCopyType::
    BaseToroidalSegment () const
    {
      return this->BaseToroidalSegment_.get ();
    }

    ToroidalSegmentCopyType::BaseToroidalSegment_type& ToroidalSegmentCopyType::
    BaseToroidalSegment ()
    {
      return this->BaseToroidalSegment_.get ();
    }

    void ToroidalSegmentCopyType::
    BaseToroidalSegment (const BaseToroidalSegment_type& x)
    {
      this->BaseToroidalSegment_.set (x);
    }

    void ToroidalSegmentCopyType::
    BaseToroidalSegment (::std::unique_ptr< BaseToroidalSegment_type > x)
    {
      this->BaseToroidalSegment_.set (std::move (x));
    }


    // ToroidalSegmentCastType
    //

    const ToroidalSegmentCastType::BaseFeature_type& ToroidalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ToroidalSegmentCastType::BaseFeature_type& ToroidalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ToroidalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ToroidalSegmentCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // ToroidalSegmentTransformType
    //

    const ToroidalSegmentTransformType::BaseToroidalSegment_type& ToroidalSegmentTransformType::
    BaseToroidalSegment () const
    {
      return this->BaseToroidalSegment_.get ();
    }

    ToroidalSegmentTransformType::BaseToroidalSegment_type& ToroidalSegmentTransformType::
    BaseToroidalSegment ()
    {
      return this->BaseToroidalSegment_.get ();
    }

    void ToroidalSegmentTransformType::
    BaseToroidalSegment (const BaseToroidalSegment_type& x)
    {
      this->BaseToroidalSegment_.set (x);
    }

    void ToroidalSegmentTransformType::
    BaseToroidalSegment (::std::unique_ptr< BaseToroidalSegment_type > x)
    {
      this->BaseToroidalSegment_.set (std::move (x));
    }

    const ToroidalSegmentTransformType::Transformation_type& ToroidalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ToroidalSegmentTransformType::Transformation_type& ToroidalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ToroidalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ToroidalSegmentTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // ToroidalSegmentCheckedType
    //

    const ToroidalSegmentCheckedType::Measured_optional& ToroidalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ToroidalSegmentCheckedType::Measured_optional& ToroidalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ToroidalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ToroidalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ToroidalSegmentCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const ToroidalSegmentCheckedType::Constructed_optional& ToroidalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ToroidalSegmentCheckedType::Constructed_optional& ToroidalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ToroidalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ToroidalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ToroidalSegmentCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ToroidalSegmentCheckedFeatureType
    //

    const ToroidalSegmentCheckedFeatureType::CheckDetails_optional& ToroidalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ToroidalSegmentCheckedFeatureType::CheckDetails_optional& ToroidalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // ToroidalSegmentMeasurementDeterminationType
    //

    const ToroidalSegmentMeasurementDeterminationType::Checked_optional& ToroidalSegmentMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ToroidalSegmentMeasurementDeterminationType::Checked_optional& ToroidalSegmentMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ToroidalSegmentMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ToroidalSegmentMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ToroidalSegmentMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const ToroidalSegmentMeasurementDeterminationType::Set_optional& ToroidalSegmentMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ToroidalSegmentMeasurementDeterminationType::Set_optional& ToroidalSegmentMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ToroidalSegmentMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ToroidalSegmentMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ToroidalSegmentMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // ToroidalSegmentFeatureItemType
    //

    const ToroidalSegmentFeatureItemType::DeterminationMode_type& ToroidalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ToroidalSegmentFeatureItemType::DeterminationMode_type& ToroidalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ToroidalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ToroidalSegmentFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // ToroidalSegmentFeatureDefinitionType
    //

    const ToroidalSegmentFeatureDefinitionType::InternalExternal_type& ToroidalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::InternalExternal_type& ToroidalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const ToroidalSegmentFeatureDefinitionType::MinorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::MinorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    MinorDiameter (::std::unique_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (std::move (x));
    }

    const ToroidalSegmentFeatureDefinitionType::MajorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::MajorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    MajorDiameter (::std::unique_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (std::move (x));
    }


    // ToroidalSegmentFeatureNominalType
    //

    const ToroidalSegmentFeatureNominalType::Location_type& ToroidalSegmentFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    ToroidalSegmentFeatureNominalType::Location_type& ToroidalSegmentFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const ToroidalSegmentFeatureNominalType::AxisVector_type& ToroidalSegmentFeatureNominalType::
    AxisVector () const
    {
      return this->AxisVector_.get ();
    }

    ToroidalSegmentFeatureNominalType::AxisVector_type& ToroidalSegmentFeatureNominalType::
    AxisVector ()
    {
      return this->AxisVector_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    AxisVector (::std::unique_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (std::move (x));
    }

    const ToroidalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    ToroidalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (std::move (x));
    }

    const ToroidalSegmentFeatureNominalType::Constructed_optional& ToroidalSegmentFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ToroidalSegmentFeatureNominalType::Constructed_optional& ToroidalSegmentFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ToroidalSegmentFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ToroidalSegmentFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // ToroidalSegmentFeatureMeasurementType
    //

    const ToroidalSegmentFeatureMeasurementType::Location_optional& ToroidalSegmentFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    ToroidalSegmentFeatureMeasurementType::Location_optional& ToroidalSegmentFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void ToroidalSegmentFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ToroidalSegmentFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void ToroidalSegmentFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const ToroidalSegmentFeatureMeasurementType::AxisVector_optional& ToroidalSegmentFeatureMeasurementType::
    AxisVector () const
    {
      return this->AxisVector_;
    }

    ToroidalSegmentFeatureMeasurementType::AxisVector_optional& ToroidalSegmentFeatureMeasurementType::
    AxisVector ()
    {
      return this->AxisVector_;
    }

    void ToroidalSegmentFeatureMeasurementType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void ToroidalSegmentFeatureMeasurementType::
    AxisVector (const AxisVector_optional& x)
    {
      this->AxisVector_ = x;
    }

    void ToroidalSegmentFeatureMeasurementType::
    AxisVector (::std::unique_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (std::move (x));
    }

    const ToroidalSegmentFeatureMeasurementType::MinorDiameter_optional& ToroidalSegmentFeatureMeasurementType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    ToroidalSegmentFeatureMeasurementType::MinorDiameter_optional& ToroidalSegmentFeatureMeasurementType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void ToroidalSegmentFeatureMeasurementType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureMeasurementType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void ToroidalSegmentFeatureMeasurementType::
    MinorDiameter (::std::unique_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (std::move (x));
    }

    const ToroidalSegmentFeatureMeasurementType::MajorDiameter_optional& ToroidalSegmentFeatureMeasurementType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    ToroidalSegmentFeatureMeasurementType::MajorDiameter_optional& ToroidalSegmentFeatureMeasurementType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void ToroidalSegmentFeatureMeasurementType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureMeasurementType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void ToroidalSegmentFeatureMeasurementType::
    MajorDiameter (::std::unique_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (std::move (x));
    }

    const ToroidalSegmentFeatureMeasurementType::LatitudeLongitudeSweepMeasurementRange_optional& ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange () const
    {
      return this->LatitudeLongitudeSweepMeasurementRange_;
    }

    ToroidalSegmentFeatureMeasurementType::LatitudeLongitudeSweepMeasurementRange_optional& ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange ()
    {
      return this->LatitudeLongitudeSweepMeasurementRange_;
    }

    void ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_type& x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_.set (x);
    }

    void ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_optional& x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_ = x;
    }

    void ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_.set (std::move (x));
    }

    const ToroidalSegmentFeatureMeasurementType::LatitudeLongitudeSweepFull_optional& ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull () const
    {
      return this->LatitudeLongitudeSweepFull_;
    }

    ToroidalSegmentFeatureMeasurementType::LatitudeLongitudeSweepFull_optional& ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull ()
    {
      return this->LatitudeLongitudeSweepFull_;
    }

    void ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_type& x)
    {
      this->LatitudeLongitudeSweepFull_.set (x);
    }

    void ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_optional& x)
    {
      this->LatitudeLongitudeSweepFull_ = x;
    }

    void ToroidalSegmentFeatureMeasurementType::
    LatitudeLongitudeSweepFull (::std::unique_ptr< LatitudeLongitudeSweepFull_type > x)
    {
      this->LatitudeLongitudeSweepFull_.set (std::move (x));
    }

    const ToroidalSegmentFeatureMeasurementType::Form_optional& ToroidalSegmentFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    ToroidalSegmentFeatureMeasurementType::Form_optional& ToroidalSegmentFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void ToroidalSegmentFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ToroidalSegmentFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ToroidalSegmentFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // TorusConstructionMethodType
    //

    const TorusConstructionMethodType::BestFit_optional& TorusConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    TorusConstructionMethodType::BestFit_optional& TorusConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void TorusConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void TorusConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void TorusConstructionMethodType::
    BestFit (::std::unique_ptr< BestFit_type > x)
    {
      this->BestFit_.set (std::move (x));
    }

    const TorusConstructionMethodType::Recompensated_optional& TorusConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    TorusConstructionMethodType::Recompensated_optional& TorusConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void TorusConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void TorusConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void TorusConstructionMethodType::
    Recompensated (::std::unique_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (std::move (x));
    }

    const TorusConstructionMethodType::Copy_optional& TorusConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    TorusConstructionMethodType::Copy_optional& TorusConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void TorusConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void TorusConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void TorusConstructionMethodType::
    Copy (::std::unique_ptr< Copy_type > x)
    {
      this->Copy_.set (std::move (x));
    }

    const TorusConstructionMethodType::Cast_optional& TorusConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    TorusConstructionMethodType::Cast_optional& TorusConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void TorusConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void TorusConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void TorusConstructionMethodType::
    Cast (::std::unique_ptr< Cast_type > x)
    {
      this->Cast_.set (std::move (x));
    }

    const TorusConstructionMethodType::Transform_optional& TorusConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    TorusConstructionMethodType::Transform_optional& TorusConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void TorusConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void TorusConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void TorusConstructionMethodType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const TorusConstructionMethodType::FromScan_optional& TorusConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    TorusConstructionMethodType::FromScan_optional& TorusConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void TorusConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void TorusConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void TorusConstructionMethodType::
    FromScan (::std::unique_ptr< FromScan_type > x)
    {
      this->FromScan_.set (std::move (x));
    }


    // TorusBestFitType
    //

    const TorusBestFitType::BaseFeature_sequence& TorusBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    TorusBestFitType::BaseFeature_sequence& TorusBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void TorusBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }

    const TorusBestFitType::n_type& TorusBestFitType::
    n () const
    {
      return this->n_.get ();
    }

    TorusBestFitType::n_type& TorusBestFitType::
    n ()
    {
      return this->n_.get ();
    }

    void TorusBestFitType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void TorusBestFitType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // TorusRecompType
    //

    const TorusRecompType::BaseFeaturePointList_type& TorusRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    TorusRecompType::BaseFeaturePointList_type& TorusRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void TorusRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void TorusRecompType::
    BaseFeaturePointList (::std::unique_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (std::move (x));
    }


    // TorusCopyType
    //

    const TorusCopyType::BaseTorus_type& TorusCopyType::
    BaseTorus () const
    {
      return this->BaseTorus_.get ();
    }

    TorusCopyType::BaseTorus_type& TorusCopyType::
    BaseTorus ()
    {
      return this->BaseTorus_.get ();
    }

    void TorusCopyType::
    BaseTorus (const BaseTorus_type& x)
    {
      this->BaseTorus_.set (x);
    }

    void TorusCopyType::
    BaseTorus (::std::unique_ptr< BaseTorus_type > x)
    {
      this->BaseTorus_.set (std::move (x));
    }


    // TorusCastType
    //

    const TorusCastType::BaseFeature_type& TorusCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    TorusCastType::BaseFeature_type& TorusCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void TorusCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void TorusCastType::
    BaseFeature (::std::unique_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (std::move (x));
    }


    // TorusTransformType
    //

    const TorusTransformType::BaseTorus_type& TorusTransformType::
    BaseTorus () const
    {
      return this->BaseTorus_.get ();
    }

    TorusTransformType::BaseTorus_type& TorusTransformType::
    BaseTorus ()
    {
      return this->BaseTorus_.get ();
    }

    void TorusTransformType::
    BaseTorus (const BaseTorus_type& x)
    {
      this->BaseTorus_.set (x);
    }

    void TorusTransformType::
    BaseTorus (::std::unique_ptr< BaseTorus_type > x)
    {
      this->BaseTorus_.set (std::move (x));
    }

    const TorusTransformType::Transformation_type& TorusTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    TorusTransformType::Transformation_type& TorusTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void TorusTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void TorusTransformType::
    Transformation (::std::unique_ptr< Transformation_type > x)
    {
      this->Transformation_.set (std::move (x));
    }


    // TorusFromScanType
    //

    const TorusFromScanType::SurfaceFeature_type& TorusFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    TorusFromScanType::SurfaceFeature_type& TorusFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void TorusFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void TorusFromScanType::
    SurfaceFeature (::std::unique_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (std::move (x));
    }

    const TorusFromScanType::SearchRadius_type& TorusFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    TorusFromScanType::SearchRadius_type& TorusFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void TorusFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void TorusFromScanType::
    SearchRadius (::std::unique_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (std::move (x));
    }


    // TorusCheckedType
    //

    const TorusCheckedType::Measured_optional& TorusCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    TorusCheckedType::Measured_optional& TorusCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void TorusCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void TorusCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void TorusCheckedType::
    Measured (::std::unique_ptr< Measured_type > x)
    {
      this->Measured_.set (std::move (x));
    }

    const TorusCheckedType::Constructed_optional& TorusCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    TorusCheckedType::Constructed_optional& TorusCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void TorusCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void TorusCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void TorusCheckedType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // TorusCheckedFeatureType
    //

    const TorusCheckedFeatureType::CheckDetails_optional& TorusCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    TorusCheckedFeatureType::CheckDetails_optional& TorusCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void TorusCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void TorusCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void TorusCheckedFeatureType::
    CheckDetails (::std::unique_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (std::move (x));
    }


    // TorusMeasurementDeterminationType
    //

    const TorusMeasurementDeterminationType::Checked_optional& TorusMeasurementDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    TorusMeasurementDeterminationType::Checked_optional& TorusMeasurementDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void TorusMeasurementDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void TorusMeasurementDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void TorusMeasurementDeterminationType::
    Checked (::std::unique_ptr< Checked_type > x)
    {
      this->Checked_.set (std::move (x));
    }

    const TorusMeasurementDeterminationType::Set_optional& TorusMeasurementDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    TorusMeasurementDeterminationType::Set_optional& TorusMeasurementDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void TorusMeasurementDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void TorusMeasurementDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void TorusMeasurementDeterminationType::
    Set (::std::unique_ptr< Set_type > x)
    {
      this->Set_.set (std::move (x));
    }


    // TorusFeatureItemType
    //

    const TorusFeatureItemType::DeterminationMode_type& TorusFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    TorusFeatureItemType::DeterminationMode_type& TorusFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void TorusFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void TorusFeatureItemType::
    DeterminationMode (::std::unique_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (std::move (x));
    }


    // TorusFeatureDefinitionType
    //

    const TorusFeatureDefinitionType::InternalExternal_type& TorusFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    TorusFeatureDefinitionType::InternalExternal_type& TorusFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void TorusFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void TorusFeatureDefinitionType::
    InternalExternal (::std::unique_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (std::move (x));
    }

    const TorusFeatureDefinitionType::MinorDiameter_type& TorusFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    TorusFeatureDefinitionType::MinorDiameter_type& TorusFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void TorusFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void TorusFeatureDefinitionType::
    MinorDiameter (::std::unique_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (std::move (x));
    }

    const TorusFeatureDefinitionType::MajorDiameter_type& TorusFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    TorusFeatureDefinitionType::MajorDiameter_type& TorusFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void TorusFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void TorusFeatureDefinitionType::
    MajorDiameter (::std::unique_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (std::move (x));
    }


    // TorusFeatureNominalType
    //

    const TorusFeatureNominalType::Location_type& TorusFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    TorusFeatureNominalType::Location_type& TorusFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void TorusFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void TorusFeatureNominalType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const TorusFeatureNominalType::AxisVector_type& TorusFeatureNominalType::
    AxisVector () const
    {
      return this->AxisVector_.get ();
    }

    TorusFeatureNominalType::AxisVector_type& TorusFeatureNominalType::
    AxisVector ()
    {
      return this->AxisVector_.get ();
    }

    void TorusFeatureNominalType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void TorusFeatureNominalType::
    AxisVector (::std::unique_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (std::move (x));
    }

    const TorusFeatureNominalType::LatitudeLongitudeSweep_optional& TorusFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    TorusFeatureNominalType::LatitudeLongitudeSweep_optional& TorusFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (std::move (x));
    }

    const TorusFeatureNominalType::Constructed_optional& TorusFeatureNominalType::
    Constructed () const
    {
      return this->Constructed_;
    }

    TorusFeatureNominalType::Constructed_optional& TorusFeatureNominalType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void TorusFeatureNominalType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void TorusFeatureNominalType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void TorusFeatureNominalType::
    Constructed (::std::unique_ptr< Constructed_type > x)
    {
      this->Constructed_.set (std::move (x));
    }


    // TorusFeatureMeasurementType
    //

    const TorusFeatureMeasurementType::Location_optional& TorusFeatureMeasurementType::
    Location () const
    {
      return this->Location_;
    }

    TorusFeatureMeasurementType::Location_optional& TorusFeatureMeasurementType::
    Location ()
    {
      return this->Location_;
    }

    void TorusFeatureMeasurementType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void TorusFeatureMeasurementType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void TorusFeatureMeasurementType::
    Location (::std::unique_ptr< Location_type > x)
    {
      this->Location_.set (std::move (x));
    }

    const TorusFeatureMeasurementType::AxisVector_optional& TorusFeatureMeasurementType::
    AxisVector () const
    {
      return this->AxisVector_;
    }

    TorusFeatureMeasurementType::AxisVector_optional& TorusFeatureMeasurementType::
    AxisVector ()
    {
      return this->AxisVector_;
    }

    void TorusFeatureMeasurementType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void TorusFeatureMeasurementType::
    AxisVector (const AxisVector_optional& x)
    {
      this->AxisVector_ = x;
    }

    void TorusFeatureMeasurementType::
    AxisVector (::std::unique_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (std::move (x));
    }

    const TorusFeatureMeasurementType::MinorDiameter_optional& TorusFeatureMeasurementType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    TorusFeatureMeasurementType::MinorDiameter_optional& TorusFeatureMeasurementType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void TorusFeatureMeasurementType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void TorusFeatureMeasurementType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void TorusFeatureMeasurementType::
    MinorDiameter (::std::unique_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (std::move (x));
    }

    const TorusFeatureMeasurementType::MajorDiameter_optional& TorusFeatureMeasurementType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    TorusFeatureMeasurementType::MajorDiameter_optional& TorusFeatureMeasurementType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void TorusFeatureMeasurementType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void TorusFeatureMeasurementType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void TorusFeatureMeasurementType::
    MajorDiameter (::std::unique_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (std::move (x));
    }

    const TorusFeatureMeasurementType::LatitudeLongitudeSweepMeasurementRange_optional& TorusFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange () const
    {
      return this->LatitudeLongitudeSweepMeasurementRange_;
    }

    TorusFeatureMeasurementType::LatitudeLongitudeSweepMeasurementRange_optional& TorusFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange ()
    {
      return this->LatitudeLongitudeSweepMeasurementRange_;
    }

    void TorusFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_type& x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_.set (x);
    }

    void TorusFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (const LatitudeLongitudeSweepMeasurementRange_optional& x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_ = x;
    }

    void TorusFeatureMeasurementType::
    LatitudeLongitudeSweepMeasurementRange (::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > x)
    {
      this->LatitudeLongitudeSweepMeasurementRange_.set (std::move (x));
    }

    const TorusFeatureMeasurementType::LatitudeLongitudeSweepFull_optional& TorusFeatureMeasurementType::
    LatitudeLongitudeSweepFull () const
    {
      return this->LatitudeLongitudeSweepFull_;
    }

    TorusFeatureMeasurementType::LatitudeLongitudeSweepFull_optional& TorusFeatureMeasurementType::
    LatitudeLongitudeSweepFull ()
    {
      return this->LatitudeLongitudeSweepFull_;
    }

    void TorusFeatureMeasurementType::
    LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_type& x)
    {
      this->LatitudeLongitudeSweepFull_.set (x);
    }

    void TorusFeatureMeasurementType::
    LatitudeLongitudeSweepFull (const LatitudeLongitudeSweepFull_optional& x)
    {
      this->LatitudeLongitudeSweepFull_ = x;
    }

    void TorusFeatureMeasurementType::
    LatitudeLongitudeSweepFull (::std::unique_ptr< LatitudeLongitudeSweepFull_type > x)
    {
      this->LatitudeLongitudeSweepFull_.set (std::move (x));
    }

    const TorusFeatureMeasurementType::Form_optional& TorusFeatureMeasurementType::
    Form () const
    {
      return this->Form_;
    }

    TorusFeatureMeasurementType::Form_optional& TorusFeatureMeasurementType::
    Form ()
    {
      return this->Form_;
    }

    void TorusFeatureMeasurementType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void TorusFeatureMeasurementType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void TorusFeatureMeasurementType::
    Form (::std::unique_ptr< Form_type > x)
    {
      this->Form_.set (std::move (x));
    }


    // GroupFeatureItemType
    //


    // GroupFeatureDefinitionType
    //

    const GroupFeatureDefinitionType::IsProfileGroup_optional& GroupFeatureDefinitionType::
    IsProfileGroup () const
    {
      return this->IsProfileGroup_;
    }

    GroupFeatureDefinitionType::IsProfileGroup_optional& GroupFeatureDefinitionType::
    IsProfileGroup ()
    {
      return this->IsProfileGroup_;
    }

    void GroupFeatureDefinitionType::
    IsProfileGroup (const IsProfileGroup_type& x)
    {
      this->IsProfileGroup_.set (x);
    }

    void GroupFeatureDefinitionType::
    IsProfileGroup (const IsProfileGroup_optional& x)
    {
      this->IsProfileGroup_ = x;
    }

    const GroupFeatureDefinitionType::IsRunoutGroup_optional& GroupFeatureDefinitionType::
    IsRunoutGroup () const
    {
      return this->IsRunoutGroup_;
    }

    GroupFeatureDefinitionType::IsRunoutGroup_optional& GroupFeatureDefinitionType::
    IsRunoutGroup ()
    {
      return this->IsRunoutGroup_;
    }

    void GroupFeatureDefinitionType::
    IsRunoutGroup (const IsRunoutGroup_type& x)
    {
      this->IsRunoutGroup_.set (x);
    }

    void GroupFeatureDefinitionType::
    IsRunoutGroup (const IsRunoutGroup_optional& x)
    {
      this->IsRunoutGroup_ = x;
    }

    const GroupFeatureDefinitionType::IsCountersunkHole_optional& GroupFeatureDefinitionType::
    IsCountersunkHole () const
    {
      return this->IsCountersunkHole_;
    }

    GroupFeatureDefinitionType::IsCountersunkHole_optional& GroupFeatureDefinitionType::
    IsCountersunkHole ()
    {
      return this->IsCountersunkHole_;
    }

    void GroupFeatureDefinitionType::
    IsCountersunkHole (const IsCountersunkHole_type& x)
    {
      this->IsCountersunkHole_.set (x);
    }

    void GroupFeatureDefinitionType::
    IsCountersunkHole (const IsCountersunkHole_optional& x)
    {
      this->IsCountersunkHole_ = x;
    }

    const GroupFeatureDefinitionType::IsCounterboredHole_optional& GroupFeatureDefinitionType::
    IsCounterboredHole () const
    {
      return this->IsCounterboredHole_;
    }

    GroupFeatureDefinitionType::IsCounterboredHole_optional& GroupFeatureDefinitionType::
    IsCounterboredHole ()
    {
      return this->IsCounterboredHole_;
    }

    void GroupFeatureDefinitionType::
    IsCounterboredHole (const IsCounterboredHole_type& x)
    {
      this->IsCounterboredHole_.set (x);
    }

    void GroupFeatureDefinitionType::
    IsCounterboredHole (const IsCounterboredHole_optional& x)
    {
      this->IsCounterboredHole_ = x;
    }

    const GroupFeatureDefinitionType::IsSpotface_optional& GroupFeatureDefinitionType::
    IsSpotface () const
    {
      return this->IsSpotface_;
    }

    GroupFeatureDefinitionType::IsSpotface_optional& GroupFeatureDefinitionType::
    IsSpotface ()
    {
      return this->IsSpotface_;
    }

    void GroupFeatureDefinitionType::
    IsSpotface (const IsSpotface_type& x)
    {
      this->IsSpotface_.set (x);
    }

    void GroupFeatureDefinitionType::
    IsSpotface (const IsSpotface_optional& x)
    {
      this->IsSpotface_ = x;
    }


    // GroupFeatureNominalType
    //

    const GroupFeatureNominalType::FeatureNominalIds_type& GroupFeatureNominalType::
    FeatureNominalIds () const
    {
      return this->FeatureNominalIds_.get ();
    }

    GroupFeatureNominalType::FeatureNominalIds_type& GroupFeatureNominalType::
    FeatureNominalIds ()
    {
      return this->FeatureNominalIds_.get ();
    }

    void GroupFeatureNominalType::
    FeatureNominalIds (const FeatureNominalIds_type& x)
    {
      this->FeatureNominalIds_.set (x);
    }

    void GroupFeatureNominalType::
    FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > x)
    {
      this->FeatureNominalIds_.set (std::move (x));
    }


    // GroupFeatureMeasurementType
    //


    // PatternFeatureItemBaseType
    //


    // PatternFeatureDefinitionBaseType
    //


    // PatternFeatureNominalBaseType
    //


    // PatternFeatureLinearItemType
    //


    // PatternFeatureLinearDefinitionType
    //

    const PatternFeatureLinearDefinitionType::LineDirection_type& PatternFeatureLinearDefinitionType::
    LineDirection () const
    {
      return this->LineDirection_.get ();
    }

    PatternFeatureLinearDefinitionType::LineDirection_type& PatternFeatureLinearDefinitionType::
    LineDirection ()
    {
      return this->LineDirection_.get ();
    }

    void PatternFeatureLinearDefinitionType::
    LineDirection (const LineDirection_type& x)
    {
      this->LineDirection_.set (x);
    }

    void PatternFeatureLinearDefinitionType::
    LineDirection (::std::unique_ptr< LineDirection_type > x)
    {
      this->LineDirection_.set (std::move (x));
    }

    const PatternFeatureLinearDefinitionType::IncrementalDistance_type& PatternFeatureLinearDefinitionType::
    IncrementalDistance () const
    {
      return this->IncrementalDistance_.get ();
    }

    PatternFeatureLinearDefinitionType::IncrementalDistance_type& PatternFeatureLinearDefinitionType::
    IncrementalDistance ()
    {
      return this->IncrementalDistance_.get ();
    }

    void PatternFeatureLinearDefinitionType::
    IncrementalDistance (const IncrementalDistance_type& x)
    {
      this->IncrementalDistance_.set (x);
    }

    void PatternFeatureLinearDefinitionType::
    IncrementalDistance (::std::unique_ptr< IncrementalDistance_type > x)
    {
      this->IncrementalDistance_.set (std::move (x));
    }

    const PatternFeatureLinearDefinitionType::FeatureDirection_optional& PatternFeatureLinearDefinitionType::
    FeatureDirection () const
    {
      return this->FeatureDirection_;
    }

    PatternFeatureLinearDefinitionType::FeatureDirection_optional& PatternFeatureLinearDefinitionType::
    FeatureDirection ()
    {
      return this->FeatureDirection_;
    }

    void PatternFeatureLinearDefinitionType::
    FeatureDirection (const FeatureDirection_type& x)
    {
      this->FeatureDirection_.set (x);
    }

    void PatternFeatureLinearDefinitionType::
    FeatureDirection (const FeatureDirection_optional& x)
    {
      this->FeatureDirection_ = x;
    }

    void PatternFeatureLinearDefinitionType::
    FeatureDirection (::std::unique_ptr< FeatureDirection_type > x)
    {
      this->FeatureDirection_.set (std::move (x));
    }

    const PatternFeatureLinearDefinitionType::NumberOfFeatures_type& PatternFeatureLinearDefinitionType::
    NumberOfFeatures () const
    {
      return this->NumberOfFeatures_.get ();
    }

    PatternFeatureLinearDefinitionType::NumberOfFeatures_type& PatternFeatureLinearDefinitionType::
    NumberOfFeatures ()
    {
      return this->NumberOfFeatures_.get ();
    }

    void PatternFeatureLinearDefinitionType::
    NumberOfFeatures (const NumberOfFeatures_type& x)
    {
      this->NumberOfFeatures_.set (x);
    }

    void PatternFeatureLinearDefinitionType::
    NumberOfFeatures (::std::unique_ptr< NumberOfFeatures_type > x)
    {
      this->NumberOfFeatures_.set (std::move (x));
    }


    // PatternFeatureLinearNominalType
    //

    const PatternFeatureLinearNominalType::FirstFeatureLocation_type& PatternFeatureLinearNominalType::
    FirstFeatureLocation () const
    {
      return this->FirstFeatureLocation_.get ();
    }

    PatternFeatureLinearNominalType::FirstFeatureLocation_type& PatternFeatureLinearNominalType::
    FirstFeatureLocation ()
    {
      return this->FirstFeatureLocation_.get ();
    }

    void PatternFeatureLinearNominalType::
    FirstFeatureLocation (const FirstFeatureLocation_type& x)
    {
      this->FirstFeatureLocation_.set (x);
    }

    void PatternFeatureLinearNominalType::
    FirstFeatureLocation (::std::unique_ptr< FirstFeatureLocation_type > x)
    {
      this->FirstFeatureLocation_.set (std::move (x));
    }


    // PatternFeatureParallelogramItemType
    //


    // PatternFeatureParallelogramDefinitionType
    //

    const PatternFeatureParallelogramDefinitionType::AlongRowDirection_type& PatternFeatureParallelogramDefinitionType::
    AlongRowDirection () const
    {
      return this->AlongRowDirection_.get ();
    }

    PatternFeatureParallelogramDefinitionType::AlongRowDirection_type& PatternFeatureParallelogramDefinitionType::
    AlongRowDirection ()
    {
      return this->AlongRowDirection_.get ();
    }

    void PatternFeatureParallelogramDefinitionType::
    AlongRowDirection (const AlongRowDirection_type& x)
    {
      this->AlongRowDirection_.set (x);
    }

    void PatternFeatureParallelogramDefinitionType::
    AlongRowDirection (::std::unique_ptr< AlongRowDirection_type > x)
    {
      this->AlongRowDirection_.set (std::move (x));
    }

    const PatternFeatureParallelogramDefinitionType::IncrementalRowDistance_type& PatternFeatureParallelogramDefinitionType::
    IncrementalRowDistance () const
    {
      return this->IncrementalRowDistance_.get ();
    }

    PatternFeatureParallelogramDefinitionType::IncrementalRowDistance_type& PatternFeatureParallelogramDefinitionType::
    IncrementalRowDistance ()
    {
      return this->IncrementalRowDistance_.get ();
    }

    void PatternFeatureParallelogramDefinitionType::
    IncrementalRowDistance (const IncrementalRowDistance_type& x)
    {
      this->IncrementalRowDistance_.set (x);
    }

    void PatternFeatureParallelogramDefinitionType::
    IncrementalRowDistance (::std::unique_ptr< IncrementalRowDistance_type > x)
    {
      this->IncrementalRowDistance_.set (std::move (x));
    }

    const PatternFeatureParallelogramDefinitionType::BetweenRowDirection_type& PatternFeatureParallelogramDefinitionType::
    BetweenRowDirection () const
    {
      return this->BetweenRowDirection_.get ();
    }

    PatternFeatureParallelogramDefinitionType::BetweenRowDirection_type& PatternFeatureParallelogramDefinitionType::
    BetweenRowDirection ()
    {
      return this->BetweenRowDirection_.get ();
    }

    void PatternFeatureParallelogramDefinitionType::
    BetweenRowDirection (const BetweenRowDirection_type& x)
    {
      this->BetweenRowDirection_.set (x);
    }

    void PatternFeatureParallelogramDefinitionType::
    BetweenRowDirection (::std::unique_ptr< BetweenRowDirection_type > x)
    {
      this->BetweenRowDirection_.set (std::move (x));
    }

    const PatternFeatureParallelogramDefinitionType::RowSeparationDistance_type& PatternFeatureParallelogramDefinitionType::
    RowSeparationDistance () const
    {
      return this->RowSeparationDistance_.get ();
    }

    PatternFeatureParallelogramDefinitionType::RowSeparationDistance_type& PatternFeatureParallelogramDefinitionType::
    RowSeparationDistance ()
    {
      return this->RowSeparationDistance_.get ();
    }

    void PatternFeatureParallelogramDefinitionType::
    RowSeparationDistance (const RowSeparationDistance_type& x)
    {
      this->RowSeparationDistance_.set (x);
    }

    void PatternFeatureParallelogramDefinitionType::
    RowSeparationDistance (::std::unique_ptr< RowSeparationDistance_type > x)
    {
      this->RowSeparationDistance_.set (std::move (x));
    }

    const PatternFeatureParallelogramDefinitionType::FeatureDirection_optional& PatternFeatureParallelogramDefinitionType::
    FeatureDirection () const
    {
      return this->FeatureDirection_;
    }

    PatternFeatureParallelogramDefinitionType::FeatureDirection_optional& PatternFeatureParallelogramDefinitionType::
    FeatureDirection ()
    {
      return this->FeatureDirection_;
    }

    void PatternFeatureParallelogramDefinitionType::
    FeatureDirection (const FeatureDirection_type& x)
    {
      this->FeatureDirection_.set (x);
    }

    void PatternFeatureParallelogramDefinitionType::
    FeatureDirection (const FeatureDirection_optional& x)
    {
      this->FeatureDirection_ = x;
    }

    void PatternFeatureParallelogramDefinitionType::
    FeatureDirection (::std::unique_ptr< FeatureDirection_type > x)
    {
      this->FeatureDirection_.set (std::move (x));
    }

    const PatternFeatureParallelogramDefinitionType::NumberOfFeaturesPerRow_type& PatternFeatureParallelogramDefinitionType::
    NumberOfFeaturesPerRow () const
    {
      return this->NumberOfFeaturesPerRow_.get ();
    }

    PatternFeatureParallelogramDefinitionType::NumberOfFeaturesPerRow_type& PatternFeatureParallelogramDefinitionType::
    NumberOfFeaturesPerRow ()
    {
      return this->NumberOfFeaturesPerRow_.get ();
    }

    void PatternFeatureParallelogramDefinitionType::
    NumberOfFeaturesPerRow (const NumberOfFeaturesPerRow_type& x)
    {
      this->NumberOfFeaturesPerRow_.set (x);
    }

    void PatternFeatureParallelogramDefinitionType::
    NumberOfFeaturesPerRow (::std::unique_ptr< NumberOfFeaturesPerRow_type > x)
    {
      this->NumberOfFeaturesPerRow_.set (std::move (x));
    }

    const PatternFeatureParallelogramDefinitionType::NumberOfRows_type& PatternFeatureParallelogramDefinitionType::
    NumberOfRows () const
    {
      return this->NumberOfRows_.get ();
    }

    PatternFeatureParallelogramDefinitionType::NumberOfRows_type& PatternFeatureParallelogramDefinitionType::
    NumberOfRows ()
    {
      return this->NumberOfRows_.get ();
    }

    void PatternFeatureParallelogramDefinitionType::
    NumberOfRows (const NumberOfRows_type& x)
    {
      this->NumberOfRows_.set (x);
    }

    void PatternFeatureParallelogramDefinitionType::
    NumberOfRows (::std::unique_ptr< NumberOfRows_type > x)
    {
      this->NumberOfRows_.set (std::move (x));
    }


    // PatternFeatureParallelogramNominalType
    //

    const PatternFeatureParallelogramNominalType::FirstFeatureLocation_type& PatternFeatureParallelogramNominalType::
    FirstFeatureLocation () const
    {
      return this->FirstFeatureLocation_.get ();
    }

    PatternFeatureParallelogramNominalType::FirstFeatureLocation_type& PatternFeatureParallelogramNominalType::
    FirstFeatureLocation ()
    {
      return this->FirstFeatureLocation_.get ();
    }

    void PatternFeatureParallelogramNominalType::
    FirstFeatureLocation (const FirstFeatureLocation_type& x)
    {
      this->FirstFeatureLocation_.set (x);
    }

    void PatternFeatureParallelogramNominalType::
    FirstFeatureLocation (::std::unique_ptr< FirstFeatureLocation_type > x)
    {
      this->FirstFeatureLocation_.set (std::move (x));
    }


    // PatternFeatureCircularArcItemType
    //


    // PatternFeatureCircularArcDefinitionType
    //

    const PatternFeatureCircularArcDefinitionType::ArcRadius_type& PatternFeatureCircularArcDefinitionType::
    ArcRadius () const
    {
      return this->ArcRadius_.get ();
    }

    PatternFeatureCircularArcDefinitionType::ArcRadius_type& PatternFeatureCircularArcDefinitionType::
    ArcRadius ()
    {
      return this->ArcRadius_.get ();
    }

    void PatternFeatureCircularArcDefinitionType::
    ArcRadius (const ArcRadius_type& x)
    {
      this->ArcRadius_.set (x);
    }

    void PatternFeatureCircularArcDefinitionType::
    ArcRadius (::std::unique_ptr< ArcRadius_type > x)
    {
      this->ArcRadius_.set (std::move (x));
    }

    const PatternFeatureCircularArcDefinitionType::IncrementalArc_type& PatternFeatureCircularArcDefinitionType::
    IncrementalArc () const
    {
      return this->IncrementalArc_.get ();
    }

    PatternFeatureCircularArcDefinitionType::IncrementalArc_type& PatternFeatureCircularArcDefinitionType::
    IncrementalArc ()
    {
      return this->IncrementalArc_.get ();
    }

    void PatternFeatureCircularArcDefinitionType::
    IncrementalArc (const IncrementalArc_type& x)
    {
      this->IncrementalArc_.set (x);
    }

    void PatternFeatureCircularArcDefinitionType::
    IncrementalArc (::std::unique_ptr< IncrementalArc_type > x)
    {
      this->IncrementalArc_.set (std::move (x));
    }

    const PatternFeatureCircularArcDefinitionType::FeatureDirection_optional& PatternFeatureCircularArcDefinitionType::
    FeatureDirection () const
    {
      return this->FeatureDirection_;
    }

    PatternFeatureCircularArcDefinitionType::FeatureDirection_optional& PatternFeatureCircularArcDefinitionType::
    FeatureDirection ()
    {
      return this->FeatureDirection_;
    }

    void PatternFeatureCircularArcDefinitionType::
    FeatureDirection (const FeatureDirection_type& x)
    {
      this->FeatureDirection_.set (x);
    }

    void PatternFeatureCircularArcDefinitionType::
    FeatureDirection (const FeatureDirection_optional& x)
    {
      this->FeatureDirection_ = x;
    }

    void PatternFeatureCircularArcDefinitionType::
    FeatureDirection (::std::unique_ptr< FeatureDirection_type > x)
    {
      this->FeatureDirection_.set (std::move (x));
    }

    const PatternFeatureCircularArcDefinitionType::NumberOfFeatures_type& PatternFeatureCircularArcDefinitionType::
    NumberOfFeatures () const
    {
      return this->NumberOfFeatures_.get ();
    }

    PatternFeatureCircularArcDefinitionType::NumberOfFeatures_type& PatternFeatureCircularArcDefinitionType::
    NumberOfFeatures ()
    {
      return this->NumberOfFeatures_.get ();
    }

    void PatternFeatureCircularArcDefinitionType::
    NumberOfFeatures (const NumberOfFeatures_type& x)
    {
      this->NumberOfFeatures_.set (x);
    }

    void PatternFeatureCircularArcDefinitionType::
    NumberOfFeatures (::std::unique_ptr< NumberOfFeatures_type > x)
    {
      this->NumberOfFeatures_.set (std::move (x));
    }


    // PatternFeatureCircularArcNominalType
    //

    const PatternFeatureCircularArcNominalType::Normal_type& PatternFeatureCircularArcNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    PatternFeatureCircularArcNominalType::Normal_type& PatternFeatureCircularArcNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void PatternFeatureCircularArcNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PatternFeatureCircularArcNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const PatternFeatureCircularArcNominalType::Center_type& PatternFeatureCircularArcNominalType::
    Center () const
    {
      return this->Center_.get ();
    }

    PatternFeatureCircularArcNominalType::Center_type& PatternFeatureCircularArcNominalType::
    Center ()
    {
      return this->Center_.get ();
    }

    void PatternFeatureCircularArcNominalType::
    Center (const Center_type& x)
    {
      this->Center_.set (x);
    }

    void PatternFeatureCircularArcNominalType::
    Center (::std::unique_ptr< Center_type > x)
    {
      this->Center_.set (std::move (x));
    }

    const PatternFeatureCircularArcNominalType::FirstFeatureLocation_type& PatternFeatureCircularArcNominalType::
    FirstFeatureLocation () const
    {
      return this->FirstFeatureLocation_.get ();
    }

    PatternFeatureCircularArcNominalType::FirstFeatureLocation_type& PatternFeatureCircularArcNominalType::
    FirstFeatureLocation ()
    {
      return this->FirstFeatureLocation_.get ();
    }

    void PatternFeatureCircularArcNominalType::
    FirstFeatureLocation (const FirstFeatureLocation_type& x)
    {
      this->FirstFeatureLocation_.set (x);
    }

    void PatternFeatureCircularArcNominalType::
    FirstFeatureLocation (::std::unique_ptr< FirstFeatureLocation_type > x)
    {
      this->FirstFeatureLocation_.set (std::move (x));
    }


    // PatternFeatureCircleItemType
    //


    // PatternFeatureCircleDefinitionType
    //

    const PatternFeatureCircleDefinitionType::Diameter_type& PatternFeatureCircleDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    PatternFeatureCircleDefinitionType::Diameter_type& PatternFeatureCircleDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void PatternFeatureCircleDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void PatternFeatureCircleDefinitionType::
    Diameter (::std::unique_ptr< Diameter_type > x)
    {
      this->Diameter_.set (std::move (x));
    }

    const PatternFeatureCircleDefinitionType::FeatureDirection_optional& PatternFeatureCircleDefinitionType::
    FeatureDirection () const
    {
      return this->FeatureDirection_;
    }

    PatternFeatureCircleDefinitionType::FeatureDirection_optional& PatternFeatureCircleDefinitionType::
    FeatureDirection ()
    {
      return this->FeatureDirection_;
    }

    void PatternFeatureCircleDefinitionType::
    FeatureDirection (const FeatureDirection_type& x)
    {
      this->FeatureDirection_.set (x);
    }

    void PatternFeatureCircleDefinitionType::
    FeatureDirection (const FeatureDirection_optional& x)
    {
      this->FeatureDirection_ = x;
    }

    void PatternFeatureCircleDefinitionType::
    FeatureDirection (::std::unique_ptr< FeatureDirection_type > x)
    {
      this->FeatureDirection_.set (std::move (x));
    }

    const PatternFeatureCircleDefinitionType::NumberOfFeatures_type& PatternFeatureCircleDefinitionType::
    NumberOfFeatures () const
    {
      return this->NumberOfFeatures_.get ();
    }

    PatternFeatureCircleDefinitionType::NumberOfFeatures_type& PatternFeatureCircleDefinitionType::
    NumberOfFeatures ()
    {
      return this->NumberOfFeatures_.get ();
    }

    void PatternFeatureCircleDefinitionType::
    NumberOfFeatures (const NumberOfFeatures_type& x)
    {
      this->NumberOfFeatures_.set (x);
    }

    void PatternFeatureCircleDefinitionType::
    NumberOfFeatures (::std::unique_ptr< NumberOfFeatures_type > x)
    {
      this->NumberOfFeatures_.set (std::move (x));
    }


    // PatternFeatureCircleNominalType
    //

    const PatternFeatureCircleNominalType::Normal_type& PatternFeatureCircleNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    PatternFeatureCircleNominalType::Normal_type& PatternFeatureCircleNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void PatternFeatureCircleNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PatternFeatureCircleNominalType::
    Normal (::std::unique_ptr< Normal_type > x)
    {
      this->Normal_.set (std::move (x));
    }

    const PatternFeatureCircleNominalType::Center_type& PatternFeatureCircleNominalType::
    Center () const
    {
      return this->Center_.get ();
    }

    PatternFeatureCircleNominalType::Center_type& PatternFeatureCircleNominalType::
    Center ()
    {
      return this->Center_.get ();
    }

    void PatternFeatureCircleNominalType::
    Center (const Center_type& x)
    {
      this->Center_.set (x);
    }

    void PatternFeatureCircleNominalType::
    Center (::std::unique_ptr< Center_type > x)
    {
      this->Center_.set (std::move (x));
    }

    const PatternFeatureCircleNominalType::FirstFeatureLocation_type& PatternFeatureCircleNominalType::
    FirstFeatureLocation () const
    {
      return this->FirstFeatureLocation_.get ();
    }

    PatternFeatureCircleNominalType::FirstFeatureLocation_type& PatternFeatureCircleNominalType::
    FirstFeatureLocation ()
    {
      return this->FirstFeatureLocation_.get ();
    }

    void PatternFeatureCircleNominalType::
    FirstFeatureLocation (const FirstFeatureLocation_type& x)
    {
      this->FirstFeatureLocation_.set (x);
    }

    void PatternFeatureCircleNominalType::
    FirstFeatureLocation (::std::unique_ptr< FirstFeatureLocation_type > x)
    {
      this->FirstFeatureLocation_.set (std::move (x));
    }


    // FeatureZoneBaseType
    //

    const FeatureZoneBaseType::Attributes_optional& FeatureZoneBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    FeatureZoneBaseType::Attributes_optional& FeatureZoneBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void FeatureZoneBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void FeatureZoneBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void FeatureZoneBaseType::
    Attributes (::std::unique_ptr< Attributes_type > x)
    {
      this->Attributes_.set (std::move (x));
    }

    const FeatureZoneBaseType::Label_optional& FeatureZoneBaseType::
    Label () const
    {
      return this->Label_;
    }

    FeatureZoneBaseType::Label_optional& FeatureZoneBaseType::
    Label ()
    {
      return this->Label_;
    }

    void FeatureZoneBaseType::
    Label (const Label_type& x)
    {
      this->Label_.set (x);
    }

    void FeatureZoneBaseType::
    Label (const Label_optional& x)
    {
      this->Label_ = x;
    }

    void FeatureZoneBaseType::
    Label (::std::unique_ptr< Label_type > x)
    {
      this->Label_.set (std::move (x));
    }

    const FeatureZoneBaseType::SurfaceFeatureNominalId_optional& FeatureZoneBaseType::
    SurfaceFeatureNominalId () const
    {
      return this->SurfaceFeatureNominalId_;
    }

    FeatureZoneBaseType::SurfaceFeatureNominalId_optional& FeatureZoneBaseType::
    SurfaceFeatureNominalId ()
    {
      return this->SurfaceFeatureNominalId_;
    }

    void FeatureZoneBaseType::
    SurfaceFeatureNominalId (const SurfaceFeatureNominalId_type& x)
    {
      this->SurfaceFeatureNominalId_.set (x);
    }

    void FeatureZoneBaseType::
    SurfaceFeatureNominalId (const SurfaceFeatureNominalId_optional& x)
    {
      this->SurfaceFeatureNominalId_ = x;
    }

    void FeatureZoneBaseType::
    SurfaceFeatureNominalId (::std::unique_ptr< SurfaceFeatureNominalId_type > x)
    {
      this->SurfaceFeatureNominalId_.set (std::move (x));
    }

    const FeatureZoneBaseType::id_type& FeatureZoneBaseType::
    id () const
    {
      return this->id_.get ();
    }

    FeatureZoneBaseType::id_type& FeatureZoneBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureZoneBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void FeatureZoneBaseType::
    id (::std::unique_ptr< id_type > x)
    {
      this->id_.set (std::move (x));
    }


    // FeatureZonePointType
    //

    const FeatureZonePointType::VertexId_optional& FeatureZonePointType::
    VertexId () const
    {
      return this->VertexId_;
    }

    FeatureZonePointType::VertexId_optional& FeatureZonePointType::
    VertexId ()
    {
      return this->VertexId_;
    }

    void FeatureZonePointType::
    VertexId (const VertexId_type& x)
    {
      this->VertexId_.set (x);
    }

    void FeatureZonePointType::
    VertexId (const VertexId_optional& x)
    {
      this->VertexId_ = x;
    }

    void FeatureZonePointType::
    VertexId (::std::unique_ptr< VertexId_type > x)
    {
      this->VertexId_.set (std::move (x));
    }

    const FeatureZonePointType::PointId_optional& FeatureZonePointType::
    PointId () const
    {
      return this->PointId_;
    }

    FeatureZonePointType::PointId_optional& FeatureZonePointType::
    PointId ()
    {
      return this->PointId_;
    }

    void FeatureZonePointType::
    PointId (const PointId_type& x)
    {
      this->PointId_.set (x);
    }

    void FeatureZonePointType::
    PointId (const PointId_optional& x)
    {
      this->PointId_ = x;
    }

    void FeatureZonePointType::
    PointId (::std::unique_ptr< PointId_type > x)
    {
      this->PointId_.set (std::move (x));
    }

    const FeatureZonePointType::Point_type& FeatureZonePointType::
    Point () const
    {
      return this->Point_.get ();
    }

    FeatureZonePointType::Point_type& FeatureZonePointType::
    Point ()
    {
      return this->Point_.get ();
    }

    void FeatureZonePointType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void FeatureZonePointType::
    Point (::std::unique_ptr< Point_type > x)
    {
      this->Point_.set (std::move (x));
    }


    // FeatureZoneCurveBaseType
    //

    const FeatureZoneCurveBaseType::EdgeIds_optional& FeatureZoneCurveBaseType::
    EdgeIds () const
    {
      return this->EdgeIds_;
    }

    FeatureZoneCurveBaseType::EdgeIds_optional& FeatureZoneCurveBaseType::
    EdgeIds ()
    {
      return this->EdgeIds_;
    }

    void FeatureZoneCurveBaseType::
    EdgeIds (const EdgeIds_type& x)
    {
      this->EdgeIds_.set (x);
    }

    void FeatureZoneCurveBaseType::
    EdgeIds (const EdgeIds_optional& x)
    {
      this->EdgeIds_ = x;
    }

    void FeatureZoneCurveBaseType::
    EdgeIds (::std::unique_ptr< EdgeIds_type > x)
    {
      this->EdgeIds_.set (std::move (x));
    }

    const FeatureZoneCurveBaseType::CurveIds_optional& FeatureZoneCurveBaseType::
    CurveIds () const
    {
      return this->CurveIds_;
    }

    FeatureZoneCurveBaseType::CurveIds_optional& FeatureZoneCurveBaseType::
    CurveIds ()
    {
      return this->CurveIds_;
    }

    void FeatureZoneCurveBaseType::
    CurveIds (const CurveIds_type& x)
    {
      this->CurveIds_.set (x);
    }

    void FeatureZoneCurveBaseType::
    CurveIds (const CurveIds_optional& x)
    {
      this->CurveIds_ = x;
    }

    void FeatureZoneCurveBaseType::
    CurveIds (::std::unique_ptr< CurveIds_type > x)
    {
      this->CurveIds_.set (std::move (x));
    }


    // FeatureZoneCurveLineType
    //

    const FeatureZoneCurveLineType::Line_type& FeatureZoneCurveLineType::
    Line () const
    {
      return this->Line_.get ();
    }

    FeatureZoneCurveLineType::Line_type& FeatureZoneCurveLineType::
    Line ()
    {
      return this->Line_.get ();
    }

    void FeatureZoneCurveLineType::
    Line (const Line_type& x)
    {
      this->Line_.set (x);
    }

    void FeatureZoneCurveLineType::
    Line (::std::unique_ptr< Line_type > x)
    {
      this->Line_.set (std::move (x));
    }


    // FeatureZoneCurveCircularType
    //

    const FeatureZoneCurveCircularType::Circle_type& FeatureZoneCurveCircularType::
    Circle () const
    {
      return this->Circle_.get ();
    }

    FeatureZoneCurveCircularType::Circle_type& FeatureZoneCurveCircularType::
    Circle ()
    {
      return this->Circle_.get ();
    }

    void FeatureZoneCurveCircularType::
    Circle (const Circle_type& x)
    {
      this->Circle_.set (x);
    }

    void FeatureZoneCurveCircularType::
    Circle (::std::unique_ptr< Circle_type > x)
    {
      this->Circle_.set (std::move (x));
    }


    // FeatureZoneCurveIrregularType
    //

    const FeatureZoneCurveIrregularType::CurvePoints_type& FeatureZoneCurveIrregularType::
    CurvePoints () const
    {
      return this->CurvePoints_.get ();
    }

    FeatureZoneCurveIrregularType::CurvePoints_type& FeatureZoneCurveIrregularType::
    CurvePoints ()
    {
      return this->CurvePoints_.get ();
    }

    void FeatureZoneCurveIrregularType::
    CurvePoints (const CurvePoints_type& x)
    {
      this->CurvePoints_.set (x);
    }

    void FeatureZoneCurveIrregularType::
    CurvePoints (::std::unique_ptr< CurvePoints_type > x)
    {
      this->CurvePoints_.set (std::move (x));
    }


    // FeatureZoneAreaBaseType
    //

    const FeatureZoneAreaBaseType::FaceIds_optional& FeatureZoneAreaBaseType::
    FaceIds () const
    {
      return this->FaceIds_;
    }

    FeatureZoneAreaBaseType::FaceIds_optional& FeatureZoneAreaBaseType::
    FaceIds ()
    {
      return this->FaceIds_;
    }

    void FeatureZoneAreaBaseType::
    FaceIds (const FaceIds_type& x)
    {
      this->FaceIds_.set (x);
    }

    void FeatureZoneAreaBaseType::
    FaceIds (const FaceIds_optional& x)
    {
      this->FaceIds_ = x;
    }

    void FeatureZoneAreaBaseType::
    FaceIds (::std::unique_ptr< FaceIds_type > x)
    {
      this->FaceIds_.set (std::move (x));
    }

    const FeatureZoneAreaBaseType::EdgeIds_optional& FeatureZoneAreaBaseType::
    EdgeIds () const
    {
      return this->EdgeIds_;
    }

    FeatureZoneAreaBaseType::EdgeIds_optional& FeatureZoneAreaBaseType::
    EdgeIds ()
    {
      return this->EdgeIds_;
    }

    void FeatureZoneAreaBaseType::
    EdgeIds (const EdgeIds_type& x)
    {
      this->EdgeIds_.set (x);
    }

    void FeatureZoneAreaBaseType::
    EdgeIds (const EdgeIds_optional& x)
    {
      this->EdgeIds_ = x;
    }

    void FeatureZoneAreaBaseType::
    EdgeIds (::std::unique_ptr< EdgeIds_type > x)
    {
      this->EdgeIds_.set (std::move (x));
    }


    // FeatureZoneAreaCircularType
    //

    const FeatureZoneAreaCircularType::Circle_type& FeatureZoneAreaCircularType::
    Circle () const
    {
      return this->Circle_.get ();
    }

    FeatureZoneAreaCircularType::Circle_type& FeatureZoneAreaCircularType::
    Circle ()
    {
      return this->Circle_.get ();
    }

    void FeatureZoneAreaCircularType::
    Circle (const Circle_type& x)
    {
      this->Circle_.set (x);
    }

    void FeatureZoneAreaCircularType::
    Circle (::std::unique_ptr< Circle_type > x)
    {
      this->Circle_.set (std::move (x));
    }


    // FeatureZoneAreaRectangularType
    //

    const FeatureZoneAreaRectangularType::Rectangle_type& FeatureZoneAreaRectangularType::
    Rectangle () const
    {
      return this->Rectangle_.get ();
    }

    FeatureZoneAreaRectangularType::Rectangle_type& FeatureZoneAreaRectangularType::
    Rectangle ()
    {
      return this->Rectangle_.get ();
    }

    void FeatureZoneAreaRectangularType::
    Rectangle (const Rectangle_type& x)
    {
      this->Rectangle_.set (x);
    }

    void FeatureZoneAreaRectangularType::
    Rectangle (::std::unique_ptr< Rectangle_type > x)
    {
      this->Rectangle_.set (std::move (x));
    }


    // FeatureZoneAreaIrregularType
    //


    // FeatureZoneAreaCylindricalType
    //

    const FeatureZoneAreaCylindricalType::Cylinder_type& FeatureZoneAreaCylindricalType::
    Cylinder () const
    {
      return this->Cylinder_.get ();
    }

    FeatureZoneAreaCylindricalType::Cylinder_type& FeatureZoneAreaCylindricalType::
    Cylinder ()
    {
      return this->Cylinder_.get ();
    }

    void FeatureZoneAreaCylindricalType::
    Cylinder (const Cylinder_type& x)
    {
      this->Cylinder_.set (x);
    }

    void FeatureZoneAreaCylindricalType::
    Cylinder (::std::unique_ptr< Cylinder_type > x)
    {
      this->Cylinder_.set (std::move (x));
    }


    // FeatureZoneAreaBetweenType
    //

    const FeatureZoneAreaBetweenType::FromPointZoneId_optional& FeatureZoneAreaBetweenType::
    FromPointZoneId () const
    {
      return this->FromPointZoneId_;
    }

    FeatureZoneAreaBetweenType::FromPointZoneId_optional& FeatureZoneAreaBetweenType::
    FromPointZoneId ()
    {
      return this->FromPointZoneId_;
    }

    void FeatureZoneAreaBetweenType::
    FromPointZoneId (const FromPointZoneId_type& x)
    {
      this->FromPointZoneId_.set (x);
    }

    void FeatureZoneAreaBetweenType::
    FromPointZoneId (const FromPointZoneId_optional& x)
    {
      this->FromPointZoneId_ = x;
    }

    void FeatureZoneAreaBetweenType::
    FromPointZoneId (::std::unique_ptr< FromPointZoneId_type > x)
    {
      this->FromPointZoneId_.set (std::move (x));
    }

    const FeatureZoneAreaBetweenType::FromCurveZoneId_optional& FeatureZoneAreaBetweenType::
    FromCurveZoneId () const
    {
      return this->FromCurveZoneId_;
    }

    FeatureZoneAreaBetweenType::FromCurveZoneId_optional& FeatureZoneAreaBetweenType::
    FromCurveZoneId ()
    {
      return this->FromCurveZoneId_;
    }

    void FeatureZoneAreaBetweenType::
    FromCurveZoneId (const FromCurveZoneId_type& x)
    {
      this->FromCurveZoneId_.set (x);
    }

    void FeatureZoneAreaBetweenType::
    FromCurveZoneId (const FromCurveZoneId_optional& x)
    {
      this->FromCurveZoneId_ = x;
    }

    void FeatureZoneAreaBetweenType::
    FromCurveZoneId (::std::unique_ptr< FromCurveZoneId_type > x)
    {
      this->FromCurveZoneId_.set (std::move (x));
    }

    const FeatureZoneAreaBetweenType::ToPointZoneId_optional& FeatureZoneAreaBetweenType::
    ToPointZoneId () const
    {
      return this->ToPointZoneId_;
    }

    FeatureZoneAreaBetweenType::ToPointZoneId_optional& FeatureZoneAreaBetweenType::
    ToPointZoneId ()
    {
      return this->ToPointZoneId_;
    }

    void FeatureZoneAreaBetweenType::
    ToPointZoneId (const ToPointZoneId_type& x)
    {
      this->ToPointZoneId_.set (x);
    }

    void FeatureZoneAreaBetweenType::
    ToPointZoneId (const ToPointZoneId_optional& x)
    {
      this->ToPointZoneId_ = x;
    }

    void FeatureZoneAreaBetweenType::
    ToPointZoneId (::std::unique_ptr< ToPointZoneId_type > x)
    {
      this->ToPointZoneId_.set (std::move (x));
    }

    const FeatureZoneAreaBetweenType::ToCurveZoneId_optional& FeatureZoneAreaBetweenType::
    ToCurveZoneId () const
    {
      return this->ToCurveZoneId_;
    }

    FeatureZoneAreaBetweenType::ToCurveZoneId_optional& FeatureZoneAreaBetweenType::
    ToCurveZoneId ()
    {
      return this->ToCurveZoneId_;
    }

    void FeatureZoneAreaBetweenType::
    ToCurveZoneId (const ToCurveZoneId_type& x)
    {
      this->ToCurveZoneId_.set (x);
    }

    void FeatureZoneAreaBetweenType::
    ToCurveZoneId (const ToCurveZoneId_optional& x)
    {
      this->ToCurveZoneId_ = x;
    }

    void FeatureZoneAreaBetweenType::
    ToCurveZoneId (::std::unique_ptr< ToCurveZoneId_type > x)
    {
      this->ToCurveZoneId_.set (std::move (x));
    }

    const FeatureZoneAreaBetweenType::StartDirection_optional& FeatureZoneAreaBetweenType::
    StartDirection () const
    {
      return this->StartDirection_;
    }

    FeatureZoneAreaBetweenType::StartDirection_optional& FeatureZoneAreaBetweenType::
    StartDirection ()
    {
      return this->StartDirection_;
    }

    void FeatureZoneAreaBetweenType::
    StartDirection (const StartDirection_type& x)
    {
      this->StartDirection_.set (x);
    }

    void FeatureZoneAreaBetweenType::
    StartDirection (const StartDirection_optional& x)
    {
      this->StartDirection_ = x;
    }

    void FeatureZoneAreaBetweenType::
    StartDirection (::std::unique_ptr< StartDirection_type > x)
    {
      this->StartDirection_.set (std::move (x));
    }

    const FeatureZoneAreaBetweenType::PlaneNormal_optional& FeatureZoneAreaBetweenType::
    PlaneNormal () const
    {
      return this->PlaneNormal_;
    }

    FeatureZoneAreaBetweenType::PlaneNormal_optional& FeatureZoneAreaBetweenType::
    PlaneNormal ()
    {
      return this->PlaneNormal_;
    }

    void FeatureZoneAreaBetweenType::
    PlaneNormal (const PlaneNormal_type& x)
    {
      this->PlaneNormal_.set (x);
    }

    void FeatureZoneAreaBetweenType::
    PlaneNormal (const PlaneNormal_optional& x)
    {
      this->PlaneNormal_ = x;
    }

    void FeatureZoneAreaBetweenType::
    PlaneNormal (::std::unique_ptr< PlaneNormal_type > x)
    {
      this->PlaneNormal_.set (std::move (x));
    }


    // FeatureZoneAreaSphericalType
    //

    const FeatureZoneAreaSphericalType::Sphere_type& FeatureZoneAreaSphericalType::
    Sphere () const
    {
      return this->Sphere_.get ();
    }

    FeatureZoneAreaSphericalType::Sphere_type& FeatureZoneAreaSphericalType::
    Sphere ()
    {
      return this->Sphere_.get ();
    }

    void FeatureZoneAreaSphericalType::
    Sphere (const Sphere_type& x)
    {
      this->Sphere_.set (x);
    }

    void FeatureZoneAreaSphericalType::
    Sphere (::std::unique_ptr< Sphere_type > x)
    {
      this->Sphere_.set (std::move (x));
    }


    // FeatureAspectsListsType
    //

    const FeatureAspectsListsType::FeatureDefinitions_optional& FeatureAspectsListsType::
    FeatureDefinitions () const
    {
      return this->FeatureDefinitions_;
    }

    FeatureAspectsListsType::FeatureDefinitions_optional& FeatureAspectsListsType::
    FeatureDefinitions ()
    {
      return this->FeatureDefinitions_;
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (const FeatureDefinitions_type& x)
    {
      this->FeatureDefinitions_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (const FeatureDefinitions_optional& x)
    {
      this->FeatureDefinitions_ = x;
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (::std::unique_ptr< FeatureDefinitions_type > x)
    {
      this->FeatureDefinitions_.set (std::move (x));
    }

    const FeatureAspectsListsType::FeatureNominals_optional& FeatureAspectsListsType::
    FeatureNominals () const
    {
      return this->FeatureNominals_;
    }

    FeatureAspectsListsType::FeatureNominals_optional& FeatureAspectsListsType::
    FeatureNominals ()
    {
      return this->FeatureNominals_;
    }

    void FeatureAspectsListsType::
    FeatureNominals (const FeatureNominals_type& x)
    {
      this->FeatureNominals_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureNominals (const FeatureNominals_optional& x)
    {
      this->FeatureNominals_ = x;
    }

    void FeatureAspectsListsType::
    FeatureNominals (::std::unique_ptr< FeatureNominals_type > x)
    {
      this->FeatureNominals_.set (std::move (x));
    }

    const FeatureAspectsListsType::FeatureItems_optional& FeatureAspectsListsType::
    FeatureItems () const
    {
      return this->FeatureItems_;
    }

    FeatureAspectsListsType::FeatureItems_optional& FeatureAspectsListsType::
    FeatureItems ()
    {
      return this->FeatureItems_;
    }

    void FeatureAspectsListsType::
    FeatureItems (const FeatureItems_type& x)
    {
      this->FeatureItems_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureItems (const FeatureItems_optional& x)
    {
      this->FeatureItems_ = x;
    }

    void FeatureAspectsListsType::
    FeatureItems (::std::unique_ptr< FeatureItems_type > x)
    {
      this->FeatureItems_.set (std::move (x));
    }

    const FeatureAspectsListsType::NominalPointSets_optional& FeatureAspectsListsType::
    NominalPointSets () const
    {
      return this->NominalPointSets_;
    }

    FeatureAspectsListsType::NominalPointSets_optional& FeatureAspectsListsType::
    NominalPointSets ()
    {
      return this->NominalPointSets_;
    }

    void FeatureAspectsListsType::
    NominalPointSets (const NominalPointSets_type& x)
    {
      this->NominalPointSets_.set (x);
    }

    void FeatureAspectsListsType::
    NominalPointSets (const NominalPointSets_optional& x)
    {
      this->NominalPointSets_ = x;
    }

    void FeatureAspectsListsType::
    NominalPointSets (::std::unique_ptr< NominalPointSets_type > x)
    {
      this->NominalPointSets_.set (std::move (x));
    }


    // FeatureDefinitionsType
    //

    const FeatureDefinitionsType::FeatureDefinition_sequence& FeatureDefinitionsType::
    FeatureDefinition () const
    {
      return this->FeatureDefinition_;
    }

    FeatureDefinitionsType::FeatureDefinition_sequence& FeatureDefinitionsType::
    FeatureDefinition ()
    {
      return this->FeatureDefinition_;
    }

    void FeatureDefinitionsType::
    FeatureDefinition (const FeatureDefinition_sequence& s)
    {
      this->FeatureDefinition_ = s;
    }

    const FeatureDefinitionsType::n_type& FeatureDefinitionsType::
    n () const
    {
      return this->n_.get ();
    }

    FeatureDefinitionsType::n_type& FeatureDefinitionsType::
    n ()
    {
      return this->n_.get ();
    }

    void FeatureDefinitionsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FeatureDefinitionsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FeatureNominalsType
    //

    const FeatureNominalsType::FeatureNominal_sequence& FeatureNominalsType::
    FeatureNominal () const
    {
      return this->FeatureNominal_;
    }

    FeatureNominalsType::FeatureNominal_sequence& FeatureNominalsType::
    FeatureNominal ()
    {
      return this->FeatureNominal_;
    }

    void FeatureNominalsType::
    FeatureNominal (const FeatureNominal_sequence& s)
    {
      this->FeatureNominal_ = s;
    }

    const FeatureNominalsType::n_type& FeatureNominalsType::
    n () const
    {
      return this->n_.get ();
    }

    FeatureNominalsType::n_type& FeatureNominalsType::
    n ()
    {
      return this->n_.get ();
    }

    void FeatureNominalsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FeatureNominalsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FeatureItemsType
    //

    const FeatureItemsType::FeatureItem_sequence& FeatureItemsType::
    FeatureItem () const
    {
      return this->FeatureItem_;
    }

    FeatureItemsType::FeatureItem_sequence& FeatureItemsType::
    FeatureItem ()
    {
      return this->FeatureItem_;
    }

    void FeatureItemsType::
    FeatureItem (const FeatureItem_sequence& s)
    {
      this->FeatureItem_ = s;
    }

    const FeatureItemsType::n_type& FeatureItemsType::
    n () const
    {
      return this->n_.get ();
    }

    FeatureItemsType::n_type& FeatureItemsType::
    n ()
    {
      return this->n_.get ();
    }

    void FeatureItemsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FeatureItemsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FeatureMeasurementsType
    //

    const FeatureMeasurementsType::FeatureMeasurement_sequence& FeatureMeasurementsType::
    FeatureMeasurement () const
    {
      return this->FeatureMeasurement_;
    }

    FeatureMeasurementsType::FeatureMeasurement_sequence& FeatureMeasurementsType::
    FeatureMeasurement ()
    {
      return this->FeatureMeasurement_;
    }

    void FeatureMeasurementsType::
    FeatureMeasurement (const FeatureMeasurement_sequence& s)
    {
      this->FeatureMeasurement_ = s;
    }

    const FeatureMeasurementsType::n_type& FeatureMeasurementsType::
    n () const
    {
      return this->n_.get ();
    }

    FeatureMeasurementsType::n_type& FeatureMeasurementsType::
    n ()
    {
      return this->n_.get ();
    }

    void FeatureMeasurementsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FeatureMeasurementsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FeatureZoneListType
    //

    const FeatureZoneListType::FeatureZone_sequence& FeatureZoneListType::
    FeatureZone () const
    {
      return this->FeatureZone_;
    }

    FeatureZoneListType::FeatureZone_sequence& FeatureZoneListType::
    FeatureZone ()
    {
      return this->FeatureZone_;
    }

    void FeatureZoneListType::
    FeatureZone (const FeatureZone_sequence& s)
    {
      this->FeatureZone_ = s;
    }

    const FeatureZoneListType::n_type& FeatureZoneListType::
    n () const
    {
      return this->n_.get ();
    }

    FeatureZoneListType::n_type& FeatureZoneListType::
    n ()
    {
      return this->n_.get ();
    }

    void FeatureZoneListType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FeatureZoneListType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // FeatureBaseType
    //

    FeatureBaseType::
    FeatureBaseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      id_ (this)
    {
    }

    FeatureBaseType::
    FeatureBaseType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    FeatureBaseType::
    FeatureBaseType (const FeatureBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    FeatureBaseType::
    FeatureBaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    FeatureBaseType& FeatureBaseType::
    operator= (const FeatureBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    FeatureBaseType::
    ~FeatureBaseType ()
    {
    }

    // FeatureItemBaseType
    //

    FeatureItemBaseType::
    FeatureItemBaseType ()
    : ::xsd::qif30::FeatureBaseType (),
      FeatureNominalId_ (this),
      ParentFeatureItemId_ (this),
      FeatureName_ (this),
      UUID_ (this),
      NotableEventIds_ (this),
      CoordinateSystemId_ (this)
    {
    }

    FeatureItemBaseType::
    FeatureItemBaseType (const id_type& id,
                         const FeatureNominalId_type& FeatureNominalId,
                         const FeatureName_type& FeatureName)
    : ::xsd::qif30::FeatureBaseType (id),
      FeatureNominalId_ (FeatureNominalId, this),
      ParentFeatureItemId_ (this),
      FeatureName_ (FeatureName, this),
      UUID_ (this),
      NotableEventIds_ (this),
      CoordinateSystemId_ (this)
    {
    }

    FeatureItemBaseType::
    FeatureItemBaseType (const id_type& id,
                         ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                         const FeatureName_type& FeatureName)
    : ::xsd::qif30::FeatureBaseType (id),
      FeatureNominalId_ (std::move (FeatureNominalId), this),
      ParentFeatureItemId_ (this),
      FeatureName_ (FeatureName, this),
      UUID_ (this),
      NotableEventIds_ (this),
      CoordinateSystemId_ (this)
    {
    }

    FeatureItemBaseType::
    FeatureItemBaseType (const FeatureItemBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::FeatureBaseType (x, f, c),
      FeatureNominalId_ (x.FeatureNominalId_, f, this),
      ParentFeatureItemId_ (x.ParentFeatureItemId_, f, this),
      FeatureName_ (x.FeatureName_, f, this),
      UUID_ (x.UUID_, f, this),
      NotableEventIds_ (x.NotableEventIds_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this)
    {
    }

    FeatureItemBaseType::
    FeatureItemBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureNominalId_ (this),
      ParentFeatureItemId_ (this),
      FeatureName_ (this),
      UUID_ (this),
      NotableEventIds_ (this),
      CoordinateSystemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureItemBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureNominalId
        //
        if (n.name () == L"FeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureNominalId_type > r (
            FeatureNominalId_traits::create (i, f, this));

          if (!FeatureNominalId_.present ())
          {
            this->FeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        // ParentFeatureItemId
        //
        if (n.name () == L"ParentFeatureItemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ParentFeatureItemId_type > r (
            ParentFeatureItemId_traits::create (i, f, this));

          if (!this->ParentFeatureItemId_)
          {
            this->ParentFeatureItemId_.set (::std::move (r));
            continue;
          }
        }

        // FeatureName
        //
        if (n.name () == L"FeatureName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureName_type > r (
            FeatureName_traits::create (i, f, this));

          if (!FeatureName_.present ())
          {
            this->FeatureName_.set (::std::move (r));
            continue;
          }
        }

        // UUID
        //
        if (n.name () == L"UUID" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UUID_type > r (
            UUID_traits::create (i, f, this));

          if (!this->UUID_)
          {
            this->UUID_.set (::std::move (r));
            continue;
          }
        }

        // NotableEventIds
        //
        if (n.name () == L"NotableEventIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NotableEventIds_type > r (
            NotableEventIds_traits::create (i, f, this));

          if (!this->NotableEventIds_)
          {
            this->NotableEventIds_.set (::std::move (r));
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == L"CoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!this->CoordinateSystemId_)
          {
            this->CoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FeatureNominalId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureNominalId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!FeatureName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureItemBaseType& FeatureItemBaseType::
    operator= (const FeatureItemBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureBaseType& > (*this) = x;
        this->FeatureNominalId_ = x.FeatureNominalId_;
        this->ParentFeatureItemId_ = x.ParentFeatureItemId_;
        this->FeatureName_ = x.FeatureName_;
        this->UUID_ = x.UUID_;
        this->NotableEventIds_ = x.NotableEventIds_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
      }

      return *this;
    }

    FeatureItemBaseType::
    ~FeatureItemBaseType ()
    {
    }

    // ShapeFeatureItemBaseType
    //

    ShapeFeatureItemBaseType::
    ShapeFeatureItemBaseType ()
    : ::xsd::qif30::FeatureItemBaseType (),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this),
      VirtualMeasurement_ (this)
    {
    }

    ShapeFeatureItemBaseType::
    ShapeFeatureItemBaseType (const id_type& id,
                              const FeatureNominalId_type& FeatureNominalId,
                              const FeatureName_type& FeatureName)
    : ::xsd::qif30::FeatureItemBaseType (id,
                                         FeatureNominalId,
                                         FeatureName),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this),
      VirtualMeasurement_ (this)
    {
    }

    ShapeFeatureItemBaseType::
    ShapeFeatureItemBaseType (const id_type& id,
                              ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                              const FeatureName_type& FeatureName)
    : ::xsd::qif30::FeatureItemBaseType (id,
                                         std::move (FeatureNominalId),
                                         FeatureName),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this),
      VirtualMeasurement_ (this)
    {
    }

    ShapeFeatureItemBaseType::
    ShapeFeatureItemBaseType (const ShapeFeatureItemBaseType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::FeatureItemBaseType (x, f, c),
      PointList_ (x.PointList_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this),
      VirtualMeasurement_ (x.VirtualMeasurement_, f, this)
    {
    }

    ShapeFeatureItemBaseType::
    ShapeFeatureItemBaseType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this),
      VirtualMeasurement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ShapeFeatureItemBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointList
        //
        if (n.name () == L"PointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (::std::move (r));
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == L"SubstituteFeatureAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        // VirtualMeasurement
        //
        if (n.name () == L"VirtualMeasurement" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VirtualMeasurement_type > r (
            VirtualMeasurement_traits::create (i, f, this));

          if (!this->VirtualMeasurement_)
          {
            this->VirtualMeasurement_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ShapeFeatureItemBaseType& ShapeFeatureItemBaseType::
    operator= (const ShapeFeatureItemBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureItemBaseType& > (*this) = x;
        this->PointList_ = x.PointList_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
        this->VirtualMeasurement_ = x.VirtualMeasurement_;
      }

      return *this;
    }

    ShapeFeatureItemBaseType::
    ~ShapeFeatureItemBaseType ()
    {
    }

    // NonShapeFeatureItemBaseType
    //

    NonShapeFeatureItemBaseType::
    NonShapeFeatureItemBaseType ()
    : ::xsd::qif30::FeatureItemBaseType ()
    {
    }

    NonShapeFeatureItemBaseType::
    NonShapeFeatureItemBaseType (const id_type& id,
                                 const FeatureNominalId_type& FeatureNominalId,
                                 const FeatureName_type& FeatureName)
    : ::xsd::qif30::FeatureItemBaseType (id,
                                         FeatureNominalId,
                                         FeatureName)
    {
    }

    NonShapeFeatureItemBaseType::
    NonShapeFeatureItemBaseType (const id_type& id,
                                 ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                 const FeatureName_type& FeatureName)
    : ::xsd::qif30::FeatureItemBaseType (id,
                                         std::move (FeatureNominalId),
                                         FeatureName)
    {
    }

    NonShapeFeatureItemBaseType::
    NonShapeFeatureItemBaseType (const NonShapeFeatureItemBaseType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::FeatureItemBaseType (x, f, c)
    {
    }

    NonShapeFeatureItemBaseType::
    NonShapeFeatureItemBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::FeatureItemBaseType (e, f, c)
    {
    }

    NonShapeFeatureItemBaseType::
    ~NonShapeFeatureItemBaseType ()
    {
    }

    // FeatureDefinitionBaseType
    //

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType ()
    : ::xsd::qif30::FeatureBaseType ()
    {
    }

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif30::FeatureBaseType (id)
    {
    }

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const FeatureDefinitionBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::FeatureBaseType (x, f, c)
    {
    }

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::FeatureBaseType (e, f, c)
    {
    }

    FeatureDefinitionBaseType::
    ~FeatureDefinitionBaseType ()
    {
    }

    // ShapeFeatureDefinitionBaseType
    //

    ShapeFeatureDefinitionBaseType::
    ShapeFeatureDefinitionBaseType ()
    : ::xsd::qif30::FeatureDefinitionBaseType ()
    {
    }

    ShapeFeatureDefinitionBaseType::
    ShapeFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif30::FeatureDefinitionBaseType (id)
    {
    }

    ShapeFeatureDefinitionBaseType::
    ShapeFeatureDefinitionBaseType (const ShapeFeatureDefinitionBaseType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::FeatureDefinitionBaseType (x, f, c)
    {
    }

    ShapeFeatureDefinitionBaseType::
    ShapeFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::FeatureDefinitionBaseType (e, f, c)
    {
    }

    ShapeFeatureDefinitionBaseType::
    ~ShapeFeatureDefinitionBaseType ()
    {
    }

    // NonShapeFeatureDefinitionBaseType
    //

    NonShapeFeatureDefinitionBaseType::
    NonShapeFeatureDefinitionBaseType ()
    : ::xsd::qif30::FeatureDefinitionBaseType ()
    {
    }

    NonShapeFeatureDefinitionBaseType::
    NonShapeFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif30::FeatureDefinitionBaseType (id)
    {
    }

    NonShapeFeatureDefinitionBaseType::
    NonShapeFeatureDefinitionBaseType (const NonShapeFeatureDefinitionBaseType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::FeatureDefinitionBaseType (x, f, c)
    {
    }

    NonShapeFeatureDefinitionBaseType::
    NonShapeFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::FeatureDefinitionBaseType (e, f, c)
    {
    }

    NonShapeFeatureDefinitionBaseType::
    ~NonShapeFeatureDefinitionBaseType ()
    {
    }

    // PointSetNominalType
    //

    PointSetNominalType::
    PointSetNominalType ()
    : ::xml_schema::type (),
      MeasurePoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      n_ (this),
      id_ (this)
    {
    }

    PointSetNominalType::
    PointSetNominalType (const n_type& n,
                         const id_type& id)
    : ::xml_schema::type (),
      MeasurePoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      n_ (n, this),
      id_ (id, this)
    {
    }

    PointSetNominalType::
    PointSetNominalType (const PointSetNominalType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurePoint_ (x.MeasurePoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this),
      n_ (x.n_, f, this),
      id_ (x.id_, f, this)
    {
    }

    PointSetNominalType::
    PointSetNominalType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurePoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      n_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointSetNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasurePoint
        //
        if (n.name () == L"MeasurePoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurePoint_type > r (
            MeasurePoint_traits::create (i, f, this));

          this->MeasurePoint_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    PointSetNominalType* PointSetNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointSetNominalType (*this, f, c);
    }

    PointSetNominalType& PointSetNominalType::
    operator= (const PointSetNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasurePoint_ = x.MeasurePoint_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
        this->n_ = x.n_;
        this->id_ = x.id_;
      }

      return *this;
    }

    PointSetNominalType::
    ~PointSetNominalType ()
    {
    }

    // NominalPointSetListType
    //

    NominalPointSetListType::
    NominalPointSetListType ()
    : ::xml_schema::type (),
      NominalPointSet_ (this),
      n_ (this)
    {
    }

    NominalPointSetListType::
    NominalPointSetListType (const n_type& n)
    : ::xml_schema::type (),
      NominalPointSet_ (this),
      n_ (n, this)
    {
    }

    NominalPointSetListType::
    NominalPointSetListType (const NominalPointSetListType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NominalPointSet_ (x.NominalPointSet_, f, this),
      n_ (x.n_, f, this)
    {
    }

    NominalPointSetListType::
    NominalPointSetListType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NominalPointSet_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NominalPointSetListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NominalPointSet
        //
        if (n.name () == L"NominalPointSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NominalPointSet_type > r (
            NominalPointSet_traits::create (i, f, this));

          this->NominalPointSet_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    NominalPointSetListType* NominalPointSetListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NominalPointSetListType (*this, f, c);
    }

    NominalPointSetListType& NominalPointSetListType::
    operator= (const NominalPointSetListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NominalPointSet_ = x.NominalPointSet_;
        this->n_ = x.n_;
      }

      return *this;
    }

    NominalPointSetListType::
    ~NominalPointSetListType ()
    {
    }

    // FeatureNominalBaseType
    //

    FeatureNominalBaseType::
    FeatureNominalBaseType ()
    : ::xsd::qif30::FeatureBaseType (),
      Name_ (this),
      UUID_ (this),
      FeatureDefinitionId_ (this),
      ParentFeatureNominalId_ (this),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this)
    {
    }

    FeatureNominalBaseType::
    FeatureNominalBaseType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::FeatureBaseType (id),
      Name_ (this),
      UUID_ (this),
      FeatureDefinitionId_ (FeatureDefinitionId, this),
      ParentFeatureNominalId_ (this),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this)
    {
    }

    FeatureNominalBaseType::
    FeatureNominalBaseType (const id_type& id,
                            ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::FeatureBaseType (id),
      Name_ (this),
      UUID_ (this),
      FeatureDefinitionId_ (std::move (FeatureDefinitionId), this),
      ParentFeatureNominalId_ (this),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this)
    {
    }

    FeatureNominalBaseType::
    FeatureNominalBaseType (const FeatureNominalBaseType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::FeatureBaseType (x, f, c),
      Name_ (x.Name_, f, this),
      UUID_ (x.UUID_, f, this),
      FeatureDefinitionId_ (x.FeatureDefinitionId_, f, this),
      ParentFeatureNominalId_ (x.ParentFeatureNominalId_, f, this),
      EntityInternalIds_ (x.EntityInternalIds_, f, this),
      EntityExternalIds_ (x.EntityExternalIds_, f, this)
    {
    }

    FeatureNominalBaseType::
    FeatureNominalBaseType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      UUID_ (this),
      FeatureDefinitionId_ (this),
      ParentFeatureNominalId_ (this),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureNominalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Name
        //
        if (n.name () == L"Name" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (::std::move (r));
            continue;
          }
        }

        // UUID
        //
        if (n.name () == L"UUID" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UUID_type > r (
            UUID_traits::create (i, f, this));

          if (!this->UUID_)
          {
            this->UUID_.set (::std::move (r));
            continue;
          }
        }

        // FeatureDefinitionId
        //
        if (n.name () == L"FeatureDefinitionId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureDefinitionId_type > r (
            FeatureDefinitionId_traits::create (i, f, this));

          if (!FeatureDefinitionId_.present ())
          {
            this->FeatureDefinitionId_.set (::std::move (r));
            continue;
          }
        }

        // ParentFeatureNominalId
        //
        if (n.name () == L"ParentFeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ParentFeatureNominalId_type > r (
            ParentFeatureNominalId_traits::create (i, f, this));

          if (!this->ParentFeatureNominalId_)
          {
            this->ParentFeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        // EntityInternalIds
        //
        if (n.name () == L"EntityInternalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EntityInternalIds_type > r (
            EntityInternalIds_traits::create (i, f, this));

          if (!this->EntityInternalIds_)
          {
            this->EntityInternalIds_.set (::std::move (r));
            continue;
          }
        }

        // EntityExternalIds
        //
        if (n.name () == L"EntityExternalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EntityExternalIds_type > r (
            EntityExternalIds_traits::create (i, f, this));

          if (!this->EntityExternalIds_)
          {
            this->EntityExternalIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FeatureDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureDefinitionId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureNominalBaseType& FeatureNominalBaseType::
    operator= (const FeatureNominalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureBaseType& > (*this) = x;
        this->Name_ = x.Name_;
        this->UUID_ = x.UUID_;
        this->FeatureDefinitionId_ = x.FeatureDefinitionId_;
        this->ParentFeatureNominalId_ = x.ParentFeatureNominalId_;
        this->EntityInternalIds_ = x.EntityInternalIds_;
        this->EntityExternalIds_ = x.EntityExternalIds_;
      }

      return *this;
    }

    FeatureNominalBaseType::
    ~FeatureNominalBaseType ()
    {
    }

    // ShapeFeatureNominalBaseType
    //

    ShapeFeatureNominalBaseType::
    ShapeFeatureNominalBaseType ()
    : ::xsd::qif30::FeatureNominalBaseType (),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ShapeFeatureNominalBaseType::
    ShapeFeatureNominalBaseType (const id_type& id,
                                 const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::FeatureNominalBaseType (id,
                                            FeatureDefinitionId),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ShapeFeatureNominalBaseType::
    ShapeFeatureNominalBaseType (const id_type& id,
                                 ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::FeatureNominalBaseType (id,
                                            std::move (FeatureDefinitionId)),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ShapeFeatureNominalBaseType::
    ShapeFeatureNominalBaseType (const ShapeFeatureNominalBaseType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::FeatureNominalBaseType (x, f, c),
      PointList_ (x.PointList_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ShapeFeatureNominalBaseType::
    ShapeFeatureNominalBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ShapeFeatureNominalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointList
        //
        if (n.name () == L"PointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (::std::move (r));
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == L"SubstituteFeatureAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ShapeFeatureNominalBaseType& ShapeFeatureNominalBaseType::
    operator= (const ShapeFeatureNominalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureNominalBaseType& > (*this) = x;
        this->PointList_ = x.PointList_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    ShapeFeatureNominalBaseType::
    ~ShapeFeatureNominalBaseType ()
    {
    }

    // NonShapeFeatureNominalBaseType
    //

    NonShapeFeatureNominalBaseType::
    NonShapeFeatureNominalBaseType ()
    : ::xsd::qif30::FeatureNominalBaseType ()
    {
    }

    NonShapeFeatureNominalBaseType::
    NonShapeFeatureNominalBaseType (const id_type& id,
                                    const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::FeatureNominalBaseType (id,
                                            FeatureDefinitionId)
    {
    }

    NonShapeFeatureNominalBaseType::
    NonShapeFeatureNominalBaseType (const id_type& id,
                                    ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::FeatureNominalBaseType (id,
                                            std::move (FeatureDefinitionId))
    {
    }

    NonShapeFeatureNominalBaseType::
    NonShapeFeatureNominalBaseType (const NonShapeFeatureNominalBaseType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::FeatureNominalBaseType (x, f, c)
    {
    }

    NonShapeFeatureNominalBaseType::
    NonShapeFeatureNominalBaseType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::FeatureNominalBaseType (e, f, c)
    {
    }

    NonShapeFeatureNominalBaseType::
    ~NonShapeFeatureNominalBaseType ()
    {
    }

    // MeasuredPointSetsType
    //

    MeasuredPointSetsType::
    MeasuredPointSetsType ()
    : ::xml_schema::type (),
      MeasuredPointSet_ (this),
      n_ (this)
    {
    }

    MeasuredPointSetsType::
    MeasuredPointSetsType (const n_type& n)
    : ::xml_schema::type (),
      MeasuredPointSet_ (this),
      n_ (n, this)
    {
    }

    MeasuredPointSetsType::
    MeasuredPointSetsType (const MeasuredPointSetsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasuredPointSet_ (x.MeasuredPointSet_, f, this),
      n_ (x.n_, f, this)
    {
    }

    MeasuredPointSetsType::
    MeasuredPointSetsType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasuredPointSet_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredPointSetsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MeasuredPointSet
        //
        if (n.name () == L"MeasuredPointSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasuredPointSet_type > r (
            MeasuredPointSet_traits::create (i, f, this));

          this->MeasuredPointSet_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    MeasuredPointSetsType* MeasuredPointSetsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredPointSetsType (*this, f, c);
    }

    MeasuredPointSetsType& MeasuredPointSetsType::
    operator= (const MeasuredPointSetsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasuredPointSet_ = x.MeasuredPointSet_;
        this->n_ = x.n_;
      }

      return *this;
    }

    MeasuredPointSetsType::
    ~MeasuredPointSetsType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_WholePointSetId_element_factory_init (
      L"PointSetId",
      L"http://qifstandards.org/xsd/qif3",
      L"WholePointSetId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointSetReferenceWholeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_RangePointSetId_element_factory_init (
      L"PointSetId",
      L"http://qifstandards.org/xsd/qif3",
      L"RangePointSetId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointSetReferenceRangeType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SinglePointSetId_element_factory_init (
      L"PointSetId",
      L"http://qifstandards.org/xsd/qif3",
      L"SinglePointSetId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointSetReferenceSingleType >);


    // PointListType
    //

    PointListType::
    PointListType ()
    : ::xml_schema::type (),
      PointSetId_ (this),
      n_ (this)
    {
    }

    PointListType::
    PointListType (const n_type& n)
    : ::xml_schema::type (),
      PointSetId_ (this),
      n_ (n, this)
    {
    }

    PointListType::
    PointListType (const PointListType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSetId_ (x.PointSetId_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PointListType::
    PointListType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSetId_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointSetId
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"PointSetId",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< PointSetId_type > r (
              dynamic_cast< PointSetId_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->PointSetId_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PointListType* PointListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointListType (*this, f, c);
    }

    PointListType& PointListType::
    operator= (const PointListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointSetId_ = x.PointSetId_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PointListType::
    ~PointListType ()
    {
    }

    // MeasuredPointSetType
    //

    MeasuredPointSetType::
    MeasuredPointSetType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Units_ (this),
      CoordinateSystemId_ (this),
      TranformId_ (this),
      Points_ (this),
      BinaryPoints_ (this),
      Normals_ (this),
      BinaryNormals_ (this),
      Compensated_ (this),
      Compensations_ (this),
      BinaryCompensated_ (this),
      ProbeRadius_ (this),
      ProbeRadii_ (this),
      BinaryProbeRadii_ (this),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      SensorIds_ (this),
      BinarySensorIds_ (this),
      TipId_ (this),
      TipIds_ (this),
      BinaryTipIds_ (this),
      MeasurePointNominalIds_ (this),
      BinaryMeasurePointNominalIds_ (this),
      TimeStamp_ (this),
      TimeStamps_ (this),
      Quality_ (this),
      BinaryQuality_ (this),
      Deviations_ (this),
      BinaryDeviations_ (this),
      Colors_ (this),
      BinaryColors_ (this),
      NumberOfFacets_ (this),
      PointIndices_ (this),
      BinaryPointIndices_ (this),
      count_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this),
      id_ (this)
    {
    }

    MeasuredPointSetType::
    MeasuredPointSetType (const count_type& count,
                          const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Units_ (this),
      CoordinateSystemId_ (this),
      TranformId_ (this),
      Points_ (this),
      BinaryPoints_ (this),
      Normals_ (this),
      BinaryNormals_ (this),
      Compensated_ (this),
      Compensations_ (this),
      BinaryCompensated_ (this),
      ProbeRadius_ (this),
      ProbeRadii_ (this),
      BinaryProbeRadii_ (this),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      SensorIds_ (this),
      BinarySensorIds_ (this),
      TipId_ (this),
      TipIds_ (this),
      BinaryTipIds_ (this),
      MeasurePointNominalIds_ (this),
      BinaryMeasurePointNominalIds_ (this),
      TimeStamp_ (this),
      TimeStamps_ (this),
      Quality_ (this),
      BinaryQuality_ (this),
      Deviations_ (this),
      BinaryDeviations_ (this),
      Colors_ (this),
      BinaryColors_ (this),
      NumberOfFacets_ (this),
      PointIndices_ (this),
      BinaryPointIndices_ (this),
      count_ (count, this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this),
      id_ (id, this)
    {
    }

    MeasuredPointSetType::
    MeasuredPointSetType (const MeasuredPointSetType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Units_ (x.Units_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this),
      TranformId_ (x.TranformId_, f, this),
      Points_ (x.Points_, f, this),
      BinaryPoints_ (x.BinaryPoints_, f, this),
      Normals_ (x.Normals_, f, this),
      BinaryNormals_ (x.BinaryNormals_, f, this),
      Compensated_ (x.Compensated_, f, this),
      Compensations_ (x.Compensations_, f, this),
      BinaryCompensated_ (x.BinaryCompensated_, f, this),
      ProbeRadius_ (x.ProbeRadius_, f, this),
      ProbeRadii_ (x.ProbeRadii_, f, this),
      BinaryProbeRadii_ (x.BinaryProbeRadii_, f, this),
      MeasurementDeviceId_ (x.MeasurementDeviceId_, f, this),
      SensorId_ (x.SensorId_, f, this),
      SensorIds_ (x.SensorIds_, f, this),
      BinarySensorIds_ (x.BinarySensorIds_, f, this),
      TipId_ (x.TipId_, f, this),
      TipIds_ (x.TipIds_, f, this),
      BinaryTipIds_ (x.BinaryTipIds_, f, this),
      MeasurePointNominalIds_ (x.MeasurePointNominalIds_, f, this),
      BinaryMeasurePointNominalIds_ (x.BinaryMeasurePointNominalIds_, f, this),
      TimeStamp_ (x.TimeStamp_, f, this),
      TimeStamps_ (x.TimeStamps_, f, this),
      Quality_ (x.Quality_, f, this),
      BinaryQuality_ (x.BinaryQuality_, f, this),
      Deviations_ (x.Deviations_, f, this),
      BinaryDeviations_ (x.BinaryDeviations_, f, this),
      Colors_ (x.Colors_, f, this),
      BinaryColors_ (x.BinaryColors_, f, this),
      NumberOfFacets_ (x.NumberOfFacets_, f, this),
      PointIndices_ (x.PointIndices_, f, this),
      BinaryPointIndices_ (x.BinaryPointIndices_, f, this),
      count_ (x.count_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this),
      id_ (x.id_, f, this)
    {
    }

    MeasuredPointSetType::
    MeasuredPointSetType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Units_ (this),
      CoordinateSystemId_ (this),
      TranformId_ (this),
      Points_ (this),
      BinaryPoints_ (this),
      Normals_ (this),
      BinaryNormals_ (this),
      Compensated_ (this),
      Compensations_ (this),
      BinaryCompensated_ (this),
      ProbeRadius_ (this),
      ProbeRadii_ (this),
      BinaryProbeRadii_ (this),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      SensorIds_ (this),
      BinarySensorIds_ (this),
      TipId_ (this),
      TipIds_ (this),
      BinaryTipIds_ (this),
      MeasurePointNominalIds_ (this),
      BinaryMeasurePointNominalIds_ (this),
      TimeStamp_ (this),
      TimeStamps_ (this),
      Quality_ (this),
      BinaryQuality_ (this),
      Deviations_ (this),
      BinaryDeviations_ (this),
      Colors_ (this),
      BinaryColors_ (this),
      NumberOfFacets_ (this),
      PointIndices_ (this),
      BinaryPointIndices_ (this),
      count_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredPointSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Units
        //
        if (n.name () == L"Units" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!this->Units_)
          {
            this->Units_.set (::std::move (r));
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == L"CoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!this->CoordinateSystemId_)
          {
            this->CoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        // TranformId
        //
        if (n.name () == L"TranformId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TranformId_type > r (
            TranformId_traits::create (i, f, this));

          if (!this->TranformId_)
          {
            this->TranformId_.set (::std::move (r));
            continue;
          }
        }

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        // BinaryPoints
        //
        if (n.name () == L"BinaryPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryPoints_type > r (
            BinaryPoints_traits::create (i, f, this));

          if (!this->BinaryPoints_)
          {
            this->BinaryPoints_.set (::std::move (r));
            continue;
          }
        }

        // Normals
        //
        if (n.name () == L"Normals" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normals_type > r (
            Normals_traits::create (i, f, this));

          if (!this->Normals_)
          {
            this->Normals_.set (::std::move (r));
            continue;
          }
        }

        // BinaryNormals
        //
        if (n.name () == L"BinaryNormals" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryNormals_type > r (
            BinaryNormals_traits::create (i, f, this));

          if (!this->BinaryNormals_)
          {
            this->BinaryNormals_.set (::std::move (r));
            continue;
          }
        }

        // Compensated
        //
        if (n.name () == L"Compensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Compensated_)
          {
            this->Compensated_.set (Compensated_traits::create (i, f, this));
            continue;
          }
        }

        // Compensations
        //
        if (n.name () == L"Compensations" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Compensations_type > r (
            Compensations_traits::create (i, f, this));

          if (!this->Compensations_)
          {
            this->Compensations_.set (::std::move (r));
            continue;
          }
        }

        // BinaryCompensated
        //
        if (n.name () == L"BinaryCompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryCompensated_type > r (
            BinaryCompensated_traits::create (i, f, this));

          if (!this->BinaryCompensated_)
          {
            this->BinaryCompensated_.set (::std::move (r));
            continue;
          }
        }

        // ProbeRadius
        //
        if (n.name () == L"ProbeRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->ProbeRadius_)
          {
            this->ProbeRadius_.set (ProbeRadius_traits::create (i, f, this));
            continue;
          }
        }

        // ProbeRadii
        //
        if (n.name () == L"ProbeRadii" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProbeRadii_type > r (
            ProbeRadii_traits::create (i, f, this));

          if (!this->ProbeRadii_)
          {
            this->ProbeRadii_.set (::std::move (r));
            continue;
          }
        }

        // BinaryProbeRadii
        //
        if (n.name () == L"BinaryProbeRadii" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryProbeRadii_type > r (
            BinaryProbeRadii_traits::create (i, f, this));

          if (!this->BinaryProbeRadii_)
          {
            this->BinaryProbeRadii_.set (::std::move (r));
            continue;
          }
        }

        // MeasurementDeviceId
        //
        if (n.name () == L"MeasurementDeviceId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceId_type > r (
            MeasurementDeviceId_traits::create (i, f, this));

          if (!this->MeasurementDeviceId_)
          {
            this->MeasurementDeviceId_.set (::std::move (r));
            continue;
          }
        }

        // SensorId
        //
        if (n.name () == L"SensorId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SensorId_type > r (
            SensorId_traits::create (i, f, this));

          if (!this->SensorId_)
          {
            this->SensorId_.set (::std::move (r));
            continue;
          }
        }

        // SensorIds
        //
        if (n.name () == L"SensorIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SensorIds_type > r (
            SensorIds_traits::create (i, f, this));

          if (!this->SensorIds_)
          {
            this->SensorIds_.set (::std::move (r));
            continue;
          }
        }

        // BinarySensorIds
        //
        if (n.name () == L"BinarySensorIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinarySensorIds_type > r (
            BinarySensorIds_traits::create (i, f, this));

          if (!this->BinarySensorIds_)
          {
            this->BinarySensorIds_.set (::std::move (r));
            continue;
          }
        }

        // TipId
        //
        if (n.name () == L"TipId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipId_type > r (
            TipId_traits::create (i, f, this));

          if (!this->TipId_)
          {
            this->TipId_.set (::std::move (r));
            continue;
          }
        }

        // TipIds
        //
        if (n.name () == L"TipIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TipIds_type > r (
            TipIds_traits::create (i, f, this));

          if (!this->TipIds_)
          {
            this->TipIds_.set (::std::move (r));
            continue;
          }
        }

        // BinaryTipIds
        //
        if (n.name () == L"BinaryTipIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryTipIds_type > r (
            BinaryTipIds_traits::create (i, f, this));

          if (!this->BinaryTipIds_)
          {
            this->BinaryTipIds_.set (::std::move (r));
            continue;
          }
        }

        // MeasurePointNominalIds
        //
        if (n.name () == L"MeasurePointNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurePointNominalIds_type > r (
            MeasurePointNominalIds_traits::create (i, f, this));

          if (!this->MeasurePointNominalIds_)
          {
            this->MeasurePointNominalIds_.set (::std::move (r));
            continue;
          }
        }

        // BinaryMeasurePointNominalIds
        //
        if (n.name () == L"BinaryMeasurePointNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryMeasurePointNominalIds_type > r (
            BinaryMeasurePointNominalIds_traits::create (i, f, this));

          if (!this->BinaryMeasurePointNominalIds_)
          {
            this->BinaryMeasurePointNominalIds_.set (::std::move (r));
            continue;
          }
        }

        // TimeStamp
        //
        if (n.name () == L"TimeStamp" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeStamp_type > r (
            TimeStamp_traits::create (i, f, this));

          if (!this->TimeStamp_)
          {
            this->TimeStamp_.set (::std::move (r));
            continue;
          }
        }

        // TimeStamps
        //
        if (n.name () == L"TimeStamps" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeStamps_type > r (
            TimeStamps_traits::create (i, f, this));

          if (!this->TimeStamps_)
          {
            this->TimeStamps_.set (::std::move (r));
            continue;
          }
        }

        // Quality
        //
        if (n.name () == L"Quality" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Quality_type > r (
            Quality_traits::create (i, f, this));

          if (!this->Quality_)
          {
            this->Quality_.set (::std::move (r));
            continue;
          }
        }

        // BinaryQuality
        //
        if (n.name () == L"BinaryQuality" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryQuality_type > r (
            BinaryQuality_traits::create (i, f, this));

          if (!this->BinaryQuality_)
          {
            this->BinaryQuality_.set (::std::move (r));
            continue;
          }
        }

        // Deviations
        //
        if (n.name () == L"Deviations" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Deviations_type > r (
            Deviations_traits::create (i, f, this));

          if (!this->Deviations_)
          {
            this->Deviations_.set (::std::move (r));
            continue;
          }
        }

        // BinaryDeviations
        //
        if (n.name () == L"BinaryDeviations" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryDeviations_type > r (
            BinaryDeviations_traits::create (i, f, this));

          if (!this->BinaryDeviations_)
          {
            this->BinaryDeviations_.set (::std::move (r));
            continue;
          }
        }

        // Colors
        //
        if (n.name () == L"Colors" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Colors_type > r (
            Colors_traits::create (i, f, this));

          if (!this->Colors_)
          {
            this->Colors_.set (::std::move (r));
            continue;
          }
        }

        // BinaryColors
        //
        if (n.name () == L"BinaryColors" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryColors_type > r (
            BinaryColors_traits::create (i, f, this));

          if (!this->BinaryColors_)
          {
            this->BinaryColors_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfFacets
        //
        if (n.name () == L"NumberOfFacets" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberOfFacets_type > r (
            NumberOfFacets_traits::create (i, f, this));

          if (!this->NumberOfFacets_)
          {
            this->NumberOfFacets_.set (::std::move (r));
            continue;
          }
        }

        // PointIndices
        //
        if (n.name () == L"PointIndices" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointIndices_type > r (
            PointIndices_traits::create (i, f, this));

          if (!this->PointIndices_)
          {
            this->PointIndices_.set (::std::move (r));
            continue;
          }
        }

        // BinaryPointIndices
        //
        if (n.name () == L"BinaryPointIndices" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BinaryPointIndices_type > r (
            BinaryPointIndices_traits::create (i, f, this));

          if (!this->BinaryPointIndices_)
          {
            this->BinaryPointIndices_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"count",
          L"");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    MeasuredPointSetType* MeasuredPointSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredPointSetType (*this, f, c);
    }

    MeasuredPointSetType& MeasuredPointSetType::
    operator= (const MeasuredPointSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Units_ = x.Units_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
        this->TranformId_ = x.TranformId_;
        this->Points_ = x.Points_;
        this->BinaryPoints_ = x.BinaryPoints_;
        this->Normals_ = x.Normals_;
        this->BinaryNormals_ = x.BinaryNormals_;
        this->Compensated_ = x.Compensated_;
        this->Compensations_ = x.Compensations_;
        this->BinaryCompensated_ = x.BinaryCompensated_;
        this->ProbeRadius_ = x.ProbeRadius_;
        this->ProbeRadii_ = x.ProbeRadii_;
        this->BinaryProbeRadii_ = x.BinaryProbeRadii_;
        this->MeasurementDeviceId_ = x.MeasurementDeviceId_;
        this->SensorId_ = x.SensorId_;
        this->SensorIds_ = x.SensorIds_;
        this->BinarySensorIds_ = x.BinarySensorIds_;
        this->TipId_ = x.TipId_;
        this->TipIds_ = x.TipIds_;
        this->BinaryTipIds_ = x.BinaryTipIds_;
        this->MeasurePointNominalIds_ = x.MeasurePointNominalIds_;
        this->BinaryMeasurePointNominalIds_ = x.BinaryMeasurePointNominalIds_;
        this->TimeStamp_ = x.TimeStamp_;
        this->TimeStamps_ = x.TimeStamps_;
        this->Quality_ = x.Quality_;
        this->BinaryQuality_ = x.BinaryQuality_;
        this->Deviations_ = x.Deviations_;
        this->BinaryDeviations_ = x.BinaryDeviations_;
        this->Colors_ = x.Colors_;
        this->BinaryColors_ = x.BinaryColors_;
        this->NumberOfFacets_ = x.NumberOfFacets_;
        this->PointIndices_ = x.PointIndices_;
        this->BinaryPointIndices_ = x.BinaryPointIndices_;
        this->count_ = x.count_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
        this->combinedUncertainty_ = x.combinedUncertainty_;
        this->meanError_ = x.meanError_;
        this->xCombinedUncertainty_ = x.xCombinedUncertainty_;
        this->xMeanError_ = x.xMeanError_;
        this->yCombinedUncertainty_ = x.yCombinedUncertainty_;
        this->yMeanError_ = x.yMeanError_;
        this->zCombinedUncertainty_ = x.zCombinedUncertainty_;
        this->zMeanError_ = x.zMeanError_;
        this->id_ = x.id_;
      }

      return *this;
    }

    MeasuredPointSetType::
    ~MeasuredPointSetType ()
    {
    }

    // FeatureMeasurementBaseType
    //

    FeatureMeasurementBaseType::
    FeatureMeasurementBaseType ()
    : ::xsd::qif30::FeatureBaseType (),
      FeatureItemId_ (this),
      FeatureName_ (this),
      TimeStamp_ (this),
      ActualComponentId_ (this),
      ManufacturingProcessId_ (this),
      MeasurementDeviceIds_ (this),
      ActualTransformId_ (this),
      NotedEventIds_ (this)
    {
    }

    FeatureMeasurementBaseType::
    FeatureMeasurementBaseType (const id_type& id)
    : ::xsd::qif30::FeatureBaseType (id),
      FeatureItemId_ (this),
      FeatureName_ (this),
      TimeStamp_ (this),
      ActualComponentId_ (this),
      ManufacturingProcessId_ (this),
      MeasurementDeviceIds_ (this),
      ActualTransformId_ (this),
      NotedEventIds_ (this)
    {
    }

    FeatureMeasurementBaseType::
    FeatureMeasurementBaseType (const FeatureMeasurementBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::FeatureBaseType (x, f, c),
      FeatureItemId_ (x.FeatureItemId_, f, this),
      FeatureName_ (x.FeatureName_, f, this),
      TimeStamp_ (x.TimeStamp_, f, this),
      ActualComponentId_ (x.ActualComponentId_, f, this),
      ManufacturingProcessId_ (x.ManufacturingProcessId_, f, this),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this),
      ActualTransformId_ (x.ActualTransformId_, f, this),
      NotedEventIds_ (x.NotedEventIds_, f, this)
    {
    }

    FeatureMeasurementBaseType::
    FeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureItemId_ (this),
      FeatureName_ (this),
      TimeStamp_ (this),
      ActualComponentId_ (this),
      ManufacturingProcessId_ (this),
      MeasurementDeviceIds_ (this),
      ActualTransformId_ (this),
      NotedEventIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureMeasurementBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureItemId
        //
        if (n.name () == L"FeatureItemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!this->FeatureItemId_)
          {
            this->FeatureItemId_.set (::std::move (r));
            continue;
          }
        }

        // FeatureName
        //
        if (n.name () == L"FeatureName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureName_type > r (
            FeatureName_traits::create (i, f, this));

          if (!this->FeatureName_)
          {
            this->FeatureName_.set (::std::move (r));
            continue;
          }
        }

        // TimeStamp
        //
        if (n.name () == L"TimeStamp" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeStamp_type > r (
            TimeStamp_traits::create (i, f, this));

          if (!this->TimeStamp_)
          {
            this->TimeStamp_.set (::std::move (r));
            continue;
          }
        }

        // ActualComponentId
        //
        if (n.name () == L"ActualComponentId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActualComponentId_type > r (
            ActualComponentId_traits::create (i, f, this));

          if (!this->ActualComponentId_)
          {
            this->ActualComponentId_.set (::std::move (r));
            continue;
          }
        }

        // ManufacturingProcessId
        //
        if (n.name () == L"ManufacturingProcessId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ManufacturingProcessId_type > r (
            ManufacturingProcessId_traits::create (i, f, this));

          if (!this->ManufacturingProcessId_)
          {
            this->ManufacturingProcessId_.set (::std::move (r));
            continue;
          }
        }

        // MeasurementDeviceIds
        //
        if (n.name () == L"MeasurementDeviceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (::std::move (r));
            continue;
          }
        }

        // ActualTransformId
        //
        if (n.name () == L"ActualTransformId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ActualTransformId_type > r (
            ActualTransformId_traits::create (i, f, this));

          if (!this->ActualTransformId_)
          {
            this->ActualTransformId_.set (::std::move (r));
            continue;
          }
        }

        // NotedEventIds
        //
        if (n.name () == L"NotedEventIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NotedEventIds_type > r (
            NotedEventIds_traits::create (i, f, this));

          if (!this->NotedEventIds_)
          {
            this->NotedEventIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FeatureMeasurementBaseType& FeatureMeasurementBaseType::
    operator= (const FeatureMeasurementBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureBaseType& > (*this) = x;
        this->FeatureItemId_ = x.FeatureItemId_;
        this->FeatureName_ = x.FeatureName_;
        this->TimeStamp_ = x.TimeStamp_;
        this->ActualComponentId_ = x.ActualComponentId_;
        this->ManufacturingProcessId_ = x.ManufacturingProcessId_;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
        this->ActualTransformId_ = x.ActualTransformId_;
        this->NotedEventIds_ = x.NotedEventIds_;
      }

      return *this;
    }

    FeatureMeasurementBaseType::
    ~FeatureMeasurementBaseType ()
    {
    }

    // ShapeFeatureMeasurementBaseType
    //

    ShapeFeatureMeasurementBaseType::
    ShapeFeatureMeasurementBaseType ()
    : ::xsd::qif30::FeatureMeasurementBaseType (),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this),
      ProxyMeasurementId_ (this)
    {
    }

    ShapeFeatureMeasurementBaseType::
    ShapeFeatureMeasurementBaseType (const id_type& id)
    : ::xsd::qif30::FeatureMeasurementBaseType (id),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this),
      ProxyMeasurementId_ (this)
    {
    }

    ShapeFeatureMeasurementBaseType::
    ShapeFeatureMeasurementBaseType (const ShapeFeatureMeasurementBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::FeatureMeasurementBaseType (x, f, c),
      PointList_ (x.PointList_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this),
      ProxyMeasurementId_ (x.ProxyMeasurementId_, f, this)
    {
    }

    ShapeFeatureMeasurementBaseType::
    ShapeFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::FeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      PointList_ (this),
      SubstituteFeatureAlgorithm_ (this),
      ProxyMeasurementId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ShapeFeatureMeasurementBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointList
        //
        if (n.name () == L"PointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (::std::move (r));
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == L"SubstituteFeatureAlgorithm" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (::std::move (r));
            continue;
          }
        }

        // ProxyMeasurementId
        //
        if (n.name () == L"ProxyMeasurementId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProxyMeasurementId_type > r (
            ProxyMeasurementId_traits::create (i, f, this));

          if (!this->ProxyMeasurementId_)
          {
            this->ProxyMeasurementId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ShapeFeatureMeasurementBaseType& ShapeFeatureMeasurementBaseType::
    operator= (const ShapeFeatureMeasurementBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureMeasurementBaseType& > (*this) = x;
        this->PointList_ = x.PointList_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
        this->ProxyMeasurementId_ = x.ProxyMeasurementId_;
      }

      return *this;
    }

    ShapeFeatureMeasurementBaseType::
    ~ShapeFeatureMeasurementBaseType ()
    {
    }

    // NonShapeFeatureMeasurementBaseType
    //

    NonShapeFeatureMeasurementBaseType::
    NonShapeFeatureMeasurementBaseType ()
    : ::xsd::qif30::FeatureMeasurementBaseType ()
    {
    }

    NonShapeFeatureMeasurementBaseType::
    NonShapeFeatureMeasurementBaseType (const id_type& id)
    : ::xsd::qif30::FeatureMeasurementBaseType (id)
    {
    }

    NonShapeFeatureMeasurementBaseType::
    NonShapeFeatureMeasurementBaseType (const NonShapeFeatureMeasurementBaseType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::FeatureMeasurementBaseType (x, f, c)
    {
    }

    NonShapeFeatureMeasurementBaseType::
    NonShapeFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::FeatureMeasurementBaseType (e, f, c)
    {
    }

    NonShapeFeatureMeasurementBaseType::
    ~NonShapeFeatureMeasurementBaseType ()
    {
    }

    // SetFeatureType
    //

    SetFeatureType::
    SetFeatureType ()
    : ::xml_schema::type ()
    {
    }

    SetFeatureType::
    SetFeatureType (const SetFeatureType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const ::std::wstring& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    SetFeatureType* SetFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SetFeatureType (*this, f, c);
    }

    SetFeatureType::
    ~SetFeatureType ()
    {
    }

    // MeasuredFeatureType
    //

    MeasuredFeatureType::
    MeasuredFeatureType ()
    : ::xml_schema::type (),
      PointList_ (this)
    {
    }

    MeasuredFeatureType::
    MeasuredFeatureType (const MeasuredFeatureType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointList_ (x.PointList_, f, this)
    {
    }

    MeasuredFeatureType::
    MeasuredFeatureType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointList
        //
        if (n.name () == L"PointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MeasuredFeatureType* MeasuredFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredFeatureType (*this, f, c);
    }

    MeasuredFeatureType& MeasuredFeatureType::
    operator= (const MeasuredFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointList_ = x.PointList_;
      }

      return *this;
    }

    MeasuredFeatureType::
    ~MeasuredFeatureType ()
    {
    }

    // ConstructionMethodBaseType
    //

    ConstructionMethodBaseType::
    ConstructionMethodBaseType ()
    : ::xml_schema::type (),
      NominalsCalculated_ (this)
    {
    }

    ConstructionMethodBaseType::
    ConstructionMethodBaseType (const ConstructionMethodBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NominalsCalculated_ (x.NominalsCalculated_, f, this)
    {
    }

    ConstructionMethodBaseType::
    ConstructionMethodBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NominalsCalculated_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConstructionMethodBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NominalsCalculated
        //
        if (n.name () == L"NominalsCalculated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->NominalsCalculated_)
          {
            this->NominalsCalculated_.set (NominalsCalculated_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    ConstructionMethodBaseType& ConstructionMethodBaseType::
    operator= (const ConstructionMethodBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NominalsCalculated_ = x.NominalsCalculated_;
      }

      return *this;
    }

    ConstructionMethodBaseType::
    ~ConstructionMethodBaseType ()
    {
    }

    // PointRangeType
    //

    PointRangeType::
    PointRangeType ()
    : ::xml_schema::type (),
      Start_ (this),
      Stop_ (this)
    {
    }

    PointRangeType::
    PointRangeType (const Start_type& Start,
                    const Stop_type& Stop)
    : ::xml_schema::type (),
      Start_ (Start, this),
      Stop_ (Stop, this)
    {
    }

    PointRangeType::
    PointRangeType (const PointRangeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Start_ (x.Start_, f, this),
      Stop_ (x.Stop_, f, this)
    {
    }

    PointRangeType::
    PointRangeType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Start_ (this),
      Stop_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointRangeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Start
        //
        if (n.name () == L"Start" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Start_type > r (
            Start_traits::create (i, f, this));

          if (!Start_.present ())
          {
            this->Start_.set (::std::move (r));
            continue;
          }
        }

        // Stop
        //
        if (n.name () == L"Stop" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Stop_type > r (
            Stop_traits::create (i, f, this));

          if (!Stop_.present ())
          {
            this->Stop_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Start_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Start",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Stop_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Stop",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointRangeType* PointRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointRangeType (*this, f, c);
    }

    PointRangeType& PointRangeType::
    operator= (const PointRangeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Start_ = x.Start_;
        this->Stop_ = x.Stop_;
      }

      return *this;
    }

    PointRangeType::
    ~PointRangeType ()
    {
    }

    // PointIndexType
    //

    const PointIndexType::All_type PointIndexType::All_default_value_ (
      L"All");

    PointIndexType::
    PointIndexType ()
    : ::xml_schema::type (),
      Single_ (this),
      Range_ (this),
      All_ (this)
    {
    }

    PointIndexType::
    PointIndexType (const PointIndexType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Single_ (x.Single_, f, this),
      Range_ (x.Range_, f, this),
      All_ (x.All_, f, this)
    {
    }

    PointIndexType::
    PointIndexType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Single_ (this),
      Range_ (this),
      All_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointIndexType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Single
        //
        if (n.name () == L"Single" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Single_type > r (
            Single_traits::create (i, f, this));

          if (!this->Single_)
          {
            this->Single_.set (::std::move (r));
            continue;
          }
        }

        // Range
        //
        if (n.name () == L"Range" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Range_type > r (
            Range_traits::create (i, f, this));

          if (!this->Range_)
          {
            this->Range_.set (::std::move (r));
            continue;
          }
        }

        // All
        //
        if (n.name () == L"All" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< All_type > r (
            All_traits::create (i, f, this));

          if (!this->All_)
          {
            this->All_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointIndexType* PointIndexType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointIndexType (*this, f, c);
    }

    PointIndexType& PointIndexType::
    operator= (const PointIndexType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Single_ = x.Single_;
        this->Range_ = x.Range_;
        this->All_ = x.All_;
      }

      return *this;
    }

    PointIndexType::
    ~PointIndexType ()
    {
    }

    // BaseFeaturePointSetType
    //

    BaseFeaturePointSetType::
    BaseFeaturePointSetType ()
    : ::xml_schema::type (),
      FeatureId_ (this),
      PointIndex_ (this),
      ReferencedComponent_ (this),
      SequenceNumber_ (this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const FeatureId_type& FeatureId,
                             const PointIndex_type& PointIndex,
                             const ReferencedComponent_type& ReferencedComponent,
                             const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      FeatureId_ (FeatureId, this),
      PointIndex_ (PointIndex, this),
      ReferencedComponent_ (ReferencedComponent, this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (::std::unique_ptr< FeatureId_type > FeatureId,
                             ::std::unique_ptr< PointIndex_type > PointIndex,
                             const ReferencedComponent_type& ReferencedComponent,
                             const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      FeatureId_ (std::move (FeatureId), this),
      PointIndex_ (std::move (PointIndex), this),
      ReferencedComponent_ (ReferencedComponent, this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const BaseFeaturePointSetType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureId_ (x.FeatureId_, f, this),
      PointIndex_ (x.PointIndex_, f, this),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureId_ (this),
      PointIndex_ (this),
      ReferencedComponent_ (this),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BaseFeaturePointSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureId
        //
        if (n.name () == L"FeatureId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureId_type > r (
            FeatureId_traits::create (i, f, this));

          if (!FeatureId_.present ())
          {
            this->FeatureId_.set (::std::move (r));
            continue;
          }
        }

        // PointIndex
        //
        if (n.name () == L"PointIndex" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointIndex_type > r (
            PointIndex_traits::create (i, f, this));

          if (!PointIndex_.present ())
          {
            this->PointIndex_.set (::std::move (r));
            continue;
          }
        }

        // ReferencedComponent
        //
        if (n.name () == L"ReferencedComponent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (::std::move (r));
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FeatureId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointIndex_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointIndex",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ReferencedComponent",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    BaseFeaturePointSetType* BaseFeaturePointSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BaseFeaturePointSetType (*this, f, c);
    }

    BaseFeaturePointSetType& BaseFeaturePointSetType::
    operator= (const BaseFeaturePointSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureId_ = x.FeatureId_;
        this->PointIndex_ = x.PointIndex_;
        this->ReferencedComponent_ = x.ReferencedComponent_;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    BaseFeaturePointSetType::
    ~BaseFeaturePointSetType ()
    {
    }

    // BaseFeaturePointListType
    //

    BaseFeaturePointListType::
    BaseFeaturePointListType ()
    : ::xml_schema::type (),
      BaseFeaturePointSet_ (this),
      n_ (this)
    {
    }

    BaseFeaturePointListType::
    BaseFeaturePointListType (const n_type& n)
    : ::xml_schema::type (),
      BaseFeaturePointSet_ (this),
      n_ (n, this)
    {
    }

    BaseFeaturePointListType::
    BaseFeaturePointListType (const BaseFeaturePointListType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BaseFeaturePointSet_ (x.BaseFeaturePointSet_, f, this),
      n_ (x.n_, f, this)
    {
    }

    BaseFeaturePointListType::
    BaseFeaturePointListType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointSet_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BaseFeaturePointListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointSet
        //
        if (n.name () == L"BaseFeaturePointSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointSet_type > r (
            BaseFeaturePointSet_traits::create (i, f, this));

          this->BaseFeaturePointSet_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    BaseFeaturePointListType* BaseFeaturePointListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BaseFeaturePointListType (*this, f, c);
    }

    BaseFeaturePointListType& BaseFeaturePointListType::
    operator= (const BaseFeaturePointListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BaseFeaturePointSet_ = x.BaseFeaturePointSet_;
        this->n_ = x.n_;
      }

      return *this;
    }

    BaseFeaturePointListType::
    ~BaseFeaturePointListType ()
    {
    }

    // TransformationReferenceType
    //

    TransformationReferenceType::
    TransformationReferenceType ()
    : ::xml_schema::type (),
      ReferencedComponent_ (this),
      CoordinateSystemId_ (this),
      SequenceNumber_ (this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const ReferencedComponent_type& ReferencedComponent,
                                 const CoordinateSystemId_type& CoordinateSystemId,
                                 const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, this),
      CoordinateSystemId_ (CoordinateSystemId, this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const ReferencedComponent_type& ReferencedComponent,
                                 ::std::unique_ptr< CoordinateSystemId_type > CoordinateSystemId,
                                 const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, this),
      CoordinateSystemId_ (std::move (CoordinateSystemId), this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const TransformationReferenceType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ReferencedComponent_ (this),
      CoordinateSystemId_ (this),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TransformationReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ReferencedComponent
        //
        if (n.name () == L"ReferencedComponent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (::std::move (r));
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == L"CoordinateSystemId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!CoordinateSystemId_.present ())
          {
            this->CoordinateSystemId_.set (::std::move (r));
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == L"SequenceNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SequenceNumber_type > r (
            SequenceNumber_traits::create (i, f, this));

          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ReferencedComponent",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CoordinateSystemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CoordinateSystemId",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SequenceNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TransformationReferenceType* TransformationReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformationReferenceType (*this, f, c);
    }

    TransformationReferenceType& TransformationReferenceType::
    operator= (const TransformationReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ReferencedComponent_ = x.ReferencedComponent_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    TransformationReferenceType::
    ~TransformationReferenceType ()
    {
    }

    // SurfaceFeatureItemBaseType
    //

    SurfaceFeatureItemBaseType::
    SurfaceFeatureItemBaseType ()
    : ::xsd::qif30::ShapeFeatureItemBaseType ()
    {
    }

    SurfaceFeatureItemBaseType::
    SurfaceFeatureItemBaseType (const id_type& id,
                                const FeatureNominalId_type& FeatureNominalId,
                                const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName)
    {
    }

    SurfaceFeatureItemBaseType::
    SurfaceFeatureItemBaseType (const id_type& id,
                                ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName)
    {
    }

    SurfaceFeatureItemBaseType::
    SurfaceFeatureItemBaseType (const SurfaceFeatureItemBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (x, f, c)
    {
    }

    SurfaceFeatureItemBaseType::
    SurfaceFeatureItemBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (e, f, c)
    {
    }

    SurfaceFeatureItemBaseType::
    ~SurfaceFeatureItemBaseType ()
    {
    }

    // SurfaceFeatureDefinitionBaseType
    //

    SurfaceFeatureDefinitionBaseType::
    SurfaceFeatureDefinitionBaseType ()
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType ()
    {
    }

    SurfaceFeatureDefinitionBaseType::
    SurfaceFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (id)
    {
    }

    SurfaceFeatureDefinitionBaseType::
    SurfaceFeatureDefinitionBaseType (const SurfaceFeatureDefinitionBaseType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (x, f, c)
    {
    }

    SurfaceFeatureDefinitionBaseType::
    SurfaceFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (e, f, c)
    {
    }

    SurfaceFeatureDefinitionBaseType::
    ~SurfaceFeatureDefinitionBaseType ()
    {
    }

    // SurfaceFeatureNominalBaseType
    //

    SurfaceFeatureNominalBaseType::
    SurfaceFeatureNominalBaseType ()
    : ::xsd::qif30::ShapeFeatureNominalBaseType ()
    {
    }

    SurfaceFeatureNominalBaseType::
    SurfaceFeatureNominalBaseType (const id_type& id,
                                   const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 FeatureDefinitionId)
    {
    }

    SurfaceFeatureNominalBaseType::
    SurfaceFeatureNominalBaseType (const id_type& id,
                                   ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId))
    {
    }

    SurfaceFeatureNominalBaseType::
    SurfaceFeatureNominalBaseType (const SurfaceFeatureNominalBaseType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (x, f, c)
    {
    }

    SurfaceFeatureNominalBaseType::
    SurfaceFeatureNominalBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (e, f, c)
    {
    }

    SurfaceFeatureNominalBaseType::
    ~SurfaceFeatureNominalBaseType ()
    {
    }

    // SurfaceFeatureMeasurementBaseType
    //

    SurfaceFeatureMeasurementBaseType::
    SurfaceFeatureMeasurementBaseType ()
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType ()
    {
    }

    SurfaceFeatureMeasurementBaseType::
    SurfaceFeatureMeasurementBaseType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (id)
    {
    }

    SurfaceFeatureMeasurementBaseType::
    SurfaceFeatureMeasurementBaseType (const SurfaceFeatureMeasurementBaseType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (x, f, c)
    {
    }

    SurfaceFeatureMeasurementBaseType::
    SurfaceFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (e, f, c)
    {
    }

    SurfaceFeatureMeasurementBaseType::
    ~SurfaceFeatureMeasurementBaseType ()
    {
    }

    // CurveFeatureItemBaseType
    //

    CurveFeatureItemBaseType::
    CurveFeatureItemBaseType ()
    : ::xsd::qif30::ShapeFeatureItemBaseType ()
    {
    }

    CurveFeatureItemBaseType::
    CurveFeatureItemBaseType (const id_type& id,
                              const FeatureNominalId_type& FeatureNominalId,
                              const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName)
    {
    }

    CurveFeatureItemBaseType::
    CurveFeatureItemBaseType (const id_type& id,
                              ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                              const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName)
    {
    }

    CurveFeatureItemBaseType::
    CurveFeatureItemBaseType (const CurveFeatureItemBaseType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (x, f, c)
    {
    }

    CurveFeatureItemBaseType::
    CurveFeatureItemBaseType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (e, f, c)
    {
    }

    CurveFeatureItemBaseType::
    ~CurveFeatureItemBaseType ()
    {
    }

    // CurveFeatureDefinitionBaseType
    //

    CurveFeatureDefinitionBaseType::
    CurveFeatureDefinitionBaseType ()
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType ()
    {
    }

    CurveFeatureDefinitionBaseType::
    CurveFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (id)
    {
    }

    CurveFeatureDefinitionBaseType::
    CurveFeatureDefinitionBaseType (const CurveFeatureDefinitionBaseType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (x, f, c)
    {
    }

    CurveFeatureDefinitionBaseType::
    CurveFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (e, f, c)
    {
    }

    CurveFeatureDefinitionBaseType::
    ~CurveFeatureDefinitionBaseType ()
    {
    }

    // CurveFeatureNominalBaseType
    //

    CurveFeatureNominalBaseType::
    CurveFeatureNominalBaseType ()
    : ::xsd::qif30::ShapeFeatureNominalBaseType (),
      SurfaceFeatureNominalId_ (this)
    {
    }

    CurveFeatureNominalBaseType::
    CurveFeatureNominalBaseType (const id_type& id,
                                 const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      SurfaceFeatureNominalId_ (this)
    {
    }

    CurveFeatureNominalBaseType::
    CurveFeatureNominalBaseType (const id_type& id,
                                 ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      SurfaceFeatureNominalId_ (this)
    {
    }

    CurveFeatureNominalBaseType::
    CurveFeatureNominalBaseType (const CurveFeatureNominalBaseType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (x, f, c),
      SurfaceFeatureNominalId_ (x.SurfaceFeatureNominalId_, f, this)
    {
    }

    CurveFeatureNominalBaseType::
    CurveFeatureNominalBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeatureNominalId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CurveFeatureNominalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ShapeFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeatureNominalId
        //
        if (n.name () == L"SurfaceFeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeatureNominalId_type > r (
            SurfaceFeatureNominalId_traits::create (i, f, this));

          if (!this->SurfaceFeatureNominalId_)
          {
            this->SurfaceFeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CurveFeatureNominalBaseType& CurveFeatureNominalBaseType::
    operator= (const CurveFeatureNominalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ShapeFeatureNominalBaseType& > (*this) = x;
        this->SurfaceFeatureNominalId_ = x.SurfaceFeatureNominalId_;
      }

      return *this;
    }

    CurveFeatureNominalBaseType::
    ~CurveFeatureNominalBaseType ()
    {
    }

    // CurveFeatureMeasurementBaseType
    //

    CurveFeatureMeasurementBaseType::
    CurveFeatureMeasurementBaseType ()
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType ()
    {
    }

    CurveFeatureMeasurementBaseType::
    CurveFeatureMeasurementBaseType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (id)
    {
    }

    CurveFeatureMeasurementBaseType::
    CurveFeatureMeasurementBaseType (const CurveFeatureMeasurementBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (x, f, c)
    {
    }

    CurveFeatureMeasurementBaseType::
    CurveFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (e, f, c)
    {
    }

    CurveFeatureMeasurementBaseType::
    ~CurveFeatureMeasurementBaseType ()
    {
    }

    // PointFeatureItemBaseType
    //

    PointFeatureItemBaseType::
    PointFeatureItemBaseType ()
    : ::xsd::qif30::ShapeFeatureItemBaseType ()
    {
    }

    PointFeatureItemBaseType::
    PointFeatureItemBaseType (const id_type& id,
                              const FeatureNominalId_type& FeatureNominalId,
                              const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName)
    {
    }

    PointFeatureItemBaseType::
    PointFeatureItemBaseType (const id_type& id,
                              ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                              const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName)
    {
    }

    PointFeatureItemBaseType::
    PointFeatureItemBaseType (const PointFeatureItemBaseType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (x, f, c)
    {
    }

    PointFeatureItemBaseType::
    PointFeatureItemBaseType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (e, f, c)
    {
    }

    PointFeatureItemBaseType::
    ~PointFeatureItemBaseType ()
    {
    }

    // PointFeatureDefinitionBaseType
    //

    PointFeatureDefinitionBaseType::
    PointFeatureDefinitionBaseType ()
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType ()
    {
    }

    PointFeatureDefinitionBaseType::
    PointFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (id)
    {
    }

    PointFeatureDefinitionBaseType::
    PointFeatureDefinitionBaseType (const PointFeatureDefinitionBaseType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (x, f, c)
    {
    }

    PointFeatureDefinitionBaseType::
    PointFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (e, f, c)
    {
    }

    PointFeatureDefinitionBaseType::
    ~PointFeatureDefinitionBaseType ()
    {
    }

    // PointFeatureNominalBaseType
    //

    PointFeatureNominalBaseType::
    PointFeatureNominalBaseType ()
    : ::xsd::qif30::ShapeFeatureNominalBaseType (),
      SurfaceFeatureNominalId_ (this),
      CurveFeatureNominalId_ (this)
    {
    }

    PointFeatureNominalBaseType::
    PointFeatureNominalBaseType (const id_type& id,
                                 const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      SurfaceFeatureNominalId_ (this),
      CurveFeatureNominalId_ (this)
    {
    }

    PointFeatureNominalBaseType::
    PointFeatureNominalBaseType (const id_type& id,
                                 ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      SurfaceFeatureNominalId_ (this),
      CurveFeatureNominalId_ (this)
    {
    }

    PointFeatureNominalBaseType::
    PointFeatureNominalBaseType (const PointFeatureNominalBaseType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (x, f, c),
      SurfaceFeatureNominalId_ (x.SurfaceFeatureNominalId_, f, this),
      CurveFeatureNominalId_ (x.CurveFeatureNominalId_, f, this)
    {
    }

    PointFeatureNominalBaseType::
    PointFeatureNominalBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeatureNominalId_ (this),
      CurveFeatureNominalId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointFeatureNominalBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ShapeFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeatureNominalId
        //
        if (n.name () == L"SurfaceFeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeatureNominalId_type > r (
            SurfaceFeatureNominalId_traits::create (i, f, this));

          if (!this->SurfaceFeatureNominalId_)
          {
            this->SurfaceFeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        // CurveFeatureNominalId
        //
        if (n.name () == L"CurveFeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveFeatureNominalId_type > r (
            CurveFeatureNominalId_traits::create (i, f, this));

          if (!this->CurveFeatureNominalId_)
          {
            this->CurveFeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointFeatureNominalBaseType& PointFeatureNominalBaseType::
    operator= (const PointFeatureNominalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ShapeFeatureNominalBaseType& > (*this) = x;
        this->SurfaceFeatureNominalId_ = x.SurfaceFeatureNominalId_;
        this->CurveFeatureNominalId_ = x.CurveFeatureNominalId_;
      }

      return *this;
    }

    PointFeatureNominalBaseType::
    ~PointFeatureNominalBaseType ()
    {
    }

    // PointFeatureMeasurementBaseType
    //

    PointFeatureMeasurementBaseType::
    PointFeatureMeasurementBaseType ()
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType ()
    {
    }

    PointFeatureMeasurementBaseType::
    PointFeatureMeasurementBaseType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (id)
    {
    }

    PointFeatureMeasurementBaseType::
    PointFeatureMeasurementBaseType (const PointFeatureMeasurementBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (x, f, c)
    {
    }

    PointFeatureMeasurementBaseType::
    PointFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (e, f, c)
    {
    }

    PointFeatureMeasurementBaseType::
    ~PointFeatureMeasurementBaseType ()
    {
    }

    // SpecifiedFeatureItemBaseType
    //

    SpecifiedFeatureItemBaseType::
    SpecifiedFeatureItemBaseType ()
    : ::xsd::qif30::ShapeFeatureItemBaseType ()
    {
    }

    SpecifiedFeatureItemBaseType::
    SpecifiedFeatureItemBaseType (const id_type& id,
                                  const FeatureNominalId_type& FeatureNominalId,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName)
    {
    }

    SpecifiedFeatureItemBaseType::
    SpecifiedFeatureItemBaseType (const id_type& id,
                                  ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName)
    {
    }

    SpecifiedFeatureItemBaseType::
    SpecifiedFeatureItemBaseType (const SpecifiedFeatureItemBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (x, f, c)
    {
    }

    SpecifiedFeatureItemBaseType::
    SpecifiedFeatureItemBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (e, f, c)
    {
    }

    SpecifiedFeatureItemBaseType::
    ~SpecifiedFeatureItemBaseType ()
    {
    }

    // SpecifiedFeatureDefinitionBaseType
    //

    SpecifiedFeatureDefinitionBaseType::
    SpecifiedFeatureDefinitionBaseType ()
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType ()
    {
    }

    SpecifiedFeatureDefinitionBaseType::
    SpecifiedFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (id)
    {
    }

    SpecifiedFeatureDefinitionBaseType::
    SpecifiedFeatureDefinitionBaseType (const SpecifiedFeatureDefinitionBaseType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (x, f, c)
    {
    }

    SpecifiedFeatureDefinitionBaseType::
    SpecifiedFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (e, f, c)
    {
    }

    SpecifiedFeatureDefinitionBaseType::
    ~SpecifiedFeatureDefinitionBaseType ()
    {
    }

    // SpecifiedFeatureNominalBaseType
    //

    SpecifiedFeatureNominalBaseType::
    SpecifiedFeatureNominalBaseType ()
    : ::xsd::qif30::ShapeFeatureNominalBaseType ()
    {
    }

    SpecifiedFeatureNominalBaseType::
    SpecifiedFeatureNominalBaseType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 FeatureDefinitionId)
    {
    }

    SpecifiedFeatureNominalBaseType::
    SpecifiedFeatureNominalBaseType (const id_type& id,
                                     ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId))
    {
    }

    SpecifiedFeatureNominalBaseType::
    SpecifiedFeatureNominalBaseType (const SpecifiedFeatureNominalBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (x, f, c)
    {
    }

    SpecifiedFeatureNominalBaseType::
    SpecifiedFeatureNominalBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (e, f, c)
    {
    }

    SpecifiedFeatureNominalBaseType::
    ~SpecifiedFeatureNominalBaseType ()
    {
    }

    // SpecifiedFeatureMeasurementBaseType
    //

    SpecifiedFeatureMeasurementBaseType::
    SpecifiedFeatureMeasurementBaseType ()
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType ()
    {
    }

    SpecifiedFeatureMeasurementBaseType::
    SpecifiedFeatureMeasurementBaseType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (id)
    {
    }

    SpecifiedFeatureMeasurementBaseType::
    SpecifiedFeatureMeasurementBaseType (const SpecifiedFeatureMeasurementBaseType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (x, f, c)
    {
    }

    SpecifiedFeatureMeasurementBaseType::
    SpecifiedFeatureMeasurementBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (e, f, c)
    {
    }

    SpecifiedFeatureMeasurementBaseType::
    ~SpecifiedFeatureMeasurementBaseType ()
    {
    }

    // CircleConstructionMethodType
    //

    CircleConstructionMethodType::
    CircleConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Tangent_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      FromCone_ (this),
      FromScan_ (this)
    {
    }

    CircleConstructionMethodType::
    CircleConstructionMethodType (const CircleConstructionMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Tangent_ (x.Tangent_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCone_ (x.FromCone_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    CircleConstructionMethodType::
    CircleConstructionMethodType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Tangent_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      FromCone_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == L"Intersection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (::std::move (r));
            continue;
          }
        }

        // Projection
        //
        if (n.name () == L"Projection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Tangent
        //
        if (n.name () == L"Tangent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Tangent_type > r (
            Tangent_traits::create (i, f, this));

          if (!this->Tangent_)
          {
            this->Tangent_.set (::std::move (r));
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == L"TangentThrough" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromCone
        //
        if (n.name () == L"FromCone" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromCone_type > r (
            FromCone_traits::create (i, f, this));

          if (!this->FromCone_)
          {
            this->FromCone_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircleConstructionMethodType* CircleConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleConstructionMethodType (*this, f, c);
    }

    CircleConstructionMethodType& CircleConstructionMethodType::
    operator= (const CircleConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Tangent_ = x.Tangent_;
        this->TangentThrough_ = x.TangentThrough_;
        this->Transform_ = x.Transform_;
        this->FromCone_ = x.FromCone_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    CircleConstructionMethodType::
    ~CircleConstructionMethodType ()
    {
    }

    // CircleBestFitType
    //

    CircleBestFitType::
    CircleBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    CircleBestFitType::
    CircleBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    CircleBestFitType::
    CircleBestFitType (const CircleBestFitType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CircleBestFitType::
    CircleBestFitType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CircleBestFitType* CircleBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleBestFitType (*this, f, c);
    }

    CircleBestFitType& CircleBestFitType::
    operator= (const CircleBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CircleBestFitType::
    ~CircleBestFitType ()
    {
    }

    // CircleRecompType
    //

    CircleRecompType::
    CircleRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    CircleRecompType::
    CircleRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CircleRecompType::
    CircleRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    CircleRecompType::
    CircleRecompType (const CircleRecompType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CircleRecompType::
    CircleRecompType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleRecompType* CircleRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleRecompType (*this, f, c);
    }

    CircleRecompType& CircleRecompType::
    operator= (const CircleRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    CircleRecompType::
    ~CircleRecompType ()
    {
    }

    // CircleIntersectionType
    //

    CircleIntersectionType::
    CircleIntersectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionFeature_ (this)
    {
    }

    CircleIntersectionType::
    CircleIntersectionType (const CircleIntersectionType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    CircleIntersectionType::
    CircleIntersectionType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionFeature
        //
        if (n.name () == L"IntersectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          this->IntersectionFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    CircleIntersectionType* CircleIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleIntersectionType (*this, f, c);
    }

    CircleIntersectionType& CircleIntersectionType::
    operator= (const CircleIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    CircleIntersectionType::
    ~CircleIntersectionType ()
    {
    }

    // CircleProjectionType
    //

    CircleProjectionType::
    CircleProjectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionCircle_ (this),
      ProjectionPlane_ (this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (const ProjectionCircle_type& ProjectionCircle,
                          const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionCircle_ (ProjectionCircle, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (::std::unique_ptr< ProjectionCircle_type > ProjectionCircle,
                          ::std::unique_ptr< ProjectionPlane_type > ProjectionPlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionCircle_ (std::move (ProjectionCircle), this),
      ProjectionPlane_ (std::move (ProjectionPlane), this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (const CircleProjectionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ProjectionCircle_ (x.ProjectionCircle_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionCircle_ (this),
      ProjectionPlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleProjectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProjectionCircle
        //
        if (n.name () == L"ProjectionCircle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionCircle_type > r (
            ProjectionCircle_traits::create (i, f, this));

          if (!ProjectionCircle_.present ())
          {
            this->ProjectionCircle_.set (::std::move (r));
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == L"ProjectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProjectionCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionCircle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleProjectionType* CircleProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleProjectionType (*this, f, c);
    }

    CircleProjectionType& CircleProjectionType::
    operator= (const CircleProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionCircle_ = x.ProjectionCircle_;
        this->ProjectionPlane_ = x.ProjectionPlane_;
      }

      return *this;
    }

    CircleProjectionType::
    ~CircleProjectionType ()
    {
    }

    // CircleCopyType
    //

    CircleCopyType::
    CircleCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCircle_ (this)
    {
    }

    CircleCopyType::
    CircleCopyType (const BaseCircle_type& BaseCircle)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, this)
    {
    }

    CircleCopyType::
    CircleCopyType (::std::unique_ptr< BaseCircle_type > BaseCircle)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCircle_ (std::move (BaseCircle), this)
    {
    }

    CircleCopyType::
    CircleCopyType (const CircleCopyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCircle_ (x.BaseCircle_, f, this)
    {
    }

    CircleCopyType::
    CircleCopyType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCircle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCircle
        //
        if (n.name () == L"BaseCircle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCircle_type > r (
            BaseCircle_traits::create (i, f, this));

          if (!BaseCircle_.present ())
          {
            this->BaseCircle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCircle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleCopyType* CircleCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCopyType (*this, f, c);
    }

    CircleCopyType& CircleCopyType::
    operator= (const CircleCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCircle_ = x.BaseCircle_;
      }

      return *this;
    }

    CircleCopyType::
    ~CircleCopyType ()
    {
    }

    // CircleCastType
    //

    CircleCastType::
    CircleCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    CircleCastType::
    CircleCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CircleCastType::
    CircleCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    CircleCastType::
    CircleCastType (const CircleCastType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CircleCastType::
    CircleCastType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleCastType* CircleCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCastType (*this, f, c);
    }

    CircleCastType& CircleCastType::
    operator= (const CircleCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CircleCastType::
    ~CircleCastType ()
    {
    }

    // CircleTangentType
    //

    CircleTangentType::
    CircleTangentType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (this)
    {
    }

    CircleTangentType::
    CircleTangentType (const CircleTangentType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this)
    {
    }

    CircleTangentType::
    CircleTangentType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleTangentType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TangentFeature
        //
        if (n.name () == L"TangentFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          this->TangentFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    CircleTangentType* CircleTangentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTangentType (*this, f, c);
    }

    CircleTangentType& CircleTangentType::
    operator= (const CircleTangentType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->TangentFeature_ = x.TangentFeature_;
      }

      return *this;
    }

    CircleTangentType::
    ~CircleTangentType ()
    {
    }

    // CircleTangentThroughType
    //

    CircleTangentThroughType::
    CircleTangentThroughType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (const TangentFeature_type& TangentFeature,
                              const PointFeature_type& PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (::std::unique_ptr< TangentFeature_type > TangentFeature,
                              ::std::unique_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (std::move (TangentFeature), this),
      PointFeature_ (std::move (PointFeature), this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (const CircleTangentThroughType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TangentFeature
        //
        if (n.name () == L"TangentFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (::std::move (r));
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == L"PointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TangentFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleTangentThroughType* CircleTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTangentThroughType (*this, f, c);
    }

    CircleTangentThroughType& CircleTangentThroughType::
    operator= (const CircleTangentThroughType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->TangentFeature_ = x.TangentFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    CircleTangentThroughType::
    ~CircleTangentThroughType ()
    {
    }

    // CircleTransformType
    //

    CircleTransformType::
    CircleTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCircle_ (this),
      Transformation_ (this)
    {
    }

    CircleTransformType::
    CircleTransformType (const BaseCircle_type& BaseCircle,
                         const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, this),
      Transformation_ (Transformation, this)
    {
    }

    CircleTransformType::
    CircleTransformType (::std::unique_ptr< BaseCircle_type > BaseCircle,
                         ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCircle_ (std::move (BaseCircle), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    CircleTransformType::
    CircleTransformType (const CircleTransformType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCircle_ (x.BaseCircle_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CircleTransformType::
    CircleTransformType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCircle_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCircle
        //
        if (n.name () == L"BaseCircle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCircle_type > r (
            BaseCircle_traits::create (i, f, this));

          if (!BaseCircle_.present ())
          {
            this->BaseCircle_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCircle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleTransformType* CircleTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTransformType (*this, f, c);
    }

    CircleTransformType& CircleTransformType::
    operator= (const CircleTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCircle_ = x.BaseCircle_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    CircleTransformType::
    ~CircleTransformType ()
    {
    }

    // CircleFromConeType
    //

    CircleFromConeType::
    CircleFromConeType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      Diameter_ (this),
      Distance_ (this)
    {
    }

    CircleFromConeType::
    CircleFromConeType (const CircleFromConeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      Distance_ (x.Distance_, f, this)
    {
    }

    CircleFromConeType::
    CircleFromConeType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      Distance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleFromConeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Distance
        //
        if (n.name () == L"Distance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!this->Distance_)
          {
            this->Distance_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircleFromConeType* CircleFromConeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFromConeType (*this, f, c);
    }

    CircleFromConeType& CircleFromConeType::
    operator= (const CircleFromConeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->Distance_ = x.Distance_;
      }

      return *this;
    }

    CircleFromConeType::
    ~CircleFromConeType ()
    {
    }

    // CircleFromScanType
    //

    CircleFromScanType::
    CircleFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (const SurfaceFeature_type& SurfaceFeature,
                        const SearchRadius_type& SearchRadius,
                        const Depth_type& Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                        ::std::unique_ptr< SearchRadius_type > SearchRadius,
                        ::std::unique_ptr< Depth_type > Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      Depth_ (std::move (Depth), this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (const CircleFromScanType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Depth",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleFromScanType* CircleFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFromScanType (*this, f, c);
    }

    CircleFromScanType& CircleFromScanType::
    operator= (const CircleFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    CircleFromScanType::
    ~CircleFromScanType ()
    {
    }

    // CircleCheckedType
    //

    CircleCheckedType::
    CircleCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    CircleCheckedType::
    CircleCheckedType (const CircleCheckedType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CircleCheckedType::
    CircleCheckedType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircleCheckedType* CircleCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCheckedType (*this, f, c);
    }

    CircleCheckedType& CircleCheckedType::
    operator= (const CircleCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CircleCheckedType::
    ~CircleCheckedType ()
    {
    }

    // CircleCheckedFeatureType
    //

    CircleCheckedFeatureType::
    CircleCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    CircleCheckedFeatureType::
    CircleCheckedFeatureType (const CircleCheckedFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CircleCheckedFeatureType::
    CircleCheckedFeatureType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircleCheckedFeatureType* CircleCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCheckedFeatureType (*this, f, c);
    }

    CircleCheckedFeatureType& CircleCheckedFeatureType::
    operator= (const CircleCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    CircleCheckedFeatureType::
    ~CircleCheckedFeatureType ()
    {
    }

    // CircleMeasurementDeterminationType
    //

    CircleMeasurementDeterminationType::
    CircleMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    CircleMeasurementDeterminationType::
    CircleMeasurementDeterminationType (const CircleMeasurementDeterminationType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CircleMeasurementDeterminationType::
    CircleMeasurementDeterminationType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircleMeasurementDeterminationType* CircleMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleMeasurementDeterminationType (*this, f, c);
    }

    CircleMeasurementDeterminationType& CircleMeasurementDeterminationType::
    operator= (const CircleMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    CircleMeasurementDeterminationType::
    ~CircleMeasurementDeterminationType ()
    {
    }

    // CircleFeatureItemType
    //

    CircleFeatureItemType::
    CircleFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const id_type& id,
                           const FeatureNominalId_type& FeatureNominalId,
                           const FeatureName_type& FeatureName,
                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const id_type& id,
                           ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                           const FeatureName_type& FeatureName,
                           ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const CircleFeatureItemType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleFeatureItemType* CircleFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureItemType (*this, f, c);
    }

    CircleFeatureItemType& CircleFeatureItemType::
    operator= (const CircleFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    CircleFeatureItemType::
    ~CircleFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircleFeatureItemType >
    _xsd_CircleFeatureItemType_type_factory_init (
      L"CircleFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // CircleFeatureDefinitionType
    //

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 const Diameter_type& Diameter)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 ::std::unique_ptr< Diameter_type > Diameter)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const CircleFeatureDefinitionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleFeatureDefinitionType* CircleFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureDefinitionType (*this, f, c);
    }

    CircleFeatureDefinitionType& CircleFeatureDefinitionType::
    operator= (const CircleFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
      }

      return *this;
    }

    CircleFeatureDefinitionType::
    ~CircleFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircleFeatureDefinitionType >
    _xsd_CircleFeatureDefinitionType_type_factory_init (
      L"CircleFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // CircleFeatureNominalType
    //

    CircleFeatureNominalType::
    CircleFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      Location_ (this),
      Normal_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              const Location_type& Location,
                              const Normal_type& Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const id_type& id,
                              ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                              ::std::unique_ptr< Location_type > Location,
                              ::std::unique_ptr< Normal_type > Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      Normal_ (std::move (Normal), this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const CircleFeatureNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircleFeatureNominalType* CircleFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureNominalType (*this, f, c);
    }

    CircleFeatureNominalType& CircleFeatureNominalType::
    operator= (const CircleFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->Sweep_ = x.Sweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CircleFeatureNominalType::
    ~CircleFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircleFeatureNominalType >
    _xsd_CircleFeatureNominalType_type_factory_init (
      L"CircleFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // CircleFeatureMeasurementType
    //

    CircleFeatureMeasurementType::
    CircleFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      Location_ (this),
      Normal_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Form_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this)
    {
    }

    CircleFeatureMeasurementType::
    CircleFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      Location_ (this),
      Normal_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Form_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this)
    {
    }

    CircleFeatureMeasurementType::
    CircleFeatureMeasurementType (const CircleFeatureMeasurementType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      Form_ (x.Form_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this)
    {
    }

    CircleFeatureMeasurementType::
    CircleFeatureMeasurementType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Form_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircleFeatureMeasurementType* CircleFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureMeasurementType (*this, f, c);
    }

    CircleFeatureMeasurementType& CircleFeatureMeasurementType::
    operator= (const CircleFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->Form_ = x.Form_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
      }

      return *this;
    }

    CircleFeatureMeasurementType::
    ~CircleFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircleFeatureMeasurementType >
    _xsd_CircleFeatureMeasurementType_type_factory_init (
      L"CircleFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // CircularArcConstructionMethodType
    //

    CircularArcConstructionMethodType::
    CircularArcConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Intersection_ (this),
      Recompensated_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this),
      Extract_ (this)
    {
    }

    CircularArcConstructionMethodType::
    CircularArcConstructionMethodType (const CircularArcConstructionMethodType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    CircularArcConstructionMethodType::
    CircularArcConstructionMethodType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Intersection_ (this),
      Recompensated_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this),
      Extract_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == L"Intersection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Projection
        //
        if (n.name () == L"Projection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        // Extract
        //
        if (n.name () == L"Extract" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircularArcConstructionMethodType* CircularArcConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcConstructionMethodType (*this, f, c);
    }

    CircularArcConstructionMethodType& CircularArcConstructionMethodType::
    operator= (const CircularArcConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Intersection_ = x.Intersection_;
        this->Recompensated_ = x.Recompensated_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
        this->Extract_ = x.Extract_;
      }

      return *this;
    }

    CircularArcConstructionMethodType::
    ~CircularArcConstructionMethodType ()
    {
    }

    // CircularArcBestFitType
    //

    CircularArcBestFitType::
    CircularArcBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    CircularArcBestFitType::
    CircularArcBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    CircularArcBestFitType::
    CircularArcBestFitType (const CircularArcBestFitType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CircularArcBestFitType::
    CircularArcBestFitType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircularArcBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CircularArcBestFitType* CircularArcBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcBestFitType (*this, f, c);
    }

    CircularArcBestFitType& CircularArcBestFitType::
    operator= (const CircularArcBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CircularArcBestFitType::
    ~CircularArcBestFitType ()
    {
    }

    // CircularArcRecompType
    //

    CircularArcRecompType::
    CircularArcRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    CircularArcRecompType::
    CircularArcRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CircularArcRecompType::
    CircularArcRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    CircularArcRecompType::
    CircularArcRecompType (const CircularArcRecompType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CircularArcRecompType::
    CircularArcRecompType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcRecompType* CircularArcRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcRecompType (*this, f, c);
    }

    CircularArcRecompType& CircularArcRecompType::
    operator= (const CircularArcRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    CircularArcRecompType::
    ~CircularArcRecompType ()
    {
    }

    // CircularArcProjectionType
    //

    CircularArcProjectionType::
    CircularArcProjectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionArc_ (this),
      ProjectionPlane_ (this)
    {
    }

    CircularArcProjectionType::
    CircularArcProjectionType (const ProjectionArc_type& ProjectionArc,
                               const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionArc_ (ProjectionArc, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    CircularArcProjectionType::
    CircularArcProjectionType (::std::unique_ptr< ProjectionArc_type > ProjectionArc,
                               ::std::unique_ptr< ProjectionPlane_type > ProjectionPlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionArc_ (std::move (ProjectionArc), this),
      ProjectionPlane_ (std::move (ProjectionPlane), this)
    {
    }

    CircularArcProjectionType::
    CircularArcProjectionType (const CircularArcProjectionType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ProjectionArc_ (x.ProjectionArc_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    CircularArcProjectionType::
    CircularArcProjectionType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionArc_ (this),
      ProjectionPlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcProjectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProjectionArc
        //
        if (n.name () == L"ProjectionArc" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionArc_type > r (
            ProjectionArc_traits::create (i, f, this));

          if (!ProjectionArc_.present ())
          {
            this->ProjectionArc_.set (::std::move (r));
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == L"ProjectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProjectionArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionArc",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcProjectionType* CircularArcProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcProjectionType (*this, f, c);
    }

    CircularArcProjectionType& CircularArcProjectionType::
    operator= (const CircularArcProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionArc_ = x.ProjectionArc_;
        this->ProjectionPlane_ = x.ProjectionPlane_;
      }

      return *this;
    }

    CircularArcProjectionType::
    ~CircularArcProjectionType ()
    {
    }

    // CircularArcCopyType
    //

    CircularArcCopyType::
    CircularArcCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseArc_ (this)
    {
    }

    CircularArcCopyType::
    CircularArcCopyType (const BaseArc_type& BaseArc)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, this)
    {
    }

    CircularArcCopyType::
    CircularArcCopyType (::std::unique_ptr< BaseArc_type > BaseArc)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseArc_ (std::move (BaseArc), this)
    {
    }

    CircularArcCopyType::
    CircularArcCopyType (const CircularArcCopyType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseArc_ (x.BaseArc_, f, this)
    {
    }

    CircularArcCopyType::
    CircularArcCopyType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseArc_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseArc
        //
        if (n.name () == L"BaseArc" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseArc_type > r (
            BaseArc_traits::create (i, f, this));

          if (!BaseArc_.present ())
          {
            this->BaseArc_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseArc",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcCopyType* CircularArcCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcCopyType (*this, f, c);
    }

    CircularArcCopyType& CircularArcCopyType::
    operator= (const CircularArcCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseArc_ = x.BaseArc_;
      }

      return *this;
    }

    CircularArcCopyType::
    ~CircularArcCopyType ()
    {
    }

    // CircularArcCastType
    //

    CircularArcCastType::
    CircularArcCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    CircularArcCastType::
    CircularArcCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CircularArcCastType::
    CircularArcCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    CircularArcCastType::
    CircularArcCastType (const CircularArcCastType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CircularArcCastType::
    CircularArcCastType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcCastType* CircularArcCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcCastType (*this, f, c);
    }

    CircularArcCastType& CircularArcCastType::
    operator= (const CircularArcCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CircularArcCastType::
    ~CircularArcCastType ()
    {
    }

    // CircularArcTransformType
    //

    CircularArcTransformType::
    CircularArcTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseArc_ (this),
      Transformation_ (this)
    {
    }

    CircularArcTransformType::
    CircularArcTransformType (const BaseArc_type& BaseArc,
                              const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, this),
      Transformation_ (Transformation, this)
    {
    }

    CircularArcTransformType::
    CircularArcTransformType (::std::unique_ptr< BaseArc_type > BaseArc,
                              ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseArc_ (std::move (BaseArc), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    CircularArcTransformType::
    CircularArcTransformType (const CircularArcTransformType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseArc_ (x.BaseArc_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CircularArcTransformType::
    CircularArcTransformType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseArc_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseArc
        //
        if (n.name () == L"BaseArc" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseArc_type > r (
            BaseArc_traits::create (i, f, this));

          if (!BaseArc_.present ())
          {
            this->BaseArc_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseArc",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcTransformType* CircularArcTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcTransformType (*this, f, c);
    }

    CircularArcTransformType& CircularArcTransformType::
    operator= (const CircularArcTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseArc_ = x.BaseArc_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    CircularArcTransformType::
    ~CircularArcTransformType ()
    {
    }

    // CircularArcFromScanType
    //

    CircularArcFromScanType::
    CircularArcFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
    }

    CircularArcFromScanType::
    CircularArcFromScanType (const SurfaceFeature_type& SurfaceFeature,
                             const SearchRadius_type& SearchRadius,
                             const Depth_type& Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    CircularArcFromScanType::
    CircularArcFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                             ::std::unique_ptr< SearchRadius_type > SearchRadius,
                             ::std::unique_ptr< Depth_type > Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      Depth_ (std::move (Depth), this)
    {
    }

    CircularArcFromScanType::
    CircularArcFromScanType (const CircularArcFromScanType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    CircularArcFromScanType::
    CircularArcFromScanType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Depth",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcFromScanType* CircularArcFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcFromScanType (*this, f, c);
    }

    CircularArcFromScanType& CircularArcFromScanType::
    operator= (const CircularArcFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    CircularArcFromScanType::
    ~CircularArcFromScanType ()
    {
    }

    // CircularArcIntersectionType
    //

    CircularArcIntersectionType::
    CircularArcIntersectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionFeature_ (this)
    {
    }

    CircularArcIntersectionType::
    CircularArcIntersectionType (const CircularArcIntersectionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    CircularArcIntersectionType::
    CircularArcIntersectionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionFeature
        //
        if (n.name () == L"IntersectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          this->IntersectionFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    CircularArcIntersectionType* CircularArcIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcIntersectionType (*this, f, c);
    }

    CircularArcIntersectionType& CircularArcIntersectionType::
    operator= (const CircularArcIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    CircularArcIntersectionType::
    ~CircularArcIntersectionType ()
    {
    }

    // CircularArcExtractType
    //

    CircularArcExtractType::
    CircularArcExtractType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (this)
    {
    }

    CircularArcExtractType::
    CircularArcExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    CircularArcExtractType::
    CircularArcExtractType (::std::unique_ptr< CurveFeature_type > CurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (std::move (CurveFeature), this)
    {
    }

    CircularArcExtractType::
    CircularArcExtractType (const CircularArcExtractType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    CircularArcExtractType::
    CircularArcExtractType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcExtractType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CurveFeature
        //
        if (n.name () == L"CurveFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CurveFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcExtractType* CircularArcExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcExtractType (*this, f, c);
    }

    CircularArcExtractType& CircularArcExtractType::
    operator= (const CircularArcExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->CurveFeature_ = x.CurveFeature_;
      }

      return *this;
    }

    CircularArcExtractType::
    ~CircularArcExtractType ()
    {
    }

    // CircularArcCheckedType
    //

    CircularArcCheckedType::
    CircularArcCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    CircularArcCheckedType::
    CircularArcCheckedType (const CircularArcCheckedType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CircularArcCheckedType::
    CircularArcCheckedType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircularArcCheckedType* CircularArcCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcCheckedType (*this, f, c);
    }

    CircularArcCheckedType& CircularArcCheckedType::
    operator= (const CircularArcCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CircularArcCheckedType::
    ~CircularArcCheckedType ()
    {
    }

    // CircularArcCheckedFeatureType
    //

    CircularArcCheckedFeatureType::
    CircularArcCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    CircularArcCheckedFeatureType::
    CircularArcCheckedFeatureType (const CircularArcCheckedFeatureType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CircularArcCheckedFeatureType::
    CircularArcCheckedFeatureType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircularArcCheckedFeatureType* CircularArcCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcCheckedFeatureType (*this, f, c);
    }

    CircularArcCheckedFeatureType& CircularArcCheckedFeatureType::
    operator= (const CircularArcCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    CircularArcCheckedFeatureType::
    ~CircularArcCheckedFeatureType ()
    {
    }

    // CircularArcMeasurementDeterminationType
    //

    CircularArcMeasurementDeterminationType::
    CircularArcMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    CircularArcMeasurementDeterminationType::
    CircularArcMeasurementDeterminationType (const CircularArcMeasurementDeterminationType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CircularArcMeasurementDeterminationType::
    CircularArcMeasurementDeterminationType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircularArcMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircularArcMeasurementDeterminationType* CircularArcMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcMeasurementDeterminationType (*this, f, c);
    }

    CircularArcMeasurementDeterminationType& CircularArcMeasurementDeterminationType::
    operator= (const CircularArcMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    CircularArcMeasurementDeterminationType::
    ~CircularArcMeasurementDeterminationType ()
    {
    }

    // CircularArcFeatureItemType
    //

    CircularArcFeatureItemType::
    CircularArcFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    CircularArcFeatureItemType::
    CircularArcFeatureItemType (const id_type& id,
                                const FeatureNominalId_type& FeatureNominalId,
                                const FeatureName_type& FeatureName,
                                const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    CircularArcFeatureItemType::
    CircularArcFeatureItemType (const id_type& id,
                                ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                const FeatureName_type& FeatureName,
                                ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    CircularArcFeatureItemType::
    CircularArcFeatureItemType (const CircularArcFeatureItemType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    CircularArcFeatureItemType::
    CircularArcFeatureItemType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircularArcFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcFeatureItemType* CircularArcFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcFeatureItemType (*this, f, c);
    }

    CircularArcFeatureItemType& CircularArcFeatureItemType::
    operator= (const CircularArcFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    CircularArcFeatureItemType::
    ~CircularArcFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircularArcFeatureItemType >
    _xsd_CircularArcFeatureItemType_type_factory_init (
      L"CircularArcFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // CircularArcFeatureDefinitionType
    //

    CircularArcFeatureDefinitionType::
    CircularArcFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Radius_ (this)
    {
    }

    CircularArcFeatureDefinitionType::
    CircularArcFeatureDefinitionType (const id_type& id,
                                      const InternalExternal_type& InternalExternal,
                                      const Radius_type& Radius)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Radius_ (Radius, this)
    {
    }

    CircularArcFeatureDefinitionType::
    CircularArcFeatureDefinitionType (const id_type& id,
                                      const InternalExternal_type& InternalExternal,
                                      ::std::unique_ptr< Radius_type > Radius)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Radius_ (std::move (Radius), this)
    {
    }

    CircularArcFeatureDefinitionType::
    CircularArcFeatureDefinitionType (const CircularArcFeatureDefinitionType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Radius_ (x.Radius_, f, this)
    {
    }

    CircularArcFeatureDefinitionType::
    CircularArcFeatureDefinitionType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Radius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircularArcFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Radius
        //
        if (n.name () == L"Radius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Radius_type > r (
            Radius_traits::create (i, f, this));

          if (!Radius_.present ())
          {
            this->Radius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Radius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Radius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcFeatureDefinitionType* CircularArcFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcFeatureDefinitionType (*this, f, c);
    }

    CircularArcFeatureDefinitionType& CircularArcFeatureDefinitionType::
    operator= (const CircularArcFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Radius_ = x.Radius_;
      }

      return *this;
    }

    CircularArcFeatureDefinitionType::
    ~CircularArcFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircularArcFeatureDefinitionType >
    _xsd_CircularArcFeatureDefinitionType_type_factory_init (
      L"CircularArcFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // CircularArcFeatureNominalType
    //

    CircularArcFeatureNominalType::
    CircularArcFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      Location_ (this),
      Sweep_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    CircularArcFeatureNominalType::
    CircularArcFeatureNominalType (const id_type& id,
                                   const FeatureDefinitionId_type& FeatureDefinitionId,
                                   const Location_type& Location,
                                   const Sweep_type& Sweep,
                                   const Normal_type& Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Location_ (Location, this),
      Sweep_ (Sweep, this),
      Normal_ (Normal, this),
      Constructed_ (this)
    {
    }

    CircularArcFeatureNominalType::
    CircularArcFeatureNominalType (const id_type& id,
                                   ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                   ::std::unique_ptr< Location_type > Location,
                                   ::std::unique_ptr< Sweep_type > Sweep,
                                   ::std::unique_ptr< Normal_type > Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      Sweep_ (std::move (Sweep), this),
      Normal_ (std::move (Normal), this),
      Constructed_ (this)
    {
    }

    CircularArcFeatureNominalType::
    CircularArcFeatureNominalType (const CircularArcFeatureNominalType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Normal_ (x.Normal_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CircularArcFeatureNominalType::
    CircularArcFeatureNominalType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Sweep_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircularArcFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Sweep",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CircularArcFeatureNominalType* CircularArcFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcFeatureNominalType (*this, f, c);
    }

    CircularArcFeatureNominalType& CircularArcFeatureNominalType::
    operator= (const CircularArcFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Sweep_ = x.Sweep_;
        this->Normal_ = x.Normal_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CircularArcFeatureNominalType::
    ~CircularArcFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircularArcFeatureNominalType >
    _xsd_CircularArcFeatureNominalType_type_factory_init (
      L"CircularArcFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // CircularArcFeatureMeasurementType
    //

    CircularArcFeatureMeasurementType::
    CircularArcFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      Location_ (this),
      Normal_ (this),
      Radius_ (this),
      RadiusMin_ (this),
      RadiusMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    CircularArcFeatureMeasurementType::
    CircularArcFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      Location_ (this),
      Normal_ (this),
      Radius_ (this),
      RadiusMin_ (this),
      RadiusMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    CircularArcFeatureMeasurementType::
    CircularArcFeatureMeasurementType (const CircularArcFeatureMeasurementType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      Radius_ (x.Radius_, f, this),
      RadiusMin_ (x.RadiusMin_, f, this),
      RadiusMax_ (x.RadiusMax_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CircularArcFeatureMeasurementType::
    CircularArcFeatureMeasurementType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      Radius_ (this),
      RadiusMin_ (this),
      RadiusMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircularArcFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Radius
        //
        if (n.name () == L"Radius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Radius_type > r (
            Radius_traits::create (i, f, this));

          if (!this->Radius_)
          {
            this->Radius_.set (::std::move (r));
            continue;
          }
        }

        // RadiusMin
        //
        if (n.name () == L"RadiusMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RadiusMin_type > r (
            RadiusMin_traits::create (i, f, this));

          if (!this->RadiusMin_)
          {
            this->RadiusMin_.set (::std::move (r));
            continue;
          }
        }

        // RadiusMax
        //
        if (n.name () == L"RadiusMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RadiusMax_type > r (
            RadiusMax_traits::create (i, f, this));

          if (!this->RadiusMax_)
          {
            this->RadiusMax_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CircularArcFeatureMeasurementType* CircularArcFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircularArcFeatureMeasurementType (*this, f, c);
    }

    CircularArcFeatureMeasurementType& CircularArcFeatureMeasurementType::
    operator= (const CircularArcFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->Radius_ = x.Radius_;
        this->RadiusMin_ = x.RadiusMin_;
        this->RadiusMax_ = x.RadiusMax_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    CircularArcFeatureMeasurementType::
    ~CircularArcFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CircularArcFeatureMeasurementType >
    _xsd_CircularArcFeatureMeasurementType_type_factory_init (
      L"CircularArcFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // ConeConstructionMethodType
    //

    ConeConstructionMethodType::
    ConeConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    ConeConstructionMethodType::
    ConeConstructionMethodType (const ConeConstructionMethodType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    ConeConstructionMethodType::
    ConeConstructionMethodType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConeConstructionMethodType* ConeConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeConstructionMethodType (*this, f, c);
    }

    ConeConstructionMethodType& ConeConstructionMethodType::
    operator= (const ConeConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    ConeConstructionMethodType::
    ~ConeConstructionMethodType ()
    {
    }

    // ConeBestFitType
    //

    ConeBestFitType::
    ConeBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    ConeBestFitType::
    ConeBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    ConeBestFitType::
    ConeBestFitType (const ConeBestFitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ConeBestFitType::
    ConeBestFitType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ConeBestFitType* ConeBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeBestFitType (*this, f, c);
    }

    ConeBestFitType& ConeBestFitType::
    operator= (const ConeBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ConeBestFitType::
    ~ConeBestFitType ()
    {
    }

    // ConeRecompType
    //

    ConeRecompType::
    ConeRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    ConeRecompType::
    ConeRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ConeRecompType::
    ConeRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    ConeRecompType::
    ConeRecompType (const ConeRecompType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ConeRecompType::
    ConeRecompType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConeRecompType* ConeRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeRecompType (*this, f, c);
    }

    ConeRecompType& ConeRecompType::
    operator= (const ConeRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ConeRecompType::
    ~ConeRecompType ()
    {
    }

    // ConeCopyType
    //

    ConeCopyType::
    ConeCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (this)
    {
    }

    ConeCopyType::
    ConeCopyType (const BaseCone_type& BaseCone)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this)
    {
    }

    ConeCopyType::
    ConeCopyType (::std::unique_ptr< BaseCone_type > BaseCone)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (std::move (BaseCone), this)
    {
    }

    ConeCopyType::
    ConeCopyType (const ConeCopyType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this)
    {
    }

    ConeCopyType::
    ConeCopyType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCone
        //
        if (n.name () == L"BaseCone" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCone",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConeCopyType* ConeCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCopyType (*this, f, c);
    }

    ConeCopyType& ConeCopyType::
    operator= (const ConeCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCone_ = x.BaseCone_;
      }

      return *this;
    }

    ConeCopyType::
    ~ConeCopyType ()
    {
    }

    // ConeCastType
    //

    ConeCastType::
    ConeCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ConeCastType::
    ConeCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ConeCastType::
    ConeCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    ConeCastType::
    ConeCastType (const ConeCastType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConeCastType::
    ConeCastType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConeCastType* ConeCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCastType (*this, f, c);
    }

    ConeCastType& ConeCastType::
    operator= (const ConeCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ConeCastType::
    ~ConeCastType ()
    {
    }

    // ConeTransformType
    //

    ConeTransformType::
    ConeTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (this),
      Transformation_ (this)
    {
    }

    ConeTransformType::
    ConeTransformType (const BaseCone_type& BaseCone,
                       const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this),
      Transformation_ (Transformation, this)
    {
    }

    ConeTransformType::
    ConeTransformType (::std::unique_ptr< BaseCone_type > BaseCone,
                       ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (std::move (BaseCone), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    ConeTransformType::
    ConeTransformType (const ConeTransformType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ConeTransformType::
    ConeTransformType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCone
        //
        if (n.name () == L"BaseCone" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCone",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConeTransformType* ConeTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeTransformType (*this, f, c);
    }

    ConeTransformType& ConeTransformType::
    operator= (const ConeTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCone_ = x.BaseCone_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ConeTransformType::
    ~ConeTransformType ()
    {
    }

    // ConeFromScanType
    //

    ConeFromScanType::
    ConeFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (const SurfaceFeature_type& SurfaceFeature,
                      const SearchRadius_type& SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                      ::std::unique_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (const ConeFromScanType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConeFromScanType* ConeFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFromScanType (*this, f, c);
    }

    ConeFromScanType& ConeFromScanType::
    operator= (const ConeFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    ConeFromScanType::
    ~ConeFromScanType ()
    {
    }

    // ConeCheckedType
    //

    ConeCheckedType::
    ConeCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ConeCheckedType::
    ConeCheckedType (const ConeCheckedType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ConeCheckedType::
    ConeCheckedType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConeCheckedType* ConeCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCheckedType (*this, f, c);
    }

    ConeCheckedType& ConeCheckedType::
    operator= (const ConeCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ConeCheckedType::
    ~ConeCheckedType ()
    {
    }

    // ConeCheckedFeatureType
    //

    ConeCheckedFeatureType::
    ConeCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ConeCheckedFeatureType::
    ConeCheckedFeatureType (const ConeCheckedFeatureType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ConeCheckedFeatureType::
    ConeCheckedFeatureType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConeCheckedFeatureType* ConeCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCheckedFeatureType (*this, f, c);
    }

    ConeCheckedFeatureType& ConeCheckedFeatureType::
    operator= (const ConeCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ConeCheckedFeatureType::
    ~ConeCheckedFeatureType ()
    {
    }

    // ConeMeasurementDeterminationType
    //

    ConeMeasurementDeterminationType::
    ConeMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ConeMeasurementDeterminationType::
    ConeMeasurementDeterminationType (const ConeMeasurementDeterminationType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ConeMeasurementDeterminationType::
    ConeMeasurementDeterminationType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConeMeasurementDeterminationType* ConeMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeMeasurementDeterminationType (*this, f, c);
    }

    ConeMeasurementDeterminationType& ConeMeasurementDeterminationType::
    operator= (const ConeMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ConeMeasurementDeterminationType::
    ~ConeMeasurementDeterminationType ()
    {
    }

    // ConeFeatureItemType
    //

    ConeFeatureItemType::
    ConeFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const id_type& id,
                         const FeatureNominalId_type& FeatureNominalId,
                         const FeatureName_type& FeatureName,
                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const id_type& id,
                         ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                         const FeatureName_type& FeatureName,
                         ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const ConeFeatureItemType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConeFeatureItemType* ConeFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureItemType (*this, f, c);
    }

    ConeFeatureItemType& ConeFeatureItemType::
    operator= (const ConeFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    ConeFeatureItemType::
    ~ConeFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConeFeatureItemType >
    _xsd_ConeFeatureItemType_type_factory_init (
      L"ConeFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // ConeFeatureDefinitionType
    //

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const id_type& id,
                               const InternalExternal_type& InternalExternal,
                               const Diameter_type& Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const id_type& id,
                               const InternalExternal_type& InternalExternal,
                               ::std::unique_ptr< Diameter_type > Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const ConeFeatureDefinitionType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == L"HalfAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (::std::move (r));
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == L"FullAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (::std::move (r));
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == L"LargeEndDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (::std::move (r));
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == L"SmallEndDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConeFeatureDefinitionType* ConeFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureDefinitionType (*this, f, c);
    }

    ConeFeatureDefinitionType& ConeFeatureDefinitionType::
    operator= (const ConeFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->HalfAngle_ = x.HalfAngle_;
        this->FullAngle_ = x.FullAngle_;
        this->LargeEndDistance_ = x.LargeEndDistance_;
        this->SmallEndDistance_ = x.SmallEndDistance_;
      }

      return *this;
    }

    ConeFeatureDefinitionType::
    ~ConeFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConeFeatureDefinitionType >
    _xsd_ConeFeatureDefinitionType_type_factory_init (
      L"ConeFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // ConeFeatureNominalType
    //

    ConeFeatureNominalType::
    ConeFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Axis_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            const Axis_type& Axis)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const id_type& id,
                            ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                            ::std::unique_ptr< Axis_type > Axis)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Axis_ (std::move (Axis), this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const ConeFeatureNominalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConeFeatureNominalType* ConeFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureNominalType (*this, f, c);
    }

    ConeFeatureNominalType& ConeFeatureNominalType::
    operator= (const ConeFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ConeFeatureNominalType::
    ~ConeFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConeFeatureNominalType >
    _xsd_ConeFeatureNominalType_type_factory_init (
      L"ConeFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // ConeFeatureMeasurementType
    //

    ConeFeatureMeasurementType::
    ConeFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    ConeFeatureMeasurementType::
    ConeFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    ConeFeatureMeasurementType::
    ConeFeatureMeasurementType (const ConeFeatureMeasurementType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ConeFeatureMeasurementType::
    ConeFeatureMeasurementType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == L"HalfAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (::std::move (r));
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == L"FullAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (::std::move (r));
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == L"SmallEndDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (::std::move (r));
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == L"LargeEndDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConeFeatureMeasurementType* ConeFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureMeasurementType (*this, f, c);
    }

    ConeFeatureMeasurementType& ConeFeatureMeasurementType::
    operator= (const ConeFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->HalfAngle_ = x.HalfAngle_;
        this->FullAngle_ = x.FullAngle_;
        this->SmallEndDistance_ = x.SmallEndDistance_;
        this->LargeEndDistance_ = x.LargeEndDistance_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ConeFeatureMeasurementType::
    ~ConeFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConeFeatureMeasurementType >
    _xsd_ConeFeatureMeasurementType_type_factory_init (
      L"ConeFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // ConicalSegmentConstructionMethodType
    //

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType (const ConicalSegmentConstructionMethodType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentConstructionMethodType* ConicalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentConstructionMethodType (*this, f, c);
    }

    ConicalSegmentConstructionMethodType& ConicalSegmentConstructionMethodType::
    operator= (const ConicalSegmentConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ConicalSegmentConstructionMethodType::
    ~ConicalSegmentConstructionMethodType ()
    {
    }

    // ConicalSegmentBestFitType
    //

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType (const ConicalSegmentBestFitType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ConicalSegmentBestFitType* ConicalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentBestFitType (*this, f, c);
    }

    ConicalSegmentBestFitType& ConicalSegmentBestFitType::
    operator= (const ConicalSegmentBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ConicalSegmentBestFitType::
    ~ConicalSegmentBestFitType ()
    {
    }

    // ConicalSegmentRecompType
    //

    ConicalSegmentRecompType::
    ConicalSegmentRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const ConicalSegmentRecompType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConicalSegmentRecompType* ConicalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentRecompType (*this, f, c);
    }

    ConicalSegmentRecompType& ConicalSegmentRecompType::
    operator= (const ConicalSegmentRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ConicalSegmentRecompType::
    ~ConicalSegmentRecompType ()
    {
    }

    // ConicalSegmentCopyType
    //

    ConicalSegmentCopyType::
    ConicalSegmentCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseConicalSegment_ (this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const BaseConicalSegment_type& BaseConicalSegment)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (::std::unique_ptr< BaseConicalSegment_type > BaseConicalSegment)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseConicalSegment_ (std::move (BaseConicalSegment), this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const ConicalSegmentCopyType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseConicalSegment_ (x.BaseConicalSegment_, f, this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseConicalSegment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseConicalSegment
        //
        if (n.name () == L"BaseConicalSegment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseConicalSegment_type > r (
            BaseConicalSegment_traits::create (i, f, this));

          if (!BaseConicalSegment_.present ())
          {
            this->BaseConicalSegment_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseConicalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseConicalSegment",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConicalSegmentCopyType* ConicalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCopyType (*this, f, c);
    }

    ConicalSegmentCopyType& ConicalSegmentCopyType::
    operator= (const ConicalSegmentCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseConicalSegment_ = x.BaseConicalSegment_;
      }

      return *this;
    }

    ConicalSegmentCopyType::
    ~ConicalSegmentCopyType ()
    {
    }

    // ConicalSegmentCastType
    //

    ConicalSegmentCastType::
    ConicalSegmentCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (const ConicalSegmentCastType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConicalSegmentCastType* ConicalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCastType (*this, f, c);
    }

    ConicalSegmentCastType& ConicalSegmentCastType::
    operator= (const ConicalSegmentCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ConicalSegmentCastType::
    ~ConicalSegmentCastType ()
    {
    }

    // ConicalSegmentTransformType
    //

    ConicalSegmentTransformType::
    ConicalSegmentTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseConicalSegment_ (this),
      Transformation_ (this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const BaseConicalSegment_type& BaseConicalSegment,
                                 const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (::std::unique_ptr< BaseConicalSegment_type > BaseConicalSegment,
                                 ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseConicalSegment_ (std::move (BaseConicalSegment), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const ConicalSegmentTransformType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseConicalSegment_ (x.BaseConicalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseConicalSegment_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseConicalSegment
        //
        if (n.name () == L"BaseConicalSegment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseConicalSegment_type > r (
            BaseConicalSegment_traits::create (i, f, this));

          if (!BaseConicalSegment_.present ())
          {
            this->BaseConicalSegment_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseConicalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseConicalSegment",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConicalSegmentTransformType* ConicalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentTransformType (*this, f, c);
    }

    ConicalSegmentTransformType& ConicalSegmentTransformType::
    operator= (const ConicalSegmentTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseConicalSegment_ = x.BaseConicalSegment_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ConicalSegmentTransformType::
    ~ConicalSegmentTransformType ()
    {
    }

    // ConicalSegmentCheckedType
    //

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType (const ConicalSegmentCheckedType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentCheckedType* ConicalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCheckedType (*this, f, c);
    }

    ConicalSegmentCheckedType& ConicalSegmentCheckedType::
    operator= (const ConicalSegmentCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ConicalSegmentCheckedType::
    ~ConicalSegmentCheckedType ()
    {
    }

    // ConicalSegmentCheckedFeatureType
    //

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType (const ConicalSegmentCheckedFeatureType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentCheckedFeatureType* ConicalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCheckedFeatureType (*this, f, c);
    }

    ConicalSegmentCheckedFeatureType& ConicalSegmentCheckedFeatureType::
    operator= (const ConicalSegmentCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ConicalSegmentCheckedFeatureType::
    ~ConicalSegmentCheckedFeatureType ()
    {
    }

    // ConicalSegmentMeasurementDeterminationType
    //

    ConicalSegmentMeasurementDeterminationType::
    ConicalSegmentMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ConicalSegmentMeasurementDeterminationType::
    ConicalSegmentMeasurementDeterminationType (const ConicalSegmentMeasurementDeterminationType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ConicalSegmentMeasurementDeterminationType::
    ConicalSegmentMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentMeasurementDeterminationType* ConicalSegmentMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentMeasurementDeterminationType (*this, f, c);
    }

    ConicalSegmentMeasurementDeterminationType& ConicalSegmentMeasurementDeterminationType::
    operator= (const ConicalSegmentMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ConicalSegmentMeasurementDeterminationType::
    ~ConicalSegmentMeasurementDeterminationType ()
    {
    }

    // ConicalSegmentFeatureItemType
    //

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const id_type& id,
                                   const FeatureNominalId_type& FeatureNominalId,
                                   const FeatureName_type& FeatureName,
                                   const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const id_type& id,
                                   ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                   const FeatureName_type& FeatureName,
                                   ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const ConicalSegmentFeatureItemType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConicalSegmentFeatureItemType* ConicalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureItemType (*this, f, c);
    }

    ConicalSegmentFeatureItemType& ConicalSegmentFeatureItemType::
    operator= (const ConicalSegmentFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    ConicalSegmentFeatureItemType::
    ~ConicalSegmentFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConicalSegmentFeatureItemType >
    _xsd_ConicalSegmentFeatureItemType_type_factory_init (
      L"ConicalSegmentFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // ConicalSegmentFeatureDefinitionType
    //

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         const Diameter_type& Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         ::std::unique_ptr< Diameter_type > Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const ConicalSegmentFeatureDefinitionType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == L"HalfAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (::std::move (r));
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == L"FullAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (::std::move (r));
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == L"LargeEndDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (::std::move (r));
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == L"SmallEndDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConicalSegmentFeatureDefinitionType* ConicalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureDefinitionType (*this, f, c);
    }

    ConicalSegmentFeatureDefinitionType& ConicalSegmentFeatureDefinitionType::
    operator= (const ConicalSegmentFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->HalfAngle_ = x.HalfAngle_;
        this->FullAngle_ = x.FullAngle_;
        this->LargeEndDistance_ = x.LargeEndDistance_;
        this->SmallEndDistance_ = x.SmallEndDistance_;
      }

      return *this;
    }

    ConicalSegmentFeatureDefinitionType::
    ~ConicalSegmentFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConicalSegmentFeatureDefinitionType >
    _xsd_ConicalSegmentFeatureDefinitionType_type_factory_init (
      L"ConicalSegmentFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // ConicalSegmentFeatureNominalType
    //

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Axis_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      const Axis_type& Axis,
                                      const Sweep_type& Sweep)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (Sweep, this),
      Constructed_ (this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const id_type& id,
                                      ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                      ::std::unique_ptr< Axis_type > Axis,
                                      ::std::unique_ptr< Sweep_type > Sweep)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Axis_ (std::move (Axis), this),
      Sweep_ (std::move (Sweep), this),
      Constructed_ (this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const ConicalSegmentFeatureNominalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Sweep",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ConicalSegmentFeatureNominalType* ConicalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureNominalType (*this, f, c);
    }

    ConicalSegmentFeatureNominalType& ConicalSegmentFeatureNominalType::
    operator= (const ConicalSegmentFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ConicalSegmentFeatureNominalType::
    ~ConicalSegmentFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConicalSegmentFeatureNominalType >
    _xsd_ConicalSegmentFeatureNominalType_type_factory_init (
      L"ConicalSegmentFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // ConicalSegmentFeatureMeasurementType
    //

    ConicalSegmentFeatureMeasurementType::
    ConicalSegmentFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    ConicalSegmentFeatureMeasurementType::
    ConicalSegmentFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    ConicalSegmentFeatureMeasurementType::
    ConicalSegmentFeatureMeasurementType (const ConicalSegmentFeatureMeasurementType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ConicalSegmentFeatureMeasurementType::
    ConicalSegmentFeatureMeasurementType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == L"HalfAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (::std::move (r));
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == L"FullAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (::std::move (r));
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == L"SmallEndDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (::std::move (r));
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == L"LargeEndDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentFeatureMeasurementType* ConicalSegmentFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureMeasurementType (*this, f, c);
    }

    ConicalSegmentFeatureMeasurementType& ConicalSegmentFeatureMeasurementType::
    operator= (const ConicalSegmentFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->HalfAngle_ = x.HalfAngle_;
        this->FullAngle_ = x.FullAngle_;
        this->SmallEndDistance_ = x.SmallEndDistance_;
        this->LargeEndDistance_ = x.LargeEndDistance_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ConicalSegmentFeatureMeasurementType::
    ~ConicalSegmentFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConicalSegmentFeatureMeasurementType >
    _xsd_ConicalSegmentFeatureMeasurementType_type_factory_init (
      L"ConicalSegmentFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // CylinderConstructionMethodType
    //

    CylinderConstructionMethodType::
    CylinderConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    CylinderConstructionMethodType::
    CylinderConstructionMethodType (const CylinderConstructionMethodType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    CylinderConstructionMethodType::
    CylinderConstructionMethodType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylinderConstructionMethodType* CylinderConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderConstructionMethodType (*this, f, c);
    }

    CylinderConstructionMethodType& CylinderConstructionMethodType::
    operator= (const CylinderConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    CylinderConstructionMethodType::
    ~CylinderConstructionMethodType ()
    {
    }

    // CylinderBestFitType
    //

    CylinderBestFitType::
    CylinderBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    CylinderBestFitType::
    CylinderBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    CylinderBestFitType::
    CylinderBestFitType (const CylinderBestFitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CylinderBestFitType::
    CylinderBestFitType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CylinderBestFitType* CylinderBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderBestFitType (*this, f, c);
    }

    CylinderBestFitType& CylinderBestFitType::
    operator= (const CylinderBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CylinderBestFitType::
    ~CylinderBestFitType ()
    {
    }

    // CylinderRecompType
    //

    CylinderRecompType::
    CylinderRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (const CylinderRecompType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderRecompType* CylinderRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderRecompType (*this, f, c);
    }

    CylinderRecompType& CylinderRecompType::
    operator= (const CylinderRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    CylinderRecompType::
    ~CylinderRecompType ()
    {
    }

    // CylinderCopyType
    //

    CylinderCopyType::
    CylinderCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (const BaseCylinder_type& BaseCylinder)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (::std::unique_ptr< BaseCylinder_type > BaseCylinder)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (std::move (BaseCylinder), this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (const CylinderCopyType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCylinder
        //
        if (n.name () == L"BaseCylinder" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCylinder",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderCopyType* CylinderCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCopyType (*this, f, c);
    }

    CylinderCopyType& CylinderCopyType::
    operator= (const CylinderCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylinder_ = x.BaseCylinder_;
      }

      return *this;
    }

    CylinderCopyType::
    ~CylinderCopyType ()
    {
    }

    // CylinderCastType
    //

    CylinderCastType::
    CylinderCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    CylinderCastType::
    CylinderCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CylinderCastType::
    CylinderCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    CylinderCastType::
    CylinderCastType (const CylinderCastType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylinderCastType::
    CylinderCastType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderCastType* CylinderCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCastType (*this, f, c);
    }

    CylinderCastType& CylinderCastType::
    operator= (const CylinderCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CylinderCastType::
    ~CylinderCastType ()
    {
    }

    // CylinderTransformType
    //

    CylinderTransformType::
    CylinderTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (this),
      Transformation_ (this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (const BaseCylinder_type& BaseCylinder,
                           const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this),
      Transformation_ (Transformation, this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (::std::unique_ptr< BaseCylinder_type > BaseCylinder,
                           ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (std::move (BaseCylinder), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (const CylinderTransformType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCylinder
        //
        if (n.name () == L"BaseCylinder" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCylinder",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderTransformType* CylinderTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderTransformType (*this, f, c);
    }

    CylinderTransformType& CylinderTransformType::
    operator= (const CylinderTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylinder_ = x.BaseCylinder_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    CylinderTransformType::
    ~CylinderTransformType ()
    {
    }

    // CylinderFromScanType
    //

    CylinderFromScanType::
    CylinderFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (const SurfaceFeature_type& SurfaceFeature,
                          const SearchRadius_type& SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                          ::std::unique_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (const CylinderFromScanType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderFromScanType* CylinderFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFromScanType (*this, f, c);
    }

    CylinderFromScanType& CylinderFromScanType::
    operator= (const CylinderFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    CylinderFromScanType::
    ~CylinderFromScanType ()
    {
    }

    // CylinderCheckedType
    //

    CylinderCheckedType::
    CylinderCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    CylinderCheckedType::
    CylinderCheckedType (const CylinderCheckedType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CylinderCheckedType::
    CylinderCheckedType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylinderCheckedType* CylinderCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCheckedType (*this, f, c);
    }

    CylinderCheckedType& CylinderCheckedType::
    operator= (const CylinderCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CylinderCheckedType::
    ~CylinderCheckedType ()
    {
    }

    // CylinderCheckedFeatureType
    //

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType (const CylinderCheckedFeatureType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylinderCheckedFeatureType* CylinderCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCheckedFeatureType (*this, f, c);
    }

    CylinderCheckedFeatureType& CylinderCheckedFeatureType::
    operator= (const CylinderCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    CylinderCheckedFeatureType::
    ~CylinderCheckedFeatureType ()
    {
    }

    // CylinderMeasurementDeterminationType
    //

    CylinderMeasurementDeterminationType::
    CylinderMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    CylinderMeasurementDeterminationType::
    CylinderMeasurementDeterminationType (const CylinderMeasurementDeterminationType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CylinderMeasurementDeterminationType::
    CylinderMeasurementDeterminationType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylinderMeasurementDeterminationType* CylinderMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderMeasurementDeterminationType (*this, f, c);
    }

    CylinderMeasurementDeterminationType& CylinderMeasurementDeterminationType::
    operator= (const CylinderMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    CylinderMeasurementDeterminationType::
    ~CylinderMeasurementDeterminationType ()
    {
    }

    // CylinderFeatureItemType
    //

    CylinderFeatureItemType::
    CylinderFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const id_type& id,
                             const FeatureNominalId_type& FeatureNominalId,
                             const FeatureName_type& FeatureName,
                             const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const id_type& id,
                             ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                             const FeatureName_type& FeatureName,
                             ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const CylinderFeatureItemType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderFeatureItemType* CylinderFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureItemType (*this, f, c);
    }

    CylinderFeatureItemType& CylinderFeatureItemType::
    operator= (const CylinderFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    CylinderFeatureItemType::
    ~CylinderFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylinderFeatureItemType >
    _xsd_CylinderFeatureItemType_type_factory_init (
      L"CylinderFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // CylinderFeatureDefinitionType
    //

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   const Diameter_type& Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   ::std::unique_ptr< Diameter_type > Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const CylinderFeatureDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Bottom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == L"Bottom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderFeatureDefinitionType* CylinderFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureDefinitionType (*this, f, c);
    }

    CylinderFeatureDefinitionType& CylinderFeatureDefinitionType::
    operator= (const CylinderFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->Bottom_ = x.Bottom_;
      }

      return *this;
    }

    CylinderFeatureDefinitionType::
    ~CylinderFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylinderFeatureDefinitionType >
    _xsd_CylinderFeatureDefinitionType_type_factory_init (
      L"CylinderFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // CylinderFeatureNominalType
    //

    CylinderFeatureNominalType::
    CylinderFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Axis_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                const Axis_type& Axis)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const id_type& id,
                                ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                ::std::unique_ptr< Axis_type > Axis)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Axis_ (std::move (Axis), this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const CylinderFeatureNominalType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylinderFeatureNominalType* CylinderFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureNominalType (*this, f, c);
    }

    CylinderFeatureNominalType& CylinderFeatureNominalType::
    operator= (const CylinderFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CylinderFeatureNominalType::
    ~CylinderFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylinderFeatureNominalType >
    _xsd_CylinderFeatureNominalType_type_factory_init (
      L"CylinderFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // CylinderFeatureMeasurementType
    //

    CylinderFeatureMeasurementType::
    CylinderFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    CylinderFeatureMeasurementType::
    CylinderFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    CylinderFeatureMeasurementType::
    CylinderFeatureMeasurementType (const CylinderFeatureMeasurementType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CylinderFeatureMeasurementType::
    CylinderFeatureMeasurementType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylinderFeatureMeasurementType* CylinderFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureMeasurementType (*this, f, c);
    }

    CylinderFeatureMeasurementType& CylinderFeatureMeasurementType::
    operator= (const CylinderFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    CylinderFeatureMeasurementType::
    ~CylinderFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylinderFeatureMeasurementType >
    _xsd_CylinderFeatureMeasurementType_type_factory_init (
      L"CylinderFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // CylindricalSegmentConstructionMethodType
    //

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType (const CylindricalSegmentConstructionMethodType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentConstructionMethodType* CylindricalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentConstructionMethodType (*this, f, c);
    }

    CylindricalSegmentConstructionMethodType& CylindricalSegmentConstructionMethodType::
    operator= (const CylindricalSegmentConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    CylindricalSegmentConstructionMethodType::
    ~CylindricalSegmentConstructionMethodType ()
    {
    }

    // CylindricalSegmentBestFitType
    //

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType (const CylindricalSegmentBestFitType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CylindricalSegmentBestFitType* CylindricalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentBestFitType (*this, f, c);
    }

    CylindricalSegmentBestFitType& CylindricalSegmentBestFitType::
    operator= (const CylindricalSegmentBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CylindricalSegmentBestFitType::
    ~CylindricalSegmentBestFitType ()
    {
    }

    // CylindricalSegmentRecompType
    //

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const CylindricalSegmentRecompType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylindricalSegmentRecompType* CylindricalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentRecompType (*this, f, c);
    }

    CylindricalSegmentRecompType& CylindricalSegmentRecompType::
    operator= (const CylindricalSegmentRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    CylindricalSegmentRecompType::
    ~CylindricalSegmentRecompType ()
    {
    }

    // CylindricalSegmentCopyType
    //

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const BaseCylindricalSegment_type& BaseCylindricalSegment)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (::std::unique_ptr< BaseCylindricalSegment_type > BaseCylindricalSegment)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (std::move (BaseCylindricalSegment), this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const CylindricalSegmentCopyType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCylindricalSegment_ (x.BaseCylindricalSegment_, f, this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylindricalSegment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCylindricalSegment
        //
        if (n.name () == L"BaseCylindricalSegment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCylindricalSegment_type > r (
            BaseCylindricalSegment_traits::create (i, f, this));

          if (!BaseCylindricalSegment_.present ())
          {
            this->BaseCylindricalSegment_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCylindricalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCylindricalSegment",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylindricalSegmentCopyType* CylindricalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCopyType (*this, f, c);
    }

    CylindricalSegmentCopyType& CylindricalSegmentCopyType::
    operator= (const CylindricalSegmentCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylindricalSegment_ = x.BaseCylindricalSegment_;
      }

      return *this;
    }

    CylindricalSegmentCopyType::
    ~CylindricalSegmentCopyType ()
    {
    }

    // CylindricalSegmentCastType
    //

    CylindricalSegmentCastType::
    CylindricalSegmentCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const CylindricalSegmentCastType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylindricalSegmentCastType* CylindricalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCastType (*this, f, c);
    }

    CylindricalSegmentCastType& CylindricalSegmentCastType::
    operator= (const CylindricalSegmentCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CylindricalSegmentCastType::
    ~CylindricalSegmentCastType ()
    {
    }

    // CylindricalSegmentTransformType
    //

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (this),
      Transformation_ (this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const BaseCylindricalSegment_type& BaseCylindricalSegment,
                                     const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (::std::unique_ptr< BaseCylindricalSegment_type > BaseCylindricalSegment,
                                     ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (std::move (BaseCylindricalSegment), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const CylindricalSegmentTransformType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCylindricalSegment_ (x.BaseCylindricalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylindricalSegment_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCylindricalSegment
        //
        if (n.name () == L"BaseCylindricalSegment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCylindricalSegment_type > r (
            BaseCylindricalSegment_traits::create (i, f, this));

          if (!BaseCylindricalSegment_.present ())
          {
            this->BaseCylindricalSegment_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCylindricalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCylindricalSegment",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylindricalSegmentTransformType* CylindricalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentTransformType (*this, f, c);
    }

    CylindricalSegmentTransformType& CylindricalSegmentTransformType::
    operator= (const CylindricalSegmentTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylindricalSegment_ = x.BaseCylindricalSegment_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    CylindricalSegmentTransformType::
    ~CylindricalSegmentTransformType ()
    {
    }

    // CylindricalSegmentCheckedType
    //

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType (const CylindricalSegmentCheckedType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentCheckedType* CylindricalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCheckedType (*this, f, c);
    }

    CylindricalSegmentCheckedType& CylindricalSegmentCheckedType::
    operator= (const CylindricalSegmentCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CylindricalSegmentCheckedType::
    ~CylindricalSegmentCheckedType ()
    {
    }

    // CylindricalSegmentCheckedFeatureType
    //

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType (const CylindricalSegmentCheckedFeatureType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentCheckedFeatureType* CylindricalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCheckedFeatureType (*this, f, c);
    }

    CylindricalSegmentCheckedFeatureType& CylindricalSegmentCheckedFeatureType::
    operator= (const CylindricalSegmentCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    CylindricalSegmentCheckedFeatureType::
    ~CylindricalSegmentCheckedFeatureType ()
    {
    }

    // CylindricalSegmentMeasurementDeterminationType
    //

    CylindricalSegmentMeasurementDeterminationType::
    CylindricalSegmentMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    CylindricalSegmentMeasurementDeterminationType::
    CylindricalSegmentMeasurementDeterminationType (const CylindricalSegmentMeasurementDeterminationType& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CylindricalSegmentMeasurementDeterminationType::
    CylindricalSegmentMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentMeasurementDeterminationType* CylindricalSegmentMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentMeasurementDeterminationType (*this, f, c);
    }

    CylindricalSegmentMeasurementDeterminationType& CylindricalSegmentMeasurementDeterminationType::
    operator= (const CylindricalSegmentMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    CylindricalSegmentMeasurementDeterminationType::
    ~CylindricalSegmentMeasurementDeterminationType ()
    {
    }

    // CylindricalSegmentFeatureItemType
    //

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const id_type& id,
                                       const FeatureNominalId_type& FeatureNominalId,
                                       const FeatureName_type& FeatureName,
                                       const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const id_type& id,
                                       ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                       const FeatureName_type& FeatureName,
                                       ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const CylindricalSegmentFeatureItemType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylindricalSegmentFeatureItemType* CylindricalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureItemType (*this, f, c);
    }

    CylindricalSegmentFeatureItemType& CylindricalSegmentFeatureItemType::
    operator= (const CylindricalSegmentFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    CylindricalSegmentFeatureItemType::
    ~CylindricalSegmentFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylindricalSegmentFeatureItemType >
    _xsd_CylindricalSegmentFeatureItemType_type_factory_init (
      L"CylindricalSegmentFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // CylindricalSegmentFeatureDefinitionType
    //

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const id_type& id,
                                             const InternalExternal_type& InternalExternal,
                                             const Diameter_type& Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const id_type& id,
                                             const InternalExternal_type& InternalExternal,
                                             ::std::unique_ptr< Diameter_type > Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const CylindricalSegmentFeatureDefinitionType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Bottom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == L"Bottom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylindricalSegmentFeatureDefinitionType* CylindricalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureDefinitionType (*this, f, c);
    }

    CylindricalSegmentFeatureDefinitionType& CylindricalSegmentFeatureDefinitionType::
    operator= (const CylindricalSegmentFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->Bottom_ = x.Bottom_;
      }

      return *this;
    }

    CylindricalSegmentFeatureDefinitionType::
    ~CylindricalSegmentFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylindricalSegmentFeatureDefinitionType >
    _xsd_CylindricalSegmentFeatureDefinitionType_type_factory_init (
      L"CylindricalSegmentFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // CylindricalSegmentFeatureNominalType
    //

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Axis_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const id_type& id,
                                          const FeatureDefinitionId_type& FeatureDefinitionId,
                                          const Axis_type& Axis,
                                          const Sweep_type& Sweep)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (Sweep, this),
      Constructed_ (this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const id_type& id,
                                          ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                          ::std::unique_ptr< Axis_type > Axis,
                                          ::std::unique_ptr< Sweep_type > Sweep)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Axis_ (std::move (Axis), this),
      Sweep_ (std::move (Sweep), this),
      Constructed_ (this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const CylindricalSegmentFeatureNominalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Sweep",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CylindricalSegmentFeatureNominalType* CylindricalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureNominalType (*this, f, c);
    }

    CylindricalSegmentFeatureNominalType& CylindricalSegmentFeatureNominalType::
    operator= (const CylindricalSegmentFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CylindricalSegmentFeatureNominalType::
    ~CylindricalSegmentFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylindricalSegmentFeatureNominalType >
    _xsd_CylindricalSegmentFeatureNominalType_type_factory_init (
      L"CylindricalSegmentFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // CylindricalSegmentFeatureMeasurementType
    //

    CylindricalSegmentFeatureMeasurementType::
    CylindricalSegmentFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    CylindricalSegmentFeatureMeasurementType::
    CylindricalSegmentFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
    }

    CylindricalSegmentFeatureMeasurementType::
    CylindricalSegmentFeatureMeasurementType (const CylindricalSegmentFeatureMeasurementType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CylindricalSegmentFeatureMeasurementType::
    CylindricalSegmentFeatureMeasurementType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentFeatureMeasurementType* CylindricalSegmentFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureMeasurementType (*this, f, c);
    }

    CylindricalSegmentFeatureMeasurementType& CylindricalSegmentFeatureMeasurementType::
    operator= (const CylindricalSegmentFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    CylindricalSegmentFeatureMeasurementType::
    ~CylindricalSegmentFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CylindricalSegmentFeatureMeasurementType >
    _xsd_CylindricalSegmentFeatureMeasurementType_type_factory_init (
      L"CylindricalSegmentFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // EdgePointConstructionMethodType
    //

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType ()
    : ::xml_schema::type (),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType (const EdgePointConstructionMethodType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EdgePointConstructionMethodType* EdgePointConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointConstructionMethodType (*this, f, c);
    }

    EdgePointConstructionMethodType& EdgePointConstructionMethodType::
    operator= (const EdgePointConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    EdgePointConstructionMethodType::
    ~EdgePointConstructionMethodType ()
    {
    }

    // EdgePointCopyType
    //

    EdgePointCopyType::
    EdgePointCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEdgePoint_ (this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (const BaseEdgePoint_type& BaseEdgePoint)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (::std::unique_ptr< BaseEdgePoint_type > BaseEdgePoint)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEdgePoint_ (std::move (BaseEdgePoint), this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (const EdgePointCopyType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseEdgePoint_ (x.BaseEdgePoint_, f, this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEdgePoint_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseEdgePoint
        //
        if (n.name () == L"BaseEdgePoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseEdgePoint_type > r (
            BaseEdgePoint_traits::create (i, f, this));

          if (!BaseEdgePoint_.present ())
          {
            this->BaseEdgePoint_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseEdgePoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseEdgePoint",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EdgePointCopyType* EdgePointCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCopyType (*this, f, c);
    }

    EdgePointCopyType& EdgePointCopyType::
    operator= (const EdgePointCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEdgePoint_ = x.BaseEdgePoint_;
      }

      return *this;
    }

    EdgePointCopyType::
    ~EdgePointCopyType ()
    {
    }

    // EdgePointCastType
    //

    EdgePointCastType::
    EdgePointCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (const EdgePointCastType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EdgePointCastType* EdgePointCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCastType (*this, f, c);
    }

    EdgePointCastType& EdgePointCastType::
    operator= (const EdgePointCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    EdgePointCastType::
    ~EdgePointCastType ()
    {
    }

    // EdgePointTransformType
    //

    EdgePointTransformType::
    EdgePointTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEdgePoint_ (this),
      Transformation_ (this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (const BaseEdgePoint_type& BaseEdgePoint,
                            const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, this),
      Transformation_ (Transformation, this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (::std::unique_ptr< BaseEdgePoint_type > BaseEdgePoint,
                            ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEdgePoint_ (std::move (BaseEdgePoint), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (const EdgePointTransformType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseEdgePoint_ (x.BaseEdgePoint_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEdgePoint_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseEdgePoint
        //
        if (n.name () == L"BaseEdgePoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseEdgePoint_type > r (
            BaseEdgePoint_traits::create (i, f, this));

          if (!BaseEdgePoint_.present ())
          {
            this->BaseEdgePoint_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseEdgePoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseEdgePoint",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EdgePointTransformType* EdgePointTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointTransformType (*this, f, c);
    }

    EdgePointTransformType& EdgePointTransformType::
    operator= (const EdgePointTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEdgePoint_ = x.BaseEdgePoint_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    EdgePointTransformType::
    ~EdgePointTransformType ()
    {
    }

    // EdgePointFromScanType
    //

    EdgePointFromScanType::
    EdgePointFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      PatchRadius_ (this),
      Distance_ (this),
      Depth_ (this),
      RetrievalMethod_ (this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (const SurfaceFeature_type& SurfaceFeature,
                           const SearchRadius_type& SearchRadius,
                           const PatchRadius_type& PatchRadius,
                           const Distance_type& Distance,
                           const Depth_type& Depth,
                           const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      PatchRadius_ (PatchRadius, this),
      Distance_ (Distance, this),
      Depth_ (Depth, this),
      RetrievalMethod_ (RetrievalMethod, this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                           ::std::unique_ptr< SearchRadius_type > SearchRadius,
                           ::std::unique_ptr< PatchRadius_type > PatchRadius,
                           ::std::unique_ptr< Distance_type > Distance,
                           ::std::unique_ptr< Depth_type > Depth,
                           const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      PatchRadius_ (std::move (PatchRadius), this),
      Distance_ (std::move (Distance), this),
      Depth_ (std::move (Depth), this),
      RetrievalMethod_ (RetrievalMethod, this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (const EdgePointFromScanType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      PatchRadius_ (x.PatchRadius_, f, this),
      Distance_ (x.Distance_, f, this),
      Depth_ (x.Depth_, f, this),
      RetrievalMethod_ (x.RetrievalMethod_, f, this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      PatchRadius_ (this),
      Distance_ (this),
      Depth_ (this),
      RetrievalMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // PatchRadius
        //
        if (n.name () == L"PatchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PatchRadius_type > r (
            PatchRadius_traits::create (i, f, this));

          if (!PatchRadius_.present ())
          {
            this->PatchRadius_.set (::std::move (r));
            continue;
          }
        }

        // Distance
        //
        if (n.name () == L"Distance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        // RetrievalMethod
        //
        if (n.name () == L"RetrievalMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RetrievalMethod_type > r (
            RetrievalMethod_traits::create (i, f, this));

          if (!RetrievalMethod_.present ())
          {
            this->RetrievalMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PatchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PatchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Distance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Depth",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RetrievalMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RetrievalMethod",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EdgePointFromScanType* EdgePointFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFromScanType (*this, f, c);
    }

    EdgePointFromScanType& EdgePointFromScanType::
    operator= (const EdgePointFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->PatchRadius_ = x.PatchRadius_;
        this->Distance_ = x.Distance_;
        this->Depth_ = x.Depth_;
        this->RetrievalMethod_ = x.RetrievalMethod_;
      }

      return *this;
    }

    EdgePointFromScanType::
    ~EdgePointFromScanType ()
    {
    }

    // EdgePointCheckedType
    //

    EdgePointCheckedType::
    EdgePointCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    EdgePointCheckedType::
    EdgePointCheckedType (const EdgePointCheckedType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EdgePointCheckedType::
    EdgePointCheckedType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EdgePointCheckedType* EdgePointCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCheckedType (*this, f, c);
    }

    EdgePointCheckedType& EdgePointCheckedType::
    operator= (const EdgePointCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    EdgePointCheckedType::
    ~EdgePointCheckedType ()
    {
    }

    // EdgePointCheckedFeatureType
    //

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType (const EdgePointCheckedFeatureType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EdgePointCheckedFeatureType* EdgePointCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCheckedFeatureType (*this, f, c);
    }

    EdgePointCheckedFeatureType& EdgePointCheckedFeatureType::
    operator= (const EdgePointCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    EdgePointCheckedFeatureType::
    ~EdgePointCheckedFeatureType ()
    {
    }

    // EdgePointMeasurementDeterminationType
    //

    EdgePointMeasurementDeterminationType::
    EdgePointMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    EdgePointMeasurementDeterminationType::
    EdgePointMeasurementDeterminationType (const EdgePointMeasurementDeterminationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    EdgePointMeasurementDeterminationType::
    EdgePointMeasurementDeterminationType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EdgePointMeasurementDeterminationType* EdgePointMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointMeasurementDeterminationType (*this, f, c);
    }

    EdgePointMeasurementDeterminationType& EdgePointMeasurementDeterminationType::
    operator= (const EdgePointMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    EdgePointMeasurementDeterminationType::
    ~EdgePointMeasurementDeterminationType ()
    {
    }

    // EdgePointFeatureItemType
    //

    EdgePointFeatureItemType::
    EdgePointFeatureItemType ()
    : ::xsd::qif30::PointFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const id_type& id,
                              const FeatureNominalId_type& FeatureNominalId,
                              const FeatureName_type& FeatureName,
                              const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::PointFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const id_type& id,
                              ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                              const FeatureName_type& FeatureName,
                              ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::PointFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const EdgePointFeatureItemType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EdgePointFeatureItemType* EdgePointFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureItemType (*this, f, c);
    }

    EdgePointFeatureItemType& EdgePointFeatureItemType::
    operator= (const EdgePointFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    EdgePointFeatureItemType::
    ~EdgePointFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EdgePointFeatureItemType >
    _xsd_EdgePointFeatureItemType_type_factory_init (
      L"EdgePointFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // EdgePointFeatureDefinitionType
    //

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType ()
    : ::xsd::qif30::PointFeatureDefinitionBaseType (),
      InternalExternal_ (this)
    {
    }

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const id_type& id,
                                    const InternalExternal_type& InternalExternal)
    : ::xsd::qif30::PointFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this)
    {
    }

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const EdgePointFeatureDefinitionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this)
    {
    }

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EdgePointFeatureDefinitionType* EdgePointFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureDefinitionType (*this, f, c);
    }

    EdgePointFeatureDefinitionType& EdgePointFeatureDefinitionType::
    operator= (const EdgePointFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
      }

      return *this;
    }

    EdgePointFeatureDefinitionType::
    ~EdgePointFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EdgePointFeatureDefinitionType >
    _xsd_EdgePointFeatureDefinitionType_type_factory_init (
      L"EdgePointFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // EdgePointFeatureNominalType
    //

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType ()
    : ::xsd::qif30::PointFeatureNominalBaseType (),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this),
      Constructed_ (this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const id_type& id,
                                 const FeatureDefinitionId_type& FeatureDefinitionId,
                                 const Location_type& Location,
                                 const Normal_type& Normal)
    : ::xsd::qif30::PointFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this),
      AdjacentNormal_ (this),
      Constructed_ (this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const id_type& id,
                                 ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                 ::std::unique_ptr< Location_type > Location,
                                 ::std::unique_ptr< Normal_type > Normal)
    : ::xsd::qif30::PointFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      Normal_ (std::move (Normal), this),
      AdjacentNormal_ (this),
      Constructed_ (this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const EdgePointFeatureNominalType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      AdjacentNormal_ (x.AdjacentNormal_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // AdjacentNormal
        //
        if (n.name () == L"AdjacentNormal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AdjacentNormal_type > r (
            AdjacentNormal_traits::create (i, f, this));

          if (!this->AdjacentNormal_)
          {
            this->AdjacentNormal_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EdgePointFeatureNominalType* EdgePointFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureNominalType (*this, f, c);
    }

    EdgePointFeatureNominalType& EdgePointFeatureNominalType::
    operator= (const EdgePointFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->AdjacentNormal_ = x.AdjacentNormal_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    EdgePointFeatureNominalType::
    ~EdgePointFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EdgePointFeatureNominalType >
    _xsd_EdgePointFeatureNominalType_type_factory_init (
      L"EdgePointFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // EdgePointFeatureMeasurementType
    //

    EdgePointFeatureMeasurementType::
    EdgePointFeatureMeasurementType ()
    : ::xsd::qif30::PointFeatureMeasurementBaseType (),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this)
    {
    }

    EdgePointFeatureMeasurementType::
    EdgePointFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::PointFeatureMeasurementBaseType (id),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this)
    {
    }

    EdgePointFeatureMeasurementType::
    EdgePointFeatureMeasurementType (const EdgePointFeatureMeasurementType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      AdjacentNormal_ (x.AdjacentNormal_, f, this)
    {
    }

    EdgePointFeatureMeasurementType::
    EdgePointFeatureMeasurementType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // AdjacentNormal
        //
        if (n.name () == L"AdjacentNormal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AdjacentNormal_type > r (
            AdjacentNormal_traits::create (i, f, this));

          if (!this->AdjacentNormal_)
          {
            this->AdjacentNormal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EdgePointFeatureMeasurementType* EdgePointFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureMeasurementType (*this, f, c);
    }

    EdgePointFeatureMeasurementType& EdgePointFeatureMeasurementType::
    operator= (const EdgePointFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->AdjacentNormal_ = x.AdjacentNormal_;
      }

      return *this;
    }

    EdgePointFeatureMeasurementType::
    ~EdgePointFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EdgePointFeatureMeasurementType >
    _xsd_EdgePointFeatureMeasurementType_type_factory_init (
      L"EdgePointFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipseConstructionMethodType
    //

    EllipseConstructionMethodType::
    EllipseConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    EllipseConstructionMethodType::
    EllipseConstructionMethodType (const EllipseConstructionMethodType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    EllipseConstructionMethodType::
    EllipseConstructionMethodType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == L"Intersection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (::std::move (r));
            continue;
          }
        }

        // Projection
        //
        if (n.name () == L"Projection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipseConstructionMethodType* EllipseConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseConstructionMethodType (*this, f, c);
    }

    EllipseConstructionMethodType& EllipseConstructionMethodType::
    operator= (const EllipseConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    EllipseConstructionMethodType::
    ~EllipseConstructionMethodType ()
    {
    }

    // EllipseBestFitType
    //

    EllipseBestFitType::
    EllipseBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    EllipseBestFitType::
    EllipseBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    EllipseBestFitType::
    EllipseBestFitType (const EllipseBestFitType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    EllipseBestFitType::
    EllipseBestFitType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    EllipseBestFitType* EllipseBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseBestFitType (*this, f, c);
    }

    EllipseBestFitType& EllipseBestFitType::
    operator= (const EllipseBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    EllipseBestFitType::
    ~EllipseBestFitType ()
    {
    }

    // EllipseRecompType
    //

    EllipseRecompType::
    EllipseRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (const EllipseRecompType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseRecompType* EllipseRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseRecompType (*this, f, c);
    }

    EllipseRecompType& EllipseRecompType::
    operator= (const EllipseRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    EllipseRecompType::
    ~EllipseRecompType ()
    {
    }

    // EllipseProjectionType
    //

    EllipseProjectionType::
    EllipseProjectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionFeature_ (this),
      ProjectionPlane_ (this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (const ProjectionFeature_type& ProjectionFeature,
                           const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionFeature_ (ProjectionFeature, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (::std::unique_ptr< ProjectionFeature_type > ProjectionFeature,
                           ::std::unique_ptr< ProjectionPlane_type > ProjectionPlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionFeature_ (std::move (ProjectionFeature), this),
      ProjectionPlane_ (std::move (ProjectionPlane), this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (const EllipseProjectionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ProjectionFeature_ (x.ProjectionFeature_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionFeature_ (this),
      ProjectionPlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseProjectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProjectionFeature
        //
        if (n.name () == L"ProjectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionFeature_type > r (
            ProjectionFeature_traits::create (i, f, this));

          if (!ProjectionFeature_.present ())
          {
            this->ProjectionFeature_.set (::std::move (r));
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == L"ProjectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProjectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseProjectionType* EllipseProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseProjectionType (*this, f, c);
    }

    EllipseProjectionType& EllipseProjectionType::
    operator= (const EllipseProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionFeature_ = x.ProjectionFeature_;
        this->ProjectionPlane_ = x.ProjectionPlane_;
      }

      return *this;
    }

    EllipseProjectionType::
    ~EllipseProjectionType ()
    {
    }

    // EllipseIntersectionType
    //

    EllipseIntersectionType::
    EllipseIntersectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (const IntersectionPlane_type& IntersectionPlane,
                             const IntersectionFeature_type& IntersectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, this),
      IntersectionFeature_ (IntersectionFeature, this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (::std::unique_ptr< IntersectionPlane_type > IntersectionPlane,
                             ::std::unique_ptr< IntersectionFeature_type > IntersectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (std::move (IntersectionPlane), this),
      IntersectionFeature_ (std::move (IntersectionFeature), this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (const EllipseIntersectionType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      IntersectionPlane_ (x.IntersectionPlane_, f, this),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionPlane
        //
        if (n.name () == L"IntersectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionPlane_type > r (
            IntersectionPlane_traits::create (i, f, this));

          if (!IntersectionPlane_.present ())
          {
            this->IntersectionPlane_.set (::std::move (r));
            continue;
          }
        }

        // IntersectionFeature
        //
        if (n.name () == L"IntersectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          if (!IntersectionFeature_.present ())
          {
            this->IntersectionFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!IntersectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseIntersectionType* EllipseIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseIntersectionType (*this, f, c);
    }

    EllipseIntersectionType& EllipseIntersectionType::
    operator= (const EllipseIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionPlane_ = x.IntersectionPlane_;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    EllipseIntersectionType::
    ~EllipseIntersectionType ()
    {
    }

    // EllipseCopyType
    //

    EllipseCopyType::
    EllipseCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipse_ (this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (const BaseEllipse_type& BaseEllipse)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (::std::unique_ptr< BaseEllipse_type > BaseEllipse)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipse_ (std::move (BaseEllipse), this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (const EllipseCopyType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseEllipse_ (x.BaseEllipse_, f, this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEllipse_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseEllipse
        //
        if (n.name () == L"BaseEllipse" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseEllipse_type > r (
            BaseEllipse_traits::create (i, f, this));

          if (!BaseEllipse_.present ())
          {
            this->BaseEllipse_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseEllipse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseEllipse",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseCopyType* EllipseCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCopyType (*this, f, c);
    }

    EllipseCopyType& EllipseCopyType::
    operator= (const EllipseCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEllipse_ = x.BaseEllipse_;
      }

      return *this;
    }

    EllipseCopyType::
    ~EllipseCopyType ()
    {
    }

    // EllipseCastType
    //

    EllipseCastType::
    EllipseCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    EllipseCastType::
    EllipseCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    EllipseCastType::
    EllipseCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    EllipseCastType::
    EllipseCastType (const EllipseCastType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EllipseCastType::
    EllipseCastType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseCastType* EllipseCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCastType (*this, f, c);
    }

    EllipseCastType& EllipseCastType::
    operator= (const EllipseCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    EllipseCastType::
    ~EllipseCastType ()
    {
    }

    // EllipseTransformType
    //

    EllipseTransformType::
    EllipseTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipse_ (this),
      Transformation_ (this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (const BaseEllipse_type& BaseEllipse,
                          const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, this),
      Transformation_ (Transformation, this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (::std::unique_ptr< BaseEllipse_type > BaseEllipse,
                          ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipse_ (std::move (BaseEllipse), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (const EllipseTransformType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseEllipse_ (x.BaseEllipse_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEllipse_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseEllipse
        //
        if (n.name () == L"BaseEllipse" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseEllipse_type > r (
            BaseEllipse_traits::create (i, f, this));

          if (!BaseEllipse_.present ())
          {
            this->BaseEllipse_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseEllipse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseEllipse",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseTransformType* EllipseTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseTransformType (*this, f, c);
    }

    EllipseTransformType& EllipseTransformType::
    operator= (const EllipseTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEllipse_ = x.BaseEllipse_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    EllipseTransformType::
    ~EllipseTransformType ()
    {
    }

    // EllipseFromScanType
    //

    EllipseFromScanType::
    EllipseFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (const SurfaceFeature_type& SurfaceFeature,
                         const SearchRadius_type& SearchRadius,
                         const Depth_type& Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                         ::std::unique_ptr< SearchRadius_type > SearchRadius,
                         ::std::unique_ptr< Depth_type > Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      Depth_ (std::move (Depth), this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (const EllipseFromScanType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Depth",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseFromScanType* EllipseFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFromScanType (*this, f, c);
    }

    EllipseFromScanType& EllipseFromScanType::
    operator= (const EllipseFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    EllipseFromScanType::
    ~EllipseFromScanType ()
    {
    }

    // EllipseCheckedType
    //

    EllipseCheckedType::
    EllipseCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    EllipseCheckedType::
    EllipseCheckedType (const EllipseCheckedType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EllipseCheckedType::
    EllipseCheckedType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipseCheckedType* EllipseCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCheckedType (*this, f, c);
    }

    EllipseCheckedType& EllipseCheckedType::
    operator= (const EllipseCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    EllipseCheckedType::
    ~EllipseCheckedType ()
    {
    }

    // EllipseCheckedFeatureType
    //

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType (const EllipseCheckedFeatureType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipseCheckedFeatureType* EllipseCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCheckedFeatureType (*this, f, c);
    }

    EllipseCheckedFeatureType& EllipseCheckedFeatureType::
    operator= (const EllipseCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    EllipseCheckedFeatureType::
    ~EllipseCheckedFeatureType ()
    {
    }

    // EllipseMeasurementDeterminationType
    //

    EllipseMeasurementDeterminationType::
    EllipseMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    EllipseMeasurementDeterminationType::
    EllipseMeasurementDeterminationType (const EllipseMeasurementDeterminationType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    EllipseMeasurementDeterminationType::
    EllipseMeasurementDeterminationType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipseMeasurementDeterminationType* EllipseMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseMeasurementDeterminationType (*this, f, c);
    }

    EllipseMeasurementDeterminationType& EllipseMeasurementDeterminationType::
    operator= (const EllipseMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    EllipseMeasurementDeterminationType::
    ~EllipseMeasurementDeterminationType ()
    {
    }

    // EllipseFeatureItemType
    //

    EllipseFeatureItemType::
    EllipseFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const id_type& id,
                            const FeatureNominalId_type& FeatureNominalId,
                            const FeatureName_type& FeatureName,
                            const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const id_type& id,
                            ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                            const FeatureName_type& FeatureName,
                            ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const EllipseFeatureItemType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseFeatureItemType* EllipseFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureItemType (*this, f, c);
    }

    EllipseFeatureItemType& EllipseFeatureItemType::
    operator= (const EllipseFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    EllipseFeatureItemType::
    ~EllipseFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipseFeatureItemType >
    _xsd_EllipseFeatureItemType_type_factory_init (
      L"EllipseFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipseFeatureDefinitionType
    //

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const id_type& id,
                                  const InternalExternal_type& InternalExternal,
                                  const MajorDiameter_type& MajorDiameter,
                                  const MinorDiameter_type& MinorDiameter)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MajorDiameter_ (MajorDiameter, this),
      MinorDiameter_ (MinorDiameter, this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const id_type& id,
                                  const InternalExternal_type& InternalExternal,
                                  ::std::unique_ptr< MajorDiameter_type > MajorDiameter,
                                  ::std::unique_ptr< MinorDiameter_type > MinorDiameter)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MajorDiameter_ (std::move (MajorDiameter), this),
      MinorDiameter_ (std::move (MinorDiameter), this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const EllipseFeatureDefinitionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == L"MajorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == L"MinorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MajorDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinorDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseFeatureDefinitionType* EllipseFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureDefinitionType (*this, f, c);
    }

    EllipseFeatureDefinitionType& EllipseFeatureDefinitionType::
    operator= (const EllipseFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->MinorDiameter_ = x.MinorDiameter_;
      }

      return *this;
    }

    EllipseFeatureDefinitionType::
    ~EllipseFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipseFeatureDefinitionType >
    _xsd_EllipseFeatureDefinitionType_type_factory_init (
      L"EllipseFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipseFeatureNominalType
    //

    EllipseFeatureNominalType::
    EllipseFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      Axis_ (this),
      Normal_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               const Axis_type& Axis,
                               const Normal_type& Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Axis_ (Axis, this),
      Normal_ (Normal, this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const id_type& id,
                               ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                               ::std::unique_ptr< Axis_type > Axis,
                               ::std::unique_ptr< Normal_type > Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Axis_ (std::move (Axis), this),
      Normal_ (std::move (Normal), this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const EllipseFeatureNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Normal_ (x.Normal_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Normal_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipseFeatureNominalType* EllipseFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureNominalType (*this, f, c);
    }

    EllipseFeatureNominalType& EllipseFeatureNominalType::
    operator= (const EllipseFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Normal_ = x.Normal_;
        this->Sweep_ = x.Sweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    EllipseFeatureNominalType::
    ~EllipseFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipseFeatureNominalType >
    _xsd_EllipseFeatureNominalType_type_factory_init (
      L"EllipseFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipseFeatureMeasurementType
    //

    EllipseFeatureMeasurementType::
    EllipseFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      Axis_ (this),
      Normal_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
    }

    EllipseFeatureMeasurementType::
    EllipseFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      Axis_ (this),
      Normal_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
    }

    EllipseFeatureMeasurementType::
    EllipseFeatureMeasurementType (const EllipseFeatureMeasurementType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Normal_ (x.Normal_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    EllipseFeatureMeasurementType::
    EllipseFeatureMeasurementType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Normal_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == L"MajorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == L"MinorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipseFeatureMeasurementType* EllipseFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureMeasurementType (*this, f, c);
    }

    EllipseFeatureMeasurementType& EllipseFeatureMeasurementType::
    operator= (const EllipseFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Normal_ = x.Normal_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    EllipseFeatureMeasurementType::
    ~EllipseFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipseFeatureMeasurementType >
    _xsd_EllipseFeatureMeasurementType_type_factory_init (
      L"EllipseFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipticalArcConstructionMethodType
    //

    EllipticalArcConstructionMethodType::
    EllipticalArcConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    EllipticalArcConstructionMethodType::
    EllipticalArcConstructionMethodType (const EllipticalArcConstructionMethodType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    EllipticalArcConstructionMethodType::
    EllipticalArcConstructionMethodType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == L"Intersection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (::std::move (r));
            continue;
          }
        }

        // Projection
        //
        if (n.name () == L"Projection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipticalArcConstructionMethodType* EllipticalArcConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcConstructionMethodType (*this, f, c);
    }

    EllipticalArcConstructionMethodType& EllipticalArcConstructionMethodType::
    operator= (const EllipticalArcConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    EllipticalArcConstructionMethodType::
    ~EllipticalArcConstructionMethodType ()
    {
    }

    // EllipticalArcBestFitType
    //

    EllipticalArcBestFitType::
    EllipticalArcBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    EllipticalArcBestFitType::
    EllipticalArcBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    EllipticalArcBestFitType::
    EllipticalArcBestFitType (const EllipticalArcBestFitType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    EllipticalArcBestFitType::
    EllipticalArcBestFitType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipticalArcBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    EllipticalArcBestFitType* EllipticalArcBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcBestFitType (*this, f, c);
    }

    EllipticalArcBestFitType& EllipticalArcBestFitType::
    operator= (const EllipticalArcBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    EllipticalArcBestFitType::
    ~EllipticalArcBestFitType ()
    {
    }

    // EllipticalArcRecompType
    //

    EllipticalArcRecompType::
    EllipticalArcRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    EllipticalArcRecompType::
    EllipticalArcRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    EllipticalArcRecompType::
    EllipticalArcRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    EllipticalArcRecompType::
    EllipticalArcRecompType (const EllipticalArcRecompType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    EllipticalArcRecompType::
    EllipticalArcRecompType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcRecompType* EllipticalArcRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcRecompType (*this, f, c);
    }

    EllipticalArcRecompType& EllipticalArcRecompType::
    operator= (const EllipticalArcRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    EllipticalArcRecompType::
    ~EllipticalArcRecompType ()
    {
    }

    // EllipticalArcProjectionType
    //

    EllipticalArcProjectionType::
    EllipticalArcProjectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionFeature_ (this),
      ProjectionPlane_ (this)
    {
    }

    EllipticalArcProjectionType::
    EllipticalArcProjectionType (const ProjectionFeature_type& ProjectionFeature,
                                 const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionFeature_ (ProjectionFeature, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    EllipticalArcProjectionType::
    EllipticalArcProjectionType (::std::unique_ptr< ProjectionFeature_type > ProjectionFeature,
                                 ::std::unique_ptr< ProjectionPlane_type > ProjectionPlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionFeature_ (std::move (ProjectionFeature), this),
      ProjectionPlane_ (std::move (ProjectionPlane), this)
    {
    }

    EllipticalArcProjectionType::
    EllipticalArcProjectionType (const EllipticalArcProjectionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ProjectionFeature_ (x.ProjectionFeature_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    EllipticalArcProjectionType::
    EllipticalArcProjectionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionFeature_ (this),
      ProjectionPlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcProjectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProjectionFeature
        //
        if (n.name () == L"ProjectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionFeature_type > r (
            ProjectionFeature_traits::create (i, f, this));

          if (!ProjectionFeature_.present ())
          {
            this->ProjectionFeature_.set (::std::move (r));
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == L"ProjectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProjectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcProjectionType* EllipticalArcProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcProjectionType (*this, f, c);
    }

    EllipticalArcProjectionType& EllipticalArcProjectionType::
    operator= (const EllipticalArcProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionFeature_ = x.ProjectionFeature_;
        this->ProjectionPlane_ = x.ProjectionPlane_;
      }

      return *this;
    }

    EllipticalArcProjectionType::
    ~EllipticalArcProjectionType ()
    {
    }

    // EllipticalArcIntersectionType
    //

    EllipticalArcIntersectionType::
    EllipticalArcIntersectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
    }

    EllipticalArcIntersectionType::
    EllipticalArcIntersectionType (const IntersectionPlane_type& IntersectionPlane,
                                   const IntersectionFeature_type& IntersectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, this),
      IntersectionFeature_ (IntersectionFeature, this)
    {
    }

    EllipticalArcIntersectionType::
    EllipticalArcIntersectionType (::std::unique_ptr< IntersectionPlane_type > IntersectionPlane,
                                   ::std::unique_ptr< IntersectionFeature_type > IntersectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (std::move (IntersectionPlane), this),
      IntersectionFeature_ (std::move (IntersectionFeature), this)
    {
    }

    EllipticalArcIntersectionType::
    EllipticalArcIntersectionType (const EllipticalArcIntersectionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      IntersectionPlane_ (x.IntersectionPlane_, f, this),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    EllipticalArcIntersectionType::
    EllipticalArcIntersectionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionPlane
        //
        if (n.name () == L"IntersectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionPlane_type > r (
            IntersectionPlane_traits::create (i, f, this));

          if (!IntersectionPlane_.present ())
          {
            this->IntersectionPlane_.set (::std::move (r));
            continue;
          }
        }

        // IntersectionFeature
        //
        if (n.name () == L"IntersectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          if (!IntersectionFeature_.present ())
          {
            this->IntersectionFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!IntersectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcIntersectionType* EllipticalArcIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcIntersectionType (*this, f, c);
    }

    EllipticalArcIntersectionType& EllipticalArcIntersectionType::
    operator= (const EllipticalArcIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionPlane_ = x.IntersectionPlane_;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    EllipticalArcIntersectionType::
    ~EllipticalArcIntersectionType ()
    {
    }

    // EllipticalArcCopyType
    //

    EllipticalArcCopyType::
    EllipticalArcCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipticalArc_ (this)
    {
    }

    EllipticalArcCopyType::
    EllipticalArcCopyType (const BaseEllipticalArc_type& BaseEllipticalArc)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipticalArc_ (BaseEllipticalArc, this)
    {
    }

    EllipticalArcCopyType::
    EllipticalArcCopyType (::std::unique_ptr< BaseEllipticalArc_type > BaseEllipticalArc)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipticalArc_ (std::move (BaseEllipticalArc), this)
    {
    }

    EllipticalArcCopyType::
    EllipticalArcCopyType (const EllipticalArcCopyType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseEllipticalArc_ (x.BaseEllipticalArc_, f, this)
    {
    }

    EllipticalArcCopyType::
    EllipticalArcCopyType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEllipticalArc_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseEllipticalArc
        //
        if (n.name () == L"BaseEllipticalArc" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseEllipticalArc_type > r (
            BaseEllipticalArc_traits::create (i, f, this));

          if (!BaseEllipticalArc_.present ())
          {
            this->BaseEllipticalArc_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseEllipticalArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseEllipticalArc",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcCopyType* EllipticalArcCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcCopyType (*this, f, c);
    }

    EllipticalArcCopyType& EllipticalArcCopyType::
    operator= (const EllipticalArcCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEllipticalArc_ = x.BaseEllipticalArc_;
      }

      return *this;
    }

    EllipticalArcCopyType::
    ~EllipticalArcCopyType ()
    {
    }

    // EllipticalArcCastType
    //

    EllipticalArcCastType::
    EllipticalArcCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    EllipticalArcCastType::
    EllipticalArcCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    EllipticalArcCastType::
    EllipticalArcCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    EllipticalArcCastType::
    EllipticalArcCastType (const EllipticalArcCastType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EllipticalArcCastType::
    EllipticalArcCastType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcCastType* EllipticalArcCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcCastType (*this, f, c);
    }

    EllipticalArcCastType& EllipticalArcCastType::
    operator= (const EllipticalArcCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    EllipticalArcCastType::
    ~EllipticalArcCastType ()
    {
    }

    // EllipticalArcTransformType
    //

    EllipticalArcTransformType::
    EllipticalArcTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipticalArc_ (this),
      Transformation_ (this)
    {
    }

    EllipticalArcTransformType::
    EllipticalArcTransformType (const BaseEllipticalArc_type& BaseEllipticalArc,
                                const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipticalArc_ (BaseEllipticalArc, this),
      Transformation_ (Transformation, this)
    {
    }

    EllipticalArcTransformType::
    EllipticalArcTransformType (::std::unique_ptr< BaseEllipticalArc_type > BaseEllipticalArc,
                                ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseEllipticalArc_ (std::move (BaseEllipticalArc), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    EllipticalArcTransformType::
    EllipticalArcTransformType (const EllipticalArcTransformType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseEllipticalArc_ (x.BaseEllipticalArc_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    EllipticalArcTransformType::
    EllipticalArcTransformType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEllipticalArc_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseEllipticalArc
        //
        if (n.name () == L"BaseEllipticalArc" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseEllipticalArc_type > r (
            BaseEllipticalArc_traits::create (i, f, this));

          if (!BaseEllipticalArc_.present ())
          {
            this->BaseEllipticalArc_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseEllipticalArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseEllipticalArc",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcTransformType* EllipticalArcTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcTransformType (*this, f, c);
    }

    EllipticalArcTransformType& EllipticalArcTransformType::
    operator= (const EllipticalArcTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEllipticalArc_ = x.BaseEllipticalArc_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    EllipticalArcTransformType::
    ~EllipticalArcTransformType ()
    {
    }

    // EllipticalArcFromScanType
    //

    EllipticalArcFromScanType::
    EllipticalArcFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
    }

    EllipticalArcFromScanType::
    EllipticalArcFromScanType (const SurfaceFeature_type& SurfaceFeature,
                               const SearchRadius_type& SearchRadius,
                               const Depth_type& Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    EllipticalArcFromScanType::
    EllipticalArcFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                               ::std::unique_ptr< SearchRadius_type > SearchRadius,
                               ::std::unique_ptr< Depth_type > Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      Depth_ (std::move (Depth), this)
    {
    }

    EllipticalArcFromScanType::
    EllipticalArcFromScanType (const EllipticalArcFromScanType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    EllipticalArcFromScanType::
    EllipticalArcFromScanType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Depth",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcFromScanType* EllipticalArcFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcFromScanType (*this, f, c);
    }

    EllipticalArcFromScanType& EllipticalArcFromScanType::
    operator= (const EllipticalArcFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    EllipticalArcFromScanType::
    ~EllipticalArcFromScanType ()
    {
    }

    // EllipticalArcCheckedType
    //

    EllipticalArcCheckedType::
    EllipticalArcCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    EllipticalArcCheckedType::
    EllipticalArcCheckedType (const EllipticalArcCheckedType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EllipticalArcCheckedType::
    EllipticalArcCheckedType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipticalArcCheckedType* EllipticalArcCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcCheckedType (*this, f, c);
    }

    EllipticalArcCheckedType& EllipticalArcCheckedType::
    operator= (const EllipticalArcCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    EllipticalArcCheckedType::
    ~EllipticalArcCheckedType ()
    {
    }

    // EllipticalArcCheckedFeatureType
    //

    EllipticalArcCheckedFeatureType::
    EllipticalArcCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    EllipticalArcCheckedFeatureType::
    EllipticalArcCheckedFeatureType (const EllipticalArcCheckedFeatureType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    EllipticalArcCheckedFeatureType::
    EllipticalArcCheckedFeatureType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipticalArcCheckedFeatureType* EllipticalArcCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcCheckedFeatureType (*this, f, c);
    }

    EllipticalArcCheckedFeatureType& EllipticalArcCheckedFeatureType::
    operator= (const EllipticalArcCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    EllipticalArcCheckedFeatureType::
    ~EllipticalArcCheckedFeatureType ()
    {
    }

    // EllipticalArcMeasurementDeterminationType
    //

    EllipticalArcMeasurementDeterminationType::
    EllipticalArcMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    EllipticalArcMeasurementDeterminationType::
    EllipticalArcMeasurementDeterminationType (const EllipticalArcMeasurementDeterminationType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    EllipticalArcMeasurementDeterminationType::
    EllipticalArcMeasurementDeterminationType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipticalArcMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipticalArcMeasurementDeterminationType* EllipticalArcMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcMeasurementDeterminationType (*this, f, c);
    }

    EllipticalArcMeasurementDeterminationType& EllipticalArcMeasurementDeterminationType::
    operator= (const EllipticalArcMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    EllipticalArcMeasurementDeterminationType::
    ~EllipticalArcMeasurementDeterminationType ()
    {
    }

    // EllipticalArcFeatureItemType
    //

    EllipticalArcFeatureItemType::
    EllipticalArcFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    EllipticalArcFeatureItemType::
    EllipticalArcFeatureItemType (const id_type& id,
                                  const FeatureNominalId_type& FeatureNominalId,
                                  const FeatureName_type& FeatureName,
                                  const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    EllipticalArcFeatureItemType::
    EllipticalArcFeatureItemType (const id_type& id,
                                  ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                  const FeatureName_type& FeatureName,
                                  ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    EllipticalArcFeatureItemType::
    EllipticalArcFeatureItemType (const EllipticalArcFeatureItemType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    EllipticalArcFeatureItemType::
    EllipticalArcFeatureItemType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipticalArcFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcFeatureItemType* EllipticalArcFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcFeatureItemType (*this, f, c);
    }

    EllipticalArcFeatureItemType& EllipticalArcFeatureItemType::
    operator= (const EllipticalArcFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    EllipticalArcFeatureItemType::
    ~EllipticalArcFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipticalArcFeatureItemType >
    _xsd_EllipticalArcFeatureItemType_type_factory_init (
      L"EllipticalArcFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipticalArcFeatureDefinitionType
    //

    EllipticalArcFeatureDefinitionType::
    EllipticalArcFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this)
    {
    }

    EllipticalArcFeatureDefinitionType::
    EllipticalArcFeatureDefinitionType (const id_type& id,
                                        const InternalExternal_type& InternalExternal,
                                        const MajorDiameter_type& MajorDiameter,
                                        const MinorDiameter_type& MinorDiameter)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MajorDiameter_ (MajorDiameter, this),
      MinorDiameter_ (MinorDiameter, this)
    {
    }

    EllipticalArcFeatureDefinitionType::
    EllipticalArcFeatureDefinitionType (const id_type& id,
                                        const InternalExternal_type& InternalExternal,
                                        ::std::unique_ptr< MajorDiameter_type > MajorDiameter,
                                        ::std::unique_ptr< MinorDiameter_type > MinorDiameter)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MajorDiameter_ (std::move (MajorDiameter), this),
      MinorDiameter_ (std::move (MinorDiameter), this)
    {
    }

    EllipticalArcFeatureDefinitionType::
    EllipticalArcFeatureDefinitionType (const EllipticalArcFeatureDefinitionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this)
    {
    }

    EllipticalArcFeatureDefinitionType::
    EllipticalArcFeatureDefinitionType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipticalArcFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == L"MajorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == L"MinorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MajorDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinorDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcFeatureDefinitionType* EllipticalArcFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcFeatureDefinitionType (*this, f, c);
    }

    EllipticalArcFeatureDefinitionType& EllipticalArcFeatureDefinitionType::
    operator= (const EllipticalArcFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->MinorDiameter_ = x.MinorDiameter_;
      }

      return *this;
    }

    EllipticalArcFeatureDefinitionType::
    ~EllipticalArcFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipticalArcFeatureDefinitionType >
    _xsd_EllipticalArcFeatureDefinitionType_type_factory_init (
      L"EllipticalArcFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipticalArcFeatureNominalType
    //

    EllipticalArcFeatureNominalType::
    EllipticalArcFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      Axis_ (this),
      Normal_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
    }

    EllipticalArcFeatureNominalType::
    EllipticalArcFeatureNominalType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     const Axis_type& Axis,
                                     const Normal_type& Normal,
                                     const Sweep_type& Sweep)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Axis_ (Axis, this),
      Normal_ (Normal, this),
      Sweep_ (Sweep, this),
      Constructed_ (this)
    {
    }

    EllipticalArcFeatureNominalType::
    EllipticalArcFeatureNominalType (const id_type& id,
                                     ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                     ::std::unique_ptr< Axis_type > Axis,
                                     ::std::unique_ptr< Normal_type > Normal,
                                     ::std::unique_ptr< Sweep_type > Sweep)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Axis_ (std::move (Axis), this),
      Normal_ (std::move (Normal), this),
      Sweep_ (std::move (Sweep), this),
      Constructed_ (this)
    {
    }

    EllipticalArcFeatureNominalType::
    EllipticalArcFeatureNominalType (const EllipticalArcFeatureNominalType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Normal_ (x.Normal_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EllipticalArcFeatureNominalType::
    EllipticalArcFeatureNominalType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Normal_ (this),
      Sweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipticalArcFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Sweep",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    EllipticalArcFeatureNominalType* EllipticalArcFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcFeatureNominalType (*this, f, c);
    }

    EllipticalArcFeatureNominalType& EllipticalArcFeatureNominalType::
    operator= (const EllipticalArcFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Normal_ = x.Normal_;
        this->Sweep_ = x.Sweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    EllipticalArcFeatureNominalType::
    ~EllipticalArcFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipticalArcFeatureNominalType >
    _xsd_EllipticalArcFeatureNominalType_type_factory_init (
      L"EllipticalArcFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // EllipticalArcFeatureMeasurementType
    //

    EllipticalArcFeatureMeasurementType::
    EllipticalArcFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      Axis_ (this),
      Normal_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
    }

    EllipticalArcFeatureMeasurementType::
    EllipticalArcFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      Axis_ (this),
      Normal_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
    }

    EllipticalArcFeatureMeasurementType::
    EllipticalArcFeatureMeasurementType (const EllipticalArcFeatureMeasurementType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Normal_ (x.Normal_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    EllipticalArcFeatureMeasurementType::
    EllipticalArcFeatureMeasurementType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Normal_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipticalArcFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == L"MajorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == L"MinorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    EllipticalArcFeatureMeasurementType* EllipticalArcFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipticalArcFeatureMeasurementType (*this, f, c);
    }

    EllipticalArcFeatureMeasurementType& EllipticalArcFeatureMeasurementType::
    operator= (const EllipticalArcFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Normal_ = x.Normal_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    EllipticalArcFeatureMeasurementType::
    ~EllipticalArcFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EllipticalArcFeatureMeasurementType >
    _xsd_EllipticalArcFeatureMeasurementType_type_factory_init (
      L"EllipticalArcFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCircleConstructionMethodType
    //

    ElongatedCircleConstructionMethodType::
    ElongatedCircleConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ElongatedCircleConstructionMethodType::
    ElongatedCircleConstructionMethodType (const ElongatedCircleConstructionMethodType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ElongatedCircleConstructionMethodType::
    ElongatedCircleConstructionMethodType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCircleConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCircleConstructionMethodType* ElongatedCircleConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleConstructionMethodType (*this, f, c);
    }

    ElongatedCircleConstructionMethodType& ElongatedCircleConstructionMethodType::
    operator= (const ElongatedCircleConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ElongatedCircleConstructionMethodType::
    ~ElongatedCircleConstructionMethodType ()
    {
    }

    // ElongatedCircleBestFitType
    //

    ElongatedCircleBestFitType::
    ElongatedCircleBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    ElongatedCircleBestFitType::
    ElongatedCircleBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    ElongatedCircleBestFitType::
    ElongatedCircleBestFitType (const ElongatedCircleBestFitType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ElongatedCircleBestFitType::
    ElongatedCircleBestFitType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCircleBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ElongatedCircleBestFitType* ElongatedCircleBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleBestFitType (*this, f, c);
    }

    ElongatedCircleBestFitType& ElongatedCircleBestFitType::
    operator= (const ElongatedCircleBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ElongatedCircleBestFitType::
    ~ElongatedCircleBestFitType ()
    {
    }

    // ElongatedCircleRecompType
    //

    ElongatedCircleRecompType::
    ElongatedCircleRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    ElongatedCircleRecompType::
    ElongatedCircleRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ElongatedCircleRecompType::
    ElongatedCircleRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    ElongatedCircleRecompType::
    ElongatedCircleRecompType (const ElongatedCircleRecompType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ElongatedCircleRecompType::
    ElongatedCircleRecompType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCircleRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCircleRecompType* ElongatedCircleRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleRecompType (*this, f, c);
    }

    ElongatedCircleRecompType& ElongatedCircleRecompType::
    operator= (const ElongatedCircleRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ElongatedCircleRecompType::
    ~ElongatedCircleRecompType ()
    {
    }

    // ElongatedCircleCopyType
    //

    ElongatedCircleCopyType::
    ElongatedCircleCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCircle_ (this)
    {
    }

    ElongatedCircleCopyType::
    ElongatedCircleCopyType (const BaseElongatedCircle_type& BaseElongatedCircle)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCircle_ (BaseElongatedCircle, this)
    {
    }

    ElongatedCircleCopyType::
    ElongatedCircleCopyType (::std::unique_ptr< BaseElongatedCircle_type > BaseElongatedCircle)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCircle_ (std::move (BaseElongatedCircle), this)
    {
    }

    ElongatedCircleCopyType::
    ElongatedCircleCopyType (const ElongatedCircleCopyType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseElongatedCircle_ (x.BaseElongatedCircle_, f, this)
    {
    }

    ElongatedCircleCopyType::
    ElongatedCircleCopyType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseElongatedCircle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCircleCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseElongatedCircle
        //
        if (n.name () == L"BaseElongatedCircle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseElongatedCircle_type > r (
            BaseElongatedCircle_traits::create (i, f, this));

          if (!BaseElongatedCircle_.present ())
          {
            this->BaseElongatedCircle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseElongatedCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseElongatedCircle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCircleCopyType* ElongatedCircleCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleCopyType (*this, f, c);
    }

    ElongatedCircleCopyType& ElongatedCircleCopyType::
    operator= (const ElongatedCircleCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseElongatedCircle_ = x.BaseElongatedCircle_;
      }

      return *this;
    }

    ElongatedCircleCopyType::
    ~ElongatedCircleCopyType ()
    {
    }

    // ElongatedCircleCastType
    //

    ElongatedCircleCastType::
    ElongatedCircleCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ElongatedCircleCastType::
    ElongatedCircleCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ElongatedCircleCastType::
    ElongatedCircleCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    ElongatedCircleCastType::
    ElongatedCircleCastType (const ElongatedCircleCastType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ElongatedCircleCastType::
    ElongatedCircleCastType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCircleCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCircleCastType* ElongatedCircleCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleCastType (*this, f, c);
    }

    ElongatedCircleCastType& ElongatedCircleCastType::
    operator= (const ElongatedCircleCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ElongatedCircleCastType::
    ~ElongatedCircleCastType ()
    {
    }

    // ElongatedCircleTransformType
    //

    ElongatedCircleTransformType::
    ElongatedCircleTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCircle_ (this),
      Transformation_ (this)
    {
    }

    ElongatedCircleTransformType::
    ElongatedCircleTransformType (const BaseElongatedCircle_type& BaseElongatedCircle,
                                  const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCircle_ (BaseElongatedCircle, this),
      Transformation_ (Transformation, this)
    {
    }

    ElongatedCircleTransformType::
    ElongatedCircleTransformType (::std::unique_ptr< BaseElongatedCircle_type > BaseElongatedCircle,
                                  ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCircle_ (std::move (BaseElongatedCircle), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    ElongatedCircleTransformType::
    ElongatedCircleTransformType (const ElongatedCircleTransformType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseElongatedCircle_ (x.BaseElongatedCircle_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ElongatedCircleTransformType::
    ElongatedCircleTransformType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseElongatedCircle_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCircleTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseElongatedCircle
        //
        if (n.name () == L"BaseElongatedCircle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseElongatedCircle_type > r (
            BaseElongatedCircle_traits::create (i, f, this));

          if (!BaseElongatedCircle_.present ())
          {
            this->BaseElongatedCircle_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseElongatedCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseElongatedCircle",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCircleTransformType* ElongatedCircleTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleTransformType (*this, f, c);
    }

    ElongatedCircleTransformType& ElongatedCircleTransformType::
    operator= (const ElongatedCircleTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseElongatedCircle_ = x.BaseElongatedCircle_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ElongatedCircleTransformType::
    ~ElongatedCircleTransformType ()
    {
    }

    // ElongatedCircleCheckedType
    //

    ElongatedCircleCheckedType::
    ElongatedCircleCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ElongatedCircleCheckedType::
    ElongatedCircleCheckedType (const ElongatedCircleCheckedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ElongatedCircleCheckedType::
    ElongatedCircleCheckedType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCircleCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCircleCheckedType* ElongatedCircleCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleCheckedType (*this, f, c);
    }

    ElongatedCircleCheckedType& ElongatedCircleCheckedType::
    operator= (const ElongatedCircleCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ElongatedCircleCheckedType::
    ~ElongatedCircleCheckedType ()
    {
    }

    // ElongatedCircleCheckedFeatureType
    //

    ElongatedCircleCheckedFeatureType::
    ElongatedCircleCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ElongatedCircleCheckedFeatureType::
    ElongatedCircleCheckedFeatureType (const ElongatedCircleCheckedFeatureType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ElongatedCircleCheckedFeatureType::
    ElongatedCircleCheckedFeatureType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCircleCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCircleCheckedFeatureType* ElongatedCircleCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleCheckedFeatureType (*this, f, c);
    }

    ElongatedCircleCheckedFeatureType& ElongatedCircleCheckedFeatureType::
    operator= (const ElongatedCircleCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ElongatedCircleCheckedFeatureType::
    ~ElongatedCircleCheckedFeatureType ()
    {
    }

    // ElongatedCircleMeasurementDeterminationType
    //

    ElongatedCircleMeasurementDeterminationType::
    ElongatedCircleMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ElongatedCircleMeasurementDeterminationType::
    ElongatedCircleMeasurementDeterminationType (const ElongatedCircleMeasurementDeterminationType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ElongatedCircleMeasurementDeterminationType::
    ElongatedCircleMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCircleMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCircleMeasurementDeterminationType* ElongatedCircleMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleMeasurementDeterminationType (*this, f, c);
    }

    ElongatedCircleMeasurementDeterminationType& ElongatedCircleMeasurementDeterminationType::
    operator= (const ElongatedCircleMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ElongatedCircleMeasurementDeterminationType::
    ~ElongatedCircleMeasurementDeterminationType ()
    {
    }

    // ElongatedCircleFeatureItemType
    //

    ElongatedCircleFeatureItemType::
    ElongatedCircleFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    ElongatedCircleFeatureItemType::
    ElongatedCircleFeatureItemType (const id_type& id,
                                    const FeatureNominalId_type& FeatureNominalId,
                                    const FeatureName_type& FeatureName,
                                    const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    ElongatedCircleFeatureItemType::
    ElongatedCircleFeatureItemType (const id_type& id,
                                    ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                    const FeatureName_type& FeatureName,
                                    ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    ElongatedCircleFeatureItemType::
    ElongatedCircleFeatureItemType (const ElongatedCircleFeatureItemType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    ElongatedCircleFeatureItemType::
    ElongatedCircleFeatureItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCircleFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCircleFeatureItemType* ElongatedCircleFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleFeatureItemType (*this, f, c);
    }

    ElongatedCircleFeatureItemType& ElongatedCircleFeatureItemType::
    operator= (const ElongatedCircleFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    ElongatedCircleFeatureItemType::
    ~ElongatedCircleFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ElongatedCircleFeatureItemType >
    _xsd_ElongatedCircleFeatureItemType_type_factory_init (
      L"ElongatedCircleFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCircleFeatureDefinitionType
    //

    ElongatedCircleFeatureDefinitionType::
    ElongatedCircleFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this)
    {
    }

    ElongatedCircleFeatureDefinitionType::
    ElongatedCircleFeatureDefinitionType (const id_type& id,
                                          const InternalExternal_type& InternalExternal,
                                          const Diameter_type& Diameter,
                                          const Length_type& Length)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (Length, this)
    {
    }

    ElongatedCircleFeatureDefinitionType::
    ElongatedCircleFeatureDefinitionType (const id_type& id,
                                          const InternalExternal_type& InternalExternal,
                                          ::std::unique_ptr< Diameter_type > Diameter,
                                          ::std::unique_ptr< Length_type > Length)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this),
      Length_ (std::move (Length), this)
    {
    }

    ElongatedCircleFeatureDefinitionType::
    ElongatedCircleFeatureDefinitionType (const ElongatedCircleFeatureDefinitionType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    ElongatedCircleFeatureDefinitionType::
    ElongatedCircleFeatureDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCircleFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCircleFeatureDefinitionType* ElongatedCircleFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleFeatureDefinitionType (*this, f, c);
    }

    ElongatedCircleFeatureDefinitionType& ElongatedCircleFeatureDefinitionType::
    operator= (const ElongatedCircleFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    ElongatedCircleFeatureDefinitionType::
    ~ElongatedCircleFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ElongatedCircleFeatureDefinitionType >
    _xsd_ElongatedCircleFeatureDefinitionType_type_factory_init (
      L"ElongatedCircleFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCircleFeatureNominalType
    //

    ElongatedCircleFeatureNominalType::
    ElongatedCircleFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      CenterLine_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    ElongatedCircleFeatureNominalType::
    ElongatedCircleFeatureNominalType (const id_type& id,
                                       const FeatureDefinitionId_type& FeatureDefinitionId,
                                       const CenterLine_type& CenterLine,
                                       const Normal_type& Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      CenterLine_ (CenterLine, this),
      Normal_ (Normal, this),
      Constructed_ (this)
    {
    }

    ElongatedCircleFeatureNominalType::
    ElongatedCircleFeatureNominalType (const id_type& id,
                                       ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                       ::std::unique_ptr< CenterLine_type > CenterLine,
                                       ::std::unique_ptr< Normal_type > Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      CenterLine_ (std::move (CenterLine), this),
      Normal_ (std::move (Normal), this),
      Constructed_ (this)
    {
    }

    ElongatedCircleFeatureNominalType::
    ElongatedCircleFeatureNominalType (const ElongatedCircleFeatureNominalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ElongatedCircleFeatureNominalType::
    ElongatedCircleFeatureNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCircleFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterLine
        //
        if (n.name () == L"CenterLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!CenterLine_.present ())
          {
            this->CenterLine_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterLine",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCircleFeatureNominalType* ElongatedCircleFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleFeatureNominalType (*this, f, c);
    }

    ElongatedCircleFeatureNominalType& ElongatedCircleFeatureNominalType::
    operator= (const ElongatedCircleFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->CenterLine_ = x.CenterLine_;
        this->Normal_ = x.Normal_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ElongatedCircleFeatureNominalType::
    ~ElongatedCircleFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ElongatedCircleFeatureNominalType >
    _xsd_ElongatedCircleFeatureNominalType_type_factory_init (
      L"ElongatedCircleFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCircleFeatureMeasurementType
    //

    ElongatedCircleFeatureMeasurementType::
    ElongatedCircleFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterLine_ (this),
      Normal_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Form_ (this)
    {
    }

    ElongatedCircleFeatureMeasurementType::
    ElongatedCircleFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterLine_ (this),
      Normal_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Form_ (this)
    {
    }

    ElongatedCircleFeatureMeasurementType::
    ElongatedCircleFeatureMeasurementType (const ElongatedCircleFeatureMeasurementType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this),
      Length_ (x.Length_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ElongatedCircleFeatureMeasurementType::
    ElongatedCircleFeatureMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterLine_ (this),
      Normal_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCircleFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // CenterLine
        //
        if (n.name () == L"CenterLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!this->CenterLine_)
          {
            this->CenterLine_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == L"LengthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (::std::move (r));
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == L"LengthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCircleFeatureMeasurementType* ElongatedCircleFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCircleFeatureMeasurementType (*this, f, c);
    }

    ElongatedCircleFeatureMeasurementType& ElongatedCircleFeatureMeasurementType::
    operator= (const ElongatedCircleFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->CenterLine_ = x.CenterLine_;
        this->Normal_ = x.Normal_;
        this->Length_ = x.Length_;
        this->LengthMax_ = x.LengthMax_;
        this->LengthMin_ = x.LengthMin_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ElongatedCircleFeatureMeasurementType::
    ~ElongatedCircleFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ElongatedCircleFeatureMeasurementType >
    _xsd_ElongatedCircleFeatureMeasurementType_type_factory_init (
      L"ElongatedCircleFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCylinderConstructionMethodType
    //

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType (const ElongatedCylinderConstructionMethodType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderConstructionMethodType* ElongatedCylinderConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderConstructionMethodType (*this, f, c);
    }

    ElongatedCylinderConstructionMethodType& ElongatedCylinderConstructionMethodType::
    operator= (const ElongatedCylinderConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ElongatedCylinderConstructionMethodType::
    ~ElongatedCylinderConstructionMethodType ()
    {
    }

    // ElongatedCylinderBestFitType
    //

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType (const ElongatedCylinderBestFitType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ElongatedCylinderBestFitType* ElongatedCylinderBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderBestFitType (*this, f, c);
    }

    ElongatedCylinderBestFitType& ElongatedCylinderBestFitType::
    operator= (const ElongatedCylinderBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ElongatedCylinderBestFitType::
    ~ElongatedCylinderBestFitType ()
    {
    }

    // ElongatedCylinderRecompType
    //

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const ElongatedCylinderRecompType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCylinderRecompType* ElongatedCylinderRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderRecompType (*this, f, c);
    }

    ElongatedCylinderRecompType& ElongatedCylinderRecompType::
    operator= (const ElongatedCylinderRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ElongatedCylinderRecompType::
    ~ElongatedCylinderRecompType ()
    {
    }

    // ElongatedCylinderCopyType
    //

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const BaseElongatedCylinder_type& BaseElongatedCylinder)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (::std::unique_ptr< BaseElongatedCylinder_type > BaseElongatedCylinder)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (std::move (BaseElongatedCylinder), this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const ElongatedCylinderCopyType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseElongatedCylinder_ (x.BaseElongatedCylinder_, f, this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseElongatedCylinder_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseElongatedCylinder
        //
        if (n.name () == L"BaseElongatedCylinder" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseElongatedCylinder_type > r (
            BaseElongatedCylinder_traits::create (i, f, this));

          if (!BaseElongatedCylinder_.present ())
          {
            this->BaseElongatedCylinder_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseElongatedCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseElongatedCylinder",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCylinderCopyType* ElongatedCylinderCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCopyType (*this, f, c);
    }

    ElongatedCylinderCopyType& ElongatedCylinderCopyType::
    operator= (const ElongatedCylinderCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseElongatedCylinder_ = x.BaseElongatedCylinder_;
      }

      return *this;
    }

    ElongatedCylinderCopyType::
    ~ElongatedCylinderCopyType ()
    {
    }

    // ElongatedCylinderCastType
    //

    ElongatedCylinderCastType::
    ElongatedCylinderCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const ElongatedCylinderCastType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCylinderCastType* ElongatedCylinderCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCastType (*this, f, c);
    }

    ElongatedCylinderCastType& ElongatedCylinderCastType::
    operator= (const ElongatedCylinderCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ElongatedCylinderCastType::
    ~ElongatedCylinderCastType ()
    {
    }

    // ElongatedCylinderTransformType
    //

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (this),
      Transformation_ (this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const BaseElongatedCylinder_type& BaseElongatedCylinder,
                                    const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, this),
      Transformation_ (Transformation, this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (::std::unique_ptr< BaseElongatedCylinder_type > BaseElongatedCylinder,
                                    ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (std::move (BaseElongatedCylinder), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const ElongatedCylinderTransformType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseElongatedCylinder_ (x.BaseElongatedCylinder_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseElongatedCylinder_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseElongatedCylinder
        //
        if (n.name () == L"BaseElongatedCylinder" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseElongatedCylinder_type > r (
            BaseElongatedCylinder_traits::create (i, f, this));

          if (!BaseElongatedCylinder_.present ())
          {
            this->BaseElongatedCylinder_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseElongatedCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseElongatedCylinder",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCylinderTransformType* ElongatedCylinderTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderTransformType (*this, f, c);
    }

    ElongatedCylinderTransformType& ElongatedCylinderTransformType::
    operator= (const ElongatedCylinderTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseElongatedCylinder_ = x.BaseElongatedCylinder_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ElongatedCylinderTransformType::
    ~ElongatedCylinderTransformType ()
    {
    }

    // ElongatedCylinderCheckedType
    //

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType (const ElongatedCylinderCheckedType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderCheckedType* ElongatedCylinderCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCheckedType (*this, f, c);
    }

    ElongatedCylinderCheckedType& ElongatedCylinderCheckedType::
    operator= (const ElongatedCylinderCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ElongatedCylinderCheckedType::
    ~ElongatedCylinderCheckedType ()
    {
    }

    // ElongatedCylinderCheckedFeatureType
    //

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType (const ElongatedCylinderCheckedFeatureType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderCheckedFeatureType* ElongatedCylinderCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCheckedFeatureType (*this, f, c);
    }

    ElongatedCylinderCheckedFeatureType& ElongatedCylinderCheckedFeatureType::
    operator= (const ElongatedCylinderCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ElongatedCylinderCheckedFeatureType::
    ~ElongatedCylinderCheckedFeatureType ()
    {
    }

    // ElongatedCylinderMeasurementDeterminationType
    //

    ElongatedCylinderMeasurementDeterminationType::
    ElongatedCylinderMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ElongatedCylinderMeasurementDeterminationType::
    ElongatedCylinderMeasurementDeterminationType (const ElongatedCylinderMeasurementDeterminationType& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ElongatedCylinderMeasurementDeterminationType::
    ElongatedCylinderMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderMeasurementDeterminationType* ElongatedCylinderMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderMeasurementDeterminationType (*this, f, c);
    }

    ElongatedCylinderMeasurementDeterminationType& ElongatedCylinderMeasurementDeterminationType::
    operator= (const ElongatedCylinderMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ElongatedCylinderMeasurementDeterminationType::
    ~ElongatedCylinderMeasurementDeterminationType ()
    {
    }

    // ElongatedCylinderFeatureItemType
    //

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const id_type& id,
                                      const FeatureNominalId_type& FeatureNominalId,
                                      const FeatureName_type& FeatureName,
                                      const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const id_type& id,
                                      ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                      const FeatureName_type& FeatureName,
                                      ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const ElongatedCylinderFeatureItemType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCylinderFeatureItemType* ElongatedCylinderFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureItemType (*this, f, c);
    }

    ElongatedCylinderFeatureItemType& ElongatedCylinderFeatureItemType::
    operator= (const ElongatedCylinderFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    ElongatedCylinderFeatureItemType::
    ~ElongatedCylinderFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ElongatedCylinderFeatureItemType >
    _xsd_ElongatedCylinderFeatureItemType_type_factory_init (
      L"ElongatedCylinderFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCylinderFeatureDefinitionType
    //

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Depth_ (this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const id_type& id,
                                            const InternalExternal_type& InternalExternal,
                                            const Diameter_type& Diameter,
                                            const Length_type& Length)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (Length, this),
      Depth_ (this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const id_type& id,
                                            const InternalExternal_type& InternalExternal,
                                            ::std::unique_ptr< Diameter_type > Diameter,
                                            ::std::unique_ptr< Length_type > Length)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this),
      Length_ (std::move (Length), this),
      Depth_ (this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const ElongatedCylinderFeatureDefinitionType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCylinderFeatureDefinitionType* ElongatedCylinderFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureDefinitionType (*this, f, c);
    }

    ElongatedCylinderFeatureDefinitionType& ElongatedCylinderFeatureDefinitionType::
    operator= (const ElongatedCylinderFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    ElongatedCylinderFeatureDefinitionType::
    ~ElongatedCylinderFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ElongatedCylinderFeatureDefinitionType >
    _xsd_ElongatedCylinderFeatureDefinitionType_type_factory_init (
      L"ElongatedCylinderFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCylinderFeatureNominalType
    //

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      CenterPlane_ (this),
      DepthVector_ (this),
      Constructed_ (this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         const CenterPlane_type& CenterPlane,
                                         const DepthVector_type& DepthVector)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      CenterPlane_ (CenterPlane, this),
      DepthVector_ (DepthVector, this),
      Constructed_ (this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const id_type& id,
                                         ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                         ::std::unique_ptr< CenterPlane_type > CenterPlane,
                                         ::std::unique_ptr< DepthVector_type > DepthVector)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      CenterPlane_ (std::move (CenterPlane), this),
      DepthVector_ (std::move (DepthVector), this),
      Constructed_ (this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const ElongatedCylinderFeatureNominalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (this),
      DepthVector_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterPlane
        //
        if (n.name () == L"CenterPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!CenterPlane_.present ())
          {
            this->CenterPlane_.set (::std::move (r));
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == L"DepthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!DepthVector_.present ())
          {
            this->DepthVector_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DepthVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DepthVector",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ElongatedCylinderFeatureNominalType* ElongatedCylinderFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureNominalType (*this, f, c);
    }

    ElongatedCylinderFeatureNominalType& ElongatedCylinderFeatureNominalType::
    operator= (const ElongatedCylinderFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->CenterPlane_ = x.CenterPlane_;
        this->DepthVector_ = x.DepthVector_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ElongatedCylinderFeatureNominalType::
    ~ElongatedCylinderFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ElongatedCylinderFeatureNominalType >
    _xsd_ElongatedCylinderFeatureNominalType_type_factory_init (
      L"ElongatedCylinderFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // ElongatedCylinderFeatureMeasurementType
    //

    ElongatedCylinderFeatureMeasurementType::
    ElongatedCylinderFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterPlane_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Depth_ (this),
      DepthMax_ (this),
      DepthMin_ (this),
      DepthVector_ (this),
      Form_ (this)
    {
    }

    ElongatedCylinderFeatureMeasurementType::
    ElongatedCylinderFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterPlane_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Depth_ (this),
      DepthMax_ (this),
      DepthMin_ (this),
      DepthVector_ (this),
      Form_ (this)
    {
    }

    ElongatedCylinderFeatureMeasurementType::
    ElongatedCylinderFeatureMeasurementType (const ElongatedCylinderFeatureMeasurementType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      CenterPlane_ (x.CenterPlane_, f, this),
      Length_ (x.Length_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      Depth_ (x.Depth_, f, this),
      DepthMax_ (x.DepthMax_, f, this),
      DepthMin_ (x.DepthMin_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ElongatedCylinderFeatureMeasurementType::
    ElongatedCylinderFeatureMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterPlane_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Depth_ (this),
      DepthMax_ (this),
      DepthMin_ (this),
      DepthVector_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // CenterPlane
        //
        if (n.name () == L"CenterPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!this->CenterPlane_)
          {
            this->CenterPlane_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == L"LengthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (::std::move (r));
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == L"LengthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        // DepthMax
        //
        if (n.name () == L"DepthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DepthMax_type > r (
            DepthMax_traits::create (i, f, this));

          if (!this->DepthMax_)
          {
            this->DepthMax_.set (::std::move (r));
            continue;
          }
        }

        // DepthMin
        //
        if (n.name () == L"DepthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DepthMin_type > r (
            DepthMin_traits::create (i, f, this));

          if (!this->DepthMin_)
          {
            this->DepthMin_.set (::std::move (r));
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == L"DepthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderFeatureMeasurementType* ElongatedCylinderFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureMeasurementType (*this, f, c);
    }

    ElongatedCylinderFeatureMeasurementType& ElongatedCylinderFeatureMeasurementType::
    operator= (const ElongatedCylinderFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->CenterPlane_ = x.CenterPlane_;
        this->Length_ = x.Length_;
        this->LengthMax_ = x.LengthMax_;
        this->LengthMin_ = x.LengthMin_;
        this->Depth_ = x.Depth_;
        this->DepthMax_ = x.DepthMax_;
        this->DepthMin_ = x.DepthMin_;
        this->DepthVector_ = x.DepthVector_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ElongatedCylinderFeatureMeasurementType::
    ~ElongatedCylinderFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ElongatedCylinderFeatureMeasurementType >
    _xsd_ElongatedCylinderFeatureMeasurementType_type_factory_init (
      L"ElongatedCylinderFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // ExtrudedCrossSectionConstructionMethodType
    //

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType (const ExtrudedCrossSectionConstructionMethodType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionConstructionMethodType* ExtrudedCrossSectionConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionConstructionMethodType (*this, f, c);
    }

    ExtrudedCrossSectionConstructionMethodType& ExtrudedCrossSectionConstructionMethodType::
    operator= (const ExtrudedCrossSectionConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ExtrudedCrossSectionConstructionMethodType::
    ~ExtrudedCrossSectionConstructionMethodType ()
    {
    }

    // ExtrudedCrossSectionBestFitType
    //

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType (const ExtrudedCrossSectionBestFitType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ExtrudedCrossSectionBestFitType* ExtrudedCrossSectionBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionBestFitType (*this, f, c);
    }

    ExtrudedCrossSectionBestFitType& ExtrudedCrossSectionBestFitType::
    operator= (const ExtrudedCrossSectionBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ExtrudedCrossSectionBestFitType::
    ~ExtrudedCrossSectionBestFitType ()
    {
    }

    // ExtrudedCrossSectionRecompType
    //

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const ExtrudedCrossSectionRecompType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExtrudedCrossSectionRecompType* ExtrudedCrossSectionRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionRecompType (*this, f, c);
    }

    ExtrudedCrossSectionRecompType& ExtrudedCrossSectionRecompType::
    operator= (const ExtrudedCrossSectionRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ExtrudedCrossSectionRecompType::
    ~ExtrudedCrossSectionRecompType ()
    {
    }

    // ExtrudedCrossSectionCopyType
    //

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const BaseExtrudedCrossSection_type& BaseExtrudedCrossSection)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (::std::unique_ptr< BaseExtrudedCrossSection_type > BaseExtrudedCrossSection)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (std::move (BaseExtrudedCrossSection), this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const ExtrudedCrossSectionCopyType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseExtrudedCrossSection_ (x.BaseExtrudedCrossSection_, f, this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseExtrudedCrossSection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseExtrudedCrossSection
        //
        if (n.name () == L"BaseExtrudedCrossSection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseExtrudedCrossSection_type > r (
            BaseExtrudedCrossSection_traits::create (i, f, this));

          if (!BaseExtrudedCrossSection_.present ())
          {
            this->BaseExtrudedCrossSection_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseExtrudedCrossSection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseExtrudedCrossSection",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExtrudedCrossSectionCopyType* ExtrudedCrossSectionCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCopyType (*this, f, c);
    }

    ExtrudedCrossSectionCopyType& ExtrudedCrossSectionCopyType::
    operator= (const ExtrudedCrossSectionCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseExtrudedCrossSection_ = x.BaseExtrudedCrossSection_;
      }

      return *this;
    }

    ExtrudedCrossSectionCopyType::
    ~ExtrudedCrossSectionCopyType ()
    {
    }

    // ExtrudedCrossSectionCastType
    //

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const ExtrudedCrossSectionCastType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExtrudedCrossSectionCastType* ExtrudedCrossSectionCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCastType (*this, f, c);
    }

    ExtrudedCrossSectionCastType& ExtrudedCrossSectionCastType::
    operator= (const ExtrudedCrossSectionCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ExtrudedCrossSectionCastType::
    ~ExtrudedCrossSectionCastType ()
    {
    }

    // ExtrudedCrossSectionTransformType
    //

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (this),
      Transformation_ (this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const BaseExtrudedCrossSection_type& BaseExtrudedCrossSection,
                                       const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, this),
      Transformation_ (Transformation, this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (::std::unique_ptr< BaseExtrudedCrossSection_type > BaseExtrudedCrossSection,
                                       ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (std::move (BaseExtrudedCrossSection), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const ExtrudedCrossSectionTransformType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseExtrudedCrossSection_ (x.BaseExtrudedCrossSection_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseExtrudedCrossSection_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseExtrudedCrossSection
        //
        if (n.name () == L"BaseExtrudedCrossSection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseExtrudedCrossSection_type > r (
            BaseExtrudedCrossSection_traits::create (i, f, this));

          if (!BaseExtrudedCrossSection_.present ())
          {
            this->BaseExtrudedCrossSection_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseExtrudedCrossSection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseExtrudedCrossSection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExtrudedCrossSectionTransformType* ExtrudedCrossSectionTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionTransformType (*this, f, c);
    }

    ExtrudedCrossSectionTransformType& ExtrudedCrossSectionTransformType::
    operator= (const ExtrudedCrossSectionTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseExtrudedCrossSection_ = x.BaseExtrudedCrossSection_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ExtrudedCrossSectionTransformType::
    ~ExtrudedCrossSectionTransformType ()
    {
    }

    // ExtrudedCrossSectionCheckedType
    //

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType (const ExtrudedCrossSectionCheckedType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionCheckedType* ExtrudedCrossSectionCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCheckedType (*this, f, c);
    }

    ExtrudedCrossSectionCheckedType& ExtrudedCrossSectionCheckedType::
    operator= (const ExtrudedCrossSectionCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ExtrudedCrossSectionCheckedType::
    ~ExtrudedCrossSectionCheckedType ()
    {
    }

    // ExtrudedCrossSectionCheckedFeatureType
    //

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType (const ExtrudedCrossSectionCheckedFeatureType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionCheckedFeatureType* ExtrudedCrossSectionCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCheckedFeatureType (*this, f, c);
    }

    ExtrudedCrossSectionCheckedFeatureType& ExtrudedCrossSectionCheckedFeatureType::
    operator= (const ExtrudedCrossSectionCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ~ExtrudedCrossSectionCheckedFeatureType ()
    {
    }

    // ExtrudedCrossSectionMeasurementDeterminationType
    //

    ExtrudedCrossSectionMeasurementDeterminationType::
    ExtrudedCrossSectionMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ExtrudedCrossSectionMeasurementDeterminationType::
    ExtrudedCrossSectionMeasurementDeterminationType (const ExtrudedCrossSectionMeasurementDeterminationType& x,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ExtrudedCrossSectionMeasurementDeterminationType::
    ExtrudedCrossSectionMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionMeasurementDeterminationType* ExtrudedCrossSectionMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionMeasurementDeterminationType (*this, f, c);
    }

    ExtrudedCrossSectionMeasurementDeterminationType& ExtrudedCrossSectionMeasurementDeterminationType::
    operator= (const ExtrudedCrossSectionMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ExtrudedCrossSectionMeasurementDeterminationType::
    ~ExtrudedCrossSectionMeasurementDeterminationType ()
    {
    }

    // ExtrudedCrossSectionFeatureItemType
    //

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const id_type& id,
                                         const FeatureNominalId_type& FeatureNominalId,
                                         const FeatureName_type& FeatureName,
                                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const id_type& id,
                                         ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                         const FeatureName_type& FeatureName,
                                         ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const ExtrudedCrossSectionFeatureItemType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExtrudedCrossSectionFeatureItemType* ExtrudedCrossSectionFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureItemType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureItemType& ExtrudedCrossSectionFeatureItemType::
    operator= (const ExtrudedCrossSectionFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    ExtrudedCrossSectionFeatureItemType::
    ~ExtrudedCrossSectionFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ExtrudedCrossSectionFeatureItemType >
    _xsd_ExtrudedCrossSectionFeatureItemType_type_factory_init (
      L"ExtrudedCrossSectionFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // ExtrudedCrossSectionFeatureDefinitionType
    //

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Length_ (this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const id_type& id,
                                               const InternalExternal_type& InternalExternal,
                                               const Length_type& Length)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Length_ (Length, this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const id_type& id,
                                               const InternalExternal_type& InternalExternal,
                                               ::std::unique_ptr< Length_type > Length)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Length_ (std::move (Length), this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const ExtrudedCrossSectionFeatureDefinitionType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Length",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExtrudedCrossSectionFeatureDefinitionType* ExtrudedCrossSectionFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureDefinitionType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureDefinitionType& ExtrudedCrossSectionFeatureDefinitionType::
    operator= (const ExtrudedCrossSectionFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ~ExtrudedCrossSectionFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ExtrudedCrossSectionFeatureDefinitionType >
    _xsd_ExtrudedCrossSectionFeatureDefinitionType_type_factory_init (
      L"ExtrudedCrossSectionFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // ExtrudedCrossSectionFeatureNominalType
    //

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Direction_ (this),
      CrossSectionReferenceFeatureId_ (this),
      Constructed_ (this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const id_type& id,
                                            const FeatureDefinitionId_type& FeatureDefinitionId,
                                            const Direction_type& Direction,
                                            const CrossSectionReferenceFeatureId_type& CrossSectionReferenceFeatureId)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Direction_ (Direction, this),
      CrossSectionReferenceFeatureId_ (CrossSectionReferenceFeatureId, this),
      Constructed_ (this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const id_type& id,
                                            ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                            ::std::unique_ptr< Direction_type > Direction,
                                            ::std::unique_ptr< CrossSectionReferenceFeatureId_type > CrossSectionReferenceFeatureId)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Direction_ (std::move (Direction), this),
      CrossSectionReferenceFeatureId_ (std::move (CrossSectionReferenceFeatureId), this),
      Constructed_ (this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const ExtrudedCrossSectionFeatureNominalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Direction_ (x.Direction_, f, this),
      CrossSectionReferenceFeatureId_ (x.CrossSectionReferenceFeatureId_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Direction_ (this),
      CrossSectionReferenceFeatureId_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        // CrossSectionReferenceFeatureId
        //
        if (n.name () == L"CrossSectionReferenceFeatureId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CrossSectionReferenceFeatureId_type > r (
            CrossSectionReferenceFeatureId_traits::create (i, f, this));

          if (!CrossSectionReferenceFeatureId_.present ())
          {
            this->CrossSectionReferenceFeatureId_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Direction",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CrossSectionReferenceFeatureId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CrossSectionReferenceFeatureId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ExtrudedCrossSectionFeatureNominalType* ExtrudedCrossSectionFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureNominalType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureNominalType& ExtrudedCrossSectionFeatureNominalType::
    operator= (const ExtrudedCrossSectionFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Direction_ = x.Direction_;
        this->CrossSectionReferenceFeatureId_ = x.CrossSectionReferenceFeatureId_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ExtrudedCrossSectionFeatureNominalType::
    ~ExtrudedCrossSectionFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ExtrudedCrossSectionFeatureNominalType >
    _xsd_ExtrudedCrossSectionFeatureNominalType_type_factory_init (
      L"ExtrudedCrossSectionFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // ExtrudedCrossSectionFeatureMeasurementType
    //

    ExtrudedCrossSectionFeatureMeasurementType::
    ExtrudedCrossSectionFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Direction_ (this),
      Length_ (this),
      Form_ (this)
    {
    }

    ExtrudedCrossSectionFeatureMeasurementType::
    ExtrudedCrossSectionFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Direction_ (this),
      Length_ (this),
      Form_ (this)
    {
    }

    ExtrudedCrossSectionFeatureMeasurementType::
    ExtrudedCrossSectionFeatureMeasurementType (const ExtrudedCrossSectionFeatureMeasurementType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureMeasurementType::
    ExtrudedCrossSectionFeatureMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Direction_ (this),
      Length_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionFeatureMeasurementType* ExtrudedCrossSectionFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureMeasurementType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureMeasurementType& ExtrudedCrossSectionFeatureMeasurementType::
    operator= (const ExtrudedCrossSectionFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Direction_ = x.Direction_;
        this->Length_ = x.Length_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ExtrudedCrossSectionFeatureMeasurementType::
    ~ExtrudedCrossSectionFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ExtrudedCrossSectionFeatureMeasurementType >
    _xsd_ExtrudedCrossSectionFeatureMeasurementType_type_factory_init (
      L"ExtrudedCrossSectionFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // LineConstructionMethodType
    //

    LineConstructionMethodType::
    LineConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Midline_ (this),
      Intersection_ (this),
      Projection_ (this),
      Perpendicular_ (this),
      Parallel_ (this),
      Copy_ (this),
      Cast_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      Extract_ (this),
      FromScan_ (this)
    {
    }

    LineConstructionMethodType::
    LineConstructionMethodType (const LineConstructionMethodType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Midline_ (x.Midline_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Perpendicular_ (x.Perpendicular_, f, this),
      Parallel_ (x.Parallel_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    LineConstructionMethodType::
    LineConstructionMethodType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Midline_ (this),
      Intersection_ (this),
      Projection_ (this),
      Perpendicular_ (this),
      Parallel_ (this),
      Copy_ (this),
      Cast_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      Extract_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Midline
        //
        if (n.name () == L"Midline" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Midline_type > r (
            Midline_traits::create (i, f, this));

          if (!this->Midline_)
          {
            this->Midline_.set (::std::move (r));
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == L"Intersection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (::std::move (r));
            continue;
          }
        }

        // Projection
        //
        if (n.name () == L"Projection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (::std::move (r));
            continue;
          }
        }

        // Perpendicular
        //
        if (n.name () == L"Perpendicular" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Perpendicular_type > r (
            Perpendicular_traits::create (i, f, this));

          if (!this->Perpendicular_)
          {
            this->Perpendicular_.set (::std::move (r));
            continue;
          }
        }

        // Parallel
        //
        if (n.name () == L"Parallel" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Parallel_type > r (
            Parallel_traits::create (i, f, this));

          if (!this->Parallel_)
          {
            this->Parallel_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == L"TangentThrough" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // Extract
        //
        if (n.name () == L"Extract" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LineConstructionMethodType* LineConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineConstructionMethodType (*this, f, c);
    }

    LineConstructionMethodType& LineConstructionMethodType::
    operator= (const LineConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Midline_ = x.Midline_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Perpendicular_ = x.Perpendicular_;
        this->Parallel_ = x.Parallel_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->TangentThrough_ = x.TangentThrough_;
        this->Transform_ = x.Transform_;
        this->Extract_ = x.Extract_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    LineConstructionMethodType::
    ~LineConstructionMethodType ()
    {
    }

    // LineBestFitType
    //

    LineBestFitType::
    LineBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    LineBestFitType::
    LineBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    LineBestFitType::
    LineBestFitType (const LineBestFitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    LineBestFitType::
    LineBestFitType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LineBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    LineBestFitType* LineBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineBestFitType (*this, f, c);
    }

    LineBestFitType& LineBestFitType::
    operator= (const LineBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    LineBestFitType::
    ~LineBestFitType ()
    {
    }

    // LineRecompType
    //

    LineRecompType::
    LineRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    LineRecompType::
    LineRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    LineRecompType::
    LineRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    LineRecompType::
    LineRecompType (const LineRecompType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    LineRecompType::
    LineRecompType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineRecompType* LineRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineRecompType (*this, f, c);
    }

    LineRecompType& LineRecompType::
    operator= (const LineRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    LineRecompType::
    ~LineRecompType ()
    {
    }

    // LineMidlineType
    //

    LineMidlineType::
    LineMidlineType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLine_ (this)
    {
    }

    LineMidlineType::
    LineMidlineType (const LineMidlineType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this)
    {
    }

    LineMidlineType::
    LineMidlineType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineMidlineType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseLine
        //
        if (n.name () == L"BaseLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          this->BaseLine_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    LineMidlineType* LineMidlineType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineMidlineType (*this, f, c);
    }

    LineMidlineType& LineMidlineType::
    operator= (const LineMidlineType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseLine_ = x.BaseLine_;
      }

      return *this;
    }

    LineMidlineType::
    ~LineMidlineType ()
    {
    }

    // LineIntersectionType
    //

    LineIntersectionType::
    LineIntersectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionFeature_ (this)
    {
    }

    LineIntersectionType::
    LineIntersectionType (const LineIntersectionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    LineIntersectionType::
    LineIntersectionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionFeature
        //
        if (n.name () == L"IntersectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          this->IntersectionFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    LineIntersectionType* LineIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineIntersectionType (*this, f, c);
    }

    LineIntersectionType& LineIntersectionType::
    operator= (const LineIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    LineIntersectionType::
    ~LineIntersectionType ()
    {
    }

    // LineProjectionType
    //

    LineProjectionType::
    LineProjectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (this),
      ProjectionLine_ (this)
    {
    }

    LineProjectionType::
    LineProjectionType (const ProjectionPlane_type& ProjectionPlane,
                        const ProjectionLine_type& ProjectionLine)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionLine_ (ProjectionLine, this)
    {
    }

    LineProjectionType::
    LineProjectionType (::std::unique_ptr< ProjectionPlane_type > ProjectionPlane,
                        ::std::unique_ptr< ProjectionLine_type > ProjectionLine)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (std::move (ProjectionPlane), this),
      ProjectionLine_ (std::move (ProjectionLine), this)
    {
    }

    LineProjectionType::
    LineProjectionType (const LineProjectionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionLine_ (x.ProjectionLine_, f, this)
    {
    }

    LineProjectionType::
    LineProjectionType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (this),
      ProjectionLine_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineProjectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProjectionPlane
        //
        if (n.name () == L"ProjectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (::std::move (r));
            continue;
          }
        }

        // ProjectionLine
        //
        if (n.name () == L"ProjectionLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionLine_type > r (
            ProjectionLine_traits::create (i, f, this));

          if (!ProjectionLine_.present ())
          {
            this->ProjectionLine_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ProjectionLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionLine",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineProjectionType* LineProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineProjectionType (*this, f, c);
    }

    LineProjectionType& LineProjectionType::
    operator= (const LineProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionPlane_ = x.ProjectionPlane_;
        this->ProjectionLine_ = x.ProjectionLine_;
      }

      return *this;
    }

    LineProjectionType::
    ~LineProjectionType ()
    {
    }

    // LinePerpendicularType
    //

    LinePerpendicularType::
    LinePerpendicularType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      PerpendicularFeature_ (this),
      PointFeature_ (this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (const PerpendicularFeature_type& PerpendicularFeature,
                           const PointFeature_type& PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (::std::unique_ptr< PerpendicularFeature_type > PerpendicularFeature,
                           ::std::unique_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      PerpendicularFeature_ (std::move (PerpendicularFeature), this),
      PointFeature_ (std::move (PointFeature), this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (const LinePerpendicularType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      PerpendicularFeature_ (x.PerpendicularFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      PerpendicularFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinePerpendicularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PerpendicularFeature
        //
        if (n.name () == L"PerpendicularFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PerpendicularFeature_type > r (
            PerpendicularFeature_traits::create (i, f, this));

          if (!PerpendicularFeature_.present ())
          {
            this->PerpendicularFeature_.set (::std::move (r));
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == L"PointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PerpendicularFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PerpendicularFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LinePerpendicularType* LinePerpendicularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinePerpendicularType (*this, f, c);
    }

    LinePerpendicularType& LinePerpendicularType::
    operator= (const LinePerpendicularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->PerpendicularFeature_ = x.PerpendicularFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    LinePerpendicularType::
    ~LinePerpendicularType ()
    {
    }

    // LineParallelType
    //

    LineParallelType::
    LineParallelType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ParallelFeature_ (this),
      PointFeature_ (this)
    {
    }

    LineParallelType::
    LineParallelType (const ParallelFeature_type& ParallelFeature,
                      const PointFeature_type& PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LineParallelType::
    LineParallelType (::std::unique_ptr< ParallelFeature_type > ParallelFeature,
                      ::std::unique_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ParallelFeature_ (std::move (ParallelFeature), this),
      PointFeature_ (std::move (PointFeature), this)
    {
    }

    LineParallelType::
    LineParallelType (const LineParallelType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ParallelFeature_ (x.ParallelFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LineParallelType::
    LineParallelType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ParallelFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineParallelType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ParallelFeature
        //
        if (n.name () == L"ParallelFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ParallelFeature_type > r (
            ParallelFeature_traits::create (i, f, this));

          if (!ParallelFeature_.present ())
          {
            this->ParallelFeature_.set (::std::move (r));
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == L"PointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ParallelFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ParallelFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineParallelType* LineParallelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineParallelType (*this, f, c);
    }

    LineParallelType& LineParallelType::
    operator= (const LineParallelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ParallelFeature_ = x.ParallelFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    LineParallelType::
    ~LineParallelType ()
    {
    }

    // LineCopyType
    //

    LineCopyType::
    LineCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLine_ (this)
    {
    }

    LineCopyType::
    LineCopyType (const BaseLine_type& BaseLine)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, this)
    {
    }

    LineCopyType::
    LineCopyType (::std::unique_ptr< BaseLine_type > BaseLine)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLine_ (std::move (BaseLine), this)
    {
    }

    LineCopyType::
    LineCopyType (const LineCopyType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this)
    {
    }

    LineCopyType::
    LineCopyType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseLine
        //
        if (n.name () == L"BaseLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          if (!BaseLine_.present ())
          {
            this->BaseLine_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseLine",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineCopyType* LineCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCopyType (*this, f, c);
    }

    LineCopyType& LineCopyType::
    operator= (const LineCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseLine_ = x.BaseLine_;
      }

      return *this;
    }

    LineCopyType::
    ~LineCopyType ()
    {
    }

    // LineCastType
    //

    LineCastType::
    LineCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    LineCastType::
    LineCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    LineCastType::
    LineCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    LineCastType::
    LineCastType (const LineCastType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    LineCastType::
    LineCastType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineCastType* LineCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCastType (*this, f, c);
    }

    LineCastType& LineCastType::
    operator= (const LineCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    LineCastType::
    ~LineCastType ()
    {
    }

    // LineTangentThroughType
    //

    LineTangentThroughType::
    LineTangentThroughType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (const TangentFeature_type& TangentFeature,
                            const PointFeature_type& PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (::std::unique_ptr< TangentFeature_type > TangentFeature,
                            ::std::unique_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (std::move (TangentFeature), this),
      PointFeature_ (std::move (PointFeature), this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (const LineTangentThroughType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TangentFeature
        //
        if (n.name () == L"TangentFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (::std::move (r));
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == L"PointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TangentFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineTangentThroughType* LineTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineTangentThroughType (*this, f, c);
    }

    LineTangentThroughType& LineTangentThroughType::
    operator= (const LineTangentThroughType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->TangentFeature_ = x.TangentFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    LineTangentThroughType::
    ~LineTangentThroughType ()
    {
    }

    // LineTransformType
    //

    LineTransformType::
    LineTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLine_ (this),
      Transformation_ (this)
    {
    }

    LineTransformType::
    LineTransformType (const BaseLine_type& BaseLine,
                       const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, this),
      Transformation_ (Transformation, this)
    {
    }

    LineTransformType::
    LineTransformType (::std::unique_ptr< BaseLine_type > BaseLine,
                       ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLine_ (std::move (BaseLine), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    LineTransformType::
    LineTransformType (const LineTransformType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    LineTransformType::
    LineTransformType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseLine
        //
        if (n.name () == L"BaseLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          if (!BaseLine_.present ())
          {
            this->BaseLine_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseLine",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineTransformType* LineTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineTransformType (*this, f, c);
    }

    LineTransformType& LineTransformType::
    operator= (const LineTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseLine_ = x.BaseLine_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    LineTransformType::
    ~LineTransformType ()
    {
    }

    // LineFromScanType
    //

    LineFromScanType::
    LineFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
    }

    LineFromScanType::
    LineFromScanType (const SurfaceFeature_type& SurfaceFeature,
                      const SearchRadius_type& SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    LineFromScanType::
    LineFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                      ::std::unique_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this)
    {
    }

    LineFromScanType::
    LineFromScanType (const LineFromScanType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    LineFromScanType::
    LineFromScanType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineFromScanType* LineFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFromScanType (*this, f, c);
    }

    LineFromScanType& LineFromScanType::
    operator= (const LineFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    LineFromScanType::
    ~LineFromScanType ()
    {
    }

    // LineExtractType
    //

    LineExtractType::
    LineExtractType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (this)
    {
    }

    LineExtractType::
    LineExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    LineExtractType::
    LineExtractType (::std::unique_ptr< CurveFeature_type > CurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (std::move (CurveFeature), this)
    {
    }

    LineExtractType::
    LineExtractType (const LineExtractType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    LineExtractType::
    LineExtractType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineExtractType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CurveFeature
        //
        if (n.name () == L"CurveFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CurveFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineExtractType* LineExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineExtractType (*this, f, c);
    }

    LineExtractType& LineExtractType::
    operator= (const LineExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->CurveFeature_ = x.CurveFeature_;
      }

      return *this;
    }

    LineExtractType::
    ~LineExtractType ()
    {
    }

    // LineCheckedType
    //

    LineCheckedType::
    LineCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    LineCheckedType::
    LineCheckedType (const LineCheckedType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    LineCheckedType::
    LineCheckedType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LineCheckedType* LineCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCheckedType (*this, f, c);
    }

    LineCheckedType& LineCheckedType::
    operator= (const LineCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    LineCheckedType::
    ~LineCheckedType ()
    {
    }

    // LineCheckedFeatureType
    //

    LineCheckedFeatureType::
    LineCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    LineCheckedFeatureType::
    LineCheckedFeatureType (const LineCheckedFeatureType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    LineCheckedFeatureType::
    LineCheckedFeatureType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LineCheckedFeatureType* LineCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCheckedFeatureType (*this, f, c);
    }

    LineCheckedFeatureType& LineCheckedFeatureType::
    operator= (const LineCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    LineCheckedFeatureType::
    ~LineCheckedFeatureType ()
    {
    }

    // LineMeasurementDeterminationType
    //

    LineMeasurementDeterminationType::
    LineMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    LineMeasurementDeterminationType::
    LineMeasurementDeterminationType (const LineMeasurementDeterminationType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    LineMeasurementDeterminationType::
    LineMeasurementDeterminationType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LineMeasurementDeterminationType* LineMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineMeasurementDeterminationType (*this, f, c);
    }

    LineMeasurementDeterminationType& LineMeasurementDeterminationType::
    operator= (const LineMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    LineMeasurementDeterminationType::
    ~LineMeasurementDeterminationType ()
    {
    }

    // LineFeatureItemType
    //

    LineFeatureItemType::
    LineFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const id_type& id,
                         const FeatureNominalId_type& FeatureNominalId,
                         const FeatureName_type& FeatureName,
                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const id_type& id,
                         ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                         const FeatureName_type& FeatureName,
                         ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const LineFeatureItemType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LineFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineFeatureItemType* LineFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureItemType (*this, f, c);
    }

    LineFeatureItemType& LineFeatureItemType::
    operator= (const LineFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    LineFeatureItemType::
    ~LineFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LineFeatureItemType >
    _xsd_LineFeatureItemType_type_factory_init (
      L"LineFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // LineFeatureDefinitionType
    //

    LineFeatureDefinitionType::
    LineFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType ()
    {
    }

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const id_type& id)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id)
    {
    }

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const LineFeatureDefinitionType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c)
    {
    }

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f, c)
    {
    }

    LineFeatureDefinitionType* LineFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureDefinitionType (*this, f, c);
    }

    LineFeatureDefinitionType::
    ~LineFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LineFeatureDefinitionType >
    _xsd_LineFeatureDefinitionType_type_factory_init (
      L"LineFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // LineFeatureNominalType
    //

    LineFeatureNominalType::
    LineFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            const Location_type& Location,
                            const Direction_type& Direction)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Location_ (Location, this),
      Direction_ (Direction, this),
      Length_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const id_type& id,
                            ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                            ::std::unique_ptr< Location_type > Location,
                            ::std::unique_ptr< Direction_type > Direction)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      Direction_ (std::move (Direction), this),
      Length_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const LineFeatureNominalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Normal_ (x.Normal_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LineFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Direction",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LineFeatureNominalType* LineFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureNominalType (*this, f, c);
    }

    LineFeatureNominalType& LineFeatureNominalType::
    operator= (const LineFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Direction_ = x.Direction_;
        this->Length_ = x.Length_;
        this->Normal_ = x.Normal_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    LineFeatureNominalType::
    ~LineFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LineFeatureNominalType >
    _xsd_LineFeatureNominalType_type_factory_init (
      L"LineFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // LineFeatureMeasurementType
    //

    LineFeatureMeasurementType::
    LineFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this),
      Form_ (this)
    {
    }

    LineFeatureMeasurementType::
    LineFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this),
      Form_ (this)
    {
    }

    LineFeatureMeasurementType::
    LineFeatureMeasurementType (const LineFeatureMeasurementType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Normal_ (x.Normal_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    LineFeatureMeasurementType::
    LineFeatureMeasurementType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LineFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Direction
        //
        if (n.name () == L"Direction" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    LineFeatureMeasurementType* LineFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureMeasurementType (*this, f, c);
    }

    LineFeatureMeasurementType& LineFeatureMeasurementType::
    operator= (const LineFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Direction_ = x.Direction_;
        this->Length_ = x.Length_;
        this->Normal_ = x.Normal_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    LineFeatureMeasurementType::
    ~LineFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LineFeatureMeasurementType >
    _xsd_LineFeatureMeasurementType_type_factory_init (
      L"LineFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelLinesConstructionMethodType
    //

    OppositeParallelLinesConstructionMethodType::
    OppositeParallelLinesConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    OppositeParallelLinesConstructionMethodType::
    OppositeParallelLinesConstructionMethodType (const OppositeParallelLinesConstructionMethodType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    OppositeParallelLinesConstructionMethodType::
    OppositeParallelLinesConstructionMethodType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == L"Intersection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (::std::move (r));
            continue;
          }
        }

        // Projection
        //
        if (n.name () == L"Projection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelLinesConstructionMethodType* OppositeParallelLinesConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesConstructionMethodType (*this, f, c);
    }

    OppositeParallelLinesConstructionMethodType& OppositeParallelLinesConstructionMethodType::
    operator= (const OppositeParallelLinesConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    OppositeParallelLinesConstructionMethodType::
    ~OppositeParallelLinesConstructionMethodType ()
    {
    }

    // OppositeParallelLinesBestFitType
    //

    OppositeParallelLinesBestFitType::
    OppositeParallelLinesBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    OppositeParallelLinesBestFitType::
    OppositeParallelLinesBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    OppositeParallelLinesBestFitType::
    OppositeParallelLinesBestFitType (const OppositeParallelLinesBestFitType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    OppositeParallelLinesBestFitType::
    OppositeParallelLinesBestFitType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    OppositeParallelLinesBestFitType* OppositeParallelLinesBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesBestFitType (*this, f, c);
    }

    OppositeParallelLinesBestFitType& OppositeParallelLinesBestFitType::
    operator= (const OppositeParallelLinesBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    OppositeParallelLinesBestFitType::
    ~OppositeParallelLinesBestFitType ()
    {
    }

    // OppositeParallelLinesRecompType
    //

    OppositeParallelLinesRecompType::
    OppositeParallelLinesRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    OppositeParallelLinesRecompType::
    OppositeParallelLinesRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    OppositeParallelLinesRecompType::
    OppositeParallelLinesRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    OppositeParallelLinesRecompType::
    OppositeParallelLinesRecompType (const OppositeParallelLinesRecompType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    OppositeParallelLinesRecompType::
    OppositeParallelLinesRecompType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesRecompType* OppositeParallelLinesRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesRecompType (*this, f, c);
    }

    OppositeParallelLinesRecompType& OppositeParallelLinesRecompType::
    operator= (const OppositeParallelLinesRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    OppositeParallelLinesRecompType::
    ~OppositeParallelLinesRecompType ()
    {
    }

    // OppositeParallelLinesIntersectionType
    //

    OppositeParallelLinesIntersectionType::
    OppositeParallelLinesIntersectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
    }

    OppositeParallelLinesIntersectionType::
    OppositeParallelLinesIntersectionType (const IntersectionPlane_type& IntersectionPlane,
                                           const IntersectionFeature_type& IntersectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, this),
      IntersectionFeature_ (IntersectionFeature, this)
    {
    }

    OppositeParallelLinesIntersectionType::
    OppositeParallelLinesIntersectionType (::std::unique_ptr< IntersectionPlane_type > IntersectionPlane,
                                           ::std::unique_ptr< IntersectionFeature_type > IntersectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (std::move (IntersectionPlane), this),
      IntersectionFeature_ (std::move (IntersectionFeature), this)
    {
    }

    OppositeParallelLinesIntersectionType::
    OppositeParallelLinesIntersectionType (const OppositeParallelLinesIntersectionType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      IntersectionPlane_ (x.IntersectionPlane_, f, this),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    OppositeParallelLinesIntersectionType::
    OppositeParallelLinesIntersectionType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionPlane
        //
        if (n.name () == L"IntersectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionPlane_type > r (
            IntersectionPlane_traits::create (i, f, this));

          if (!IntersectionPlane_.present ())
          {
            this->IntersectionPlane_.set (::std::move (r));
            continue;
          }
        }

        // IntersectionFeature
        //
        if (n.name () == L"IntersectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          if (!IntersectionFeature_.present ())
          {
            this->IntersectionFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!IntersectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesIntersectionType* OppositeParallelLinesIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesIntersectionType (*this, f, c);
    }

    OppositeParallelLinesIntersectionType& OppositeParallelLinesIntersectionType::
    operator= (const OppositeParallelLinesIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionPlane_ = x.IntersectionPlane_;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    OppositeParallelLinesIntersectionType::
    ~OppositeParallelLinesIntersectionType ()
    {
    }

    // OppositeParallelLinesProjectionType
    //

    OppositeParallelLinesProjectionType::
    OppositeParallelLinesProjectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (this),
      ProjectionOppositeParallelLines_ (this)
    {
    }

    OppositeParallelLinesProjectionType::
    OppositeParallelLinesProjectionType (const ProjectionPlane_type& ProjectionPlane,
                                         const ProjectionOppositeParallelLines_type& ProjectionOppositeParallelLines)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionOppositeParallelLines_ (ProjectionOppositeParallelLines, this)
    {
    }

    OppositeParallelLinesProjectionType::
    OppositeParallelLinesProjectionType (::std::unique_ptr< ProjectionPlane_type > ProjectionPlane,
                                         ::std::unique_ptr< ProjectionOppositeParallelLines_type > ProjectionOppositeParallelLines)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (std::move (ProjectionPlane), this),
      ProjectionOppositeParallelLines_ (std::move (ProjectionOppositeParallelLines), this)
    {
    }

    OppositeParallelLinesProjectionType::
    OppositeParallelLinesProjectionType (const OppositeParallelLinesProjectionType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionOppositeParallelLines_ (x.ProjectionOppositeParallelLines_, f, this)
    {
    }

    OppositeParallelLinesProjectionType::
    OppositeParallelLinesProjectionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (this),
      ProjectionOppositeParallelLines_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesProjectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProjectionPlane
        //
        if (n.name () == L"ProjectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (::std::move (r));
            continue;
          }
        }

        // ProjectionOppositeParallelLines
        //
        if (n.name () == L"ProjectionOppositeParallelLines" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionOppositeParallelLines_type > r (
            ProjectionOppositeParallelLines_traits::create (i, f, this));

          if (!ProjectionOppositeParallelLines_.present ())
          {
            this->ProjectionOppositeParallelLines_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ProjectionOppositeParallelLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionOppositeParallelLines",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesProjectionType* OppositeParallelLinesProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesProjectionType (*this, f, c);
    }

    OppositeParallelLinesProjectionType& OppositeParallelLinesProjectionType::
    operator= (const OppositeParallelLinesProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionPlane_ = x.ProjectionPlane_;
        this->ProjectionOppositeParallelLines_ = x.ProjectionOppositeParallelLines_;
      }

      return *this;
    }

    OppositeParallelLinesProjectionType::
    ~OppositeParallelLinesProjectionType ()
    {
    }

    // OppositeParallelLinesCopyType
    //

    OppositeParallelLinesCopyType::
    OppositeParallelLinesCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelLines_ (this)
    {
    }

    OppositeParallelLinesCopyType::
    OppositeParallelLinesCopyType (const BaseOppositeParallelLines_type& BaseOppositeParallelLines)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelLines_ (BaseOppositeParallelLines, this)
    {
    }

    OppositeParallelLinesCopyType::
    OppositeParallelLinesCopyType (::std::unique_ptr< BaseOppositeParallelLines_type > BaseOppositeParallelLines)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelLines_ (std::move (BaseOppositeParallelLines), this)
    {
    }

    OppositeParallelLinesCopyType::
    OppositeParallelLinesCopyType (const OppositeParallelLinesCopyType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOppositeParallelLines_ (x.BaseOppositeParallelLines_, f, this)
    {
    }

    OppositeParallelLinesCopyType::
    OppositeParallelLinesCopyType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeParallelLines_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOppositeParallelLines
        //
        if (n.name () == L"BaseOppositeParallelLines" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOppositeParallelLines_type > r (
            BaseOppositeParallelLines_traits::create (i, f, this));

          if (!BaseOppositeParallelLines_.present ())
          {
            this->BaseOppositeParallelLines_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeParallelLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOppositeParallelLines",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesCopyType* OppositeParallelLinesCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesCopyType (*this, f, c);
    }

    OppositeParallelLinesCopyType& OppositeParallelLinesCopyType::
    operator= (const OppositeParallelLinesCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeParallelLines_ = x.BaseOppositeParallelLines_;
      }

      return *this;
    }

    OppositeParallelLinesCopyType::
    ~OppositeParallelLinesCopyType ()
    {
    }

    // OppositeParallelLinesCastType
    //

    OppositeParallelLinesCastType::
    OppositeParallelLinesCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    OppositeParallelLinesCastType::
    OppositeParallelLinesCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    OppositeParallelLinesCastType::
    OppositeParallelLinesCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    OppositeParallelLinesCastType::
    OppositeParallelLinesCastType (const OppositeParallelLinesCastType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositeParallelLinesCastType::
    OppositeParallelLinesCastType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesCastType* OppositeParallelLinesCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesCastType (*this, f, c);
    }

    OppositeParallelLinesCastType& OppositeParallelLinesCastType::
    operator= (const OppositeParallelLinesCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    OppositeParallelLinesCastType::
    ~OppositeParallelLinesCastType ()
    {
    }

    // OppositeParallelLinesTransformType
    //

    OppositeParallelLinesTransformType::
    OppositeParallelLinesTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelLines_ (this),
      Transformation_ (this)
    {
    }

    OppositeParallelLinesTransformType::
    OppositeParallelLinesTransformType (const BaseOppositeParallelLines_type& BaseOppositeParallelLines,
                                        const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelLines_ (BaseOppositeParallelLines, this),
      Transformation_ (Transformation, this)
    {
    }

    OppositeParallelLinesTransformType::
    OppositeParallelLinesTransformType (::std::unique_ptr< BaseOppositeParallelLines_type > BaseOppositeParallelLines,
                                        ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelLines_ (std::move (BaseOppositeParallelLines), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    OppositeParallelLinesTransformType::
    OppositeParallelLinesTransformType (const OppositeParallelLinesTransformType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOppositeParallelLines_ (x.BaseOppositeParallelLines_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    OppositeParallelLinesTransformType::
    OppositeParallelLinesTransformType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeParallelLines_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOppositeParallelLines
        //
        if (n.name () == L"BaseOppositeParallelLines" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOppositeParallelLines_type > r (
            BaseOppositeParallelLines_traits::create (i, f, this));

          if (!BaseOppositeParallelLines_.present ())
          {
            this->BaseOppositeParallelLines_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeParallelLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOppositeParallelLines",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesTransformType* OppositeParallelLinesTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesTransformType (*this, f, c);
    }

    OppositeParallelLinesTransformType& OppositeParallelLinesTransformType::
    operator= (const OppositeParallelLinesTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeParallelLines_ = x.BaseOppositeParallelLines_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    OppositeParallelLinesTransformType::
    ~OppositeParallelLinesTransformType ()
    {
    }

    // OppositeParallelLinesFromScanType
    //

    OppositeParallelLinesFromScanType::
    OppositeParallelLinesFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
    }

    OppositeParallelLinesFromScanType::
    OppositeParallelLinesFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                       const SearchRadius_type& SearchRadius,
                                       const Depth_type& Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    OppositeParallelLinesFromScanType::
    OppositeParallelLinesFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                                       ::std::unique_ptr< SearchRadius_type > SearchRadius,
                                       ::std::unique_ptr< Depth_type > Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      Depth_ (std::move (Depth), this)
    {
    }

    OppositeParallelLinesFromScanType::
    OppositeParallelLinesFromScanType (const OppositeParallelLinesFromScanType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    OppositeParallelLinesFromScanType::
    OppositeParallelLinesFromScanType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Depth",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesFromScanType* OppositeParallelLinesFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesFromScanType (*this, f, c);
    }

    OppositeParallelLinesFromScanType& OppositeParallelLinesFromScanType::
    operator= (const OppositeParallelLinesFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    OppositeParallelLinesFromScanType::
    ~OppositeParallelLinesFromScanType ()
    {
    }

    // OppositeParallelLinesCheckedType
    //

    OppositeParallelLinesCheckedType::
    OppositeParallelLinesCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OppositeParallelLinesCheckedType::
    OppositeParallelLinesCheckedType (const OppositeParallelLinesCheckedType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeParallelLinesCheckedType::
    OppositeParallelLinesCheckedType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelLinesCheckedType* OppositeParallelLinesCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesCheckedType (*this, f, c);
    }

    OppositeParallelLinesCheckedType& OppositeParallelLinesCheckedType::
    operator= (const OppositeParallelLinesCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeParallelLinesCheckedType::
    ~OppositeParallelLinesCheckedType ()
    {
    }

    // OppositeParallelLinesCheckedFeatureType
    //

    OppositeParallelLinesCheckedFeatureType::
    OppositeParallelLinesCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OppositeParallelLinesCheckedFeatureType::
    OppositeParallelLinesCheckedFeatureType (const OppositeParallelLinesCheckedFeatureType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OppositeParallelLinesCheckedFeatureType::
    OppositeParallelLinesCheckedFeatureType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelLinesCheckedFeatureType* OppositeParallelLinesCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesCheckedFeatureType (*this, f, c);
    }

    OppositeParallelLinesCheckedFeatureType& OppositeParallelLinesCheckedFeatureType::
    operator= (const OppositeParallelLinesCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OppositeParallelLinesCheckedFeatureType::
    ~OppositeParallelLinesCheckedFeatureType ()
    {
    }

    // OppositeParallelLinesMeasurementDeterminationType
    //

    OppositeParallelLinesMeasurementDeterminationType::
    OppositeParallelLinesMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OppositeParallelLinesMeasurementDeterminationType::
    OppositeParallelLinesMeasurementDeterminationType (const OppositeParallelLinesMeasurementDeterminationType& x,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OppositeParallelLinesMeasurementDeterminationType::
    OppositeParallelLinesMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f,
                                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelLinesMeasurementDeterminationType* OppositeParallelLinesMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesMeasurementDeterminationType (*this, f, c);
    }

    OppositeParallelLinesMeasurementDeterminationType& OppositeParallelLinesMeasurementDeterminationType::
    operator= (const OppositeParallelLinesMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OppositeParallelLinesMeasurementDeterminationType::
    ~OppositeParallelLinesMeasurementDeterminationType ()
    {
    }

    // OppositeParallelLinesFeatureItemType
    //

    OppositeParallelLinesFeatureItemType::
    OppositeParallelLinesFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    OppositeParallelLinesFeatureItemType::
    OppositeParallelLinesFeatureItemType (const id_type& id,
                                          const FeatureNominalId_type& FeatureNominalId,
                                          const FeatureName_type& FeatureName,
                                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    OppositeParallelLinesFeatureItemType::
    OppositeParallelLinesFeatureItemType (const id_type& id,
                                          ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                          const FeatureName_type& FeatureName,
                                          ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    OppositeParallelLinesFeatureItemType::
    OppositeParallelLinesFeatureItemType (const OppositeParallelLinesFeatureItemType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    OppositeParallelLinesFeatureItemType::
    OppositeParallelLinesFeatureItemType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesFeatureItemType* OppositeParallelLinesFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesFeatureItemType (*this, f, c);
    }

    OppositeParallelLinesFeatureItemType& OppositeParallelLinesFeatureItemType::
    operator= (const OppositeParallelLinesFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    OppositeParallelLinesFeatureItemType::
    ~OppositeParallelLinesFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeParallelLinesFeatureItemType >
    _xsd_OppositeParallelLinesFeatureItemType_type_factory_init (
      L"OppositeParallelLinesFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelLinesFeatureDefinitionType
    //

    OppositeParallelLinesFeatureDefinitionType::
    OppositeParallelLinesFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeParallelLinesFeatureDefinitionType::
    OppositeParallelLinesFeatureDefinitionType (const id_type& id,
                                                const InternalExternal_type& InternalExternal,
                                                const Width_type& Width,
                                                const EndType_type& EndType)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (Width, this),
      Length_ (this),
      EndType_ (EndType, this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeParallelLinesFeatureDefinitionType::
    OppositeParallelLinesFeatureDefinitionType (const id_type& id,
                                                const InternalExternal_type& InternalExternal,
                                                ::std::unique_ptr< Width_type > Width,
                                                ::std::unique_ptr< EndType_type > EndType)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (std::move (Width), this),
      Length_ (this),
      EndType_ (std::move (EndType), this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeParallelLinesFeatureDefinitionType::
    OppositeParallelLinesFeatureDefinitionType (const OppositeParallelLinesFeatureDefinitionType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Width_ (x.Width_, f, this),
      Length_ (x.Length_, f, this),
      EndType_ (x.EndType_, f, this),
      SingleOpenEnd_ (x.SingleOpenEnd_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this)
    {
    }

    OppositeParallelLinesFeatureDefinitionType::
    OppositeParallelLinesFeatureDefinitionType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // EndType
        //
        if (n.name () == L"EndType" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndType_type > r (
            EndType_traits::create (i, f, this));

          if (!EndType_.present ())
          {
            this->EndType_.set (::std::move (r));
            continue;
          }
        }

        // SingleOpenEnd
        //
        if (n.name () == L"SingleOpenEnd" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SingleOpenEnd_)
          {
            this->SingleOpenEnd_.set (SingleOpenEnd_traits::create (i, f, this));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == L"EndRadius1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == L"EndRadius2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Width",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!EndType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndType",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesFeatureDefinitionType* OppositeParallelLinesFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesFeatureDefinitionType (*this, f, c);
    }

    OppositeParallelLinesFeatureDefinitionType& OppositeParallelLinesFeatureDefinitionType::
    operator= (const OppositeParallelLinesFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Width_ = x.Width_;
        this->Length_ = x.Length_;
        this->EndType_ = x.EndType_;
        this->SingleOpenEnd_ = x.SingleOpenEnd_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
      }

      return *this;
    }

    OppositeParallelLinesFeatureDefinitionType::
    ~OppositeParallelLinesFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeParallelLinesFeatureDefinitionType >
    _xsd_OppositeParallelLinesFeatureDefinitionType_type_factory_init (
      L"OppositeParallelLinesFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelLinesFeatureNominalType
    //

    OppositeParallelLinesFeatureNominalType::
    OppositeParallelLinesFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      CenterLine_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    OppositeParallelLinesFeatureNominalType::
    OppositeParallelLinesFeatureNominalType (const id_type& id,
                                             const FeatureDefinitionId_type& FeatureDefinitionId,
                                             const CenterLine_type& CenterLine,
                                             const Normal_type& Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      CenterLine_ (CenterLine, this),
      Normal_ (Normal, this),
      Constructed_ (this)
    {
    }

    OppositeParallelLinesFeatureNominalType::
    OppositeParallelLinesFeatureNominalType (const id_type& id,
                                             ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                             ::std::unique_ptr< CenterLine_type > CenterLine,
                                             ::std::unique_ptr< Normal_type > Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      CenterLine_ (std::move (CenterLine), this),
      Normal_ (std::move (Normal), this),
      Constructed_ (this)
    {
    }

    OppositeParallelLinesFeatureNominalType::
    OppositeParallelLinesFeatureNominalType (const OppositeParallelLinesFeatureNominalType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeParallelLinesFeatureNominalType::
    OppositeParallelLinesFeatureNominalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterLine
        //
        if (n.name () == L"CenterLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!CenterLine_.present ())
          {
            this->CenterLine_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterLine",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelLinesFeatureNominalType* OppositeParallelLinesFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesFeatureNominalType (*this, f, c);
    }

    OppositeParallelLinesFeatureNominalType& OppositeParallelLinesFeatureNominalType::
    operator= (const OppositeParallelLinesFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->CenterLine_ = x.CenterLine_;
        this->Normal_ = x.Normal_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeParallelLinesFeatureNominalType::
    ~OppositeParallelLinesFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeParallelLinesFeatureNominalType >
    _xsd_OppositeParallelLinesFeatureNominalType_type_factory_init (
      L"OppositeParallelLinesFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelLinesFeatureMeasurementType
    //

    OppositeParallelLinesFeatureMeasurementType::
    OppositeParallelLinesFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeParallelLinesFeatureMeasurementType::
    OppositeParallelLinesFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeParallelLinesFeatureMeasurementType::
    OppositeParallelLinesFeatureMeasurementType (const OppositeParallelLinesFeatureMeasurementType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this),
      Width_ (x.Width_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      Length_ (x.Length_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    OppositeParallelLinesFeatureMeasurementType::
    OppositeParallelLinesFeatureMeasurementType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelLinesFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterLine
        //
        if (n.name () == L"CenterLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!this->CenterLine_)
          {
            this->CenterLine_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == L"WidthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (::std::move (r));
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == L"WidthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == L"LengthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (::std::move (r));
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == L"LengthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == L"EndRadius1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == L"EndRadius2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelLinesFeatureMeasurementType* OppositeParallelLinesFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelLinesFeatureMeasurementType (*this, f, c);
    }

    OppositeParallelLinesFeatureMeasurementType& OppositeParallelLinesFeatureMeasurementType::
    operator= (const OppositeParallelLinesFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->CenterLine_ = x.CenterLine_;
        this->Normal_ = x.Normal_;
        this->Width_ = x.Width_;
        this->WidthMin_ = x.WidthMin_;
        this->WidthMax_ = x.WidthMax_;
        this->Length_ = x.Length_;
        this->LengthMin_ = x.LengthMin_;
        this->LengthMax_ = x.LengthMax_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    OppositeParallelLinesFeatureMeasurementType::
    ~OppositeParallelLinesFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeParallelLinesFeatureMeasurementType >
    _xsd_OppositeParallelLinesFeatureMeasurementType_type_factory_init (
      L"OppositeParallelLinesFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledLinesConstructionMethodType
    //

    OppositeAngledLinesConstructionMethodType::
    OppositeAngledLinesConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    OppositeAngledLinesConstructionMethodType::
    OppositeAngledLinesConstructionMethodType (const OppositeAngledLinesConstructionMethodType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    OppositeAngledLinesConstructionMethodType::
    OppositeAngledLinesConstructionMethodType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == L"Intersection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (::std::move (r));
            continue;
          }
        }

        // Projection
        //
        if (n.name () == L"Projection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledLinesConstructionMethodType* OppositeAngledLinesConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesConstructionMethodType (*this, f, c);
    }

    OppositeAngledLinesConstructionMethodType& OppositeAngledLinesConstructionMethodType::
    operator= (const OppositeAngledLinesConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    OppositeAngledLinesConstructionMethodType::
    ~OppositeAngledLinesConstructionMethodType ()
    {
    }

    // OppositeAngledLinesBestFitType
    //

    OppositeAngledLinesBestFitType::
    OppositeAngledLinesBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    OppositeAngledLinesBestFitType::
    OppositeAngledLinesBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    OppositeAngledLinesBestFitType::
    OppositeAngledLinesBestFitType (const OppositeAngledLinesBestFitType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    OppositeAngledLinesBestFitType::
    OppositeAngledLinesBestFitType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    OppositeAngledLinesBestFitType* OppositeAngledLinesBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesBestFitType (*this, f, c);
    }

    OppositeAngledLinesBestFitType& OppositeAngledLinesBestFitType::
    operator= (const OppositeAngledLinesBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    OppositeAngledLinesBestFitType::
    ~OppositeAngledLinesBestFitType ()
    {
    }

    // OppositeAngledLinesRecompType
    //

    OppositeAngledLinesRecompType::
    OppositeAngledLinesRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    OppositeAngledLinesRecompType::
    OppositeAngledLinesRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    OppositeAngledLinesRecompType::
    OppositeAngledLinesRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    OppositeAngledLinesRecompType::
    OppositeAngledLinesRecompType (const OppositeAngledLinesRecompType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    OppositeAngledLinesRecompType::
    OppositeAngledLinesRecompType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesRecompType* OppositeAngledLinesRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesRecompType (*this, f, c);
    }

    OppositeAngledLinesRecompType& OppositeAngledLinesRecompType::
    operator= (const OppositeAngledLinesRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    OppositeAngledLinesRecompType::
    ~OppositeAngledLinesRecompType ()
    {
    }

    // OppositeAngledLinesIntersectionType
    //

    OppositeAngledLinesIntersectionType::
    OppositeAngledLinesIntersectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
    }

    OppositeAngledLinesIntersectionType::
    OppositeAngledLinesIntersectionType (const IntersectionPlane_type& IntersectionPlane,
                                         const IntersectionFeature_type& IntersectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, this),
      IntersectionFeature_ (IntersectionFeature, this)
    {
    }

    OppositeAngledLinesIntersectionType::
    OppositeAngledLinesIntersectionType (::std::unique_ptr< IntersectionPlane_type > IntersectionPlane,
                                         ::std::unique_ptr< IntersectionFeature_type > IntersectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionPlane_ (std::move (IntersectionPlane), this),
      IntersectionFeature_ (std::move (IntersectionFeature), this)
    {
    }

    OppositeAngledLinesIntersectionType::
    OppositeAngledLinesIntersectionType (const OppositeAngledLinesIntersectionType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      IntersectionPlane_ (x.IntersectionPlane_, f, this),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    OppositeAngledLinesIntersectionType::
    OppositeAngledLinesIntersectionType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionPlane
        //
        if (n.name () == L"IntersectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionPlane_type > r (
            IntersectionPlane_traits::create (i, f, this));

          if (!IntersectionPlane_.present ())
          {
            this->IntersectionPlane_.set (::std::move (r));
            continue;
          }
        }

        // IntersectionFeature
        //
        if (n.name () == L"IntersectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          if (!IntersectionFeature_.present ())
          {
            this->IntersectionFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!IntersectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IntersectionFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesIntersectionType* OppositeAngledLinesIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesIntersectionType (*this, f, c);
    }

    OppositeAngledLinesIntersectionType& OppositeAngledLinesIntersectionType::
    operator= (const OppositeAngledLinesIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionPlane_ = x.IntersectionPlane_;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    OppositeAngledLinesIntersectionType::
    ~OppositeAngledLinesIntersectionType ()
    {
    }

    // OppositeAngledLinesProjectionType
    //

    OppositeAngledLinesProjectionType::
    OppositeAngledLinesProjectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (this),
      ProjectionOppositeAngledLines_ (this)
    {
    }

    OppositeAngledLinesProjectionType::
    OppositeAngledLinesProjectionType (const ProjectionPlane_type& ProjectionPlane,
                                       const ProjectionOppositeAngledLines_type& ProjectionOppositeAngledLines)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionOppositeAngledLines_ (ProjectionOppositeAngledLines, this)
    {
    }

    OppositeAngledLinesProjectionType::
    OppositeAngledLinesProjectionType (::std::unique_ptr< ProjectionPlane_type > ProjectionPlane,
                                       ::std::unique_ptr< ProjectionOppositeAngledLines_type > ProjectionOppositeAngledLines)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (std::move (ProjectionPlane), this),
      ProjectionOppositeAngledLines_ (std::move (ProjectionOppositeAngledLines), this)
    {
    }

    OppositeAngledLinesProjectionType::
    OppositeAngledLinesProjectionType (const OppositeAngledLinesProjectionType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionOppositeAngledLines_ (x.ProjectionOppositeAngledLines_, f, this)
    {
    }

    OppositeAngledLinesProjectionType::
    OppositeAngledLinesProjectionType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (this),
      ProjectionOppositeAngledLines_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesProjectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProjectionPlane
        //
        if (n.name () == L"ProjectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (::std::move (r));
            continue;
          }
        }

        // ProjectionOppositeAngledLines
        //
        if (n.name () == L"ProjectionOppositeAngledLines" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionOppositeAngledLines_type > r (
            ProjectionOppositeAngledLines_traits::create (i, f, this));

          if (!ProjectionOppositeAngledLines_.present ())
          {
            this->ProjectionOppositeAngledLines_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ProjectionOppositeAngledLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionOppositeAngledLines",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesProjectionType* OppositeAngledLinesProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesProjectionType (*this, f, c);
    }

    OppositeAngledLinesProjectionType& OppositeAngledLinesProjectionType::
    operator= (const OppositeAngledLinesProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionPlane_ = x.ProjectionPlane_;
        this->ProjectionOppositeAngledLines_ = x.ProjectionOppositeAngledLines_;
      }

      return *this;
    }

    OppositeAngledLinesProjectionType::
    ~OppositeAngledLinesProjectionType ()
    {
    }

    // OppositeAngledLinesCopyType
    //

    OppositeAngledLinesCopyType::
    OppositeAngledLinesCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledLines_ (this)
    {
    }

    OppositeAngledLinesCopyType::
    OppositeAngledLinesCopyType (const BaseOppositeAngledLines_type& BaseOppositeAngledLines)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledLines_ (BaseOppositeAngledLines, this)
    {
    }

    OppositeAngledLinesCopyType::
    OppositeAngledLinesCopyType (::std::unique_ptr< BaseOppositeAngledLines_type > BaseOppositeAngledLines)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledLines_ (std::move (BaseOppositeAngledLines), this)
    {
    }

    OppositeAngledLinesCopyType::
    OppositeAngledLinesCopyType (const OppositeAngledLinesCopyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOppositeAngledLines_ (x.BaseOppositeAngledLines_, f, this)
    {
    }

    OppositeAngledLinesCopyType::
    OppositeAngledLinesCopyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeAngledLines_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOppositeAngledLines
        //
        if (n.name () == L"BaseOppositeAngledLines" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOppositeAngledLines_type > r (
            BaseOppositeAngledLines_traits::create (i, f, this));

          if (!BaseOppositeAngledLines_.present ())
          {
            this->BaseOppositeAngledLines_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeAngledLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOppositeAngledLines",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesCopyType* OppositeAngledLinesCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesCopyType (*this, f, c);
    }

    OppositeAngledLinesCopyType& OppositeAngledLinesCopyType::
    operator= (const OppositeAngledLinesCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeAngledLines_ = x.BaseOppositeAngledLines_;
      }

      return *this;
    }

    OppositeAngledLinesCopyType::
    ~OppositeAngledLinesCopyType ()
    {
    }

    // OppositeAngledLinesCastType
    //

    OppositeAngledLinesCastType::
    OppositeAngledLinesCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    OppositeAngledLinesCastType::
    OppositeAngledLinesCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    OppositeAngledLinesCastType::
    OppositeAngledLinesCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    OppositeAngledLinesCastType::
    OppositeAngledLinesCastType (const OppositeAngledLinesCastType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositeAngledLinesCastType::
    OppositeAngledLinesCastType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesCastType* OppositeAngledLinesCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesCastType (*this, f, c);
    }

    OppositeAngledLinesCastType& OppositeAngledLinesCastType::
    operator= (const OppositeAngledLinesCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    OppositeAngledLinesCastType::
    ~OppositeAngledLinesCastType ()
    {
    }

    // OppositeAngledLinesTransformType
    //

    OppositeAngledLinesTransformType::
    OppositeAngledLinesTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledLines_ (this),
      Transformation_ (this)
    {
    }

    OppositeAngledLinesTransformType::
    OppositeAngledLinesTransformType (const BaseOppositeAngledLines_type& BaseOppositeAngledLines,
                                      const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledLines_ (BaseOppositeAngledLines, this),
      Transformation_ (Transformation, this)
    {
    }

    OppositeAngledLinesTransformType::
    OppositeAngledLinesTransformType (::std::unique_ptr< BaseOppositeAngledLines_type > BaseOppositeAngledLines,
                                      ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledLines_ (std::move (BaseOppositeAngledLines), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    OppositeAngledLinesTransformType::
    OppositeAngledLinesTransformType (const OppositeAngledLinesTransformType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOppositeAngledLines_ (x.BaseOppositeAngledLines_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    OppositeAngledLinesTransformType::
    OppositeAngledLinesTransformType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeAngledLines_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOppositeAngledLines
        //
        if (n.name () == L"BaseOppositeAngledLines" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOppositeAngledLines_type > r (
            BaseOppositeAngledLines_traits::create (i, f, this));

          if (!BaseOppositeAngledLines_.present ())
          {
            this->BaseOppositeAngledLines_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeAngledLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOppositeAngledLines",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesTransformType* OppositeAngledLinesTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesTransformType (*this, f, c);
    }

    OppositeAngledLinesTransformType& OppositeAngledLinesTransformType::
    operator= (const OppositeAngledLinesTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeAngledLines_ = x.BaseOppositeAngledLines_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    OppositeAngledLinesTransformType::
    ~OppositeAngledLinesTransformType ()
    {
    }

    // OppositeAngledLinesFromScanType
    //

    OppositeAngledLinesFromScanType::
    OppositeAngledLinesFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
    }

    OppositeAngledLinesFromScanType::
    OppositeAngledLinesFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                     const SearchRadius_type& SearchRadius,
                                     const Depth_type& Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    OppositeAngledLinesFromScanType::
    OppositeAngledLinesFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                                     ::std::unique_ptr< SearchRadius_type > SearchRadius,
                                     ::std::unique_ptr< Depth_type > Depth)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      Depth_ (std::move (Depth), this)
    {
    }

    OppositeAngledLinesFromScanType::
    OppositeAngledLinesFromScanType (const OppositeAngledLinesFromScanType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    OppositeAngledLinesFromScanType::
    OppositeAngledLinesFromScanType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Depth",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesFromScanType* OppositeAngledLinesFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesFromScanType (*this, f, c);
    }

    OppositeAngledLinesFromScanType& OppositeAngledLinesFromScanType::
    operator= (const OppositeAngledLinesFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    OppositeAngledLinesFromScanType::
    ~OppositeAngledLinesFromScanType ()
    {
    }

    // OppositeAngledLinesCheckedType
    //

    OppositeAngledLinesCheckedType::
    OppositeAngledLinesCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OppositeAngledLinesCheckedType::
    OppositeAngledLinesCheckedType (const OppositeAngledLinesCheckedType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeAngledLinesCheckedType::
    OppositeAngledLinesCheckedType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledLinesCheckedType* OppositeAngledLinesCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesCheckedType (*this, f, c);
    }

    OppositeAngledLinesCheckedType& OppositeAngledLinesCheckedType::
    operator= (const OppositeAngledLinesCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeAngledLinesCheckedType::
    ~OppositeAngledLinesCheckedType ()
    {
    }

    // OppositeAngledLinesCheckedFeatureType
    //

    OppositeAngledLinesCheckedFeatureType::
    OppositeAngledLinesCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OppositeAngledLinesCheckedFeatureType::
    OppositeAngledLinesCheckedFeatureType (const OppositeAngledLinesCheckedFeatureType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OppositeAngledLinesCheckedFeatureType::
    OppositeAngledLinesCheckedFeatureType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledLinesCheckedFeatureType* OppositeAngledLinesCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesCheckedFeatureType (*this, f, c);
    }

    OppositeAngledLinesCheckedFeatureType& OppositeAngledLinesCheckedFeatureType::
    operator= (const OppositeAngledLinesCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OppositeAngledLinesCheckedFeatureType::
    ~OppositeAngledLinesCheckedFeatureType ()
    {
    }

    // OppositeAngledLinesMeasurementDeterminationType
    //

    OppositeAngledLinesMeasurementDeterminationType::
    OppositeAngledLinesMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OppositeAngledLinesMeasurementDeterminationType::
    OppositeAngledLinesMeasurementDeterminationType (const OppositeAngledLinesMeasurementDeterminationType& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OppositeAngledLinesMeasurementDeterminationType::
    OppositeAngledLinesMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledLinesMeasurementDeterminationType* OppositeAngledLinesMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesMeasurementDeterminationType (*this, f, c);
    }

    OppositeAngledLinesMeasurementDeterminationType& OppositeAngledLinesMeasurementDeterminationType::
    operator= (const OppositeAngledLinesMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OppositeAngledLinesMeasurementDeterminationType::
    ~OppositeAngledLinesMeasurementDeterminationType ()
    {
    }

    // OppositeAngledLinesFeatureItemType
    //

    OppositeAngledLinesFeatureItemType::
    OppositeAngledLinesFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    OppositeAngledLinesFeatureItemType::
    OppositeAngledLinesFeatureItemType (const id_type& id,
                                        const FeatureNominalId_type& FeatureNominalId,
                                        const FeatureName_type& FeatureName,
                                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    OppositeAngledLinesFeatureItemType::
    OppositeAngledLinesFeatureItemType (const id_type& id,
                                        ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                        const FeatureName_type& FeatureName,
                                        ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    OppositeAngledLinesFeatureItemType::
    OppositeAngledLinesFeatureItemType (const OppositeAngledLinesFeatureItemType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    OppositeAngledLinesFeatureItemType::
    OppositeAngledLinesFeatureItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesFeatureItemType* OppositeAngledLinesFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesFeatureItemType (*this, f, c);
    }

    OppositeAngledLinesFeatureItemType& OppositeAngledLinesFeatureItemType::
    operator= (const OppositeAngledLinesFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    OppositeAngledLinesFeatureItemType::
    ~OppositeAngledLinesFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeAngledLinesFeatureItemType >
    _xsd_OppositeAngledLinesFeatureItemType_type_factory_init (
      L"OppositeAngledLinesFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledLinesFeatureDefinitionType
    //

    OppositeAngledLinesFeatureDefinitionType::
    OppositeAngledLinesFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      TaperAngle_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeAngledLinesFeatureDefinitionType::
    OppositeAngledLinesFeatureDefinitionType (const id_type& id,
                                              const InternalExternal_type& InternalExternal,
                                              const Width_type& Width,
                                              const EndType_type& EndType,
                                              const TaperAngle_type& TaperAngle)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (Width, this),
      Length_ (this),
      EndType_ (EndType, this),
      TaperAngle_ (TaperAngle, this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeAngledLinesFeatureDefinitionType::
    OppositeAngledLinesFeatureDefinitionType (const id_type& id,
                                              const InternalExternal_type& InternalExternal,
                                              ::std::unique_ptr< Width_type > Width,
                                              ::std::unique_ptr< EndType_type > EndType,
                                              ::std::unique_ptr< TaperAngle_type > TaperAngle)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (std::move (Width), this),
      Length_ (this),
      EndType_ (std::move (EndType), this),
      TaperAngle_ (std::move (TaperAngle), this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeAngledLinesFeatureDefinitionType::
    OppositeAngledLinesFeatureDefinitionType (const OppositeAngledLinesFeatureDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Width_ (x.Width_, f, this),
      Length_ (x.Length_, f, this),
      EndType_ (x.EndType_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      SingleOpenEnd_ (x.SingleOpenEnd_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this)
    {
    }

    OppositeAngledLinesFeatureDefinitionType::
    OppositeAngledLinesFeatureDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      TaperAngle_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // EndType
        //
        if (n.name () == L"EndType" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndType_type > r (
            EndType_traits::create (i, f, this));

          if (!EndType_.present ())
          {
            this->EndType_.set (::std::move (r));
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == L"TaperAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!TaperAngle_.present ())
          {
            this->TaperAngle_.set (::std::move (r));
            continue;
          }
        }

        // SingleOpenEnd
        //
        if (n.name () == L"SingleOpenEnd" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SingleOpenEnd_)
          {
            this->SingleOpenEnd_.set (SingleOpenEnd_traits::create (i, f, this));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == L"EndRadius1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == L"EndRadius2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Width",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!EndType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndType",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!TaperAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TaperAngle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesFeatureDefinitionType* OppositeAngledLinesFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesFeatureDefinitionType (*this, f, c);
    }

    OppositeAngledLinesFeatureDefinitionType& OppositeAngledLinesFeatureDefinitionType::
    operator= (const OppositeAngledLinesFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Width_ = x.Width_;
        this->Length_ = x.Length_;
        this->EndType_ = x.EndType_;
        this->TaperAngle_ = x.TaperAngle_;
        this->SingleOpenEnd_ = x.SingleOpenEnd_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
      }

      return *this;
    }

    OppositeAngledLinesFeatureDefinitionType::
    ~OppositeAngledLinesFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeAngledLinesFeatureDefinitionType >
    _xsd_OppositeAngledLinesFeatureDefinitionType_type_factory_init (
      L"OppositeAngledLinesFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledLinesFeatureNominalType
    //

    OppositeAngledLinesFeatureNominalType::
    OppositeAngledLinesFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      CenterLine_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    OppositeAngledLinesFeatureNominalType::
    OppositeAngledLinesFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           const CenterLine_type& CenterLine,
                                           const Normal_type& Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      CenterLine_ (CenterLine, this),
      Normal_ (Normal, this),
      Constructed_ (this)
    {
    }

    OppositeAngledLinesFeatureNominalType::
    OppositeAngledLinesFeatureNominalType (const id_type& id,
                                           ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                           ::std::unique_ptr< CenterLine_type > CenterLine,
                                           ::std::unique_ptr< Normal_type > Normal)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      CenterLine_ (std::move (CenterLine), this),
      Normal_ (std::move (Normal), this),
      Constructed_ (this)
    {
    }

    OppositeAngledLinesFeatureNominalType::
    OppositeAngledLinesFeatureNominalType (const OppositeAngledLinesFeatureNominalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeAngledLinesFeatureNominalType::
    OppositeAngledLinesFeatureNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterLine
        //
        if (n.name () == L"CenterLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!CenterLine_.present ())
          {
            this->CenterLine_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterLine",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledLinesFeatureNominalType* OppositeAngledLinesFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesFeatureNominalType (*this, f, c);
    }

    OppositeAngledLinesFeatureNominalType& OppositeAngledLinesFeatureNominalType::
    operator= (const OppositeAngledLinesFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->CenterLine_ = x.CenterLine_;
        this->Normal_ = x.Normal_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeAngledLinesFeatureNominalType::
    ~OppositeAngledLinesFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeAngledLinesFeatureNominalType >
    _xsd_OppositeAngledLinesFeatureNominalType_type_factory_init (
      L"OppositeAngledLinesFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledLinesFeatureMeasurementType
    //

    OppositeAngledLinesFeatureMeasurementType::
    OppositeAngledLinesFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      TaperAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeAngledLinesFeatureMeasurementType::
    OppositeAngledLinesFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      TaperAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeAngledLinesFeatureMeasurementType::
    OppositeAngledLinesFeatureMeasurementType (const OppositeAngledLinesFeatureMeasurementType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this),
      Width_ (x.Width_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      Length_ (x.Length_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    OppositeAngledLinesFeatureMeasurementType::
    OppositeAngledLinesFeatureMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      TaperAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledLinesFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterLine
        //
        if (n.name () == L"CenterLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!this->CenterLine_)
          {
            this->CenterLine_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == L"WidthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (::std::move (r));
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == L"WidthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == L"LengthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (::std::move (r));
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == L"LengthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (::std::move (r));
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == L"TaperAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == L"EndRadius1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == L"EndRadius2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledLinesFeatureMeasurementType* OppositeAngledLinesFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledLinesFeatureMeasurementType (*this, f, c);
    }

    OppositeAngledLinesFeatureMeasurementType& OppositeAngledLinesFeatureMeasurementType::
    operator= (const OppositeAngledLinesFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->CenterLine_ = x.CenterLine_;
        this->Normal_ = x.Normal_;
        this->Width_ = x.Width_;
        this->WidthMin_ = x.WidthMin_;
        this->WidthMax_ = x.WidthMax_;
        this->Length_ = x.Length_;
        this->LengthMin_ = x.LengthMin_;
        this->LengthMax_ = x.LengthMax_;
        this->TaperAngle_ = x.TaperAngle_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    OppositeAngledLinesFeatureMeasurementType::
    ~OppositeAngledLinesFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeAngledLinesFeatureMeasurementType >
    _xsd_OppositeAngledLinesFeatureMeasurementType_type_factory_init (
      L"OppositeAngledLinesFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelPlanesConstructionMethodType
    //

    OppositeParallelPlanesConstructionMethodType::
    OppositeParallelPlanesConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    OppositeParallelPlanesConstructionMethodType::
    OppositeParallelPlanesConstructionMethodType (const OppositeParallelPlanesConstructionMethodType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    OppositeParallelPlanesConstructionMethodType::
    OppositeParallelPlanesConstructionMethodType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelPlanesConstructionMethodType* OppositeParallelPlanesConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesConstructionMethodType (*this, f, c);
    }

    OppositeParallelPlanesConstructionMethodType& OppositeParallelPlanesConstructionMethodType::
    operator= (const OppositeParallelPlanesConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    OppositeParallelPlanesConstructionMethodType::
    ~OppositeParallelPlanesConstructionMethodType ()
    {
    }

    // OppositeParallelPlanesBestFitType
    //

    OppositeParallelPlanesBestFitType::
    OppositeParallelPlanesBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    OppositeParallelPlanesBestFitType::
    OppositeParallelPlanesBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    OppositeParallelPlanesBestFitType::
    OppositeParallelPlanesBestFitType (const OppositeParallelPlanesBestFitType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    OppositeParallelPlanesBestFitType::
    OppositeParallelPlanesBestFitType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    OppositeParallelPlanesBestFitType* OppositeParallelPlanesBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesBestFitType (*this, f, c);
    }

    OppositeParallelPlanesBestFitType& OppositeParallelPlanesBestFitType::
    operator= (const OppositeParallelPlanesBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    OppositeParallelPlanesBestFitType::
    ~OppositeParallelPlanesBestFitType ()
    {
    }

    // OppositeParallelPlanesRecompType
    //

    OppositeParallelPlanesRecompType::
    OppositeParallelPlanesRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    OppositeParallelPlanesRecompType::
    OppositeParallelPlanesRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    OppositeParallelPlanesRecompType::
    OppositeParallelPlanesRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    OppositeParallelPlanesRecompType::
    OppositeParallelPlanesRecompType (const OppositeParallelPlanesRecompType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    OppositeParallelPlanesRecompType::
    OppositeParallelPlanesRecompType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelPlanesRecompType* OppositeParallelPlanesRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesRecompType (*this, f, c);
    }

    OppositeParallelPlanesRecompType& OppositeParallelPlanesRecompType::
    operator= (const OppositeParallelPlanesRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    OppositeParallelPlanesRecompType::
    ~OppositeParallelPlanesRecompType ()
    {
    }

    // OppositeParallelPlanesCopyType
    //

    OppositeParallelPlanesCopyType::
    OppositeParallelPlanesCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelPlanes_ (this)
    {
    }

    OppositeParallelPlanesCopyType::
    OppositeParallelPlanesCopyType (const BaseOppositeParallelPlanes_type& BaseOppositeParallelPlanes)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelPlanes_ (BaseOppositeParallelPlanes, this)
    {
    }

    OppositeParallelPlanesCopyType::
    OppositeParallelPlanesCopyType (::std::unique_ptr< BaseOppositeParallelPlanes_type > BaseOppositeParallelPlanes)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelPlanes_ (std::move (BaseOppositeParallelPlanes), this)
    {
    }

    OppositeParallelPlanesCopyType::
    OppositeParallelPlanesCopyType (const OppositeParallelPlanesCopyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOppositeParallelPlanes_ (x.BaseOppositeParallelPlanes_, f, this)
    {
    }

    OppositeParallelPlanesCopyType::
    OppositeParallelPlanesCopyType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeParallelPlanes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOppositeParallelPlanes
        //
        if (n.name () == L"BaseOppositeParallelPlanes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOppositeParallelPlanes_type > r (
            BaseOppositeParallelPlanes_traits::create (i, f, this));

          if (!BaseOppositeParallelPlanes_.present ())
          {
            this->BaseOppositeParallelPlanes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeParallelPlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOppositeParallelPlanes",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelPlanesCopyType* OppositeParallelPlanesCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesCopyType (*this, f, c);
    }

    OppositeParallelPlanesCopyType& OppositeParallelPlanesCopyType::
    operator= (const OppositeParallelPlanesCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeParallelPlanes_ = x.BaseOppositeParallelPlanes_;
      }

      return *this;
    }

    OppositeParallelPlanesCopyType::
    ~OppositeParallelPlanesCopyType ()
    {
    }

    // OppositeParallelPlanesCastType
    //

    OppositeParallelPlanesCastType::
    OppositeParallelPlanesCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    OppositeParallelPlanesCastType::
    OppositeParallelPlanesCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    OppositeParallelPlanesCastType::
    OppositeParallelPlanesCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    OppositeParallelPlanesCastType::
    OppositeParallelPlanesCastType (const OppositeParallelPlanesCastType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositeParallelPlanesCastType::
    OppositeParallelPlanesCastType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelPlanesCastType* OppositeParallelPlanesCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesCastType (*this, f, c);
    }

    OppositeParallelPlanesCastType& OppositeParallelPlanesCastType::
    operator= (const OppositeParallelPlanesCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    OppositeParallelPlanesCastType::
    ~OppositeParallelPlanesCastType ()
    {
    }

    // OppositeParallelPlanesTransformType
    //

    OppositeParallelPlanesTransformType::
    OppositeParallelPlanesTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelPlanes_ (this),
      Transformation_ (this)
    {
    }

    OppositeParallelPlanesTransformType::
    OppositeParallelPlanesTransformType (const BaseOppositeParallelPlanes_type& BaseOppositeParallelPlanes,
                                         const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelPlanes_ (BaseOppositeParallelPlanes, this),
      Transformation_ (Transformation, this)
    {
    }

    OppositeParallelPlanesTransformType::
    OppositeParallelPlanesTransformType (::std::unique_ptr< BaseOppositeParallelPlanes_type > BaseOppositeParallelPlanes,
                                         ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeParallelPlanes_ (std::move (BaseOppositeParallelPlanes), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    OppositeParallelPlanesTransformType::
    OppositeParallelPlanesTransformType (const OppositeParallelPlanesTransformType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOppositeParallelPlanes_ (x.BaseOppositeParallelPlanes_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    OppositeParallelPlanesTransformType::
    OppositeParallelPlanesTransformType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeParallelPlanes_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOppositeParallelPlanes
        //
        if (n.name () == L"BaseOppositeParallelPlanes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOppositeParallelPlanes_type > r (
            BaseOppositeParallelPlanes_traits::create (i, f, this));

          if (!BaseOppositeParallelPlanes_.present ())
          {
            this->BaseOppositeParallelPlanes_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeParallelPlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOppositeParallelPlanes",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelPlanesTransformType* OppositeParallelPlanesTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesTransformType (*this, f, c);
    }

    OppositeParallelPlanesTransformType& OppositeParallelPlanesTransformType::
    operator= (const OppositeParallelPlanesTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeParallelPlanes_ = x.BaseOppositeParallelPlanes_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    OppositeParallelPlanesTransformType::
    ~OppositeParallelPlanesTransformType ()
    {
    }

    // OppositeParallelPlanesFromScanType
    //

    OppositeParallelPlanesFromScanType::
    OppositeParallelPlanesFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
    }

    OppositeParallelPlanesFromScanType::
    OppositeParallelPlanesFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                        const SearchRadius_type& SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    OppositeParallelPlanesFromScanType::
    OppositeParallelPlanesFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                                        ::std::unique_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this)
    {
    }

    OppositeParallelPlanesFromScanType::
    OppositeParallelPlanesFromScanType (const OppositeParallelPlanesFromScanType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    OppositeParallelPlanesFromScanType::
    OppositeParallelPlanesFromScanType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelPlanesFromScanType* OppositeParallelPlanesFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesFromScanType (*this, f, c);
    }

    OppositeParallelPlanesFromScanType& OppositeParallelPlanesFromScanType::
    operator= (const OppositeParallelPlanesFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    OppositeParallelPlanesFromScanType::
    ~OppositeParallelPlanesFromScanType ()
    {
    }

    // OppositeParallelPlanesCheckedType
    //

    OppositeParallelPlanesCheckedType::
    OppositeParallelPlanesCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OppositeParallelPlanesCheckedType::
    OppositeParallelPlanesCheckedType (const OppositeParallelPlanesCheckedType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeParallelPlanesCheckedType::
    OppositeParallelPlanesCheckedType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelPlanesCheckedType* OppositeParallelPlanesCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesCheckedType (*this, f, c);
    }

    OppositeParallelPlanesCheckedType& OppositeParallelPlanesCheckedType::
    operator= (const OppositeParallelPlanesCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeParallelPlanesCheckedType::
    ~OppositeParallelPlanesCheckedType ()
    {
    }

    // OppositeParallelPlanesCheckedFeatureType
    //

    OppositeParallelPlanesCheckedFeatureType::
    OppositeParallelPlanesCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OppositeParallelPlanesCheckedFeatureType::
    OppositeParallelPlanesCheckedFeatureType (const OppositeParallelPlanesCheckedFeatureType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OppositeParallelPlanesCheckedFeatureType::
    OppositeParallelPlanesCheckedFeatureType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelPlanesCheckedFeatureType* OppositeParallelPlanesCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesCheckedFeatureType (*this, f, c);
    }

    OppositeParallelPlanesCheckedFeatureType& OppositeParallelPlanesCheckedFeatureType::
    operator= (const OppositeParallelPlanesCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OppositeParallelPlanesCheckedFeatureType::
    ~OppositeParallelPlanesCheckedFeatureType ()
    {
    }

    // OppositeParallelPlanesMeasurementDeterminationType
    //

    OppositeParallelPlanesMeasurementDeterminationType::
    OppositeParallelPlanesMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OppositeParallelPlanesMeasurementDeterminationType::
    OppositeParallelPlanesMeasurementDeterminationType (const OppositeParallelPlanesMeasurementDeterminationType& x,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OppositeParallelPlanesMeasurementDeterminationType::
    OppositeParallelPlanesMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelPlanesMeasurementDeterminationType* OppositeParallelPlanesMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesMeasurementDeterminationType (*this, f, c);
    }

    OppositeParallelPlanesMeasurementDeterminationType& OppositeParallelPlanesMeasurementDeterminationType::
    operator= (const OppositeParallelPlanesMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OppositeParallelPlanesMeasurementDeterminationType::
    ~OppositeParallelPlanesMeasurementDeterminationType ()
    {
    }

    // OppositeParallelPlanesFeatureItemType
    //

    OppositeParallelPlanesFeatureItemType::
    OppositeParallelPlanesFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    OppositeParallelPlanesFeatureItemType::
    OppositeParallelPlanesFeatureItemType (const id_type& id,
                                           const FeatureNominalId_type& FeatureNominalId,
                                           const FeatureName_type& FeatureName,
                                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    OppositeParallelPlanesFeatureItemType::
    OppositeParallelPlanesFeatureItemType (const id_type& id,
                                           ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                           const FeatureName_type& FeatureName,
                                           ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    OppositeParallelPlanesFeatureItemType::
    OppositeParallelPlanesFeatureItemType (const OppositeParallelPlanesFeatureItemType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    OppositeParallelPlanesFeatureItemType::
    OppositeParallelPlanesFeatureItemType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelPlanesFeatureItemType* OppositeParallelPlanesFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesFeatureItemType (*this, f, c);
    }

    OppositeParallelPlanesFeatureItemType& OppositeParallelPlanesFeatureItemType::
    operator= (const OppositeParallelPlanesFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    OppositeParallelPlanesFeatureItemType::
    ~OppositeParallelPlanesFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeParallelPlanesFeatureItemType >
    _xsd_OppositeParallelPlanesFeatureItemType_type_factory_init (
      L"OppositeParallelPlanesFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelPlanesFeatureDefinitionType
    //

    OppositeParallelPlanesFeatureDefinitionType::
    OppositeParallelPlanesFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeParallelPlanesFeatureDefinitionType::
    OppositeParallelPlanesFeatureDefinitionType (const id_type& id,
                                                 const InternalExternal_type& InternalExternal,
                                                 const Width_type& Width,
                                                 const EndType_type& EndType)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (Width, this),
      Length_ (this),
      EndType_ (EndType, this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeParallelPlanesFeatureDefinitionType::
    OppositeParallelPlanesFeatureDefinitionType (const id_type& id,
                                                 const InternalExternal_type& InternalExternal,
                                                 ::std::unique_ptr< Width_type > Width,
                                                 ::std::unique_ptr< EndType_type > EndType)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (std::move (Width), this),
      Length_ (this),
      EndType_ (std::move (EndType), this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeParallelPlanesFeatureDefinitionType::
    OppositeParallelPlanesFeatureDefinitionType (const OppositeParallelPlanesFeatureDefinitionType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Width_ (x.Width_, f, this),
      Length_ (x.Length_, f, this),
      EndType_ (x.EndType_, f, this),
      Depth_ (x.Depth_, f, this),
      Bottom_ (x.Bottom_, f, this),
      SingleOpenEnd_ (x.SingleOpenEnd_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this)
    {
    }

    OppositeParallelPlanesFeatureDefinitionType::
    OppositeParallelPlanesFeatureDefinitionType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // EndType
        //
        if (n.name () == L"EndType" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndType_type > r (
            EndType_traits::create (i, f, this));

          if (!EndType_.present ())
          {
            this->EndType_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == L"Bottom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (::std::move (r));
            continue;
          }
        }

        // SingleOpenEnd
        //
        if (n.name () == L"SingleOpenEnd" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SingleOpenEnd_)
          {
            this->SingleOpenEnd_.set (SingleOpenEnd_traits::create (i, f, this));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == L"EndRadius1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == L"EndRadius2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Width",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!EndType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndType",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelPlanesFeatureDefinitionType* OppositeParallelPlanesFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesFeatureDefinitionType (*this, f, c);
    }

    OppositeParallelPlanesFeatureDefinitionType& OppositeParallelPlanesFeatureDefinitionType::
    operator= (const OppositeParallelPlanesFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Width_ = x.Width_;
        this->Length_ = x.Length_;
        this->EndType_ = x.EndType_;
        this->Depth_ = x.Depth_;
        this->Bottom_ = x.Bottom_;
        this->SingleOpenEnd_ = x.SingleOpenEnd_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
      }

      return *this;
    }

    OppositeParallelPlanesFeatureDefinitionType::
    ~OppositeParallelPlanesFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeParallelPlanesFeatureDefinitionType >
    _xsd_OppositeParallelPlanesFeatureDefinitionType_type_factory_init (
      L"OppositeParallelPlanesFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelPlanesFeatureNominalType
    //

    OppositeParallelPlanesFeatureNominalType::
    OppositeParallelPlanesFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Constructed_ (this)
    {
    }

    OppositeParallelPlanesFeatureNominalType::
    OppositeParallelPlanesFeatureNominalType (const id_type& id,
                                              const FeatureDefinitionId_type& FeatureDefinitionId,
                                              const CenterPlane_type& CenterPlane)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      CenterPlane_ (CenterPlane, this),
      LengthVector_ (this),
      DepthVector_ (this),
      Constructed_ (this)
    {
    }

    OppositeParallelPlanesFeatureNominalType::
    OppositeParallelPlanesFeatureNominalType (const id_type& id,
                                              ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                              ::std::unique_ptr< CenterPlane_type > CenterPlane)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      CenterPlane_ (std::move (CenterPlane), this),
      LengthVector_ (this),
      DepthVector_ (this),
      Constructed_ (this)
    {
    }

    OppositeParallelPlanesFeatureNominalType::
    OppositeParallelPlanesFeatureNominalType (const OppositeParallelPlanesFeatureNominalType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeParallelPlanesFeatureNominalType::
    OppositeParallelPlanesFeatureNominalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterPlane
        //
        if (n.name () == L"CenterPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!CenterPlane_.present ())
          {
            this->CenterPlane_.set (::std::move (r));
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == L"LengthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (::std::move (r));
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == L"DepthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterPlane",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeParallelPlanesFeatureNominalType* OppositeParallelPlanesFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesFeatureNominalType (*this, f, c);
    }

    OppositeParallelPlanesFeatureNominalType& OppositeParallelPlanesFeatureNominalType::
    operator= (const OppositeParallelPlanesFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->CenterPlane_ = x.CenterPlane_;
        this->LengthVector_ = x.LengthVector_;
        this->DepthVector_ = x.DepthVector_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeParallelPlanesFeatureNominalType::
    ~OppositeParallelPlanesFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeParallelPlanesFeatureNominalType >
    _xsd_OppositeParallelPlanesFeatureNominalType_type_factory_init (
      L"OppositeParallelPlanesFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeParallelPlanesFeatureMeasurementType
    //

    OppositeParallelPlanesFeatureMeasurementType::
    OppositeParallelPlanesFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeParallelPlanesFeatureMeasurementType::
    OppositeParallelPlanesFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeParallelPlanesFeatureMeasurementType::
    OppositeParallelPlanesFeatureMeasurementType (const OppositeParallelPlanesFeatureMeasurementType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Width_ (x.Width_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      Length_ (x.Length_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      Depth_ (x.Depth_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    OppositeParallelPlanesFeatureMeasurementType::
    OppositeParallelPlanesFeatureMeasurementType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeParallelPlanesFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterPlane
        //
        if (n.name () == L"CenterPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!this->CenterPlane_)
          {
            this->CenterPlane_.set (::std::move (r));
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == L"LengthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (::std::move (r));
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == L"DepthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == L"WidthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (::std::move (r));
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == L"WidthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == L"LengthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (::std::move (r));
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == L"LengthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == L"EndRadius1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == L"EndRadius2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeParallelPlanesFeatureMeasurementType* OppositeParallelPlanesFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeParallelPlanesFeatureMeasurementType (*this, f, c);
    }

    OppositeParallelPlanesFeatureMeasurementType& OppositeParallelPlanesFeatureMeasurementType::
    operator= (const OppositeParallelPlanesFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->CenterPlane_ = x.CenterPlane_;
        this->LengthVector_ = x.LengthVector_;
        this->DepthVector_ = x.DepthVector_;
        this->Width_ = x.Width_;
        this->WidthMin_ = x.WidthMin_;
        this->WidthMax_ = x.WidthMax_;
        this->Length_ = x.Length_;
        this->LengthMin_ = x.LengthMin_;
        this->LengthMax_ = x.LengthMax_;
        this->Depth_ = x.Depth_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    OppositeParallelPlanesFeatureMeasurementType::
    ~OppositeParallelPlanesFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeParallelPlanesFeatureMeasurementType >
    _xsd_OppositeParallelPlanesFeatureMeasurementType_type_factory_init (
      L"OppositeParallelPlanesFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledPlanesConstructionMethodType
    //

    OppositeAngledPlanesConstructionMethodType::
    OppositeAngledPlanesConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    OppositeAngledPlanesConstructionMethodType::
    OppositeAngledPlanesConstructionMethodType (const OppositeAngledPlanesConstructionMethodType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    OppositeAngledPlanesConstructionMethodType::
    OppositeAngledPlanesConstructionMethodType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledPlanesConstructionMethodType* OppositeAngledPlanesConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesConstructionMethodType (*this, f, c);
    }

    OppositeAngledPlanesConstructionMethodType& OppositeAngledPlanesConstructionMethodType::
    operator= (const OppositeAngledPlanesConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    OppositeAngledPlanesConstructionMethodType::
    ~OppositeAngledPlanesConstructionMethodType ()
    {
    }

    // OppositeAngledPlanesBestFitType
    //

    OppositeAngledPlanesBestFitType::
    OppositeAngledPlanesBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    OppositeAngledPlanesBestFitType::
    OppositeAngledPlanesBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    OppositeAngledPlanesBestFitType::
    OppositeAngledPlanesBestFitType (const OppositeAngledPlanesBestFitType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    OppositeAngledPlanesBestFitType::
    OppositeAngledPlanesBestFitType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    OppositeAngledPlanesBestFitType* OppositeAngledPlanesBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesBestFitType (*this, f, c);
    }

    OppositeAngledPlanesBestFitType& OppositeAngledPlanesBestFitType::
    operator= (const OppositeAngledPlanesBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    OppositeAngledPlanesBestFitType::
    ~OppositeAngledPlanesBestFitType ()
    {
    }

    // OppositeAngledPlanesRecompType
    //

    OppositeAngledPlanesRecompType::
    OppositeAngledPlanesRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    OppositeAngledPlanesRecompType::
    OppositeAngledPlanesRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    OppositeAngledPlanesRecompType::
    OppositeAngledPlanesRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    OppositeAngledPlanesRecompType::
    OppositeAngledPlanesRecompType (const OppositeAngledPlanesRecompType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    OppositeAngledPlanesRecompType::
    OppositeAngledPlanesRecompType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledPlanesRecompType* OppositeAngledPlanesRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesRecompType (*this, f, c);
    }

    OppositeAngledPlanesRecompType& OppositeAngledPlanesRecompType::
    operator= (const OppositeAngledPlanesRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    OppositeAngledPlanesRecompType::
    ~OppositeAngledPlanesRecompType ()
    {
    }

    // OppositeAngledPlanesCopyType
    //

    OppositeAngledPlanesCopyType::
    OppositeAngledPlanesCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledPlanes_ (this)
    {
    }

    OppositeAngledPlanesCopyType::
    OppositeAngledPlanesCopyType (const BaseOppositeAngledPlanes_type& BaseOppositeAngledPlanes)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledPlanes_ (BaseOppositeAngledPlanes, this)
    {
    }

    OppositeAngledPlanesCopyType::
    OppositeAngledPlanesCopyType (::std::unique_ptr< BaseOppositeAngledPlanes_type > BaseOppositeAngledPlanes)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledPlanes_ (std::move (BaseOppositeAngledPlanes), this)
    {
    }

    OppositeAngledPlanesCopyType::
    OppositeAngledPlanesCopyType (const OppositeAngledPlanesCopyType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOppositeAngledPlanes_ (x.BaseOppositeAngledPlanes_, f, this)
    {
    }

    OppositeAngledPlanesCopyType::
    OppositeAngledPlanesCopyType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeAngledPlanes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOppositeAngledPlanes
        //
        if (n.name () == L"BaseOppositeAngledPlanes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOppositeAngledPlanes_type > r (
            BaseOppositeAngledPlanes_traits::create (i, f, this));

          if (!BaseOppositeAngledPlanes_.present ())
          {
            this->BaseOppositeAngledPlanes_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeAngledPlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOppositeAngledPlanes",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledPlanesCopyType* OppositeAngledPlanesCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesCopyType (*this, f, c);
    }

    OppositeAngledPlanesCopyType& OppositeAngledPlanesCopyType::
    operator= (const OppositeAngledPlanesCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeAngledPlanes_ = x.BaseOppositeAngledPlanes_;
      }

      return *this;
    }

    OppositeAngledPlanesCopyType::
    ~OppositeAngledPlanesCopyType ()
    {
    }

    // OppositeAngledPlanesCastType
    //

    OppositeAngledPlanesCastType::
    OppositeAngledPlanesCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    OppositeAngledPlanesCastType::
    OppositeAngledPlanesCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    OppositeAngledPlanesCastType::
    OppositeAngledPlanesCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    OppositeAngledPlanesCastType::
    OppositeAngledPlanesCastType (const OppositeAngledPlanesCastType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositeAngledPlanesCastType::
    OppositeAngledPlanesCastType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledPlanesCastType* OppositeAngledPlanesCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesCastType (*this, f, c);
    }

    OppositeAngledPlanesCastType& OppositeAngledPlanesCastType::
    operator= (const OppositeAngledPlanesCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    OppositeAngledPlanesCastType::
    ~OppositeAngledPlanesCastType ()
    {
    }

    // OppositeAngledPlanesTransformType
    //

    OppositeAngledPlanesTransformType::
    OppositeAngledPlanesTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledPlanes_ (this),
      Transformation_ (this)
    {
    }

    OppositeAngledPlanesTransformType::
    OppositeAngledPlanesTransformType (const BaseOppositeAngledPlanes_type& BaseOppositeAngledPlanes,
                                       const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledPlanes_ (BaseOppositeAngledPlanes, this),
      Transformation_ (Transformation, this)
    {
    }

    OppositeAngledPlanesTransformType::
    OppositeAngledPlanesTransformType (::std::unique_ptr< BaseOppositeAngledPlanes_type > BaseOppositeAngledPlanes,
                                       ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOppositeAngledPlanes_ (std::move (BaseOppositeAngledPlanes), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    OppositeAngledPlanesTransformType::
    OppositeAngledPlanesTransformType (const OppositeAngledPlanesTransformType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOppositeAngledPlanes_ (x.BaseOppositeAngledPlanes_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    OppositeAngledPlanesTransformType::
    OppositeAngledPlanesTransformType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeAngledPlanes_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOppositeAngledPlanes
        //
        if (n.name () == L"BaseOppositeAngledPlanes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOppositeAngledPlanes_type > r (
            BaseOppositeAngledPlanes_traits::create (i, f, this));

          if (!BaseOppositeAngledPlanes_.present ())
          {
            this->BaseOppositeAngledPlanes_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeAngledPlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOppositeAngledPlanes",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledPlanesTransformType* OppositeAngledPlanesTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesTransformType (*this, f, c);
    }

    OppositeAngledPlanesTransformType& OppositeAngledPlanesTransformType::
    operator= (const OppositeAngledPlanesTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeAngledPlanes_ = x.BaseOppositeAngledPlanes_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    OppositeAngledPlanesTransformType::
    ~OppositeAngledPlanesTransformType ()
    {
    }

    // OppositeAngledPlanesFromScanType
    //

    OppositeAngledPlanesFromScanType::
    OppositeAngledPlanesFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
    }

    OppositeAngledPlanesFromScanType::
    OppositeAngledPlanesFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                      const SearchRadius_type& SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    OppositeAngledPlanesFromScanType::
    OppositeAngledPlanesFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                                      ::std::unique_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this)
    {
    }

    OppositeAngledPlanesFromScanType::
    OppositeAngledPlanesFromScanType (const OppositeAngledPlanesFromScanType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    OppositeAngledPlanesFromScanType::
    OppositeAngledPlanesFromScanType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledPlanesFromScanType* OppositeAngledPlanesFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesFromScanType (*this, f, c);
    }

    OppositeAngledPlanesFromScanType& OppositeAngledPlanesFromScanType::
    operator= (const OppositeAngledPlanesFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    OppositeAngledPlanesFromScanType::
    ~OppositeAngledPlanesFromScanType ()
    {
    }

    // OppositeAngledPlanesCheckedType
    //

    OppositeAngledPlanesCheckedType::
    OppositeAngledPlanesCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OppositeAngledPlanesCheckedType::
    OppositeAngledPlanesCheckedType (const OppositeAngledPlanesCheckedType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeAngledPlanesCheckedType::
    OppositeAngledPlanesCheckedType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledPlanesCheckedType* OppositeAngledPlanesCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesCheckedType (*this, f, c);
    }

    OppositeAngledPlanesCheckedType& OppositeAngledPlanesCheckedType::
    operator= (const OppositeAngledPlanesCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeAngledPlanesCheckedType::
    ~OppositeAngledPlanesCheckedType ()
    {
    }

    // OppositeAngledPlanesCheckedFeatureType
    //

    OppositeAngledPlanesCheckedFeatureType::
    OppositeAngledPlanesCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OppositeAngledPlanesCheckedFeatureType::
    OppositeAngledPlanesCheckedFeatureType (const OppositeAngledPlanesCheckedFeatureType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OppositeAngledPlanesCheckedFeatureType::
    OppositeAngledPlanesCheckedFeatureType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledPlanesCheckedFeatureType* OppositeAngledPlanesCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesCheckedFeatureType (*this, f, c);
    }

    OppositeAngledPlanesCheckedFeatureType& OppositeAngledPlanesCheckedFeatureType::
    operator= (const OppositeAngledPlanesCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OppositeAngledPlanesCheckedFeatureType::
    ~OppositeAngledPlanesCheckedFeatureType ()
    {
    }

    // OppositeAngledPlanesMeasurementDeterminationType
    //

    OppositeAngledPlanesMeasurementDeterminationType::
    OppositeAngledPlanesMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OppositeAngledPlanesMeasurementDeterminationType::
    OppositeAngledPlanesMeasurementDeterminationType (const OppositeAngledPlanesMeasurementDeterminationType& x,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OppositeAngledPlanesMeasurementDeterminationType::
    OppositeAngledPlanesMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f,
                                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledPlanesMeasurementDeterminationType* OppositeAngledPlanesMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesMeasurementDeterminationType (*this, f, c);
    }

    OppositeAngledPlanesMeasurementDeterminationType& OppositeAngledPlanesMeasurementDeterminationType::
    operator= (const OppositeAngledPlanesMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OppositeAngledPlanesMeasurementDeterminationType::
    ~OppositeAngledPlanesMeasurementDeterminationType ()
    {
    }

    // OppositeAngledPlanesFeatureItemType
    //

    OppositeAngledPlanesFeatureItemType::
    OppositeAngledPlanesFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    OppositeAngledPlanesFeatureItemType::
    OppositeAngledPlanesFeatureItemType (const id_type& id,
                                         const FeatureNominalId_type& FeatureNominalId,
                                         const FeatureName_type& FeatureName,
                                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    OppositeAngledPlanesFeatureItemType::
    OppositeAngledPlanesFeatureItemType (const id_type& id,
                                         ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                         const FeatureName_type& FeatureName,
                                         ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    OppositeAngledPlanesFeatureItemType::
    OppositeAngledPlanesFeatureItemType (const OppositeAngledPlanesFeatureItemType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    OppositeAngledPlanesFeatureItemType::
    OppositeAngledPlanesFeatureItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledPlanesFeatureItemType* OppositeAngledPlanesFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesFeatureItemType (*this, f, c);
    }

    OppositeAngledPlanesFeatureItemType& OppositeAngledPlanesFeatureItemType::
    operator= (const OppositeAngledPlanesFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    OppositeAngledPlanesFeatureItemType::
    ~OppositeAngledPlanesFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeAngledPlanesFeatureItemType >
    _xsd_OppositeAngledPlanesFeatureItemType_type_factory_init (
      L"OppositeAngledPlanesFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledPlanesFeatureDefinitionType
    //

    OppositeAngledPlanesFeatureDefinitionType::
    OppositeAngledPlanesFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this)
    {
    }

    OppositeAngledPlanesFeatureDefinitionType::
    OppositeAngledPlanesFeatureDefinitionType (const id_type& id,
                                               const InternalExternal_type& InternalExternal,
                                               const Width_type& Width,
                                               const EndType_type& EndType)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (Width, this),
      Length_ (this),
      EndType_ (EndType, this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this)
    {
    }

    OppositeAngledPlanesFeatureDefinitionType::
    OppositeAngledPlanesFeatureDefinitionType (const id_type& id,
                                               const InternalExternal_type& InternalExternal,
                                               ::std::unique_ptr< Width_type > Width,
                                               ::std::unique_ptr< EndType_type > EndType)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (std::move (Width), this),
      Length_ (this),
      EndType_ (std::move (EndType), this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this)
    {
    }

    OppositeAngledPlanesFeatureDefinitionType::
    OppositeAngledPlanesFeatureDefinitionType (const OppositeAngledPlanesFeatureDefinitionType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Width_ (x.Width_, f, this),
      Length_ (x.Length_, f, this),
      EndType_ (x.EndType_, f, this),
      Depth_ (x.Depth_, f, this),
      Bottom_ (x.Bottom_, f, this),
      SingleOpenEnd_ (x.SingleOpenEnd_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      DraftAngle_ (x.DraftAngle_, f, this)
    {
    }

    OppositeAngledPlanesFeatureDefinitionType::
    OppositeAngledPlanesFeatureDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // EndType
        //
        if (n.name () == L"EndType" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndType_type > r (
            EndType_traits::create (i, f, this));

          if (!EndType_.present ())
          {
            this->EndType_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == L"Bottom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (::std::move (r));
            continue;
          }
        }

        // SingleOpenEnd
        //
        if (n.name () == L"SingleOpenEnd" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->SingleOpenEnd_)
          {
            this->SingleOpenEnd_.set (SingleOpenEnd_traits::create (i, f, this));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == L"EndRadius1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == L"EndRadius2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (::std::move (r));
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == L"TaperAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (::std::move (r));
            continue;
          }
        }

        // DraftAngle
        //
        if (n.name () == L"DraftAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DraftAngle_type > r (
            DraftAngle_traits::create (i, f, this));

          if (!this->DraftAngle_)
          {
            this->DraftAngle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Width",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!EndType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EndType",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledPlanesFeatureDefinitionType* OppositeAngledPlanesFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesFeatureDefinitionType (*this, f, c);
    }

    OppositeAngledPlanesFeatureDefinitionType& OppositeAngledPlanesFeatureDefinitionType::
    operator= (const OppositeAngledPlanesFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Width_ = x.Width_;
        this->Length_ = x.Length_;
        this->EndType_ = x.EndType_;
        this->Depth_ = x.Depth_;
        this->Bottom_ = x.Bottom_;
        this->SingleOpenEnd_ = x.SingleOpenEnd_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
        this->TaperAngle_ = x.TaperAngle_;
        this->DraftAngle_ = x.DraftAngle_;
      }

      return *this;
    }

    OppositeAngledPlanesFeatureDefinitionType::
    ~OppositeAngledPlanesFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeAngledPlanesFeatureDefinitionType >
    _xsd_OppositeAngledPlanesFeatureDefinitionType_type_factory_init (
      L"OppositeAngledPlanesFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledPlanesFeatureNominalType
    //

    OppositeAngledPlanesFeatureNominalType::
    OppositeAngledPlanesFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      DraftVector_ (this),
      Constructed_ (this)
    {
    }

    OppositeAngledPlanesFeatureNominalType::
    OppositeAngledPlanesFeatureNominalType (const id_type& id,
                                            const FeatureDefinitionId_type& FeatureDefinitionId,
                                            const CenterPlane_type& CenterPlane)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      CenterPlane_ (CenterPlane, this),
      LengthVector_ (this),
      DepthVector_ (this),
      DraftVector_ (this),
      Constructed_ (this)
    {
    }

    OppositeAngledPlanesFeatureNominalType::
    OppositeAngledPlanesFeatureNominalType (const id_type& id,
                                            ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                            ::std::unique_ptr< CenterPlane_type > CenterPlane)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      CenterPlane_ (std::move (CenterPlane), this),
      LengthVector_ (this),
      DepthVector_ (this),
      DraftVector_ (this),
      Constructed_ (this)
    {
    }

    OppositeAngledPlanesFeatureNominalType::
    OppositeAngledPlanesFeatureNominalType (const OppositeAngledPlanesFeatureNominalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      DraftVector_ (x.DraftVector_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeAngledPlanesFeatureNominalType::
    OppositeAngledPlanesFeatureNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      DraftVector_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterPlane
        //
        if (n.name () == L"CenterPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!CenterPlane_.present ())
          {
            this->CenterPlane_.set (::std::move (r));
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == L"LengthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (::std::move (r));
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == L"DepthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (::std::move (r));
            continue;
          }
        }

        // DraftVector
        //
        if (n.name () == L"DraftVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DraftVector_type > r (
            DraftVector_traits::create (i, f, this));

          if (!this->DraftVector_)
          {
            this->DraftVector_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CenterPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CenterPlane",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OppositeAngledPlanesFeatureNominalType* OppositeAngledPlanesFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesFeatureNominalType (*this, f, c);
    }

    OppositeAngledPlanesFeatureNominalType& OppositeAngledPlanesFeatureNominalType::
    operator= (const OppositeAngledPlanesFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->CenterPlane_ = x.CenterPlane_;
        this->LengthVector_ = x.LengthVector_;
        this->DepthVector_ = x.DepthVector_;
        this->DraftVector_ = x.DraftVector_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeAngledPlanesFeatureNominalType::
    ~OppositeAngledPlanesFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeAngledPlanesFeatureNominalType >
    _xsd_OppositeAngledPlanesFeatureNominalType_type_factory_init (
      L"OppositeAngledPlanesFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // OppositeAngledPlanesFeatureMeasurementType
    //

    OppositeAngledPlanesFeatureMeasurementType::
    OppositeAngledPlanesFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeAngledPlanesFeatureMeasurementType::
    OppositeAngledPlanesFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeAngledPlanesFeatureMeasurementType::
    OppositeAngledPlanesFeatureMeasurementType (const OppositeAngledPlanesFeatureMeasurementType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Width_ (x.Width_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      Length_ (x.Length_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      Depth_ (x.Depth_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      DraftAngle_ (x.DraftAngle_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    OppositeAngledPlanesFeatureMeasurementType::
    OppositeAngledPlanesFeatureMeasurementType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeAngledPlanesFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CenterPlane
        //
        if (n.name () == L"CenterPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!this->CenterPlane_)
          {
            this->CenterPlane_.set (::std::move (r));
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == L"LengthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (::std::move (r));
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == L"DepthVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (::std::move (r));
            continue;
          }
        }

        // Width
        //
        if (n.name () == L"Width" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (::std::move (r));
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == L"WidthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (::std::move (r));
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == L"WidthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == L"LengthMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (::std::move (r));
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == L"LengthMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (::std::move (r));
            continue;
          }
        }

        // Depth
        //
        if (n.name () == L"Depth" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (::std::move (r));
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == L"TaperAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (::std::move (r));
            continue;
          }
        }

        // DraftAngle
        //
        if (n.name () == L"DraftAngle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DraftAngle_type > r (
            DraftAngle_traits::create (i, f, this));

          if (!this->DraftAngle_)
          {
            this->DraftAngle_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == L"EndRadius1" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (::std::move (r));
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == L"EndRadius2" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OppositeAngledPlanesFeatureMeasurementType* OppositeAngledPlanesFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeAngledPlanesFeatureMeasurementType (*this, f, c);
    }

    OppositeAngledPlanesFeatureMeasurementType& OppositeAngledPlanesFeatureMeasurementType::
    operator= (const OppositeAngledPlanesFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->CenterPlane_ = x.CenterPlane_;
        this->LengthVector_ = x.LengthVector_;
        this->DepthVector_ = x.DepthVector_;
        this->Width_ = x.Width_;
        this->WidthMin_ = x.WidthMin_;
        this->WidthMax_ = x.WidthMax_;
        this->Length_ = x.Length_;
        this->LengthMin_ = x.LengthMin_;
        this->LengthMax_ = x.LengthMax_;
        this->Depth_ = x.Depth_;
        this->TaperAngle_ = x.TaperAngle_;
        this->DraftAngle_ = x.DraftAngle_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    OppositeAngledPlanesFeatureMeasurementType::
    ~OppositeAngledPlanesFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OppositeAngledPlanesFeatureMeasurementType >
    _xsd_OppositeAngledPlanesFeatureMeasurementType_type_factory_init (
      L"OppositeAngledPlanesFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherCurveConstructionMethodType
    //

    OtherCurveConstructionMethodType::
    OtherCurveConstructionMethodType ()
    : ::xml_schema::type (),
      Copy_ (this)
    {
    }

    OtherCurveConstructionMethodType::
    OtherCurveConstructionMethodType (const OtherCurveConstructionMethodType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Copy_ (x.Copy_, f, this)
    {
    }

    OtherCurveConstructionMethodType::
    OtherCurveConstructionMethodType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Copy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherCurveConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherCurveConstructionMethodType* OtherCurveConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveConstructionMethodType (*this, f, c);
    }

    OtherCurveConstructionMethodType& OtherCurveConstructionMethodType::
    operator= (const OtherCurveConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Copy_ = x.Copy_;
      }

      return *this;
    }

    OtherCurveConstructionMethodType::
    ~OtherCurveConstructionMethodType ()
    {
    }

    // OtherCurveFeatureCopyType
    //

    OtherCurveFeatureCopyType::
    OtherCurveFeatureCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherCurveFeature_ (this)
    {
    }

    OtherCurveFeatureCopyType::
    OtherCurveFeatureCopyType (const BaseOtherCurveFeature_type& BaseOtherCurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherCurveFeature_ (BaseOtherCurveFeature, this)
    {
    }

    OtherCurveFeatureCopyType::
    OtherCurveFeatureCopyType (::std::unique_ptr< BaseOtherCurveFeature_type > BaseOtherCurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherCurveFeature_ (std::move (BaseOtherCurveFeature), this)
    {
    }

    OtherCurveFeatureCopyType::
    OtherCurveFeatureCopyType (const OtherCurveFeatureCopyType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOtherCurveFeature_ (x.BaseOtherCurveFeature_, f, this)
    {
    }

    OtherCurveFeatureCopyType::
    OtherCurveFeatureCopyType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOtherCurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherCurveFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOtherCurveFeature
        //
        if (n.name () == L"BaseOtherCurveFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOtherCurveFeature_type > r (
            BaseOtherCurveFeature_traits::create (i, f, this));

          if (!BaseOtherCurveFeature_.present ())
          {
            this->BaseOtherCurveFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOtherCurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOtherCurveFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OtherCurveFeatureCopyType* OtherCurveFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveFeatureCopyType (*this, f, c);
    }

    OtherCurveFeatureCopyType& OtherCurveFeatureCopyType::
    operator= (const OtherCurveFeatureCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOtherCurveFeature_ = x.BaseOtherCurveFeature_;
      }

      return *this;
    }

    OtherCurveFeatureCopyType::
    ~OtherCurveFeatureCopyType ()
    {
    }

    // OtherCurveCheckedType
    //

    OtherCurveCheckedType::
    OtherCurveCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OtherCurveCheckedType::
    OtherCurveCheckedType (const OtherCurveCheckedType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OtherCurveCheckedType::
    OtherCurveCheckedType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherCurveCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherCurveCheckedType* OtherCurveCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveCheckedType (*this, f, c);
    }

    OtherCurveCheckedType& OtherCurveCheckedType::
    operator= (const OtherCurveCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OtherCurveCheckedType::
    ~OtherCurveCheckedType ()
    {
    }

    // OtherCurveCheckedFeatureType
    //

    OtherCurveCheckedFeatureType::
    OtherCurveCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OtherCurveCheckedFeatureType::
    OtherCurveCheckedFeatureType (const OtherCurveCheckedFeatureType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OtherCurveCheckedFeatureType::
    OtherCurveCheckedFeatureType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherCurveCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherCurveCheckedFeatureType* OtherCurveCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveCheckedFeatureType (*this, f, c);
    }

    OtherCurveCheckedFeatureType& OtherCurveCheckedFeatureType::
    operator= (const OtherCurveCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OtherCurveCheckedFeatureType::
    ~OtherCurveCheckedFeatureType ()
    {
    }

    // OtherCurveMeasurementDeterminationType
    //

    OtherCurveMeasurementDeterminationType::
    OtherCurveMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OtherCurveMeasurementDeterminationType::
    OtherCurveMeasurementDeterminationType (const OtherCurveMeasurementDeterminationType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OtherCurveMeasurementDeterminationType::
    OtherCurveMeasurementDeterminationType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherCurveMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherCurveMeasurementDeterminationType* OtherCurveMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveMeasurementDeterminationType (*this, f, c);
    }

    OtherCurveMeasurementDeterminationType& OtherCurveMeasurementDeterminationType::
    operator= (const OtherCurveMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OtherCurveMeasurementDeterminationType::
    ~OtherCurveMeasurementDeterminationType ()
    {
    }

    // OtherCurveFeatureItemType
    //

    OtherCurveFeatureItemType::
    OtherCurveFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    OtherCurveFeatureItemType::
    OtherCurveFeatureItemType (const id_type& id,
                               const FeatureNominalId_type& FeatureNominalId,
                               const FeatureName_type& FeatureName,
                               const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    OtherCurveFeatureItemType::
    OtherCurveFeatureItemType (const id_type& id,
                               ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                               const FeatureName_type& FeatureName,
                               ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    OtherCurveFeatureItemType::
    OtherCurveFeatureItemType (const OtherCurveFeatureItemType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    OtherCurveFeatureItemType::
    OtherCurveFeatureItemType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherCurveFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OtherCurveFeatureItemType* OtherCurveFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveFeatureItemType (*this, f, c);
    }

    OtherCurveFeatureItemType& OtherCurveFeatureItemType::
    operator= (const OtherCurveFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    OtherCurveFeatureItemType::
    ~OtherCurveFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherCurveFeatureItemType >
    _xsd_OtherCurveFeatureItemType_type_factory_init (
      L"OtherCurveFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherCurveFeatureDefinitionType
    //

    OtherCurveFeatureDefinitionType::
    OtherCurveFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType ()
    {
    }

    OtherCurveFeatureDefinitionType::
    OtherCurveFeatureDefinitionType (const id_type& id)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id)
    {
    }

    OtherCurveFeatureDefinitionType::
    OtherCurveFeatureDefinitionType (const OtherCurveFeatureDefinitionType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c)
    {
    }

    OtherCurveFeatureDefinitionType::
    OtherCurveFeatureDefinitionType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f, c)
    {
    }

    OtherCurveFeatureDefinitionType* OtherCurveFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveFeatureDefinitionType (*this, f, c);
    }

    OtherCurveFeatureDefinitionType::
    ~OtherCurveFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherCurveFeatureDefinitionType >
    _xsd_OtherCurveFeatureDefinitionType_type_factory_init (
      L"OtherCurveFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherCurveFeatureNominalType
    //

    OtherCurveFeatureNominalType::
    OtherCurveFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      Constructed_ (this)
    {
    }

    OtherCurveFeatureNominalType::
    OtherCurveFeatureNominalType (const id_type& id,
                                  const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Constructed_ (this)
    {
    }

    OtherCurveFeatureNominalType::
    OtherCurveFeatureNominalType (const id_type& id,
                                  ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Constructed_ (this)
    {
    }

    OtherCurveFeatureNominalType::
    OtherCurveFeatureNominalType (const OtherCurveFeatureNominalType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OtherCurveFeatureNominalType::
    OtherCurveFeatureNominalType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherCurveFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherCurveFeatureNominalType* OtherCurveFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveFeatureNominalType (*this, f, c);
    }

    OtherCurveFeatureNominalType& OtherCurveFeatureNominalType::
    operator= (const OtherCurveFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OtherCurveFeatureNominalType::
    ~OtherCurveFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherCurveFeatureNominalType >
    _xsd_OtherCurveFeatureNominalType_type_factory_init (
      L"OtherCurveFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherCurveFeatureMeasurementType
    //

    OtherCurveFeatureMeasurementType::
    OtherCurveFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType ()
    {
    }

    OtherCurveFeatureMeasurementType::
    OtherCurveFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id)
    {
    }

    OtherCurveFeatureMeasurementType::
    OtherCurveFeatureMeasurementType (const OtherCurveFeatureMeasurementType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c)
    {
    }

    OtherCurveFeatureMeasurementType::
    OtherCurveFeatureMeasurementType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f, c)
    {
    }

    OtherCurveFeatureMeasurementType* OtherCurveFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherCurveFeatureMeasurementType (*this, f, c);
    }

    OtherCurveFeatureMeasurementType::
    ~OtherCurveFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherCurveFeatureMeasurementType >
    _xsd_OtherCurveFeatureMeasurementType_type_factory_init (
      L"OtherCurveFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherNonShapeFeatureItemType
    //

    OtherNonShapeFeatureItemType::
    OtherNonShapeFeatureItemType ()
    : ::xsd::qif30::NonShapeFeatureItemBaseType ()
    {
    }

    OtherNonShapeFeatureItemType::
    OtherNonShapeFeatureItemType (const id_type& id,
                                  const FeatureNominalId_type& FeatureNominalId,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif30::NonShapeFeatureItemBaseType (id,
                                                 FeatureNominalId,
                                                 FeatureName)
    {
    }

    OtherNonShapeFeatureItemType::
    OtherNonShapeFeatureItemType (const id_type& id,
                                  ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif30::NonShapeFeatureItemBaseType (id,
                                                 std::move (FeatureNominalId),
                                                 FeatureName)
    {
    }

    OtherNonShapeFeatureItemType::
    OtherNonShapeFeatureItemType (const OtherNonShapeFeatureItemType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureItemBaseType (x, f, c)
    {
    }

    OtherNonShapeFeatureItemType::
    OtherNonShapeFeatureItemType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureItemBaseType (e, f, c)
    {
    }

    OtherNonShapeFeatureItemType* OtherNonShapeFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherNonShapeFeatureItemType (*this, f, c);
    }

    OtherNonShapeFeatureItemType::
    ~OtherNonShapeFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherNonShapeFeatureItemType >
    _xsd_OtherNonShapeFeatureItemType_type_factory_init (
      L"OtherNonShapeFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherNonShapeFeatureDefinitionType
    //

    OtherNonShapeFeatureDefinitionType::
    OtherNonShapeFeatureDefinitionType ()
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (),
      Description_ (this)
    {
    }

    OtherNonShapeFeatureDefinitionType::
    OtherNonShapeFeatureDefinitionType (const id_type& id,
                                        const Description_type& Description)
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (id),
      Description_ (Description, this)
    {
    }

    OtherNonShapeFeatureDefinitionType::
    OtherNonShapeFeatureDefinitionType (const OtherNonShapeFeatureDefinitionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (x, f, c),
      Description_ (x.Description_, f, this)
    {
    }

    OtherNonShapeFeatureDefinitionType::
    OtherNonShapeFeatureDefinitionType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherNonShapeFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NonShapeFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Description",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OtherNonShapeFeatureDefinitionType* OtherNonShapeFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherNonShapeFeatureDefinitionType (*this, f, c);
    }

    OtherNonShapeFeatureDefinitionType& OtherNonShapeFeatureDefinitionType::
    operator= (const OtherNonShapeFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NonShapeFeatureDefinitionBaseType& > (*this) = x;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    OtherNonShapeFeatureDefinitionType::
    ~OtherNonShapeFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherNonShapeFeatureDefinitionType >
    _xsd_OtherNonShapeFeatureDefinitionType_type_factory_init (
      L"OtherNonShapeFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherNonShapeFeatureNominalType
    //

    OtherNonShapeFeatureNominalType::
    OtherNonShapeFeatureNominalType ()
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (),
      ReferenceFeatureNominalIds_ (this)
    {
    }

    OtherNonShapeFeatureNominalType::
    OtherNonShapeFeatureNominalType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId),
      ReferenceFeatureNominalIds_ (this)
    {
    }

    OtherNonShapeFeatureNominalType::
    OtherNonShapeFeatureNominalType (const id_type& id,
                                     ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (id,
                                                    std::move (FeatureDefinitionId)),
      ReferenceFeatureNominalIds_ (this)
    {
    }

    OtherNonShapeFeatureNominalType::
    OtherNonShapeFeatureNominalType (const OtherNonShapeFeatureNominalType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (x, f, c),
      ReferenceFeatureNominalIds_ (x.ReferenceFeatureNominalIds_, f, this)
    {
    }

    OtherNonShapeFeatureNominalType::
    OtherNonShapeFeatureNominalType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      ReferenceFeatureNominalIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherNonShapeFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NonShapeFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ReferenceFeatureNominalIds
        //
        if (n.name () == L"ReferenceFeatureNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferenceFeatureNominalIds_type > r (
            ReferenceFeatureNominalIds_traits::create (i, f, this));

          if (!this->ReferenceFeatureNominalIds_)
          {
            this->ReferenceFeatureNominalIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherNonShapeFeatureNominalType* OtherNonShapeFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherNonShapeFeatureNominalType (*this, f, c);
    }

    OtherNonShapeFeatureNominalType& OtherNonShapeFeatureNominalType::
    operator= (const OtherNonShapeFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NonShapeFeatureNominalBaseType& > (*this) = x;
        this->ReferenceFeatureNominalIds_ = x.ReferenceFeatureNominalIds_;
      }

      return *this;
    }

    OtherNonShapeFeatureNominalType::
    ~OtherNonShapeFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherNonShapeFeatureNominalType >
    _xsd_OtherNonShapeFeatureNominalType_type_factory_init (
      L"OtherNonShapeFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherNonShapeFeatureMeasurementType
    //

    OtherNonShapeFeatureMeasurementType::
    OtherNonShapeFeatureMeasurementType ()
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType ()
    {
    }

    OtherNonShapeFeatureMeasurementType::
    OtherNonShapeFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType (id)
    {
    }

    OtherNonShapeFeatureMeasurementType::
    OtherNonShapeFeatureMeasurementType (const OtherNonShapeFeatureMeasurementType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType (x, f, c)
    {
    }

    OtherNonShapeFeatureMeasurementType::
    OtherNonShapeFeatureMeasurementType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType (e, f, c)
    {
    }

    OtherNonShapeFeatureMeasurementType* OtherNonShapeFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherNonShapeFeatureMeasurementType (*this, f, c);
    }

    OtherNonShapeFeatureMeasurementType::
    ~OtherNonShapeFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherNonShapeFeatureMeasurementType >
    _xsd_OtherNonShapeFeatureMeasurementType_type_factory_init (
      L"OtherNonShapeFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // MarkingMethodEnumType
    //

    MarkingMethodEnumType::
    MarkingMethodEnumType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_MarkingMethodEnumType_convert ();
    }

    MarkingMethodEnumType::
    MarkingMethodEnumType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_MarkingMethodEnumType_convert ();
    }

    MarkingMethodEnumType::
    MarkingMethodEnumType (const ::std::wstring& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_MarkingMethodEnumType_convert ();
    }

    MarkingMethodEnumType* MarkingMethodEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MarkingMethodEnumType (*this, f, c);
    }

    MarkingMethodEnumType::value MarkingMethodEnumType::
    _xsd_MarkingMethodEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_MarkingMethodEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MarkingMethodEnumType_indexes_,
                        _xsd_MarkingMethodEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_MarkingMethodEnumType_indexes_ + 4 || _xsd_MarkingMethodEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const MarkingMethodEnumType::
    _xsd_MarkingMethodEnumType_literals_[4] =
    {
      L"PAINT",
      L"STAIN",
      L"ENSCRIBE",
      L"EMBOSS"
    };

    const MarkingMethodEnumType::value MarkingMethodEnumType::
    _xsd_MarkingMethodEnumType_indexes_[4] =
    {
      ::xsd::qif30::MarkingMethodEnumType::EMBOSS,
      ::xsd::qif30::MarkingMethodEnumType::ENSCRIBE,
      ::xsd::qif30::MarkingMethodEnumType::PAINT,
      ::xsd::qif30::MarkingMethodEnumType::STAIN
    };

    // MarkingMethodType
    //

    MarkingMethodType::
    MarkingMethodType ()
    : ::xml_schema::type (),
      MarkingMethodEnum_ (this),
      OtherMarkingMethod_ (this)
    {
    }

    MarkingMethodType::
    MarkingMethodType (const MarkingMethodType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MarkingMethodEnum_ (x.MarkingMethodEnum_, f, this),
      OtherMarkingMethod_ (x.OtherMarkingMethod_, f, this)
    {
    }

    MarkingMethodType::
    MarkingMethodType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MarkingMethodEnum_ (this),
      OtherMarkingMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MarkingMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // MarkingMethodEnum
        //
        if (n.name () == L"MarkingMethodEnum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MarkingMethodEnum_type > r (
            MarkingMethodEnum_traits::create (i, f, this));

          if (!this->MarkingMethodEnum_)
          {
            this->MarkingMethodEnum_.set (::std::move (r));
            continue;
          }
        }

        // OtherMarkingMethod
        //
        if (n.name () == L"OtherMarkingMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherMarkingMethod_type > r (
            OtherMarkingMethod_traits::create (i, f, this));

          if (!this->OtherMarkingMethod_)
          {
            this->OtherMarkingMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    MarkingMethodType* MarkingMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MarkingMethodType (*this, f, c);
    }

    MarkingMethodType& MarkingMethodType::
    operator= (const MarkingMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MarkingMethodEnum_ = x.MarkingMethodEnum_;
        this->OtherMarkingMethod_ = x.OtherMarkingMethod_;
      }

      return *this;
    }

    MarkingMethodType::
    ~MarkingMethodType ()
    {
    }

    // MarkingFeatureItemType
    //

    MarkingFeatureItemType::
    MarkingFeatureItemType ()
    : ::xsd::qif30::NonShapeFeatureItemBaseType ()
    {
    }

    MarkingFeatureItemType::
    MarkingFeatureItemType (const id_type& id,
                            const FeatureNominalId_type& FeatureNominalId,
                            const FeatureName_type& FeatureName)
    : ::xsd::qif30::NonShapeFeatureItemBaseType (id,
                                                 FeatureNominalId,
                                                 FeatureName)
    {
    }

    MarkingFeatureItemType::
    MarkingFeatureItemType (const id_type& id,
                            ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                            const FeatureName_type& FeatureName)
    : ::xsd::qif30::NonShapeFeatureItemBaseType (id,
                                                 std::move (FeatureNominalId),
                                                 FeatureName)
    {
    }

    MarkingFeatureItemType::
    MarkingFeatureItemType (const MarkingFeatureItemType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureItemBaseType (x, f, c)
    {
    }

    MarkingFeatureItemType::
    MarkingFeatureItemType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureItemBaseType (e, f, c)
    {
    }

    MarkingFeatureItemType* MarkingFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MarkingFeatureItemType (*this, f, c);
    }

    MarkingFeatureItemType::
    ~MarkingFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MarkingFeatureItemType >
    _xsd_MarkingFeatureItemType_type_factory_init (
      L"MarkingFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // MarkingFeatureDefinitionType
    //

    MarkingFeatureDefinitionType::
    MarkingFeatureDefinitionType ()
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (),
      Text_ (this),
      MarkingMethod_ (this)
    {
    }

    MarkingFeatureDefinitionType::
    MarkingFeatureDefinitionType (const id_type& id,
                                  const Text_type& Text,
                                  const MarkingMethod_type& MarkingMethod)
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (id),
      Text_ (Text, this),
      MarkingMethod_ (MarkingMethod, this)
    {
    }

    MarkingFeatureDefinitionType::
    MarkingFeatureDefinitionType (const id_type& id,
                                  const Text_type& Text,
                                  ::std::unique_ptr< MarkingMethod_type > MarkingMethod)
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (id),
      Text_ (Text, this),
      MarkingMethod_ (std::move (MarkingMethod), this)
    {
    }

    MarkingFeatureDefinitionType::
    MarkingFeatureDefinitionType (const MarkingFeatureDefinitionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (x, f, c),
      Text_ (x.Text_, f, this),
      MarkingMethod_ (x.MarkingMethod_, f, this)
    {
    }

    MarkingFeatureDefinitionType::
    MarkingFeatureDefinitionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Text_ (this),
      MarkingMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MarkingFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NonShapeFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Text
        //
        if (n.name () == L"Text" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          if (!Text_.present ())
          {
            this->Text_.set (::std::move (r));
            continue;
          }
        }

        // MarkingMethod
        //
        if (n.name () == L"MarkingMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MarkingMethod_type > r (
            MarkingMethod_traits::create (i, f, this));

          if (!MarkingMethod_.present ())
          {
            this->MarkingMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Text_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Text",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MarkingMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MarkingMethod",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MarkingFeatureDefinitionType* MarkingFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MarkingFeatureDefinitionType (*this, f, c);
    }

    MarkingFeatureDefinitionType& MarkingFeatureDefinitionType::
    operator= (const MarkingFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NonShapeFeatureDefinitionBaseType& > (*this) = x;
        this->Text_ = x.Text_;
        this->MarkingMethod_ = x.MarkingMethod_;
      }

      return *this;
    }

    MarkingFeatureDefinitionType::
    ~MarkingFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MarkingFeatureDefinitionType >
    _xsd_MarkingFeatureDefinitionType_type_factory_init (
      L"MarkingFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // MarkingFeatureNominalType
    //

    MarkingFeatureNominalType::
    MarkingFeatureNominalType ()
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (),
      Location_ (this)
    {
    }

    MarkingFeatureNominalType::
    MarkingFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               const Location_type& Location)
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId),
      Location_ (Location, this)
    {
    }

    MarkingFeatureNominalType::
    MarkingFeatureNominalType (const id_type& id,
                               ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                               ::std::unique_ptr< Location_type > Location)
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (id,
                                                    std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this)
    {
    }

    MarkingFeatureNominalType::
    MarkingFeatureNominalType (const MarkingFeatureNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this)
    {
    }

    MarkingFeatureNominalType::
    MarkingFeatureNominalType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MarkingFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NonShapeFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MarkingFeatureNominalType* MarkingFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MarkingFeatureNominalType (*this, f, c);
    }

    MarkingFeatureNominalType& MarkingFeatureNominalType::
    operator= (const MarkingFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NonShapeFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
      }

      return *this;
    }

    MarkingFeatureNominalType::
    ~MarkingFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MarkingFeatureNominalType >
    _xsd_MarkingFeatureNominalType_type_factory_init (
      L"MarkingFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // MarkingFeatureMeasurementType
    //

    MarkingFeatureMeasurementType::
    MarkingFeatureMeasurementType ()
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType (),
      Text_ (this),
      Location_ (this)
    {
    }

    MarkingFeatureMeasurementType::
    MarkingFeatureMeasurementType (const id_type& id,
                                   const Text_type& Text,
                                   const Location_type& Location)
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType (id),
      Text_ (Text, this),
      Location_ (Location, this)
    {
    }

    MarkingFeatureMeasurementType::
    MarkingFeatureMeasurementType (const id_type& id,
                                   const Text_type& Text,
                                   ::std::unique_ptr< Location_type > Location)
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType (id),
      Text_ (Text, this),
      Location_ (std::move (Location), this)
    {
    }

    MarkingFeatureMeasurementType::
    MarkingFeatureMeasurementType (const MarkingFeatureMeasurementType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType (x, f, c),
      Text_ (x.Text_, f, this),
      Location_ (x.Location_, f, this)
    {
    }

    MarkingFeatureMeasurementType::
    MarkingFeatureMeasurementType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::NonShapeFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Text_ (this),
      Location_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MarkingFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::NonShapeFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Text
        //
        if (n.name () == L"Text" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          if (!Text_.present ())
          {
            this->Text_.set (::std::move (r));
            continue;
          }
        }

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Text_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Text",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MarkingFeatureMeasurementType* MarkingFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MarkingFeatureMeasurementType (*this, f, c);
    }

    MarkingFeatureMeasurementType& MarkingFeatureMeasurementType::
    operator= (const MarkingFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::NonShapeFeatureMeasurementBaseType& > (*this) = x;
        this->Text_ = x.Text_;
        this->Location_ = x.Location_;
      }

      return *this;
    }

    MarkingFeatureMeasurementType::
    ~MarkingFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, MarkingFeatureMeasurementType >
    _xsd_MarkingFeatureMeasurementType_type_factory_init (
      L"MarkingFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherShapeConstructionMethodType
    //

    OtherShapeConstructionMethodType::
    OtherShapeConstructionMethodType ()
    : ::xml_schema::type (),
      Copy_ (this)
    {
    }

    OtherShapeConstructionMethodType::
    OtherShapeConstructionMethodType (const OtherShapeConstructionMethodType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Copy_ (x.Copy_, f, this)
    {
    }

    OtherShapeConstructionMethodType::
    OtherShapeConstructionMethodType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Copy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherShapeConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherShapeConstructionMethodType* OtherShapeConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeConstructionMethodType (*this, f, c);
    }

    OtherShapeConstructionMethodType& OtherShapeConstructionMethodType::
    operator= (const OtherShapeConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Copy_ = x.Copy_;
      }

      return *this;
    }

    OtherShapeConstructionMethodType::
    ~OtherShapeConstructionMethodType ()
    {
    }

    // OtherShapeFeatureCopyType
    //

    OtherShapeFeatureCopyType::
    OtherShapeFeatureCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherShapeFeature_ (this)
    {
    }

    OtherShapeFeatureCopyType::
    OtherShapeFeatureCopyType (const BaseOtherShapeFeature_type& BaseOtherShapeFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherShapeFeature_ (BaseOtherShapeFeature, this)
    {
    }

    OtherShapeFeatureCopyType::
    OtherShapeFeatureCopyType (::std::unique_ptr< BaseOtherShapeFeature_type > BaseOtherShapeFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherShapeFeature_ (std::move (BaseOtherShapeFeature), this)
    {
    }

    OtherShapeFeatureCopyType::
    OtherShapeFeatureCopyType (const OtherShapeFeatureCopyType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOtherShapeFeature_ (x.BaseOtherShapeFeature_, f, this)
    {
    }

    OtherShapeFeatureCopyType::
    OtherShapeFeatureCopyType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOtherShapeFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherShapeFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOtherShapeFeature
        //
        if (n.name () == L"BaseOtherShapeFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOtherShapeFeature_type > r (
            BaseOtherShapeFeature_traits::create (i, f, this));

          if (!BaseOtherShapeFeature_.present ())
          {
            this->BaseOtherShapeFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOtherShapeFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOtherShapeFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OtherShapeFeatureCopyType* OtherShapeFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeFeatureCopyType (*this, f, c);
    }

    OtherShapeFeatureCopyType& OtherShapeFeatureCopyType::
    operator= (const OtherShapeFeatureCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOtherShapeFeature_ = x.BaseOtherShapeFeature_;
      }

      return *this;
    }

    OtherShapeFeatureCopyType::
    ~OtherShapeFeatureCopyType ()
    {
    }

    // OtherShapeCheckedType
    //

    OtherShapeCheckedType::
    OtherShapeCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OtherShapeCheckedType::
    OtherShapeCheckedType (const OtherShapeCheckedType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OtherShapeCheckedType::
    OtherShapeCheckedType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherShapeCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherShapeCheckedType* OtherShapeCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeCheckedType (*this, f, c);
    }

    OtherShapeCheckedType& OtherShapeCheckedType::
    operator= (const OtherShapeCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OtherShapeCheckedType::
    ~OtherShapeCheckedType ()
    {
    }

    // OtherShapeCheckedFeatureType
    //

    OtherShapeCheckedFeatureType::
    OtherShapeCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OtherShapeCheckedFeatureType::
    OtherShapeCheckedFeatureType (const OtherShapeCheckedFeatureType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OtherShapeCheckedFeatureType::
    OtherShapeCheckedFeatureType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherShapeCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherShapeCheckedFeatureType* OtherShapeCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeCheckedFeatureType (*this, f, c);
    }

    OtherShapeCheckedFeatureType& OtherShapeCheckedFeatureType::
    operator= (const OtherShapeCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OtherShapeCheckedFeatureType::
    ~OtherShapeCheckedFeatureType ()
    {
    }

    // OtherShapeMeasurementDeterminationType
    //

    OtherShapeMeasurementDeterminationType::
    OtherShapeMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OtherShapeMeasurementDeterminationType::
    OtherShapeMeasurementDeterminationType (const OtherShapeMeasurementDeterminationType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OtherShapeMeasurementDeterminationType::
    OtherShapeMeasurementDeterminationType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherShapeMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherShapeMeasurementDeterminationType* OtherShapeMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeMeasurementDeterminationType (*this, f, c);
    }

    OtherShapeMeasurementDeterminationType& OtherShapeMeasurementDeterminationType::
    operator= (const OtherShapeMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OtherShapeMeasurementDeterminationType::
    ~OtherShapeMeasurementDeterminationType ()
    {
    }

    // OtherShapeFeatureItemType
    //

    OtherShapeFeatureItemType::
    OtherShapeFeatureItemType ()
    : ::xsd::qif30::ShapeFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    OtherShapeFeatureItemType::
    OtherShapeFeatureItemType (const id_type& id,
                               const FeatureNominalId_type& FeatureNominalId,
                               const FeatureName_type& FeatureName,
                               const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    OtherShapeFeatureItemType::
    OtherShapeFeatureItemType (const id_type& id,
                               ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                               const FeatureName_type& FeatureName,
                               ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    OtherShapeFeatureItemType::
    OtherShapeFeatureItemType (const OtherShapeFeatureItemType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    OtherShapeFeatureItemType::
    OtherShapeFeatureItemType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherShapeFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ShapeFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OtherShapeFeatureItemType* OtherShapeFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeFeatureItemType (*this, f, c);
    }

    OtherShapeFeatureItemType& OtherShapeFeatureItemType::
    operator= (const OtherShapeFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ShapeFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    OtherShapeFeatureItemType::
    ~OtherShapeFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherShapeFeatureItemType >
    _xsd_OtherShapeFeatureItemType_type_factory_init (
      L"OtherShapeFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherShapeFeatureDefinitionType
    //

    OtherShapeFeatureDefinitionType::
    OtherShapeFeatureDefinitionType ()
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (),
      Description_ (this)
    {
    }

    OtherShapeFeatureDefinitionType::
    OtherShapeFeatureDefinitionType (const id_type& id,
                                     const Description_type& Description)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (id),
      Description_ (Description, this)
    {
    }

    OtherShapeFeatureDefinitionType::
    OtherShapeFeatureDefinitionType (const OtherShapeFeatureDefinitionType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (x, f, c),
      Description_ (x.Description_, f, this)
    {
    }

    OtherShapeFeatureDefinitionType::
    OtherShapeFeatureDefinitionType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherShapeFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ShapeFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Description
        //
        if (n.name () == L"Description" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Description",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OtherShapeFeatureDefinitionType* OtherShapeFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeFeatureDefinitionType (*this, f, c);
    }

    OtherShapeFeatureDefinitionType& OtherShapeFeatureDefinitionType::
    operator= (const OtherShapeFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ShapeFeatureDefinitionBaseType& > (*this) = x;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    OtherShapeFeatureDefinitionType::
    ~OtherShapeFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherShapeFeatureDefinitionType >
    _xsd_OtherShapeFeatureDefinitionType_type_factory_init (
      L"OtherShapeFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherShapeFeatureNominalType
    //

    OtherShapeFeatureNominalType::
    OtherShapeFeatureNominalType ()
    : ::xsd::qif30::ShapeFeatureNominalBaseType (),
      Constructed_ (this)
    {
    }

    OtherShapeFeatureNominalType::
    OtherShapeFeatureNominalType (const id_type& id,
                                  const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Constructed_ (this)
    {
    }

    OtherShapeFeatureNominalType::
    OtherShapeFeatureNominalType (const id_type& id,
                                  ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Constructed_ (this)
    {
    }

    OtherShapeFeatureNominalType::
    OtherShapeFeatureNominalType (const OtherShapeFeatureNominalType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (x, f, c),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OtherShapeFeatureNominalType::
    OtherShapeFeatureNominalType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherShapeFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ShapeFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherShapeFeatureNominalType* OtherShapeFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeFeatureNominalType (*this, f, c);
    }

    OtherShapeFeatureNominalType& OtherShapeFeatureNominalType::
    operator= (const OtherShapeFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ShapeFeatureNominalBaseType& > (*this) = x;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OtherShapeFeatureNominalType::
    ~OtherShapeFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherShapeFeatureNominalType >
    _xsd_OtherShapeFeatureNominalType_type_factory_init (
      L"OtherShapeFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherShapeFeatureMeasurementType
    //

    OtherShapeFeatureMeasurementType::
    OtherShapeFeatureMeasurementType ()
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType ()
    {
    }

    OtherShapeFeatureMeasurementType::
    OtherShapeFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (id)
    {
    }

    OtherShapeFeatureMeasurementType::
    OtherShapeFeatureMeasurementType (const OtherShapeFeatureMeasurementType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (x, f, c)
    {
    }

    OtherShapeFeatureMeasurementType::
    OtherShapeFeatureMeasurementType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (e, f, c)
    {
    }

    OtherShapeFeatureMeasurementType* OtherShapeFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherShapeFeatureMeasurementType (*this, f, c);
    }

    OtherShapeFeatureMeasurementType::
    ~OtherShapeFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherShapeFeatureMeasurementType >
    _xsd_OtherShapeFeatureMeasurementType_type_factory_init (
      L"OtherShapeFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherSurfaceConstructionMethodType
    //

    OtherSurfaceConstructionMethodType::
    OtherSurfaceConstructionMethodType ()
    : ::xml_schema::type (),
      Copy_ (this)
    {
    }

    OtherSurfaceConstructionMethodType::
    OtherSurfaceConstructionMethodType (const OtherSurfaceConstructionMethodType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Copy_ (x.Copy_, f, this)
    {
    }

    OtherSurfaceConstructionMethodType::
    OtherSurfaceConstructionMethodType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Copy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherSurfaceConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherSurfaceConstructionMethodType* OtherSurfaceConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceConstructionMethodType (*this, f, c);
    }

    OtherSurfaceConstructionMethodType& OtherSurfaceConstructionMethodType::
    operator= (const OtherSurfaceConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Copy_ = x.Copy_;
      }

      return *this;
    }

    OtherSurfaceConstructionMethodType::
    ~OtherSurfaceConstructionMethodType ()
    {
    }

    // OtherSurfaceFeatureCopyType
    //

    OtherSurfaceFeatureCopyType::
    OtherSurfaceFeatureCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherSurfaceFeature_ (this)
    {
    }

    OtherSurfaceFeatureCopyType::
    OtherSurfaceFeatureCopyType (const BaseOtherSurfaceFeature_type& BaseOtherSurfaceFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherSurfaceFeature_ (BaseOtherSurfaceFeature, this)
    {
    }

    OtherSurfaceFeatureCopyType::
    OtherSurfaceFeatureCopyType (::std::unique_ptr< BaseOtherSurfaceFeature_type > BaseOtherSurfaceFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseOtherSurfaceFeature_ (std::move (BaseOtherSurfaceFeature), this)
    {
    }

    OtherSurfaceFeatureCopyType::
    OtherSurfaceFeatureCopyType (const OtherSurfaceFeatureCopyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseOtherSurfaceFeature_ (x.BaseOtherSurfaceFeature_, f, this)
    {
    }

    OtherSurfaceFeatureCopyType::
    OtherSurfaceFeatureCopyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOtherSurfaceFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherSurfaceFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseOtherSurfaceFeature
        //
        if (n.name () == L"BaseOtherSurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseOtherSurfaceFeature_type > r (
            BaseOtherSurfaceFeature_traits::create (i, f, this));

          if (!BaseOtherSurfaceFeature_.present ())
          {
            this->BaseOtherSurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseOtherSurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseOtherSurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OtherSurfaceFeatureCopyType* OtherSurfaceFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceFeatureCopyType (*this, f, c);
    }

    OtherSurfaceFeatureCopyType& OtherSurfaceFeatureCopyType::
    operator= (const OtherSurfaceFeatureCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOtherSurfaceFeature_ = x.BaseOtherSurfaceFeature_;
      }

      return *this;
    }

    OtherSurfaceFeatureCopyType::
    ~OtherSurfaceFeatureCopyType ()
    {
    }

    // OtherSurfaceCheckedType
    //

    OtherSurfaceCheckedType::
    OtherSurfaceCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OtherSurfaceCheckedType::
    OtherSurfaceCheckedType (const OtherSurfaceCheckedType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OtherSurfaceCheckedType::
    OtherSurfaceCheckedType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherSurfaceCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherSurfaceCheckedType* OtherSurfaceCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceCheckedType (*this, f, c);
    }

    OtherSurfaceCheckedType& OtherSurfaceCheckedType::
    operator= (const OtherSurfaceCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OtherSurfaceCheckedType::
    ~OtherSurfaceCheckedType ()
    {
    }

    // OtherSurfaceCheckedFeatureType
    //

    OtherSurfaceCheckedFeatureType::
    OtherSurfaceCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OtherSurfaceCheckedFeatureType::
    OtherSurfaceCheckedFeatureType (const OtherSurfaceCheckedFeatureType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OtherSurfaceCheckedFeatureType::
    OtherSurfaceCheckedFeatureType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherSurfaceCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherSurfaceCheckedFeatureType* OtherSurfaceCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceCheckedFeatureType (*this, f, c);
    }

    OtherSurfaceCheckedFeatureType& OtherSurfaceCheckedFeatureType::
    operator= (const OtherSurfaceCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OtherSurfaceCheckedFeatureType::
    ~OtherSurfaceCheckedFeatureType ()
    {
    }

    // OtherSurfaceMeasurementDeterminationType
    //

    OtherSurfaceMeasurementDeterminationType::
    OtherSurfaceMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OtherSurfaceMeasurementDeterminationType::
    OtherSurfaceMeasurementDeterminationType (const OtherSurfaceMeasurementDeterminationType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OtherSurfaceMeasurementDeterminationType::
    OtherSurfaceMeasurementDeterminationType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OtherSurfaceMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherSurfaceMeasurementDeterminationType* OtherSurfaceMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceMeasurementDeterminationType (*this, f, c);
    }

    OtherSurfaceMeasurementDeterminationType& OtherSurfaceMeasurementDeterminationType::
    operator= (const OtherSurfaceMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OtherSurfaceMeasurementDeterminationType::
    ~OtherSurfaceMeasurementDeterminationType ()
    {
    }

    // OtherSurfaceFeatureItemType
    //

    OtherSurfaceFeatureItemType::
    OtherSurfaceFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    OtherSurfaceFeatureItemType::
    OtherSurfaceFeatureItemType (const id_type& id,
                                 const FeatureNominalId_type& FeatureNominalId,
                                 const FeatureName_type& FeatureName,
                                 const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    OtherSurfaceFeatureItemType::
    OtherSurfaceFeatureItemType (const id_type& id,
                                 ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                 const FeatureName_type& FeatureName,
                                 ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    OtherSurfaceFeatureItemType::
    OtherSurfaceFeatureItemType (const OtherSurfaceFeatureItemType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    OtherSurfaceFeatureItemType::
    OtherSurfaceFeatureItemType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherSurfaceFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    OtherSurfaceFeatureItemType* OtherSurfaceFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceFeatureItemType (*this, f, c);
    }

    OtherSurfaceFeatureItemType& OtherSurfaceFeatureItemType::
    operator= (const OtherSurfaceFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    OtherSurfaceFeatureItemType::
    ~OtherSurfaceFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherSurfaceFeatureItemType >
    _xsd_OtherSurfaceFeatureItemType_type_factory_init (
      L"OtherSurfaceFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherSurfaceFeatureDefinitionType
    //

    OtherSurfaceFeatureDefinitionType::
    OtherSurfaceFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType ()
    {
    }

    OtherSurfaceFeatureDefinitionType::
    OtherSurfaceFeatureDefinitionType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id)
    {
    }

    OtherSurfaceFeatureDefinitionType::
    OtherSurfaceFeatureDefinitionType (const OtherSurfaceFeatureDefinitionType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c)
    {
    }

    OtherSurfaceFeatureDefinitionType::
    OtherSurfaceFeatureDefinitionType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f, c)
    {
    }

    OtherSurfaceFeatureDefinitionType* OtherSurfaceFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceFeatureDefinitionType (*this, f, c);
    }

    OtherSurfaceFeatureDefinitionType::
    ~OtherSurfaceFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherSurfaceFeatureDefinitionType >
    _xsd_OtherSurfaceFeatureDefinitionType_type_factory_init (
      L"OtherSurfaceFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherSurfaceFeatureNominalType
    //

    OtherSurfaceFeatureNominalType::
    OtherSurfaceFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      PolyLine_ (this),
      ClosedSurface_ (this),
      Constructed_ (this)
    {
    }

    OtherSurfaceFeatureNominalType::
    OtherSurfaceFeatureNominalType (const id_type& id,
                                    const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      PolyLine_ (this),
      ClosedSurface_ (this),
      Constructed_ (this)
    {
    }

    OtherSurfaceFeatureNominalType::
    OtherSurfaceFeatureNominalType (const id_type& id,
                                    ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      PolyLine_ (this),
      ClosedSurface_ (this),
      Constructed_ (this)
    {
    }

    OtherSurfaceFeatureNominalType::
    OtherSurfaceFeatureNominalType (const OtherSurfaceFeatureNominalType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      PolyLine_ (x.PolyLine_, f, this),
      ClosedSurface_ (x.ClosedSurface_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OtherSurfaceFeatureNominalType::
    OtherSurfaceFeatureNominalType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      PolyLine_ (this),
      ClosedSurface_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherSurfaceFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PolyLine
        //
        if (n.name () == L"PolyLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PolyLine_type > r (
            PolyLine_traits::create (i, f, this));

          if (!this->PolyLine_)
          {
            this->PolyLine_.set (::std::move (r));
            continue;
          }
        }

        // ClosedSurface
        //
        if (n.name () == L"ClosedSurface" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ClosedSurface_type > r (
            ClosedSurface_traits::create (i, f, this));

          if (!this->ClosedSurface_)
          {
            this->ClosedSurface_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherSurfaceFeatureNominalType* OtherSurfaceFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceFeatureNominalType (*this, f, c);
    }

    OtherSurfaceFeatureNominalType& OtherSurfaceFeatureNominalType::
    operator= (const OtherSurfaceFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->PolyLine_ = x.PolyLine_;
        this->ClosedSurface_ = x.ClosedSurface_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OtherSurfaceFeatureNominalType::
    ~OtherSurfaceFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherSurfaceFeatureNominalType >
    _xsd_OtherSurfaceFeatureNominalType_type_factory_init (
      L"OtherSurfaceFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // OtherSurfaceFeatureMeasurementType
    //

    OtherSurfaceFeatureMeasurementType::
    OtherSurfaceFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      PolyLine_ (this)
    {
    }

    OtherSurfaceFeatureMeasurementType::
    OtherSurfaceFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      PolyLine_ (this)
    {
    }

    OtherSurfaceFeatureMeasurementType::
    OtherSurfaceFeatureMeasurementType (const OtherSurfaceFeatureMeasurementType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      PolyLine_ (x.PolyLine_, f, this)
    {
    }

    OtherSurfaceFeatureMeasurementType::
    OtherSurfaceFeatureMeasurementType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      PolyLine_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherSurfaceFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PolyLine
        //
        if (n.name () == L"PolyLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PolyLine_type > r (
            PolyLine_traits::create (i, f, this));

          if (!this->PolyLine_)
          {
            this->PolyLine_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    OtherSurfaceFeatureMeasurementType* OtherSurfaceFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherSurfaceFeatureMeasurementType (*this, f, c);
    }

    OtherSurfaceFeatureMeasurementType& OtherSurfaceFeatureMeasurementType::
    operator= (const OtherSurfaceFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->PolyLine_ = x.PolyLine_;
      }

      return *this;
    }

    OtherSurfaceFeatureMeasurementType::
    ~OtherSurfaceFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OtherSurfaceFeatureMeasurementType >
    _xsd_OtherSurfaceFeatureMeasurementType_type_factory_init (
      L"OtherSurfaceFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // PlaneConstructionMethodType
    //

    PlaneConstructionMethodType::
    PlaneConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Midplane_ (this),
      Offset_ (this),
      Perpendicular_ (this),
      Parallel_ (this),
      Copy_ (this),
      Cast_ (this),
      TangentThrough_ (this),
      Through_ (this),
      Transform_ (this),
      Extract_ (this)
    {
    }

    PlaneConstructionMethodType::
    PlaneConstructionMethodType (const PlaneConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Midplane_ (x.Midplane_, f, this),
      Offset_ (x.Offset_, f, this),
      Perpendicular_ (x.Perpendicular_, f, this),
      Parallel_ (x.Parallel_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Through_ (x.Through_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PlaneConstructionMethodType::
    PlaneConstructionMethodType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Midplane_ (this),
      Offset_ (this),
      Perpendicular_ (this),
      Parallel_ (this),
      Copy_ (this),
      Cast_ (this),
      TangentThrough_ (this),
      Through_ (this),
      Transform_ (this),
      Extract_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Midplane
        //
        if (n.name () == L"Midplane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Midplane_type > r (
            Midplane_traits::create (i, f, this));

          if (!this->Midplane_)
          {
            this->Midplane_.set (::std::move (r));
            continue;
          }
        }

        // Offset
        //
        if (n.name () == L"Offset" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (::std::move (r));
            continue;
          }
        }

        // Perpendicular
        //
        if (n.name () == L"Perpendicular" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Perpendicular_type > r (
            Perpendicular_traits::create (i, f, this));

          if (!this->Perpendicular_)
          {
            this->Perpendicular_.set (::std::move (r));
            continue;
          }
        }

        // Parallel
        //
        if (n.name () == L"Parallel" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Parallel_type > r (
            Parallel_traits::create (i, f, this));

          if (!this->Parallel_)
          {
            this->Parallel_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == L"TangentThrough" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (::std::move (r));
            continue;
          }
        }

        // Through
        //
        if (n.name () == L"Through" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Through_type > r (
            Through_traits::create (i, f, this));

          if (!this->Through_)
          {
            this->Through_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // Extract
        //
        if (n.name () == L"Extract" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PlaneConstructionMethodType* PlaneConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneConstructionMethodType (*this, f, c);
    }

    PlaneConstructionMethodType& PlaneConstructionMethodType::
    operator= (const PlaneConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Midplane_ = x.Midplane_;
        this->Offset_ = x.Offset_;
        this->Perpendicular_ = x.Perpendicular_;
        this->Parallel_ = x.Parallel_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->TangentThrough_ = x.TangentThrough_;
        this->Through_ = x.Through_;
        this->Transform_ = x.Transform_;
        this->Extract_ = x.Extract_;
      }

      return *this;
    }

    PlaneConstructionMethodType::
    ~PlaneConstructionMethodType ()
    {
    }

    // PlaneBestFitType
    //

    PlaneBestFitType::
    PlaneBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    PlaneBestFitType::
    PlaneBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    PlaneBestFitType::
    PlaneBestFitType (const PlaneBestFitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PlaneBestFitType::
    PlaneBestFitType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaneBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PlaneBestFitType* PlaneBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneBestFitType (*this, f, c);
    }

    PlaneBestFitType& PlaneBestFitType::
    operator= (const PlaneBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PlaneBestFitType::
    ~PlaneBestFitType ()
    {
    }

    // PlaneRecompType
    //

    PlaneRecompType::
    PlaneRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (const PlaneRecompType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneRecompType* PlaneRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneRecompType (*this, f, c);
    }

    PlaneRecompType& PlaneRecompType::
    operator= (const PlaneRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    PlaneRecompType::
    ~PlaneRecompType ()
    {
    }

    // PlaneMidplaneType
    //

    PlaneMidplaneType::
    PlaneMidplaneType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (this)
    {
    }

    PlaneMidplaneType::
    PlaneMidplaneType (const PlaneMidplaneType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this)
    {
    }

    PlaneMidplaneType::
    PlaneMidplaneType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneMidplaneType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePlane
        //
        if (n.name () == L"BasePlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          this->BasePlane_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    PlaneMidplaneType* PlaneMidplaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneMidplaneType (*this, f, c);
    }

    PlaneMidplaneType& PlaneMidplaneType::
    operator= (const PlaneMidplaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
      }

      return *this;
    }

    PlaneMidplaneType::
    ~PlaneMidplaneType ()
    {
    }

    // PlaneOffsetType
    //

    PlaneOffsetType::
    PlaneOffsetType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (this),
      Offset_ (this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (const BasePlane_type& BasePlane,
                     const Offset_type& Offset)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this),
      Offset_ (Offset, this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (::std::unique_ptr< BasePlane_type > BasePlane,
                     ::std::unique_ptr< Offset_type > Offset)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (std::move (BasePlane), this),
      Offset_ (std::move (Offset), this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (const PlaneOffsetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this),
      Offset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneOffsetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePlane
        //
        if (n.name () == L"BasePlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (::std::move (r));
            continue;
          }
        }

        // Offset
        //
        if (n.name () == L"Offset" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!Offset_.present ())
          {
            this->Offset_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Offset",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneOffsetType* PlaneOffsetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneOffsetType (*this, f, c);
    }

    PlaneOffsetType& PlaneOffsetType::
    operator= (const PlaneOffsetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
        this->Offset_ = x.Offset_;
      }

      return *this;
    }

    PlaneOffsetType::
    ~PlaneOffsetType ()
    {
    }

    // PlanePerpendicularType
    //

    PlanePerpendicularType::
    PlanePerpendicularType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      PerpendicularFeature_ (this),
      PointFeature_ (this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (const PerpendicularFeature_type& PerpendicularFeature,
                            const PointFeature_type& PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (::std::unique_ptr< PerpendicularFeature_type > PerpendicularFeature,
                            ::std::unique_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      PerpendicularFeature_ (std::move (PerpendicularFeature), this),
      PointFeature_ (std::move (PointFeature), this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (const PlanePerpendicularType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      PerpendicularFeature_ (x.PerpendicularFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      PerpendicularFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlanePerpendicularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PerpendicularFeature
        //
        if (n.name () == L"PerpendicularFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PerpendicularFeature_type > r (
            PerpendicularFeature_traits::create (i, f, this));

          if (!PerpendicularFeature_.present ())
          {
            this->PerpendicularFeature_.set (::std::move (r));
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == L"PointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PerpendicularFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PerpendicularFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlanePerpendicularType* PlanePerpendicularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanePerpendicularType (*this, f, c);
    }

    PlanePerpendicularType& PlanePerpendicularType::
    operator= (const PlanePerpendicularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->PerpendicularFeature_ = x.PerpendicularFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    PlanePerpendicularType::
    ~PlanePerpendicularType ()
    {
    }

    // PlaneParallelType
    //

    PlaneParallelType::
    PlaneParallelType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ParallelFeature_ (this),
      PointFeature_ (this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (const ParallelFeature_type& ParallelFeature,
                       const PointFeature_type& PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (::std::unique_ptr< ParallelFeature_type > ParallelFeature,
                       ::std::unique_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ParallelFeature_ (std::move (ParallelFeature), this),
      PointFeature_ (std::move (PointFeature), this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (const PlaneParallelType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ParallelFeature_ (x.ParallelFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ParallelFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneParallelType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ParallelFeature
        //
        if (n.name () == L"ParallelFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ParallelFeature_type > r (
            ParallelFeature_traits::create (i, f, this));

          if (!ParallelFeature_.present ())
          {
            this->ParallelFeature_.set (::std::move (r));
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == L"PointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ParallelFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ParallelFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneParallelType* PlaneParallelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneParallelType (*this, f, c);
    }

    PlaneParallelType& PlaneParallelType::
    operator= (const PlaneParallelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ParallelFeature_ = x.ParallelFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    PlaneParallelType::
    ~PlaneParallelType ()
    {
    }

    // PlaneCopyType
    //

    PlaneCopyType::
    PlaneCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (const BasePlane_type& BasePlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (::std::unique_ptr< BasePlane_type > BasePlane)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (std::move (BasePlane), this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (const PlaneCopyType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePlane
        //
        if (n.name () == L"BasePlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePlane",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneCopyType* PlaneCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCopyType (*this, f, c);
    }

    PlaneCopyType& PlaneCopyType::
    operator= (const PlaneCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
      }

      return *this;
    }

    PlaneCopyType::
    ~PlaneCopyType ()
    {
    }

    // PlaneCastType
    //

    PlaneCastType::
    PlaneCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PlaneCastType::
    PlaneCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    PlaneCastType::
    PlaneCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    PlaneCastType::
    PlaneCastType (const PlaneCastType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PlaneCastType::
    PlaneCastType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneCastType* PlaneCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCastType (*this, f, c);
    }

    PlaneCastType& PlaneCastType::
    operator= (const PlaneCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PlaneCastType::
    ~PlaneCastType ()
    {
    }

    // PlaneTangentThroughType
    //

    PlaneTangentThroughType::
    PlaneTangentThroughType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (const TangentFeature_type& TangentFeature,
                             const PointFeature_type& PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (::std::unique_ptr< TangentFeature_type > TangentFeature,
                             ::std::unique_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      TangentFeature_ (std::move (TangentFeature), this),
      PointFeature_ (std::move (PointFeature), this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (const PlaneTangentThroughType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // TangentFeature
        //
        if (n.name () == L"TangentFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (::std::move (r));
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == L"PointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"TangentFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneTangentThroughType* PlaneTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneTangentThroughType (*this, f, c);
    }

    PlaneTangentThroughType& PlaneTangentThroughType::
    operator= (const PlaneTangentThroughType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->TangentFeature_ = x.TangentFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    PlaneTangentThroughType::
    ~PlaneTangentThroughType ()
    {
    }

    // PlaneThroughType
    //

    PlaneThroughType::
    PlaneThroughType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PlaneThroughType::
    PlaneThroughType (const PlaneThroughType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PlaneThroughType::
    PlaneThroughType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneThroughType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    PlaneThroughType* PlaneThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneThroughType (*this, f, c);
    }

    PlaneThroughType& PlaneThroughType::
    operator= (const PlaneThroughType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PlaneThroughType::
    ~PlaneThroughType ()
    {
    }

    // PlaneTransformType
    //

    PlaneTransformType::
    PlaneTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (this),
      Transformation_ (this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (const BasePlane_type& BasePlane,
                        const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this),
      Transformation_ (Transformation, this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (::std::unique_ptr< BasePlane_type > BasePlane,
                        ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePlane_ (std::move (BasePlane), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (const PlaneTransformType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePlane
        //
        if (n.name () == L"BasePlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneTransformType* PlaneTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneTransformType (*this, f, c);
    }

    PlaneTransformType& PlaneTransformType::
    operator= (const PlaneTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    PlaneTransformType::
    ~PlaneTransformType ()
    {
    }

    // PlaneExtractType
    //

    PlaneExtractType::
    PlaneExtractType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (const SurfaceFeature_type& SurfaceFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (const PlaneExtractType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneExtractType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneExtractType* PlaneExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneExtractType (*this, f, c);
    }

    PlaneExtractType& PlaneExtractType::
    operator= (const PlaneExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
      }

      return *this;
    }

    PlaneExtractType::
    ~PlaneExtractType ()
    {
    }

    // PlaneCheckedType
    //

    PlaneCheckedType::
    PlaneCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    PlaneCheckedType::
    PlaneCheckedType (const PlaneCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PlaneCheckedType::
    PlaneCheckedType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PlaneCheckedType* PlaneCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCheckedType (*this, f, c);
    }

    PlaneCheckedType& PlaneCheckedType::
    operator= (const PlaneCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PlaneCheckedType::
    ~PlaneCheckedType ()
    {
    }

    // PlaneCheckedFeatureType
    //

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType (const PlaneCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PlaneCheckedFeatureType* PlaneCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCheckedFeatureType (*this, f, c);
    }

    PlaneCheckedFeatureType& PlaneCheckedFeatureType::
    operator= (const PlaneCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    PlaneCheckedFeatureType::
    ~PlaneCheckedFeatureType ()
    {
    }

    // PlaneMeasurementDeterminationType
    //

    PlaneMeasurementDeterminationType::
    PlaneMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    PlaneMeasurementDeterminationType::
    PlaneMeasurementDeterminationType (const PlaneMeasurementDeterminationType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PlaneMeasurementDeterminationType::
    PlaneMeasurementDeterminationType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PlaneMeasurementDeterminationType* PlaneMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneMeasurementDeterminationType (*this, f, c);
    }

    PlaneMeasurementDeterminationType& PlaneMeasurementDeterminationType::
    operator= (const PlaneMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    PlaneMeasurementDeterminationType::
    ~PlaneMeasurementDeterminationType ()
    {
    }

    // PlaneFeatureItemType
    //

    PlaneFeatureItemType::
    PlaneFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const id_type& id,
                          const FeatureNominalId_type& FeatureNominalId,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const id_type& id,
                          ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                          const FeatureName_type& FeatureName,
                          ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const PlaneFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneFeatureItemType* PlaneFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureItemType (*this, f, c);
    }

    PlaneFeatureItemType& PlaneFeatureItemType::
    operator= (const PlaneFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    PlaneFeatureItemType::
    ~PlaneFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PlaneFeatureItemType >
    _xsd_PlaneFeatureItemType_type_factory_init (
      L"PlaneFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // PlaneFeatureDefinitionType
    //

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType ()
    {
    }

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id)
    {
    }

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const PlaneFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c)
    {
    }

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f, c)
    {
    }

    PlaneFeatureDefinitionType* PlaneFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureDefinitionType (*this, f, c);
    }

    PlaneFeatureDefinitionType::
    ~PlaneFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PlaneFeatureDefinitionType >
    _xsd_PlaneFeatureDefinitionType_type_factory_init (
      L"PlaneFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // PlaneFeatureNominalType
    //

    PlaneFeatureNominalType::
    PlaneFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this),
      Rectangle_ (this),
      Circle_ (this),
      Constructed_ (this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location,
                             const Normal_type& Normal)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this),
      PolyLine_ (this),
      Rectangle_ (this),
      Circle_ (this),
      Constructed_ (this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const id_type& id,
                             ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                             ::std::unique_ptr< Location_type > Location,
                             ::std::unique_ptr< Normal_type > Normal)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      Normal_ (std::move (Normal), this),
      PolyLine_ (this),
      Rectangle_ (this),
      Circle_ (this),
      Constructed_ (this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const PlaneFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      PolyLine_ (x.PolyLine_, f, this),
      Rectangle_ (x.Rectangle_, f, this),
      Circle_ (x.Circle_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this),
      Rectangle_ (this),
      Circle_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // PolyLine
        //
        if (n.name () == L"PolyLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PolyLine_type > r (
            PolyLine_traits::create (i, f, this));

          if (!this->PolyLine_)
          {
            this->PolyLine_.set (::std::move (r));
            continue;
          }
        }

        // Rectangle
        //
        if (n.name () == L"Rectangle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Rectangle_type > r (
            Rectangle_traits::create (i, f, this));

          if (!this->Rectangle_)
          {
            this->Rectangle_.set (::std::move (r));
            continue;
          }
        }

        // Circle
        //
        if (n.name () == L"Circle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Circle_type > r (
            Circle_traits::create (i, f, this));

          if (!this->Circle_)
          {
            this->Circle_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PlaneFeatureNominalType* PlaneFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureNominalType (*this, f, c);
    }

    PlaneFeatureNominalType& PlaneFeatureNominalType::
    operator= (const PlaneFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->PolyLine_ = x.PolyLine_;
        this->Rectangle_ = x.Rectangle_;
        this->Circle_ = x.Circle_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PlaneFeatureNominalType::
    ~PlaneFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PlaneFeatureNominalType >
    _xsd_PlaneFeatureNominalType_type_factory_init (
      L"PlaneFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // PlaneFeatureMeasurementType
    //

    PlaneFeatureMeasurementType::
    PlaneFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this),
      Form_ (this)
    {
    }

    PlaneFeatureMeasurementType::
    PlaneFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this),
      Form_ (this)
    {
    }

    PlaneFeatureMeasurementType::
    PlaneFeatureMeasurementType (const PlaneFeatureMeasurementType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      PolyLine_ (x.PolyLine_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PlaneFeatureMeasurementType::
    PlaneFeatureMeasurementType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // PolyLine
        //
        if (n.name () == L"PolyLine" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PolyLine_type > r (
            PolyLine_traits::create (i, f, this));

          if (!this->PolyLine_)
          {
            this->PolyLine_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PlaneFeatureMeasurementType* PlaneFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureMeasurementType (*this, f, c);
    }

    PlaneFeatureMeasurementType& PlaneFeatureMeasurementType::
    operator= (const PlaneFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->PolyLine_ = x.PolyLine_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    PlaneFeatureMeasurementType::
    ~PlaneFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PlaneFeatureMeasurementType >
    _xsd_PlaneFeatureMeasurementType_type_factory_init (
      L"PlaneFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDefinedCurveConstructionMethodType
    //

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Transform_ (this),
      FromScan_ (this),
      Extract_ (this)
    {
    }

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType (const PointDefinedCurveConstructionMethodType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Transform_ (this),
      FromScan_ (this),
      Extract_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        // Extract
        //
        if (n.name () == L"Extract" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveConstructionMethodType* PointDefinedCurveConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveConstructionMethodType (*this, f, c);
    }

    PointDefinedCurveConstructionMethodType& PointDefinedCurveConstructionMethodType::
    operator= (const PointDefinedCurveConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
        this->Extract_ = x.Extract_;
      }

      return *this;
    }

    PointDefinedCurveConstructionMethodType::
    ~PointDefinedCurveConstructionMethodType ()
    {
    }

    // PointDefinedCurveBestFitType
    //

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType (const PointDefinedCurveBestFitType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PointDefinedCurveBestFitType* PointDefinedCurveBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveBestFitType (*this, f, c);
    }

    PointDefinedCurveBestFitType& PointDefinedCurveBestFitType::
    operator= (const PointDefinedCurveBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PointDefinedCurveBestFitType::
    ~PointDefinedCurveBestFitType ()
    {
    }

    // PointDefinedCurveRecompType
    //

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const PointDefinedCurveRecompType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedCurveRecompType* PointDefinedCurveRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveRecompType (*this, f, c);
    }

    PointDefinedCurveRecompType& PointDefinedCurveRecompType::
    operator= (const PointDefinedCurveRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    PointDefinedCurveRecompType::
    ~PointDefinedCurveRecompType ()
    {
    }

    // PointDefinedCurveCopyType
    //

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const BasePointDefinedCurve_type& BasePointDefinedCurve)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (::std::unique_ptr< BasePointDefinedCurve_type > BasePointDefinedCurve)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (std::move (BasePointDefinedCurve), this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const PointDefinedCurveCopyType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedCurve_ (x.BasePointDefinedCurve_, f, this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedCurve_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePointDefinedCurve
        //
        if (n.name () == L"BasePointDefinedCurve" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePointDefinedCurve_type > r (
            BasePointDefinedCurve_traits::create (i, f, this));

          if (!BasePointDefinedCurve_.present ())
          {
            this->BasePointDefinedCurve_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedCurve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePointDefinedCurve",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedCurveCopyType* PointDefinedCurveCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCopyType (*this, f, c);
    }

    PointDefinedCurveCopyType& PointDefinedCurveCopyType::
    operator= (const PointDefinedCurveCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointDefinedCurve_ = x.BasePointDefinedCurve_;
      }

      return *this;
    }

    PointDefinedCurveCopyType::
    ~PointDefinedCurveCopyType ()
    {
    }

    // PointDefinedCurveTransformType
    //

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (this),
      Transformation_ (this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const BasePointDefinedCurve_type& BasePointDefinedCurve,
                                    const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, this),
      Transformation_ (Transformation, this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (::std::unique_ptr< BasePointDefinedCurve_type > BasePointDefinedCurve,
                                    ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (std::move (BasePointDefinedCurve), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const PointDefinedCurveTransformType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedCurve_ (x.BasePointDefinedCurve_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedCurve_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePointDefinedCurve
        //
        if (n.name () == L"BasePointDefinedCurve" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePointDefinedCurve_type > r (
            BasePointDefinedCurve_traits::create (i, f, this));

          if (!BasePointDefinedCurve_.present ())
          {
            this->BasePointDefinedCurve_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedCurve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePointDefinedCurve",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedCurveTransformType* PointDefinedCurveTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveTransformType (*this, f, c);
    }

    PointDefinedCurveTransformType& PointDefinedCurveTransformType::
    operator= (const PointDefinedCurveTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointDefinedCurve_ = x.BasePointDefinedCurve_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    PointDefinedCurveTransformType::
    ~PointDefinedCurveTransformType ()
    {
    }

    // PointDefinedCurveFromScanType
    //

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                   const SearchRadius_type& SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                                   ::std::unique_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const PointDefinedCurveFromScanType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedCurveFromScanType* PointDefinedCurveFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFromScanType (*this, f, c);
    }

    PointDefinedCurveFromScanType& PointDefinedCurveFromScanType::
    operator= (const PointDefinedCurveFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    PointDefinedCurveFromScanType::
    ~PointDefinedCurveFromScanType ()
    {
    }

    // PointDefinedCurveExtractType
    //

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (::std::unique_ptr< CurveFeature_type > CurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      CurveFeature_ (std::move (CurveFeature), this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const PointDefinedCurveExtractType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveExtractType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CurveFeature
        //
        if (n.name () == L"CurveFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CurveFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedCurveExtractType* PointDefinedCurveExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveExtractType (*this, f, c);
    }

    PointDefinedCurveExtractType& PointDefinedCurveExtractType::
    operator= (const PointDefinedCurveExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->CurveFeature_ = x.CurveFeature_;
      }

      return *this;
    }

    PointDefinedCurveExtractType::
    ~PointDefinedCurveExtractType ()
    {
    }

    // PointDefinedCurveCheckedType
    //

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType (const PointDefinedCurveCheckedType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveCheckedType* PointDefinedCurveCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCheckedType (*this, f, c);
    }

    PointDefinedCurveCheckedType& PointDefinedCurveCheckedType::
    operator= (const PointDefinedCurveCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointDefinedCurveCheckedType::
    ~PointDefinedCurveCheckedType ()
    {
    }

    // PointDefinedCurveCheckedFeatureType
    //

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType (const PointDefinedCurveCheckedFeatureType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveCheckedFeatureType* PointDefinedCurveCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCheckedFeatureType (*this, f, c);
    }

    PointDefinedCurveCheckedFeatureType& PointDefinedCurveCheckedFeatureType::
    operator= (const PointDefinedCurveCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    PointDefinedCurveCheckedFeatureType::
    ~PointDefinedCurveCheckedFeatureType ()
    {
    }

    // PointDefinedCurveMeasurementDeterminationType
    //

    PointDefinedCurveMeasurementDeterminationType::
    PointDefinedCurveMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    PointDefinedCurveMeasurementDeterminationType::
    PointDefinedCurveMeasurementDeterminationType (const PointDefinedCurveMeasurementDeterminationType& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointDefinedCurveMeasurementDeterminationType::
    PointDefinedCurveMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveMeasurementDeterminationType* PointDefinedCurveMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveMeasurementDeterminationType (*this, f, c);
    }

    PointDefinedCurveMeasurementDeterminationType& PointDefinedCurveMeasurementDeterminationType::
    operator= (const PointDefinedCurveMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    PointDefinedCurveMeasurementDeterminationType::
    ~PointDefinedCurveMeasurementDeterminationType ()
    {
    }

    // PointDefinedCurveFeatureItemType
    //

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType ()
    : ::xsd::qif30::CurveFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const id_type& id,
                                      const FeatureNominalId_type& FeatureNominalId,
                                      const FeatureName_type& FeatureName,
                                      const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const id_type& id,
                                      ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                      const FeatureName_type& FeatureName,
                                      ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::CurveFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const PointDefinedCurveFeatureItemType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedCurveFeatureItemType* PointDefinedCurveFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureItemType (*this, f, c);
    }

    PointDefinedCurveFeatureItemType& PointDefinedCurveFeatureItemType::
    operator= (const PointDefinedCurveFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    PointDefinedCurveFeatureItemType::
    ~PointDefinedCurveFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointDefinedCurveFeatureItemType >
    _xsd_PointDefinedCurveFeatureItemType_type_factory_init (
      L"PointDefinedCurveFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDefinedCurveFeatureDefinitionType
    //

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType ()
    : ::xsd::qif30::CurveFeatureDefinitionBaseType ()
    {
    }

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const id_type& id)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (id)
    {
    }

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const PointDefinedCurveFeatureDefinitionType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (x, f, c)
    {
    }

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureDefinitionBaseType (e, f, c)
    {
    }

    PointDefinedCurveFeatureDefinitionType* PointDefinedCurveFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureDefinitionType (*this, f, c);
    }

    PointDefinedCurveFeatureDefinitionType::
    ~PointDefinedCurveFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointDefinedCurveFeatureDefinitionType >
    _xsd_PointDefinedCurveFeatureDefinitionType_type_factory_init (
      L"PointDefinedCurveFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDefinedCurveFeatureNominalType
    //

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType ()
    : ::xsd::qif30::CurveFeatureNominalBaseType (),
      DefiningPoints_ (this),
      Plane_ (this),
      Constructed_ (this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         const DefiningPoints_type& DefiningPoints)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, this),
      Plane_ (this),
      Constructed_ (this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const id_type& id,
                                         ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                         ::std::unique_ptr< DefiningPoints_type > DefiningPoints)
    : ::xsd::qif30::CurveFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      DefiningPoints_ (std::move (DefiningPoints), this),
      Plane_ (this),
      Constructed_ (this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const PointDefinedCurveFeatureNominalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Plane_ (x.Plane_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (this),
      Plane_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DefiningPoints
        //
        if (n.name () == L"DefiningPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!DefiningPoints_.present ())
          {
            this->DefiningPoints_.set (::std::move (r));
            continue;
          }
        }

        // Plane
        //
        if (n.name () == L"Plane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Plane_type > r (
            Plane_traits::create (i, f, this));

          if (!this->Plane_)
          {
            this->Plane_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefiningPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefiningPoints",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedCurveFeatureNominalType* PointDefinedCurveFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureNominalType (*this, f, c);
    }

    PointDefinedCurveFeatureNominalType& PointDefinedCurveFeatureNominalType::
    operator= (const PointDefinedCurveFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureNominalBaseType& > (*this) = x;
        this->DefiningPoints_ = x.DefiningPoints_;
        this->Plane_ = x.Plane_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointDefinedCurveFeatureNominalType::
    ~PointDefinedCurveFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointDefinedCurveFeatureNominalType >
    _xsd_PointDefinedCurveFeatureNominalType_type_factory_init (
      L"PointDefinedCurveFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // DefiningPointsMeasurementType
    //

    DefiningPointsMeasurementType::
    DefiningPointsMeasurementType ()
    : ::xml_schema::type (),
      DefiningPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this),
      n_ (this)
    {
    }

    DefiningPointsMeasurementType::
    DefiningPointsMeasurementType (const n_type& n)
    : ::xml_schema::type (),
      DefiningPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this),
      n_ (n, this)
    {
    }

    DefiningPointsMeasurementType::
    DefiningPointsMeasurementType (const DefiningPointsMeasurementType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DefiningPoint_ (x.DefiningPoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DefiningPointsMeasurementType::
    DefiningPointsMeasurementType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DefiningPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DefiningPointsMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DefiningPoint
        //
        if (n.name () == L"DefiningPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefiningPoint_type > r (
            DefiningPoint_traits::create (i, f, this));

          this->DefiningPoint_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DefiningPointsMeasurementType* DefiningPointsMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DefiningPointsMeasurementType (*this, f, c);
    }

    DefiningPointsMeasurementType& DefiningPointsMeasurementType::
    operator= (const DefiningPointsMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DefiningPoint_ = x.DefiningPoint_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
        this->combinedUncertainty_ = x.combinedUncertainty_;
        this->meanError_ = x.meanError_;
        this->xCombinedUncertainty_ = x.xCombinedUncertainty_;
        this->xMeanError_ = x.xMeanError_;
        this->yCombinedUncertainty_ = x.yCombinedUncertainty_;
        this->yMeanError_ = x.yMeanError_;
        this->zCombinedUncertainty_ = x.zCombinedUncertainty_;
        this->zMeanError_ = x.zMeanError_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DefiningPointsMeasurementType::
    ~DefiningPointsMeasurementType ()
    {
    }

    // PointDefinedCurveFeatureMeasurementType
    //

    PointDefinedCurveFeatureMeasurementType::
    PointDefinedCurveFeatureMeasurementType ()
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (),
      DefiningPoints_ (this),
      Plane_ (this),
      Form_ (this)
    {
    }

    PointDefinedCurveFeatureMeasurementType::
    PointDefinedCurveFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (id),
      DefiningPoints_ (this),
      Plane_ (this),
      Form_ (this)
    {
    }

    PointDefinedCurveFeatureMeasurementType::
    PointDefinedCurveFeatureMeasurementType (const PointDefinedCurveFeatureMeasurementType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Plane_ (x.Plane_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PointDefinedCurveFeatureMeasurementType::
    PointDefinedCurveFeatureMeasurementType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::CurveFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (this),
      Plane_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::CurveFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DefiningPoints
        //
        if (n.name () == L"DefiningPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!this->DefiningPoints_)
          {
            this->DefiningPoints_.set (::std::move (r));
            continue;
          }
        }

        // Plane
        //
        if (n.name () == L"Plane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Plane_type > r (
            Plane_traits::create (i, f, this));

          if (!this->Plane_)
          {
            this->Plane_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveFeatureMeasurementType* PointDefinedCurveFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureMeasurementType (*this, f, c);
    }

    PointDefinedCurveFeatureMeasurementType& PointDefinedCurveFeatureMeasurementType::
    operator= (const PointDefinedCurveFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::CurveFeatureMeasurementBaseType& > (*this) = x;
        this->DefiningPoints_ = x.DefiningPoints_;
        this->Plane_ = x.Plane_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    PointDefinedCurveFeatureMeasurementType::
    ~PointDefinedCurveFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointDefinedCurveFeatureMeasurementType >
    _xsd_PointDefinedCurveFeatureMeasurementType_type_factory_init (
      L"PointDefinedCurveFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDefinedSurfaceConstructionMethodType
    //

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Transform_ (this),
      Extract_ (this)
    {
    }

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType (const PointDefinedSurfaceConstructionMethodType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Transform_ (this),
      Extract_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // Extract
        //
        if (n.name () == L"Extract" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceConstructionMethodType* PointDefinedSurfaceConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceConstructionMethodType (*this, f, c);
    }

    PointDefinedSurfaceConstructionMethodType& PointDefinedSurfaceConstructionMethodType::
    operator= (const PointDefinedSurfaceConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Transform_ = x.Transform_;
        this->Extract_ = x.Extract_;
      }

      return *this;
    }

    PointDefinedSurfaceConstructionMethodType::
    ~PointDefinedSurfaceConstructionMethodType ()
    {
    }

    // PointDefinedSurfaceBestFitType
    //

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType (const PointDefinedSurfaceBestFitType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PointDefinedSurfaceBestFitType* PointDefinedSurfaceBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceBestFitType (*this, f, c);
    }

    PointDefinedSurfaceBestFitType& PointDefinedSurfaceBestFitType::
    operator= (const PointDefinedSurfaceBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PointDefinedSurfaceBestFitType::
    ~PointDefinedSurfaceBestFitType ()
    {
    }

    // PointDefinedSurfaceRecompType
    //

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const PointDefinedSurfaceRecompType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedSurfaceRecompType* PointDefinedSurfaceRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceRecompType (*this, f, c);
    }

    PointDefinedSurfaceRecompType& PointDefinedSurfaceRecompType::
    operator= (const PointDefinedSurfaceRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    PointDefinedSurfaceRecompType::
    ~PointDefinedSurfaceRecompType ()
    {
    }

    // PointDefinedSurfaceCopyType
    //

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const BasePointDefinedSurface_type& BasePointDefinedSurface)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (::std::unique_ptr< BasePointDefinedSurface_type > BasePointDefinedSurface)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (std::move (BasePointDefinedSurface), this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const PointDefinedSurfaceCopyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedSurface_ (x.BasePointDefinedSurface_, f, this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedSurface_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePointDefinedSurface
        //
        if (n.name () == L"BasePointDefinedSurface" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePointDefinedSurface_type > r (
            BasePointDefinedSurface_traits::create (i, f, this));

          if (!BasePointDefinedSurface_.present ())
          {
            this->BasePointDefinedSurface_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedSurface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePointDefinedSurface",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedSurfaceCopyType* PointDefinedSurfaceCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCopyType (*this, f, c);
    }

    PointDefinedSurfaceCopyType& PointDefinedSurfaceCopyType::
    operator= (const PointDefinedSurfaceCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointDefinedSurface_ = x.BasePointDefinedSurface_;
      }

      return *this;
    }

    PointDefinedSurfaceCopyType::
    ~PointDefinedSurfaceCopyType ()
    {
    }

    // PointDefinedSurfaceTransformType
    //

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (this),
      Transformation_ (this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const BasePointDefinedSurface_type& BasePointDefinedSurface,
                                      const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, this),
      Transformation_ (Transformation, this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (::std::unique_ptr< BasePointDefinedSurface_type > BasePointDefinedSurface,
                                      ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (std::move (BasePointDefinedSurface), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const PointDefinedSurfaceTransformType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedSurface_ (x.BasePointDefinedSurface_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedSurface_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePointDefinedSurface
        //
        if (n.name () == L"BasePointDefinedSurface" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePointDefinedSurface_type > r (
            BasePointDefinedSurface_traits::create (i, f, this));

          if (!BasePointDefinedSurface_.present ())
          {
            this->BasePointDefinedSurface_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedSurface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePointDefinedSurface",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedSurfaceTransformType* PointDefinedSurfaceTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceTransformType (*this, f, c);
    }

    PointDefinedSurfaceTransformType& PointDefinedSurfaceTransformType::
    operator= (const PointDefinedSurfaceTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointDefinedSurface_ = x.BasePointDefinedSurface_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    PointDefinedSurfaceTransformType::
    ~PointDefinedSurfaceTransformType ()
    {
    }

    // PointDefinedSurfaceExtractType
    //

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const SurfaceFeature_type& SurfaceFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const PointDefinedSurfaceExtractType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceExtractType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedSurfaceExtractType* PointDefinedSurfaceExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceExtractType (*this, f, c);
    }

    PointDefinedSurfaceExtractType& PointDefinedSurfaceExtractType::
    operator= (const PointDefinedSurfaceExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
      }

      return *this;
    }

    PointDefinedSurfaceExtractType::
    ~PointDefinedSurfaceExtractType ()
    {
    }

    // PointDefinedSurfaceCheckedType
    //

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType (const PointDefinedSurfaceCheckedType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceCheckedType* PointDefinedSurfaceCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCheckedType (*this, f, c);
    }

    PointDefinedSurfaceCheckedType& PointDefinedSurfaceCheckedType::
    operator= (const PointDefinedSurfaceCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointDefinedSurfaceCheckedType::
    ~PointDefinedSurfaceCheckedType ()
    {
    }

    // PointDefinedSurfaceCheckedFeatureType
    //

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType (const PointDefinedSurfaceCheckedFeatureType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceCheckedFeatureType* PointDefinedSurfaceCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCheckedFeatureType (*this, f, c);
    }

    PointDefinedSurfaceCheckedFeatureType& PointDefinedSurfaceCheckedFeatureType::
    operator= (const PointDefinedSurfaceCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    PointDefinedSurfaceCheckedFeatureType::
    ~PointDefinedSurfaceCheckedFeatureType ()
    {
    }

    // PointDefinedSurfaceMeasurementDeterminationType
    //

    PointDefinedSurfaceMeasurementDeterminationType::
    PointDefinedSurfaceMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    PointDefinedSurfaceMeasurementDeterminationType::
    PointDefinedSurfaceMeasurementDeterminationType (const PointDefinedSurfaceMeasurementDeterminationType& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointDefinedSurfaceMeasurementDeterminationType::
    PointDefinedSurfaceMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceMeasurementDeterminationType* PointDefinedSurfaceMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceMeasurementDeterminationType (*this, f, c);
    }

    PointDefinedSurfaceMeasurementDeterminationType& PointDefinedSurfaceMeasurementDeterminationType::
    operator= (const PointDefinedSurfaceMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    PointDefinedSurfaceMeasurementDeterminationType::
    ~PointDefinedSurfaceMeasurementDeterminationType ()
    {
    }

    // PointDefinedSurfaceFeatureItemType
    //

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const id_type& id,
                                        const FeatureNominalId_type& FeatureNominalId,
                                        const FeatureName_type& FeatureName,
                                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const id_type& id,
                                        ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                        const FeatureName_type& FeatureName,
                                        ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const PointDefinedSurfaceFeatureItemType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedSurfaceFeatureItemType* PointDefinedSurfaceFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureItemType (*this, f, c);
    }

    PointDefinedSurfaceFeatureItemType& PointDefinedSurfaceFeatureItemType::
    operator= (const PointDefinedSurfaceFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    PointDefinedSurfaceFeatureItemType::
    ~PointDefinedSurfaceFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointDefinedSurfaceFeatureItemType >
    _xsd_PointDefinedSurfaceFeatureItemType_type_factory_init (
      L"PointDefinedSurfaceFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDefinedSurfaceFeatureDefinitionType
    //

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType ()
    {
    }

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const PointDefinedSurfaceFeatureDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f, c)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType* PointDefinedSurfaceFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureDefinitionType (*this, f, c);
    }

    PointDefinedSurfaceFeatureDefinitionType::
    ~PointDefinedSurfaceFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointDefinedSurfaceFeatureDefinitionType >
    _xsd_PointDefinedSurfaceFeatureDefinitionType_type_factory_init (
      L"PointDefinedSurfaceFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // DefiningPointsNominalType
    //

    DefiningPointsNominalType::
    DefiningPointsNominalType ()
    : ::xml_schema::type (),
      DefiningPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      n_ (this)
    {
    }

    DefiningPointsNominalType::
    DefiningPointsNominalType (const n_type& n)
    : ::xml_schema::type (),
      DefiningPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      n_ (n, this)
    {
    }

    DefiningPointsNominalType::
    DefiningPointsNominalType (const DefiningPointsNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DefiningPoint_ (x.DefiningPoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this),
      n_ (x.n_, f, this)
    {
    }

    DefiningPointsNominalType::
    DefiningPointsNominalType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DefiningPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DefiningPointsNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DefiningPoint
        //
        if (n.name () == L"DefiningPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefiningPoint_type > r (
            DefiningPoint_traits::create (i, f, this));

          this->DefiningPoint_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    DefiningPointsNominalType* DefiningPointsNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DefiningPointsNominalType (*this, f, c);
    }

    DefiningPointsNominalType& DefiningPointsNominalType::
    operator= (const DefiningPointsNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DefiningPoint_ = x.DefiningPoint_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
        this->n_ = x.n_;
      }

      return *this;
    }

    DefiningPointsNominalType::
    ~DefiningPointsNominalType ()
    {
    }

    // PointDefinedSurfaceFeatureNominalType
    //

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      DefiningPoints_ (this),
      Constructed_ (this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           const DefiningPoints_type& DefiningPoints)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, this),
      Constructed_ (this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const id_type& id,
                                           ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                           ::std::unique_ptr< DefiningPoints_type > DefiningPoints)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      DefiningPoints_ (std::move (DefiningPoints), this),
      Constructed_ (this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const PointDefinedSurfaceFeatureNominalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DefiningPoints
        //
        if (n.name () == L"DefiningPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!DefiningPoints_.present ())
          {
            this->DefiningPoints_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DefiningPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DefiningPoints",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointDefinedSurfaceFeatureNominalType* PointDefinedSurfaceFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureNominalType (*this, f, c);
    }

    PointDefinedSurfaceFeatureNominalType& PointDefinedSurfaceFeatureNominalType::
    operator= (const PointDefinedSurfaceFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->DefiningPoints_ = x.DefiningPoints_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointDefinedSurfaceFeatureNominalType::
    ~PointDefinedSurfaceFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointDefinedSurfaceFeatureNominalType >
    _xsd_PointDefinedSurfaceFeatureNominalType_type_factory_init (
      L"PointDefinedSurfaceFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // PointDefinedSurfaceFeatureMeasurementType
    //

    PointDefinedSurfaceFeatureMeasurementType::
    PointDefinedSurfaceFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      DefiningPoints_ (this),
      Form_ (this)
    {
    }

    PointDefinedSurfaceFeatureMeasurementType::
    PointDefinedSurfaceFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      DefiningPoints_ (this),
      Form_ (this)
    {
    }

    PointDefinedSurfaceFeatureMeasurementType::
    PointDefinedSurfaceFeatureMeasurementType (const PointDefinedSurfaceFeatureMeasurementType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PointDefinedSurfaceFeatureMeasurementType::
    PointDefinedSurfaceFeatureMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DefiningPoints
        //
        if (n.name () == L"DefiningPoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!this->DefiningPoints_)
          {
            this->DefiningPoints_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceFeatureMeasurementType* PointDefinedSurfaceFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureMeasurementType (*this, f, c);
    }

    PointDefinedSurfaceFeatureMeasurementType& PointDefinedSurfaceFeatureMeasurementType::
    operator= (const PointDefinedSurfaceFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->DefiningPoints_ = x.DefiningPoints_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    PointDefinedSurfaceFeatureMeasurementType::
    ~PointDefinedSurfaceFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointDefinedSurfaceFeatureMeasurementType >
    _xsd_PointDefinedSurfaceFeatureMeasurementType_type_factory_init (
      L"PointDefinedSurfaceFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // PointConstructionMethodType
    //

    PointConstructionMethodType::
    PointConstructionMethodType ()
    : ::xml_schema::type (),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromCone_ (this),
      FromScan_ (this),
      CenterOfGravity_ (this),
      Pierce_ (this),
      MidPoint_ (this),
      MovePoint_ (this),
      MovePointVector_ (this),
      MovePointAxis_ (this),
      Extreme_ (this)
    {
    }

    PointConstructionMethodType::
    PointConstructionMethodType (const PointConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCone_ (x.FromCone_, f, this),
      FromScan_ (x.FromScan_, f, this),
      CenterOfGravity_ (x.CenterOfGravity_, f, this),
      Pierce_ (x.Pierce_, f, this),
      MidPoint_ (x.MidPoint_, f, this),
      MovePoint_ (x.MovePoint_, f, this),
      MovePointVector_ (x.MovePointVector_, f, this),
      MovePointAxis_ (x.MovePointAxis_, f, this),
      Extreme_ (x.Extreme_, f, this)
    {
    }

    PointConstructionMethodType::
    PointConstructionMethodType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromCone_ (this),
      FromScan_ (this),
      CenterOfGravity_ (this),
      Pierce_ (this),
      MidPoint_ (this),
      MovePoint_ (this),
      MovePointVector_ (this),
      MovePointAxis_ (this),
      Extreme_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Intersection
        //
        if (n.name () == L"Intersection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (::std::move (r));
            continue;
          }
        }

        // Projection
        //
        if (n.name () == L"Projection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromCone
        //
        if (n.name () == L"FromCone" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromCone_type > r (
            FromCone_traits::create (i, f, this));

          if (!this->FromCone_)
          {
            this->FromCone_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        // CenterOfGravity
        //
        if (n.name () == L"CenterOfGravity" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CenterOfGravity_type > r (
            CenterOfGravity_traits::create (i, f, this));

          if (!this->CenterOfGravity_)
          {
            this->CenterOfGravity_.set (::std::move (r));
            continue;
          }
        }

        // Pierce
        //
        if (n.name () == L"Pierce" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Pierce_type > r (
            Pierce_traits::create (i, f, this));

          if (!this->Pierce_)
          {
            this->Pierce_.set (::std::move (r));
            continue;
          }
        }

        // MidPoint
        //
        if (n.name () == L"MidPoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MidPoint_type > r (
            MidPoint_traits::create (i, f, this));

          if (!this->MidPoint_)
          {
            this->MidPoint_.set (::std::move (r));
            continue;
          }
        }

        // MovePoint
        //
        if (n.name () == L"MovePoint" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MovePoint_type > r (
            MovePoint_traits::create (i, f, this));

          if (!this->MovePoint_)
          {
            this->MovePoint_.set (::std::move (r));
            continue;
          }
        }

        // MovePointVector
        //
        if (n.name () == L"MovePointVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MovePointVector_type > r (
            MovePointVector_traits::create (i, f, this));

          if (!this->MovePointVector_)
          {
            this->MovePointVector_.set (::std::move (r));
            continue;
          }
        }

        // MovePointAxis
        //
        if (n.name () == L"MovePointAxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MovePointAxis_type > r (
            MovePointAxis_traits::create (i, f, this));

          if (!this->MovePointAxis_)
          {
            this->MovePointAxis_.set (::std::move (r));
            continue;
          }
        }

        // Extreme
        //
        if (n.name () == L"Extreme" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Extreme_type > r (
            Extreme_traits::create (i, f, this));

          if (!this->Extreme_)
          {
            this->Extreme_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointConstructionMethodType* PointConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointConstructionMethodType (*this, f, c);
    }

    PointConstructionMethodType& PointConstructionMethodType::
    operator= (const PointConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromCone_ = x.FromCone_;
        this->FromScan_ = x.FromScan_;
        this->CenterOfGravity_ = x.CenterOfGravity_;
        this->Pierce_ = x.Pierce_;
        this->MidPoint_ = x.MidPoint_;
        this->MovePoint_ = x.MovePoint_;
        this->MovePointVector_ = x.MovePointVector_;
        this->MovePointAxis_ = x.MovePointAxis_;
        this->Extreme_ = x.Extreme_;
      }

      return *this;
    }

    PointConstructionMethodType::
    ~PointConstructionMethodType ()
    {
    }

    // PointFeatureIntersectionType
    //

    PointFeatureIntersectionType::
    PointFeatureIntersectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      IntersectionFeature_ (this)
    {
    }

    PointFeatureIntersectionType::
    PointFeatureIntersectionType (const PointFeatureIntersectionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    PointFeatureIntersectionType::
    PointFeatureIntersectionType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IntersectionFeature
        //
        if (n.name () == L"IntersectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          this->IntersectionFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    PointFeatureIntersectionType* PointFeatureIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureIntersectionType (*this, f, c);
    }

    PointFeatureIntersectionType& PointFeatureIntersectionType::
    operator= (const PointFeatureIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    PointFeatureIntersectionType::
    ~PointFeatureIntersectionType ()
    {
    }

    // PointFeaturePierceType
    //

    PointFeaturePierceType::
    PointFeaturePierceType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      CurveFeature_ (this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (const SurfaceFeature_type& SurfaceFeature,
                            const CurveFeature_type& CurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      CurveFeature_ (CurveFeature, this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                            ::std::unique_ptr< CurveFeature_type > CurveFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      CurveFeature_ (std::move (CurveFeature), this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (const PointFeaturePierceType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      CurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeaturePierceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // CurveFeature
        //
        if (n.name () == L"CurveFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CurveFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeaturePierceType* PointFeaturePierceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeaturePierceType (*this, f, c);
    }

    PointFeaturePierceType& PointFeaturePierceType::
    operator= (const PointFeaturePierceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->CurveFeature_ = x.CurveFeature_;
      }

      return *this;
    }

    PointFeaturePierceType::
    ~PointFeaturePierceType ()
    {
    }

    // PointFeatureProjectionType
    //

    PointFeatureProjectionType::
    PointFeatureProjectionType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (this),
      ProjectionFeature_ (this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (const ProjectionPlane_type& ProjectionPlane,
                                const ProjectionFeature_type& ProjectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionFeature_ (ProjectionFeature, this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (::std::unique_ptr< ProjectionPlane_type > ProjectionPlane,
                                ::std::unique_ptr< ProjectionFeature_type > ProjectionFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      ProjectionPlane_ (std::move (ProjectionPlane), this),
      ProjectionFeature_ (std::move (ProjectionFeature), this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (const PointFeatureProjectionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionFeature_ (x.ProjectionFeature_, f, this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (this),
      ProjectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureProjectionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ProjectionPlane
        //
        if (n.name () == L"ProjectionPlane" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (::std::move (r));
            continue;
          }
        }

        // ProjectionFeature
        //
        if (n.name () == L"ProjectionFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ProjectionFeature_type > r (
            ProjectionFeature_traits::create (i, f, this));

          if (!ProjectionFeature_.present ())
          {
            this->ProjectionFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionPlane",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ProjectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ProjectionFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureProjectionType* PointFeatureProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureProjectionType (*this, f, c);
    }

    PointFeatureProjectionType& PointFeatureProjectionType::
    operator= (const PointFeatureProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionPlane_ = x.ProjectionPlane_;
        this->ProjectionFeature_ = x.ProjectionFeature_;
      }

      return *this;
    }

    PointFeatureProjectionType::
    ~PointFeatureProjectionType ()
    {
    }

    // PointFeatureFromConeType
    //

    PointFeatureFromConeType::
    PointFeatureFromConeType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (const BaseCone_type& BaseCone)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (::std::unique_ptr< BaseCone_type > BaseCone)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCone_ (std::move (BaseCone), this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (const PointFeatureFromConeType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureFromConeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCone
        //
        if (n.name () == L"BaseCone" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCone",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureFromConeType* PointFeatureFromConeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureFromConeType (*this, f, c);
    }

    PointFeatureFromConeType& PointFeatureFromConeType::
    operator= (const PointFeatureFromConeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCone_ = x.BaseCone_;
      }

      return *this;
    }

    PointFeatureFromConeType::
    ~PointFeatureFromConeType ()
    {
    }

    // PointFeatureCopyType
    //

    PointFeatureCopyType::
    PointFeatureCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointFeature_ (this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (const BasePointFeature_type& BasePointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (::std::unique_ptr< BasePointFeature_type > BasePointFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointFeature_ (std::move (BasePointFeature), this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (const PointFeatureCopyType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePointFeature_ (x.BasePointFeature_, f, this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePointFeature
        //
        if (n.name () == L"BasePointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePointFeature_type > r (
            BasePointFeature_traits::create (i, f, this));

          if (!BasePointFeature_.present ())
          {
            this->BasePointFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureCopyType* PointFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCopyType (*this, f, c);
    }

    PointFeatureCopyType& PointFeatureCopyType::
    operator= (const PointFeatureCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointFeature_ = x.BasePointFeature_;
      }

      return *this;
    }

    PointFeatureCopyType::
    ~PointFeatureCopyType ()
    {
    }

    // PointFeatureTransformType
    //

    PointFeatureTransformType::
    PointFeatureTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointFeature_ (this),
      Transformation_ (this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (const BasePointFeature_type& BasePointFeature,
                               const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, this),
      Transformation_ (Transformation, this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (::std::unique_ptr< BasePointFeature_type > BasePointFeature,
                               ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BasePointFeature_ (std::move (BasePointFeature), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (const PointFeatureTransformType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BasePointFeature_ (x.BasePointFeature_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointFeature_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BasePointFeature
        //
        if (n.name () == L"BasePointFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BasePointFeature_type > r (
            BasePointFeature_traits::create (i, f, this));

          if (!BasePointFeature_.present ())
          {
            this->BasePointFeature_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BasePointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BasePointFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureTransformType* PointFeatureTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureTransformType (*this, f, c);
    }

    PointFeatureTransformType& PointFeatureTransformType::
    operator= (const PointFeatureTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointFeature_ = x.BasePointFeature_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    PointFeatureTransformType::
    ~PointFeatureTransformType ()
    {
    }

    // PointFeatureFromScanType
    //

    PointFeatureFromScanType::
    PointFeatureFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      RetrievalMethod_ (this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (const SurfaceFeature_type& SurfaceFeature,
                              const SearchRadius_type& SearchRadius,
                              const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      RetrievalMethod_ (RetrievalMethod, this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                              ::std::unique_ptr< SearchRadius_type > SearchRadius,
                              const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      RetrievalMethod_ (RetrievalMethod, this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (const PointFeatureFromScanType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      RetrievalMethod_ (x.RetrievalMethod_, f, this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      RetrievalMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // RetrievalMethod
        //
        if (n.name () == L"RetrievalMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RetrievalMethod_type > r (
            RetrievalMethod_traits::create (i, f, this));

          if (!RetrievalMethod_.present ())
          {
            this->RetrievalMethod_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RetrievalMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RetrievalMethod",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureFromScanType* PointFeatureFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureFromScanType (*this, f, c);
    }

    PointFeatureFromScanType& PointFeatureFromScanType::
    operator= (const PointFeatureFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->RetrievalMethod_ = x.RetrievalMethod_;
      }

      return *this;
    }

    PointFeatureFromScanType::
    ~PointFeatureFromScanType ()
    {
    }

    // PointFeatureCenterOfGravityType
    //

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType (const PointFeatureCenterOfGravityType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointFeatureCenterOfGravityType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PointFeatureCenterOfGravityType* PointFeatureCenterOfGravityType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCenterOfGravityType (*this, f, c);
    }

    PointFeatureCenterOfGravityType& PointFeatureCenterOfGravityType::
    operator= (const PointFeatureCenterOfGravityType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PointFeatureCenterOfGravityType::
    ~PointFeatureCenterOfGravityType ()
    {
    }

    // PointFeatureMidPointType
    //

    PointFeatureMidPointType::
    PointFeatureMidPointType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PointFeatureMidPointType::
    PointFeatureMidPointType (const PointFeatureMidPointType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointFeatureMidPointType::
    PointFeatureMidPointType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMidPointType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    PointFeatureMidPointType* PointFeatureMidPointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMidPointType (*this, f, c);
    }

    PointFeatureMidPointType& PointFeatureMidPointType::
    operator= (const PointFeatureMidPointType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PointFeatureMidPointType::
    ~PointFeatureMidPointType ()
    {
    }

    // PointFeatureCastType
    //

    PointFeatureCastType::
    PointFeatureCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (const PointFeatureCastType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureCastType* PointFeatureCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCastType (*this, f, c);
    }

    PointFeatureCastType& PointFeatureCastType::
    operator= (const PointFeatureCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PointFeatureCastType::
    ~PointFeatureCastType ()
    {
    }

    // PointFeatureMovePointType
    //

    PointFeatureMovePointType::
    PointFeatureMovePointType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      Offset_ (this),
      DirectionalOffset_ (this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Offset_ (this),
      DirectionalOffset_ (this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this),
      Offset_ (this),
      DirectionalOffset_ (this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (const PointFeatureMovePointType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Offset_ (x.Offset_, f, this),
      DirectionalOffset_ (x.DirectionalOffset_, f, this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      Offset_ (this),
      DirectionalOffset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        // Offset
        //
        if (n.name () == L"Offset" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (::std::move (r));
            continue;
          }
        }

        // DirectionalOffset
        //
        if (n.name () == L"DirectionalOffset" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DirectionalOffset_type > r (
            DirectionalOffset_traits::create (i, f, this));

          if (!this->DirectionalOffset_)
          {
            this->DirectionalOffset_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureMovePointType* PointFeatureMovePointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointType (*this, f, c);
    }

    PointFeatureMovePointType& PointFeatureMovePointType::
    operator= (const PointFeatureMovePointType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->Offset_ = x.Offset_;
        this->DirectionalOffset_ = x.DirectionalOffset_;
      }

      return *this;
    }

    PointFeatureMovePointType::
    ~PointFeatureMovePointType ()
    {
    }

    // PointFeatureMovePointVectorType
    //

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      Distance_ (this),
      Vector_ (this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const BaseFeature_type& BaseFeature,
                                     const Distance_type& Distance,
                                     const Vector_type& Vector)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Distance_ (Distance, this),
      Vector_ (Vector, this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (::std::unique_ptr< BaseFeature_type > BaseFeature,
                                     ::std::unique_ptr< Distance_type > Distance,
                                     ::std::unique_ptr< Vector_type > Vector)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this),
      Distance_ (std::move (Distance), this),
      Vector_ (std::move (Vector), this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const PointFeatureMovePointVectorType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Distance_ (x.Distance_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      Distance_ (this),
      Vector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointVectorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        // Distance
        //
        if (n.name () == L"Distance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (::std::move (r));
            continue;
          }
        }

        // Vector
        //
        if (n.name () == L"Vector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!Vector_.present ())
          {
            this->Vector_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Distance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Vector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Vector",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureMovePointVectorType* PointFeatureMovePointVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointVectorType (*this, f, c);
    }

    PointFeatureMovePointVectorType& PointFeatureMovePointVectorType::
    operator= (const PointFeatureMovePointVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->Distance_ = x.Distance_;
        this->Vector_ = x.Vector_;
      }

      return *this;
    }

    PointFeatureMovePointVectorType::
    ~PointFeatureMovePointVectorType ()
    {
    }

    // PointFeatureMovePointAxisType
    //

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLocationFeature_ (this),
      Distance_ (this),
      BaseAxisFeature_ (this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const BaseLocationFeature_type& BaseLocationFeature,
                                   const Distance_type& Distance,
                                   const BaseAxisFeature_type& BaseAxisFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLocationFeature_ (BaseLocationFeature, this),
      Distance_ (Distance, this),
      BaseAxisFeature_ (BaseAxisFeature, this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (::std::unique_ptr< BaseLocationFeature_type > BaseLocationFeature,
                                   ::std::unique_ptr< Distance_type > Distance,
                                   ::std::unique_ptr< BaseAxisFeature_type > BaseAxisFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseLocationFeature_ (std::move (BaseLocationFeature), this),
      Distance_ (std::move (Distance), this),
      BaseAxisFeature_ (std::move (BaseAxisFeature), this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const PointFeatureMovePointAxisType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseLocationFeature_ (x.BaseLocationFeature_, f, this),
      Distance_ (x.Distance_, f, this),
      BaseAxisFeature_ (x.BaseAxisFeature_, f, this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLocationFeature_ (this),
      Distance_ (this),
      BaseAxisFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointAxisType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseLocationFeature
        //
        if (n.name () == L"BaseLocationFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseLocationFeature_type > r (
            BaseLocationFeature_traits::create (i, f, this));

          if (!BaseLocationFeature_.present ())
          {
            this->BaseLocationFeature_.set (::std::move (r));
            continue;
          }
        }

        // Distance
        //
        if (n.name () == L"Distance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (::std::move (r));
            continue;
          }
        }

        // BaseAxisFeature
        //
        if (n.name () == L"BaseAxisFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseAxisFeature_type > r (
            BaseAxisFeature_traits::create (i, f, this));

          if (!BaseAxisFeature_.present ())
          {
            this->BaseAxisFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseLocationFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseLocationFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Distance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!BaseAxisFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseAxisFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureMovePointAxisType* PointFeatureMovePointAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointAxisType (*this, f, c);
    }

    PointFeatureMovePointAxisType& PointFeatureMovePointAxisType::
    operator= (const PointFeatureMovePointAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseLocationFeature_ = x.BaseLocationFeature_;
        this->Distance_ = x.Distance_;
        this->BaseAxisFeature_ = x.BaseAxisFeature_;
      }

      return *this;
    }

    PointFeatureMovePointAxisType::
    ~PointFeatureMovePointAxisType ()
    {
    }

    // PointFeatureExtremeType
    //

    const PointFeatureExtremeType::Radial_type PointFeatureExtremeType::Radial_default_value_ (
      L"Radial");

    const PointFeatureExtremeType::Xaxis_type PointFeatureExtremeType::Xaxis_default_value_ (
      L"Xaxis");

    const PointFeatureExtremeType::Yaxis_type PointFeatureExtremeType::Yaxis_default_value_ (
      L"Yaxis");

    const PointFeatureExtremeType::Zaxis_type PointFeatureExtremeType::Zaxis_default_value_ (
      L"Zaxis");

    PointFeatureExtremeType::
    PointFeatureExtremeType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      Minimum_ (this),
      BaseAxisFeature_ (this),
      Vector_ (this),
      Radial_ (this),
      Xaxis_ (this),
      Yaxis_ (this),
      Zaxis_ (this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (const BaseFeature_type& BaseFeature,
                             const Minimum_type& Minimum)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Minimum_ (Minimum, this),
      BaseAxisFeature_ (this),
      Vector_ (this),
      Radial_ (this),
      Xaxis_ (this),
      Yaxis_ (this),
      Zaxis_ (this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (::std::unique_ptr< BaseFeature_type > BaseFeature,
                             const Minimum_type& Minimum)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this),
      Minimum_ (Minimum, this),
      BaseAxisFeature_ (this),
      Vector_ (this),
      Radial_ (this),
      Xaxis_ (this),
      Yaxis_ (this),
      Zaxis_ (this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (const PointFeatureExtremeType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Minimum_ (x.Minimum_, f, this),
      BaseAxisFeature_ (x.BaseAxisFeature_, f, this),
      Vector_ (x.Vector_, f, this),
      Radial_ (x.Radial_, f, this),
      Xaxis_ (x.Xaxis_, f, this),
      Yaxis_ (x.Yaxis_, f, this),
      Zaxis_ (x.Zaxis_, f, this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      Minimum_ (this),
      BaseAxisFeature_ (this),
      Vector_ (this),
      Radial_ (this),
      Xaxis_ (this),
      Yaxis_ (this),
      Zaxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureExtremeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        // Minimum
        //
        if (n.name () == L"Minimum" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!Minimum_.present ())
          {
            this->Minimum_.set (Minimum_traits::create (i, f, this));
            continue;
          }
        }

        // BaseAxisFeature
        //
        if (n.name () == L"BaseAxisFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseAxisFeature_type > r (
            BaseAxisFeature_traits::create (i, f, this));

          if (!this->BaseAxisFeature_)
          {
            this->BaseAxisFeature_.set (::std::move (r));
            continue;
          }
        }

        // Vector
        //
        if (n.name () == L"Vector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!this->Vector_)
          {
            this->Vector_.set (::std::move (r));
            continue;
          }
        }

        // Radial
        //
        if (n.name () == L"Radial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Radial_type > r (
            Radial_traits::create (i, f, this));

          if (!this->Radial_)
          {
            this->Radial_.set (::std::move (r));
            continue;
          }
        }

        // Xaxis
        //
        if (n.name () == L"Xaxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Xaxis_type > r (
            Xaxis_traits::create (i, f, this));

          if (!this->Xaxis_)
          {
            this->Xaxis_.set (::std::move (r));
            continue;
          }
        }

        // Yaxis
        //
        if (n.name () == L"Yaxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Yaxis_type > r (
            Yaxis_traits::create (i, f, this));

          if (!this->Yaxis_)
          {
            this->Yaxis_.set (::std::move (r));
            continue;
          }
        }

        // Zaxis
        //
        if (n.name () == L"Zaxis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Zaxis_type > r (
            Zaxis_traits::create (i, f, this));

          if (!this->Zaxis_)
          {
            this->Zaxis_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Minimum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Minimum",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureExtremeType* PointFeatureExtremeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureExtremeType (*this, f, c);
    }

    PointFeatureExtremeType& PointFeatureExtremeType::
    operator= (const PointFeatureExtremeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->Minimum_ = x.Minimum_;
        this->BaseAxisFeature_ = x.BaseAxisFeature_;
        this->Vector_ = x.Vector_;
        this->Radial_ = x.Radial_;
        this->Xaxis_ = x.Xaxis_;
        this->Yaxis_ = x.Yaxis_;
        this->Zaxis_ = x.Zaxis_;
      }

      return *this;
    }

    PointFeatureExtremeType::
    ~PointFeatureExtremeType ()
    {
    }

    // PointCheckedType
    //

    PointCheckedType::
    PointCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    PointCheckedType::
    PointCheckedType (const PointCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointCheckedType::
    PointCheckedType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointCheckedType* PointCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCheckedType (*this, f, c);
    }

    PointCheckedType& PointCheckedType::
    operator= (const PointCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointCheckedType::
    ~PointCheckedType ()
    {
    }

    // PointCheckedFeatureType
    //

    PointCheckedFeatureType::
    PointCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    PointCheckedFeatureType::
    PointCheckedFeatureType (const PointCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointCheckedFeatureType::
    PointCheckedFeatureType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointCheckedFeatureType* PointCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCheckedFeatureType (*this, f, c);
    }

    PointCheckedFeatureType& PointCheckedFeatureType::
    operator= (const PointCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    PointCheckedFeatureType::
    ~PointCheckedFeatureType ()
    {
    }

    // PointMeasurementDeterminationType
    //

    PointMeasurementDeterminationType::
    PointMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    PointMeasurementDeterminationType::
    PointMeasurementDeterminationType (const PointMeasurementDeterminationType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointMeasurementDeterminationType::
    PointMeasurementDeterminationType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointMeasurementDeterminationType* PointMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointMeasurementDeterminationType (*this, f, c);
    }

    PointMeasurementDeterminationType& PointMeasurementDeterminationType::
    operator= (const PointMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    PointMeasurementDeterminationType::
    ~PointMeasurementDeterminationType ()
    {
    }

    // PointFeatureItemType
    //

    PointFeatureItemType::
    PointFeatureItemType ()
    : ::xsd::qif30::PointFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const id_type& id,
                          const FeatureNominalId_type& FeatureNominalId,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::PointFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const id_type& id,
                          ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                          const FeatureName_type& FeatureName,
                          ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::PointFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const PointFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureItemType* PointFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureItemType (*this, f, c);
    }

    PointFeatureItemType& PointFeatureItemType::
    operator= (const PointFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    PointFeatureItemType::
    ~PointFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointFeatureItemType >
    _xsd_PointFeatureItemType_type_factory_init (
      L"PointFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // PointFeatureDefinitionType
    //

    PointFeatureDefinitionType::
    PointFeatureDefinitionType ()
    : ::xsd::qif30::PointFeatureDefinitionBaseType ()
    {
    }

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const id_type& id)
    : ::xsd::qif30::PointFeatureDefinitionBaseType (id)
    {
    }

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const PointFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureDefinitionBaseType (x, f, c)
    {
    }

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureDefinitionBaseType (e, f, c)
    {
    }

    PointFeatureDefinitionType* PointFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureDefinitionType (*this, f, c);
    }

    PointFeatureDefinitionType::
    ~PointFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointFeatureDefinitionType >
    _xsd_PointFeatureDefinitionType_type_factory_init (
      L"PointFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // PointFeatureNominalType
    //

    PointFeatureNominalType::
    PointFeatureNominalType ()
    : ::xsd::qif30::PointFeatureNominalBaseType (),
      Location_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location)
    : ::xsd::qif30::PointFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const id_type& id,
                             ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                             ::std::unique_ptr< Location_type > Location)
    : ::xsd::qif30::PointFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      Normal_ (this),
      Constructed_ (this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const PointFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PointFeatureNominalType* PointFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureNominalType (*this, f, c);
    }

    PointFeatureNominalType& PointFeatureNominalType::
    operator= (const PointFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointFeatureNominalType::
    ~PointFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointFeatureNominalType >
    _xsd_PointFeatureNominalType_type_factory_init (
      L"PointFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // PointFeatureMeasurementType
    //

    PointFeatureMeasurementType::
    PointFeatureMeasurementType ()
    : ::xsd::qif30::PointFeatureMeasurementBaseType (),
      Location_ (this),
      Normal_ (this)
    {
    }

    PointFeatureMeasurementType::
    PointFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::PointFeatureMeasurementBaseType (id),
      Location_ (this),
      Normal_ (this)
    {
    }

    PointFeatureMeasurementType::
    PointFeatureMeasurementType (const PointFeatureMeasurementType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    PointFeatureMeasurementType::
    PointFeatureMeasurementType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::PointFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PointFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointFeatureMeasurementType* PointFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMeasurementType (*this, f, c);
    }

    PointFeatureMeasurementType& PointFeatureMeasurementType::
    operator= (const PointFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PointFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    PointFeatureMeasurementType::
    ~PointFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PointFeatureMeasurementType >
    _xsd_PointFeatureMeasurementType_type_factory_init (
      L"PointFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // SphereConstructionMethodType
    //

    SphereConstructionMethodType::
    SphereConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    SphereConstructionMethodType::
    SphereConstructionMethodType (const SphereConstructionMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    SphereConstructionMethodType::
    SphereConstructionMethodType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphereConstructionMethodType* SphereConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereConstructionMethodType (*this, f, c);
    }

    SphereConstructionMethodType& SphereConstructionMethodType::
    operator= (const SphereConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    SphereConstructionMethodType::
    ~SphereConstructionMethodType ()
    {
    }

    // SphereBestFitType
    //

    SphereBestFitType::
    SphereBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    SphereBestFitType::
    SphereBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    SphereBestFitType::
    SphereBestFitType (const SphereBestFitType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SphereBestFitType::
    SphereBestFitType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SphereBestFitType* SphereBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereBestFitType (*this, f, c);
    }

    SphereBestFitType& SphereBestFitType::
    operator= (const SphereBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SphereBestFitType::
    ~SphereBestFitType ()
    {
    }

    // SphereRecompType
    //

    SphereRecompType::
    SphereRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    SphereRecompType::
    SphereRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SphereRecompType::
    SphereRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    SphereRecompType::
    SphereRecompType (const SphereRecompType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SphereRecompType::
    SphereRecompType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereRecompType* SphereRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereRecompType (*this, f, c);
    }

    SphereRecompType& SphereRecompType::
    operator= (const SphereRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    SphereRecompType::
    ~SphereRecompType ()
    {
    }

    // SphereCopyType
    //

    SphereCopyType::
    SphereCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphere_ (this)
    {
    }

    SphereCopyType::
    SphereCopyType (const BaseSphere_type& BaseSphere)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, this)
    {
    }

    SphereCopyType::
    SphereCopyType (::std::unique_ptr< BaseSphere_type > BaseSphere)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphere_ (std::move (BaseSphere), this)
    {
    }

    SphereCopyType::
    SphereCopyType (const SphereCopyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseSphere_ (x.BaseSphere_, f, this)
    {
    }

    SphereCopyType::
    SphereCopyType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphere_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseSphere
        //
        if (n.name () == L"BaseSphere" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseSphere_type > r (
            BaseSphere_traits::create (i, f, this));

          if (!BaseSphere_.present ())
          {
            this->BaseSphere_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseSphere_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseSphere",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereCopyType* SphereCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCopyType (*this, f, c);
    }

    SphereCopyType& SphereCopyType::
    operator= (const SphereCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSphere_ = x.BaseSphere_;
      }

      return *this;
    }

    SphereCopyType::
    ~SphereCopyType ()
    {
    }

    // SphereCastType
    //

    SphereCastType::
    SphereCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    SphereCastType::
    SphereCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SphereCastType::
    SphereCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    SphereCastType::
    SphereCastType (const SphereCastType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphereCastType::
    SphereCastType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereCastType* SphereCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCastType (*this, f, c);
    }

    SphereCastType& SphereCastType::
    operator= (const SphereCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SphereCastType::
    ~SphereCastType ()
    {
    }

    // SphereTransformType
    //

    SphereTransformType::
    SphereTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphere_ (this),
      Transformation_ (this)
    {
    }

    SphereTransformType::
    SphereTransformType (const BaseSphere_type& BaseSphere,
                         const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, this),
      Transformation_ (Transformation, this)
    {
    }

    SphereTransformType::
    SphereTransformType (::std::unique_ptr< BaseSphere_type > BaseSphere,
                         ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphere_ (std::move (BaseSphere), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    SphereTransformType::
    SphereTransformType (const SphereTransformType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseSphere_ (x.BaseSphere_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SphereTransformType::
    SphereTransformType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphere_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseSphere
        //
        if (n.name () == L"BaseSphere" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseSphere_type > r (
            BaseSphere_traits::create (i, f, this));

          if (!BaseSphere_.present ())
          {
            this->BaseSphere_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseSphere_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseSphere",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereTransformType* SphereTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereTransformType (*this, f, c);
    }

    SphereTransformType& SphereTransformType::
    operator= (const SphereTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSphere_ = x.BaseSphere_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    SphereTransformType::
    ~SphereTransformType ()
    {
    }

    // SphereFromScanType
    //

    SphereFromScanType::
    SphereFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Vector_ (this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (const SurfaceFeature_type& SurfaceFeature,
                        const SearchRadius_type& SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Vector_ (this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                        ::std::unique_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this),
      Vector_ (this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (const SphereFromScanType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Vector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        // Vector
        //
        if (n.name () == L"Vector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!this->Vector_)
          {
            this->Vector_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereFromScanType* SphereFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFromScanType (*this, f, c);
    }

    SphereFromScanType& SphereFromScanType::
    operator= (const SphereFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Vector_ = x.Vector_;
      }

      return *this;
    }

    SphereFromScanType::
    ~SphereFromScanType ()
    {
    }

    // SphereCheckedType
    //

    SphereCheckedType::
    SphereCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    SphereCheckedType::
    SphereCheckedType (const SphereCheckedType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SphereCheckedType::
    SphereCheckedType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphereCheckedType* SphereCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCheckedType (*this, f, c);
    }

    SphereCheckedType& SphereCheckedType::
    operator= (const SphereCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SphereCheckedType::
    ~SphereCheckedType ()
    {
    }

    // SphereCheckedFeatureType
    //

    SphereCheckedFeatureType::
    SphereCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    SphereCheckedFeatureType::
    SphereCheckedFeatureType (const SphereCheckedFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SphereCheckedFeatureType::
    SphereCheckedFeatureType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphereCheckedFeatureType* SphereCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCheckedFeatureType (*this, f, c);
    }

    SphereCheckedFeatureType& SphereCheckedFeatureType::
    operator= (const SphereCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    SphereCheckedFeatureType::
    ~SphereCheckedFeatureType ()
    {
    }

    // SphereMeasurementDeterminationType
    //

    SphereMeasurementDeterminationType::
    SphereMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    SphereMeasurementDeterminationType::
    SphereMeasurementDeterminationType (const SphereMeasurementDeterminationType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SphereMeasurementDeterminationType::
    SphereMeasurementDeterminationType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphereMeasurementDeterminationType* SphereMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereMeasurementDeterminationType (*this, f, c);
    }

    SphereMeasurementDeterminationType& SphereMeasurementDeterminationType::
    operator= (const SphereMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    SphereMeasurementDeterminationType::
    ~SphereMeasurementDeterminationType ()
    {
    }

    // SphereFeatureItemType
    //

    SphereFeatureItemType::
    SphereFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const id_type& id,
                           const FeatureNominalId_type& FeatureNominalId,
                           const FeatureName_type& FeatureName,
                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const id_type& id,
                           ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                           const FeatureName_type& FeatureName,
                           ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const SphereFeatureItemType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereFeatureItemType* SphereFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureItemType (*this, f, c);
    }

    SphereFeatureItemType& SphereFeatureItemType::
    operator= (const SphereFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    SphereFeatureItemType::
    ~SphereFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphereFeatureItemType >
    _xsd_SphereFeatureItemType_type_factory_init (
      L"SphereFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // SphereFeatureDefinitionType
    //

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 const Diameter_type& Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 ::std::unique_ptr< Diameter_type > Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const SphereFeatureDefinitionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereFeatureDefinitionType* SphereFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureDefinitionType (*this, f, c);
    }

    SphereFeatureDefinitionType& SphereFeatureDefinitionType::
    operator= (const SphereFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
      }

      return *this;
    }

    SphereFeatureDefinitionType::
    ~SphereFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphereFeatureDefinitionType >
    _xsd_SphereFeatureDefinitionType_type_factory_init (
      L"SphereFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // SphereFeatureNominalType
    //

    SphereFeatureNominalType::
    SphereFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Location_ (this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              const Location_type& Location)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Location_ (Location, this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const id_type& id,
                              ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                              ::std::unique_ptr< Location_type > Location)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const SphereFeatureNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == L"LatitudeLongitudeSweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphereFeatureNominalType* SphereFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureNominalType (*this, f, c);
    }

    SphereFeatureNominalType& SphereFeatureNominalType::
    operator= (const SphereFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SphereFeatureNominalType::
    ~SphereFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphereFeatureNominalType >
    _xsd_SphereFeatureNominalType_type_factory_init (
      L"SphereFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // SphereFeatureMeasurementType
    //

    SphereFeatureMeasurementType::
    SphereFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
    }

    SphereFeatureMeasurementType::
    SphereFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
    }

    SphereFeatureMeasurementType::
    SphereFeatureMeasurementType (const SphereFeatureMeasurementType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      LatitudeLongitudeSweepMeasurementRange_ (x.LatitudeLongitudeSweepMeasurementRange_, f, this),
      LatitudeLongitudeSweepFull_ (x.LatitudeLongitudeSweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SphereFeatureMeasurementType::
    SphereFeatureMeasurementType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweepMeasurementRange
        //
        if (n.name () == L"LatitudeLongitudeSweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > r (
            LatitudeLongitudeSweepMeasurementRange_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweepMeasurementRange_)
          {
            this->LatitudeLongitudeSweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweepFull
        //
        if (n.name () == L"LatitudeLongitudeSweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweepFull_type > r (
            LatitudeLongitudeSweepFull_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweepFull_)
          {
            this->LatitudeLongitudeSweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphereFeatureMeasurementType* SphereFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureMeasurementType (*this, f, c);
    }

    SphereFeatureMeasurementType& SphereFeatureMeasurementType::
    operator= (const SphereFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->LatitudeLongitudeSweepMeasurementRange_ = x.LatitudeLongitudeSweepMeasurementRange_;
        this->LatitudeLongitudeSweepFull_ = x.LatitudeLongitudeSweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    SphereFeatureMeasurementType::
    ~SphereFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphereFeatureMeasurementType >
    _xsd_SphereFeatureMeasurementType_type_factory_init (
      L"SphereFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericalSegmentConstructionMethodType
    //

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType (const SphericalSegmentConstructionMethodType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentConstructionMethodType* SphericalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentConstructionMethodType (*this, f, c);
    }

    SphericalSegmentConstructionMethodType& SphericalSegmentConstructionMethodType::
    operator= (const SphericalSegmentConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    SphericalSegmentConstructionMethodType::
    ~SphericalSegmentConstructionMethodType ()
    {
    }

    // SphericalSegmentBestFitType
    //

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType (const SphericalSegmentBestFitType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SphericalSegmentBestFitType* SphericalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentBestFitType (*this, f, c);
    }

    SphericalSegmentBestFitType& SphericalSegmentBestFitType::
    operator= (const SphericalSegmentBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SphericalSegmentBestFitType::
    ~SphericalSegmentBestFitType ()
    {
    }

    // SphericalSegmentRecompType
    //

    SphericalSegmentRecompType::
    SphericalSegmentRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const SphericalSegmentRecompType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphericalSegmentRecompType* SphericalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentRecompType (*this, f, c);
    }

    SphericalSegmentRecompType& SphericalSegmentRecompType::
    operator= (const SphericalSegmentRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    SphericalSegmentRecompType::
    ~SphericalSegmentRecompType ()
    {
    }

    // SphericalSegmentCopyType
    //

    SphericalSegmentCopyType::
    SphericalSegmentCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const BaseSphericalSegment_type& BaseSphericalSegment)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (::std::unique_ptr< BaseSphericalSegment_type > BaseSphericalSegment)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (std::move (BaseSphericalSegment), this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const SphericalSegmentCopyType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseSphericalSegment_ (x.BaseSphericalSegment_, f, this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphericalSegment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseSphericalSegment
        //
        if (n.name () == L"BaseSphericalSegment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseSphericalSegment_type > r (
            BaseSphericalSegment_traits::create (i, f, this));

          if (!BaseSphericalSegment_.present ())
          {
            this->BaseSphericalSegment_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseSphericalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseSphericalSegment",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphericalSegmentCopyType* SphericalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCopyType (*this, f, c);
    }

    SphericalSegmentCopyType& SphericalSegmentCopyType::
    operator= (const SphericalSegmentCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSphericalSegment_ = x.BaseSphericalSegment_;
      }

      return *this;
    }

    SphericalSegmentCopyType::
    ~SphericalSegmentCopyType ()
    {
    }

    // SphericalSegmentCastType
    //

    SphericalSegmentCastType::
    SphericalSegmentCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (const SphericalSegmentCastType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphericalSegmentCastType* SphericalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCastType (*this, f, c);
    }

    SphericalSegmentCastType& SphericalSegmentCastType::
    operator= (const SphericalSegmentCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SphericalSegmentCastType::
    ~SphericalSegmentCastType ()
    {
    }

    // SphericalSegmentTransformType
    //

    SphericalSegmentTransformType::
    SphericalSegmentTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (this),
      Transformation_ (this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const BaseSphericalSegment_type& BaseSphericalSegment,
                                   const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (::std::unique_ptr< BaseSphericalSegment_type > BaseSphericalSegment,
                                   ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (std::move (BaseSphericalSegment), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const SphericalSegmentTransformType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseSphericalSegment_ (x.BaseSphericalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphericalSegment_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseSphericalSegment
        //
        if (n.name () == L"BaseSphericalSegment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseSphericalSegment_type > r (
            BaseSphericalSegment_traits::create (i, f, this));

          if (!BaseSphericalSegment_.present ())
          {
            this->BaseSphericalSegment_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseSphericalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseSphericalSegment",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphericalSegmentTransformType* SphericalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentTransformType (*this, f, c);
    }

    SphericalSegmentTransformType& SphericalSegmentTransformType::
    operator= (const SphericalSegmentTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSphericalSegment_ = x.BaseSphericalSegment_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    SphericalSegmentTransformType::
    ~SphericalSegmentTransformType ()
    {
    }

    // SphericalSegmentCheckedType
    //

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType (const SphericalSegmentCheckedType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentCheckedType* SphericalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCheckedType (*this, f, c);
    }

    SphericalSegmentCheckedType& SphericalSegmentCheckedType::
    operator= (const SphericalSegmentCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SphericalSegmentCheckedType::
    ~SphericalSegmentCheckedType ()
    {
    }

    // SphericalSegmentCheckedFeatureType
    //

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType (const SphericalSegmentCheckedFeatureType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentCheckedFeatureType* SphericalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCheckedFeatureType (*this, f, c);
    }

    SphericalSegmentCheckedFeatureType& SphericalSegmentCheckedFeatureType::
    operator= (const SphericalSegmentCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    SphericalSegmentCheckedFeatureType::
    ~SphericalSegmentCheckedFeatureType ()
    {
    }

    // SphericalSegmentMeasurementDeterminationType
    //

    SphericalSegmentMeasurementDeterminationType::
    SphericalSegmentMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    SphericalSegmentMeasurementDeterminationType::
    SphericalSegmentMeasurementDeterminationType (const SphericalSegmentMeasurementDeterminationType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SphericalSegmentMeasurementDeterminationType::
    SphericalSegmentMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentMeasurementDeterminationType* SphericalSegmentMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentMeasurementDeterminationType (*this, f, c);
    }

    SphericalSegmentMeasurementDeterminationType& SphericalSegmentMeasurementDeterminationType::
    operator= (const SphericalSegmentMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    SphericalSegmentMeasurementDeterminationType::
    ~SphericalSegmentMeasurementDeterminationType ()
    {
    }

    // SphericalSegmentFeatureItemType
    //

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const id_type& id,
                                     const FeatureNominalId_type& FeatureNominalId,
                                     const FeatureName_type& FeatureName,
                                     const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const id_type& id,
                                     ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                     const FeatureName_type& FeatureName,
                                     ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const SphericalSegmentFeatureItemType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphericalSegmentFeatureItemType* SphericalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureItemType (*this, f, c);
    }

    SphericalSegmentFeatureItemType& SphericalSegmentFeatureItemType::
    operator= (const SphericalSegmentFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    SphericalSegmentFeatureItemType::
    ~SphericalSegmentFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericalSegmentFeatureItemType >
    _xsd_SphericalSegmentFeatureItemType_type_factory_init (
      L"SphericalSegmentFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericalSegmentFeatureDefinitionType
    //

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Diameter_ (this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const id_type& id,
                                           const InternalExternal_type& InternalExternal,
                                           const Diameter_type& Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const id_type& id,
                                           const InternalExternal_type& InternalExternal,
                                           ::std::unique_ptr< Diameter_type > Diameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (std::move (Diameter), this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const SphericalSegmentFeatureDefinitionType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphericalSegmentFeatureDefinitionType* SphericalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureDefinitionType (*this, f, c);
    }

    SphericalSegmentFeatureDefinitionType& SphericalSegmentFeatureDefinitionType::
    operator= (const SphericalSegmentFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
      }

      return *this;
    }

    SphericalSegmentFeatureDefinitionType::
    ~SphericalSegmentFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericalSegmentFeatureDefinitionType >
    _xsd_SphericalSegmentFeatureDefinitionType_type_factory_init (
      L"SphericalSegmentFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericalSegmentFeatureNominalType
    //

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Location_ (this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const id_type& id,
                                        const FeatureDefinitionId_type& FeatureDefinitionId,
                                        const Location_type& Location,
                                        const LatitudeLongitudeSweep_type& LatitudeLongitudeSweep)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Location_ (Location, this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, this),
      Constructed_ (this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const id_type& id,
                                        ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                        ::std::unique_ptr< Location_type > Location,
                                        ::std::unique_ptr< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      LatitudeLongitudeSweep_ (std::move (LatitudeLongitudeSweep), this),
      Constructed_ (this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const SphericalSegmentFeatureNominalType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == L"LatitudeLongitudeSweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!LatitudeLongitudeSweep_.present ())
          {
            this->LatitudeLongitudeSweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!LatitudeLongitudeSweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LatitudeLongitudeSweep",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SphericalSegmentFeatureNominalType* SphericalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureNominalType (*this, f, c);
    }

    SphericalSegmentFeatureNominalType& SphericalSegmentFeatureNominalType::
    operator= (const SphericalSegmentFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SphericalSegmentFeatureNominalType::
    ~SphericalSegmentFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericalSegmentFeatureNominalType >
    _xsd_SphericalSegmentFeatureNominalType_type_factory_init (
      L"SphericalSegmentFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // SphericalSegmentFeatureMeasurementType
    //

    SphericalSegmentFeatureMeasurementType::
    SphericalSegmentFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
    }

    SphericalSegmentFeatureMeasurementType::
    SphericalSegmentFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
    }

    SphericalSegmentFeatureMeasurementType::
    SphericalSegmentFeatureMeasurementType (const SphericalSegmentFeatureMeasurementType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      LatitudeLongitudeSweepMeasurementRange_ (x.LatitudeLongitudeSweepMeasurementRange_, f, this),
      LatitudeLongitudeSweepFull_ (x.LatitudeLongitudeSweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SphericalSegmentFeatureMeasurementType::
    SphericalSegmentFeatureMeasurementType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == L"DiameterMin" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (::std::move (r));
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == L"DiameterMax" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweepMeasurementRange
        //
        if (n.name () == L"LatitudeLongitudeSweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > r (
            LatitudeLongitudeSweepMeasurementRange_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweepMeasurementRange_)
          {
            this->LatitudeLongitudeSweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweepFull
        //
        if (n.name () == L"LatitudeLongitudeSweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweepFull_type > r (
            LatitudeLongitudeSweepFull_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweepFull_)
          {
            this->LatitudeLongitudeSweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentFeatureMeasurementType* SphericalSegmentFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureMeasurementType (*this, f, c);
    }

    SphericalSegmentFeatureMeasurementType& SphericalSegmentFeatureMeasurementType::
    operator= (const SphericalSegmentFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->LatitudeLongitudeSweepMeasurementRange_ = x.LatitudeLongitudeSweepMeasurementRange_;
        this->LatitudeLongitudeSweepFull_ = x.LatitudeLongitudeSweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    SphericalSegmentFeatureMeasurementType::
    ~SphericalSegmentFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SphericalSegmentFeatureMeasurementType >
    _xsd_SphericalSegmentFeatureMeasurementType_type_factory_init (
      L"SphericalSegmentFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceOfRevolutionConstructionMethodType
    //

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType (const SurfaceOfRevolutionConstructionMethodType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionConstructionMethodType* SurfaceOfRevolutionConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionConstructionMethodType (*this, f, c);
    }

    SurfaceOfRevolutionConstructionMethodType& SurfaceOfRevolutionConstructionMethodType::
    operator= (const SurfaceOfRevolutionConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    SurfaceOfRevolutionConstructionMethodType::
    ~SurfaceOfRevolutionConstructionMethodType ()
    {
    }

    // SurfaceOfRevolutionBestFitType
    //

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType (const SurfaceOfRevolutionBestFitType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    SurfaceOfRevolutionBestFitType* SurfaceOfRevolutionBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionBestFitType (*this, f, c);
    }

    SurfaceOfRevolutionBestFitType& SurfaceOfRevolutionBestFitType::
    operator= (const SurfaceOfRevolutionBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    SurfaceOfRevolutionBestFitType::
    ~SurfaceOfRevolutionBestFitType ()
    {
    }

    // SurfaceOfRevolutionRecompType
    //

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const SurfaceOfRevolutionRecompType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SurfaceOfRevolutionRecompType* SurfaceOfRevolutionRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionRecompType (*this, f, c);
    }

    SurfaceOfRevolutionRecompType& SurfaceOfRevolutionRecompType::
    operator= (const SurfaceOfRevolutionRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    SurfaceOfRevolutionRecompType::
    ~SurfaceOfRevolutionRecompType ()
    {
    }

    // SurfaceOfRevolutionCopyType
    //

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const BaseSurfaceOfRevolution_type& BaseSurfaceOfRevolution)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (::std::unique_ptr< BaseSurfaceOfRevolution_type > BaseSurfaceOfRevolution)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (std::move (BaseSurfaceOfRevolution), this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const SurfaceOfRevolutionCopyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseSurfaceOfRevolution_ (x.BaseSurfaceOfRevolution_, f, this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSurfaceOfRevolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseSurfaceOfRevolution
        //
        if (n.name () == L"BaseSurfaceOfRevolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseSurfaceOfRevolution_type > r (
            BaseSurfaceOfRevolution_traits::create (i, f, this));

          if (!BaseSurfaceOfRevolution_.present ())
          {
            this->BaseSurfaceOfRevolution_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseSurfaceOfRevolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseSurfaceOfRevolution",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SurfaceOfRevolutionCopyType* SurfaceOfRevolutionCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCopyType (*this, f, c);
    }

    SurfaceOfRevolutionCopyType& SurfaceOfRevolutionCopyType::
    operator= (const SurfaceOfRevolutionCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSurfaceOfRevolution_ = x.BaseSurfaceOfRevolution_;
      }

      return *this;
    }

    SurfaceOfRevolutionCopyType::
    ~SurfaceOfRevolutionCopyType ()
    {
    }

    // SurfaceOfRevolutionCastType
    //

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const SurfaceOfRevolutionCastType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SurfaceOfRevolutionCastType* SurfaceOfRevolutionCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCastType (*this, f, c);
    }

    SurfaceOfRevolutionCastType& SurfaceOfRevolutionCastType::
    operator= (const SurfaceOfRevolutionCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SurfaceOfRevolutionCastType::
    ~SurfaceOfRevolutionCastType ()
    {
    }

    // SurfaceOfRevolutionTransformType
    //

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (this),
      Transformation_ (this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const BaseSurfaceOfRevolution_type& BaseSurfaceOfRevolution,
                                      const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, this),
      Transformation_ (Transformation, this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (::std::unique_ptr< BaseSurfaceOfRevolution_type > BaseSurfaceOfRevolution,
                                      ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (std::move (BaseSurfaceOfRevolution), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const SurfaceOfRevolutionTransformType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseSurfaceOfRevolution_ (x.BaseSurfaceOfRevolution_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSurfaceOfRevolution_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseSurfaceOfRevolution
        //
        if (n.name () == L"BaseSurfaceOfRevolution" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseSurfaceOfRevolution_type > r (
            BaseSurfaceOfRevolution_traits::create (i, f, this));

          if (!BaseSurfaceOfRevolution_.present ())
          {
            this->BaseSurfaceOfRevolution_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseSurfaceOfRevolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseSurfaceOfRevolution",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SurfaceOfRevolutionTransformType* SurfaceOfRevolutionTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionTransformType (*this, f, c);
    }

    SurfaceOfRevolutionTransformType& SurfaceOfRevolutionTransformType::
    operator= (const SurfaceOfRevolutionTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSurfaceOfRevolution_ = x.BaseSurfaceOfRevolution_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    SurfaceOfRevolutionTransformType::
    ~SurfaceOfRevolutionTransformType ()
    {
    }

    // SurfaceOfRevolutionCheckedType
    //

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType (const SurfaceOfRevolutionCheckedType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionCheckedType* SurfaceOfRevolutionCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCheckedType (*this, f, c);
    }

    SurfaceOfRevolutionCheckedType& SurfaceOfRevolutionCheckedType::
    operator= (const SurfaceOfRevolutionCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SurfaceOfRevolutionCheckedType::
    ~SurfaceOfRevolutionCheckedType ()
    {
    }

    // SurfaceOfRevolutionCheckedFeatureType
    //

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType (const SurfaceOfRevolutionCheckedFeatureType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionCheckedFeatureType* SurfaceOfRevolutionCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCheckedFeatureType (*this, f, c);
    }

    SurfaceOfRevolutionCheckedFeatureType& SurfaceOfRevolutionCheckedFeatureType::
    operator= (const SurfaceOfRevolutionCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    SurfaceOfRevolutionCheckedFeatureType::
    ~SurfaceOfRevolutionCheckedFeatureType ()
    {
    }

    // SurfaceOfRevolutionMeasurementDeterminationType
    //

    SurfaceOfRevolutionMeasurementDeterminationType::
    SurfaceOfRevolutionMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    SurfaceOfRevolutionMeasurementDeterminationType::
    SurfaceOfRevolutionMeasurementDeterminationType (const SurfaceOfRevolutionMeasurementDeterminationType& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SurfaceOfRevolutionMeasurementDeterminationType::
    SurfaceOfRevolutionMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionMeasurementDeterminationType* SurfaceOfRevolutionMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionMeasurementDeterminationType (*this, f, c);
    }

    SurfaceOfRevolutionMeasurementDeterminationType& SurfaceOfRevolutionMeasurementDeterminationType::
    operator= (const SurfaceOfRevolutionMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    SurfaceOfRevolutionMeasurementDeterminationType::
    ~SurfaceOfRevolutionMeasurementDeterminationType ()
    {
    }

    // SurfaceOfRevolutionFeatureItemType
    //

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const id_type& id,
                                        const FeatureNominalId_type& FeatureNominalId,
                                        const FeatureName_type& FeatureName,
                                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const id_type& id,
                                        ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                        const FeatureName_type& FeatureName,
                                        ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const SurfaceOfRevolutionFeatureItemType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SurfaceOfRevolutionFeatureItemType* SurfaceOfRevolutionFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureItemType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureItemType& SurfaceOfRevolutionFeatureItemType::
    operator= (const SurfaceOfRevolutionFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    SurfaceOfRevolutionFeatureItemType::
    ~SurfaceOfRevolutionFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SurfaceOfRevolutionFeatureItemType >
    _xsd_SurfaceOfRevolutionFeatureItemType_type_factory_init (
      L"SurfaceOfRevolutionFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceOfRevolutionFeatureDefinitionType
    //

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      Length_ (this)
    {
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const id_type& id,
                                              const InternalExternal_type& InternalExternal)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Length_ (this)
    {
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const SurfaceOfRevolutionFeatureDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SurfaceOfRevolutionFeatureDefinitionType* SurfaceOfRevolutionFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureDefinitionType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureDefinitionType& SurfaceOfRevolutionFeatureDefinitionType::
    operator= (const SurfaceOfRevolutionFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    ~SurfaceOfRevolutionFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SurfaceOfRevolutionFeatureDefinitionType >
    _xsd_SurfaceOfRevolutionFeatureDefinitionType_type_factory_init (
      L"SurfaceOfRevolutionFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceOfRevolutionFeatureNominalType
    //

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Axis_ (this),
      Sweep_ (this),
      ReferenceFeatureNominalId_ (this),
      Constructed_ (this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           const Axis_type& Axis)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this),
      ReferenceFeatureNominalId_ (this),
      Constructed_ (this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const id_type& id,
                                           ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                           ::std::unique_ptr< Axis_type > Axis)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Axis_ (std::move (Axis), this),
      Sweep_ (this),
      ReferenceFeatureNominalId_ (this),
      Constructed_ (this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const SurfaceOfRevolutionFeatureNominalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      ReferenceFeatureNominalId_ (x.ReferenceFeatureNominalId_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this),
      ReferenceFeatureNominalId_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == L"Sweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (::std::move (r));
            continue;
          }
        }

        // ReferenceFeatureNominalId
        //
        if (n.name () == L"ReferenceFeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ReferenceFeatureNominalId_type > r (
            ReferenceFeatureNominalId_traits::create (i, f, this));

          if (!this->ReferenceFeatureNominalId_)
          {
            this->ReferenceFeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SurfaceOfRevolutionFeatureNominalType* SurfaceOfRevolutionFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureNominalType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureNominalType& SurfaceOfRevolutionFeatureNominalType::
    operator= (const SurfaceOfRevolutionFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->ReferenceFeatureNominalId_ = x.ReferenceFeatureNominalId_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SurfaceOfRevolutionFeatureNominalType::
    ~SurfaceOfRevolutionFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SurfaceOfRevolutionFeatureNominalType >
    _xsd_SurfaceOfRevolutionFeatureNominalType_type_factory_init (
      L"SurfaceOfRevolutionFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // SurfaceOfRevolutionFeatureMeasurementType
    //

    SurfaceOfRevolutionFeatureMeasurementType::
    SurfaceOfRevolutionFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Axis_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Length_ (this),
      Form_ (this)
    {
    }

    SurfaceOfRevolutionFeatureMeasurementType::
    SurfaceOfRevolutionFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Axis_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Length_ (this),
      Form_ (this)
    {
    }

    SurfaceOfRevolutionFeatureMeasurementType::
    SurfaceOfRevolutionFeatureMeasurementType (const SurfaceOfRevolutionFeatureMeasurementType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      SweepMeasurementRange_ (x.SweepMeasurementRange_, f, this),
      SweepFull_ (x.SweepFull_, f, this),
      Length_ (x.Length_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureMeasurementType::
    SurfaceOfRevolutionFeatureMeasurementType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      SweepMeasurementRange_ (this),
      SweepFull_ (this),
      Length_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // SweepMeasurementRange
        //
        if (n.name () == L"SweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepMeasurementRange_type > r (
            SweepMeasurementRange_traits::create (i, f, this));

          if (!this->SweepMeasurementRange_)
          {
            this->SweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // SweepFull
        //
        if (n.name () == L"SweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SweepFull_type > r (
            SweepFull_traits::create (i, f, this));

          if (!this->SweepFull_)
          {
            this->SweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionFeatureMeasurementType* SurfaceOfRevolutionFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureMeasurementType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureMeasurementType& SurfaceOfRevolutionFeatureMeasurementType::
    operator= (const SurfaceOfRevolutionFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->SweepMeasurementRange_ = x.SweepMeasurementRange_;
        this->SweepFull_ = x.SweepFull_;
        this->Length_ = x.Length_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    SurfaceOfRevolutionFeatureMeasurementType::
    ~SurfaceOfRevolutionFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SurfaceOfRevolutionFeatureMeasurementType >
    _xsd_SurfaceOfRevolutionFeatureMeasurementType_type_factory_init (
      L"SurfaceOfRevolutionFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // ThreadedFeatureConstructionMethodType
    //

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromCylinder_ (this)
    {
    }

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType (const ThreadedFeatureConstructionMethodType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCylinder_ (x.FromCylinder_, f, this)
    {
    }

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromCylinder_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromCylinder
        //
        if (n.name () == L"FromCylinder" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromCylinder_type > r (
            FromCylinder_traits::create (i, f, this));

          if (!this->FromCylinder_)
          {
            this->FromCylinder_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureConstructionMethodType* ThreadedFeatureConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureConstructionMethodType (*this, f, c);
    }

    ThreadedFeatureConstructionMethodType& ThreadedFeatureConstructionMethodType::
    operator= (const ThreadedFeatureConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromCylinder_ = x.FromCylinder_;
      }

      return *this;
    }

    ThreadedFeatureConstructionMethodType::
    ~ThreadedFeatureConstructionMethodType ()
    {
    }

    // ThreadedFeatureBestFitType
    //

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType (const ThreadedFeatureBestFitType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ThreadedFeatureBestFitType* ThreadedFeatureBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureBestFitType (*this, f, c);
    }

    ThreadedFeatureBestFitType& ThreadedFeatureBestFitType::
    operator= (const ThreadedFeatureBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ThreadedFeatureBestFitType::
    ~ThreadedFeatureBestFitType ()
    {
    }

    // ThreadedFeatureRecompType
    //

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const ThreadedFeatureRecompType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ThreadedFeatureRecompType* ThreadedFeatureRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureRecompType (*this, f, c);
    }

    ThreadedFeatureRecompType& ThreadedFeatureRecompType::
    operator= (const ThreadedFeatureRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ThreadedFeatureRecompType::
    ~ThreadedFeatureRecompType ()
    {
    }

    // ThreadedFeatureCopyType
    //

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const BaseThreadedFeature_type& BaseThreadedFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (::std::unique_ptr< BaseThreadedFeature_type > BaseThreadedFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (std::move (BaseThreadedFeature), this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const ThreadedFeatureCopyType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseThreadedFeature_ (x.BaseThreadedFeature_, f, this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseThreadedFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseThreadedFeature
        //
        if (n.name () == L"BaseThreadedFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseThreadedFeature_type > r (
            BaseThreadedFeature_traits::create (i, f, this));

          if (!BaseThreadedFeature_.present ())
          {
            this->BaseThreadedFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseThreadedFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseThreadedFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ThreadedFeatureCopyType* ThreadedFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCopyType (*this, f, c);
    }

    ThreadedFeatureCopyType& ThreadedFeatureCopyType::
    operator= (const ThreadedFeatureCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseThreadedFeature_ = x.BaseThreadedFeature_;
      }

      return *this;
    }

    ThreadedFeatureCopyType::
    ~ThreadedFeatureCopyType ()
    {
    }

    // ThreadedFeatureCastType
    //

    ThreadedFeatureCastType::
    ThreadedFeatureCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const ThreadedFeatureCastType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ThreadedFeatureCastType* ThreadedFeatureCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCastType (*this, f, c);
    }

    ThreadedFeatureCastType& ThreadedFeatureCastType::
    operator= (const ThreadedFeatureCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ThreadedFeatureCastType::
    ~ThreadedFeatureCastType ()
    {
    }

    // ThreadedFeatureTransformType
    //

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (this),
      Transformation_ (this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const BaseThreadedFeature_type& BaseThreadedFeature,
                                  const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, this),
      Transformation_ (Transformation, this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (::std::unique_ptr< BaseThreadedFeature_type > BaseThreadedFeature,
                                  ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (std::move (BaseThreadedFeature), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const ThreadedFeatureTransformType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseThreadedFeature_ (x.BaseThreadedFeature_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseThreadedFeature_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseThreadedFeature
        //
        if (n.name () == L"BaseThreadedFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseThreadedFeature_type > r (
            BaseThreadedFeature_traits::create (i, f, this));

          if (!BaseThreadedFeature_.present ())
          {
            this->BaseThreadedFeature_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseThreadedFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseThreadedFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ThreadedFeatureTransformType* ThreadedFeatureTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureTransformType (*this, f, c);
    }

    ThreadedFeatureTransformType& ThreadedFeatureTransformType::
    operator= (const ThreadedFeatureTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseThreadedFeature_ = x.BaseThreadedFeature_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ThreadedFeatureTransformType::
    ~ThreadedFeatureTransformType ()
    {
    }

    // ThreadedFeatureFromCylinderType
    //

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (this),
      Offset_ (this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const BaseCylinder_type& BaseCylinder)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this),
      Offset_ (this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (::std::unique_ptr< BaseCylinder_type > BaseCylinder)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseCylinder_ (std::move (BaseCylinder), this),
      Offset_ (this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const ThreadedFeatureFromCylinderType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (this),
      Offset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureFromCylinderType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseCylinder
        //
        if (n.name () == L"BaseCylinder" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (::std::move (r));
            continue;
          }
        }

        // Offset
        //
        if (n.name () == L"Offset" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseCylinder",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ThreadedFeatureFromCylinderType* ThreadedFeatureFromCylinderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureFromCylinderType (*this, f, c);
    }

    ThreadedFeatureFromCylinderType& ThreadedFeatureFromCylinderType::
    operator= (const ThreadedFeatureFromCylinderType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylinder_ = x.BaseCylinder_;
        this->Offset_ = x.Offset_;
      }

      return *this;
    }

    ThreadedFeatureFromCylinderType::
    ~ThreadedFeatureFromCylinderType ()
    {
    }

    // ThreadedFeatureCheckedType
    //

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType (const ThreadedFeatureCheckedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureCheckedType* ThreadedFeatureCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCheckedType (*this, f, c);
    }

    ThreadedFeatureCheckedType& ThreadedFeatureCheckedType::
    operator= (const ThreadedFeatureCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ThreadedFeatureCheckedType::
    ~ThreadedFeatureCheckedType ()
    {
    }

    // ThreadedFeatureCheckedFeatureType
    //

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType (const ThreadedFeatureCheckedFeatureType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureCheckedFeatureType* ThreadedFeatureCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCheckedFeatureType (*this, f, c);
    }

    ThreadedFeatureCheckedFeatureType& ThreadedFeatureCheckedFeatureType::
    operator= (const ThreadedFeatureCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ThreadedFeatureCheckedFeatureType::
    ~ThreadedFeatureCheckedFeatureType ()
    {
    }

    // ThreadedFeatureMeasurementDeterminationType
    //

    ThreadedFeatureMeasurementDeterminationType::
    ThreadedFeatureMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ThreadedFeatureMeasurementDeterminationType::
    ThreadedFeatureMeasurementDeterminationType (const ThreadedFeatureMeasurementDeterminationType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ThreadedFeatureMeasurementDeterminationType::
    ThreadedFeatureMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureMeasurementDeterminationType* ThreadedFeatureMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureMeasurementDeterminationType (*this, f, c);
    }

    ThreadedFeatureMeasurementDeterminationType& ThreadedFeatureMeasurementDeterminationType::
    operator= (const ThreadedFeatureMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ThreadedFeatureMeasurementDeterminationType::
    ~ThreadedFeatureMeasurementDeterminationType ()
    {
    }

    // ThreadedFeatureItemType
    //

    ThreadedFeatureItemType::
    ThreadedFeatureItemType ()
    : ::xsd::qif30::SpecifiedFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const id_type& id,
                             const FeatureNominalId_type& FeatureNominalId,
                             const FeatureName_type& FeatureName,
                             const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SpecifiedFeatureItemBaseType (id,
                                                  FeatureNominalId,
                                                  FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const id_type& id,
                             ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                             const FeatureName_type& FeatureName,
                             ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SpecifiedFeatureItemBaseType (id,
                                                  std::move (FeatureNominalId),
                                                  FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const ThreadedFeatureItemType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ThreadedFeatureItemType* ThreadedFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureItemType (*this, f, c);
    }

    ThreadedFeatureItemType& ThreadedFeatureItemType::
    operator= (const ThreadedFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    ThreadedFeatureItemType::
    ~ThreadedFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ThreadedFeatureItemType >
    _xsd_ThreadedFeatureItemType_type_factory_init (
      L"ThreadedFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // ThreadedFeatureDefinitionType
    //

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType ()
    : ::xsd::qif30::SpecifiedFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      ThreadSpecificationId_ (this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   const ThreadSpecificationId_type& ThreadSpecificationId)
    : ::xsd::qif30::SpecifiedFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      ThreadSpecificationId_ (ThreadSpecificationId, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   ::std::unique_ptr< ThreadSpecificationId_type > ThreadSpecificationId)
    : ::xsd::qif30::SpecifiedFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      ThreadSpecificationId_ (std::move (ThreadSpecificationId), this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const ThreadedFeatureDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      ThreadSpecificationId_ (x.ThreadSpecificationId_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      ThreadSpecificationId_ (this),
      Length_ (this),
      Bottom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // ThreadSpecificationId
        //
        if (n.name () == L"ThreadSpecificationId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ThreadSpecificationId_type > r (
            ThreadSpecificationId_traits::create (i, f, this));

          if (!ThreadSpecificationId_.present ())
          {
            this->ThreadSpecificationId_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == L"Bottom" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!ThreadSpecificationId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ThreadSpecificationId",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ThreadedFeatureDefinitionType* ThreadedFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureDefinitionType (*this, f, c);
    }

    ThreadedFeatureDefinitionType& ThreadedFeatureDefinitionType::
    operator= (const ThreadedFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->ThreadSpecificationId_ = x.ThreadSpecificationId_;
        this->Length_ = x.Length_;
        this->Bottom_ = x.Bottom_;
      }

      return *this;
    }

    ThreadedFeatureDefinitionType::
    ~ThreadedFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ThreadedFeatureDefinitionType >
    _xsd_ThreadedFeatureDefinitionType_type_factory_init (
      L"ThreadedFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // ThreadedFeatureNominalType
    //

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType ()
    : ::xsd::qif30::SpecifiedFeatureNominalBaseType (),
      Axis_ (this),
      Constructed_ (this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                const Axis_type& Axis)
    : ::xsd::qif30::SpecifiedFeatureNominalBaseType (id,
                                                     FeatureDefinitionId),
      Axis_ (Axis, this),
      Constructed_ (this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const id_type& id,
                                ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                ::std::unique_ptr< Axis_type > Axis)
    : ::xsd::qif30::SpecifiedFeatureNominalBaseType (id,
                                                     std::move (FeatureDefinitionId)),
      Axis_ (std::move (Axis), this),
      Constructed_ (this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const ThreadedFeatureNominalType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedFeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Axis",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ThreadedFeatureNominalType* ThreadedFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureNominalType (*this, f, c);
    }

    ThreadedFeatureNominalType& ThreadedFeatureNominalType::
    operator= (const ThreadedFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedFeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ThreadedFeatureNominalType::
    ~ThreadedFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ThreadedFeatureNominalType >
    _xsd_ThreadedFeatureNominalType_type_factory_init (
      L"ThreadedFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // ThreadedFeatureMeasurementType
    //

    ThreadedFeatureMeasurementType::
    ThreadedFeatureMeasurementType ()
    : ::xsd::qif30::SpecifiedFeatureMeasurementBaseType (),
      Axis_ (this),
      PitchDiameter_ (this),
      FunctionalSize_ (this),
      Length_ (this)
    {
    }

    ThreadedFeatureMeasurementType::
    ThreadedFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SpecifiedFeatureMeasurementBaseType (id),
      Axis_ (this),
      PitchDiameter_ (this),
      FunctionalSize_ (this),
      Length_ (this)
    {
    }

    ThreadedFeatureMeasurementType::
    ThreadedFeatureMeasurementType (const ThreadedFeatureMeasurementType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedFeatureMeasurementBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      PitchDiameter_ (x.PitchDiameter_, f, this),
      FunctionalSize_ (x.FunctionalSize_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    ThreadedFeatureMeasurementType::
    ThreadedFeatureMeasurementType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      PitchDiameter_ (this),
      FunctionalSize_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Axis
        //
        if (n.name () == L"Axis" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (::std::move (r));
            continue;
          }
        }

        // PitchDiameter
        //
        if (n.name () == L"PitchDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PitchDiameter_type > r (
            PitchDiameter_traits::create (i, f, this));

          if (!this->PitchDiameter_)
          {
            this->PitchDiameter_.set (::std::move (r));
            continue;
          }
        }

        // FunctionalSize
        //
        if (n.name () == L"FunctionalSize" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FunctionalSize_type > r (
            FunctionalSize_traits::create (i, f, this));

          if (!this->FunctionalSize_)
          {
            this->FunctionalSize_.set (::std::move (r));
            continue;
          }
        }

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureMeasurementType* ThreadedFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureMeasurementType (*this, f, c);
    }

    ThreadedFeatureMeasurementType& ThreadedFeatureMeasurementType::
    operator= (const ThreadedFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedFeatureMeasurementBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->PitchDiameter_ = x.PitchDiameter_;
        this->FunctionalSize_ = x.FunctionalSize_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    ThreadedFeatureMeasurementType::
    ~ThreadedFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ThreadedFeatureMeasurementType >
    _xsd_ThreadedFeatureMeasurementType_type_factory_init (
      L"ThreadedFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // ToroidalSegmentConstructionMethodType
    //

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType (const ToroidalSegmentConstructionMethodType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentConstructionMethodType* ToroidalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentConstructionMethodType (*this, f, c);
    }

    ToroidalSegmentConstructionMethodType& ToroidalSegmentConstructionMethodType::
    operator= (const ToroidalSegmentConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ToroidalSegmentConstructionMethodType::
    ~ToroidalSegmentConstructionMethodType ()
    {
    }

    // ToroidalSegmentBestFitType
    //

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType (const ToroidalSegmentBestFitType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ToroidalSegmentBestFitType* ToroidalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentBestFitType (*this, f, c);
    }

    ToroidalSegmentBestFitType& ToroidalSegmentBestFitType::
    operator= (const ToroidalSegmentBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ToroidalSegmentBestFitType::
    ~ToroidalSegmentBestFitType ()
    {
    }

    // ToroidalSegmentRecompType
    //

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const ToroidalSegmentRecompType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToroidalSegmentRecompType* ToroidalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentRecompType (*this, f, c);
    }

    ToroidalSegmentRecompType& ToroidalSegmentRecompType::
    operator= (const ToroidalSegmentRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ToroidalSegmentRecompType::
    ~ToroidalSegmentRecompType ()
    {
    }

    // ToroidalSegmentCopyType
    //

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const BaseToroidalSegment_type& BaseToroidalSegment)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (::std::unique_ptr< BaseToroidalSegment_type > BaseToroidalSegment)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (std::move (BaseToroidalSegment), this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const ToroidalSegmentCopyType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseToroidalSegment_ (x.BaseToroidalSegment_, f, this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseToroidalSegment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseToroidalSegment
        //
        if (n.name () == L"BaseToroidalSegment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseToroidalSegment_type > r (
            BaseToroidalSegment_traits::create (i, f, this));

          if (!BaseToroidalSegment_.present ())
          {
            this->BaseToroidalSegment_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseToroidalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseToroidalSegment",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToroidalSegmentCopyType* ToroidalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCopyType (*this, f, c);
    }

    ToroidalSegmentCopyType& ToroidalSegmentCopyType::
    operator= (const ToroidalSegmentCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseToroidalSegment_ = x.BaseToroidalSegment_;
      }

      return *this;
    }

    ToroidalSegmentCopyType::
    ~ToroidalSegmentCopyType ()
    {
    }

    // ToroidalSegmentCastType
    //

    ToroidalSegmentCastType::
    ToroidalSegmentCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const ToroidalSegmentCastType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToroidalSegmentCastType* ToroidalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCastType (*this, f, c);
    }

    ToroidalSegmentCastType& ToroidalSegmentCastType::
    operator= (const ToroidalSegmentCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ToroidalSegmentCastType::
    ~ToroidalSegmentCastType ()
    {
    }

    // ToroidalSegmentTransformType
    //

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (this),
      Transformation_ (this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const BaseToroidalSegment_type& BaseToroidalSegment,
                                  const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (::std::unique_ptr< BaseToroidalSegment_type > BaseToroidalSegment,
                                  ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (std::move (BaseToroidalSegment), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const ToroidalSegmentTransformType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseToroidalSegment_ (x.BaseToroidalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseToroidalSegment_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseToroidalSegment
        //
        if (n.name () == L"BaseToroidalSegment" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseToroidalSegment_type > r (
            BaseToroidalSegment_traits::create (i, f, this));

          if (!BaseToroidalSegment_.present ())
          {
            this->BaseToroidalSegment_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseToroidalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseToroidalSegment",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToroidalSegmentTransformType* ToroidalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentTransformType (*this, f, c);
    }

    ToroidalSegmentTransformType& ToroidalSegmentTransformType::
    operator= (const ToroidalSegmentTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseToroidalSegment_ = x.BaseToroidalSegment_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ToroidalSegmentTransformType::
    ~ToroidalSegmentTransformType ()
    {
    }

    // ToroidalSegmentCheckedType
    //

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType (const ToroidalSegmentCheckedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentCheckedType* ToroidalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCheckedType (*this, f, c);
    }

    ToroidalSegmentCheckedType& ToroidalSegmentCheckedType::
    operator= (const ToroidalSegmentCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ToroidalSegmentCheckedType::
    ~ToroidalSegmentCheckedType ()
    {
    }

    // ToroidalSegmentCheckedFeatureType
    //

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType (const ToroidalSegmentCheckedFeatureType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentCheckedFeatureType* ToroidalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCheckedFeatureType (*this, f, c);
    }

    ToroidalSegmentCheckedFeatureType& ToroidalSegmentCheckedFeatureType::
    operator= (const ToroidalSegmentCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ToroidalSegmentCheckedFeatureType::
    ~ToroidalSegmentCheckedFeatureType ()
    {
    }

    // ToroidalSegmentMeasurementDeterminationType
    //

    ToroidalSegmentMeasurementDeterminationType::
    ToroidalSegmentMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ToroidalSegmentMeasurementDeterminationType::
    ToroidalSegmentMeasurementDeterminationType (const ToroidalSegmentMeasurementDeterminationType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ToroidalSegmentMeasurementDeterminationType::
    ToroidalSegmentMeasurementDeterminationType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentMeasurementDeterminationType* ToroidalSegmentMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentMeasurementDeterminationType (*this, f, c);
    }

    ToroidalSegmentMeasurementDeterminationType& ToroidalSegmentMeasurementDeterminationType::
    operator= (const ToroidalSegmentMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ToroidalSegmentMeasurementDeterminationType::
    ~ToroidalSegmentMeasurementDeterminationType ()
    {
    }

    // ToroidalSegmentFeatureItemType
    //

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const id_type& id,
                                    const FeatureNominalId_type& FeatureNominalId,
                                    const FeatureName_type& FeatureName,
                                    const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const id_type& id,
                                    ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                    const FeatureName_type& FeatureName,
                                    ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const ToroidalSegmentFeatureItemType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToroidalSegmentFeatureItemType* ToroidalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureItemType (*this, f, c);
    }

    ToroidalSegmentFeatureItemType& ToroidalSegmentFeatureItemType::
    operator= (const ToroidalSegmentFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    ToroidalSegmentFeatureItemType::
    ~ToroidalSegmentFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToroidalSegmentFeatureItemType >
    _xsd_ToroidalSegmentFeatureItemType_type_factory_init (
      L"ToroidalSegmentFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // ToroidalSegmentFeatureDefinitionType
    //

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const id_type& id,
                                          const InternalExternal_type& InternalExternal,
                                          const MinorDiameter_type& MinorDiameter,
                                          const MajorDiameter_type& MajorDiameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MinorDiameter_ (MinorDiameter, this),
      MajorDiameter_ (MajorDiameter, this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const id_type& id,
                                          const InternalExternal_type& InternalExternal,
                                          ::std::unique_ptr< MinorDiameter_type > MinorDiameter,
                                          ::std::unique_ptr< MajorDiameter_type > MajorDiameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MinorDiameter_ (std::move (MinorDiameter), this),
      MajorDiameter_ (std::move (MajorDiameter), this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const ToroidalSegmentFeatureDefinitionType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == L"MinorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == L"MajorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinorDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MajorDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToroidalSegmentFeatureDefinitionType* ToroidalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureDefinitionType (*this, f, c);
    }

    ToroidalSegmentFeatureDefinitionType& ToroidalSegmentFeatureDefinitionType::
    operator= (const ToroidalSegmentFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->MajorDiameter_ = x.MajorDiameter_;
      }

      return *this;
    }

    ToroidalSegmentFeatureDefinitionType::
    ~ToroidalSegmentFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToroidalSegmentFeatureDefinitionType >
    _xsd_ToroidalSegmentFeatureDefinitionType_type_factory_init (
      L"ToroidalSegmentFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // ToroidalSegmentFeatureNominalType
    //

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Location_ (this),
      AxisVector_ (this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const id_type& id,
                                       const FeatureDefinitionId_type& FeatureDefinitionId,
                                       const Location_type& Location,
                                       const AxisVector_type& AxisVector,
                                       const LatitudeLongitudeSweep_type& LatitudeLongitudeSweep)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Location_ (Location, this),
      AxisVector_ (AxisVector, this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, this),
      Constructed_ (this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const id_type& id,
                                       ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                       ::std::unique_ptr< Location_type > Location,
                                       ::std::unique_ptr< AxisVector_type > AxisVector,
                                       ::std::unique_ptr< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      AxisVector_ (std::move (AxisVector), this),
      LatitudeLongitudeSweep_ (std::move (LatitudeLongitudeSweep), this),
      Constructed_ (this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const ToroidalSegmentFeatureNominalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      AxisVector_ (this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == L"AxisVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!AxisVector_.present ())
          {
            this->AxisVector_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == L"LatitudeLongitudeSweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!LatitudeLongitudeSweep_.present ())
          {
            this->LatitudeLongitudeSweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!AxisVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AxisVector",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!LatitudeLongitudeSweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LatitudeLongitudeSweep",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ToroidalSegmentFeatureNominalType* ToroidalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureNominalType (*this, f, c);
    }

    ToroidalSegmentFeatureNominalType& ToroidalSegmentFeatureNominalType::
    operator= (const ToroidalSegmentFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->AxisVector_ = x.AxisVector_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ToroidalSegmentFeatureNominalType::
    ~ToroidalSegmentFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToroidalSegmentFeatureNominalType >
    _xsd_ToroidalSegmentFeatureNominalType_type_factory_init (
      L"ToroidalSegmentFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // ToroidalSegmentFeatureMeasurementType
    //

    ToroidalSegmentFeatureMeasurementType::
    ToroidalSegmentFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
    }

    ToroidalSegmentFeatureMeasurementType::
    ToroidalSegmentFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
    }

    ToroidalSegmentFeatureMeasurementType::
    ToroidalSegmentFeatureMeasurementType (const ToroidalSegmentFeatureMeasurementType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      LatitudeLongitudeSweepMeasurementRange_ (x.LatitudeLongitudeSweepMeasurementRange_, f, this),
      LatitudeLongitudeSweepFull_ (x.LatitudeLongitudeSweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ToroidalSegmentFeatureMeasurementType::
    ToroidalSegmentFeatureMeasurementType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == L"AxisVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!this->AxisVector_)
          {
            this->AxisVector_.set (::std::move (r));
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == L"MinorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == L"MajorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweepMeasurementRange
        //
        if (n.name () == L"LatitudeLongitudeSweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > r (
            LatitudeLongitudeSweepMeasurementRange_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweepMeasurementRange_)
          {
            this->LatitudeLongitudeSweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweepFull
        //
        if (n.name () == L"LatitudeLongitudeSweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweepFull_type > r (
            LatitudeLongitudeSweepFull_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweepFull_)
          {
            this->LatitudeLongitudeSweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentFeatureMeasurementType* ToroidalSegmentFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureMeasurementType (*this, f, c);
    }

    ToroidalSegmentFeatureMeasurementType& ToroidalSegmentFeatureMeasurementType::
    operator= (const ToroidalSegmentFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->AxisVector_ = x.AxisVector_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->LatitudeLongitudeSweepMeasurementRange_ = x.LatitudeLongitudeSweepMeasurementRange_;
        this->LatitudeLongitudeSweepFull_ = x.LatitudeLongitudeSweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ToroidalSegmentFeatureMeasurementType::
    ~ToroidalSegmentFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ToroidalSegmentFeatureMeasurementType >
    _xsd_ToroidalSegmentFeatureMeasurementType_type_factory_init (
      L"ToroidalSegmentFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // TorusConstructionMethodType
    //

    TorusConstructionMethodType::
    TorusConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    TorusConstructionMethodType::
    TorusConstructionMethodType (const TorusConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    TorusConstructionMethodType::
    TorusConstructionMethodType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BestFit
        //
        if (n.name () == L"BestFit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (::std::move (r));
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == L"Recompensated" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (::std::move (r));
            continue;
          }
        }

        // Copy
        //
        if (n.name () == L"Copy" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (::std::move (r));
            continue;
          }
        }

        // Cast
        //
        if (n.name () == L"Cast" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == L"FromScan" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TorusConstructionMethodType* TorusConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusConstructionMethodType (*this, f, c);
    }

    TorusConstructionMethodType& TorusConstructionMethodType::
    operator= (const TorusConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    TorusConstructionMethodType::
    ~TorusConstructionMethodType ()
    {
    }

    // TorusBestFitType
    //

    TorusBestFitType::
    TorusBestFitType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (this)
    {
    }

    TorusBestFitType::
    TorusBestFitType (const n_type& n)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this),
      n_ (n, this)
    {
    }

    TorusBestFitType::
    TorusBestFitType (const TorusBestFitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      n_ (x.n_, f, this)
    {
    }

    TorusBestFitType::
    TorusBestFitType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusBestFitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    TorusBestFitType* TorusBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusBestFitType (*this, f, c);
    }

    TorusBestFitType& TorusBestFitType::
    operator= (const TorusBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->n_ = x.n_;
      }

      return *this;
    }

    TorusBestFitType::
    ~TorusBestFitType ()
    {
    }

    // TorusRecompType
    //

    TorusRecompType::
    TorusRecompType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (this)
    {
    }

    TorusRecompType::
    TorusRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    TorusRecompType::
    TorusRecompType (::std::unique_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (std::move (BaseFeaturePointList), this)
    {
    }

    TorusRecompType::
    TorusRecompType (const TorusRecompType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    TorusRecompType::
    TorusRecompType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusRecompType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeaturePointList
        //
        if (n.name () == L"BaseFeaturePointList" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeaturePointList",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TorusRecompType* TorusRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusRecompType (*this, f, c);
    }

    TorusRecompType& TorusRecompType::
    operator= (const TorusRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    TorusRecompType::
    ~TorusRecompType ()
    {
    }

    // TorusCopyType
    //

    TorusCopyType::
    TorusCopyType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseTorus_ (this)
    {
    }

    TorusCopyType::
    TorusCopyType (const BaseTorus_type& BaseTorus)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, this)
    {
    }

    TorusCopyType::
    TorusCopyType (::std::unique_ptr< BaseTorus_type > BaseTorus)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseTorus_ (std::move (BaseTorus), this)
    {
    }

    TorusCopyType::
    TorusCopyType (const TorusCopyType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseTorus_ (x.BaseTorus_, f, this)
    {
    }

    TorusCopyType::
    TorusCopyType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseTorus_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusCopyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseTorus
        //
        if (n.name () == L"BaseTorus" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseTorus_type > r (
            BaseTorus_traits::create (i, f, this));

          if (!BaseTorus_.present ())
          {
            this->BaseTorus_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseTorus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseTorus",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TorusCopyType* TorusCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCopyType (*this, f, c);
    }

    TorusCopyType& TorusCopyType::
    operator= (const TorusCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseTorus_ = x.BaseTorus_;
      }

      return *this;
    }

    TorusCopyType::
    ~TorusCopyType ()
    {
    }

    // TorusCastType
    //

    TorusCastType::
    TorusCastType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    TorusCastType::
    TorusCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    TorusCastType::
    TorusCastType (::std::unique_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseFeature_ (std::move (BaseFeature), this)
    {
    }

    TorusCastType::
    TorusCastType (const TorusCastType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    TorusCastType::
    TorusCastType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusCastType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseFeature
        //
        if (n.name () == L"BaseFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseFeature",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TorusCastType* TorusCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCastType (*this, f, c);
    }

    TorusCastType& TorusCastType::
    operator= (const TorusCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    TorusCastType::
    ~TorusCastType ()
    {
    }

    // TorusTransformType
    //

    TorusTransformType::
    TorusTransformType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseTorus_ (this),
      Transformation_ (this)
    {
    }

    TorusTransformType::
    TorusTransformType (const BaseTorus_type& BaseTorus,
                        const Transformation_type& Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, this),
      Transformation_ (Transformation, this)
    {
    }

    TorusTransformType::
    TorusTransformType (::std::unique_ptr< BaseTorus_type > BaseTorus,
                        ::std::unique_ptr< Transformation_type > Transformation)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      BaseTorus_ (std::move (BaseTorus), this),
      Transformation_ (std::move (Transformation), this)
    {
    }

    TorusTransformType::
    TorusTransformType (const TorusTransformType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      BaseTorus_ (x.BaseTorus_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    TorusTransformType::
    TorusTransformType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseTorus_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseTorus
        //
        if (n.name () == L"BaseTorus" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BaseTorus_type > r (
            BaseTorus_traits::create (i, f, this));

          if (!BaseTorus_.present ())
          {
            this->BaseTorus_.set (::std::move (r));
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == L"Transformation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!BaseTorus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BaseTorus",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transformation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TorusTransformType* TorusTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusTransformType (*this, f, c);
    }

    TorusTransformType& TorusTransformType::
    operator= (const TorusTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->BaseTorus_ = x.BaseTorus_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    TorusTransformType::
    ~TorusTransformType ()
    {
    }

    // TorusFromScanType
    //

    TorusFromScanType::
    TorusFromScanType ()
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (const SurfaceFeature_type& SurfaceFeature,
                       const SearchRadius_type& SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (::std::unique_ptr< SurfaceFeature_type > SurfaceFeature,
                       ::std::unique_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif30::ConstructionMethodBaseType (),
      SurfaceFeature_ (std::move (SurfaceFeature), this),
      SearchRadius_ (std::move (SearchRadius), this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (const TorusFromScanType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusFromScanType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SurfaceFeature
        //
        if (n.name () == L"SurfaceFeature" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (::std::move (r));
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == L"SearchRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SurfaceFeature",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SearchRadius",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TorusFromScanType* TorusFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFromScanType (*this, f, c);
    }

    TorusFromScanType& TorusFromScanType::
    operator= (const TorusFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    TorusFromScanType::
    ~TorusFromScanType ()
    {
    }

    // TorusCheckedType
    //

    TorusCheckedType::
    TorusCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    TorusCheckedType::
    TorusCheckedType (const TorusCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    TorusCheckedType::
    TorusCheckedType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusCheckedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Measured
        //
        if (n.name () == L"Measured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TorusCheckedType* TorusCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCheckedType (*this, f, c);
    }

    TorusCheckedType& TorusCheckedType::
    operator= (const TorusCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    TorusCheckedType::
    ~TorusCheckedType ()
    {
    }

    // TorusCheckedFeatureType
    //

    TorusCheckedFeatureType::
    TorusCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    TorusCheckedFeatureType::
    TorusCheckedFeatureType (const TorusCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    TorusCheckedFeatureType::
    TorusCheckedFeatureType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CheckDetails
        //
        if (n.name () == L"CheckDetails" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TorusCheckedFeatureType* TorusCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCheckedFeatureType (*this, f, c);
    }

    TorusCheckedFeatureType& TorusCheckedFeatureType::
    operator= (const TorusCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    TorusCheckedFeatureType::
    ~TorusCheckedFeatureType ()
    {
    }

    // TorusMeasurementDeterminationType
    //

    TorusMeasurementDeterminationType::
    TorusMeasurementDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    TorusMeasurementDeterminationType::
    TorusMeasurementDeterminationType (const TorusMeasurementDeterminationType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    TorusMeasurementDeterminationType::
    TorusMeasurementDeterminationType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusMeasurementDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Checked
        //
        if (n.name () == L"Checked" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (::std::move (r));
            continue;
          }
        }

        // Set
        //
        if (n.name () == L"Set" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TorusMeasurementDeterminationType* TorusMeasurementDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusMeasurementDeterminationType (*this, f, c);
    }

    TorusMeasurementDeterminationType& TorusMeasurementDeterminationType::
    operator= (const TorusMeasurementDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    TorusMeasurementDeterminationType::
    ~TorusMeasurementDeterminationType ()
    {
    }

    // TorusFeatureItemType
    //

    TorusFeatureItemType::
    TorusFeatureItemType ()
    : ::xsd::qif30::SurfaceFeatureItemBaseType (),
      DeterminationMode_ (this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const id_type& id,
                          const FeatureNominalId_type& FeatureNominalId,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const id_type& id,
                          ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                          const FeatureName_type& FeatureName,
                          ::std::unique_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName),
      DeterminationMode_ (std::move (DeterminationMode), this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const TorusFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DeterminationMode
        //
        if (n.name () == L"DeterminationMode" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DeterminationMode",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TorusFeatureItemType* TorusFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureItemType (*this, f, c);
    }

    TorusFeatureItemType& TorusFeatureItemType::
    operator= (const TorusFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    TorusFeatureItemType::
    ~TorusFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TorusFeatureItemType >
    _xsd_TorusFeatureItemType_type_factory_init (
      L"TorusFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // TorusFeatureDefinitionType
    //

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType ()
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (),
      InternalExternal_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const id_type& id,
                                const InternalExternal_type& InternalExternal,
                                const MinorDiameter_type& MinorDiameter,
                                const MajorDiameter_type& MajorDiameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MinorDiameter_ (MinorDiameter, this),
      MajorDiameter_ (MajorDiameter, this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const id_type& id,
                                const InternalExternal_type& InternalExternal,
                                ::std::unique_ptr< MinorDiameter_type > MinorDiameter,
                                ::std::unique_ptr< MajorDiameter_type > MajorDiameter)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MinorDiameter_ (std::move (MinorDiameter), this),
      MajorDiameter_ (std::move (MajorDiameter), this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const TorusFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // InternalExternal
        //
        if (n.name () == L"InternalExternal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (::std::move (r));
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == L"MinorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == L"MajorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"InternalExternal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MinorDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"MajorDiameter",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TorusFeatureDefinitionType* TorusFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureDefinitionType (*this, f, c);
    }

    TorusFeatureDefinitionType& TorusFeatureDefinitionType::
    operator= (const TorusFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->MajorDiameter_ = x.MajorDiameter_;
      }

      return *this;
    }

    TorusFeatureDefinitionType::
    ~TorusFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TorusFeatureDefinitionType >
    _xsd_TorusFeatureDefinitionType_type_factory_init (
      L"TorusFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // TorusFeatureNominalType
    //

    TorusFeatureNominalType::
    TorusFeatureNominalType ()
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (),
      Location_ (this),
      AxisVector_ (this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location,
                             const AxisVector_type& AxisVector)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   FeatureDefinitionId),
      Location_ (Location, this),
      AxisVector_ (AxisVector, this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const id_type& id,
                             ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                             ::std::unique_ptr< Location_type > Location,
                             ::std::unique_ptr< AxisVector_type > AxisVector)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId)),
      Location_ (std::move (Location), this),
      AxisVector_ (std::move (AxisVector), this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const TorusFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      AxisVector_ (this),
      LatitudeLongitudeSweep_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == L"AxisVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!AxisVector_.present ())
          {
            this->AxisVector_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == L"LatitudeLongitudeSweep" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (::std::move (r));
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == L"Constructed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Location",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!AxisVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AxisVector",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TorusFeatureNominalType* TorusFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureNominalType (*this, f, c);
    }

    TorusFeatureNominalType& TorusFeatureNominalType::
    operator= (const TorusFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->AxisVector_ = x.AxisVector_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    TorusFeatureNominalType::
    ~TorusFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TorusFeatureNominalType >
    _xsd_TorusFeatureNominalType_type_factory_init (
      L"TorusFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // TorusFeatureMeasurementType
    //

    TorusFeatureMeasurementType::
    TorusFeatureMeasurementType ()
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
    }

    TorusFeatureMeasurementType::
    TorusFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (id),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
    }

    TorusFeatureMeasurementType::
    TorusFeatureMeasurementType (const TorusFeatureMeasurementType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      LatitudeLongitudeSweepMeasurementRange_ (x.LatitudeLongitudeSweepMeasurementRange_, f, this),
      LatitudeLongitudeSweepFull_ (x.LatitudeLongitudeSweepFull_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    TorusFeatureMeasurementType::
    TorusFeatureMeasurementType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::SurfaceFeatureMeasurementBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweepMeasurementRange_ (this),
      LatitudeLongitudeSweepFull_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureMeasurementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SurfaceFeatureMeasurementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Location
        //
        if (n.name () == L"Location" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (::std::move (r));
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == L"AxisVector" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!this->AxisVector_)
          {
            this->AxisVector_.set (::std::move (r));
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == L"MinorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == L"MajorDiameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweepMeasurementRange
        //
        if (n.name () == L"LatitudeLongitudeSweepMeasurementRange" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweepMeasurementRange_type > r (
            LatitudeLongitudeSweepMeasurementRange_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweepMeasurementRange_)
          {
            this->LatitudeLongitudeSweepMeasurementRange_.set (::std::move (r));
            continue;
          }
        }

        // LatitudeLongitudeSweepFull
        //
        if (n.name () == L"LatitudeLongitudeSweepFull" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LatitudeLongitudeSweepFull_type > r (
            LatitudeLongitudeSweepFull_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweepFull_)
          {
            this->LatitudeLongitudeSweepFull_.set (::std::move (r));
            continue;
          }
        }

        // Form
        //
        if (n.name () == L"Form" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TorusFeatureMeasurementType* TorusFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureMeasurementType (*this, f, c);
    }

    TorusFeatureMeasurementType& TorusFeatureMeasurementType::
    operator= (const TorusFeatureMeasurementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->AxisVector_ = x.AxisVector_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->LatitudeLongitudeSweepMeasurementRange_ = x.LatitudeLongitudeSweepMeasurementRange_;
        this->LatitudeLongitudeSweepFull_ = x.LatitudeLongitudeSweepFull_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    TorusFeatureMeasurementType::
    ~TorusFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TorusFeatureMeasurementType >
    _xsd_TorusFeatureMeasurementType_type_factory_init (
      L"TorusFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // GroupFeatureItemType
    //

    GroupFeatureItemType::
    GroupFeatureItemType ()
    : ::xsd::qif30::ShapeFeatureItemBaseType ()
    {
    }

    GroupFeatureItemType::
    GroupFeatureItemType (const id_type& id,
                          const FeatureNominalId_type& FeatureNominalId,
                          const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              FeatureNominalId,
                                              FeatureName)
    {
    }

    GroupFeatureItemType::
    GroupFeatureItemType (const id_type& id,
                          ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                          const FeatureName_type& FeatureName)
    : ::xsd::qif30::ShapeFeatureItemBaseType (id,
                                              std::move (FeatureNominalId),
                                              FeatureName)
    {
    }

    GroupFeatureItemType::
    GroupFeatureItemType (const GroupFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (x, f, c)
    {
    }

    GroupFeatureItemType::
    GroupFeatureItemType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureItemBaseType (e, f, c)
    {
    }

    GroupFeatureItemType* GroupFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GroupFeatureItemType (*this, f, c);
    }

    GroupFeatureItemType::
    ~GroupFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GroupFeatureItemType >
    _xsd_GroupFeatureItemType_type_factory_init (
      L"GroupFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");

    // GroupFeatureDefinitionType
    //

    GroupFeatureDefinitionType::
    GroupFeatureDefinitionType ()
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (),
      IsProfileGroup_ (this),
      IsRunoutGroup_ (this),
      IsCountersunkHole_ (this),
      IsCounterboredHole_ (this),
      IsSpotface_ (this)
    {
    }

    GroupFeatureDefinitionType::
    GroupFeatureDefinitionType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (id),
      IsProfileGroup_ (this),
      IsRunoutGroup_ (this),
      IsCountersunkHole_ (this),
      IsCounterboredHole_ (this),
      IsSpotface_ (this)
    {
    }

    GroupFeatureDefinitionType::
    GroupFeatureDefinitionType (const GroupFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (x, f, c),
      IsProfileGroup_ (x.IsProfileGroup_, f, this),
      IsRunoutGroup_ (x.IsRunoutGroup_, f, this),
      IsCountersunkHole_ (x.IsCountersunkHole_, f, this),
      IsCounterboredHole_ (x.IsCounterboredHole_, f, this),
      IsSpotface_ (x.IsSpotface_, f, this)
    {
    }

    GroupFeatureDefinitionType::
    GroupFeatureDefinitionType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      IsProfileGroup_ (this),
      IsRunoutGroup_ (this),
      IsCountersunkHole_ (this),
      IsCounterboredHole_ (this),
      IsSpotface_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GroupFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ShapeFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IsProfileGroup
        //
        if (n.name () == L"IsProfileGroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->IsProfileGroup_)
          {
            this->IsProfileGroup_.set (IsProfileGroup_traits::create (i, f, this));
            continue;
          }
        }

        // IsRunoutGroup
        //
        if (n.name () == L"IsRunoutGroup" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->IsRunoutGroup_)
          {
            this->IsRunoutGroup_.set (IsRunoutGroup_traits::create (i, f, this));
            continue;
          }
        }

        // IsCountersunkHole
        //
        if (n.name () == L"IsCountersunkHole" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->IsCountersunkHole_)
          {
            this->IsCountersunkHole_.set (IsCountersunkHole_traits::create (i, f, this));
            continue;
          }
        }

        // IsCounterboredHole
        //
        if (n.name () == L"IsCounterboredHole" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->IsCounterboredHole_)
          {
            this->IsCounterboredHole_.set (IsCounterboredHole_traits::create (i, f, this));
            continue;
          }
        }

        // IsSpotface
        //
        if (n.name () == L"IsSpotface" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->IsSpotface_)
          {
            this->IsSpotface_.set (IsSpotface_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    GroupFeatureDefinitionType* GroupFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GroupFeatureDefinitionType (*this, f, c);
    }

    GroupFeatureDefinitionType& GroupFeatureDefinitionType::
    operator= (const GroupFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ShapeFeatureDefinitionBaseType& > (*this) = x;
        this->IsProfileGroup_ = x.IsProfileGroup_;
        this->IsRunoutGroup_ = x.IsRunoutGroup_;
        this->IsCountersunkHole_ = x.IsCountersunkHole_;
        this->IsCounterboredHole_ = x.IsCounterboredHole_;
        this->IsSpotface_ = x.IsSpotface_;
      }

      return *this;
    }

    GroupFeatureDefinitionType::
    ~GroupFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GroupFeatureDefinitionType >
    _xsd_GroupFeatureDefinitionType_type_factory_init (
      L"GroupFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // GroupFeatureNominalType
    //

    GroupFeatureNominalType::
    GroupFeatureNominalType ()
    : ::xsd::qif30::ShapeFeatureNominalBaseType (),
      FeatureNominalIds_ (this)
    {
    }

    GroupFeatureNominalType::
    GroupFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 FeatureDefinitionId),
      FeatureNominalIds_ (FeatureNominalIds, this)
    {
    }

    GroupFeatureNominalType::
    GroupFeatureNominalType (const id_type& id,
                             ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                             ::std::unique_ptr< FeatureNominalIds_type > FeatureNominalIds)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (id,
                                                 std::move (FeatureDefinitionId)),
      FeatureNominalIds_ (std::move (FeatureNominalIds), this)
    {
    }

    GroupFeatureNominalType::
    GroupFeatureNominalType (const GroupFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (x, f, c),
      FeatureNominalIds_ (x.FeatureNominalIds_, f, this)
    {
    }

    GroupFeatureNominalType::
    GroupFeatureNominalType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureNominalIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GroupFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::ShapeFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureNominalIds
        //
        if (n.name () == L"FeatureNominalIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureNominalIds_type > r (
            FeatureNominalIds_traits::create (i, f, this));

          if (!FeatureNominalIds_.present ())
          {
            this->FeatureNominalIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FeatureNominalIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FeatureNominalIds",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    GroupFeatureNominalType* GroupFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GroupFeatureNominalType (*this, f, c);
    }

    GroupFeatureNominalType& GroupFeatureNominalType::
    operator= (const GroupFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::ShapeFeatureNominalBaseType& > (*this) = x;
        this->FeatureNominalIds_ = x.FeatureNominalIds_;
      }

      return *this;
    }

    GroupFeatureNominalType::
    ~GroupFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GroupFeatureNominalType >
    _xsd_GroupFeatureNominalType_type_factory_init (
      L"GroupFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // GroupFeatureMeasurementType
    //

    GroupFeatureMeasurementType::
    GroupFeatureMeasurementType ()
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType ()
    {
    }

    GroupFeatureMeasurementType::
    GroupFeatureMeasurementType (const id_type& id)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (id)
    {
    }

    GroupFeatureMeasurementType::
    GroupFeatureMeasurementType (const GroupFeatureMeasurementType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (x, f, c)
    {
    }

    GroupFeatureMeasurementType::
    GroupFeatureMeasurementType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::ShapeFeatureMeasurementBaseType (e, f, c)
    {
    }

    GroupFeatureMeasurementType* GroupFeatureMeasurementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GroupFeatureMeasurementType (*this, f, c);
    }

    GroupFeatureMeasurementType::
    ~GroupFeatureMeasurementType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, GroupFeatureMeasurementType >
    _xsd_GroupFeatureMeasurementType_type_factory_init (
      L"GroupFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureItemBaseType
    //

    PatternFeatureItemBaseType::
    PatternFeatureItemBaseType ()
    : ::xsd::qif30::GroupFeatureItemType ()
    {
    }

    PatternFeatureItemBaseType::
    PatternFeatureItemBaseType (const id_type& id,
                                const FeatureNominalId_type& FeatureNominalId,
                                const FeatureName_type& FeatureName)
    : ::xsd::qif30::GroupFeatureItemType (id,
                                          FeatureNominalId,
                                          FeatureName)
    {
    }

    PatternFeatureItemBaseType::
    PatternFeatureItemBaseType (const id_type& id,
                                ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                const FeatureName_type& FeatureName)
    : ::xsd::qif30::GroupFeatureItemType (id,
                                          std::move (FeatureNominalId),
                                          FeatureName)
    {
    }

    PatternFeatureItemBaseType::
    PatternFeatureItemBaseType (const PatternFeatureItemBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::GroupFeatureItemType (x, f, c)
    {
    }

    PatternFeatureItemBaseType::
    PatternFeatureItemBaseType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::GroupFeatureItemType (e, f, c)
    {
    }

    PatternFeatureItemBaseType::
    ~PatternFeatureItemBaseType ()
    {
    }

    // PatternFeatureDefinitionBaseType
    //

    PatternFeatureDefinitionBaseType::
    PatternFeatureDefinitionBaseType ()
    : ::xsd::qif30::GroupFeatureDefinitionType ()
    {
    }

    PatternFeatureDefinitionBaseType::
    PatternFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif30::GroupFeatureDefinitionType (id)
    {
    }

    PatternFeatureDefinitionBaseType::
    PatternFeatureDefinitionBaseType (const PatternFeatureDefinitionBaseType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::GroupFeatureDefinitionType (x, f, c)
    {
    }

    PatternFeatureDefinitionBaseType::
    PatternFeatureDefinitionBaseType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::GroupFeatureDefinitionType (e, f, c)
    {
    }

    PatternFeatureDefinitionBaseType::
    ~PatternFeatureDefinitionBaseType ()
    {
    }

    // PatternFeatureNominalBaseType
    //

    PatternFeatureNominalBaseType::
    PatternFeatureNominalBaseType ()
    : ::xsd::qif30::GroupFeatureNominalType ()
    {
    }

    PatternFeatureNominalBaseType::
    PatternFeatureNominalBaseType (const id_type& id,
                                   const FeatureDefinitionId_type& FeatureDefinitionId,
                                   const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif30::GroupFeatureNominalType (id,
                                             FeatureDefinitionId,
                                             FeatureNominalIds)
    {
    }

    PatternFeatureNominalBaseType::
    PatternFeatureNominalBaseType (const id_type& id,
                                   ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                   ::std::unique_ptr< FeatureNominalIds_type > FeatureNominalIds)
    : ::xsd::qif30::GroupFeatureNominalType (id,
                                             std::move (FeatureDefinitionId),
                                             std::move (FeatureNominalIds))
    {
    }

    PatternFeatureNominalBaseType::
    PatternFeatureNominalBaseType (const PatternFeatureNominalBaseType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::GroupFeatureNominalType (x, f, c)
    {
    }

    PatternFeatureNominalBaseType::
    PatternFeatureNominalBaseType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::GroupFeatureNominalType (e, f, c)
    {
    }

    PatternFeatureNominalBaseType::
    ~PatternFeatureNominalBaseType ()
    {
    }

    // PatternFeatureLinearItemType
    //

    PatternFeatureLinearItemType::
    PatternFeatureLinearItemType ()
    : ::xsd::qif30::PatternFeatureItemBaseType ()
    {
    }

    PatternFeatureLinearItemType::
    PatternFeatureLinearItemType (const id_type& id,
                                  const FeatureNominalId_type& FeatureNominalId,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif30::PatternFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName)
    {
    }

    PatternFeatureLinearItemType::
    PatternFeatureLinearItemType (const id_type& id,
                                  ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif30::PatternFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName)
    {
    }

    PatternFeatureLinearItemType::
    PatternFeatureLinearItemType (const PatternFeatureLinearItemType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureItemBaseType (x, f, c)
    {
    }

    PatternFeatureLinearItemType::
    PatternFeatureLinearItemType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureItemBaseType (e, f, c)
    {
    }

    PatternFeatureLinearItemType* PatternFeatureLinearItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureLinearItemType (*this, f, c);
    }

    PatternFeatureLinearItemType::
    ~PatternFeatureLinearItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureLinearItemType >
    _xsd_PatternFeatureLinearItemType_type_factory_init (
      L"PatternFeatureLinearItemType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureLinearDefinitionType
    //

    PatternFeatureLinearDefinitionType::
    PatternFeatureLinearDefinitionType ()
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (),
      LineDirection_ (this),
      IncrementalDistance_ (this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (this)
    {
    }

    PatternFeatureLinearDefinitionType::
    PatternFeatureLinearDefinitionType (const id_type& id,
                                        const LineDirection_type& LineDirection,
                                        const IncrementalDistance_type& IncrementalDistance,
                                        const NumberOfFeatures_type& NumberOfFeatures)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (id),
      LineDirection_ (LineDirection, this),
      IncrementalDistance_ (IncrementalDistance, this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (NumberOfFeatures, this)
    {
    }

    PatternFeatureLinearDefinitionType::
    PatternFeatureLinearDefinitionType (const id_type& id,
                                        ::std::unique_ptr< LineDirection_type > LineDirection,
                                        ::std::unique_ptr< IncrementalDistance_type > IncrementalDistance,
                                        const NumberOfFeatures_type& NumberOfFeatures)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (id),
      LineDirection_ (std::move (LineDirection), this),
      IncrementalDistance_ (std::move (IncrementalDistance), this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (NumberOfFeatures, this)
    {
    }

    PatternFeatureLinearDefinitionType::
    PatternFeatureLinearDefinitionType (const PatternFeatureLinearDefinitionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (x, f, c),
      LineDirection_ (x.LineDirection_, f, this),
      IncrementalDistance_ (x.IncrementalDistance_, f, this),
      FeatureDirection_ (x.FeatureDirection_, f, this),
      NumberOfFeatures_ (x.NumberOfFeatures_, f, this)
    {
    }

    PatternFeatureLinearDefinitionType::
    PatternFeatureLinearDefinitionType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      LineDirection_ (this),
      IncrementalDistance_ (this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PatternFeatureLinearDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PatternFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LineDirection
        //
        if (n.name () == L"LineDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LineDirection_type > r (
            LineDirection_traits::create (i, f, this));

          if (!LineDirection_.present ())
          {
            this->LineDirection_.set (::std::move (r));
            continue;
          }
        }

        // IncrementalDistance
        //
        if (n.name () == L"IncrementalDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IncrementalDistance_type > r (
            IncrementalDistance_traits::create (i, f, this));

          if (!IncrementalDistance_.present ())
          {
            this->IncrementalDistance_.set (::std::move (r));
            continue;
          }
        }

        // FeatureDirection
        //
        if (n.name () == L"FeatureDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureDirection_type > r (
            FeatureDirection_traits::create (i, f, this));

          if (!this->FeatureDirection_)
          {
            this->FeatureDirection_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfFeatures
        //
        if (n.name () == L"NumberOfFeatures" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberOfFeatures_type > r (
            NumberOfFeatures_traits::create (i, f, this));

          if (!NumberOfFeatures_.present ())
          {
            this->NumberOfFeatures_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!LineDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"LineDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!IncrementalDistance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IncrementalDistance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfFeatures_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfFeatures",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PatternFeatureLinearDefinitionType* PatternFeatureLinearDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureLinearDefinitionType (*this, f, c);
    }

    PatternFeatureLinearDefinitionType& PatternFeatureLinearDefinitionType::
    operator= (const PatternFeatureLinearDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PatternFeatureDefinitionBaseType& > (*this) = x;
        this->LineDirection_ = x.LineDirection_;
        this->IncrementalDistance_ = x.IncrementalDistance_;
        this->FeatureDirection_ = x.FeatureDirection_;
        this->NumberOfFeatures_ = x.NumberOfFeatures_;
      }

      return *this;
    }

    PatternFeatureLinearDefinitionType::
    ~PatternFeatureLinearDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureLinearDefinitionType >
    _xsd_PatternFeatureLinearDefinitionType_type_factory_init (
      L"PatternFeatureLinearDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureLinearNominalType
    //

    PatternFeatureLinearNominalType::
    PatternFeatureLinearNominalType ()
    : ::xsd::qif30::PatternFeatureNominalBaseType (),
      FirstFeatureLocation_ (this)
    {
    }

    PatternFeatureLinearNominalType::
    PatternFeatureLinearNominalType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     const FeatureNominalIds_type& FeatureNominalIds,
                                     const FirstFeatureLocation_type& FirstFeatureLocation)
    : ::xsd::qif30::PatternFeatureNominalBaseType (id,
                                                   FeatureDefinitionId,
                                                   FeatureNominalIds),
      FirstFeatureLocation_ (FirstFeatureLocation, this)
    {
    }

    PatternFeatureLinearNominalType::
    PatternFeatureLinearNominalType (const id_type& id,
                                     ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                     ::std::unique_ptr< FeatureNominalIds_type > FeatureNominalIds,
                                     ::std::unique_ptr< FirstFeatureLocation_type > FirstFeatureLocation)
    : ::xsd::qif30::PatternFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId),
                                                   std::move (FeatureNominalIds)),
      FirstFeatureLocation_ (std::move (FirstFeatureLocation), this)
    {
    }

    PatternFeatureLinearNominalType::
    PatternFeatureLinearNominalType (const PatternFeatureLinearNominalType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureNominalBaseType (x, f, c),
      FirstFeatureLocation_ (x.FirstFeatureLocation_, f, this)
    {
    }

    PatternFeatureLinearNominalType::
    PatternFeatureLinearNominalType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      FirstFeatureLocation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PatternFeatureLinearNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PatternFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FirstFeatureLocation
        //
        if (n.name () == L"FirstFeatureLocation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FirstFeatureLocation_type > r (
            FirstFeatureLocation_traits::create (i, f, this));

          if (!FirstFeatureLocation_.present ())
          {
            this->FirstFeatureLocation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FirstFeatureLocation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FirstFeatureLocation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PatternFeatureLinearNominalType* PatternFeatureLinearNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureLinearNominalType (*this, f, c);
    }

    PatternFeatureLinearNominalType& PatternFeatureLinearNominalType::
    operator= (const PatternFeatureLinearNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PatternFeatureNominalBaseType& > (*this) = x;
        this->FirstFeatureLocation_ = x.FirstFeatureLocation_;
      }

      return *this;
    }

    PatternFeatureLinearNominalType::
    ~PatternFeatureLinearNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureLinearNominalType >
    _xsd_PatternFeatureLinearNominalType_type_factory_init (
      L"PatternFeatureLinearNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureParallelogramItemType
    //

    PatternFeatureParallelogramItemType::
    PatternFeatureParallelogramItemType ()
    : ::xsd::qif30::PatternFeatureItemBaseType ()
    {
    }

    PatternFeatureParallelogramItemType::
    PatternFeatureParallelogramItemType (const id_type& id,
                                         const FeatureNominalId_type& FeatureNominalId,
                                         const FeatureName_type& FeatureName)
    : ::xsd::qif30::PatternFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName)
    {
    }

    PatternFeatureParallelogramItemType::
    PatternFeatureParallelogramItemType (const id_type& id,
                                         ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                         const FeatureName_type& FeatureName)
    : ::xsd::qif30::PatternFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName)
    {
    }

    PatternFeatureParallelogramItemType::
    PatternFeatureParallelogramItemType (const PatternFeatureParallelogramItemType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureItemBaseType (x, f, c)
    {
    }

    PatternFeatureParallelogramItemType::
    PatternFeatureParallelogramItemType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureItemBaseType (e, f, c)
    {
    }

    PatternFeatureParallelogramItemType* PatternFeatureParallelogramItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureParallelogramItemType (*this, f, c);
    }

    PatternFeatureParallelogramItemType::
    ~PatternFeatureParallelogramItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureParallelogramItemType >
    _xsd_PatternFeatureParallelogramItemType_type_factory_init (
      L"PatternFeatureParallelogramItemType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureParallelogramDefinitionType
    //

    PatternFeatureParallelogramDefinitionType::
    PatternFeatureParallelogramDefinitionType ()
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (),
      AlongRowDirection_ (this),
      IncrementalRowDistance_ (this),
      BetweenRowDirection_ (this),
      RowSeparationDistance_ (this),
      FeatureDirection_ (this),
      NumberOfFeaturesPerRow_ (this),
      NumberOfRows_ (this)
    {
    }

    PatternFeatureParallelogramDefinitionType::
    PatternFeatureParallelogramDefinitionType (const id_type& id,
                                               const AlongRowDirection_type& AlongRowDirection,
                                               const IncrementalRowDistance_type& IncrementalRowDistance,
                                               const BetweenRowDirection_type& BetweenRowDirection,
                                               const RowSeparationDistance_type& RowSeparationDistance,
                                               const NumberOfFeaturesPerRow_type& NumberOfFeaturesPerRow,
                                               const NumberOfRows_type& NumberOfRows)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (id),
      AlongRowDirection_ (AlongRowDirection, this),
      IncrementalRowDistance_ (IncrementalRowDistance, this),
      BetweenRowDirection_ (BetweenRowDirection, this),
      RowSeparationDistance_ (RowSeparationDistance, this),
      FeatureDirection_ (this),
      NumberOfFeaturesPerRow_ (NumberOfFeaturesPerRow, this),
      NumberOfRows_ (NumberOfRows, this)
    {
    }

    PatternFeatureParallelogramDefinitionType::
    PatternFeatureParallelogramDefinitionType (const id_type& id,
                                               ::std::unique_ptr< AlongRowDirection_type > AlongRowDirection,
                                               ::std::unique_ptr< IncrementalRowDistance_type > IncrementalRowDistance,
                                               ::std::unique_ptr< BetweenRowDirection_type > BetweenRowDirection,
                                               ::std::unique_ptr< RowSeparationDistance_type > RowSeparationDistance,
                                               const NumberOfFeaturesPerRow_type& NumberOfFeaturesPerRow,
                                               const NumberOfRows_type& NumberOfRows)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (id),
      AlongRowDirection_ (std::move (AlongRowDirection), this),
      IncrementalRowDistance_ (std::move (IncrementalRowDistance), this),
      BetweenRowDirection_ (std::move (BetweenRowDirection), this),
      RowSeparationDistance_ (std::move (RowSeparationDistance), this),
      FeatureDirection_ (this),
      NumberOfFeaturesPerRow_ (NumberOfFeaturesPerRow, this),
      NumberOfRows_ (NumberOfRows, this)
    {
    }

    PatternFeatureParallelogramDefinitionType::
    PatternFeatureParallelogramDefinitionType (const PatternFeatureParallelogramDefinitionType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (x, f, c),
      AlongRowDirection_ (x.AlongRowDirection_, f, this),
      IncrementalRowDistance_ (x.IncrementalRowDistance_, f, this),
      BetweenRowDirection_ (x.BetweenRowDirection_, f, this),
      RowSeparationDistance_ (x.RowSeparationDistance_, f, this),
      FeatureDirection_ (x.FeatureDirection_, f, this),
      NumberOfFeaturesPerRow_ (x.NumberOfFeaturesPerRow_, f, this),
      NumberOfRows_ (x.NumberOfRows_, f, this)
    {
    }

    PatternFeatureParallelogramDefinitionType::
    PatternFeatureParallelogramDefinitionType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      AlongRowDirection_ (this),
      IncrementalRowDistance_ (this),
      BetweenRowDirection_ (this),
      RowSeparationDistance_ (this),
      FeatureDirection_ (this),
      NumberOfFeaturesPerRow_ (this),
      NumberOfRows_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PatternFeatureParallelogramDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PatternFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AlongRowDirection
        //
        if (n.name () == L"AlongRowDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AlongRowDirection_type > r (
            AlongRowDirection_traits::create (i, f, this));

          if (!AlongRowDirection_.present ())
          {
            this->AlongRowDirection_.set (::std::move (r));
            continue;
          }
        }

        // IncrementalRowDistance
        //
        if (n.name () == L"IncrementalRowDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IncrementalRowDistance_type > r (
            IncrementalRowDistance_traits::create (i, f, this));

          if (!IncrementalRowDistance_.present ())
          {
            this->IncrementalRowDistance_.set (::std::move (r));
            continue;
          }
        }

        // BetweenRowDirection
        //
        if (n.name () == L"BetweenRowDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BetweenRowDirection_type > r (
            BetweenRowDirection_traits::create (i, f, this));

          if (!BetweenRowDirection_.present ())
          {
            this->BetweenRowDirection_.set (::std::move (r));
            continue;
          }
        }

        // RowSeparationDistance
        //
        if (n.name () == L"RowSeparationDistance" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RowSeparationDistance_type > r (
            RowSeparationDistance_traits::create (i, f, this));

          if (!RowSeparationDistance_.present ())
          {
            this->RowSeparationDistance_.set (::std::move (r));
            continue;
          }
        }

        // FeatureDirection
        //
        if (n.name () == L"FeatureDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureDirection_type > r (
            FeatureDirection_traits::create (i, f, this));

          if (!this->FeatureDirection_)
          {
            this->FeatureDirection_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfFeaturesPerRow
        //
        if (n.name () == L"NumberOfFeaturesPerRow" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberOfFeaturesPerRow_type > r (
            NumberOfFeaturesPerRow_traits::create (i, f, this));

          if (!NumberOfFeaturesPerRow_.present ())
          {
            this->NumberOfFeaturesPerRow_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfRows
        //
        if (n.name () == L"NumberOfRows" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberOfRows_type > r (
            NumberOfRows_traits::create (i, f, this));

          if (!NumberOfRows_.present ())
          {
            this->NumberOfRows_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!AlongRowDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AlongRowDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!IncrementalRowDistance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IncrementalRowDistance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!BetweenRowDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"BetweenRowDirection",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!RowSeparationDistance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"RowSeparationDistance",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfFeaturesPerRow_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfFeaturesPerRow",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfRows_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfRows",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PatternFeatureParallelogramDefinitionType* PatternFeatureParallelogramDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureParallelogramDefinitionType (*this, f, c);
    }

    PatternFeatureParallelogramDefinitionType& PatternFeatureParallelogramDefinitionType::
    operator= (const PatternFeatureParallelogramDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PatternFeatureDefinitionBaseType& > (*this) = x;
        this->AlongRowDirection_ = x.AlongRowDirection_;
        this->IncrementalRowDistance_ = x.IncrementalRowDistance_;
        this->BetweenRowDirection_ = x.BetweenRowDirection_;
        this->RowSeparationDistance_ = x.RowSeparationDistance_;
        this->FeatureDirection_ = x.FeatureDirection_;
        this->NumberOfFeaturesPerRow_ = x.NumberOfFeaturesPerRow_;
        this->NumberOfRows_ = x.NumberOfRows_;
      }

      return *this;
    }

    PatternFeatureParallelogramDefinitionType::
    ~PatternFeatureParallelogramDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureParallelogramDefinitionType >
    _xsd_PatternFeatureParallelogramDefinitionType_type_factory_init (
      L"PatternFeatureParallelogramDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureParallelogramNominalType
    //

    PatternFeatureParallelogramNominalType::
    PatternFeatureParallelogramNominalType ()
    : ::xsd::qif30::PatternFeatureNominalBaseType (),
      FirstFeatureLocation_ (this)
    {
    }

    PatternFeatureParallelogramNominalType::
    PatternFeatureParallelogramNominalType (const id_type& id,
                                            const FeatureDefinitionId_type& FeatureDefinitionId,
                                            const FeatureNominalIds_type& FeatureNominalIds,
                                            const FirstFeatureLocation_type& FirstFeatureLocation)
    : ::xsd::qif30::PatternFeatureNominalBaseType (id,
                                                   FeatureDefinitionId,
                                                   FeatureNominalIds),
      FirstFeatureLocation_ (FirstFeatureLocation, this)
    {
    }

    PatternFeatureParallelogramNominalType::
    PatternFeatureParallelogramNominalType (const id_type& id,
                                            ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                            ::std::unique_ptr< FeatureNominalIds_type > FeatureNominalIds,
                                            ::std::unique_ptr< FirstFeatureLocation_type > FirstFeatureLocation)
    : ::xsd::qif30::PatternFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId),
                                                   std::move (FeatureNominalIds)),
      FirstFeatureLocation_ (std::move (FirstFeatureLocation), this)
    {
    }

    PatternFeatureParallelogramNominalType::
    PatternFeatureParallelogramNominalType (const PatternFeatureParallelogramNominalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureNominalBaseType (x, f, c),
      FirstFeatureLocation_ (x.FirstFeatureLocation_, f, this)
    {
    }

    PatternFeatureParallelogramNominalType::
    PatternFeatureParallelogramNominalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      FirstFeatureLocation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PatternFeatureParallelogramNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PatternFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FirstFeatureLocation
        //
        if (n.name () == L"FirstFeatureLocation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FirstFeatureLocation_type > r (
            FirstFeatureLocation_traits::create (i, f, this));

          if (!FirstFeatureLocation_.present ())
          {
            this->FirstFeatureLocation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!FirstFeatureLocation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FirstFeatureLocation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PatternFeatureParallelogramNominalType* PatternFeatureParallelogramNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureParallelogramNominalType (*this, f, c);
    }

    PatternFeatureParallelogramNominalType& PatternFeatureParallelogramNominalType::
    operator= (const PatternFeatureParallelogramNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PatternFeatureNominalBaseType& > (*this) = x;
        this->FirstFeatureLocation_ = x.FirstFeatureLocation_;
      }

      return *this;
    }

    PatternFeatureParallelogramNominalType::
    ~PatternFeatureParallelogramNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureParallelogramNominalType >
    _xsd_PatternFeatureParallelogramNominalType_type_factory_init (
      L"PatternFeatureParallelogramNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureCircularArcItemType
    //

    PatternFeatureCircularArcItemType::
    PatternFeatureCircularArcItemType ()
    : ::xsd::qif30::PatternFeatureItemBaseType ()
    {
    }

    PatternFeatureCircularArcItemType::
    PatternFeatureCircularArcItemType (const id_type& id,
                                       const FeatureNominalId_type& FeatureNominalId,
                                       const FeatureName_type& FeatureName)
    : ::xsd::qif30::PatternFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName)
    {
    }

    PatternFeatureCircularArcItemType::
    PatternFeatureCircularArcItemType (const id_type& id,
                                       ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                       const FeatureName_type& FeatureName)
    : ::xsd::qif30::PatternFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName)
    {
    }

    PatternFeatureCircularArcItemType::
    PatternFeatureCircularArcItemType (const PatternFeatureCircularArcItemType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureItemBaseType (x, f, c)
    {
    }

    PatternFeatureCircularArcItemType::
    PatternFeatureCircularArcItemType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureItemBaseType (e, f, c)
    {
    }

    PatternFeatureCircularArcItemType* PatternFeatureCircularArcItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureCircularArcItemType (*this, f, c);
    }

    PatternFeatureCircularArcItemType::
    ~PatternFeatureCircularArcItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureCircularArcItemType >
    _xsd_PatternFeatureCircularArcItemType_type_factory_init (
      L"PatternFeatureCircularArcItemType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureCircularArcDefinitionType
    //

    PatternFeatureCircularArcDefinitionType::
    PatternFeatureCircularArcDefinitionType ()
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (),
      ArcRadius_ (this),
      IncrementalArc_ (this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (this)
    {
    }

    PatternFeatureCircularArcDefinitionType::
    PatternFeatureCircularArcDefinitionType (const id_type& id,
                                             const ArcRadius_type& ArcRadius,
                                             const IncrementalArc_type& IncrementalArc,
                                             const NumberOfFeatures_type& NumberOfFeatures)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (id),
      ArcRadius_ (ArcRadius, this),
      IncrementalArc_ (IncrementalArc, this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (NumberOfFeatures, this)
    {
    }

    PatternFeatureCircularArcDefinitionType::
    PatternFeatureCircularArcDefinitionType (const id_type& id,
                                             ::std::unique_ptr< ArcRadius_type > ArcRadius,
                                             ::std::unique_ptr< IncrementalArc_type > IncrementalArc,
                                             const NumberOfFeatures_type& NumberOfFeatures)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (id),
      ArcRadius_ (std::move (ArcRadius), this),
      IncrementalArc_ (std::move (IncrementalArc), this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (NumberOfFeatures, this)
    {
    }

    PatternFeatureCircularArcDefinitionType::
    PatternFeatureCircularArcDefinitionType (const PatternFeatureCircularArcDefinitionType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (x, f, c),
      ArcRadius_ (x.ArcRadius_, f, this),
      IncrementalArc_ (x.IncrementalArc_, f, this),
      FeatureDirection_ (x.FeatureDirection_, f, this),
      NumberOfFeatures_ (x.NumberOfFeatures_, f, this)
    {
    }

    PatternFeatureCircularArcDefinitionType::
    PatternFeatureCircularArcDefinitionType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      ArcRadius_ (this),
      IncrementalArc_ (this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PatternFeatureCircularArcDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PatternFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArcRadius
        //
        if (n.name () == L"ArcRadius" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ArcRadius_type > r (
            ArcRadius_traits::create (i, f, this));

          if (!ArcRadius_.present ())
          {
            this->ArcRadius_.set (::std::move (r));
            continue;
          }
        }

        // IncrementalArc
        //
        if (n.name () == L"IncrementalArc" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< IncrementalArc_type > r (
            IncrementalArc_traits::create (i, f, this));

          if (!IncrementalArc_.present ())
          {
            this->IncrementalArc_.set (::std::move (r));
            continue;
          }
        }

        // FeatureDirection
        //
        if (n.name () == L"FeatureDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureDirection_type > r (
            FeatureDirection_traits::create (i, f, this));

          if (!this->FeatureDirection_)
          {
            this->FeatureDirection_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfFeatures
        //
        if (n.name () == L"NumberOfFeatures" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberOfFeatures_type > r (
            NumberOfFeatures_traits::create (i, f, this));

          if (!NumberOfFeatures_.present ())
          {
            this->NumberOfFeatures_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!ArcRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ArcRadius",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!IncrementalArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"IncrementalArc",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfFeatures_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfFeatures",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PatternFeatureCircularArcDefinitionType* PatternFeatureCircularArcDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureCircularArcDefinitionType (*this, f, c);
    }

    PatternFeatureCircularArcDefinitionType& PatternFeatureCircularArcDefinitionType::
    operator= (const PatternFeatureCircularArcDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PatternFeatureDefinitionBaseType& > (*this) = x;
        this->ArcRadius_ = x.ArcRadius_;
        this->IncrementalArc_ = x.IncrementalArc_;
        this->FeatureDirection_ = x.FeatureDirection_;
        this->NumberOfFeatures_ = x.NumberOfFeatures_;
      }

      return *this;
    }

    PatternFeatureCircularArcDefinitionType::
    ~PatternFeatureCircularArcDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureCircularArcDefinitionType >
    _xsd_PatternFeatureCircularArcDefinitionType_type_factory_init (
      L"PatternFeatureCircularArcDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureCircularArcNominalType
    //

    PatternFeatureCircularArcNominalType::
    PatternFeatureCircularArcNominalType ()
    : ::xsd::qif30::PatternFeatureNominalBaseType (),
      Normal_ (this),
      Center_ (this),
      FirstFeatureLocation_ (this)
    {
    }

    PatternFeatureCircularArcNominalType::
    PatternFeatureCircularArcNominalType (const id_type& id,
                                          const FeatureDefinitionId_type& FeatureDefinitionId,
                                          const FeatureNominalIds_type& FeatureNominalIds,
                                          const Normal_type& Normal,
                                          const Center_type& Center,
                                          const FirstFeatureLocation_type& FirstFeatureLocation)
    : ::xsd::qif30::PatternFeatureNominalBaseType (id,
                                                   FeatureDefinitionId,
                                                   FeatureNominalIds),
      Normal_ (Normal, this),
      Center_ (Center, this),
      FirstFeatureLocation_ (FirstFeatureLocation, this)
    {
    }

    PatternFeatureCircularArcNominalType::
    PatternFeatureCircularArcNominalType (const id_type& id,
                                          ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                          ::std::unique_ptr< FeatureNominalIds_type > FeatureNominalIds,
                                          ::std::unique_ptr< Normal_type > Normal,
                                          ::std::unique_ptr< Center_type > Center,
                                          ::std::unique_ptr< FirstFeatureLocation_type > FirstFeatureLocation)
    : ::xsd::qif30::PatternFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId),
                                                   std::move (FeatureNominalIds)),
      Normal_ (std::move (Normal), this),
      Center_ (std::move (Center), this),
      FirstFeatureLocation_ (std::move (FirstFeatureLocation), this)
    {
    }

    PatternFeatureCircularArcNominalType::
    PatternFeatureCircularArcNominalType (const PatternFeatureCircularArcNominalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureNominalBaseType (x, f, c),
      Normal_ (x.Normal_, f, this),
      Center_ (x.Center_, f, this),
      FirstFeatureLocation_ (x.FirstFeatureLocation_, f, this)
    {
    }

    PatternFeatureCircularArcNominalType::
    PatternFeatureCircularArcNominalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Normal_ (this),
      Center_ (this),
      FirstFeatureLocation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PatternFeatureCircularArcNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PatternFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Center
        //
        if (n.name () == L"Center" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Center_type > r (
            Center_traits::create (i, f, this));

          if (!Center_.present ())
          {
            this->Center_.set (::std::move (r));
            continue;
          }
        }

        // FirstFeatureLocation
        //
        if (n.name () == L"FirstFeatureLocation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FirstFeatureLocation_type > r (
            FirstFeatureLocation_traits::create (i, f, this));

          if (!FirstFeatureLocation_.present ())
          {
            this->FirstFeatureLocation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Center",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!FirstFeatureLocation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FirstFeatureLocation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PatternFeatureCircularArcNominalType* PatternFeatureCircularArcNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureCircularArcNominalType (*this, f, c);
    }

    PatternFeatureCircularArcNominalType& PatternFeatureCircularArcNominalType::
    operator= (const PatternFeatureCircularArcNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PatternFeatureNominalBaseType& > (*this) = x;
        this->Normal_ = x.Normal_;
        this->Center_ = x.Center_;
        this->FirstFeatureLocation_ = x.FirstFeatureLocation_;
      }

      return *this;
    }

    PatternFeatureCircularArcNominalType::
    ~PatternFeatureCircularArcNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureCircularArcNominalType >
    _xsd_PatternFeatureCircularArcNominalType_type_factory_init (
      L"PatternFeatureCircularArcNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureCircleItemType
    //

    PatternFeatureCircleItemType::
    PatternFeatureCircleItemType ()
    : ::xsd::qif30::PatternFeatureItemBaseType ()
    {
    }

    PatternFeatureCircleItemType::
    PatternFeatureCircleItemType (const id_type& id,
                                  const FeatureNominalId_type& FeatureNominalId,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif30::PatternFeatureItemBaseType (id,
                                                FeatureNominalId,
                                                FeatureName)
    {
    }

    PatternFeatureCircleItemType::
    PatternFeatureCircleItemType (const id_type& id,
                                  ::std::unique_ptr< FeatureNominalId_type > FeatureNominalId,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif30::PatternFeatureItemBaseType (id,
                                                std::move (FeatureNominalId),
                                                FeatureName)
    {
    }

    PatternFeatureCircleItemType::
    PatternFeatureCircleItemType (const PatternFeatureCircleItemType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureItemBaseType (x, f, c)
    {
    }

    PatternFeatureCircleItemType::
    PatternFeatureCircleItemType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureItemBaseType (e, f, c)
    {
    }

    PatternFeatureCircleItemType* PatternFeatureCircleItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureCircleItemType (*this, f, c);
    }

    PatternFeatureCircleItemType::
    ~PatternFeatureCircleItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureCircleItemType >
    _xsd_PatternFeatureCircleItemType_type_factory_init (
      L"PatternFeatureCircleItemType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureCircleDefinitionType
    //

    PatternFeatureCircleDefinitionType::
    PatternFeatureCircleDefinitionType ()
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (),
      Diameter_ (this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (this)
    {
    }

    PatternFeatureCircleDefinitionType::
    PatternFeatureCircleDefinitionType (const id_type& id,
                                        const Diameter_type& Diameter,
                                        const NumberOfFeatures_type& NumberOfFeatures)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (id),
      Diameter_ (Diameter, this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (NumberOfFeatures, this)
    {
    }

    PatternFeatureCircleDefinitionType::
    PatternFeatureCircleDefinitionType (const id_type& id,
                                        ::std::unique_ptr< Diameter_type > Diameter,
                                        const NumberOfFeatures_type& NumberOfFeatures)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (id),
      Diameter_ (std::move (Diameter), this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (NumberOfFeatures, this)
    {
    }

    PatternFeatureCircleDefinitionType::
    PatternFeatureCircleDefinitionType (const PatternFeatureCircleDefinitionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      FeatureDirection_ (x.FeatureDirection_, f, this),
      NumberOfFeatures_ (x.NumberOfFeatures_, f, this)
    {
    }

    PatternFeatureCircleDefinitionType::
    PatternFeatureCircleDefinitionType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      FeatureDirection_ (this),
      NumberOfFeatures_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PatternFeatureCircleDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PatternFeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Diameter
        //
        if (n.name () == L"Diameter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (::std::move (r));
            continue;
          }
        }

        // FeatureDirection
        //
        if (n.name () == L"FeatureDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureDirection_type > r (
            FeatureDirection_traits::create (i, f, this));

          if (!this->FeatureDirection_)
          {
            this->FeatureDirection_.set (::std::move (r));
            continue;
          }
        }

        // NumberOfFeatures
        //
        if (n.name () == L"NumberOfFeatures" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NumberOfFeatures_type > r (
            NumberOfFeatures_traits::create (i, f, this));

          if (!NumberOfFeatures_.present ())
          {
            this->NumberOfFeatures_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Diameter",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!NumberOfFeatures_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NumberOfFeatures",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PatternFeatureCircleDefinitionType* PatternFeatureCircleDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureCircleDefinitionType (*this, f, c);
    }

    PatternFeatureCircleDefinitionType& PatternFeatureCircleDefinitionType::
    operator= (const PatternFeatureCircleDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PatternFeatureDefinitionBaseType& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->FeatureDirection_ = x.FeatureDirection_;
        this->NumberOfFeatures_ = x.NumberOfFeatures_;
      }

      return *this;
    }

    PatternFeatureCircleDefinitionType::
    ~PatternFeatureCircleDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureCircleDefinitionType >
    _xsd_PatternFeatureCircleDefinitionType_type_factory_init (
      L"PatternFeatureCircleDefinitionType",
      L"http://qifstandards.org/xsd/qif3");

    // PatternFeatureCircleNominalType
    //

    PatternFeatureCircleNominalType::
    PatternFeatureCircleNominalType ()
    : ::xsd::qif30::PatternFeatureNominalBaseType (),
      Normal_ (this),
      Center_ (this),
      FirstFeatureLocation_ (this)
    {
    }

    PatternFeatureCircleNominalType::
    PatternFeatureCircleNominalType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     const FeatureNominalIds_type& FeatureNominalIds,
                                     const Normal_type& Normal,
                                     const Center_type& Center,
                                     const FirstFeatureLocation_type& FirstFeatureLocation)
    : ::xsd::qif30::PatternFeatureNominalBaseType (id,
                                                   FeatureDefinitionId,
                                                   FeatureNominalIds),
      Normal_ (Normal, this),
      Center_ (Center, this),
      FirstFeatureLocation_ (FirstFeatureLocation, this)
    {
    }

    PatternFeatureCircleNominalType::
    PatternFeatureCircleNominalType (const id_type& id,
                                     ::std::unique_ptr< FeatureDefinitionId_type > FeatureDefinitionId,
                                     ::std::unique_ptr< FeatureNominalIds_type > FeatureNominalIds,
                                     ::std::unique_ptr< Normal_type > Normal,
                                     ::std::unique_ptr< Center_type > Center,
                                     ::std::unique_ptr< FirstFeatureLocation_type > FirstFeatureLocation)
    : ::xsd::qif30::PatternFeatureNominalBaseType (id,
                                                   std::move (FeatureDefinitionId),
                                                   std::move (FeatureNominalIds)),
      Normal_ (std::move (Normal), this),
      Center_ (std::move (Center), this),
      FirstFeatureLocation_ (std::move (FirstFeatureLocation), this)
    {
    }

    PatternFeatureCircleNominalType::
    PatternFeatureCircleNominalType (const PatternFeatureCircleNominalType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureNominalBaseType (x, f, c),
      Normal_ (x.Normal_, f, this),
      Center_ (x.Center_, f, this),
      FirstFeatureLocation_ (x.FirstFeatureLocation_, f, this)
    {
    }

    PatternFeatureCircleNominalType::
    PatternFeatureCircleNominalType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif30::PatternFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Normal_ (this),
      Center_ (this),
      FirstFeatureLocation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PatternFeatureCircleNominalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::PatternFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Normal
        //
        if (n.name () == L"Normal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (::std::move (r));
            continue;
          }
        }

        // Center
        //
        if (n.name () == L"Center" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Center_type > r (
            Center_traits::create (i, f, this));

          if (!Center_.present ())
          {
            this->Center_.set (::std::move (r));
            continue;
          }
        }

        // FirstFeatureLocation
        //
        if (n.name () == L"FirstFeatureLocation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FirstFeatureLocation_type > r (
            FirstFeatureLocation_traits::create (i, f, this));

          if (!FirstFeatureLocation_.present ())
          {
            this->FirstFeatureLocation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Normal",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Center_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Center",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!FirstFeatureLocation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"FirstFeatureLocation",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PatternFeatureCircleNominalType* PatternFeatureCircleNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureCircleNominalType (*this, f, c);
    }

    PatternFeatureCircleNominalType& PatternFeatureCircleNominalType::
    operator= (const PatternFeatureCircleNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::PatternFeatureNominalBaseType& > (*this) = x;
        this->Normal_ = x.Normal_;
        this->Center_ = x.Center_;
        this->FirstFeatureLocation_ = x.FirstFeatureLocation_;
      }

      return *this;
    }

    PatternFeatureCircleNominalType::
    ~PatternFeatureCircleNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PatternFeatureCircleNominalType >
    _xsd_PatternFeatureCircleNominalType_type_factory_init (
      L"PatternFeatureCircleNominalType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneBaseType
    //

    FeatureZoneBaseType::
    FeatureZoneBaseType ()
    : ::xml_schema::type (),
      Attributes_ (this),
      Label_ (this),
      SurfaceFeatureNominalId_ (this),
      id_ (this)
    {
    }

    FeatureZoneBaseType::
    FeatureZoneBaseType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Label_ (this),
      SurfaceFeatureNominalId_ (this),
      id_ (id, this)
    {
    }

    FeatureZoneBaseType::
    FeatureZoneBaseType (const FeatureZoneBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Label_ (x.Label_, f, this),
      SurfaceFeatureNominalId_ (x.SurfaceFeatureNominalId_, f, this),
      id_ (x.id_, f, this)
    {
    }

    FeatureZoneBaseType::
    FeatureZoneBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Label_ (this),
      SurfaceFeatureNominalId_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attributes
        //
        if (n.name () == L"Attributes" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (::std::move (r));
            continue;
          }
        }

        // Label
        //
        if (n.name () == L"Label" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Label_type > r (
            Label_traits::create (i, f, this));

          if (!this->Label_)
          {
            this->Label_.set (::std::move (r));
            continue;
          }
        }

        // SurfaceFeatureNominalId
        //
        if (n.name () == L"SurfaceFeatureNominalId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SurfaceFeatureNominalId_type > r (
            SurfaceFeatureNominalId_traits::create (i, f, this));

          if (!this->SurfaceFeatureNominalId_)
          {
            this->SurfaceFeatureNominalId_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    FeatureZoneBaseType& FeatureZoneBaseType::
    operator= (const FeatureZoneBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Label_ = x.Label_;
        this->SurfaceFeatureNominalId_ = x.SurfaceFeatureNominalId_;
        this->id_ = x.id_;
      }

      return *this;
    }

    FeatureZoneBaseType::
    ~FeatureZoneBaseType ()
    {
    }

    // FeatureZonePointType
    //

    FeatureZonePointType::
    FeatureZonePointType ()
    : ::xsd::qif30::FeatureZoneBaseType (),
      VertexId_ (this),
      PointId_ (this),
      Point_ (this)
    {
    }

    FeatureZonePointType::
    FeatureZonePointType (const id_type& id,
                          const Point_type& Point)
    : ::xsd::qif30::FeatureZoneBaseType (id),
      VertexId_ (this),
      PointId_ (this),
      Point_ (Point, this)
    {
    }

    FeatureZonePointType::
    FeatureZonePointType (const id_type& id,
                          ::std::unique_ptr< Point_type > Point)
    : ::xsd::qif30::FeatureZoneBaseType (id),
      VertexId_ (this),
      PointId_ (this),
      Point_ (std::move (Point), this)
    {
    }

    FeatureZonePointType::
    FeatureZonePointType (const FeatureZonePointType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneBaseType (x, f, c),
      VertexId_ (x.VertexId_, f, this),
      PointId_ (x.PointId_, f, this),
      Point_ (x.Point_, f, this)
    {
    }

    FeatureZonePointType::
    FeatureZonePointType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneBaseType (e, f | ::xml_schema::flags::base, c),
      VertexId_ (this),
      PointId_ (this),
      Point_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZonePointType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // VertexId
        //
        if (n.name () == L"VertexId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VertexId_type > r (
            VertexId_traits::create (i, f, this));

          if (!this->VertexId_)
          {
            this->VertexId_.set (::std::move (r));
            continue;
          }
        }

        // PointId
        //
        if (n.name () == L"PointId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointId_type > r (
            PointId_traits::create (i, f, this));

          if (!this->PointId_)
          {
            this->PointId_.set (::std::move (r));
            continue;
          }
        }

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Point",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureZonePointType* FeatureZonePointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZonePointType (*this, f, c);
    }

    FeatureZonePointType& FeatureZonePointType::
    operator= (const FeatureZonePointType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneBaseType& > (*this) = x;
        this->VertexId_ = x.VertexId_;
        this->PointId_ = x.PointId_;
        this->Point_ = x.Point_;
      }

      return *this;
    }

    FeatureZonePointType::
    ~FeatureZonePointType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZonePointType >
    _xsd_FeatureZonePointType_type_factory_init (
      L"FeatureZonePointType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneCurveBaseType
    //

    FeatureZoneCurveBaseType::
    FeatureZoneCurveBaseType ()
    : ::xsd::qif30::FeatureZoneBaseType (),
      EdgeIds_ (this),
      CurveIds_ (this)
    {
    }

    FeatureZoneCurveBaseType::
    FeatureZoneCurveBaseType (const id_type& id)
    : ::xsd::qif30::FeatureZoneBaseType (id),
      EdgeIds_ (this),
      CurveIds_ (this)
    {
    }

    FeatureZoneCurveBaseType::
    FeatureZoneCurveBaseType (const FeatureZoneCurveBaseType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneBaseType (x, f, c),
      EdgeIds_ (x.EdgeIds_, f, this),
      CurveIds_ (x.CurveIds_, f, this)
    {
    }

    FeatureZoneCurveBaseType::
    FeatureZoneCurveBaseType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneBaseType (e, f | ::xml_schema::flags::base, c),
      EdgeIds_ (this),
      CurveIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneCurveBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EdgeIds
        //
        if (n.name () == L"EdgeIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgeIds_type > r (
            EdgeIds_traits::create (i, f, this));

          if (!this->EdgeIds_)
          {
            this->EdgeIds_.set (::std::move (r));
            continue;
          }
        }

        // CurveIds
        //
        if (n.name () == L"CurveIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveIds_type > r (
            CurveIds_traits::create (i, f, this));

          if (!this->CurveIds_)
          {
            this->CurveIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FeatureZoneCurveBaseType& FeatureZoneCurveBaseType::
    operator= (const FeatureZoneCurveBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneBaseType& > (*this) = x;
        this->EdgeIds_ = x.EdgeIds_;
        this->CurveIds_ = x.CurveIds_;
      }

      return *this;
    }

    FeatureZoneCurveBaseType::
    ~FeatureZoneCurveBaseType ()
    {
    }

    // FeatureZoneCurveLineType
    //

    FeatureZoneCurveLineType::
    FeatureZoneCurveLineType ()
    : ::xsd::qif30::FeatureZoneCurveBaseType (),
      Line_ (this)
    {
    }

    FeatureZoneCurveLineType::
    FeatureZoneCurveLineType (const id_type& id,
                              const Line_type& Line)
    : ::xsd::qif30::FeatureZoneCurveBaseType (id),
      Line_ (Line, this)
    {
    }

    FeatureZoneCurveLineType::
    FeatureZoneCurveLineType (const id_type& id,
                              ::std::unique_ptr< Line_type > Line)
    : ::xsd::qif30::FeatureZoneCurveBaseType (id),
      Line_ (std::move (Line), this)
    {
    }

    FeatureZoneCurveLineType::
    FeatureZoneCurveLineType (const FeatureZoneCurveLineType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneCurveBaseType (x, f, c),
      Line_ (x.Line_, f, this)
    {
    }

    FeatureZoneCurveLineType::
    FeatureZoneCurveLineType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneCurveBaseType (e, f | ::xml_schema::flags::base, c),
      Line_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneCurveLineType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneCurveBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Line
        //
        if (n.name () == L"Line" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Line_type > r (
            Line_traits::create (i, f, this));

          if (!Line_.present ())
          {
            this->Line_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Line_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Line",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureZoneCurveLineType* FeatureZoneCurveLineType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneCurveLineType (*this, f, c);
    }

    FeatureZoneCurveLineType& FeatureZoneCurveLineType::
    operator= (const FeatureZoneCurveLineType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneCurveBaseType& > (*this) = x;
        this->Line_ = x.Line_;
      }

      return *this;
    }

    FeatureZoneCurveLineType::
    ~FeatureZoneCurveLineType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneCurveLineType >
    _xsd_FeatureZoneCurveLineType_type_factory_init (
      L"FeatureZoneCurveLineType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneCurveCircularType
    //

    FeatureZoneCurveCircularType::
    FeatureZoneCurveCircularType ()
    : ::xsd::qif30::FeatureZoneCurveBaseType (),
      Circle_ (this)
    {
    }

    FeatureZoneCurveCircularType::
    FeatureZoneCurveCircularType (const id_type& id,
                                  const Circle_type& Circle)
    : ::xsd::qif30::FeatureZoneCurveBaseType (id),
      Circle_ (Circle, this)
    {
    }

    FeatureZoneCurveCircularType::
    FeatureZoneCurveCircularType (const id_type& id,
                                  ::std::unique_ptr< Circle_type > Circle)
    : ::xsd::qif30::FeatureZoneCurveBaseType (id),
      Circle_ (std::move (Circle), this)
    {
    }

    FeatureZoneCurveCircularType::
    FeatureZoneCurveCircularType (const FeatureZoneCurveCircularType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneCurveBaseType (x, f, c),
      Circle_ (x.Circle_, f, this)
    {
    }

    FeatureZoneCurveCircularType::
    FeatureZoneCurveCircularType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneCurveBaseType (e, f | ::xml_schema::flags::base, c),
      Circle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneCurveCircularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneCurveBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Circle
        //
        if (n.name () == L"Circle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Circle_type > r (
            Circle_traits::create (i, f, this));

          if (!Circle_.present ())
          {
            this->Circle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Circle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Circle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureZoneCurveCircularType* FeatureZoneCurveCircularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneCurveCircularType (*this, f, c);
    }

    FeatureZoneCurveCircularType& FeatureZoneCurveCircularType::
    operator= (const FeatureZoneCurveCircularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneCurveBaseType& > (*this) = x;
        this->Circle_ = x.Circle_;
      }

      return *this;
    }

    FeatureZoneCurveCircularType::
    ~FeatureZoneCurveCircularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneCurveCircularType >
    _xsd_FeatureZoneCurveCircularType_type_factory_init (
      L"FeatureZoneCurveCircularType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneCurveIrregularType
    //

    FeatureZoneCurveIrregularType::
    FeatureZoneCurveIrregularType ()
    : ::xsd::qif30::FeatureZoneCurveBaseType (),
      CurvePoints_ (this)
    {
    }

    FeatureZoneCurveIrregularType::
    FeatureZoneCurveIrregularType (const id_type& id,
                                   const CurvePoints_type& CurvePoints)
    : ::xsd::qif30::FeatureZoneCurveBaseType (id),
      CurvePoints_ (CurvePoints, this)
    {
    }

    FeatureZoneCurveIrregularType::
    FeatureZoneCurveIrregularType (const id_type& id,
                                   ::std::unique_ptr< CurvePoints_type > CurvePoints)
    : ::xsd::qif30::FeatureZoneCurveBaseType (id),
      CurvePoints_ (std::move (CurvePoints), this)
    {
    }

    FeatureZoneCurveIrregularType::
    FeatureZoneCurveIrregularType (const FeatureZoneCurveIrregularType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneCurveBaseType (x, f, c),
      CurvePoints_ (x.CurvePoints_, f, this)
    {
    }

    FeatureZoneCurveIrregularType::
    FeatureZoneCurveIrregularType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneCurveBaseType (e, f | ::xml_schema::flags::base, c),
      CurvePoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneCurveIrregularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneCurveBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CurvePoints
        //
        if (n.name () == L"CurvePoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurvePoints_type > r (
            CurvePoints_traits::create (i, f, this));

          if (!CurvePoints_.present ())
          {
            this->CurvePoints_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CurvePoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CurvePoints",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureZoneCurveIrregularType* FeatureZoneCurveIrregularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneCurveIrregularType (*this, f, c);
    }

    FeatureZoneCurveIrregularType& FeatureZoneCurveIrregularType::
    operator= (const FeatureZoneCurveIrregularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneCurveBaseType& > (*this) = x;
        this->CurvePoints_ = x.CurvePoints_;
      }

      return *this;
    }

    FeatureZoneCurveIrregularType::
    ~FeatureZoneCurveIrregularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneCurveIrregularType >
    _xsd_FeatureZoneCurveIrregularType_type_factory_init (
      L"FeatureZoneCurveIrregularType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneAreaBaseType
    //

    FeatureZoneAreaBaseType::
    FeatureZoneAreaBaseType ()
    : ::xsd::qif30::FeatureZoneBaseType (),
      FaceIds_ (this),
      EdgeIds_ (this)
    {
    }

    FeatureZoneAreaBaseType::
    FeatureZoneAreaBaseType (const id_type& id)
    : ::xsd::qif30::FeatureZoneBaseType (id),
      FaceIds_ (this),
      EdgeIds_ (this)
    {
    }

    FeatureZoneAreaBaseType::
    FeatureZoneAreaBaseType (const FeatureZoneAreaBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneBaseType (x, f, c),
      FaceIds_ (x.FaceIds_, f, this),
      EdgeIds_ (x.EdgeIds_, f, this)
    {
    }

    FeatureZoneAreaBaseType::
    FeatureZoneAreaBaseType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneBaseType (e, f | ::xml_schema::flags::base, c),
      FaceIds_ (this),
      EdgeIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneAreaBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FaceIds
        //
        if (n.name () == L"FaceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FaceIds_type > r (
            FaceIds_traits::create (i, f, this));

          if (!this->FaceIds_)
          {
            this->FaceIds_.set (::std::move (r));
            continue;
          }
        }

        // EdgeIds
        //
        if (n.name () == L"EdgeIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgeIds_type > r (
            EdgeIds_traits::create (i, f, this));

          if (!this->EdgeIds_)
          {
            this->EdgeIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FeatureZoneAreaBaseType& FeatureZoneAreaBaseType::
    operator= (const FeatureZoneAreaBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneBaseType& > (*this) = x;
        this->FaceIds_ = x.FaceIds_;
        this->EdgeIds_ = x.EdgeIds_;
      }

      return *this;
    }

    FeatureZoneAreaBaseType::
    ~FeatureZoneAreaBaseType ()
    {
    }

    // FeatureZoneAreaCircularType
    //

    FeatureZoneAreaCircularType::
    FeatureZoneAreaCircularType ()
    : ::xsd::qif30::FeatureZoneAreaBaseType (),
      Circle_ (this)
    {
    }

    FeatureZoneAreaCircularType::
    FeatureZoneAreaCircularType (const id_type& id,
                                 const Circle_type& Circle)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      Circle_ (Circle, this)
    {
    }

    FeatureZoneAreaCircularType::
    FeatureZoneAreaCircularType (const id_type& id,
                                 ::std::unique_ptr< Circle_type > Circle)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      Circle_ (std::move (Circle), this)
    {
    }

    FeatureZoneAreaCircularType::
    FeatureZoneAreaCircularType (const FeatureZoneAreaCircularType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (x, f, c),
      Circle_ (x.Circle_, f, this)
    {
    }

    FeatureZoneAreaCircularType::
    FeatureZoneAreaCircularType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (e, f | ::xml_schema::flags::base, c),
      Circle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneAreaCircularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneAreaBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Circle
        //
        if (n.name () == L"Circle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Circle_type > r (
            Circle_traits::create (i, f, this));

          if (!Circle_.present ())
          {
            this->Circle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Circle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Circle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureZoneAreaCircularType* FeatureZoneAreaCircularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneAreaCircularType (*this, f, c);
    }

    FeatureZoneAreaCircularType& FeatureZoneAreaCircularType::
    operator= (const FeatureZoneAreaCircularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneAreaBaseType& > (*this) = x;
        this->Circle_ = x.Circle_;
      }

      return *this;
    }

    FeatureZoneAreaCircularType::
    ~FeatureZoneAreaCircularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneAreaCircularType >
    _xsd_FeatureZoneAreaCircularType_type_factory_init (
      L"FeatureZoneAreaCircularType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneAreaRectangularType
    //

    FeatureZoneAreaRectangularType::
    FeatureZoneAreaRectangularType ()
    : ::xsd::qif30::FeatureZoneAreaBaseType (),
      Rectangle_ (this)
    {
    }

    FeatureZoneAreaRectangularType::
    FeatureZoneAreaRectangularType (const id_type& id,
                                    const Rectangle_type& Rectangle)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      Rectangle_ (Rectangle, this)
    {
    }

    FeatureZoneAreaRectangularType::
    FeatureZoneAreaRectangularType (const id_type& id,
                                    ::std::unique_ptr< Rectangle_type > Rectangle)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      Rectangle_ (std::move (Rectangle), this)
    {
    }

    FeatureZoneAreaRectangularType::
    FeatureZoneAreaRectangularType (const FeatureZoneAreaRectangularType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (x, f, c),
      Rectangle_ (x.Rectangle_, f, this)
    {
    }

    FeatureZoneAreaRectangularType::
    FeatureZoneAreaRectangularType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (e, f | ::xml_schema::flags::base, c),
      Rectangle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneAreaRectangularType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneAreaBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Rectangle
        //
        if (n.name () == L"Rectangle" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Rectangle_type > r (
            Rectangle_traits::create (i, f, this));

          if (!Rectangle_.present ())
          {
            this->Rectangle_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Rectangle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Rectangle",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureZoneAreaRectangularType* FeatureZoneAreaRectangularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneAreaRectangularType (*this, f, c);
    }

    FeatureZoneAreaRectangularType& FeatureZoneAreaRectangularType::
    operator= (const FeatureZoneAreaRectangularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneAreaBaseType& > (*this) = x;
        this->Rectangle_ = x.Rectangle_;
      }

      return *this;
    }

    FeatureZoneAreaRectangularType::
    ~FeatureZoneAreaRectangularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneAreaRectangularType >
    _xsd_FeatureZoneAreaRectangularType_type_factory_init (
      L"FeatureZoneAreaRectangularType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneAreaIrregularType
    //

    FeatureZoneAreaIrregularType::
    FeatureZoneAreaIrregularType ()
    : ::xsd::qif30::FeatureZoneAreaBaseType ()
    {
    }

    FeatureZoneAreaIrregularType::
    FeatureZoneAreaIrregularType (const id_type& id)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id)
    {
    }

    FeatureZoneAreaIrregularType::
    FeatureZoneAreaIrregularType (const FeatureZoneAreaIrregularType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (x, f, c)
    {
    }

    FeatureZoneAreaIrregularType::
    FeatureZoneAreaIrregularType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (e, f, c)
    {
    }

    FeatureZoneAreaIrregularType* FeatureZoneAreaIrregularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneAreaIrregularType (*this, f, c);
    }

    FeatureZoneAreaIrregularType::
    ~FeatureZoneAreaIrregularType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneAreaIrregularType >
    _xsd_FeatureZoneAreaIrregularType_type_factory_init (
      L"FeatureZoneAreaIrregularType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneAreaCylindricalType
    //

    FeatureZoneAreaCylindricalType::
    FeatureZoneAreaCylindricalType ()
    : ::xsd::qif30::FeatureZoneAreaBaseType (),
      Cylinder_ (this)
    {
    }

    FeatureZoneAreaCylindricalType::
    FeatureZoneAreaCylindricalType (const id_type& id,
                                    const Cylinder_type& Cylinder)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      Cylinder_ (Cylinder, this)
    {
    }

    FeatureZoneAreaCylindricalType::
    FeatureZoneAreaCylindricalType (const id_type& id,
                                    ::std::unique_ptr< Cylinder_type > Cylinder)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      Cylinder_ (std::move (Cylinder), this)
    {
    }

    FeatureZoneAreaCylindricalType::
    FeatureZoneAreaCylindricalType (const FeatureZoneAreaCylindricalType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (x, f, c),
      Cylinder_ (x.Cylinder_, f, this)
    {
    }

    FeatureZoneAreaCylindricalType::
    FeatureZoneAreaCylindricalType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (e, f | ::xml_schema::flags::base, c),
      Cylinder_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneAreaCylindricalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneAreaBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Cylinder
        //
        if (n.name () == L"Cylinder" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Cylinder_type > r (
            Cylinder_traits::create (i, f, this));

          if (!Cylinder_.present ())
          {
            this->Cylinder_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Cylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Cylinder",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureZoneAreaCylindricalType* FeatureZoneAreaCylindricalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneAreaCylindricalType (*this, f, c);
    }

    FeatureZoneAreaCylindricalType& FeatureZoneAreaCylindricalType::
    operator= (const FeatureZoneAreaCylindricalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneAreaBaseType& > (*this) = x;
        this->Cylinder_ = x.Cylinder_;
      }

      return *this;
    }

    FeatureZoneAreaCylindricalType::
    ~FeatureZoneAreaCylindricalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneAreaCylindricalType >
    _xsd_FeatureZoneAreaCylindricalType_type_factory_init (
      L"FeatureZoneAreaCylindricalType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneAreaBetweenType
    //

    FeatureZoneAreaBetweenType::
    FeatureZoneAreaBetweenType ()
    : ::xsd::qif30::FeatureZoneAreaBaseType (),
      FromPointZoneId_ (this),
      FromCurveZoneId_ (this),
      ToPointZoneId_ (this),
      ToCurveZoneId_ (this),
      StartDirection_ (this),
      PlaneNormal_ (this)
    {
    }

    FeatureZoneAreaBetweenType::
    FeatureZoneAreaBetweenType (const id_type& id)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      FromPointZoneId_ (this),
      FromCurveZoneId_ (this),
      ToPointZoneId_ (this),
      ToCurveZoneId_ (this),
      StartDirection_ (this),
      PlaneNormal_ (this)
    {
    }

    FeatureZoneAreaBetweenType::
    FeatureZoneAreaBetweenType (const FeatureZoneAreaBetweenType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (x, f, c),
      FromPointZoneId_ (x.FromPointZoneId_, f, this),
      FromCurveZoneId_ (x.FromCurveZoneId_, f, this),
      ToPointZoneId_ (x.ToPointZoneId_, f, this),
      ToCurveZoneId_ (x.ToCurveZoneId_, f, this),
      StartDirection_ (x.StartDirection_, f, this),
      PlaneNormal_ (x.PlaneNormal_, f, this)
    {
    }

    FeatureZoneAreaBetweenType::
    FeatureZoneAreaBetweenType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (e, f | ::xml_schema::flags::base, c),
      FromPointZoneId_ (this),
      FromCurveZoneId_ (this),
      ToPointZoneId_ (this),
      ToCurveZoneId_ (this),
      StartDirection_ (this),
      PlaneNormal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneAreaBetweenType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneAreaBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FromPointZoneId
        //
        if (n.name () == L"FromPointZoneId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromPointZoneId_type > r (
            FromPointZoneId_traits::create (i, f, this));

          if (!this->FromPointZoneId_)
          {
            this->FromPointZoneId_.set (::std::move (r));
            continue;
          }
        }

        // FromCurveZoneId
        //
        if (n.name () == L"FromCurveZoneId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FromCurveZoneId_type > r (
            FromCurveZoneId_traits::create (i, f, this));

          if (!this->FromCurveZoneId_)
          {
            this->FromCurveZoneId_.set (::std::move (r));
            continue;
          }
        }

        // ToPointZoneId
        //
        if (n.name () == L"ToPointZoneId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToPointZoneId_type > r (
            ToPointZoneId_traits::create (i, f, this));

          if (!this->ToPointZoneId_)
          {
            this->ToPointZoneId_.set (::std::move (r));
            continue;
          }
        }

        // ToCurveZoneId
        //
        if (n.name () == L"ToCurveZoneId" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ToCurveZoneId_type > r (
            ToCurveZoneId_traits::create (i, f, this));

          if (!this->ToCurveZoneId_)
          {
            this->ToCurveZoneId_.set (::std::move (r));
            continue;
          }
        }

        // StartDirection
        //
        if (n.name () == L"StartDirection" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StartDirection_type > r (
            StartDirection_traits::create (i, f, this));

          if (!this->StartDirection_)
          {
            this->StartDirection_.set (::std::move (r));
            continue;
          }
        }

        // PlaneNormal
        //
        if (n.name () == L"PlaneNormal" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PlaneNormal_type > r (
            PlaneNormal_traits::create (i, f, this));

          if (!this->PlaneNormal_)
          {
            this->PlaneNormal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FeatureZoneAreaBetweenType* FeatureZoneAreaBetweenType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneAreaBetweenType (*this, f, c);
    }

    FeatureZoneAreaBetweenType& FeatureZoneAreaBetweenType::
    operator= (const FeatureZoneAreaBetweenType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneAreaBaseType& > (*this) = x;
        this->FromPointZoneId_ = x.FromPointZoneId_;
        this->FromCurveZoneId_ = x.FromCurveZoneId_;
        this->ToPointZoneId_ = x.ToPointZoneId_;
        this->ToCurveZoneId_ = x.ToCurveZoneId_;
        this->StartDirection_ = x.StartDirection_;
        this->PlaneNormal_ = x.PlaneNormal_;
      }

      return *this;
    }

    FeatureZoneAreaBetweenType::
    ~FeatureZoneAreaBetweenType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneAreaBetweenType >
    _xsd_FeatureZoneAreaBetweenType_type_factory_init (
      L"FeatureZoneAreaBetweenType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureZoneAreaSphericalType
    //

    FeatureZoneAreaSphericalType::
    FeatureZoneAreaSphericalType ()
    : ::xsd::qif30::FeatureZoneAreaBaseType (),
      Sphere_ (this)
    {
    }

    FeatureZoneAreaSphericalType::
    FeatureZoneAreaSphericalType (const id_type& id,
                                  const Sphere_type& Sphere)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      Sphere_ (Sphere, this)
    {
    }

    FeatureZoneAreaSphericalType::
    FeatureZoneAreaSphericalType (const id_type& id,
                                  ::std::unique_ptr< Sphere_type > Sphere)
    : ::xsd::qif30::FeatureZoneAreaBaseType (id),
      Sphere_ (std::move (Sphere), this)
    {
    }

    FeatureZoneAreaSphericalType::
    FeatureZoneAreaSphericalType (const FeatureZoneAreaSphericalType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (x, f, c),
      Sphere_ (x.Sphere_, f, this)
    {
    }

    FeatureZoneAreaSphericalType::
    FeatureZoneAreaSphericalType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::FeatureZoneAreaBaseType (e, f | ::xml_schema::flags::base, c),
      Sphere_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneAreaSphericalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FeatureZoneAreaBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Sphere
        //
        if (n.name () == L"Sphere" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Sphere_type > r (
            Sphere_traits::create (i, f, this));

          if (!Sphere_.present ())
          {
            this->Sphere_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Sphere_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Sphere",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FeatureZoneAreaSphericalType* FeatureZoneAreaSphericalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneAreaSphericalType (*this, f, c);
    }

    FeatureZoneAreaSphericalType& FeatureZoneAreaSphericalType::
    operator= (const FeatureZoneAreaSphericalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FeatureZoneAreaBaseType& > (*this) = x;
        this->Sphere_ = x.Sphere_;
      }

      return *this;
    }

    FeatureZoneAreaSphericalType::
    ~FeatureZoneAreaSphericalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FeatureZoneAreaSphericalType >
    _xsd_FeatureZoneAreaSphericalType_type_factory_init (
      L"FeatureZoneAreaSphericalType",
      L"http://qifstandards.org/xsd/qif3");

    // FeatureAspectsListsType
    //

    FeatureAspectsListsType::
    FeatureAspectsListsType ()
    : ::xml_schema::type (),
      FeatureDefinitions_ (this),
      FeatureNominals_ (this),
      FeatureItems_ (this),
      NominalPointSets_ (this)
    {
    }

    FeatureAspectsListsType::
    FeatureAspectsListsType (const FeatureAspectsListsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureDefinitions_ (x.FeatureDefinitions_, f, this),
      FeatureNominals_ (x.FeatureNominals_, f, this),
      FeatureItems_ (x.FeatureItems_, f, this),
      NominalPointSets_ (x.NominalPointSets_, f, this)
    {
    }

    FeatureAspectsListsType::
    FeatureAspectsListsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureDefinitions_ (this),
      FeatureNominals_ (this),
      FeatureItems_ (this),
      NominalPointSets_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureAspectsListsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureDefinitions
        //
        if (n.name () == L"FeatureDefinitions" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureDefinitions_type > r (
            FeatureDefinitions_traits::create (i, f, this));

          if (!this->FeatureDefinitions_)
          {
            this->FeatureDefinitions_.set (::std::move (r));
            continue;
          }
        }

        // FeatureNominals
        //
        if (n.name () == L"FeatureNominals" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureNominals_type > r (
            FeatureNominals_traits::create (i, f, this));

          if (!this->FeatureNominals_)
          {
            this->FeatureNominals_.set (::std::move (r));
            continue;
          }
        }

        // FeatureItems
        //
        if (n.name () == L"FeatureItems" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FeatureItems_type > r (
            FeatureItems_traits::create (i, f, this));

          if (!this->FeatureItems_)
          {
            this->FeatureItems_.set (::std::move (r));
            continue;
          }
        }

        // NominalPointSets
        //
        if (n.name () == L"NominalPointSets" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NominalPointSets_type > r (
            NominalPointSets_traits::create (i, f, this));

          if (!this->NominalPointSets_)
          {
            this->NominalPointSets_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    FeatureAspectsListsType* FeatureAspectsListsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureAspectsListsType (*this, f, c);
    }

    FeatureAspectsListsType& FeatureAspectsListsType::
    operator= (const FeatureAspectsListsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureDefinitions_ = x.FeatureDefinitions_;
        this->FeatureNominals_ = x.FeatureNominals_;
        this->FeatureItems_ = x.FeatureItems_;
        this->NominalPointSets_ = x.NominalPointSets_;
      }

      return *this;
    }

    FeatureAspectsListsType::
    ~FeatureAspectsListsType ()
    {
    }

    // FeatureDefinitionsType
    //

    FeatureDefinitionsType::
    FeatureDefinitionsType ()
    : ::xml_schema::type (),
      FeatureDefinition_ (this),
      n_ (this)
    {
    }

    FeatureDefinitionsType::
    FeatureDefinitionsType (const n_type& n)
    : ::xml_schema::type (),
      FeatureDefinition_ (this),
      n_ (n, this)
    {
    }

    FeatureDefinitionsType::
    FeatureDefinitionsType (const FeatureDefinitionsType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureDefinition_ (x.FeatureDefinition_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FeatureDefinitionsType::
    FeatureDefinitionsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureDefinition_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureDefinitionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureDefinition
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"FeatureDefinition",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FeatureDefinition_type > r (
              dynamic_cast< FeatureDefinition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->FeatureDefinition_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FeatureDefinitionsType* FeatureDefinitionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureDefinitionsType (*this, f, c);
    }

    FeatureDefinitionsType& FeatureDefinitionsType::
    operator= (const FeatureDefinitionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureDefinition_ = x.FeatureDefinition_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FeatureDefinitionsType::
    ~FeatureDefinitionsType ()
    {
    }

    // FeatureNominalsType
    //

    FeatureNominalsType::
    FeatureNominalsType ()
    : ::xml_schema::type (),
      FeatureNominal_ (this),
      n_ (this)
    {
    }

    FeatureNominalsType::
    FeatureNominalsType (const n_type& n)
    : ::xml_schema::type (),
      FeatureNominal_ (this),
      n_ (n, this)
    {
    }

    FeatureNominalsType::
    FeatureNominalsType (const FeatureNominalsType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureNominal_ (x.FeatureNominal_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FeatureNominalsType::
    FeatureNominalsType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureNominal_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureNominalsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureNominal
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"FeatureNominal",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FeatureNominal_type > r (
              dynamic_cast< FeatureNominal_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->FeatureNominal_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FeatureNominalsType* FeatureNominalsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureNominalsType (*this, f, c);
    }

    FeatureNominalsType& FeatureNominalsType::
    operator= (const FeatureNominalsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureNominal_ = x.FeatureNominal_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FeatureNominalsType::
    ~FeatureNominalsType ()
    {
    }

    // FeatureItemsType
    //

    FeatureItemsType::
    FeatureItemsType ()
    : ::xml_schema::type (),
      FeatureItem_ (this),
      n_ (this)
    {
    }

    FeatureItemsType::
    FeatureItemsType (const n_type& n)
    : ::xml_schema::type (),
      FeatureItem_ (this),
      n_ (n, this)
    {
    }

    FeatureItemsType::
    FeatureItemsType (const FeatureItemsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureItem_ (x.FeatureItem_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FeatureItemsType::
    FeatureItemsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureItem_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureItemsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureItem
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"FeatureItem",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FeatureItem_type > r (
              dynamic_cast< FeatureItem_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->FeatureItem_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FeatureItemsType* FeatureItemsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureItemsType (*this, f, c);
    }

    FeatureItemsType& FeatureItemsType::
    operator= (const FeatureItemsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureItem_ = x.FeatureItem_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FeatureItemsType::
    ~FeatureItemsType ()
    {
    }

    // FeatureMeasurementsType
    //

    FeatureMeasurementsType::
    FeatureMeasurementsType ()
    : ::xml_schema::type (),
      FeatureMeasurement_ (this),
      n_ (this)
    {
    }

    FeatureMeasurementsType::
    FeatureMeasurementsType (const n_type& n)
    : ::xml_schema::type (),
      FeatureMeasurement_ (this),
      n_ (n, this)
    {
    }

    FeatureMeasurementsType::
    FeatureMeasurementsType (const FeatureMeasurementsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureMeasurement_ (x.FeatureMeasurement_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FeatureMeasurementsType::
    FeatureMeasurementsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureMeasurement_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureMeasurementsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureMeasurement
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"FeatureMeasurement",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FeatureMeasurement_type > r (
              dynamic_cast< FeatureMeasurement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->FeatureMeasurement_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FeatureMeasurementsType* FeatureMeasurementsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureMeasurementsType (*this, f, c);
    }

    FeatureMeasurementsType& FeatureMeasurementsType::
    operator= (const FeatureMeasurementsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureMeasurement_ = x.FeatureMeasurement_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FeatureMeasurementsType::
    ~FeatureMeasurementsType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircleFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"CircleFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircleFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircularArcFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularArcFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircularArcFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConeFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ConeFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConeFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConicalSegmentFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalSegmentFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConicalSegmentFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylinderFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"CylinderFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylinderFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylindricalSegmentFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalSegmentFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylindricalSegmentFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EdgePointFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"EdgePointFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EdgePointFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipseFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipseFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipseFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipticalArcFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticalArcFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipticalArcFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ElongatedCircleFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCircleFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ElongatedCircleFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ElongatedCylinderFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCylinderFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ElongatedCylinderFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ExtrudedCrossSectionFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ExtrudedCrossSectionFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ExtrudedCrossSectionFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GroupFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"GroupFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GroupFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LineFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"LineFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LineFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MarkingFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"MarkingFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MarkingFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeAngledLinesFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledLinesFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeAngledLinesFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeAngledPlanesFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledPlanesFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeAngledPlanesFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeParallelLinesFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelLinesFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeParallelLinesFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeParallelPlanesFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelPlanesFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeParallelPlanesFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherCurveFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherCurveFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherCurveFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherNonShapeFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherNonShapeFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherNonShapeFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherShapeFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherShapeFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherShapeFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherSurfaceFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherSurfaceFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherSurfaceFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureCircleDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircleDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureCircleDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureCircularArcDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircularArcDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureCircularArcDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureLinearDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureLinearDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureLinearDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureParallelogramDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureParallelogramDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureParallelogramDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PlaneFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PlaneFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PlaneFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointDefinedCurveFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedCurveFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointDefinedCurveFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointDefinedSurfaceFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedSurfaceFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointDefinedSurfaceFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PointFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphereFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"SphereFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphereFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericalSegmentFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalSegmentFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericalSegmentFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SurfaceOfRevolutionFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceOfRevolutionFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SurfaceOfRevolutionFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ThreadedFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadedFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ThreadedFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToroidalSegmentFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidalSegmentFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToroidalSegmentFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TorusFeatureDefinition_element_factory_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"TorusFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TorusFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircleFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"CircleFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircleFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircularArcFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularArcFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircularArcFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConeFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ConeFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConeFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConicalSegmentFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalSegmentFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConicalSegmentFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylinderFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"CylinderFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylinderFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylindricalSegmentFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalSegmentFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylindricalSegmentFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EdgePointFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"EdgePointFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EdgePointFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipseFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipseFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipseFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipticalArcFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticalArcFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipticalArcFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ElongatedCircleFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCircleFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ElongatedCircleFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ElongatedCylinderFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCylinderFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ElongatedCylinderFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ExtrudedCrossSectionFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ExtrudedCrossSectionFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ExtrudedCrossSectionFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GroupFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"GroupFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GroupFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LineFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"LineFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LineFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MarkingFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"MarkingFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MarkingFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeAngledLinesFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledLinesFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeAngledLinesFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeAngledPlanesFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledPlanesFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeAngledPlanesFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeParallelLinesFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelLinesFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeParallelLinesFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeParallelPlanesFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelPlanesFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeParallelPlanesFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherCurveFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherCurveFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherCurveFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherNonShapeFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherNonShapeFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherNonShapeFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherShapeFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherShapeFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherShapeFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherSurfaceFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherSurfaceFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherSurfaceFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureCircleNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircleNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureCircleNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureCircularArcNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircularArcNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureCircularArcNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureLinearNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureLinearNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureLinearNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureParallelogramNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureParallelogramNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureParallelogramNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PlaneFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PlaneFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PlaneFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointDefinedCurveFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedCurveFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointDefinedCurveFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointDefinedSurfaceFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedSurfaceFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointDefinedSurfaceFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PointFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphereFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"SphereFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphereFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericalSegmentFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalSegmentFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericalSegmentFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SurfaceOfRevolutionFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceOfRevolutionFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SurfaceOfRevolutionFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ThreadedFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadedFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ThreadedFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToroidalSegmentFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidalSegmentFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToroidalSegmentFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TorusFeatureNominal_element_factory_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"TorusFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TorusFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircleFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"CircleFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircleFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircularArcFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularArcFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircularArcFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConeFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ConeFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConeFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConicalSegmentFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalSegmentFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConicalSegmentFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylinderFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"CylinderFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylinderFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylindricalSegmentFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalSegmentFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylindricalSegmentFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EdgePointFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"EdgePointFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EdgePointFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipseFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipseFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipseFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipticalArcFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticalArcFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipticalArcFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ElongatedCircleFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCircleFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ElongatedCircleFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ElongatedCylinderFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCylinderFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ElongatedCylinderFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ExtrudedCrossSectionFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ExtrudedCrossSectionFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ExtrudedCrossSectionFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GroupFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"GroupFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GroupFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LineFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"LineFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LineFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MarkingFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"MarkingFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MarkingFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeAngledLinesFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledLinesFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeAngledLinesFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeAngledPlanesFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledPlanesFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeAngledPlanesFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeParallelLinesFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelLinesFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeParallelLinesFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeParallelPlanesFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelPlanesFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeParallelPlanesFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherCurveFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherCurveFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherCurveFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherNonShapeFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherNonShapeFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherNonShapeFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherShapeFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherShapeFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherShapeFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherSurfaceFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherSurfaceFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherSurfaceFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PlaneFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"PlaneFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PlaneFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointDefinedCurveFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedCurveFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointDefinedCurveFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointDefinedSurfaceFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedSurfaceFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointDefinedSurfaceFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"PointFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphereFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"SphereFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphereFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericalSegmentFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalSegmentFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericalSegmentFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SurfaceOfRevolutionFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceOfRevolutionFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SurfaceOfRevolutionFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ThreadedFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadedFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ThreadedFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToroidalSegmentFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidalSegmentFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToroidalSegmentFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TorusFeatureMeasurement_element_factory_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"TorusFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TorusFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircleFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"CircleFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircleFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CircularArcFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularArcFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CircularArcFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConeFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ConeFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConeFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ConicalSegmentFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalSegmentFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ConicalSegmentFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylinderFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"CylinderFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylinderFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_CylindricalSegmentFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalSegmentFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::CylindricalSegmentFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EdgePointFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"EdgePointFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EdgePointFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipseFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipseFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipseFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_EllipticalArcFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticalArcFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::EllipticalArcFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ElongatedCircleFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCircleFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ElongatedCircleFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ElongatedCylinderFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCylinderFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ElongatedCylinderFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ExtrudedCrossSectionFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ExtrudedCrossSectionFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ExtrudedCrossSectionFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_GroupFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"GroupFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::GroupFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LineFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"LineFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LineFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_MarkingFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"MarkingFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::MarkingFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeAngledLinesFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledLinesFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeAngledLinesFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeAngledPlanesFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledPlanesFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeAngledPlanesFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeParallelLinesFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelLinesFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeParallelLinesFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OppositeParallelPlanesFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelPlanesFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OppositeParallelPlanesFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherCurveFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherCurveFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherCurveFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherNonShapeFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherNonShapeFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherNonShapeFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherShapeFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherShapeFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherShapeFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_OtherSurfaceFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherSurfaceFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::OtherSurfaceFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureCircleItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircleItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureCircleItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureCircularArcItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircularArcItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureCircularArcItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureLinearItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureLinearItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureLinearItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PatternFeatureParallelogramItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureParallelogramItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PatternFeatureParallelogramItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PlaneFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PlaneFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PlaneFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointDefinedCurveFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedCurveFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointDefinedCurveFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointDefinedSurfaceFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedSurfaceFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointDefinedSurfaceFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_PointFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PointFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::PointFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphereFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"SphereFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphereFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SphericalSegmentFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalSegmentFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SphericalSegmentFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_SurfaceOfRevolutionFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceOfRevolutionFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::SurfaceOfRevolutionFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ThreadedFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadedFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ThreadedFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_ToroidalSegmentFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidalSegmentFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::ToroidalSegmentFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_TorusFeatureItem_element_factory_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"TorusFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::TorusFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZonePoint_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZonePoint",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZonePointType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneCurveLine_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneCurveLine",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneCurveLineType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneCurveCircular_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneCurveCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneCurveCircularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneCurveIrregular_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneCurveIrregular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneCurveIrregularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneAreaCircular_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneAreaCircularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneAreaRectangular_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaRectangular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneAreaRectangularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneAreaIrregular_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaIrregular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneAreaIrregularType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneAreaCylindrical_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaCylindrical",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneAreaCylindricalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneAreaSpherical_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaSpherical",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneAreaSphericalType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FeatureZoneAreaBetween_element_factory_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaBetween",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FeatureZoneAreaBetweenType >);


    // FeatureZoneListType
    //

    FeatureZoneListType::
    FeatureZoneListType ()
    : ::xml_schema::type (),
      FeatureZone_ (this),
      n_ (this)
    {
    }

    FeatureZoneListType::
    FeatureZoneListType (const n_type& n)
    : ::xml_schema::type (),
      FeatureZone_ (this),
      n_ (n, this)
    {
    }

    FeatureZoneListType::
    FeatureZoneListType (const FeatureZoneListType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureZone_ (x.FeatureZone_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FeatureZoneListType::
    FeatureZoneListType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureZone_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureZoneListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FeatureZone
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"FeatureZone",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FeatureZone_type > r (
              dynamic_cast< FeatureZone_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->FeatureZone_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FeatureZoneListType* FeatureZoneListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureZoneListType (*this, f, c);
    }

    FeatureZoneListType& FeatureZoneListType::
    operator= (const FeatureZoneListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureZone_ = x.FeatureZone_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FeatureZoneListType::
    ~FeatureZoneListType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const FeatureBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureBaseType& > (i);

      // FeatureNominalId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureNominalId ();
      }

      // ParentFeatureItemId
      //
      if (i.ParentFeatureItemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ParentFeatureItemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ParentFeatureItemId ();
      }

      // FeatureName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureName ();
      }

      // UUID
      //
      if (i.UUID ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UUID",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UUID ();
      }

      // NotableEventIds
      //
      if (i.NotableEventIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NotableEventIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NotableEventIds ();
      }

      // CoordinateSystemId
      //
      if (i.CoordinateSystemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CoordinateSystemId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ShapeFeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureItemBaseType& > (i);

      // PointList
      //
      if (i.PointList ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointList ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubstituteFeatureAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }

      // VirtualMeasurement
      //
      if (i.VirtualMeasurement ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VirtualMeasurement",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VirtualMeasurement ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NonShapeFeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureItemBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ShapeFeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureDefinitionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const NonShapeFeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureDefinitionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointSetNominalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasurePoint
      //
      for (PointSetNominalType::MeasurePoint_const_iterator
           b (i.MeasurePoint ().begin ()), n (i.MeasurePoint ().end ());
           b != n; ++b)
      {
        const PointSetNominalType::MeasurePoint_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurePoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NominalPointSetListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NominalPointSet
      //
      for (NominalPointSetListType::NominalPointSet_const_iterator
           b (i.NominalPointSet ().begin ()), n (i.NominalPointSet ().end ());
           b != n; ++b)
      {
        const NominalPointSetListType::NominalPointSet_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalPointSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureBaseType& > (i);

      // Name
      //
      if (i.Name ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Name",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Name ();
      }

      // UUID
      //
      if (i.UUID ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UUID",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UUID ();
      }

      // FeatureDefinitionId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureDefinitionId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureDefinitionId ();
      }

      // ParentFeatureNominalId
      //
      if (i.ParentFeatureNominalId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ParentFeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ParentFeatureNominalId ();
      }

      // EntityInternalIds
      //
      if (i.EntityInternalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EntityInternalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EntityInternalIds ();
      }

      // EntityExternalIds
      //
      if (i.EntityExternalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EntityExternalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EntityExternalIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ShapeFeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureNominalBaseType& > (i);

      // PointList
      //
      if (i.PointList ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointList ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubstituteFeatureAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NonShapeFeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureNominalBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredPointSetsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasuredPointSet
      //
      for (MeasuredPointSetsType::MeasuredPointSet_const_iterator
           b (i.MeasuredPointSet ().begin ()), n (i.MeasuredPointSet ().end ());
           b != n; ++b)
      {
        const MeasuredPointSetsType::MeasuredPointSet_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasuredPointSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointSetReferenceWholeType >
    _xsd_WholePointSetId_element_serializer_init (
      L"PointSetId",
      L"http://qifstandards.org/xsd/qif3",
      L"WholePointSetId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointSetReferenceWholeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointSetReferenceRangeType >
    _xsd_RangePointSetId_element_serializer_init (
      L"PointSetId",
      L"http://qifstandards.org/xsd/qif3",
      L"RangePointSetId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointSetReferenceRangeType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointSetReferenceSingleType >
    _xsd_SinglePointSetId_element_serializer_init (
      L"PointSetId",
      L"http://qifstandards.org/xsd/qif3",
      L"SinglePointSetId",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointSetReferenceSingleType >);


    void
    operator<< (xercesc::DOMElement& e, const PointListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointSetId
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (PointListType::PointSetId_const_iterator
             b (i.PointSetId ().begin ()), n (i.PointSetId ().end ());
             b != n; ++b)
        {
          const PointListType::PointSetId_type& x (*b);

          if (typeid (PointListType::PointSetId_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"PointSetId",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"PointSetId",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredPointSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Units
      //
      if (i.Units ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Units",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Units ();
      }

      // CoordinateSystemId
      //
      if (i.CoordinateSystemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CoordinateSystemId ();
      }

      // TranformId
      //
      if (i.TranformId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TranformId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TranformId ();
      }

      // Points
      //
      if (i.Points ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Points ();
      }

      // BinaryPoints
      //
      if (i.BinaryPoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryPoints ();
      }

      // Normals
      //
      if (i.Normals ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normals",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normals ();
      }

      // BinaryNormals
      //
      if (i.BinaryNormals ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryNormals",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryNormals ();
      }

      // Compensated
      //
      if (i.Compensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Compensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Compensated ();
      }

      // Compensations
      //
      if (i.Compensations ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Compensations",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Compensations ();
      }

      // BinaryCompensated
      //
      if (i.BinaryCompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryCompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryCompensated ();
      }

      // ProbeRadius
      //
      if (i.ProbeRadius ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProbeRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.ProbeRadius ());
      }

      // ProbeRadii
      //
      if (i.ProbeRadii ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProbeRadii",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ProbeRadii ();
      }

      // BinaryProbeRadii
      //
      if (i.BinaryProbeRadii ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryProbeRadii",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryProbeRadii ();
      }

      // MeasurementDeviceId
      //
      if (i.MeasurementDeviceId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceId ();
      }

      // SensorId
      //
      if (i.SensorId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SensorId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SensorId ();
      }

      // SensorIds
      //
      if (i.SensorIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SensorIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SensorIds ();
      }

      // BinarySensorIds
      //
      if (i.BinarySensorIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinarySensorIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinarySensorIds ();
      }

      // TipId
      //
      if (i.TipId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipId ();
      }

      // TipIds
      //
      if (i.TipIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TipIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TipIds ();
      }

      // BinaryTipIds
      //
      if (i.BinaryTipIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryTipIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryTipIds ();
      }

      // MeasurePointNominalIds
      //
      if (i.MeasurePointNominalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurePointNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurePointNominalIds ();
      }

      // BinaryMeasurePointNominalIds
      //
      if (i.BinaryMeasurePointNominalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryMeasurePointNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryMeasurePointNominalIds ();
      }

      // TimeStamp
      //
      if (i.TimeStamp ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeStamp",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeStamp ();
      }

      // TimeStamps
      //
      if (i.TimeStamps ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeStamps",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeStamps ();
      }

      // Quality
      //
      if (i.Quality ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Quality",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Quality ();
      }

      // BinaryQuality
      //
      if (i.BinaryQuality ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryQuality",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryQuality ();
      }

      // Deviations
      //
      if (i.Deviations ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Deviations",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Deviations ();
      }

      // BinaryDeviations
      //
      if (i.BinaryDeviations ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryDeviations",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryDeviations ();
      }

      // Colors
      //
      if (i.Colors ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Colors",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Colors ();
      }

      // BinaryColors
      //
      if (i.BinaryColors ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryColors",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryColors ();
      }

      // NumberOfFacets
      //
      if (i.NumberOfFacets ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfFacets",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NumberOfFacets ();
      }

      // PointIndices
      //
      if (i.PointIndices ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointIndices",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointIndices ();
      }

      // BinaryPointIndices
      //
      if (i.BinaryPointIndices ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BinaryPointIndices",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BinaryPointIndices ();
      }

      // count
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"count",
            e));

        a << i.count ();
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }

      // combinedUncertainty
      //
      if (i.combinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"combinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.combinedUncertainty ());
      }

      // meanError
      //
      if (i.meanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"meanError",
            e));

        a << ::xml_schema::as_decimal(*i.meanError ());
      }

      // xCombinedUncertainty
      //
      if (i.xCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.xCombinedUncertainty ());
      }

      // xMeanError
      //
      if (i.xMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.xMeanError ());
      }

      // yCombinedUncertainty
      //
      if (i.yCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.yCombinedUncertainty ());
      }

      // yMeanError
      //
      if (i.yMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.yMeanError ());
      }

      // zCombinedUncertainty
      //
      if (i.zCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.zCombinedUncertainty ());
      }

      // zMeanError
      //
      if (i.zMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.zMeanError ());
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureMeasurementBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureBaseType& > (i);

      // FeatureItemId
      //
      if (i.FeatureItemId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureItemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureItemId ();
      }

      // FeatureName
      //
      if (i.FeatureName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureName ();
      }

      // TimeStamp
      //
      if (i.TimeStamp ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeStamp",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeStamp ();
      }

      // ActualComponentId
      //
      if (i.ActualComponentId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActualComponentId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActualComponentId ();
      }

      // ManufacturingProcessId
      //
      if (i.ManufacturingProcessId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ManufacturingProcessId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ManufacturingProcessId ();
      }

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MeasurementDeviceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MeasurementDeviceIds ();
      }

      // ActualTransformId
      //
      if (i.ActualTransformId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ActualTransformId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ActualTransformId ();
      }

      // NotedEventIds
      //
      if (i.NotedEventIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NotedEventIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NotedEventIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ShapeFeatureMeasurementBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureMeasurementBaseType& > (i);

      // PointList
      //
      if (i.PointList ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointList ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SubstituteFeatureAlgorithm",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }

      // ProxyMeasurementId
      //
      if (i.ProxyMeasurementId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProxyMeasurementId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ProxyMeasurementId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const NonShapeFeatureMeasurementBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureMeasurementBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SetFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (xercesc::DOMAttr&, const SetFeatureType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const SetFeatureType&)
    {
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointList
      //
      if (i.PointList ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConstructionMethodBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NominalsCalculated
      //
      if (i.NominalsCalculated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalsCalculated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NominalsCalculated ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointRangeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Start
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Start",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Start ();
      }

      // Stop
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Stop",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Stop ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointIndexType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Single
      //
      if (i.Single ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Single",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Single ();
      }

      // Range
      //
      if (i.Range ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Range",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Range ();
      }

      // All
      //
      if (i.All ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"All",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.All ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BaseFeaturePointSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureId ();
      }

      // PointIndex
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointIndex",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointIndex ();
      }

      // ReferencedComponent
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferencedComponent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ReferencedComponent ();
      }

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BaseFeaturePointListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BaseFeaturePointSet
      //
      for (BaseFeaturePointListType::BaseFeaturePointSet_const_iterator
           b (i.BaseFeaturePointSet ().begin ()), n (i.BaseFeaturePointSet ().end ());
           b != n; ++b)
      {
        const BaseFeaturePointListType::BaseFeaturePointSet_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TransformationReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ReferencedComponent
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferencedComponent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ReferencedComponent ();
      }

      // CoordinateSystemId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoordinateSystemId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CoordinateSystemId ();
      }

      // SequenceNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SequenceNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceFeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureItemBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceFeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureDefinitionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceFeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureNominalBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceFeatureMeasurementBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureMeasurementBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CurveFeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureItemBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CurveFeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureDefinitionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CurveFeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureNominalBaseType& > (i);

      // SurfaceFeatureNominalId
      //
      if (i.SurfaceFeatureNominalId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfaceFeatureNominalId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CurveFeatureMeasurementBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureMeasurementBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureItemBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureDefinitionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureNominalBaseType& > (i);

      // SurfaceFeatureNominalId
      //
      if (i.SurfaceFeatureNominalId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfaceFeatureNominalId ();
      }

      // CurveFeatureNominalId
      //
      if (i.CurveFeatureNominalId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveFeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CurveFeatureNominalId ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureMeasurementBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureMeasurementBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SpecifiedFeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureItemBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SpecifiedFeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureDefinitionBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SpecifiedFeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureNominalBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SpecifiedFeatureMeasurementBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureMeasurementBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Intersection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Projection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Tangent
      //
      if (i.Tangent ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Tangent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Tangent ();
      }

      // TangentThrough
      //
      if (i.TangentThrough ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TangentThrough",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TangentThrough ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromCone
      //
      if (i.FromCone ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromCone",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromCone ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (CircleBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const CircleBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // IntersectionFeature
      //
      for (CircleIntersectionType::IntersectionFeature_const_iterator
           b (i.IntersectionFeature ().begin ()), n (i.IntersectionFeature ().end ());
           b != n; ++b)
      {
        const CircleIntersectionType::IntersectionFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleProjectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ProjectionCircle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionCircle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionCircle ();
      }

      // ProjectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionPlane ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCircle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCircle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCircle ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleTangentType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // TangentFeature
      //
      for (CircleTangentType::TangentFeature_const_iterator
           b (i.TangentFeature ().begin ()), n (i.TangentFeature ().end ());
           b != n; ++b)
      {
        const CircleTangentType::TangentFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TangentFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleTangentThroughType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // TangentFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TangentFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TangentFeature ();
      }

      // PointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCircle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCircle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCircle ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleFromConeType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // Distance
      //
      if (i.Distance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Distance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Distance ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircleFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircleFeatureItemType >
    _xsd_CircleFeatureItemType_type_serializer_init (
      L"CircleFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CircleFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircleFeatureDefinitionType >
    _xsd_CircleFeatureDefinitionType_type_serializer_init (
      L"CircleFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CircleFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Sweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircleFeatureNominalType >
    _xsd_CircleFeatureNominalType_type_serializer_init (
      L"CircleFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CircleFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircleFeatureMeasurementType >
    _xsd_CircleFeatureMeasurementType_type_serializer_init (
      L"CircleFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CircularArcConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Intersection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Intersection ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Projection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Extract",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Extract ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (CircularArcBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const CircularArcBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcProjectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ProjectionArc
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionArc",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionArc ();
      }

      // ProjectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionPlane ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseArc
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseArc",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseArc ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseArc
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseArc",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseArc ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // IntersectionFeature
      //
      for (CircularArcIntersectionType::IntersectionFeature_const_iterator
           b (i.IntersectionFeature ().begin ()), n (i.IntersectionFeature ().end ());
           b != n; ++b)
      {
        const CircularArcIntersectionType::IntersectionFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcExtractType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // CurveFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CurveFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CircularArcFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircularArcFeatureItemType >
    _xsd_CircularArcFeatureItemType_type_serializer_init (
      L"CircularArcFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CircularArcFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Radius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Radius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Radius ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircularArcFeatureDefinitionType >
    _xsd_CircularArcFeatureDefinitionType_type_serializer_init (
      L"CircularArcFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CircularArcFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // Sweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Sweep ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircularArcFeatureNominalType >
    _xsd_CircularArcFeatureNominalType_type_serializer_init (
      L"CircularArcFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CircularArcFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // Radius
      //
      if (i.Radius ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Radius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Radius ();
      }

      // RadiusMin
      //
      if (i.RadiusMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RadiusMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RadiusMin ();
      }

      // RadiusMax
      //
      if (i.RadiusMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RadiusMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RadiusMax ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CircularArcFeatureMeasurementType >
    _xsd_CircularArcFeatureMeasurementType_type_serializer_init (
      L"CircularArcFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConeConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ConeBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const ConeBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCone
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCone",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCone ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCone
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCone",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCone ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConeFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConeFeatureItemType >
    _xsd_ConeFeatureItemType_type_serializer_init (
      L"ConeFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConeFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // HalfAngle
      //
      if (i.HalfAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HalfAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HalfAngle ();
      }

      // FullAngle
      //
      if (i.FullAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FullAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FullAngle ();
      }

      // LargeEndDistance
      //
      if (i.LargeEndDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LargeEndDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LargeEndDistance ();
      }

      // SmallEndDistance
      //
      if (i.SmallEndDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SmallEndDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SmallEndDistance ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConeFeatureDefinitionType >
    _xsd_ConeFeatureDefinitionType_type_serializer_init (
      L"ConeFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConeFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Sweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConeFeatureNominalType >
    _xsd_ConeFeatureNominalType_type_serializer_init (
      L"ConeFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConeFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Axis ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // HalfAngle
      //
      if (i.HalfAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HalfAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HalfAngle ();
      }

      // FullAngle
      //
      if (i.FullAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FullAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FullAngle ();
      }

      // SmallEndDistance
      //
      if (i.SmallEndDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SmallEndDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SmallEndDistance ();
      }

      // LargeEndDistance
      //
      if (i.LargeEndDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LargeEndDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LargeEndDistance ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConeFeatureMeasurementType >
    _xsd_ConeFeatureMeasurementType_type_serializer_init (
      L"ConeFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ConicalSegmentBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const ConicalSegmentBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseConicalSegment
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseConicalSegment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseConicalSegment ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseConicalSegment
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseConicalSegment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseConicalSegment ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConicalSegmentFeatureItemType >
    _xsd_ConicalSegmentFeatureItemType_type_serializer_init (
      L"ConicalSegmentFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // HalfAngle
      //
      if (i.HalfAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HalfAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HalfAngle ();
      }

      // FullAngle
      //
      if (i.FullAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FullAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FullAngle ();
      }

      // LargeEndDistance
      //
      if (i.LargeEndDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LargeEndDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LargeEndDistance ();
      }

      // SmallEndDistance
      //
      if (i.SmallEndDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SmallEndDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SmallEndDistance ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConicalSegmentFeatureDefinitionType >
    _xsd_ConicalSegmentFeatureDefinitionType_type_serializer_init (
      L"ConicalSegmentFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Sweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConicalSegmentFeatureNominalType >
    _xsd_ConicalSegmentFeatureNominalType_type_serializer_init (
      L"ConicalSegmentFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ConicalSegmentFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Axis ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // HalfAngle
      //
      if (i.HalfAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HalfAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HalfAngle ();
      }

      // FullAngle
      //
      if (i.FullAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FullAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FullAngle ();
      }

      // SmallEndDistance
      //
      if (i.SmallEndDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SmallEndDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SmallEndDistance ();
      }

      // LargeEndDistance
      //
      if (i.LargeEndDistance ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LargeEndDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LargeEndDistance ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConicalSegmentFeatureMeasurementType >
    _xsd_ConicalSegmentFeatureMeasurementType_type_serializer_init (
      L"ConicalSegmentFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylinderConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (CylinderBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const CylinderBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCylinder
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCylinder",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCylinder ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCylinder
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCylinder",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCylinder ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylinderFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylinderFeatureItemType >
    _xsd_CylinderFeatureItemType_type_serializer_init (
      L"CylinderFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylinderFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Bottom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Bottom ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylinderFeatureDefinitionType >
    _xsd_CylinderFeatureDefinitionType_type_serializer_init (
      L"CylinderFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylinderFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Sweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylinderFeatureNominalType >
    _xsd_CylinderFeatureNominalType_type_serializer_init (
      L"CylinderFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylinderFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Axis ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylinderFeatureMeasurementType >
    _xsd_CylinderFeatureMeasurementType_type_serializer_init (
      L"CylinderFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (CylindricalSegmentBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const CylindricalSegmentBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCylindricalSegment
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCylindricalSegment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCylindricalSegment ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCylindricalSegment
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCylindricalSegment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCylindricalSegment ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylindricalSegmentFeatureItemType >
    _xsd_CylindricalSegmentFeatureItemType_type_serializer_init (
      L"CylindricalSegmentFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Bottom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Bottom ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylindricalSegmentFeatureDefinitionType >
    _xsd_CylindricalSegmentFeatureDefinitionType_type_serializer_init (
      L"CylindricalSegmentFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Sweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylindricalSegmentFeatureNominalType >
    _xsd_CylindricalSegmentFeatureNominalType_type_serializer_init (
      L"CylindricalSegmentFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const CylindricalSegmentFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Axis ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CylindricalSegmentFeatureMeasurementType >
    _xsd_CylindricalSegmentFeatureMeasurementType_type_serializer_init (
      L"CylindricalSegmentFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EdgePointConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgePointCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseEdgePoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseEdgePoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseEdgePoint ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgePointCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgePointTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseEdgePoint
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseEdgePoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseEdgePoint ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgePointFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // PatchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PatchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PatchRadius ();
      }

      // Distance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Distance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Distance ();
      }

      // Depth
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Depth ();
      }

      // RetrievalMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RetrievalMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RetrievalMethod ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgePointCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgePointCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgePointMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgePointFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::PointFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EdgePointFeatureItemType >
    _xsd_EdgePointFeatureItemType_type_serializer_init (
      L"EdgePointFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EdgePointFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::PointFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EdgePointFeatureDefinitionType >
    _xsd_EdgePointFeatureDefinitionType_type_serializer_init (
      L"EdgePointFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EdgePointFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::PointFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // AdjacentNormal
      //
      if (i.AdjacentNormal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AdjacentNormal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AdjacentNormal ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EdgePointFeatureNominalType >
    _xsd_EdgePointFeatureNominalType_type_serializer_init (
      L"EdgePointFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EdgePointFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::PointFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // AdjacentNormal
      //
      if (i.AdjacentNormal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AdjacentNormal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AdjacentNormal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EdgePointFeatureMeasurementType >
    _xsd_EdgePointFeatureMeasurementType_type_serializer_init (
      L"EdgePointFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipseConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Intersection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Projection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (EllipseBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const EllipseBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseProjectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ProjectionFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionFeature ();
      }

      // ProjectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionPlane ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // IntersectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionPlane ();
      }

      // IntersectionFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseEllipse
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseEllipse",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseEllipse ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseEllipse
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseEllipse",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseEllipse ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipseFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipseFeatureItemType >
    _xsd_EllipseFeatureItemType_type_serializer_init (
      L"EllipseFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipseFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // MajorDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MajorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MajorDiameter ();
      }

      // MinorDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinorDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipseFeatureDefinitionType >
    _xsd_EllipseFeatureDefinitionType_type_serializer_init (
      L"EllipseFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipseFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Sweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipseFeatureNominalType >
    _xsd_EllipseFeatureNominalType_type_serializer_init (
      L"EllipseFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipseFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Axis ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }

      // MajorDiameter
      //
      if (i.MajorDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MajorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MajorDiameter ();
      }

      // MinorDiameter
      //
      if (i.MinorDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinorDiameter ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipseFeatureMeasurementType >
    _xsd_EllipseFeatureMeasurementType_type_serializer_init (
      L"EllipseFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Intersection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Projection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (EllipticalArcBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const EllipticalArcBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcProjectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ProjectionFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionFeature ();
      }

      // ProjectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionPlane ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // IntersectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionPlane ();
      }

      // IntersectionFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseEllipticalArc
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseEllipticalArc",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseEllipticalArc ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseEllipticalArc
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseEllipticalArc",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseEllipticalArc ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipticalArcFeatureItemType >
    _xsd_EllipticalArcFeatureItemType_type_serializer_init (
      L"EllipticalArcFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // MajorDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MajorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MajorDiameter ();
      }

      // MinorDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinorDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipticalArcFeatureDefinitionType >
    _xsd_EllipticalArcFeatureDefinitionType_type_serializer_init (
      L"EllipticalArcFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Sweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Sweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipticalArcFeatureNominalType >
    _xsd_EllipticalArcFeatureNominalType_type_serializer_init (
      L"EllipticalArcFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const EllipticalArcFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Axis ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }

      // MajorDiameter
      //
      if (i.MajorDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MajorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MajorDiameter ();
      }

      // MinorDiameter
      //
      if (i.MinorDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinorDiameter ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EllipticalArcFeatureMeasurementType >
    _xsd_EllipticalArcFeatureMeasurementType_type_serializer_init (
      L"EllipticalArcFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ElongatedCircleBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const ElongatedCircleBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseElongatedCircle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseElongatedCircle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseElongatedCircle ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseElongatedCircle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseElongatedCircle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseElongatedCircle ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ElongatedCircleFeatureItemType >
    _xsd_ElongatedCircleFeatureItemType_type_serializer_init (
      L"ElongatedCircleFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Length ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ElongatedCircleFeatureDefinitionType >
    _xsd_ElongatedCircleFeatureDefinitionType_type_serializer_init (
      L"ElongatedCircleFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // CenterLine
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterLine ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ElongatedCircleFeatureNominalType >
    _xsd_ElongatedCircleFeatureNominalType_type_serializer_init (
      L"ElongatedCircleFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCircleFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // CenterLine
      //
      if (i.CenterLine ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CenterLine ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMax ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMin ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ElongatedCircleFeatureMeasurementType >
    _xsd_ElongatedCircleFeatureMeasurementType_type_serializer_init (
      L"ElongatedCircleFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ElongatedCylinderBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const ElongatedCylinderBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseElongatedCylinder
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseElongatedCylinder",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseElongatedCylinder ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseElongatedCylinder
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseElongatedCylinder",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseElongatedCylinder ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ElongatedCylinderFeatureItemType >
    _xsd_ElongatedCylinderFeatureItemType_type_serializer_init (
      L"ElongatedCylinderFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Length ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Depth ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ElongatedCylinderFeatureDefinitionType >
    _xsd_ElongatedCylinderFeatureDefinitionType_type_serializer_init (
      L"ElongatedCylinderFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // CenterPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterPlane ();
      }

      // DepthVector
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DepthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DepthVector ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ElongatedCylinderFeatureNominalType >
    _xsd_ElongatedCylinderFeatureNominalType_type_serializer_init (
      L"ElongatedCylinderFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ElongatedCylinderFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // CenterPlane
      //
      if (i.CenterPlane ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CenterPlane ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMax ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMin ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Depth ();
      }

      // DepthMax
      //
      if (i.DepthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DepthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DepthMax ();
      }

      // DepthMin
      //
      if (i.DepthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DepthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DepthMin ();
      }

      // DepthVector
      //
      if (i.DepthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DepthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DepthVector ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ElongatedCylinderFeatureMeasurementType >
    _xsd_ElongatedCylinderFeatureMeasurementType_type_serializer_init (
      L"ElongatedCylinderFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ExtrudedCrossSectionBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const ExtrudedCrossSectionBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseExtrudedCrossSection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseExtrudedCrossSection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseExtrudedCrossSection ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseExtrudedCrossSection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseExtrudedCrossSection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseExtrudedCrossSection ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ExtrudedCrossSectionFeatureItemType >
    _xsd_ExtrudedCrossSectionFeatureItemType_type_serializer_init (
      L"ExtrudedCrossSectionFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Length
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Length ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ExtrudedCrossSectionFeatureDefinitionType >
    _xsd_ExtrudedCrossSectionFeatureDefinitionType_type_serializer_init (
      L"ExtrudedCrossSectionFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Direction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Direction ();
      }

      // CrossSectionReferenceFeatureId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CrossSectionReferenceFeatureId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CrossSectionReferenceFeatureId ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ExtrudedCrossSectionFeatureNominalType >
    _xsd_ExtrudedCrossSectionFeatureNominalType_type_serializer_init (
      L"ExtrudedCrossSectionFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ExtrudedCrossSectionFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Direction
      //
      if (i.Direction ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Direction ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ExtrudedCrossSectionFeatureMeasurementType >
    _xsd_ExtrudedCrossSectionFeatureMeasurementType_type_serializer_init (
      L"ExtrudedCrossSectionFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LineConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Midline
      //
      if (i.Midline ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Midline",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Midline ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Intersection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Projection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Projection ();
      }

      // Perpendicular
      //
      if (i.Perpendicular ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Perpendicular",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Perpendicular ();
      }

      // Parallel
      //
      if (i.Parallel ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Parallel",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Parallel ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // TangentThrough
      //
      if (i.TangentThrough ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TangentThrough",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TangentThrough ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Extract",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Extract ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (LineBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const LineBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineMidlineType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseLine
      //
      for (LineMidlineType::BaseLine_const_iterator
           b (i.BaseLine ().begin ()), n (i.BaseLine ().end ());
           b != n; ++b)
      {
        const LineMidlineType::BaseLine_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // IntersectionFeature
      //
      for (LineIntersectionType::IntersectionFeature_const_iterator
           b (i.IntersectionFeature ().begin ()), n (i.IntersectionFeature ().end ());
           b != n; ++b)
      {
        const LineIntersectionType::IntersectionFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineProjectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ProjectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionPlane ();
      }

      // ProjectionLine
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionLine ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinePerpendicularType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // PerpendicularFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PerpendicularFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PerpendicularFeature ();
      }

      // PointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineParallelType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ParallelFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ParallelFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ParallelFeature ();
      }

      // PointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseLine
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseLine ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineTangentThroughType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // TangentFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TangentFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TangentFeature ();
      }

      // PointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseLine
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseLine ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineExtractType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // CurveFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CurveFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LineFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LineFeatureItemType >
    _xsd_LineFeatureItemType_type_serializer_init (
      L"LineFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LineFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LineFeatureDefinitionType >
    _xsd_LineFeatureDefinitionType_type_serializer_init (
      L"LineFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LineFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // Direction
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Direction ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LineFeatureNominalType >
    _xsd_LineFeatureNominalType_type_serializer_init (
      L"LineFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LineFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Direction
      //
      if (i.Direction ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Direction",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Direction ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LineFeatureMeasurementType >
    _xsd_LineFeatureMeasurementType_type_serializer_init (
      L"LineFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Intersection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Projection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (OppositeParallelLinesBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const OppositeParallelLinesBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // IntersectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionPlane ();
      }

      // IntersectionFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesProjectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ProjectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionPlane ();
      }

      // ProjectionOppositeParallelLines
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionOppositeParallelLines",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionOppositeParallelLines ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOppositeParallelLines
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOppositeParallelLines",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOppositeParallelLines ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOppositeParallelLines
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOppositeParallelLines",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOppositeParallelLines ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeParallelLinesFeatureItemType >
    _xsd_OppositeParallelLinesFeatureItemType_type_serializer_init (
      L"OppositeParallelLinesFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Width
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Width ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // EndType
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndType",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndType ();
      }

      // SingleOpenEnd
      //
      if (i.SingleOpenEnd ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SingleOpenEnd",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SingleOpenEnd ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius2 ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeParallelLinesFeatureDefinitionType >
    _xsd_OppositeParallelLinesFeatureDefinitionType_type_serializer_init (
      L"OppositeParallelLinesFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // CenterLine
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterLine ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeParallelLinesFeatureNominalType >
    _xsd_OppositeParallelLinesFeatureNominalType_type_serializer_init (
      L"OppositeParallelLinesFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelLinesFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // CenterLine
      //
      if (i.CenterLine ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CenterLine ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // Width
      //
      if (i.Width ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Width ();
      }

      // WidthMin
      //
      if (i.WidthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WidthMin ();
      }

      // WidthMax
      //
      if (i.WidthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WidthMax ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMin ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMax ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius2 ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeParallelLinesFeatureMeasurementType >
    _xsd_OppositeParallelLinesFeatureMeasurementType_type_serializer_init (
      L"OppositeParallelLinesFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Intersection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Projection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (OppositeAngledLinesBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const OppositeAngledLinesBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // IntersectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionPlane ();
      }

      // IntersectionFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IntersectionFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesProjectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ProjectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionPlane ();
      }

      // ProjectionOppositeAngledLines
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionOppositeAngledLines",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionOppositeAngledLines ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOppositeAngledLines
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOppositeAngledLines",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOppositeAngledLines ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOppositeAngledLines
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOppositeAngledLines",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOppositeAngledLines ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeAngledLinesFeatureItemType >
    _xsd_OppositeAngledLinesFeatureItemType_type_serializer_init (
      L"OppositeAngledLinesFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Width
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Width ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // EndType
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndType",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndType ();
      }

      // TaperAngle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TaperAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TaperAngle ();
      }

      // SingleOpenEnd
      //
      if (i.SingleOpenEnd ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SingleOpenEnd",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SingleOpenEnd ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius2 ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeAngledLinesFeatureDefinitionType >
    _xsd_OppositeAngledLinesFeatureDefinitionType_type_serializer_init (
      L"OppositeAngledLinesFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // CenterLine
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterLine ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeAngledLinesFeatureNominalType >
    _xsd_OppositeAngledLinesFeatureNominalType_type_serializer_init (
      L"OppositeAngledLinesFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledLinesFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // CenterLine
      //
      if (i.CenterLine ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CenterLine ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // Width
      //
      if (i.Width ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Width ();
      }

      // WidthMin
      //
      if (i.WidthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WidthMin ();
      }

      // WidthMax
      //
      if (i.WidthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WidthMax ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMin ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMax ();
      }

      // TaperAngle
      //
      if (i.TaperAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TaperAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TaperAngle ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius2 ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeAngledLinesFeatureMeasurementType >
    _xsd_OppositeAngledLinesFeatureMeasurementType_type_serializer_init (
      L"OppositeAngledLinesFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (OppositeParallelPlanesBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const OppositeParallelPlanesBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOppositeParallelPlanes
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOppositeParallelPlanes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOppositeParallelPlanes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOppositeParallelPlanes
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOppositeParallelPlanes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOppositeParallelPlanes ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeParallelPlanesFeatureItemType >
    _xsd_OppositeParallelPlanesFeatureItemType_type_serializer_init (
      L"OppositeParallelPlanesFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Width
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Width ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // EndType
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndType",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndType ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Depth ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Bottom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Bottom ();
      }

      // SingleOpenEnd
      //
      if (i.SingleOpenEnd ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SingleOpenEnd",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SingleOpenEnd ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius2 ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeParallelPlanesFeatureDefinitionType >
    _xsd_OppositeParallelPlanesFeatureDefinitionType_type_serializer_init (
      L"OppositeParallelPlanesFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // CenterPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterPlane ();
      }

      // LengthVector
      //
      if (i.LengthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthVector ();
      }

      // DepthVector
      //
      if (i.DepthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DepthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DepthVector ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeParallelPlanesFeatureNominalType >
    _xsd_OppositeParallelPlanesFeatureNominalType_type_serializer_init (
      L"OppositeParallelPlanesFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeParallelPlanesFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // CenterPlane
      //
      if (i.CenterPlane ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CenterPlane ();
      }

      // LengthVector
      //
      if (i.LengthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthVector ();
      }

      // DepthVector
      //
      if (i.DepthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DepthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DepthVector ();
      }

      // Width
      //
      if (i.Width ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Width ();
      }

      // WidthMin
      //
      if (i.WidthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WidthMin ();
      }

      // WidthMax
      //
      if (i.WidthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WidthMax ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMin ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMax ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Depth ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius2 ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeParallelPlanesFeatureMeasurementType >
    _xsd_OppositeParallelPlanesFeatureMeasurementType_type_serializer_init (
      L"OppositeParallelPlanesFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (OppositeAngledPlanesBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const OppositeAngledPlanesBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOppositeAngledPlanes
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOppositeAngledPlanes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOppositeAngledPlanes ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOppositeAngledPlanes
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOppositeAngledPlanes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOppositeAngledPlanes ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeAngledPlanesFeatureItemType >
    _xsd_OppositeAngledPlanesFeatureItemType_type_serializer_init (
      L"OppositeAngledPlanesFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Width
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Width ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // EndType
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndType",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EndType ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Depth ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Bottom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Bottom ();
      }

      // SingleOpenEnd
      //
      if (i.SingleOpenEnd ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SingleOpenEnd",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SingleOpenEnd ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius2 ();
      }

      // TaperAngle
      //
      if (i.TaperAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TaperAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TaperAngle ();
      }

      // DraftAngle
      //
      if (i.DraftAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DraftAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DraftAngle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeAngledPlanesFeatureDefinitionType >
    _xsd_OppositeAngledPlanesFeatureDefinitionType_type_serializer_init (
      L"OppositeAngledPlanesFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // CenterPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CenterPlane ();
      }

      // LengthVector
      //
      if (i.LengthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthVector ();
      }

      // DepthVector
      //
      if (i.DepthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DepthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DepthVector ();
      }

      // DraftVector
      //
      if (i.DraftVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DraftVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DraftVector ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeAngledPlanesFeatureNominalType >
    _xsd_OppositeAngledPlanesFeatureNominalType_type_serializer_init (
      L"OppositeAngledPlanesFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OppositeAngledPlanesFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // CenterPlane
      //
      if (i.CenterPlane ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CenterPlane ();
      }

      // LengthVector
      //
      if (i.LengthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthVector ();
      }

      // DepthVector
      //
      if (i.DepthVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DepthVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DepthVector ();
      }

      // Width
      //
      if (i.Width ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Width",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Width ();
      }

      // WidthMin
      //
      if (i.WidthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WidthMin ();
      }

      // WidthMax
      //
      if (i.WidthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WidthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.WidthMax ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMin ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LengthMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LengthMax ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Depth",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Depth ();
      }

      // TaperAngle
      //
      if (i.TaperAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TaperAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TaperAngle ();
      }

      // DraftAngle
      //
      if (i.DraftAngle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DraftAngle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DraftAngle ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius1",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EndRadius2",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EndRadius2 ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OppositeAngledPlanesFeatureMeasurementType >
    _xsd_OppositeAngledPlanesFeatureMeasurementType_type_serializer_init (
      L"OppositeAngledPlanesFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherCurveConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherCurveFeatureCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOtherCurveFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOtherCurveFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOtherCurveFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherCurveCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherCurveCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherCurveMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherCurveFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherCurveFeatureItemType >
    _xsd_OtherCurveFeatureItemType_type_serializer_init (
      L"OtherCurveFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherCurveFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherCurveFeatureDefinitionType >
    _xsd_OtherCurveFeatureDefinitionType_type_serializer_init (
      L"OtherCurveFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherCurveFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherCurveFeatureNominalType >
    _xsd_OtherCurveFeatureNominalType_type_serializer_init (
      L"OtherCurveFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherCurveFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherCurveFeatureMeasurementType >
    _xsd_OtherCurveFeatureMeasurementType_type_serializer_init (
      L"OtherCurveFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherNonShapeFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::NonShapeFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherNonShapeFeatureItemType >
    _xsd_OtherNonShapeFeatureItemType_type_serializer_init (
      L"OtherNonShapeFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherNonShapeFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::NonShapeFeatureDefinitionBaseType& > (i);

      // Description
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Description ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherNonShapeFeatureDefinitionType >
    _xsd_OtherNonShapeFeatureDefinitionType_type_serializer_init (
      L"OtherNonShapeFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherNonShapeFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::NonShapeFeatureNominalBaseType& > (i);

      // ReferenceFeatureNominalIds
      //
      if (i.ReferenceFeatureNominalIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferenceFeatureNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ReferenceFeatureNominalIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherNonShapeFeatureNominalType >
    _xsd_OtherNonShapeFeatureNominalType_type_serializer_init (
      L"OtherNonShapeFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherNonShapeFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::NonShapeFeatureMeasurementBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherNonShapeFeatureMeasurementType >
    _xsd_OtherNonShapeFeatureMeasurementType_type_serializer_init (
      L"OtherNonShapeFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MarkingMethodEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const MarkingMethodEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const MarkingMethodEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const MarkingMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MarkingMethodEnum
      //
      if (i.MarkingMethodEnum ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MarkingMethodEnum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MarkingMethodEnum ();
      }

      // OtherMarkingMethod
      //
      if (i.OtherMarkingMethod ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherMarkingMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherMarkingMethod ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MarkingFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::NonShapeFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MarkingFeatureItemType >
    _xsd_MarkingFeatureItemType_type_serializer_init (
      L"MarkingFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MarkingFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::NonShapeFeatureDefinitionBaseType& > (i);

      // Text
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Text",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Text ();
      }

      // MarkingMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MarkingMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MarkingMethod ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MarkingFeatureDefinitionType >
    _xsd_MarkingFeatureDefinitionType_type_serializer_init (
      L"MarkingFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MarkingFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::NonShapeFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MarkingFeatureNominalType >
    _xsd_MarkingFeatureNominalType_type_serializer_init (
      L"MarkingFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const MarkingFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::NonShapeFeatureMeasurementBaseType& > (i);

      // Text
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Text",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Text ();
      }

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, MarkingFeatureMeasurementType >
    _xsd_MarkingFeatureMeasurementType_type_serializer_init (
      L"MarkingFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherShapeConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherShapeFeatureCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOtherShapeFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOtherShapeFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOtherShapeFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherShapeCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherShapeCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherShapeMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherShapeFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherShapeFeatureItemType >
    _xsd_OtherShapeFeatureItemType_type_serializer_init (
      L"OtherShapeFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherShapeFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureDefinitionBaseType& > (i);

      // Description
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Description",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Description ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherShapeFeatureDefinitionType >
    _xsd_OtherShapeFeatureDefinitionType_type_serializer_init (
      L"OtherShapeFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherShapeFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureNominalBaseType& > (i);

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherShapeFeatureNominalType >
    _xsd_OtherShapeFeatureNominalType_type_serializer_init (
      L"OtherShapeFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherShapeFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureMeasurementBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherShapeFeatureMeasurementType >
    _xsd_OtherShapeFeatureMeasurementType_type_serializer_init (
      L"OtherShapeFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceFeatureCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseOtherSurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseOtherSurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseOtherSurfaceFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherSurfaceFeatureItemType >
    _xsd_OtherSurfaceFeatureItemType_type_serializer_init (
      L"OtherSurfaceFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherSurfaceFeatureDefinitionType >
    _xsd_OtherSurfaceFeatureDefinitionType_type_serializer_init (
      L"OtherSurfaceFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // PolyLine
      //
      if (i.PolyLine ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PolyLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PolyLine ();
      }

      // ClosedSurface
      //
      if (i.ClosedSurface ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ClosedSurface",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ClosedSurface ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherSurfaceFeatureNominalType >
    _xsd_OtherSurfaceFeatureNominalType_type_serializer_init (
      L"OtherSurfaceFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const OtherSurfaceFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // PolyLine
      //
      if (i.PolyLine ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PolyLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PolyLine ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OtherSurfaceFeatureMeasurementType >
    _xsd_OtherSurfaceFeatureMeasurementType_type_serializer_init (
      L"OtherSurfaceFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PlaneConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Midplane
      //
      if (i.Midplane ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Midplane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Midplane ();
      }

      // Offset
      //
      if (i.Offset ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Offset",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Offset ();
      }

      // Perpendicular
      //
      if (i.Perpendicular ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Perpendicular",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Perpendicular ();
      }

      // Parallel
      //
      if (i.Parallel ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Parallel",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Parallel ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // TangentThrough
      //
      if (i.TangentThrough ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TangentThrough",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TangentThrough ();
      }

      // Through
      //
      if (i.Through ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Through",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Through ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Extract",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Extract ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PlaneBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const PlaneBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneMidplaneType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      for (PlaneMidplaneType::BasePlane_const_iterator
           b (i.BasePlane ().begin ()), n (i.BasePlane ().end ());
           b != n; ++b)
      {
        const PlaneMidplaneType::BasePlane_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneOffsetType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePlane ();
      }

      // Offset
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Offset",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Offset ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlanePerpendicularType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // PerpendicularFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PerpendicularFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PerpendicularFeature ();
      }

      // PointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneParallelType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ParallelFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ParallelFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ParallelFeature ();
      }

      // PointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePlane ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneTangentThroughType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // TangentFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TangentFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.TangentFeature ();
      }

      // PointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneThroughType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PlaneThroughType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const PlaneThroughType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePlane ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneExtractType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PlaneFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PlaneFeatureItemType >
    _xsd_PlaneFeatureItemType_type_serializer_init (
      L"PlaneFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PlaneFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PlaneFeatureDefinitionType >
    _xsd_PlaneFeatureDefinitionType_type_serializer_init (
      L"PlaneFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PlaneFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // PolyLine
      //
      if (i.PolyLine ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PolyLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PolyLine ();
      }

      // Rectangle
      //
      if (i.Rectangle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Rectangle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Rectangle ();
      }

      // Circle
      //
      if (i.Circle ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Circle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Circle ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PlaneFeatureNominalType >
    _xsd_PlaneFeatureNominalType_type_serializer_init (
      L"PlaneFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PlaneFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // PolyLine
      //
      if (i.PolyLine ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PolyLine",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PolyLine ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PlaneFeatureMeasurementType >
    _xsd_PlaneFeatureMeasurementType_type_serializer_init (
      L"PlaneFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Extract",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Extract ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PointDefinedCurveBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const PointDefinedCurveBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePointDefinedCurve
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePointDefinedCurve",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePointDefinedCurve ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePointDefinedCurve
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePointDefinedCurve",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePointDefinedCurve ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveExtractType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // CurveFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CurveFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointDefinedCurveFeatureItemType >
    _xsd_PointDefinedCurveFeatureItemType_type_serializer_init (
      L"PointDefinedCurveFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointDefinedCurveFeatureDefinitionType >
    _xsd_PointDefinedCurveFeatureDefinitionType_type_serializer_init (
      L"PointDefinedCurveFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureNominalBaseType& > (i);

      // DefiningPoints
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefiningPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefiningPoints ();
      }

      // Plane
      //
      if (i.Plane ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Plane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Plane ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointDefinedCurveFeatureNominalType >
    _xsd_PointDefinedCurveFeatureNominalType_type_serializer_init (
      L"PointDefinedCurveFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DefiningPointsMeasurementType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DefiningPoint
      //
      for (DefiningPointsMeasurementType::DefiningPoint_const_iterator
           b (i.DefiningPoint ().begin ()), n (i.DefiningPoint ().end ());
           b != n; ++b)
      {
        const DefiningPointsMeasurementType::DefiningPoint_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefiningPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }

      // combinedUncertainty
      //
      if (i.combinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"combinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.combinedUncertainty ());
      }

      // meanError
      //
      if (i.meanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"meanError",
            e));

        a << ::xml_schema::as_decimal(*i.meanError ());
      }

      // xCombinedUncertainty
      //
      if (i.xCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.xCombinedUncertainty ());
      }

      // xMeanError
      //
      if (i.xMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.xMeanError ());
      }

      // yCombinedUncertainty
      //
      if (i.yCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.yCombinedUncertainty ());
      }

      // yMeanError
      //
      if (i.yMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.yMeanError ());
      }

      // zCombinedUncertainty
      //
      if (i.zCombinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.zCombinedUncertainty ());
      }

      // zMeanError
      //
      if (i.zMeanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.zMeanError ());
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedCurveFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::CurveFeatureMeasurementBaseType& > (i);

      // DefiningPoints
      //
      if (i.DefiningPoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefiningPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DefiningPoints ();
      }

      // Plane
      //
      if (i.Plane ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Plane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Plane ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointDefinedCurveFeatureMeasurementType >
    _xsd_PointDefinedCurveFeatureMeasurementType_type_serializer_init (
      L"PointDefinedCurveFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Extract",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Extract ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PointDefinedSurfaceBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const PointDefinedSurfaceBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePointDefinedSurface
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePointDefinedSurface",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePointDefinedSurface ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePointDefinedSurface
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePointDefinedSurface",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePointDefinedSurface ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceExtractType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointDefinedSurfaceFeatureItemType >
    _xsd_PointDefinedSurfaceFeatureItemType_type_serializer_init (
      L"PointDefinedSurfaceFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointDefinedSurfaceFeatureDefinitionType >
    _xsd_PointDefinedSurfaceFeatureDefinitionType_type_serializer_init (
      L"PointDefinedSurfaceFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const DefiningPointsNominalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DefiningPoint
      //
      for (DefiningPointsNominalType::DefiningPoint_const_iterator
           b (i.DefiningPoint ().begin ()), n (i.DefiningPoint ().end ());
           b != n; ++b)
      {
        const DefiningPointsNominalType::DefiningPoint_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefiningPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"zValidity",
            e));

        a << *i.zValidity ();
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // DefiningPoints
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefiningPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DefiningPoints ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointDefinedSurfaceFeatureNominalType >
    _xsd_PointDefinedSurfaceFeatureNominalType_type_serializer_init (
      L"PointDefinedSurfaceFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointDefinedSurfaceFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // DefiningPoints
      //
      if (i.DefiningPoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DefiningPoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DefiningPoints ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointDefinedSurfaceFeatureMeasurementType >
    _xsd_PointDefinedSurfaceFeatureMeasurementType_type_serializer_init (
      L"PointDefinedSurfaceFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Intersection
      //
      if (i.Intersection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Intersection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Projection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromCone
      //
      if (i.FromCone ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromCone",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromCone ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }

      // CenterOfGravity
      //
      if (i.CenterOfGravity ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CenterOfGravity",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CenterOfGravity ();
      }

      // Pierce
      //
      if (i.Pierce ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Pierce",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Pierce ();
      }

      // MidPoint
      //
      if (i.MidPoint ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MidPoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MidPoint ();
      }

      // MovePoint
      //
      if (i.MovePoint ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MovePoint",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MovePoint ();
      }

      // MovePointVector
      //
      if (i.MovePointVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MovePointVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MovePointVector ();
      }

      // MovePointAxis
      //
      if (i.MovePointAxis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MovePointAxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MovePointAxis ();
      }

      // Extreme
      //
      if (i.Extreme ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Extreme",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Extreme ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // IntersectionFeature
      //
      for (PointFeatureIntersectionType::IntersectionFeature_const_iterator
           b (i.IntersectionFeature ().begin ()), n (i.IntersectionFeature ().end ());
           b != n; ++b)
      {
        const PointFeatureIntersectionType::IntersectionFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IntersectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeaturePierceType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // CurveFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CurveFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureProjectionType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // ProjectionPlane
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionPlane",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionPlane ();
      }

      // ProjectionFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ProjectionFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ProjectionFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureFromConeType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCone
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCone",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCone ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePointFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BasePointFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BasePointFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BasePointFeature ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // RetrievalMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RetrievalMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RetrievalMethod ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureCenterOfGravityType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PointFeatureCenterOfGravityType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const PointFeatureCenterOfGravityType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureMidPointType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PointFeatureMidPointType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const PointFeatureMidPointType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureMovePointType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }

      // Offset
      //
      if (i.Offset ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Offset",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Offset ();
      }

      // DirectionalOffset
      //
      if (i.DirectionalOffset ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DirectionalOffset",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DirectionalOffset ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureMovePointVectorType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }

      // Distance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Distance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Distance ();
      }

      // Vector
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Vector ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureMovePointAxisType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseLocationFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseLocationFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseLocationFeature ();
      }

      // Distance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Distance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Distance ();
      }

      // BaseAxisFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseAxisFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseAxisFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureExtremeType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }

      // Minimum
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Minimum",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Minimum ();
      }

      // BaseAxisFeature
      //
      if (i.BaseAxisFeature ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseAxisFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BaseAxisFeature ();
      }

      // Vector
      //
      if (i.Vector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Vector ();
      }

      // Radial
      //
      if (i.Radial ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Radial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Radial ();
      }

      // Xaxis
      //
      if (i.Xaxis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Xaxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Xaxis ();
      }

      // Yaxis
      //
      if (i.Yaxis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Yaxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Yaxis ();
      }

      // Zaxis
      //
      if (i.Zaxis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Zaxis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Zaxis ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::PointFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointFeatureItemType >
    _xsd_PointFeatureItemType_type_serializer_init (
      L"PointFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::PointFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointFeatureDefinitionType >
    _xsd_PointFeatureDefinitionType_type_serializer_init (
      L"PointFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::PointFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointFeatureNominalType >
    _xsd_PointFeatureNominalType_type_serializer_init (
      L"PointFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PointFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::PointFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PointFeatureMeasurementType >
    _xsd_PointFeatureMeasurementType_type_serializer_init (
      L"PointFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphereConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (SphereBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const SphereBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseSphere
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseSphere",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseSphere ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseSphere
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseSphere",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseSphere ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }

      // Vector
      //
      if (i.Vector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Vector ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphereFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphereFeatureItemType >
    _xsd_SphereFeatureItemType_type_serializer_init (
      L"SphereFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphereFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphereFeatureDefinitionType >
    _xsd_SphereFeatureDefinitionType_type_serializer_init (
      L"SphereFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphereFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // LatitudeLongitudeSweep
      //
      if (i.LatitudeLongitudeSweep ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphereFeatureNominalType >
    _xsd_SphereFeatureNominalType_type_serializer_init (
      L"SphereFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphereFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // LatitudeLongitudeSweepMeasurementRange
      //
      if (i.LatitudeLongitudeSweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweepMeasurementRange ();
      }

      // LatitudeLongitudeSweepFull
      //
      if (i.LatitudeLongitudeSweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphereFeatureMeasurementType >
    _xsd_SphereFeatureMeasurementType_type_serializer_init (
      L"SphereFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (SphericalSegmentBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const SphericalSegmentBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseSphericalSegment
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseSphericalSegment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseSphericalSegment ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseSphericalSegment
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseSphericalSegment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseSphericalSegment ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericalSegmentFeatureItemType >
    _xsd_SphericalSegmentFeatureItemType_type_serializer_init (
      L"SphericalSegmentFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericalSegmentFeatureDefinitionType >
    _xsd_SphericalSegmentFeatureDefinitionType_type_serializer_init (
      L"SphericalSegmentFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // LatitudeLongitudeSweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LatitudeLongitudeSweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericalSegmentFeatureNominalType >
    _xsd_SphericalSegmentFeatureNominalType_type_serializer_init (
      L"SphericalSegmentFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SphericalSegmentFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMin",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DiameterMax",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DiameterMax ();
      }

      // LatitudeLongitudeSweepMeasurementRange
      //
      if (i.LatitudeLongitudeSweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweepMeasurementRange ();
      }

      // LatitudeLongitudeSweepFull
      //
      if (i.LatitudeLongitudeSweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SphericalSegmentFeatureMeasurementType >
    _xsd_SphericalSegmentFeatureMeasurementType_type_serializer_init (
      L"SphericalSegmentFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (SurfaceOfRevolutionBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const SurfaceOfRevolutionBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseSurfaceOfRevolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseSurfaceOfRevolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseSurfaceOfRevolution ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseSurfaceOfRevolution
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseSurfaceOfRevolution",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseSurfaceOfRevolution ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SurfaceOfRevolutionFeatureItemType >
    _xsd_SurfaceOfRevolutionFeatureItemType_type_serializer_init (
      L"SurfaceOfRevolutionFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SurfaceOfRevolutionFeatureDefinitionType >
    _xsd_SurfaceOfRevolutionFeatureDefinitionType_type_serializer_init (
      L"SurfaceOfRevolutionFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Sweep ();
      }

      // ReferenceFeatureNominalId
      //
      if (i.ReferenceFeatureNominalId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferenceFeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ReferenceFeatureNominalId ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SurfaceOfRevolutionFeatureNominalType >
    _xsd_SurfaceOfRevolutionFeatureNominalType_type_serializer_init (
      L"SurfaceOfRevolutionFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const SurfaceOfRevolutionFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Axis ();
      }

      // SweepMeasurementRange
      //
      if (i.SweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepMeasurementRange ();
      }

      // SweepFull
      //
      if (i.SweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SweepFull ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SurfaceOfRevolutionFeatureMeasurementType >
    _xsd_SurfaceOfRevolutionFeatureMeasurementType_type_serializer_init (
      L"SurfaceOfRevolutionFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromCylinder
      //
      if (i.FromCylinder ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromCylinder",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromCylinder ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ThreadedFeatureBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const ThreadedFeatureBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseThreadedFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseThreadedFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseThreadedFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseThreadedFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseThreadedFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseThreadedFeature ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureFromCylinderType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseCylinder
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseCylinder",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseCylinder ();
      }

      // Offset
      //
      if (i.Offset ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Offset",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Offset ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ThreadedFeatureItemType >
    _xsd_ThreadedFeatureItemType_type_serializer_init (
      L"ThreadedFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // ThreadSpecificationId
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ThreadSpecificationId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ThreadSpecificationId ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Bottom",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Bottom ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ThreadedFeatureDefinitionType >
    _xsd_ThreadedFeatureDefinitionType_type_serializer_init (
      L"ThreadedFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedFeatureNominalBaseType& > (i);

      // Axis
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Axis ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ThreadedFeatureNominalType >
    _xsd_ThreadedFeatureNominalType_type_serializer_init (
      L"ThreadedFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ThreadedFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedFeatureMeasurementBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Axis",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Axis ();
      }

      // PitchDiameter
      //
      if (i.PitchDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PitchDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PitchDiameter ();
      }

      // FunctionalSize
      //
      if (i.FunctionalSize ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FunctionalSize",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FunctionalSize ();
      }

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Length ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ThreadedFeatureMeasurementType >
    _xsd_ThreadedFeatureMeasurementType_type_serializer_init (
      L"ThreadedFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ToroidalSegmentBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const ToroidalSegmentBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseToroidalSegment
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseToroidalSegment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseToroidalSegment ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseToroidalSegment
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseToroidalSegment",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseToroidalSegment ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToroidalSegmentFeatureItemType >
    _xsd_ToroidalSegmentFeatureItemType_type_serializer_init (
      L"ToroidalSegmentFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // MinorDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinorDiameter ();
      }

      // MajorDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MajorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MajorDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToroidalSegmentFeatureDefinitionType >
    _xsd_ToroidalSegmentFeatureDefinitionType_type_serializer_init (
      L"ToroidalSegmentFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // AxisVector
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AxisVector ();
      }

      // LatitudeLongitudeSweep
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LatitudeLongitudeSweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToroidalSegmentFeatureNominalType >
    _xsd_ToroidalSegmentFeatureNominalType_type_serializer_init (
      L"ToroidalSegmentFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ToroidalSegmentFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // AxisVector
      //
      if (i.AxisVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AxisVector ();
      }

      // MinorDiameter
      //
      if (i.MinorDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinorDiameter ();
      }

      // MajorDiameter
      //
      if (i.MajorDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MajorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MajorDiameter ();
      }

      // LatitudeLongitudeSweepMeasurementRange
      //
      if (i.LatitudeLongitudeSweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweepMeasurementRange ();
      }

      // LatitudeLongitudeSweepFull
      //
      if (i.LatitudeLongitudeSweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ToroidalSegmentFeatureMeasurementType >
    _xsd_ToroidalSegmentFeatureMeasurementType_type_serializer_init (
      L"ToroidalSegmentFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TorusConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BestFit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Recompensated",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Copy",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cast",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromScan",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusBestFitType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (TorusBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        const TorusBestFitType::BaseFeature_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusRecompType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeaturePointList",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusCopyType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseTorus
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseTorus",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseTorus ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusCastType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusTransformType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // BaseTorus
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BaseTorus",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BaseTorus ();
      }

      // Transformation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transformation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusFromScanType& i)
    {
      e << static_cast< const ::xsd::qif30::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeature",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SearchRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Measured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CheckDetails",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusMeasurementDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Checked",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Set",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TorusFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DeterminationMode",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TorusFeatureItemType >
    _xsd_TorusFeatureItemType_type_serializer_init (
      L"TorusFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TorusFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"InternalExternal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.InternalExternal ();
      }

      // MinorDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MinorDiameter ();
      }

      // MajorDiameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MajorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.MajorDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TorusFeatureDefinitionType >
    _xsd_TorusFeatureDefinitionType_type_serializer_init (
      L"TorusFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TorusFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureNominalBaseType& > (i);

      // Location
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Location ();
      }

      // AxisVector
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AxisVector ();
      }

      // LatitudeLongitudeSweep
      //
      if (i.LatitudeLongitudeSweep ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweep",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweep ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Constructed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Constructed ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TorusFeatureNominalType >
    _xsd_TorusFeatureNominalType_type_serializer_init (
      L"TorusFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const TorusFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::SurfaceFeatureMeasurementBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Location",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Location ();
      }

      // AxisVector
      //
      if (i.AxisVector ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AxisVector",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AxisVector ();
      }

      // MinorDiameter
      //
      if (i.MinorDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MinorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MinorDiameter ();
      }

      // MajorDiameter
      //
      if (i.MajorDiameter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MajorDiameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MajorDiameter ();
      }

      // LatitudeLongitudeSweepMeasurementRange
      //
      if (i.LatitudeLongitudeSweepMeasurementRange ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweepMeasurementRange",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweepMeasurementRange ();
      }

      // LatitudeLongitudeSweepFull
      //
      if (i.LatitudeLongitudeSweepFull ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LatitudeLongitudeSweepFull",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LatitudeLongitudeSweepFull ();
      }

      // Form
      //
      if (i.Form ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Form",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TorusFeatureMeasurementType >
    _xsd_TorusFeatureMeasurementType_type_serializer_init (
      L"TorusFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GroupFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GroupFeatureItemType >
    _xsd_GroupFeatureItemType_type_serializer_init (
      L"GroupFeatureItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GroupFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureDefinitionBaseType& > (i);

      // IsProfileGroup
      //
      if (i.IsProfileGroup ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IsProfileGroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.IsProfileGroup ();
      }

      // IsRunoutGroup
      //
      if (i.IsRunoutGroup ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IsRunoutGroup",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.IsRunoutGroup ();
      }

      // IsCountersunkHole
      //
      if (i.IsCountersunkHole ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IsCountersunkHole",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.IsCountersunkHole ();
      }

      // IsCounterboredHole
      //
      if (i.IsCounterboredHole ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IsCounterboredHole",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.IsCounterboredHole ();
      }

      // IsSpotface
      //
      if (i.IsSpotface ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IsSpotface",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.IsSpotface ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GroupFeatureDefinitionType >
    _xsd_GroupFeatureDefinitionType_type_serializer_init (
      L"GroupFeatureDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GroupFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureNominalBaseType& > (i);

      // FeatureNominalIds
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureNominalIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FeatureNominalIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GroupFeatureNominalType >
    _xsd_GroupFeatureNominalType_type_serializer_init (
      L"GroupFeatureNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const GroupFeatureMeasurementType& i)
    {
      e << static_cast< const ::xsd::qif30::ShapeFeatureMeasurementBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, GroupFeatureMeasurementType >
    _xsd_GroupFeatureMeasurementType_type_serializer_init (
      L"GroupFeatureMeasurementType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GroupFeatureItemType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GroupFeatureDefinitionType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::GroupFeatureNominalType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureLinearItemType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureLinearItemType >
    _xsd_PatternFeatureLinearItemType_type_serializer_init (
      L"PatternFeatureLinearItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureLinearDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureDefinitionBaseType& > (i);

      // LineDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LineDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.LineDirection ();
      }

      // IncrementalDistance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IncrementalDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IncrementalDistance ();
      }

      // FeatureDirection
      //
      if (i.FeatureDirection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureDirection ();
      }

      // NumberOfFeatures
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfFeatures",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfFeatures ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureLinearDefinitionType >
    _xsd_PatternFeatureLinearDefinitionType_type_serializer_init (
      L"PatternFeatureLinearDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureLinearNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureNominalBaseType& > (i);

      // FirstFeatureLocation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FirstFeatureLocation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FirstFeatureLocation ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureLinearNominalType >
    _xsd_PatternFeatureLinearNominalType_type_serializer_init (
      L"PatternFeatureLinearNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureParallelogramItemType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureParallelogramItemType >
    _xsd_PatternFeatureParallelogramItemType_type_serializer_init (
      L"PatternFeatureParallelogramItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureParallelogramDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureDefinitionBaseType& > (i);

      // AlongRowDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AlongRowDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.AlongRowDirection ();
      }

      // IncrementalRowDistance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IncrementalRowDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IncrementalRowDistance ();
      }

      // BetweenRowDirection
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BetweenRowDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.BetweenRowDirection ();
      }

      // RowSeparationDistance
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RowSeparationDistance",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.RowSeparationDistance ();
      }

      // FeatureDirection
      //
      if (i.FeatureDirection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureDirection ();
      }

      // NumberOfFeaturesPerRow
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfFeaturesPerRow",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfFeaturesPerRow ();
      }

      // NumberOfRows
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfRows",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfRows ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureParallelogramDefinitionType >
    _xsd_PatternFeatureParallelogramDefinitionType_type_serializer_init (
      L"PatternFeatureParallelogramDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureParallelogramNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureNominalBaseType& > (i);

      // FirstFeatureLocation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FirstFeatureLocation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FirstFeatureLocation ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureParallelogramNominalType >
    _xsd_PatternFeatureParallelogramNominalType_type_serializer_init (
      L"PatternFeatureParallelogramNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureCircularArcItemType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureCircularArcItemType >
    _xsd_PatternFeatureCircularArcItemType_type_serializer_init (
      L"PatternFeatureCircularArcItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureCircularArcDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureDefinitionBaseType& > (i);

      // ArcRadius
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ArcRadius",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.ArcRadius ();
      }

      // IncrementalArc
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"IncrementalArc",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.IncrementalArc ();
      }

      // FeatureDirection
      //
      if (i.FeatureDirection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureDirection ();
      }

      // NumberOfFeatures
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfFeatures",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfFeatures ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureCircularArcDefinitionType >
    _xsd_PatternFeatureCircularArcDefinitionType_type_serializer_init (
      L"PatternFeatureCircularArcDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureCircularArcNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureNominalBaseType& > (i);

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Center
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Center",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Center ();
      }

      // FirstFeatureLocation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FirstFeatureLocation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FirstFeatureLocation ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureCircularArcNominalType >
    _xsd_PatternFeatureCircularArcNominalType_type_serializer_init (
      L"PatternFeatureCircularArcNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureCircleItemType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureCircleItemType >
    _xsd_PatternFeatureCircleItemType_type_serializer_init (
      L"PatternFeatureCircleItemType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureCircleDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureDefinitionBaseType& > (i);

      // Diameter
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Diameter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Diameter ();
      }

      // FeatureDirection
      //
      if (i.FeatureDirection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureDirection ();
      }

      // NumberOfFeatures
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NumberOfFeatures",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.NumberOfFeatures ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureCircleDefinitionType >
    _xsd_PatternFeatureCircleDefinitionType_type_serializer_init (
      L"PatternFeatureCircleDefinitionType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const PatternFeatureCircleNominalType& i)
    {
      e << static_cast< const ::xsd::qif30::PatternFeatureNominalBaseType& > (i);

      // Normal
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Normal ();
      }

      // Center
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Center",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Center ();
      }

      // FirstFeatureLocation
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FirstFeatureLocation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.FirstFeatureLocation ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PatternFeatureCircleNominalType >
    _xsd_PatternFeatureCircleNominalType_type_serializer_init (
      L"PatternFeatureCircleNominalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Attributes",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Attributes ();
      }

      // Label
      //
      if (i.Label ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Label",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Label ();
      }

      // SurfaceFeatureNominalId
      //
      if (i.SurfaceFeatureNominalId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SurfaceFeatureNominalId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SurfaceFeatureNominalId ();
      }

      // id
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureZonePointType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneBaseType& > (i);

      // VertexId
      //
      if (i.VertexId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VertexId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VertexId ();
      }

      // PointId
      //
      if (i.PointId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointId ();
      }

      // Point
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Point ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZonePointType >
    _xsd_FeatureZonePointType_type_serializer_init (
      L"FeatureZonePointType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneCurveBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneBaseType& > (i);

      // EdgeIds
      //
      if (i.EdgeIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgeIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EdgeIds ();
      }

      // CurveIds
      //
      if (i.CurveIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CurveIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneCurveLineType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneCurveBaseType& > (i);

      // Line
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Line",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Line ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneCurveLineType >
    _xsd_FeatureZoneCurveLineType_type_serializer_init (
      L"FeatureZoneCurveLineType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneCurveCircularType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneCurveBaseType& > (i);

      // Circle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Circle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Circle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneCurveCircularType >
    _xsd_FeatureZoneCurveCircularType_type_serializer_init (
      L"FeatureZoneCurveCircularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneCurveIrregularType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneCurveBaseType& > (i);

      // CurvePoints
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurvePoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CurvePoints ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneCurveIrregularType >
    _xsd_FeatureZoneCurveIrregularType_type_serializer_init (
      L"FeatureZoneCurveIrregularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneAreaBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneBaseType& > (i);

      // FaceIds
      //
      if (i.FaceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FaceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FaceIds ();
      }

      // EdgeIds
      //
      if (i.EdgeIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgeIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EdgeIds ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneAreaCircularType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneAreaBaseType& > (i);

      // Circle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Circle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Circle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneAreaCircularType >
    _xsd_FeatureZoneAreaCircularType_type_serializer_init (
      L"FeatureZoneAreaCircularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneAreaRectangularType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneAreaBaseType& > (i);

      // Rectangle
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Rectangle",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Rectangle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneAreaRectangularType >
    _xsd_FeatureZoneAreaRectangularType_type_serializer_init (
      L"FeatureZoneAreaRectangularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneAreaIrregularType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneAreaBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneAreaIrregularType >
    _xsd_FeatureZoneAreaIrregularType_type_serializer_init (
      L"FeatureZoneAreaIrregularType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneAreaCylindricalType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneAreaBaseType& > (i);

      // Cylinder
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Cylinder",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Cylinder ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneAreaCylindricalType >
    _xsd_FeatureZoneAreaCylindricalType_type_serializer_init (
      L"FeatureZoneAreaCylindricalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneAreaBetweenType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneAreaBaseType& > (i);

      // FromPointZoneId
      //
      if (i.FromPointZoneId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromPointZoneId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromPointZoneId ();
      }

      // FromCurveZoneId
      //
      if (i.FromCurveZoneId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FromCurveZoneId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FromCurveZoneId ();
      }

      // ToPointZoneId
      //
      if (i.ToPointZoneId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToPointZoneId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToPointZoneId ();
      }

      // ToCurveZoneId
      //
      if (i.ToCurveZoneId ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ToCurveZoneId",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ToCurveZoneId ();
      }

      // StartDirection
      //
      if (i.StartDirection ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StartDirection",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StartDirection ();
      }

      // PlaneNormal
      //
      if (i.PlaneNormal ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PlaneNormal",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PlaneNormal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneAreaBetweenType >
    _xsd_FeatureZoneAreaBetweenType_type_serializer_init (
      L"FeatureZoneAreaBetweenType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneAreaSphericalType& i)
    {
      e << static_cast< const ::xsd::qif30::FeatureZoneAreaBaseType& > (i);

      // Sphere
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Sphere",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Sphere ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FeatureZoneAreaSphericalType >
    _xsd_FeatureZoneAreaSphericalType_type_serializer_init (
      L"FeatureZoneAreaSphericalType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FeatureAspectsListsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureDefinitions
      //
      if (i.FeatureDefinitions ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureDefinitions",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureDefinitions ();
      }

      // FeatureNominals
      //
      if (i.FeatureNominals ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureNominals",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureNominals ();
      }

      // FeatureItems
      //
      if (i.FeatureItems ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FeatureItems",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FeatureItems ();
      }

      // NominalPointSets
      //
      if (i.NominalPointSets ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NominalPointSets",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NominalPointSets ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureDefinitionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureDefinition
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (FeatureDefinitionsType::FeatureDefinition_const_iterator
             b (i.FeatureDefinition ().begin ()), n (i.FeatureDefinition ().end ());
             b != n; ++b)
        {
          const FeatureDefinitionsType::FeatureDefinition_type& x (*b);

          if (typeid (FeatureDefinitionsType::FeatureDefinition_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"FeatureDefinition",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"FeatureDefinition",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureNominalsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureNominal
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (FeatureNominalsType::FeatureNominal_const_iterator
             b (i.FeatureNominal ().begin ()), n (i.FeatureNominal ().end ());
             b != n; ++b)
        {
          const FeatureNominalsType::FeatureNominal_type& x (*b);

          if (typeid (FeatureNominalsType::FeatureNominal_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"FeatureNominal",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"FeatureNominal",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureItemsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureItem
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (FeatureItemsType::FeatureItem_const_iterator
             b (i.FeatureItem ().begin ()), n (i.FeatureItem ().end ());
             b != n; ++b)
        {
          const FeatureItemsType::FeatureItem_type& x (*b);

          if (typeid (FeatureItemsType::FeatureItem_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"FeatureItem",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"FeatureItem",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FeatureMeasurementsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureMeasurement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (FeatureMeasurementsType::FeatureMeasurement_const_iterator
             b (i.FeatureMeasurement ().begin ()), n (i.FeatureMeasurement ().end ());
             b != n; ++b)
        {
          const FeatureMeasurementsType::FeatureMeasurement_type& x (*b);

          if (typeid (FeatureMeasurementsType::FeatureMeasurement_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"FeatureMeasurement",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"FeatureMeasurement",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircleFeatureDefinitionType >
    _xsd_CircleFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"CircleFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircleFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircularArcFeatureDefinitionType >
    _xsd_CircularArcFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularArcFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircularArcFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConeFeatureDefinitionType >
    _xsd_ConeFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ConeFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConeFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConicalSegmentFeatureDefinitionType >
    _xsd_ConicalSegmentFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalSegmentFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConicalSegmentFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylinderFeatureDefinitionType >
    _xsd_CylinderFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"CylinderFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylinderFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylindricalSegmentFeatureDefinitionType >
    _xsd_CylindricalSegmentFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalSegmentFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylindricalSegmentFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EdgePointFeatureDefinitionType >
    _xsd_EdgePointFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"EdgePointFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EdgePointFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipseFeatureDefinitionType >
    _xsd_EllipseFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipseFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipseFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipticalArcFeatureDefinitionType >
    _xsd_EllipticalArcFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticalArcFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipticalArcFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ElongatedCircleFeatureDefinitionType >
    _xsd_ElongatedCircleFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCircleFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ElongatedCircleFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ElongatedCylinderFeatureDefinitionType >
    _xsd_ElongatedCylinderFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCylinderFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ElongatedCylinderFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ExtrudedCrossSectionFeatureDefinitionType >
    _xsd_ExtrudedCrossSectionFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ExtrudedCrossSectionFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ExtrudedCrossSectionFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GroupFeatureDefinitionType >
    _xsd_GroupFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"GroupFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GroupFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LineFeatureDefinitionType >
    _xsd_LineFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"LineFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LineFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MarkingFeatureDefinitionType >
    _xsd_MarkingFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"MarkingFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MarkingFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeAngledLinesFeatureDefinitionType >
    _xsd_OppositeAngledLinesFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledLinesFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeAngledLinesFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeAngledPlanesFeatureDefinitionType >
    _xsd_OppositeAngledPlanesFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledPlanesFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeAngledPlanesFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeParallelLinesFeatureDefinitionType >
    _xsd_OppositeParallelLinesFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelLinesFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeParallelLinesFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeParallelPlanesFeatureDefinitionType >
    _xsd_OppositeParallelPlanesFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelPlanesFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeParallelPlanesFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherCurveFeatureDefinitionType >
    _xsd_OtherCurveFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherCurveFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherCurveFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherNonShapeFeatureDefinitionType >
    _xsd_OtherNonShapeFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherNonShapeFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherNonShapeFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherShapeFeatureDefinitionType >
    _xsd_OtherShapeFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherShapeFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherShapeFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherSurfaceFeatureDefinitionType >
    _xsd_OtherSurfaceFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherSurfaceFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherSurfaceFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureCircleDefinitionType >
    _xsd_PatternFeatureCircleDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircleDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureCircleDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureCircularArcDefinitionType >
    _xsd_PatternFeatureCircularArcDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircularArcDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureCircularArcDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureLinearDefinitionType >
    _xsd_PatternFeatureLinearDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureLinearDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureLinearDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureParallelogramDefinitionType >
    _xsd_PatternFeatureParallelogramDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureParallelogramDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureParallelogramDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PlaneFeatureDefinitionType >
    _xsd_PlaneFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PlaneFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PlaneFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointDefinedCurveFeatureDefinitionType >
    _xsd_PointDefinedCurveFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedCurveFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointDefinedCurveFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointDefinedSurfaceFeatureDefinitionType >
    _xsd_PointDefinedSurfaceFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedSurfaceFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointDefinedSurfaceFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointFeatureDefinitionType >
    _xsd_PointFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"PointFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphereFeatureDefinitionType >
    _xsd_SphereFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"SphereFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphereFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericalSegmentFeatureDefinitionType >
    _xsd_SphericalSegmentFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalSegmentFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericalSegmentFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SurfaceOfRevolutionFeatureDefinitionType >
    _xsd_SurfaceOfRevolutionFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceOfRevolutionFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SurfaceOfRevolutionFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ThreadedFeatureDefinitionType >
    _xsd_ThreadedFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadedFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ThreadedFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToroidalSegmentFeatureDefinitionType >
    _xsd_ToroidalSegmentFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidalSegmentFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToroidalSegmentFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TorusFeatureDefinitionType >
    _xsd_TorusFeatureDefinition_element_serializer_init (
      L"FeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      L"TorusFeatureDefinition",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TorusFeatureDefinitionType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircleFeatureNominalType >
    _xsd_CircleFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"CircleFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircleFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircularArcFeatureNominalType >
    _xsd_CircularArcFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularArcFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircularArcFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConeFeatureNominalType >
    _xsd_ConeFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ConeFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConeFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConicalSegmentFeatureNominalType >
    _xsd_ConicalSegmentFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalSegmentFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConicalSegmentFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylinderFeatureNominalType >
    _xsd_CylinderFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"CylinderFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylinderFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylindricalSegmentFeatureNominalType >
    _xsd_CylindricalSegmentFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalSegmentFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylindricalSegmentFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EdgePointFeatureNominalType >
    _xsd_EdgePointFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"EdgePointFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EdgePointFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipseFeatureNominalType >
    _xsd_EllipseFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipseFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipseFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipticalArcFeatureNominalType >
    _xsd_EllipticalArcFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticalArcFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipticalArcFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ElongatedCircleFeatureNominalType >
    _xsd_ElongatedCircleFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCircleFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ElongatedCircleFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ElongatedCylinderFeatureNominalType >
    _xsd_ElongatedCylinderFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCylinderFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ElongatedCylinderFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ExtrudedCrossSectionFeatureNominalType >
    _xsd_ExtrudedCrossSectionFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ExtrudedCrossSectionFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ExtrudedCrossSectionFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GroupFeatureNominalType >
    _xsd_GroupFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"GroupFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GroupFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LineFeatureNominalType >
    _xsd_LineFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"LineFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LineFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MarkingFeatureNominalType >
    _xsd_MarkingFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"MarkingFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MarkingFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeAngledLinesFeatureNominalType >
    _xsd_OppositeAngledLinesFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledLinesFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeAngledLinesFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeAngledPlanesFeatureNominalType >
    _xsd_OppositeAngledPlanesFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledPlanesFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeAngledPlanesFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeParallelLinesFeatureNominalType >
    _xsd_OppositeParallelLinesFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelLinesFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeParallelLinesFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeParallelPlanesFeatureNominalType >
    _xsd_OppositeParallelPlanesFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelPlanesFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeParallelPlanesFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherCurveFeatureNominalType >
    _xsd_OtherCurveFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherCurveFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherCurveFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherNonShapeFeatureNominalType >
    _xsd_OtherNonShapeFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherNonShapeFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherNonShapeFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherShapeFeatureNominalType >
    _xsd_OtherShapeFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherShapeFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherShapeFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherSurfaceFeatureNominalType >
    _xsd_OtherSurfaceFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherSurfaceFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherSurfaceFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureCircleNominalType >
    _xsd_PatternFeatureCircleNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircleNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureCircleNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureCircularArcNominalType >
    _xsd_PatternFeatureCircularArcNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircularArcNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureCircularArcNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureLinearNominalType >
    _xsd_PatternFeatureLinearNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureLinearNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureLinearNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureParallelogramNominalType >
    _xsd_PatternFeatureParallelogramNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureParallelogramNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureParallelogramNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PlaneFeatureNominalType >
    _xsd_PlaneFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PlaneFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PlaneFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointDefinedCurveFeatureNominalType >
    _xsd_PointDefinedCurveFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedCurveFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointDefinedCurveFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointDefinedSurfaceFeatureNominalType >
    _xsd_PointDefinedSurfaceFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedSurfaceFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointDefinedSurfaceFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointFeatureNominalType >
    _xsd_PointFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"PointFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphereFeatureNominalType >
    _xsd_SphereFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"SphereFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphereFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericalSegmentFeatureNominalType >
    _xsd_SphericalSegmentFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalSegmentFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericalSegmentFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SurfaceOfRevolutionFeatureNominalType >
    _xsd_SurfaceOfRevolutionFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceOfRevolutionFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SurfaceOfRevolutionFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ThreadedFeatureNominalType >
    _xsd_ThreadedFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadedFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ThreadedFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToroidalSegmentFeatureNominalType >
    _xsd_ToroidalSegmentFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidalSegmentFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToroidalSegmentFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TorusFeatureNominalType >
    _xsd_TorusFeatureNominal_element_serializer_init (
      L"FeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      L"TorusFeatureNominal",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TorusFeatureNominalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircleFeatureMeasurementType >
    _xsd_CircleFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"CircleFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircleFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircularArcFeatureMeasurementType >
    _xsd_CircularArcFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularArcFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircularArcFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConeFeatureMeasurementType >
    _xsd_ConeFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ConeFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConeFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConicalSegmentFeatureMeasurementType >
    _xsd_ConicalSegmentFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalSegmentFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConicalSegmentFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylinderFeatureMeasurementType >
    _xsd_CylinderFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"CylinderFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylinderFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylindricalSegmentFeatureMeasurementType >
    _xsd_CylindricalSegmentFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalSegmentFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylindricalSegmentFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EdgePointFeatureMeasurementType >
    _xsd_EdgePointFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"EdgePointFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EdgePointFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipseFeatureMeasurementType >
    _xsd_EllipseFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipseFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipseFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipticalArcFeatureMeasurementType >
    _xsd_EllipticalArcFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticalArcFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipticalArcFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ElongatedCircleFeatureMeasurementType >
    _xsd_ElongatedCircleFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCircleFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ElongatedCircleFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ElongatedCylinderFeatureMeasurementType >
    _xsd_ElongatedCylinderFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCylinderFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ElongatedCylinderFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ExtrudedCrossSectionFeatureMeasurementType >
    _xsd_ExtrudedCrossSectionFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ExtrudedCrossSectionFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ExtrudedCrossSectionFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GroupFeatureMeasurementType >
    _xsd_GroupFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"GroupFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GroupFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LineFeatureMeasurementType >
    _xsd_LineFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"LineFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LineFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MarkingFeatureMeasurementType >
    _xsd_MarkingFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"MarkingFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MarkingFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeAngledLinesFeatureMeasurementType >
    _xsd_OppositeAngledLinesFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledLinesFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeAngledLinesFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeAngledPlanesFeatureMeasurementType >
    _xsd_OppositeAngledPlanesFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledPlanesFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeAngledPlanesFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeParallelLinesFeatureMeasurementType >
    _xsd_OppositeParallelLinesFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelLinesFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeParallelLinesFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeParallelPlanesFeatureMeasurementType >
    _xsd_OppositeParallelPlanesFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelPlanesFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeParallelPlanesFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherCurveFeatureMeasurementType >
    _xsd_OtherCurveFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherCurveFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherCurveFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherNonShapeFeatureMeasurementType >
    _xsd_OtherNonShapeFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherNonShapeFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherNonShapeFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherShapeFeatureMeasurementType >
    _xsd_OtherShapeFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherShapeFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherShapeFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherSurfaceFeatureMeasurementType >
    _xsd_OtherSurfaceFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherSurfaceFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherSurfaceFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PlaneFeatureMeasurementType >
    _xsd_PlaneFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"PlaneFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PlaneFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointDefinedCurveFeatureMeasurementType >
    _xsd_PointDefinedCurveFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedCurveFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointDefinedCurveFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointDefinedSurfaceFeatureMeasurementType >
    _xsd_PointDefinedSurfaceFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedSurfaceFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointDefinedSurfaceFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointFeatureMeasurementType >
    _xsd_PointFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"PointFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphereFeatureMeasurementType >
    _xsd_SphereFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"SphereFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphereFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericalSegmentFeatureMeasurementType >
    _xsd_SphericalSegmentFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalSegmentFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericalSegmentFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SurfaceOfRevolutionFeatureMeasurementType >
    _xsd_SurfaceOfRevolutionFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceOfRevolutionFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SurfaceOfRevolutionFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ThreadedFeatureMeasurementType >
    _xsd_ThreadedFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadedFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ThreadedFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToroidalSegmentFeatureMeasurementType >
    _xsd_ToroidalSegmentFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidalSegmentFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToroidalSegmentFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TorusFeatureMeasurementType >
    _xsd_TorusFeatureMeasurement_element_serializer_init (
      L"FeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      L"TorusFeatureMeasurement",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TorusFeatureMeasurementType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircleFeatureItemType >
    _xsd_CircleFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"CircleFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircleFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CircularArcFeatureItemType >
    _xsd_CircularArcFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"CircularArcFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CircularArcFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConeFeatureItemType >
    _xsd_ConeFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ConeFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConeFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ConicalSegmentFeatureItemType >
    _xsd_ConicalSegmentFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ConicalSegmentFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ConicalSegmentFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylinderFeatureItemType >
    _xsd_CylinderFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"CylinderFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylinderFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::CylindricalSegmentFeatureItemType >
    _xsd_CylindricalSegmentFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"CylindricalSegmentFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::CylindricalSegmentFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EdgePointFeatureItemType >
    _xsd_EdgePointFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"EdgePointFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EdgePointFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipseFeatureItemType >
    _xsd_EllipseFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipseFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipseFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::EllipticalArcFeatureItemType >
    _xsd_EllipticalArcFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"EllipticalArcFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::EllipticalArcFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ElongatedCircleFeatureItemType >
    _xsd_ElongatedCircleFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCircleFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ElongatedCircleFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ElongatedCylinderFeatureItemType >
    _xsd_ElongatedCylinderFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ElongatedCylinderFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ElongatedCylinderFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ExtrudedCrossSectionFeatureItemType >
    _xsd_ExtrudedCrossSectionFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ExtrudedCrossSectionFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ExtrudedCrossSectionFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::GroupFeatureItemType >
    _xsd_GroupFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"GroupFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::GroupFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LineFeatureItemType >
    _xsd_LineFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"LineFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LineFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::MarkingFeatureItemType >
    _xsd_MarkingFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"MarkingFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::MarkingFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeAngledLinesFeatureItemType >
    _xsd_OppositeAngledLinesFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledLinesFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeAngledLinesFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeAngledPlanesFeatureItemType >
    _xsd_OppositeAngledPlanesFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeAngledPlanesFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeAngledPlanesFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeParallelLinesFeatureItemType >
    _xsd_OppositeParallelLinesFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelLinesFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeParallelLinesFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OppositeParallelPlanesFeatureItemType >
    _xsd_OppositeParallelPlanesFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OppositeParallelPlanesFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OppositeParallelPlanesFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherCurveFeatureItemType >
    _xsd_OtherCurveFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherCurveFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherCurveFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherNonShapeFeatureItemType >
    _xsd_OtherNonShapeFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherNonShapeFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherNonShapeFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherShapeFeatureItemType >
    _xsd_OtherShapeFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherShapeFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherShapeFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::OtherSurfaceFeatureItemType >
    _xsd_OtherSurfaceFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"OtherSurfaceFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::OtherSurfaceFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureCircleItemType >
    _xsd_PatternFeatureCircleItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircleItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureCircleItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureCircularArcItemType >
    _xsd_PatternFeatureCircularArcItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureCircularArcItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureCircularArcItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureLinearItemType >
    _xsd_PatternFeatureLinearItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureLinearItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureLinearItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PatternFeatureParallelogramItemType >
    _xsd_PatternFeatureParallelogramItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PatternFeatureParallelogramItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PatternFeatureParallelogramItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PlaneFeatureItemType >
    _xsd_PlaneFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PlaneFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PlaneFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointDefinedCurveFeatureItemType >
    _xsd_PointDefinedCurveFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedCurveFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointDefinedCurveFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointDefinedSurfaceFeatureItemType >
    _xsd_PointDefinedSurfaceFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PointDefinedSurfaceFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointDefinedSurfaceFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::PointFeatureItemType >
    _xsd_PointFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"PointFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::PointFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphereFeatureItemType >
    _xsd_SphereFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"SphereFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphereFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SphericalSegmentFeatureItemType >
    _xsd_SphericalSegmentFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"SphericalSegmentFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SphericalSegmentFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::SurfaceOfRevolutionFeatureItemType >
    _xsd_SurfaceOfRevolutionFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"SurfaceOfRevolutionFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::SurfaceOfRevolutionFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ThreadedFeatureItemType >
    _xsd_ThreadedFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ThreadedFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ThreadedFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::ToroidalSegmentFeatureItemType >
    _xsd_ToroidalSegmentFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"ToroidalSegmentFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::ToroidalSegmentFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::TorusFeatureItemType >
    _xsd_TorusFeatureItem_element_serializer_init (
      L"FeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      L"TorusFeatureItem",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::TorusFeatureItemType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZonePointType >
    _xsd_FeatureZonePoint_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZonePoint",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZonePointType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneCurveLineType >
    _xsd_FeatureZoneCurveLine_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneCurveLine",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneCurveLineType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneCurveCircularType >
    _xsd_FeatureZoneCurveCircular_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneCurveCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneCurveCircularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneCurveIrregularType >
    _xsd_FeatureZoneCurveIrregular_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneCurveIrregular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneCurveIrregularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneAreaCircularType >
    _xsd_FeatureZoneAreaCircular_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaCircular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneAreaCircularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneAreaRectangularType >
    _xsd_FeatureZoneAreaRectangular_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaRectangular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneAreaRectangularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneAreaIrregularType >
    _xsd_FeatureZoneAreaIrregular_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaIrregular",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneAreaIrregularType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneAreaCylindricalType >
    _xsd_FeatureZoneAreaCylindrical_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaCylindrical",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneAreaCylindricalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneAreaSphericalType >
    _xsd_FeatureZoneAreaSpherical_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaSpherical",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneAreaSphericalType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FeatureZoneAreaBetweenType >
    _xsd_FeatureZoneAreaBetween_element_serializer_init (
      L"FeatureZone",
      L"http://qifstandards.org/xsd/qif3",
      L"FeatureZoneAreaBetween",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FeatureZoneAreaBetweenType >);


    void
    operator<< (xercesc::DOMElement& e, const FeatureZoneListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureZone
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (FeatureZoneListType::FeatureZone_const_iterator
             b (i.FeatureZone ().begin ()), n (i.FeatureZone ().end ());
             b != n; ++b)
        {
          const FeatureZoneListType::FeatureZone_type& x (*b);

          if (typeid (FeatureZoneListType::FeatureZone_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"FeatureZone",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"FeatureZone",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

