// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_UNITS_HXX
#define CXX___QIFLIBRARY_UNITS_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class PositiveDecimalType;
    class NonNegativeDecimalType;
    class UnitConversionType;
    class SpecifiedDecimalType;
    class MeasuredDecimalType;
    class AngularUnitType;
    class AngularValueType;
    class MeasuredAngularValueType;
    class AreaUnitType;
    class AreaValueType;
    class MeasuredAreaValueType;
    class ForceUnitType;
    class ForceValueType;
    class MeasuredForceValueType;
    class LinearUnitType;
    class LinearValueType;
    class LinearDualValueType;
    class MeasuredLinearValueType;
    class MassUnitType;
    class MassValueType;
    class MeasuredMassValueType;
    class PressureUnitType;
    class PressureValueType;
    class MeasuredPressureValueType;
    class SpeedUnitType;
    class SpeedValueType;
    class MeasuredSpeedValueType;
    class TemperatureUnitType;
    class TemperatureValueType;
    class MeasuredTemperatureValueType;
    class TimeUnitType;
    class TimeValueType;
    class MeasuredTimeValueType;
    class PrimaryUnitsType;
    class OtherUnitsType;
    class UserDefinedUnitType;
    class UserDefinedUnitValueType;
    class MeasuredUserDefinedUnitValueType;
    class UserDefinedUnitsType;
    class FileUnitsType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/Primitives.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL PositiveDecimalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // Constructors.
      //
      PositiveDecimalType ();

      PositiveDecimalType (const ::xml_schema::decimal&);

      PositiveDecimalType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PositiveDecimalType (const xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PositiveDecimalType (const ::std::wstring& s,
                           const xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PositiveDecimalType (const PositiveDecimalType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual PositiveDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PositiveDecimalType&
      operator= (const PositiveDecimalType&) = default;
#endif

      virtual 
      ~PositiveDecimalType ();
    };

    class QIF30_SYMBOL_DECL NonNegativeDecimalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // Constructors.
      //
      NonNegativeDecimalType ();

      NonNegativeDecimalType (const ::xml_schema::decimal&);

      NonNegativeDecimalType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      NonNegativeDecimalType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      NonNegativeDecimalType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      NonNegativeDecimalType (const NonNegativeDecimalType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual NonNegativeDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      NonNegativeDecimalType&
      operator= (const NonNegativeDecimalType&) = default;
#endif

      virtual 
      ~NonNegativeDecimalType ();
    };

    class QIF30_SYMBOL_DECL UnitConversionType: public ::xml_schema::type
    {
      public:
      // Factor
      //
      typedef ::xsd::qif30::PositiveDecimalType Factor_type;
      typedef ::xsd::cxx::tree::traits< Factor_type, wchar_t > Factor_traits;

      const Factor_type&
      Factor () const;

      Factor_type&
      Factor ();

      void
      Factor (const Factor_type& x);

      void
      Factor (::std::unique_ptr< Factor_type > p);

      // Offset
      //
      typedef ::xml_schema::decimal Offset_type;
      typedef ::xsd::cxx::tree::optional< Offset_type > Offset_optional;
      typedef ::xsd::cxx::tree::traits< Offset_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > Offset_traits;

      const Offset_optional&
      Offset () const;

      Offset_optional&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (const Offset_optional& x);

      static Offset_type
      Offset_default_value ();

      // Constructors.
      //
      UnitConversionType ();

      UnitConversionType (const Factor_type&);

      UnitConversionType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      UnitConversionType (const UnitConversionType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual UnitConversionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UnitConversionType&
      operator= (const UnitConversionType& x);

      virtual 
      ~UnitConversionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Factor_type > Factor_;
      Offset_optional Offset_;
    };

    class QIF30_SYMBOL_DECL SpecifiedDecimalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, wchar_t > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, wchar_t > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // Constructors.
      //
      SpecifiedDecimalType ();

      SpecifiedDecimalType (const ::xml_schema::decimal&);

      SpecifiedDecimalType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      SpecifiedDecimalType (const SpecifiedDecimalType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual SpecifiedDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpecifiedDecimalType&
      operator= (const SpecifiedDecimalType& x);

      virtual 
      ~SpecifiedDecimalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
    };

    class QIF30_SYMBOL_DECL MeasuredDecimalType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // combinedUncertainty
      //
      typedef ::xsd::qif30::NonNegativeDecimalType combinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< combinedUncertainty_type > combinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< combinedUncertainty_type, wchar_t > combinedUncertainty_traits;

      const combinedUncertainty_optional&
      combinedUncertainty () const;

      combinedUncertainty_optional&
      combinedUncertainty ();

      void
      combinedUncertainty (const combinedUncertainty_type& x);

      void
      combinedUncertainty (const combinedUncertainty_optional& x);

      void
      combinedUncertainty (::std::unique_ptr< combinedUncertainty_type > p);

      // meanError
      //
      typedef ::xsd::qif30::NonNegativeDecimalType meanError_type;
      typedef ::xsd::cxx::tree::optional< meanError_type > meanError_optional;
      typedef ::xsd::cxx::tree::traits< meanError_type, wchar_t > meanError_traits;

      const meanError_optional&
      meanError () const;

      meanError_optional&
      meanError ();

      void
      meanError (const meanError_type& x);

      void
      meanError (const meanError_optional& x);

      void
      meanError (::std::unique_ptr< meanError_type > p);

      // Constructors.
      //
      MeasuredDecimalType ();

      MeasuredDecimalType (const ::xml_schema::decimal&);

      MeasuredDecimalType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      MeasuredDecimalType (const MeasuredDecimalType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual MeasuredDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredDecimalType&
      operator= (const MeasuredDecimalType& x);

      virtual 
      ~MeasuredDecimalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      combinedUncertainty_optional combinedUncertainty_;
      meanError_optional meanError_;
    };

    class QIF30_SYMBOL_DECL AngularUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      AngularUnitType ();

      AngularUnitType (const UnitName_type&);

      AngularUnitType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AngularUnitType (const AngularUnitType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AngularUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularUnitType&
      operator= (const AngularUnitType& x);

      virtual 
      ~AngularUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL AngularValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, wchar_t > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::unique_ptr< angularUnit_type > p);

      // Constructors.
      //
      AngularValueType ();

      AngularValueType (const ::xml_schema::decimal&);

      AngularValueType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      AngularValueType (const AngularValueType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual AngularValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularValueType&
      operator= (const AngularValueType& x);

      virtual 
      ~AngularValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredAngularValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, wchar_t > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::unique_ptr< angularUnit_type > p);

      // Constructors.
      //
      MeasuredAngularValueType ();

      MeasuredAngularValueType (const ::xml_schema::decimal&);

      MeasuredAngularValueType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MeasuredAngularValueType (const MeasuredAngularValueType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual MeasuredAngularValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredAngularValueType&
      operator= (const MeasuredAngularValueType& x);

      virtual 
      ~MeasuredAngularValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class QIF30_SYMBOL_DECL AreaUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      AreaUnitType ();

      AreaUnitType (const UnitName_type&);

      AreaUnitType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      AreaUnitType (const AreaUnitType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual AreaUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AreaUnitType&
      operator= (const AreaUnitType& x);

      virtual 
      ~AreaUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL AreaValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // areaUnit
      //
      typedef ::xml_schema::token areaUnit_type;
      typedef ::xsd::cxx::tree::optional< areaUnit_type > areaUnit_optional;
      typedef ::xsd::cxx::tree::traits< areaUnit_type, wchar_t > areaUnit_traits;

      const areaUnit_optional&
      areaUnit () const;

      areaUnit_optional&
      areaUnit ();

      void
      areaUnit (const areaUnit_type& x);

      void
      areaUnit (const areaUnit_optional& x);

      void
      areaUnit (::std::unique_ptr< areaUnit_type > p);

      // Constructors.
      //
      AreaValueType ();

      AreaValueType (const ::xml_schema::decimal&);

      AreaValueType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      AreaValueType (const AreaValueType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual AreaValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AreaValueType&
      operator= (const AreaValueType& x);

      virtual 
      ~AreaValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      areaUnit_optional areaUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredAreaValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // areaUnit
      //
      typedef ::xml_schema::token areaUnit_type;
      typedef ::xsd::cxx::tree::optional< areaUnit_type > areaUnit_optional;
      typedef ::xsd::cxx::tree::traits< areaUnit_type, wchar_t > areaUnit_traits;

      const areaUnit_optional&
      areaUnit () const;

      areaUnit_optional&
      areaUnit ();

      void
      areaUnit (const areaUnit_type& x);

      void
      areaUnit (const areaUnit_optional& x);

      void
      areaUnit (::std::unique_ptr< areaUnit_type > p);

      // Constructors.
      //
      MeasuredAreaValueType ();

      MeasuredAreaValueType (const ::xml_schema::decimal&);

      MeasuredAreaValueType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MeasuredAreaValueType (const MeasuredAreaValueType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MeasuredAreaValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredAreaValueType&
      operator= (const MeasuredAreaValueType& x);

      virtual 
      ~MeasuredAreaValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      areaUnit_optional areaUnit_;
    };

    class QIF30_SYMBOL_DECL ForceUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      ForceUnitType ();

      ForceUnitType (const UnitName_type&);

      ForceUnitType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ForceUnitType (const ForceUnitType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual ForceUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ForceUnitType&
      operator= (const ForceUnitType& x);

      virtual 
      ~ForceUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL ForceValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // forceUnit
      //
      typedef ::xml_schema::token forceUnit_type;
      typedef ::xsd::cxx::tree::optional< forceUnit_type > forceUnit_optional;
      typedef ::xsd::cxx::tree::traits< forceUnit_type, wchar_t > forceUnit_traits;

      const forceUnit_optional&
      forceUnit () const;

      forceUnit_optional&
      forceUnit ();

      void
      forceUnit (const forceUnit_type& x);

      void
      forceUnit (const forceUnit_optional& x);

      void
      forceUnit (::std::unique_ptr< forceUnit_type > p);

      // Constructors.
      //
      ForceValueType ();

      ForceValueType (const ::xml_schema::decimal&);

      ForceValueType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ForceValueType (const ForceValueType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ForceValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ForceValueType&
      operator= (const ForceValueType& x);

      virtual 
      ~ForceValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      forceUnit_optional forceUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredForceValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // forceUnit
      //
      typedef ::xml_schema::token forceUnit_type;
      typedef ::xsd::cxx::tree::optional< forceUnit_type > forceUnit_optional;
      typedef ::xsd::cxx::tree::traits< forceUnit_type, wchar_t > forceUnit_traits;

      const forceUnit_optional&
      forceUnit () const;

      forceUnit_optional&
      forceUnit ();

      void
      forceUnit (const forceUnit_type& x);

      void
      forceUnit (const forceUnit_optional& x);

      void
      forceUnit (::std::unique_ptr< forceUnit_type > p);

      // Constructors.
      //
      MeasuredForceValueType ();

      MeasuredForceValueType (const ::xml_schema::decimal&);

      MeasuredForceValueType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      MeasuredForceValueType (const MeasuredForceValueType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual MeasuredForceValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredForceValueType&
      operator= (const MeasuredForceValueType& x);

      virtual 
      ~MeasuredForceValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      forceUnit_optional forceUnit_;
    };

    class QIF30_SYMBOL_DECL LinearUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      LinearUnitType ();

      LinearUnitType (const UnitName_type&);

      LinearUnitType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      LinearUnitType (const LinearUnitType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual LinearUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearUnitType&
      operator= (const LinearUnitType& x);

      virtual 
      ~LinearUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL LinearValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // Constructors.
      //
      LinearValueType ();

      LinearValueType (const ::xml_schema::decimal&);

      LinearValueType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LinearValueType (const LinearValueType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LinearValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearValueType&
      operator= (const LinearValueType& x);

      virtual 
      ~LinearValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
    };

    class QIF30_SYMBOL_DECL LinearDualValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_type&
      linearUnit () const;

      linearUnit_type&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // Constructors.
      //
      LinearDualValueType ();

      LinearDualValueType (const ::xml_schema::decimal&,
                           const linearUnit_type&);

      LinearDualValueType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      LinearDualValueType (const LinearDualValueType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual LinearDualValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearDualValueType&
      operator= (const LinearDualValueType& x);

      virtual 
      ~LinearDualValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< linearUnit_type > linearUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredLinearValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // Constructors.
      //
      MeasuredLinearValueType ();

      MeasuredLinearValueType (const ::xml_schema::decimal&);

      MeasuredLinearValueType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      MeasuredLinearValueType (const MeasuredLinearValueType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual MeasuredLinearValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredLinearValueType&
      operator= (const MeasuredLinearValueType& x);

      virtual 
      ~MeasuredLinearValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
    };

    class QIF30_SYMBOL_DECL MassUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      MassUnitType ();

      MassUnitType (const UnitName_type&);

      MassUnitType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      MassUnitType (const MassUnitType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual MassUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MassUnitType&
      operator= (const MassUnitType& x);

      virtual 
      ~MassUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL MassValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // massUnit
      //
      typedef ::xml_schema::token massUnit_type;
      typedef ::xsd::cxx::tree::optional< massUnit_type > massUnit_optional;
      typedef ::xsd::cxx::tree::traits< massUnit_type, wchar_t > massUnit_traits;

      const massUnit_optional&
      massUnit () const;

      massUnit_optional&
      massUnit ();

      void
      massUnit (const massUnit_type& x);

      void
      massUnit (const massUnit_optional& x);

      void
      massUnit (::std::unique_ptr< massUnit_type > p);

      // Constructors.
      //
      MassValueType ();

      MassValueType (const ::xml_schema::decimal&);

      MassValueType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      MassValueType (const MassValueType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual MassValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MassValueType&
      operator= (const MassValueType& x);

      virtual 
      ~MassValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      massUnit_optional massUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredMassValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // massUnit
      //
      typedef ::xml_schema::token massUnit_type;
      typedef ::xsd::cxx::tree::optional< massUnit_type > massUnit_optional;
      typedef ::xsd::cxx::tree::traits< massUnit_type, wchar_t > massUnit_traits;

      const massUnit_optional&
      massUnit () const;

      massUnit_optional&
      massUnit ();

      void
      massUnit (const massUnit_type& x);

      void
      massUnit (const massUnit_optional& x);

      void
      massUnit (::std::unique_ptr< massUnit_type > p);

      // Constructors.
      //
      MeasuredMassValueType ();

      MeasuredMassValueType (const ::xml_schema::decimal&);

      MeasuredMassValueType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MeasuredMassValueType (const MeasuredMassValueType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MeasuredMassValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredMassValueType&
      operator= (const MeasuredMassValueType& x);

      virtual 
      ~MeasuredMassValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      massUnit_optional massUnit_;
    };

    class QIF30_SYMBOL_DECL PressureUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      PressureUnitType ();

      PressureUnitType (const UnitName_type&);

      PressureUnitType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PressureUnitType (const PressureUnitType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PressureUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PressureUnitType&
      operator= (const PressureUnitType& x);

      virtual 
      ~PressureUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL PressureValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // pressureUnit
      //
      typedef ::xml_schema::token pressureUnit_type;
      typedef ::xsd::cxx::tree::optional< pressureUnit_type > pressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< pressureUnit_type, wchar_t > pressureUnit_traits;

      const pressureUnit_optional&
      pressureUnit () const;

      pressureUnit_optional&
      pressureUnit ();

      void
      pressureUnit (const pressureUnit_type& x);

      void
      pressureUnit (const pressureUnit_optional& x);

      void
      pressureUnit (::std::unique_ptr< pressureUnit_type > p);

      // Constructors.
      //
      PressureValueType ();

      PressureValueType (const ::xml_schema::decimal&);

      PressureValueType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PressureValueType (const PressureValueType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PressureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PressureValueType&
      operator= (const PressureValueType& x);

      virtual 
      ~PressureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      pressureUnit_optional pressureUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredPressureValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // pressureUnit
      //
      typedef ::xml_schema::token pressureUnit_type;
      typedef ::xsd::cxx::tree::optional< pressureUnit_type > pressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< pressureUnit_type, wchar_t > pressureUnit_traits;

      const pressureUnit_optional&
      pressureUnit () const;

      pressureUnit_optional&
      pressureUnit ();

      void
      pressureUnit (const pressureUnit_type& x);

      void
      pressureUnit (const pressureUnit_optional& x);

      void
      pressureUnit (::std::unique_ptr< pressureUnit_type > p);

      // Constructors.
      //
      MeasuredPressureValueType ();

      MeasuredPressureValueType (const ::xml_schema::decimal&);

      MeasuredPressureValueType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      MeasuredPressureValueType (const MeasuredPressureValueType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual MeasuredPressureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredPressureValueType&
      operator= (const MeasuredPressureValueType& x);

      virtual 
      ~MeasuredPressureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      pressureUnit_optional pressureUnit_;
    };

    class QIF30_SYMBOL_DECL SpeedUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      SpeedUnitType ();

      SpeedUnitType (const UnitName_type&);

      SpeedUnitType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      SpeedUnitType (const SpeedUnitType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual SpeedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpeedUnitType&
      operator= (const SpeedUnitType& x);

      virtual 
      ~SpeedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL SpeedValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // speedUnit
      //
      typedef ::xml_schema::token speedUnit_type;
      typedef ::xsd::cxx::tree::optional< speedUnit_type > speedUnit_optional;
      typedef ::xsd::cxx::tree::traits< speedUnit_type, wchar_t > speedUnit_traits;

      const speedUnit_optional&
      speedUnit () const;

      speedUnit_optional&
      speedUnit ();

      void
      speedUnit (const speedUnit_type& x);

      void
      speedUnit (const speedUnit_optional& x);

      void
      speedUnit (::std::unique_ptr< speedUnit_type > p);

      // Constructors.
      //
      SpeedValueType ();

      SpeedValueType (const ::xml_schema::decimal&);

      SpeedValueType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SpeedValueType (const SpeedValueType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SpeedValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpeedValueType&
      operator= (const SpeedValueType& x);

      virtual 
      ~SpeedValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      speedUnit_optional speedUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredSpeedValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // speedUnit
      //
      typedef ::xml_schema::token speedUnit_type;
      typedef ::xsd::cxx::tree::optional< speedUnit_type > speedUnit_optional;
      typedef ::xsd::cxx::tree::traits< speedUnit_type, wchar_t > speedUnit_traits;

      const speedUnit_optional&
      speedUnit () const;

      speedUnit_optional&
      speedUnit ();

      void
      speedUnit (const speedUnit_type& x);

      void
      speedUnit (const speedUnit_optional& x);

      void
      speedUnit (::std::unique_ptr< speedUnit_type > p);

      // Constructors.
      //
      MeasuredSpeedValueType ();

      MeasuredSpeedValueType (const ::xml_schema::decimal&);

      MeasuredSpeedValueType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      MeasuredSpeedValueType (const MeasuredSpeedValueType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual MeasuredSpeedValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredSpeedValueType&
      operator= (const MeasuredSpeedValueType& x);

      virtual 
      ~MeasuredSpeedValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      speedUnit_optional speedUnit_;
    };

    class QIF30_SYMBOL_DECL TemperatureUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      TemperatureUnitType ();

      TemperatureUnitType (const UnitName_type&);

      TemperatureUnitType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      TemperatureUnitType (const TemperatureUnitType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual TemperatureUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureUnitType&
      operator= (const TemperatureUnitType& x);

      virtual 
      ~TemperatureUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL TemperatureValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // temperatureUnit
      //
      typedef ::xml_schema::token temperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< temperatureUnit_type > temperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< temperatureUnit_type, wchar_t > temperatureUnit_traits;

      const temperatureUnit_optional&
      temperatureUnit () const;

      temperatureUnit_optional&
      temperatureUnit ();

      void
      temperatureUnit (const temperatureUnit_type& x);

      void
      temperatureUnit (const temperatureUnit_optional& x);

      void
      temperatureUnit (::std::unique_ptr< temperatureUnit_type > p);

      // Constructors.
      //
      TemperatureValueType ();

      TemperatureValueType (const ::xml_schema::decimal&);

      TemperatureValueType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      TemperatureValueType (const TemperatureValueType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual TemperatureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureValueType&
      operator= (const TemperatureValueType& x);

      virtual 
      ~TemperatureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      temperatureUnit_optional temperatureUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredTemperatureValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // temperatureUnit
      //
      typedef ::xml_schema::token temperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< temperatureUnit_type > temperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< temperatureUnit_type, wchar_t > temperatureUnit_traits;

      const temperatureUnit_optional&
      temperatureUnit () const;

      temperatureUnit_optional&
      temperatureUnit ();

      void
      temperatureUnit (const temperatureUnit_type& x);

      void
      temperatureUnit (const temperatureUnit_optional& x);

      void
      temperatureUnit (::std::unique_ptr< temperatureUnit_type > p);

      // Constructors.
      //
      MeasuredTemperatureValueType ();

      MeasuredTemperatureValueType (const ::xml_schema::decimal&);

      MeasuredTemperatureValueType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasuredTemperatureValueType (const MeasuredTemperatureValueType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual MeasuredTemperatureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredTemperatureValueType&
      operator= (const MeasuredTemperatureValueType& x);

      virtual 
      ~MeasuredTemperatureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      temperatureUnit_optional temperatureUnit_;
    };

    class QIF30_SYMBOL_DECL TimeUnitType: public ::xml_schema::type
    {
      public:
      // SIUnitName
      //
      typedef ::xml_schema::token SIUnitName_type;
      typedef ::xsd::cxx::tree::optional< SIUnitName_type > SIUnitName_optional;
      typedef ::xsd::cxx::tree::traits< SIUnitName_type, wchar_t > SIUnitName_traits;

      const SIUnitName_optional&
      SIUnitName () const;

      SIUnitName_optional&
      SIUnitName ();

      void
      SIUnitName (const SIUnitName_type& x);

      void
      SIUnitName (const SIUnitName_optional& x);

      void
      SIUnitName (::std::unique_ptr< SIUnitName_type > p);

      static const SIUnitName_type&
      SIUnitName_default_value ();

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // UnitConversion
      //
      typedef ::xsd::qif30::UnitConversionType UnitConversion_type;
      typedef ::xsd::cxx::tree::optional< UnitConversion_type > UnitConversion_optional;
      typedef ::xsd::cxx::tree::traits< UnitConversion_type, wchar_t > UnitConversion_traits;

      const UnitConversion_optional&
      UnitConversion () const;

      UnitConversion_optional&
      UnitConversion ();

      void
      UnitConversion (const UnitConversion_type& x);

      void
      UnitConversion (const UnitConversion_optional& x);

      void
      UnitConversion (::std::unique_ptr< UnitConversion_type > p);

      // Constructors.
      //
      TimeUnitType ();

      TimeUnitType (const UnitName_type&);

      TimeUnitType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      TimeUnitType (const TimeUnitType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual TimeUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TimeUnitType&
      operator= (const TimeUnitType& x);

      virtual 
      ~TimeUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SIUnitName_optional SIUnitName_;
      static const SIUnitName_type SIUnitName_default_value_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      UnitConversion_optional UnitConversion_;
    };

    class QIF30_SYMBOL_DECL TimeValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // timeUnit
      //
      typedef ::xml_schema::token timeUnit_type;
      typedef ::xsd::cxx::tree::optional< timeUnit_type > timeUnit_optional;
      typedef ::xsd::cxx::tree::traits< timeUnit_type, wchar_t > timeUnit_traits;

      const timeUnit_optional&
      timeUnit () const;

      timeUnit_optional&
      timeUnit ();

      void
      timeUnit (const timeUnit_type& x);

      void
      timeUnit (const timeUnit_optional& x);

      void
      timeUnit (::std::unique_ptr< timeUnit_type > p);

      // Constructors.
      //
      TimeValueType ();

      TimeValueType (const ::xml_schema::decimal&);

      TimeValueType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      TimeValueType (const TimeValueType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual TimeValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TimeValueType&
      operator= (const TimeValueType& x);

      virtual 
      ~TimeValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      timeUnit_optional timeUnit_;
    };

    class QIF30_SYMBOL_DECL MeasuredTimeValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // timeUnit
      //
      typedef ::xml_schema::token timeUnit_type;
      typedef ::xsd::cxx::tree::optional< timeUnit_type > timeUnit_optional;
      typedef ::xsd::cxx::tree::traits< timeUnit_type, wchar_t > timeUnit_traits;

      const timeUnit_optional&
      timeUnit () const;

      timeUnit_optional&
      timeUnit ();

      void
      timeUnit (const timeUnit_type& x);

      void
      timeUnit (const timeUnit_optional& x);

      void
      timeUnit (::std::unique_ptr< timeUnit_type > p);

      // Constructors.
      //
      MeasuredTimeValueType ();

      MeasuredTimeValueType (const ::xml_schema::decimal&);

      MeasuredTimeValueType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MeasuredTimeValueType (const MeasuredTimeValueType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MeasuredTimeValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredTimeValueType&
      operator= (const MeasuredTimeValueType& x);

      virtual 
      ~MeasuredTimeValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      timeUnit_optional timeUnit_;
    };

    class QIF30_SYMBOL_DECL PrimaryUnitsType: public ::xml_schema::type
    {
      public:
      // AreaUnit
      //
      typedef ::xsd::qif30::AreaUnitType AreaUnit_type;
      typedef ::xsd::cxx::tree::optional< AreaUnit_type > AreaUnit_optional;
      typedef ::xsd::cxx::tree::traits< AreaUnit_type, wchar_t > AreaUnit_traits;

      const AreaUnit_optional&
      AreaUnit () const;

      AreaUnit_optional&
      AreaUnit ();

      void
      AreaUnit (const AreaUnit_type& x);

      void
      AreaUnit (const AreaUnit_optional& x);

      void
      AreaUnit (::std::unique_ptr< AreaUnit_type > p);

      // PMIAreaUnit
      //
      typedef ::xsd::qif30::AreaUnitType PMIAreaUnit_type;
      typedef ::xsd::cxx::tree::optional< PMIAreaUnit_type > PMIAreaUnit_optional;
      typedef ::xsd::cxx::tree::traits< PMIAreaUnit_type, wchar_t > PMIAreaUnit_traits;

      const PMIAreaUnit_optional&
      PMIAreaUnit () const;

      PMIAreaUnit_optional&
      PMIAreaUnit ();

      void
      PMIAreaUnit (const PMIAreaUnit_type& x);

      void
      PMIAreaUnit (const PMIAreaUnit_optional& x);

      void
      PMIAreaUnit (::std::unique_ptr< PMIAreaUnit_type > p);

      // AngularUnit
      //
      typedef ::xsd::qif30::AngularUnitType AngularUnit_type;
      typedef ::xsd::cxx::tree::optional< AngularUnit_type > AngularUnit_optional;
      typedef ::xsd::cxx::tree::traits< AngularUnit_type, wchar_t > AngularUnit_traits;

      const AngularUnit_optional&
      AngularUnit () const;

      AngularUnit_optional&
      AngularUnit ();

      void
      AngularUnit (const AngularUnit_type& x);

      void
      AngularUnit (const AngularUnit_optional& x);

      void
      AngularUnit (::std::unique_ptr< AngularUnit_type > p);

      // PMIAngularUnit
      //
      typedef ::xsd::qif30::AngularUnitType PMIAngularUnit_type;
      typedef ::xsd::cxx::tree::optional< PMIAngularUnit_type > PMIAngularUnit_optional;
      typedef ::xsd::cxx::tree::traits< PMIAngularUnit_type, wchar_t > PMIAngularUnit_traits;

      const PMIAngularUnit_optional&
      PMIAngularUnit () const;

      PMIAngularUnit_optional&
      PMIAngularUnit ();

      void
      PMIAngularUnit (const PMIAngularUnit_type& x);

      void
      PMIAngularUnit (const PMIAngularUnit_optional& x);

      void
      PMIAngularUnit (::std::unique_ptr< PMIAngularUnit_type > p);

      // ForceUnit
      //
      typedef ::xsd::qif30::ForceUnitType ForceUnit_type;
      typedef ::xsd::cxx::tree::optional< ForceUnit_type > ForceUnit_optional;
      typedef ::xsd::cxx::tree::traits< ForceUnit_type, wchar_t > ForceUnit_traits;

      const ForceUnit_optional&
      ForceUnit () const;

      ForceUnit_optional&
      ForceUnit ();

      void
      ForceUnit (const ForceUnit_type& x);

      void
      ForceUnit (const ForceUnit_optional& x);

      void
      ForceUnit (::std::unique_ptr< ForceUnit_type > p);

      // LinearUnit
      //
      typedef ::xsd::qif30::LinearUnitType LinearUnit_type;
      typedef ::xsd::cxx::tree::optional< LinearUnit_type > LinearUnit_optional;
      typedef ::xsd::cxx::tree::traits< LinearUnit_type, wchar_t > LinearUnit_traits;

      const LinearUnit_optional&
      LinearUnit () const;

      LinearUnit_optional&
      LinearUnit ();

      void
      LinearUnit (const LinearUnit_type& x);

      void
      LinearUnit (const LinearUnit_optional& x);

      void
      LinearUnit (::std::unique_ptr< LinearUnit_type > p);

      // PMILinearUnit
      //
      typedef ::xsd::qif30::LinearUnitType PMILinearUnit_type;
      typedef ::xsd::cxx::tree::optional< PMILinearUnit_type > PMILinearUnit_optional;
      typedef ::xsd::cxx::tree::traits< PMILinearUnit_type, wchar_t > PMILinearUnit_traits;

      const PMILinearUnit_optional&
      PMILinearUnit () const;

      PMILinearUnit_optional&
      PMILinearUnit ();

      void
      PMILinearUnit (const PMILinearUnit_type& x);

      void
      PMILinearUnit (const PMILinearUnit_optional& x);

      void
      PMILinearUnit (::std::unique_ptr< PMILinearUnit_type > p);

      // MassUnit
      //
      typedef ::xsd::qif30::MassUnitType MassUnit_type;
      typedef ::xsd::cxx::tree::optional< MassUnit_type > MassUnit_optional;
      typedef ::xsd::cxx::tree::traits< MassUnit_type, wchar_t > MassUnit_traits;

      const MassUnit_optional&
      MassUnit () const;

      MassUnit_optional&
      MassUnit ();

      void
      MassUnit (const MassUnit_type& x);

      void
      MassUnit (const MassUnit_optional& x);

      void
      MassUnit (::std::unique_ptr< MassUnit_type > p);

      // PressureUnit
      //
      typedef ::xsd::qif30::PressureUnitType PressureUnit_type;
      typedef ::xsd::cxx::tree::optional< PressureUnit_type > PressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< PressureUnit_type, wchar_t > PressureUnit_traits;

      const PressureUnit_optional&
      PressureUnit () const;

      PressureUnit_optional&
      PressureUnit ();

      void
      PressureUnit (const PressureUnit_type& x);

      void
      PressureUnit (const PressureUnit_optional& x);

      void
      PressureUnit (::std::unique_ptr< PressureUnit_type > p);

      // SpeedUnit
      //
      typedef ::xsd::qif30::SpeedUnitType SpeedUnit_type;
      typedef ::xsd::cxx::tree::optional< SpeedUnit_type > SpeedUnit_optional;
      typedef ::xsd::cxx::tree::traits< SpeedUnit_type, wchar_t > SpeedUnit_traits;

      const SpeedUnit_optional&
      SpeedUnit () const;

      SpeedUnit_optional&
      SpeedUnit ();

      void
      SpeedUnit (const SpeedUnit_type& x);

      void
      SpeedUnit (const SpeedUnit_optional& x);

      void
      SpeedUnit (::std::unique_ptr< SpeedUnit_type > p);

      // TemperatureUnit
      //
      typedef ::xsd::qif30::TemperatureUnitType TemperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< TemperatureUnit_type > TemperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< TemperatureUnit_type, wchar_t > TemperatureUnit_traits;

      const TemperatureUnit_optional&
      TemperatureUnit () const;

      TemperatureUnit_optional&
      TemperatureUnit ();

      void
      TemperatureUnit (const TemperatureUnit_type& x);

      void
      TemperatureUnit (const TemperatureUnit_optional& x);

      void
      TemperatureUnit (::std::unique_ptr< TemperatureUnit_type > p);

      // TimeUnit
      //
      typedef ::xsd::qif30::TimeUnitType TimeUnit_type;
      typedef ::xsd::cxx::tree::optional< TimeUnit_type > TimeUnit_optional;
      typedef ::xsd::cxx::tree::traits< TimeUnit_type, wchar_t > TimeUnit_traits;

      const TimeUnit_optional&
      TimeUnit () const;

      TimeUnit_optional&
      TimeUnit ();

      void
      TimeUnit (const TimeUnit_type& x);

      void
      TimeUnit (const TimeUnit_optional& x);

      void
      TimeUnit (::std::unique_ptr< TimeUnit_type > p);

      // Constructors.
      //
      PrimaryUnitsType ();

      PrimaryUnitsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      PrimaryUnitsType (const PrimaryUnitsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual PrimaryUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrimaryUnitsType&
      operator= (const PrimaryUnitsType& x);

      virtual 
      ~PrimaryUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AreaUnit_optional AreaUnit_;
      PMIAreaUnit_optional PMIAreaUnit_;
      AngularUnit_optional AngularUnit_;
      PMIAngularUnit_optional PMIAngularUnit_;
      ForceUnit_optional ForceUnit_;
      LinearUnit_optional LinearUnit_;
      PMILinearUnit_optional PMILinearUnit_;
      MassUnit_optional MassUnit_;
      PressureUnit_optional PressureUnit_;
      SpeedUnit_optional SpeedUnit_;
      TemperatureUnit_optional TemperatureUnit_;
      TimeUnit_optional TimeUnit_;
    };

    class QIF30_SYMBOL_DECL OtherUnitsType: public ::xml_schema::type
    {
      public:
      // AreaUnit
      //
      typedef ::xsd::qif30::AreaUnitType AreaUnit_type;
      typedef ::xsd::cxx::tree::sequence< AreaUnit_type > AreaUnit_sequence;
      typedef xsd::cxx::tree::sequence< AreaUnit_type >::iterator AreaUnit_iterator;
      typedef xsd::cxx::tree::sequence< AreaUnit_type >::const_iterator AreaUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< AreaUnit_type, wchar_t > AreaUnit_traits;

      const AreaUnit_sequence&
      AreaUnit () const;

      AreaUnit_sequence&
      AreaUnit ();

      void
      AreaUnit (const AreaUnit_sequence& s);

      // AngularUnit
      //
      typedef ::xsd::qif30::AngularUnitType AngularUnit_type;
      typedef ::xsd::cxx::tree::sequence< AngularUnit_type > AngularUnit_sequence;
      typedef xsd::cxx::tree::sequence< AngularUnit_type >::iterator AngularUnit_iterator;
      typedef xsd::cxx::tree::sequence< AngularUnit_type >::const_iterator AngularUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< AngularUnit_type, wchar_t > AngularUnit_traits;

      const AngularUnit_sequence&
      AngularUnit () const;

      AngularUnit_sequence&
      AngularUnit ();

      void
      AngularUnit (const AngularUnit_sequence& s);

      // ForceUnit
      //
      typedef ::xsd::qif30::ForceUnitType ForceUnit_type;
      typedef ::xsd::cxx::tree::sequence< ForceUnit_type > ForceUnit_sequence;
      typedef xsd::cxx::tree::sequence< ForceUnit_type >::iterator ForceUnit_iterator;
      typedef xsd::cxx::tree::sequence< ForceUnit_type >::const_iterator ForceUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< ForceUnit_type, wchar_t > ForceUnit_traits;

      const ForceUnit_sequence&
      ForceUnit () const;

      ForceUnit_sequence&
      ForceUnit ();

      void
      ForceUnit (const ForceUnit_sequence& s);

      // LinearUnit
      //
      typedef ::xsd::qif30::LinearUnitType LinearUnit_type;
      typedef ::xsd::cxx::tree::sequence< LinearUnit_type > LinearUnit_sequence;
      typedef xsd::cxx::tree::sequence< LinearUnit_type >::iterator LinearUnit_iterator;
      typedef xsd::cxx::tree::sequence< LinearUnit_type >::const_iterator LinearUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< LinearUnit_type, wchar_t > LinearUnit_traits;

      const LinearUnit_sequence&
      LinearUnit () const;

      LinearUnit_sequence&
      LinearUnit ();

      void
      LinearUnit (const LinearUnit_sequence& s);

      // MassUnit
      //
      typedef ::xsd::qif30::MassUnitType MassUnit_type;
      typedef ::xsd::cxx::tree::sequence< MassUnit_type > MassUnit_sequence;
      typedef xsd::cxx::tree::sequence< MassUnit_type >::iterator MassUnit_iterator;
      typedef xsd::cxx::tree::sequence< MassUnit_type >::const_iterator MassUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< MassUnit_type, wchar_t > MassUnit_traits;

      const MassUnit_sequence&
      MassUnit () const;

      MassUnit_sequence&
      MassUnit ();

      void
      MassUnit (const MassUnit_sequence& s);

      // PressureUnit
      //
      typedef ::xsd::qif30::PressureUnitType PressureUnit_type;
      typedef ::xsd::cxx::tree::sequence< PressureUnit_type > PressureUnit_sequence;
      typedef xsd::cxx::tree::sequence< PressureUnit_type >::iterator PressureUnit_iterator;
      typedef xsd::cxx::tree::sequence< PressureUnit_type >::const_iterator PressureUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< PressureUnit_type, wchar_t > PressureUnit_traits;

      const PressureUnit_sequence&
      PressureUnit () const;

      PressureUnit_sequence&
      PressureUnit ();

      void
      PressureUnit (const PressureUnit_sequence& s);

      // SpeedUnit
      //
      typedef ::xsd::qif30::SpeedUnitType SpeedUnit_type;
      typedef ::xsd::cxx::tree::sequence< SpeedUnit_type > SpeedUnit_sequence;
      typedef xsd::cxx::tree::sequence< SpeedUnit_type >::iterator SpeedUnit_iterator;
      typedef xsd::cxx::tree::sequence< SpeedUnit_type >::const_iterator SpeedUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< SpeedUnit_type, wchar_t > SpeedUnit_traits;

      const SpeedUnit_sequence&
      SpeedUnit () const;

      SpeedUnit_sequence&
      SpeedUnit ();

      void
      SpeedUnit (const SpeedUnit_sequence& s);

      // TemperatureUnit
      //
      typedef ::xsd::qif30::TemperatureUnitType TemperatureUnit_type;
      typedef ::xsd::cxx::tree::sequence< TemperatureUnit_type > TemperatureUnit_sequence;
      typedef xsd::cxx::tree::sequence< TemperatureUnit_type >::iterator TemperatureUnit_iterator;
      typedef xsd::cxx::tree::sequence< TemperatureUnit_type >::const_iterator TemperatureUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< TemperatureUnit_type, wchar_t > TemperatureUnit_traits;

      const TemperatureUnit_sequence&
      TemperatureUnit () const;

      TemperatureUnit_sequence&
      TemperatureUnit ();

      void
      TemperatureUnit (const TemperatureUnit_sequence& s);

      // TimeUnit
      //
      typedef ::xsd::qif30::TimeUnitType TimeUnit_type;
      typedef ::xsd::cxx::tree::sequence< TimeUnit_type > TimeUnit_sequence;
      typedef xsd::cxx::tree::sequence< TimeUnit_type >::iterator TimeUnit_iterator;
      typedef xsd::cxx::tree::sequence< TimeUnit_type >::const_iterator TimeUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< TimeUnit_type, wchar_t > TimeUnit_traits;

      const TimeUnit_sequence&
      TimeUnit () const;

      TimeUnit_sequence&
      TimeUnit ();

      void
      TimeUnit (const TimeUnit_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      OtherUnitsType ();

      OtherUnitsType (const n_type&);

      OtherUnitsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      OtherUnitsType (const OtherUnitsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual OtherUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OtherUnitsType&
      operator= (const OtherUnitsType& x);

      virtual 
      ~OtherUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AreaUnit_sequence AreaUnit_;
      AngularUnit_sequence AngularUnit_;
      ForceUnit_sequence ForceUnit_;
      LinearUnit_sequence LinearUnit_;
      MassUnit_sequence MassUnit_;
      PressureUnit_sequence PressureUnit_;
      SpeedUnit_sequence SpeedUnit_;
      TemperatureUnit_sequence TemperatureUnit_;
      TimeUnit_sequence TimeUnit_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL UserDefinedUnitType: public ::xml_schema::type
    {
      public:
      // WhatIsMeasured
      //
      typedef ::xml_schema::string WhatIsMeasured_type;
      typedef ::xsd::cxx::tree::traits< WhatIsMeasured_type, wchar_t > WhatIsMeasured_traits;

      const WhatIsMeasured_type&
      WhatIsMeasured () const;

      WhatIsMeasured_type&
      WhatIsMeasured ();

      void
      WhatIsMeasured (const WhatIsMeasured_type& x);

      void
      WhatIsMeasured (::std::unique_ptr< WhatIsMeasured_type > p);

      // UnitName
      //
      typedef ::xml_schema::token UnitName_type;
      typedef ::xsd::cxx::tree::traits< UnitName_type, wchar_t > UnitName_traits;

      const UnitName_type&
      UnitName () const;

      UnitName_type&
      UnitName ();

      void
      UnitName (const UnitName_type& x);

      void
      UnitName (::std::unique_ptr< UnitName_type > p);

      // StandardName
      //
      typedef ::xml_schema::string StandardName_type;
      typedef ::xsd::cxx::tree::optional< StandardName_type > StandardName_optional;
      typedef ::xsd::cxx::tree::traits< StandardName_type, wchar_t > StandardName_traits;

      const StandardName_optional&
      StandardName () const;

      StandardName_optional&
      StandardName ();

      void
      StandardName (const StandardName_type& x);

      void
      StandardName (const StandardName_optional& x);

      void
      StandardName (::std::unique_ptr< StandardName_type > p);

      // Constructors.
      //
      UserDefinedUnitType ();

      UserDefinedUnitType (const WhatIsMeasured_type&,
                           const UnitName_type&);

      UserDefinedUnitType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      UserDefinedUnitType (const UserDefinedUnitType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual UserDefinedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitType&
      operator= (const UserDefinedUnitType& x);

      virtual 
      ~UserDefinedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< WhatIsMeasured_type > WhatIsMeasured_;
      ::xsd::cxx::tree::one< UnitName_type > UnitName_;
      StandardName_optional StandardName_;
    };

    class QIF30_SYMBOL_DECL UserDefinedUnitValueType: public ::xsd::qif30::SpecifiedDecimalType
    {
      public:
      // unitName
      //
      typedef ::xml_schema::token unitName_type;
      typedef ::xsd::cxx::tree::traits< unitName_type, wchar_t > unitName_traits;

      const unitName_type&
      unitName () const;

      unitName_type&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (::std::unique_ptr< unitName_type > p);

      // Constructors.
      //
      UserDefinedUnitValueType ();

      UserDefinedUnitValueType (const ::xml_schema::decimal&,
                                const unitName_type&);

      UserDefinedUnitValueType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      UserDefinedUnitValueType (const UserDefinedUnitValueType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual UserDefinedUnitValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitValueType&
      operator= (const UserDefinedUnitValueType& x);

      virtual 
      ~UserDefinedUnitValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unitName_type > unitName_;
    };

    class QIF30_SYMBOL_DECL MeasuredUserDefinedUnitValueType: public ::xsd::qif30::MeasuredDecimalType
    {
      public:
      // unitName
      //
      typedef ::xml_schema::token unitName_type;
      typedef ::xsd::cxx::tree::traits< unitName_type, wchar_t > unitName_traits;

      const unitName_type&
      unitName () const;

      unitName_type&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (::std::unique_ptr< unitName_type > p);

      // Constructors.
      //
      MeasuredUserDefinedUnitValueType ();

      MeasuredUserDefinedUnitValueType (const ::xml_schema::decimal&,
                                        const unitName_type&);

      MeasuredUserDefinedUnitValueType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      MeasuredUserDefinedUnitValueType (const MeasuredUserDefinedUnitValueType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual MeasuredUserDefinedUnitValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredUserDefinedUnitValueType&
      operator= (const MeasuredUserDefinedUnitValueType& x);

      virtual 
      ~MeasuredUserDefinedUnitValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unitName_type > unitName_;
    };

    class QIF30_SYMBOL_DECL UserDefinedUnitsType: public ::xml_schema::type
    {
      public:
      // UserDefinedUnit
      //
      typedef ::xsd::qif30::UserDefinedUnitType UserDefinedUnit_type;
      typedef ::xsd::cxx::tree::sequence< UserDefinedUnit_type > UserDefinedUnit_sequence;
      typedef xsd::cxx::tree::sequence< UserDefinedUnit_type >::iterator UserDefinedUnit_iterator;
      typedef xsd::cxx::tree::sequence< UserDefinedUnit_type >::const_iterator UserDefinedUnit_const_iterator;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnit_type, wchar_t > UserDefinedUnit_traits;

      const UserDefinedUnit_sequence&
      UserDefinedUnit () const;

      UserDefinedUnit_sequence&
      UserDefinedUnit ();

      void
      UserDefinedUnit (const UserDefinedUnit_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      UserDefinedUnitsType ();

      UserDefinedUnitsType (const n_type&);

      UserDefinedUnitsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UserDefinedUnitsType (const UserDefinedUnitsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual UserDefinedUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitsType&
      operator= (const UserDefinedUnitsType& x);

      virtual 
      ~UserDefinedUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      UserDefinedUnit_sequence UserDefinedUnit_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL FileUnitsType: public ::xml_schema::type
    {
      public:
      // PrimaryUnits
      //
      typedef ::xsd::qif30::PrimaryUnitsType PrimaryUnits_type;
      typedef ::xsd::cxx::tree::traits< PrimaryUnits_type, wchar_t > PrimaryUnits_traits;

      const PrimaryUnits_type&
      PrimaryUnits () const;

      PrimaryUnits_type&
      PrimaryUnits ();

      void
      PrimaryUnits (const PrimaryUnits_type& x);

      void
      PrimaryUnits (::std::unique_ptr< PrimaryUnits_type > p);

      // OtherUnits
      //
      typedef ::xsd::qif30::OtherUnitsType OtherUnits_type;
      typedef ::xsd::cxx::tree::optional< OtherUnits_type > OtherUnits_optional;
      typedef ::xsd::cxx::tree::traits< OtherUnits_type, wchar_t > OtherUnits_traits;

      const OtherUnits_optional&
      OtherUnits () const;

      OtherUnits_optional&
      OtherUnits ();

      void
      OtherUnits (const OtherUnits_type& x);

      void
      OtherUnits (const OtherUnits_optional& x);

      void
      OtherUnits (::std::unique_ptr< OtherUnits_type > p);

      // UserDefinedUnits
      //
      typedef ::xsd::qif30::UserDefinedUnitsType UserDefinedUnits_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedUnits_type > UserDefinedUnits_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnits_type, wchar_t > UserDefinedUnits_traits;

      const UserDefinedUnits_optional&
      UserDefinedUnits () const;

      UserDefinedUnits_optional&
      UserDefinedUnits ();

      void
      UserDefinedUnits (const UserDefinedUnits_type& x);

      void
      UserDefinedUnits (const UserDefinedUnits_optional& x);

      void
      UserDefinedUnits (::std::unique_ptr< UserDefinedUnits_type > p);

      // Constructors.
      //
      FileUnitsType ();

      FileUnitsType (const PrimaryUnits_type&);

      FileUnitsType (::std::unique_ptr< PrimaryUnits_type >);

      FileUnitsType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      FileUnitsType (const FileUnitsType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual FileUnitsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileUnitsType&
      operator= (const FileUnitsType& x);

      virtual 
      ~FileUnitsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PrimaryUnits_type > PrimaryUnits_;
      OtherUnits_optional OtherUnits_;
      UserDefinedUnits_optional UserDefinedUnits_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositiveDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PositiveDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PositiveDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NonNegativeDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const NonNegativeDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const NonNegativeDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UnitConversionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpecifiedDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredAngularValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AreaUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AreaValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredAreaValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ForceUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ForceValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredForceValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearDualValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredLinearValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MassUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MassValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredMassValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PressureUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PressureValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredPressureValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpeedUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpeedValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredSpeedValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredTemperatureValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TimeUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TimeValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredTimeValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PrimaryUnitsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherUnitsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedUnitValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredUserDefinedUnitValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedUnitsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FileUnitsType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_UNITS_HXX
