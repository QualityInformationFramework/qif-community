// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "xmldsig-core-schema-qif3-namespace.hxx"

namespace xsd
{
  namespace qif30
  {
    // CryptoBinary
    //


    // SignatureType
    //

    const SignatureType::SignedInfo_type& SignatureType::
    SignedInfo () const
    {
      return this->SignedInfo_.get ();
    }

    SignatureType::SignedInfo_type& SignatureType::
    SignedInfo ()
    {
      return this->SignedInfo_.get ();
    }

    void SignatureType::
    SignedInfo (const SignedInfo_type& x)
    {
      this->SignedInfo_.set (x);
    }

    void SignatureType::
    SignedInfo (::std::unique_ptr< SignedInfo_type > x)
    {
      this->SignedInfo_.set (std::move (x));
    }

    const SignatureType::SignatureValue_type& SignatureType::
    SignatureValue () const
    {
      return this->SignatureValue_.get ();
    }

    SignatureType::SignatureValue_type& SignatureType::
    SignatureValue ()
    {
      return this->SignatureValue_.get ();
    }

    void SignatureType::
    SignatureValue (const SignatureValue_type& x)
    {
      this->SignatureValue_.set (x);
    }

    void SignatureType::
    SignatureValue (::std::unique_ptr< SignatureValue_type > x)
    {
      this->SignatureValue_.set (std::move (x));
    }

    const SignatureType::KeyInfo_optional& SignatureType::
    KeyInfo () const
    {
      return this->KeyInfo_;
    }

    SignatureType::KeyInfo_optional& SignatureType::
    KeyInfo ()
    {
      return this->KeyInfo_;
    }

    void SignatureType::
    KeyInfo (const KeyInfo_type& x)
    {
      this->KeyInfo_.set (x);
    }

    void SignatureType::
    KeyInfo (const KeyInfo_optional& x)
    {
      this->KeyInfo_ = x;
    }

    void SignatureType::
    KeyInfo (::std::unique_ptr< KeyInfo_type > x)
    {
      this->KeyInfo_.set (std::move (x));
    }

    const SignatureType::Object_sequence& SignatureType::
    Object () const
    {
      return this->Object_;
    }

    SignatureType::Object_sequence& SignatureType::
    Object ()
    {
      return this->Object_;
    }

    void SignatureType::
    Object (const Object_sequence& s)
    {
      this->Object_ = s;
    }

    const SignatureType::Id_optional& SignatureType::
    Id () const
    {
      return this->Id_;
    }

    SignatureType::Id_optional& SignatureType::
    Id ()
    {
      return this->Id_;
    }

    void SignatureType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void SignatureType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void SignatureType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // SignatureValueType
    //

    const SignatureValueType::Id_optional& SignatureValueType::
    Id () const
    {
      return this->Id_;
    }

    SignatureValueType::Id_optional& SignatureValueType::
    Id ()
    {
      return this->Id_;
    }

    void SignatureValueType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void SignatureValueType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void SignatureValueType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // SignedInfoType
    //

    const SignedInfoType::CanonicalizationMethod_type& SignedInfoType::
    CanonicalizationMethod () const
    {
      return this->CanonicalizationMethod_.get ();
    }

    SignedInfoType::CanonicalizationMethod_type& SignedInfoType::
    CanonicalizationMethod ()
    {
      return this->CanonicalizationMethod_.get ();
    }

    void SignedInfoType::
    CanonicalizationMethod (const CanonicalizationMethod_type& x)
    {
      this->CanonicalizationMethod_.set (x);
    }

    void SignedInfoType::
    CanonicalizationMethod (::std::unique_ptr< CanonicalizationMethod_type > x)
    {
      this->CanonicalizationMethod_.set (std::move (x));
    }

    const SignedInfoType::SignatureMethod_type& SignedInfoType::
    SignatureMethod () const
    {
      return this->SignatureMethod_.get ();
    }

    SignedInfoType::SignatureMethod_type& SignedInfoType::
    SignatureMethod ()
    {
      return this->SignatureMethod_.get ();
    }

    void SignedInfoType::
    SignatureMethod (const SignatureMethod_type& x)
    {
      this->SignatureMethod_.set (x);
    }

    void SignedInfoType::
    SignatureMethod (::std::unique_ptr< SignatureMethod_type > x)
    {
      this->SignatureMethod_.set (std::move (x));
    }

    const SignedInfoType::Reference_sequence& SignedInfoType::
    Reference () const
    {
      return this->Reference_;
    }

    SignedInfoType::Reference_sequence& SignedInfoType::
    Reference ()
    {
      return this->Reference_;
    }

    void SignedInfoType::
    Reference (const Reference_sequence& s)
    {
      this->Reference_ = s;
    }

    const SignedInfoType::Id_optional& SignedInfoType::
    Id () const
    {
      return this->Id_;
    }

    SignedInfoType::Id_optional& SignedInfoType::
    Id ()
    {
      return this->Id_;
    }

    void SignedInfoType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void SignedInfoType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void SignedInfoType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // CanonicalizationMethodType
    //

    const CanonicalizationMethodType::Algorithm_type& CanonicalizationMethodType::
    Algorithm () const
    {
      return this->Algorithm_.get ();
    }

    CanonicalizationMethodType::Algorithm_type& CanonicalizationMethodType::
    Algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void CanonicalizationMethodType::
    Algorithm (const Algorithm_type& x)
    {
      this->Algorithm_.set (x);
    }

    void CanonicalizationMethodType::
    Algorithm (::std::unique_ptr< Algorithm_type > x)
    {
      this->Algorithm_.set (std::move (x));
    }


    // SignatureMethodType
    //

    const SignatureMethodType::HMACOutputLength_optional& SignatureMethodType::
    HMACOutputLength () const
    {
      return this->HMACOutputLength_;
    }

    SignatureMethodType::HMACOutputLength_optional& SignatureMethodType::
    HMACOutputLength ()
    {
      return this->HMACOutputLength_;
    }

    void SignatureMethodType::
    HMACOutputLength (const HMACOutputLength_type& x)
    {
      this->HMACOutputLength_.set (x);
    }

    void SignatureMethodType::
    HMACOutputLength (const HMACOutputLength_optional& x)
    {
      this->HMACOutputLength_ = x;
    }

    void SignatureMethodType::
    HMACOutputLength (::std::unique_ptr< HMACOutputLength_type > x)
    {
      this->HMACOutputLength_.set (std::move (x));
    }

    const SignatureMethodType::Algorithm_type& SignatureMethodType::
    Algorithm () const
    {
      return this->Algorithm_.get ();
    }

    SignatureMethodType::Algorithm_type& SignatureMethodType::
    Algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void SignatureMethodType::
    Algorithm (const Algorithm_type& x)
    {
      this->Algorithm_.set (x);
    }

    void SignatureMethodType::
    Algorithm (::std::unique_ptr< Algorithm_type > x)
    {
      this->Algorithm_.set (std::move (x));
    }


    // ReferenceType
    //

    const ReferenceType::Transforms_type& ReferenceType::
    Transforms () const
    {
      return this->Transforms_.get ();
    }

    ReferenceType::Transforms_type& ReferenceType::
    Transforms ()
    {
      return this->Transforms_.get ();
    }

    void ReferenceType::
    Transforms (const Transforms_type& x)
    {
      this->Transforms_.set (x);
    }

    void ReferenceType::
    Transforms (::std::unique_ptr< Transforms_type > x)
    {
      this->Transforms_.set (std::move (x));
    }

    const ReferenceType::DigestMethod_type& ReferenceType::
    DigestMethod () const
    {
      return this->DigestMethod_.get ();
    }

    ReferenceType::DigestMethod_type& ReferenceType::
    DigestMethod ()
    {
      return this->DigestMethod_.get ();
    }

    void ReferenceType::
    DigestMethod (const DigestMethod_type& x)
    {
      this->DigestMethod_.set (x);
    }

    void ReferenceType::
    DigestMethod (::std::unique_ptr< DigestMethod_type > x)
    {
      this->DigestMethod_.set (std::move (x));
    }

    const ReferenceType::DigestValue_type& ReferenceType::
    DigestValue () const
    {
      return this->DigestValue_.get ();
    }

    ReferenceType::DigestValue_type& ReferenceType::
    DigestValue ()
    {
      return this->DigestValue_.get ();
    }

    void ReferenceType::
    DigestValue (const DigestValue_type& x)
    {
      this->DigestValue_.set (x);
    }

    void ReferenceType::
    DigestValue (::std::unique_ptr< DigestValue_type > x)
    {
      this->DigestValue_.set (std::move (x));
    }

    const ReferenceType::Id_optional& ReferenceType::
    Id () const
    {
      return this->Id_;
    }

    ReferenceType::Id_optional& ReferenceType::
    Id ()
    {
      return this->Id_;
    }

    void ReferenceType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ReferenceType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void ReferenceType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }

    const ReferenceType::URI_optional& ReferenceType::
    URI () const
    {
      return this->URI_;
    }

    ReferenceType::URI_optional& ReferenceType::
    URI ()
    {
      return this->URI_;
    }

    void ReferenceType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void ReferenceType::
    URI (const URI_optional& x)
    {
      this->URI_ = x;
    }

    void ReferenceType::
    URI (::std::unique_ptr< URI_type > x)
    {
      this->URI_.set (std::move (x));
    }

    const ReferenceType::Type_optional& ReferenceType::
    Type () const
    {
      return this->Type_;
    }

    ReferenceType::Type_optional& ReferenceType::
    Type ()
    {
      return this->Type_;
    }

    void ReferenceType::
    Type (const Type_type& x)
    {
      this->Type_.set (x);
    }

    void ReferenceType::
    Type (const Type_optional& x)
    {
      this->Type_ = x;
    }

    void ReferenceType::
    Type (::std::unique_ptr< Type_type > x)
    {
      this->Type_.set (std::move (x));
    }


    // DsTransformsType
    //

    const DsTransformsType::Transform_type& DsTransformsType::
    Transform () const
    {
      return this->Transform_.get ();
    }

    DsTransformsType::Transform_type& DsTransformsType::
    Transform ()
    {
      return this->Transform_.get ();
    }

    void DsTransformsType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void DsTransformsType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }


    // DsTransformType
    //

    const DsTransformType::XPath_sequence& DsTransformType::
    XPath () const
    {
      return this->XPath_;
    }

    DsTransformType::XPath_sequence& DsTransformType::
    XPath ()
    {
      return this->XPath_;
    }

    void DsTransformType::
    XPath (const XPath_sequence& s)
    {
      this->XPath_ = s;
    }

    const DsTransformType::Algorithm_type& DsTransformType::
    Algorithm () const
    {
      return this->Algorithm_.get ();
    }

    DsTransformType::Algorithm_type& DsTransformType::
    Algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void DsTransformType::
    Algorithm (const Algorithm_type& x)
    {
      this->Algorithm_.set (x);
    }

    void DsTransformType::
    Algorithm (::std::unique_ptr< Algorithm_type > x)
    {
      this->Algorithm_.set (std::move (x));
    }


    // DigestMethodType
    //

    const DigestMethodType::Algorithm_type& DigestMethodType::
    Algorithm () const
    {
      return this->Algorithm_.get ();
    }

    DigestMethodType::Algorithm_type& DigestMethodType::
    Algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void DigestMethodType::
    Algorithm (const Algorithm_type& x)
    {
      this->Algorithm_.set (x);
    }

    void DigestMethodType::
    Algorithm (::std::unique_ptr< Algorithm_type > x)
    {
      this->Algorithm_.set (std::move (x));
    }


    // DigestValueType
    //


    // KeyInfoType
    //

    const KeyInfoType::KeyName_sequence& KeyInfoType::
    KeyName () const
    {
      return this->KeyName_;
    }

    KeyInfoType::KeyName_sequence& KeyInfoType::
    KeyName ()
    {
      return this->KeyName_;
    }

    void KeyInfoType::
    KeyName (const KeyName_sequence& s)
    {
      this->KeyName_ = s;
    }

    const KeyInfoType::KeyValue_sequence& KeyInfoType::
    KeyValue () const
    {
      return this->KeyValue_;
    }

    KeyInfoType::KeyValue_sequence& KeyInfoType::
    KeyValue ()
    {
      return this->KeyValue_;
    }

    void KeyInfoType::
    KeyValue (const KeyValue_sequence& s)
    {
      this->KeyValue_ = s;
    }

    const KeyInfoType::RetrievalMethod_sequence& KeyInfoType::
    RetrievalMethod () const
    {
      return this->RetrievalMethod_;
    }

    KeyInfoType::RetrievalMethod_sequence& KeyInfoType::
    RetrievalMethod ()
    {
      return this->RetrievalMethod_;
    }

    void KeyInfoType::
    RetrievalMethod (const RetrievalMethod_sequence& s)
    {
      this->RetrievalMethod_ = s;
    }

    const KeyInfoType::X509Data_sequence& KeyInfoType::
    X509Data () const
    {
      return this->X509Data_;
    }

    KeyInfoType::X509Data_sequence& KeyInfoType::
    X509Data ()
    {
      return this->X509Data_;
    }

    void KeyInfoType::
    X509Data (const X509Data_sequence& s)
    {
      this->X509Data_ = s;
    }

    const KeyInfoType::PGPData_sequence& KeyInfoType::
    PGPData () const
    {
      return this->PGPData_;
    }

    KeyInfoType::PGPData_sequence& KeyInfoType::
    PGPData ()
    {
      return this->PGPData_;
    }

    void KeyInfoType::
    PGPData (const PGPData_sequence& s)
    {
      this->PGPData_ = s;
    }

    const KeyInfoType::SPKIData_sequence& KeyInfoType::
    SPKIData () const
    {
      return this->SPKIData_;
    }

    KeyInfoType::SPKIData_sequence& KeyInfoType::
    SPKIData ()
    {
      return this->SPKIData_;
    }

    void KeyInfoType::
    SPKIData (const SPKIData_sequence& s)
    {
      this->SPKIData_ = s;
    }

    const KeyInfoType::MgmtData_sequence& KeyInfoType::
    MgmtData () const
    {
      return this->MgmtData_;
    }

    KeyInfoType::MgmtData_sequence& KeyInfoType::
    MgmtData ()
    {
      return this->MgmtData_;
    }

    void KeyInfoType::
    MgmtData (const MgmtData_sequence& s)
    {
      this->MgmtData_ = s;
    }

    const KeyInfoType::Id_optional& KeyInfoType::
    Id () const
    {
      return this->Id_;
    }

    KeyInfoType::Id_optional& KeyInfoType::
    Id ()
    {
      return this->Id_;
    }

    void KeyInfoType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void KeyInfoType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void KeyInfoType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // KeyValueType
    //

    const KeyValueType::DSAKeyValue_optional& KeyValueType::
    DSAKeyValue () const
    {
      return this->DSAKeyValue_;
    }

    KeyValueType::DSAKeyValue_optional& KeyValueType::
    DSAKeyValue ()
    {
      return this->DSAKeyValue_;
    }

    void KeyValueType::
    DSAKeyValue (const DSAKeyValue_type& x)
    {
      this->DSAKeyValue_.set (x);
    }

    void KeyValueType::
    DSAKeyValue (const DSAKeyValue_optional& x)
    {
      this->DSAKeyValue_ = x;
    }

    void KeyValueType::
    DSAKeyValue (::std::unique_ptr< DSAKeyValue_type > x)
    {
      this->DSAKeyValue_.set (std::move (x));
    }

    const KeyValueType::RSAKeyValue_optional& KeyValueType::
    RSAKeyValue () const
    {
      return this->RSAKeyValue_;
    }

    KeyValueType::RSAKeyValue_optional& KeyValueType::
    RSAKeyValue ()
    {
      return this->RSAKeyValue_;
    }

    void KeyValueType::
    RSAKeyValue (const RSAKeyValue_type& x)
    {
      this->RSAKeyValue_.set (x);
    }

    void KeyValueType::
    RSAKeyValue (const RSAKeyValue_optional& x)
    {
      this->RSAKeyValue_ = x;
    }

    void KeyValueType::
    RSAKeyValue (::std::unique_ptr< RSAKeyValue_type > x)
    {
      this->RSAKeyValue_.set (std::move (x));
    }


    // RetrievalMethodType
    //

    const RetrievalMethodType::Transforms_optional& RetrievalMethodType::
    Transforms () const
    {
      return this->Transforms_;
    }

    RetrievalMethodType::Transforms_optional& RetrievalMethodType::
    Transforms ()
    {
      return this->Transforms_;
    }

    void RetrievalMethodType::
    Transforms (const Transforms_type& x)
    {
      this->Transforms_.set (x);
    }

    void RetrievalMethodType::
    Transforms (const Transforms_optional& x)
    {
      this->Transforms_ = x;
    }

    void RetrievalMethodType::
    Transforms (::std::unique_ptr< Transforms_type > x)
    {
      this->Transforms_.set (std::move (x));
    }

    const RetrievalMethodType::URI_optional& RetrievalMethodType::
    URI () const
    {
      return this->URI_;
    }

    RetrievalMethodType::URI_optional& RetrievalMethodType::
    URI ()
    {
      return this->URI_;
    }

    void RetrievalMethodType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void RetrievalMethodType::
    URI (const URI_optional& x)
    {
      this->URI_ = x;
    }

    void RetrievalMethodType::
    URI (::std::unique_ptr< URI_type > x)
    {
      this->URI_.set (std::move (x));
    }

    const RetrievalMethodType::Type_optional& RetrievalMethodType::
    Type () const
    {
      return this->Type_;
    }

    RetrievalMethodType::Type_optional& RetrievalMethodType::
    Type ()
    {
      return this->Type_;
    }

    void RetrievalMethodType::
    Type (const Type_type& x)
    {
      this->Type_.set (x);
    }

    void RetrievalMethodType::
    Type (const Type_optional& x)
    {
      this->Type_ = x;
    }

    void RetrievalMethodType::
    Type (::std::unique_ptr< Type_type > x)
    {
      this->Type_.set (std::move (x));
    }


    // X509DataType
    //

    const X509DataType::X509IssuerSerial_sequence& X509DataType::
    X509IssuerSerial () const
    {
      return this->X509IssuerSerial_;
    }

    X509DataType::X509IssuerSerial_sequence& X509DataType::
    X509IssuerSerial ()
    {
      return this->X509IssuerSerial_;
    }

    void X509DataType::
    X509IssuerSerial (const X509IssuerSerial_sequence& s)
    {
      this->X509IssuerSerial_ = s;
    }

    const X509DataType::X509SKI_sequence& X509DataType::
    X509SKI () const
    {
      return this->X509SKI_;
    }

    X509DataType::X509SKI_sequence& X509DataType::
    X509SKI ()
    {
      return this->X509SKI_;
    }

    void X509DataType::
    X509SKI (const X509SKI_sequence& s)
    {
      this->X509SKI_ = s;
    }

    const X509DataType::X509SubjectName_sequence& X509DataType::
    X509SubjectName () const
    {
      return this->X509SubjectName_;
    }

    X509DataType::X509SubjectName_sequence& X509DataType::
    X509SubjectName ()
    {
      return this->X509SubjectName_;
    }

    void X509DataType::
    X509SubjectName (const X509SubjectName_sequence& s)
    {
      this->X509SubjectName_ = s;
    }

    const X509DataType::X509Certificate_sequence& X509DataType::
    X509Certificate () const
    {
      return this->X509Certificate_;
    }

    X509DataType::X509Certificate_sequence& X509DataType::
    X509Certificate ()
    {
      return this->X509Certificate_;
    }

    void X509DataType::
    X509Certificate (const X509Certificate_sequence& s)
    {
      this->X509Certificate_ = s;
    }

    const X509DataType::X509CRL_sequence& X509DataType::
    X509CRL () const
    {
      return this->X509CRL_;
    }

    X509DataType::X509CRL_sequence& X509DataType::
    X509CRL ()
    {
      return this->X509CRL_;
    }

    void X509DataType::
    X509CRL (const X509CRL_sequence& s)
    {
      this->X509CRL_ = s;
    }


    // X509IssuerSerialType
    //

    const X509IssuerSerialType::X509IssuerName_type& X509IssuerSerialType::
    X509IssuerName () const
    {
      return this->X509IssuerName_.get ();
    }

    X509IssuerSerialType::X509IssuerName_type& X509IssuerSerialType::
    X509IssuerName ()
    {
      return this->X509IssuerName_.get ();
    }

    void X509IssuerSerialType::
    X509IssuerName (const X509IssuerName_type& x)
    {
      this->X509IssuerName_.set (x);
    }

    void X509IssuerSerialType::
    X509IssuerName (::std::unique_ptr< X509IssuerName_type > x)
    {
      this->X509IssuerName_.set (std::move (x));
    }

    const X509IssuerSerialType::X509SerialNumber_type& X509IssuerSerialType::
    X509SerialNumber () const
    {
      return this->X509SerialNumber_.get ();
    }

    X509IssuerSerialType::X509SerialNumber_type& X509IssuerSerialType::
    X509SerialNumber ()
    {
      return this->X509SerialNumber_.get ();
    }

    void X509IssuerSerialType::
    X509SerialNumber (const X509SerialNumber_type& x)
    {
      this->X509SerialNumber_.set (x);
    }


    // PGPDataType
    //

    const PGPDataType::PGPKeyID_optional& PGPDataType::
    PGPKeyID () const
    {
      return this->PGPKeyID_;
    }

    PGPDataType::PGPKeyID_optional& PGPDataType::
    PGPKeyID ()
    {
      return this->PGPKeyID_;
    }

    void PGPDataType::
    PGPKeyID (const PGPKeyID_type& x)
    {
      this->PGPKeyID_.set (x);
    }

    void PGPDataType::
    PGPKeyID (const PGPKeyID_optional& x)
    {
      this->PGPKeyID_ = x;
    }

    void PGPDataType::
    PGPKeyID (::std::unique_ptr< PGPKeyID_type > x)
    {
      this->PGPKeyID_.set (std::move (x));
    }

    const PGPDataType::PGPKeyPacket_optional& PGPDataType::
    PGPKeyPacket () const
    {
      return this->PGPKeyPacket_;
    }

    PGPDataType::PGPKeyPacket_optional& PGPDataType::
    PGPKeyPacket ()
    {
      return this->PGPKeyPacket_;
    }

    void PGPDataType::
    PGPKeyPacket (const PGPKeyPacket_type& x)
    {
      this->PGPKeyPacket_.set (x);
    }

    void PGPDataType::
    PGPKeyPacket (const PGPKeyPacket_optional& x)
    {
      this->PGPKeyPacket_ = x;
    }

    void PGPDataType::
    PGPKeyPacket (::std::unique_ptr< PGPKeyPacket_type > x)
    {
      this->PGPKeyPacket_.set (std::move (x));
    }


    // SPKIDataType
    //

    const SPKIDataType::SPKISexp_sequence& SPKIDataType::
    SPKISexp () const
    {
      return this->SPKISexp_;
    }

    SPKIDataType::SPKISexp_sequence& SPKIDataType::
    SPKISexp ()
    {
      return this->SPKISexp_;
    }

    void SPKIDataType::
    SPKISexp (const SPKISexp_sequence& s)
    {
      this->SPKISexp_ = s;
    }


    // ObjectType
    //

    const ObjectType::Id_optional& ObjectType::
    Id () const
    {
      return this->Id_;
    }

    ObjectType::Id_optional& ObjectType::
    Id ()
    {
      return this->Id_;
    }

    void ObjectType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ObjectType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void ObjectType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }

    const ObjectType::MimeType_optional& ObjectType::
    MimeType () const
    {
      return this->MimeType_;
    }

    ObjectType::MimeType_optional& ObjectType::
    MimeType ()
    {
      return this->MimeType_;
    }

    void ObjectType::
    MimeType (const MimeType_type& x)
    {
      this->MimeType_.set (x);
    }

    void ObjectType::
    MimeType (const MimeType_optional& x)
    {
      this->MimeType_ = x;
    }

    void ObjectType::
    MimeType (::std::unique_ptr< MimeType_type > x)
    {
      this->MimeType_.set (std::move (x));
    }

    const ObjectType::Encoding_optional& ObjectType::
    Encoding () const
    {
      return this->Encoding_;
    }

    ObjectType::Encoding_optional& ObjectType::
    Encoding ()
    {
      return this->Encoding_;
    }

    void ObjectType::
    Encoding (const Encoding_type& x)
    {
      this->Encoding_.set (x);
    }

    void ObjectType::
    Encoding (const Encoding_optional& x)
    {
      this->Encoding_ = x;
    }

    void ObjectType::
    Encoding (::std::unique_ptr< Encoding_type > x)
    {
      this->Encoding_.set (std::move (x));
    }


    // ManifestType
    //

    const ManifestType::Reference_sequence& ManifestType::
    Reference () const
    {
      return this->Reference_;
    }

    ManifestType::Reference_sequence& ManifestType::
    Reference ()
    {
      return this->Reference_;
    }

    void ManifestType::
    Reference (const Reference_sequence& s)
    {
      this->Reference_ = s;
    }

    const ManifestType::Id_optional& ManifestType::
    Id () const
    {
      return this->Id_;
    }

    ManifestType::Id_optional& ManifestType::
    Id ()
    {
      return this->Id_;
    }

    void ManifestType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ManifestType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void ManifestType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // SignaturePropertiesType
    //

    const SignaturePropertiesType::SignatureProperty_sequence& SignaturePropertiesType::
    SignatureProperty () const
    {
      return this->SignatureProperty_;
    }

    SignaturePropertiesType::SignatureProperty_sequence& SignaturePropertiesType::
    SignatureProperty ()
    {
      return this->SignatureProperty_;
    }

    void SignaturePropertiesType::
    SignatureProperty (const SignatureProperty_sequence& s)
    {
      this->SignatureProperty_ = s;
    }

    const SignaturePropertiesType::Id_optional& SignaturePropertiesType::
    Id () const
    {
      return this->Id_;
    }

    SignaturePropertiesType::Id_optional& SignaturePropertiesType::
    Id ()
    {
      return this->Id_;
    }

    void SignaturePropertiesType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void SignaturePropertiesType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void SignaturePropertiesType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // SignaturePropertyType
    //

    const SignaturePropertyType::Target_type& SignaturePropertyType::
    Target () const
    {
      return this->Target_.get ();
    }

    SignaturePropertyType::Target_type& SignaturePropertyType::
    Target ()
    {
      return this->Target_.get ();
    }

    void SignaturePropertyType::
    Target (const Target_type& x)
    {
      this->Target_.set (x);
    }

    void SignaturePropertyType::
    Target (::std::unique_ptr< Target_type > x)
    {
      this->Target_.set (std::move (x));
    }

    const SignaturePropertyType::Id_optional& SignaturePropertyType::
    Id () const
    {
      return this->Id_;
    }

    SignaturePropertyType::Id_optional& SignaturePropertyType::
    Id ()
    {
      return this->Id_;
    }

    void SignaturePropertyType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void SignaturePropertyType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void SignaturePropertyType::
    Id (::std::unique_ptr< Id_type > x)
    {
      this->Id_.set (std::move (x));
    }


    // HMACOutputLengthType
    //


    // DSAKeyValueType
    //

    const DSAKeyValueType::P_optional& DSAKeyValueType::
    P () const
    {
      return this->P_;
    }

    DSAKeyValueType::P_optional& DSAKeyValueType::
    P ()
    {
      return this->P_;
    }

    void DSAKeyValueType::
    P (const P_type& x)
    {
      this->P_.set (x);
    }

    void DSAKeyValueType::
    P (const P_optional& x)
    {
      this->P_ = x;
    }

    void DSAKeyValueType::
    P (::std::unique_ptr< P_type > x)
    {
      this->P_.set (std::move (x));
    }

    const DSAKeyValueType::Q_optional& DSAKeyValueType::
    Q () const
    {
      return this->Q_;
    }

    DSAKeyValueType::Q_optional& DSAKeyValueType::
    Q ()
    {
      return this->Q_;
    }

    void DSAKeyValueType::
    Q (const Q_type& x)
    {
      this->Q_.set (x);
    }

    void DSAKeyValueType::
    Q (const Q_optional& x)
    {
      this->Q_ = x;
    }

    void DSAKeyValueType::
    Q (::std::unique_ptr< Q_type > x)
    {
      this->Q_.set (std::move (x));
    }

    const DSAKeyValueType::G_optional& DSAKeyValueType::
    G () const
    {
      return this->G_;
    }

    DSAKeyValueType::G_optional& DSAKeyValueType::
    G ()
    {
      return this->G_;
    }

    void DSAKeyValueType::
    G (const G_type& x)
    {
      this->G_.set (x);
    }

    void DSAKeyValueType::
    G (const G_optional& x)
    {
      this->G_ = x;
    }

    void DSAKeyValueType::
    G (::std::unique_ptr< G_type > x)
    {
      this->G_.set (std::move (x));
    }

    const DSAKeyValueType::Y_type& DSAKeyValueType::
    Y () const
    {
      return this->Y_.get ();
    }

    DSAKeyValueType::Y_type& DSAKeyValueType::
    Y ()
    {
      return this->Y_.get ();
    }

    void DSAKeyValueType::
    Y (const Y_type& x)
    {
      this->Y_.set (x);
    }

    void DSAKeyValueType::
    Y (::std::unique_ptr< Y_type > x)
    {
      this->Y_.set (std::move (x));
    }

    const DSAKeyValueType::J_optional& DSAKeyValueType::
    J () const
    {
      return this->J_;
    }

    DSAKeyValueType::J_optional& DSAKeyValueType::
    J ()
    {
      return this->J_;
    }

    void DSAKeyValueType::
    J (const J_type& x)
    {
      this->J_.set (x);
    }

    void DSAKeyValueType::
    J (const J_optional& x)
    {
      this->J_ = x;
    }

    void DSAKeyValueType::
    J (::std::unique_ptr< J_type > x)
    {
      this->J_.set (std::move (x));
    }

    const DSAKeyValueType::Seed_optional& DSAKeyValueType::
    Seed () const
    {
      return this->Seed_;
    }

    DSAKeyValueType::Seed_optional& DSAKeyValueType::
    Seed ()
    {
      return this->Seed_;
    }

    void DSAKeyValueType::
    Seed (const Seed_type& x)
    {
      this->Seed_.set (x);
    }

    void DSAKeyValueType::
    Seed (const Seed_optional& x)
    {
      this->Seed_ = x;
    }

    void DSAKeyValueType::
    Seed (::std::unique_ptr< Seed_type > x)
    {
      this->Seed_.set (std::move (x));
    }

    const DSAKeyValueType::PgenCounter_optional& DSAKeyValueType::
    PgenCounter () const
    {
      return this->PgenCounter_;
    }

    DSAKeyValueType::PgenCounter_optional& DSAKeyValueType::
    PgenCounter ()
    {
      return this->PgenCounter_;
    }

    void DSAKeyValueType::
    PgenCounter (const PgenCounter_type& x)
    {
      this->PgenCounter_.set (x);
    }

    void DSAKeyValueType::
    PgenCounter (const PgenCounter_optional& x)
    {
      this->PgenCounter_ = x;
    }

    void DSAKeyValueType::
    PgenCounter (::std::unique_ptr< PgenCounter_type > x)
    {
      this->PgenCounter_.set (std::move (x));
    }


    // RSAKeyValueType
    //

    const RSAKeyValueType::Modulus_type& RSAKeyValueType::
    Modulus () const
    {
      return this->Modulus_.get ();
    }

    RSAKeyValueType::Modulus_type& RSAKeyValueType::
    Modulus ()
    {
      return this->Modulus_.get ();
    }

    void RSAKeyValueType::
    Modulus (const Modulus_type& x)
    {
      this->Modulus_.set (x);
    }

    void RSAKeyValueType::
    Modulus (::std::unique_ptr< Modulus_type > x)
    {
      this->Modulus_.set (std::move (x));
    }

    const RSAKeyValueType::Exponent_type& RSAKeyValueType::
    Exponent () const
    {
      return this->Exponent_.get ();
    }

    RSAKeyValueType::Exponent_type& RSAKeyValueType::
    Exponent ()
    {
      return this->Exponent_.get ();
    }

    void RSAKeyValueType::
    Exponent (const Exponent_type& x)
    {
      this->Exponent_.set (x);
    }

    void RSAKeyValueType::
    Exponent (::std::unique_ptr< Exponent_type > x)
    {
      this->Exponent_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // CryptoBinary
    //

    CryptoBinary::
    CryptoBinary ()
    : ::xml_schema::base64_binary ()
    {
    }

    CryptoBinary::
    CryptoBinary (const ::xml_schema::base64_binary& _xsd_base64_binary_base)
    : ::xml_schema::base64_binary (_xsd_base64_binary_base)
    {
    }

    CryptoBinary::
    CryptoBinary (const CryptoBinary& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::base64_binary (x, f, c)
    {
    }

    CryptoBinary::
    CryptoBinary (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::base64_binary (e, f, c)
    {
    }

    CryptoBinary::
    CryptoBinary (const xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::base64_binary (a, f, c)
    {
    }

    CryptoBinary::
    CryptoBinary (const ::std::wstring& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::base64_binary (s, e, f, c)
    {
    }

    CryptoBinary* CryptoBinary::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CryptoBinary (*this, f, c);
    }

    CryptoBinary::
    ~CryptoBinary ()
    {
    }

    // SignatureType
    //

    SignatureType::
    SignatureType ()
    : ::xml_schema::type (),
      SignedInfo_ (this),
      SignatureValue_ (this),
      KeyInfo_ (this),
      Object_ (this),
      Id_ (this)
    {
    }

    SignatureType::
    SignatureType (const SignedInfo_type& SignedInfo,
                   const SignatureValue_type& SignatureValue)
    : ::xml_schema::type (),
      SignedInfo_ (SignedInfo, this),
      SignatureValue_ (SignatureValue, this),
      KeyInfo_ (this),
      Object_ (this),
      Id_ (this)
    {
    }

    SignatureType::
    SignatureType (::std::unique_ptr< SignedInfo_type > SignedInfo,
                   ::std::unique_ptr< SignatureValue_type > SignatureValue)
    : ::xml_schema::type (),
      SignedInfo_ (std::move (SignedInfo), this),
      SignatureValue_ (std::move (SignatureValue), this),
      KeyInfo_ (this),
      Object_ (this),
      Id_ (this)
    {
    }

    SignatureType::
    SignatureType (const SignatureType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SignedInfo_ (x.SignedInfo_, f, this),
      SignatureValue_ (x.SignatureValue_, f, this),
      KeyInfo_ (x.KeyInfo_, f, this),
      Object_ (x.Object_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignatureType::
    SignatureType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SignedInfo_ (this),
      SignatureValue_ (this),
      KeyInfo_ (this),
      Object_ (this),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SignatureType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SignedInfo
        //
        if (n.name () == L"SignedInfo" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SignedInfo_type > r (
            SignedInfo_traits::create (i, f, this));

          if (!SignedInfo_.present ())
          {
            this->SignedInfo_.set (::std::move (r));
            continue;
          }
        }

        // SignatureValue
        //
        if (n.name () == L"SignatureValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SignatureValue_type > r (
            SignatureValue_traits::create (i, f, this));

          if (!SignatureValue_.present ())
          {
            this->SignatureValue_.set (::std::move (r));
            continue;
          }
        }

        // KeyInfo
        //
        if (n.name () == L"KeyInfo" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< KeyInfo_type > r (
            KeyInfo_traits::create (i, f, this));

          if (!this->KeyInfo_)
          {
            this->KeyInfo_.set (::std::move (r));
            continue;
          }
        }

        // Object
        //
        if (n.name () == L"Object" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Object_type > r (
            Object_traits::create (i, f, this));

          this->Object_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!SignedInfo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SignedInfo",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SignatureValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SignatureValue",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }
      }
    }

    SignatureType* SignatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignatureType (*this, f, c);
    }

    SignatureType& SignatureType::
    operator= (const SignatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SignedInfo_ = x.SignedInfo_;
        this->SignatureValue_ = x.SignatureValue_;
        this->KeyInfo_ = x.KeyInfo_;
        this->Object_ = x.Object_;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    SignatureType::
    ~SignatureType ()
    {
    }

    // SignatureValueType
    //

    SignatureValueType::
    SignatureValueType ()
    : ::xml_schema::base64_binary (),
      Id_ (this)
    {
    }

    SignatureValueType::
    SignatureValueType (const ::xml_schema::base64_binary& _xsd_base64_binary_base)
    : ::xml_schema::base64_binary (_xsd_base64_binary_base),
      Id_ (this)
    {
    }

    SignatureValueType::
    SignatureValueType (const SignatureValueType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::base64_binary (x, f, c),
      Id_ (x.Id_, f, this)
    {
    }

    SignatureValueType::
    SignatureValueType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::base64_binary (e, f | ::xml_schema::flags::base, c),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SignatureValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }
      }
    }

    SignatureValueType* SignatureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignatureValueType (*this, f, c);
    }

    SignatureValueType& SignatureValueType::
    operator= (const SignatureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::base64_binary& > (*this) = x;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    SignatureValueType::
    ~SignatureValueType ()
    {
    }

    // SignedInfoType
    //

    SignedInfoType::
    SignedInfoType ()
    : ::xml_schema::type (),
      CanonicalizationMethod_ (this),
      SignatureMethod_ (this),
      Reference_ (this),
      Id_ (this)
    {
    }

    SignedInfoType::
    SignedInfoType (const CanonicalizationMethod_type& CanonicalizationMethod,
                    const SignatureMethod_type& SignatureMethod)
    : ::xml_schema::type (),
      CanonicalizationMethod_ (CanonicalizationMethod, this),
      SignatureMethod_ (SignatureMethod, this),
      Reference_ (this),
      Id_ (this)
    {
    }

    SignedInfoType::
    SignedInfoType (::std::unique_ptr< CanonicalizationMethod_type > CanonicalizationMethod,
                    ::std::unique_ptr< SignatureMethod_type > SignatureMethod)
    : ::xml_schema::type (),
      CanonicalizationMethod_ (std::move (CanonicalizationMethod), this),
      SignatureMethod_ (std::move (SignatureMethod), this),
      Reference_ (this),
      Id_ (this)
    {
    }

    SignedInfoType::
    SignedInfoType (const SignedInfoType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CanonicalizationMethod_ (x.CanonicalizationMethod_, f, this),
      SignatureMethod_ (x.SignatureMethod_, f, this),
      Reference_ (x.Reference_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignedInfoType::
    SignedInfoType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CanonicalizationMethod_ (this),
      SignatureMethod_ (this),
      Reference_ (this),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SignedInfoType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CanonicalizationMethod
        //
        if (n.name () == L"CanonicalizationMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CanonicalizationMethod_type > r (
            CanonicalizationMethod_traits::create (i, f, this));

          if (!CanonicalizationMethod_.present ())
          {
            this->CanonicalizationMethod_.set (::std::move (r));
            continue;
          }
        }

        // SignatureMethod
        //
        if (n.name () == L"SignatureMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SignatureMethod_type > r (
            SignatureMethod_traits::create (i, f, this));

          if (!SignatureMethod_.present ())
          {
            this->SignatureMethod_.set (::std::move (r));
            continue;
          }
        }

        // Reference
        //
        if (n.name () == L"Reference" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Reference_type > r (
            Reference_traits::create (i, f, this));

          this->Reference_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!CanonicalizationMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CanonicalizationMethod",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!SignatureMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"SignatureMethod",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }
      }
    }

    SignedInfoType* SignedInfoType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignedInfoType (*this, f, c);
    }

    SignedInfoType& SignedInfoType::
    operator= (const SignedInfoType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CanonicalizationMethod_ = x.CanonicalizationMethod_;
        this->SignatureMethod_ = x.SignatureMethod_;
        this->Reference_ = x.Reference_;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    SignedInfoType::
    ~SignedInfoType ()
    {
    }

    // CanonicalizationMethodType
    //

    CanonicalizationMethodType::
    CanonicalizationMethodType ()
    : ::xml_schema::type (),
      Algorithm_ (this)
    {
    }

    CanonicalizationMethodType::
    CanonicalizationMethodType (const Algorithm_type& Algorithm)
    : ::xml_schema::type (),
      Algorithm_ (Algorithm, this)
    {
    }

    CanonicalizationMethodType::
    CanonicalizationMethodType (const CanonicalizationMethodType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    CanonicalizationMethodType::
    CanonicalizationMethodType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Algorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CanonicalizationMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Algorithm" && n.namespace_ ().empty ())
        {
          this->Algorithm_.set (Algorithm_traits::create (i, f, this));
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Algorithm",
          L"");
      }
    }

    CanonicalizationMethodType* CanonicalizationMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CanonicalizationMethodType (*this, f, c);
    }

    CanonicalizationMethodType& CanonicalizationMethodType::
    operator= (const CanonicalizationMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Algorithm_ = x.Algorithm_;
      }

      return *this;
    }

    CanonicalizationMethodType::
    ~CanonicalizationMethodType ()
    {
    }

    // SignatureMethodType
    //

    SignatureMethodType::
    SignatureMethodType ()
    : ::xml_schema::type (),
      HMACOutputLength_ (this),
      Algorithm_ (this)
    {
    }

    SignatureMethodType::
    SignatureMethodType (const Algorithm_type& Algorithm)
    : ::xml_schema::type (),
      HMACOutputLength_ (this),
      Algorithm_ (Algorithm, this)
    {
    }

    SignatureMethodType::
    SignatureMethodType (const SignatureMethodType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      HMACOutputLength_ (x.HMACOutputLength_, f, this),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    SignatureMethodType::
    SignatureMethodType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      HMACOutputLength_ (this),
      Algorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SignatureMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // HMACOutputLength
        //
        if (n.name () == L"HMACOutputLength" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< HMACOutputLength_type > r (
            HMACOutputLength_traits::create (i, f, this));

          if (!this->HMACOutputLength_)
          {
            this->HMACOutputLength_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Algorithm" && n.namespace_ ().empty ())
        {
          this->Algorithm_.set (Algorithm_traits::create (i, f, this));
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Algorithm",
          L"");
      }
    }

    SignatureMethodType* SignatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignatureMethodType (*this, f, c);
    }

    SignatureMethodType& SignatureMethodType::
    operator= (const SignatureMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->HMACOutputLength_ = x.HMACOutputLength_;
        this->Algorithm_ = x.Algorithm_;
      }

      return *this;
    }

    SignatureMethodType::
    ~SignatureMethodType ()
    {
    }

    // ReferenceType
    //

    ReferenceType::
    ReferenceType ()
    : ::xml_schema::type (),
      Transforms_ (this),
      DigestMethod_ (this),
      DigestValue_ (this),
      Id_ (this),
      URI_ (this),
      Type_ (this)
    {
    }

    ReferenceType::
    ReferenceType (const Transforms_type& Transforms,
                   const DigestMethod_type& DigestMethod,
                   const DigestValue_type& DigestValue)
    : ::xml_schema::type (),
      Transforms_ (Transforms, this),
      DigestMethod_ (DigestMethod, this),
      DigestValue_ (DigestValue, this),
      Id_ (this),
      URI_ (this),
      Type_ (this)
    {
    }

    ReferenceType::
    ReferenceType (::std::unique_ptr< Transforms_type > Transforms,
                   ::std::unique_ptr< DigestMethod_type > DigestMethod,
                   const DigestValue_type& DigestValue)
    : ::xml_schema::type (),
      Transforms_ (std::move (Transforms), this),
      DigestMethod_ (std::move (DigestMethod), this),
      DigestValue_ (DigestValue, this),
      Id_ (this),
      URI_ (this),
      Type_ (this)
    {
    }

    ReferenceType::
    ReferenceType (const ReferenceType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Transforms_ (x.Transforms_, f, this),
      DigestMethod_ (x.DigestMethod_, f, this),
      DigestValue_ (x.DigestValue_, f, this),
      Id_ (x.Id_, f, this),
      URI_ (x.URI_, f, this),
      Type_ (x.Type_, f, this)
    {
    }

    ReferenceType::
    ReferenceType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Transforms_ (this),
      DigestMethod_ (this),
      DigestValue_ (this),
      Id_ (this),
      URI_ (this),
      Type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Transforms
        //
        if (n.name () == L"Transforms" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transforms_type > r (
            Transforms_traits::create (i, f, this));

          if (!Transforms_.present ())
          {
            this->Transforms_.set (::std::move (r));
            continue;
          }
        }

        // DigestMethod
        //
        if (n.name () == L"DigestMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DigestMethod_type > r (
            DigestMethod_traits::create (i, f, this));

          if (!DigestMethod_.present ())
          {
            this->DigestMethod_.set (::std::move (r));
            continue;
          }
        }

        // DigestValue
        //
        if (n.name () == L"DigestValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DigestValue_type > r (
            DigestValue_traits::create (i, f, this));

          if (!DigestValue_.present ())
          {
            this->DigestValue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Transforms_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transforms",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DigestMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DigestMethod",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!DigestValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"DigestValue",
          L"http://qifstandards.org/xsd/qif3");
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"URI" && n.namespace_ ().empty ())
        {
          this->URI_.set (URI_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"Type" && n.namespace_ ().empty ())
        {
          this->Type_.set (Type_traits::create (i, f, this));
          continue;
        }
      }
    }

    ReferenceType* ReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReferenceType (*this, f, c);
    }

    ReferenceType& ReferenceType::
    operator= (const ReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Transforms_ = x.Transforms_;
        this->DigestMethod_ = x.DigestMethod_;
        this->DigestValue_ = x.DigestValue_;
        this->Id_ = x.Id_;
        this->URI_ = x.URI_;
        this->Type_ = x.Type_;
      }

      return *this;
    }

    ReferenceType::
    ~ReferenceType ()
    {
    }

    // DsTransformsType
    //

    DsTransformsType::
    DsTransformsType ()
    : ::xml_schema::type (),
      Transform_ (this)
    {
    }

    DsTransformsType::
    DsTransformsType (const Transform_type& Transform)
    : ::xml_schema::type (),
      Transform_ (Transform, this)
    {
    }

    DsTransformsType::
    DsTransformsType (::std::unique_ptr< Transform_type > Transform)
    : ::xml_schema::type (),
      Transform_ (std::move (Transform), this)
    {
    }

    DsTransformsType::
    DsTransformsType (const DsTransformsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Transform_ (x.Transform_, f, this)
    {
    }

    DsTransformsType::
    DsTransformsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DsTransformsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!Transform_.present ())
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Transform_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Transform",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DsTransformsType* DsTransformsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DsTransformsType (*this, f, c);
    }

    DsTransformsType& DsTransformsType::
    operator= (const DsTransformsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    DsTransformsType::
    ~DsTransformsType ()
    {
    }

    // DsTransformType
    //

    DsTransformType::
    DsTransformType ()
    : ::xml_schema::type (),
      XPath_ (this),
      Algorithm_ (this)
    {
    }

    DsTransformType::
    DsTransformType (const Algorithm_type& Algorithm)
    : ::xml_schema::type (),
      XPath_ (this),
      Algorithm_ (Algorithm, this)
    {
    }

    DsTransformType::
    DsTransformType (const DsTransformType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XPath_ (x.XPath_, f, this),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    DsTransformType::
    DsTransformType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XPath_ (this),
      Algorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DsTransformType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // XPath
        //
        if (n.name () == L"XPath" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< XPath_type > r (
            XPath_traits::create (i, f, this));

          this->XPath_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Algorithm" && n.namespace_ ().empty ())
        {
          this->Algorithm_.set (Algorithm_traits::create (i, f, this));
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Algorithm",
          L"");
      }
    }

    DsTransformType* DsTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DsTransformType (*this, f, c);
    }

    DsTransformType& DsTransformType::
    operator= (const DsTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XPath_ = x.XPath_;
        this->Algorithm_ = x.Algorithm_;
      }

      return *this;
    }

    DsTransformType::
    ~DsTransformType ()
    {
    }

    // DigestMethodType
    //

    DigestMethodType::
    DigestMethodType ()
    : ::xml_schema::type (),
      Algorithm_ (this)
    {
    }

    DigestMethodType::
    DigestMethodType (const Algorithm_type& Algorithm)
    : ::xml_schema::type (),
      Algorithm_ (Algorithm, this)
    {
    }

    DigestMethodType::
    DigestMethodType (const DigestMethodType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    DigestMethodType::
    DigestMethodType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Algorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DigestMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Algorithm" && n.namespace_ ().empty ())
        {
          this->Algorithm_.set (Algorithm_traits::create (i, f, this));
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Algorithm",
          L"");
      }
    }

    DigestMethodType* DigestMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigestMethodType (*this, f, c);
    }

    DigestMethodType& DigestMethodType::
    operator= (const DigestMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Algorithm_ = x.Algorithm_;
      }

      return *this;
    }

    DigestMethodType::
    ~DigestMethodType ()
    {
    }

    // DigestValueType
    //

    DigestValueType::
    DigestValueType ()
    : ::xml_schema::base64_binary ()
    {
    }

    DigestValueType::
    DigestValueType (const ::xml_schema::base64_binary& _xsd_base64_binary_base)
    : ::xml_schema::base64_binary (_xsd_base64_binary_base)
    {
    }

    DigestValueType::
    DigestValueType (const DigestValueType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::base64_binary (x, f, c)
    {
    }

    DigestValueType::
    DigestValueType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::base64_binary (e, f, c)
    {
    }

    DigestValueType::
    DigestValueType (const xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::base64_binary (a, f, c)
    {
    }

    DigestValueType::
    DigestValueType (const ::std::wstring& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::base64_binary (s, e, f, c)
    {
    }

    DigestValueType* DigestValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigestValueType (*this, f, c);
    }

    DigestValueType::
    ~DigestValueType ()
    {
    }

    // KeyInfoType
    //

    KeyInfoType::
    KeyInfoType ()
    : ::xml_schema::type (),
      KeyName_ (this),
      KeyValue_ (this),
      RetrievalMethod_ (this),
      X509Data_ (this),
      PGPData_ (this),
      SPKIData_ (this),
      MgmtData_ (this),
      Id_ (this)
    {
    }

    KeyInfoType::
    KeyInfoType (const KeyInfoType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      KeyName_ (x.KeyName_, f, this),
      KeyValue_ (x.KeyValue_, f, this),
      RetrievalMethod_ (x.RetrievalMethod_, f, this),
      X509Data_ (x.X509Data_, f, this),
      PGPData_ (x.PGPData_, f, this),
      SPKIData_ (x.SPKIData_, f, this),
      MgmtData_ (x.MgmtData_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    KeyInfoType::
    KeyInfoType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      KeyName_ (this),
      KeyValue_ (this),
      RetrievalMethod_ (this),
      X509Data_ (this),
      PGPData_ (this),
      SPKIData_ (this),
      MgmtData_ (this),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void KeyInfoType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // KeyName
        //
        if (n.name () == L"KeyName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< KeyName_type > r (
            KeyName_traits::create (i, f, this));

          this->KeyName_.push_back (::std::move (r));
          continue;
        }

        // KeyValue
        //
        if (n.name () == L"KeyValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< KeyValue_type > r (
            KeyValue_traits::create (i, f, this));

          this->KeyValue_.push_back (::std::move (r));
          continue;
        }

        // RetrievalMethod
        //
        if (n.name () == L"RetrievalMethod" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RetrievalMethod_type > r (
            RetrievalMethod_traits::create (i, f, this));

          this->RetrievalMethod_.push_back (::std::move (r));
          continue;
        }

        // X509Data
        //
        if (n.name () == L"X509Data" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< X509Data_type > r (
            X509Data_traits::create (i, f, this));

          this->X509Data_.push_back (::std::move (r));
          continue;
        }

        // PGPData
        //
        if (n.name () == L"PGPData" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PGPData_type > r (
            PGPData_traits::create (i, f, this));

          this->PGPData_.push_back (::std::move (r));
          continue;
        }

        // SPKIData
        //
        if (n.name () == L"SPKIData" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SPKIData_type > r (
            SPKIData_traits::create (i, f, this));

          this->SPKIData_.push_back (::std::move (r));
          continue;
        }

        // MgmtData
        //
        if (n.name () == L"MgmtData" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MgmtData_type > r (
            MgmtData_traits::create (i, f, this));

          this->MgmtData_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }
      }
    }

    KeyInfoType* KeyInfoType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class KeyInfoType (*this, f, c);
    }

    KeyInfoType& KeyInfoType::
    operator= (const KeyInfoType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->KeyName_ = x.KeyName_;
        this->KeyValue_ = x.KeyValue_;
        this->RetrievalMethod_ = x.RetrievalMethod_;
        this->X509Data_ = x.X509Data_;
        this->PGPData_ = x.PGPData_;
        this->SPKIData_ = x.SPKIData_;
        this->MgmtData_ = x.MgmtData_;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    KeyInfoType::
    ~KeyInfoType ()
    {
    }

    // KeyValueType
    //

    KeyValueType::
    KeyValueType ()
    : ::xml_schema::type (),
      DSAKeyValue_ (this),
      RSAKeyValue_ (this)
    {
    }

    KeyValueType::
    KeyValueType (const KeyValueType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DSAKeyValue_ (x.DSAKeyValue_, f, this),
      RSAKeyValue_ (x.RSAKeyValue_, f, this)
    {
    }

    KeyValueType::
    KeyValueType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DSAKeyValue_ (this),
      RSAKeyValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void KeyValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DSAKeyValue
        //
        if (n.name () == L"DSAKeyValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< DSAKeyValue_type > r (
            DSAKeyValue_traits::create (i, f, this));

          if (!this->DSAKeyValue_)
          {
            this->DSAKeyValue_.set (::std::move (r));
            continue;
          }
        }

        // RSAKeyValue
        //
        if (n.name () == L"RSAKeyValue" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< RSAKeyValue_type > r (
            RSAKeyValue_traits::create (i, f, this));

          if (!this->RSAKeyValue_)
          {
            this->RSAKeyValue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    KeyValueType* KeyValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class KeyValueType (*this, f, c);
    }

    KeyValueType& KeyValueType::
    operator= (const KeyValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DSAKeyValue_ = x.DSAKeyValue_;
        this->RSAKeyValue_ = x.RSAKeyValue_;
      }

      return *this;
    }

    KeyValueType::
    ~KeyValueType ()
    {
    }

    // RetrievalMethodType
    //

    RetrievalMethodType::
    RetrievalMethodType ()
    : ::xml_schema::type (),
      Transforms_ (this),
      URI_ (this),
      Type_ (this)
    {
    }

    RetrievalMethodType::
    RetrievalMethodType (const RetrievalMethodType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Transforms_ (x.Transforms_, f, this),
      URI_ (x.URI_, f, this),
      Type_ (x.Type_, f, this)
    {
    }

    RetrievalMethodType::
    RetrievalMethodType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Transforms_ (this),
      URI_ (this),
      Type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void RetrievalMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Transforms
        //
        if (n.name () == L"Transforms" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transforms_type > r (
            Transforms_traits::create (i, f, this));

          if (!this->Transforms_)
          {
            this->Transforms_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"URI" && n.namespace_ ().empty ())
        {
          this->URI_.set (URI_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"Type" && n.namespace_ ().empty ())
        {
          this->Type_.set (Type_traits::create (i, f, this));
          continue;
        }
      }
    }

    RetrievalMethodType* RetrievalMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RetrievalMethodType (*this, f, c);
    }

    RetrievalMethodType& RetrievalMethodType::
    operator= (const RetrievalMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Transforms_ = x.Transforms_;
        this->URI_ = x.URI_;
        this->Type_ = x.Type_;
      }

      return *this;
    }

    RetrievalMethodType::
    ~RetrievalMethodType ()
    {
    }

    // X509DataType
    //

    X509DataType::
    X509DataType ()
    : ::xml_schema::type (),
      X509IssuerSerial_ (this),
      X509SKI_ (this),
      X509SubjectName_ (this),
      X509Certificate_ (this),
      X509CRL_ (this)
    {
    }

    X509DataType::
    X509DataType (const X509DataType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      X509IssuerSerial_ (x.X509IssuerSerial_, f, this),
      X509SKI_ (x.X509SKI_, f, this),
      X509SubjectName_ (x.X509SubjectName_, f, this),
      X509Certificate_ (x.X509Certificate_, f, this),
      X509CRL_ (x.X509CRL_, f, this)
    {
    }

    X509DataType::
    X509DataType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      X509IssuerSerial_ (this),
      X509SKI_ (this),
      X509SubjectName_ (this),
      X509Certificate_ (this),
      X509CRL_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void X509DataType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // X509IssuerSerial
        //
        if (n.name () == L"X509IssuerSerial" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< X509IssuerSerial_type > r (
            X509IssuerSerial_traits::create (i, f, this));

          this->X509IssuerSerial_.push_back (::std::move (r));
          continue;
        }

        // X509SKI
        //
        if (n.name () == L"X509SKI" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< X509SKI_type > r (
            X509SKI_traits::create (i, f, this));

          this->X509SKI_.push_back (::std::move (r));
          continue;
        }

        // X509SubjectName
        //
        if (n.name () == L"X509SubjectName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< X509SubjectName_type > r (
            X509SubjectName_traits::create (i, f, this));

          this->X509SubjectName_.push_back (::std::move (r));
          continue;
        }

        // X509Certificate
        //
        if (n.name () == L"X509Certificate" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< X509Certificate_type > r (
            X509Certificate_traits::create (i, f, this));

          this->X509Certificate_.push_back (::std::move (r));
          continue;
        }

        // X509CRL
        //
        if (n.name () == L"X509CRL" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< X509CRL_type > r (
            X509CRL_traits::create (i, f, this));

          this->X509CRL_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    X509DataType* X509DataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class X509DataType (*this, f, c);
    }

    X509DataType& X509DataType::
    operator= (const X509DataType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->X509IssuerSerial_ = x.X509IssuerSerial_;
        this->X509SKI_ = x.X509SKI_;
        this->X509SubjectName_ = x.X509SubjectName_;
        this->X509Certificate_ = x.X509Certificate_;
        this->X509CRL_ = x.X509CRL_;
      }

      return *this;
    }

    X509DataType::
    ~X509DataType ()
    {
    }

    // X509IssuerSerialType
    //

    X509IssuerSerialType::
    X509IssuerSerialType ()
    : ::xml_schema::type (),
      X509IssuerName_ (this),
      X509SerialNumber_ (this)
    {
    }

    X509IssuerSerialType::
    X509IssuerSerialType (const X509IssuerName_type& X509IssuerName,
                          const X509SerialNumber_type& X509SerialNumber)
    : ::xml_schema::type (),
      X509IssuerName_ (X509IssuerName, this),
      X509SerialNumber_ (X509SerialNumber, this)
    {
    }

    X509IssuerSerialType::
    X509IssuerSerialType (const X509IssuerSerialType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      X509IssuerName_ (x.X509IssuerName_, f, this),
      X509SerialNumber_ (x.X509SerialNumber_, f, this)
    {
    }

    X509IssuerSerialType::
    X509IssuerSerialType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      X509IssuerName_ (this),
      X509SerialNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void X509IssuerSerialType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // X509IssuerName
        //
        if (n.name () == L"X509IssuerName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< X509IssuerName_type > r (
            X509IssuerName_traits::create (i, f, this));

          if (!X509IssuerName_.present ())
          {
            this->X509IssuerName_.set (::std::move (r));
            continue;
          }
        }

        // X509SerialNumber
        //
        if (n.name () == L"X509SerialNumber" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!X509SerialNumber_.present ())
          {
            this->X509SerialNumber_.set (X509SerialNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!X509IssuerName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"X509IssuerName",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!X509SerialNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"X509SerialNumber",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    X509IssuerSerialType* X509IssuerSerialType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class X509IssuerSerialType (*this, f, c);
    }

    X509IssuerSerialType& X509IssuerSerialType::
    operator= (const X509IssuerSerialType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->X509IssuerName_ = x.X509IssuerName_;
        this->X509SerialNumber_ = x.X509SerialNumber_;
      }

      return *this;
    }

    X509IssuerSerialType::
    ~X509IssuerSerialType ()
    {
    }

    // PGPDataType
    //

    PGPDataType::
    PGPDataType ()
    : ::xml_schema::type (),
      PGPKeyID_ (this),
      PGPKeyPacket_ (this)
    {
    }

    PGPDataType::
    PGPDataType (const PGPDataType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PGPKeyID_ (x.PGPKeyID_, f, this),
      PGPKeyPacket_ (x.PGPKeyPacket_, f, this)
    {
    }

    PGPDataType::
    PGPDataType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PGPKeyID_ (this),
      PGPKeyPacket_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PGPDataType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PGPKeyID
        //
        if (n.name () == L"PGPKeyID" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PGPKeyID_type > r (
            PGPKeyID_traits::create (i, f, this));

          if (!this->PGPKeyID_)
          {
            this->PGPKeyID_.set (::std::move (r));
            continue;
          }
        }

        // PGPKeyPacket
        //
        if (n.name () == L"PGPKeyPacket" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PGPKeyPacket_type > r (
            PGPKeyPacket_traits::create (i, f, this));

          if (!this->PGPKeyPacket_)
          {
            this->PGPKeyPacket_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PGPDataType* PGPDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PGPDataType (*this, f, c);
    }

    PGPDataType& PGPDataType::
    operator= (const PGPDataType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PGPKeyID_ = x.PGPKeyID_;
        this->PGPKeyPacket_ = x.PGPKeyPacket_;
      }

      return *this;
    }

    PGPDataType::
    ~PGPDataType ()
    {
    }

    // SPKIDataType
    //

    SPKIDataType::
    SPKIDataType ()
    : ::xml_schema::type (),
      SPKISexp_ (this)
    {
    }

    SPKIDataType::
    SPKIDataType (const SPKIDataType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SPKISexp_ (x.SPKISexp_, f, this)
    {
    }

    SPKIDataType::
    SPKIDataType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SPKISexp_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SPKIDataType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SPKISexp
        //
        if (n.name () == L"SPKISexp" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SPKISexp_type > r (
            SPKISexp_traits::create (i, f, this));

          this->SPKISexp_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    SPKIDataType* SPKIDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SPKIDataType (*this, f, c);
    }

    SPKIDataType& SPKIDataType::
    operator= (const SPKIDataType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SPKISexp_ = x.SPKISexp_;
      }

      return *this;
    }

    SPKIDataType::
    ~SPKIDataType ()
    {
    }

    // ObjectType
    //

    ObjectType::
    ObjectType ()
    : ::xml_schema::type (),
      Id_ (this),
      MimeType_ (this),
      Encoding_ (this)
    {
    }

    ObjectType::
    ObjectType (const ObjectType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this),
      MimeType_ (x.MimeType_, f, this),
      Encoding_ (x.Encoding_, f, this)
    {
    }

    ObjectType::
    ObjectType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (this),
      MimeType_ (this),
      Encoding_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ObjectType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"MimeType" && n.namespace_ ().empty ())
        {
          this->MimeType_.set (MimeType_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"Encoding" && n.namespace_ ().empty ())
        {
          this->Encoding_.set (Encoding_traits::create (i, f, this));
          continue;
        }
      }
    }

    ObjectType* ObjectType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ObjectType (*this, f, c);
    }

    ObjectType& ObjectType::
    operator= (const ObjectType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Id_ = x.Id_;
        this->MimeType_ = x.MimeType_;
        this->Encoding_ = x.Encoding_;
      }

      return *this;
    }

    ObjectType::
    ~ObjectType ()
    {
    }

    // ManifestType
    //

    ManifestType::
    ManifestType ()
    : ::xml_schema::type (),
      Reference_ (this),
      Id_ (this)
    {
    }

    ManifestType::
    ManifestType (const ManifestType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Reference_ (x.Reference_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    ManifestType::
    ManifestType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Reference_ (this),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ManifestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Reference
        //
        if (n.name () == L"Reference" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Reference_type > r (
            Reference_traits::create (i, f, this));

          this->Reference_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }
      }
    }

    ManifestType* ManifestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManifestType (*this, f, c);
    }

    ManifestType& ManifestType::
    operator= (const ManifestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Reference_ = x.Reference_;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    ManifestType::
    ~ManifestType ()
    {
    }

    // SignaturePropertiesType
    //

    SignaturePropertiesType::
    SignaturePropertiesType ()
    : ::xml_schema::type (),
      SignatureProperty_ (this),
      Id_ (this)
    {
    }

    SignaturePropertiesType::
    SignaturePropertiesType (const SignaturePropertiesType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SignatureProperty_ (x.SignatureProperty_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignaturePropertiesType::
    SignaturePropertiesType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SignatureProperty_ (this),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SignaturePropertiesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SignatureProperty
        //
        if (n.name () == L"SignatureProperty" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SignatureProperty_type > r (
            SignatureProperty_traits::create (i, f, this));

          this->SignatureProperty_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }
      }
    }

    SignaturePropertiesType* SignaturePropertiesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignaturePropertiesType (*this, f, c);
    }

    SignaturePropertiesType& SignaturePropertiesType::
    operator= (const SignaturePropertiesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SignatureProperty_ = x.SignatureProperty_;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    SignaturePropertiesType::
    ~SignaturePropertiesType ()
    {
    }

    // SignaturePropertyType
    //

    SignaturePropertyType::
    SignaturePropertyType ()
    : ::xml_schema::type (),
      Target_ (this),
      Id_ (this)
    {
    }

    SignaturePropertyType::
    SignaturePropertyType (const Target_type& Target)
    : ::xml_schema::type (),
      Target_ (Target, this),
      Id_ (this)
    {
    }

    SignaturePropertyType::
    SignaturePropertyType (const SignaturePropertyType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Target_ (x.Target_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    SignaturePropertyType::
    SignaturePropertyType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Target_ (this),
      Id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SignaturePropertyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Target" && n.namespace_ ().empty ())
        {
          this->Target_.set (Target_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          this->Id_.set (Id_traits::create (i, f, this));
          continue;
        }
      }

      if (!Target_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Target",
          L"");
      }
    }

    SignaturePropertyType* SignaturePropertyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignaturePropertyType (*this, f, c);
    }

    SignaturePropertyType& SignaturePropertyType::
    operator= (const SignaturePropertyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Target_ = x.Target_;
        this->Id_ = x.Id_;
      }

      return *this;
    }

    SignaturePropertyType::
    ~SignaturePropertyType ()
    {
    }

    // HMACOutputLengthType
    //

    HMACOutputLengthType::
    HMACOutputLengthType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > ()
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const ::xml_schema::integer& _xsd_integer_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (_xsd_integer_base)
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const HMACOutputLengthType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (x, f, c)
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (e, f, c)
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (a, f, c)
    {
    }

    HMACOutputLengthType::
    HMACOutputLengthType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    HMACOutputLengthType* HMACOutputLengthType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class HMACOutputLengthType (*this, f, c);
    }

    HMACOutputLengthType::
    ~HMACOutputLengthType ()
    {
    }

    // DSAKeyValueType
    //

    DSAKeyValueType::
    DSAKeyValueType ()
    : ::xml_schema::type (),
      P_ (this),
      Q_ (this),
      G_ (this),
      Y_ (this),
      J_ (this),
      Seed_ (this),
      PgenCounter_ (this)
    {
    }

    DSAKeyValueType::
    DSAKeyValueType (const Y_type& Y)
    : ::xml_schema::type (),
      P_ (this),
      Q_ (this),
      G_ (this),
      Y_ (Y, this),
      J_ (this),
      Seed_ (this),
      PgenCounter_ (this)
    {
    }

    DSAKeyValueType::
    DSAKeyValueType (const DSAKeyValueType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      P_ (x.P_, f, this),
      Q_ (x.Q_, f, this),
      G_ (x.G_, f, this),
      Y_ (x.Y_, f, this),
      J_ (x.J_, f, this),
      Seed_ (x.Seed_, f, this),
      PgenCounter_ (x.PgenCounter_, f, this)
    {
    }

    DSAKeyValueType::
    DSAKeyValueType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      P_ (this),
      Q_ (this),
      G_ (this),
      Y_ (this),
      J_ (this),
      Seed_ (this),
      PgenCounter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DSAKeyValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // P
        //
        if (n.name () == L"P" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< P_type > r (
            P_traits::create (i, f, this));

          if (!this->P_)
          {
            this->P_.set (::std::move (r));
            continue;
          }
        }

        // Q
        //
        if (n.name () == L"Q" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Q_type > r (
            Q_traits::create (i, f, this));

          if (!this->Q_)
          {
            this->Q_.set (::std::move (r));
            continue;
          }
        }

        // G
        //
        if (n.name () == L"G" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< G_type > r (
            G_traits::create (i, f, this));

          if (!this->G_)
          {
            this->G_.set (::std::move (r));
            continue;
          }
        }

        // Y
        //
        if (n.name () == L"Y" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Y_type > r (
            Y_traits::create (i, f, this));

          if (!Y_.present ())
          {
            this->Y_.set (::std::move (r));
            continue;
          }
        }

        // J
        //
        if (n.name () == L"J" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< J_type > r (
            J_traits::create (i, f, this));

          if (!this->J_)
          {
            this->J_.set (::std::move (r));
            continue;
          }
        }

        // Seed
        //
        if (n.name () == L"Seed" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Seed_type > r (
            Seed_traits::create (i, f, this));

          if (!this->Seed_)
          {
            this->Seed_.set (::std::move (r));
            continue;
          }
        }

        // PgenCounter
        //
        if (n.name () == L"PgenCounter" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PgenCounter_type > r (
            PgenCounter_traits::create (i, f, this));

          if (!this->PgenCounter_)
          {
            this->PgenCounter_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Y_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Y",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    DSAKeyValueType* DSAKeyValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DSAKeyValueType (*this, f, c);
    }

    DSAKeyValueType& DSAKeyValueType::
    operator= (const DSAKeyValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->P_ = x.P_;
        this->Q_ = x.Q_;
        this->G_ = x.G_;
        this->Y_ = x.Y_;
        this->J_ = x.J_;
        this->Seed_ = x.Seed_;
        this->PgenCounter_ = x.PgenCounter_;
      }

      return *this;
    }

    DSAKeyValueType::
    ~DSAKeyValueType ()
    {
    }

    // RSAKeyValueType
    //

    RSAKeyValueType::
    RSAKeyValueType ()
    : ::xml_schema::type (),
      Modulus_ (this),
      Exponent_ (this)
    {
    }

    RSAKeyValueType::
    RSAKeyValueType (const Modulus_type& Modulus,
                     const Exponent_type& Exponent)
    : ::xml_schema::type (),
      Modulus_ (Modulus, this),
      Exponent_ (Exponent, this)
    {
    }

    RSAKeyValueType::
    RSAKeyValueType (const RSAKeyValueType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Modulus_ (x.Modulus_, f, this),
      Exponent_ (x.Exponent_, f, this)
    {
    }

    RSAKeyValueType::
    RSAKeyValueType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Modulus_ (this),
      Exponent_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RSAKeyValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Modulus
        //
        if (n.name () == L"Modulus" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Modulus_type > r (
            Modulus_traits::create (i, f, this));

          if (!Modulus_.present ())
          {
            this->Modulus_.set (::std::move (r));
            continue;
          }
        }

        // Exponent
        //
        if (n.name () == L"Exponent" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Exponent_type > r (
            Exponent_traits::create (i, f, this));

          if (!Exponent_.present ())
          {
            this->Exponent_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Modulus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Modulus",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!Exponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Exponent",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    RSAKeyValueType* RSAKeyValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RSAKeyValueType (*this, f, c);
    }

    RSAKeyValueType& RSAKeyValueType::
    operator= (const RSAKeyValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Modulus_ = x.Modulus_;
        this->Exponent_ = x.Exponent_;
      }

      return *this;
    }

    RSAKeyValueType::
    ~RSAKeyValueType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const CryptoBinary& i)
    {
      e << static_cast< const ::xml_schema::base64_binary& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const CryptoBinary& i)
    {
      a << static_cast< const ::xml_schema::base64_binary& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CryptoBinary& i)
    {
      l << static_cast< const ::xml_schema::base64_binary& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const SignatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SignedInfo
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SignedInfo",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SignedInfo ();
      }

      // SignatureValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SignatureValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SignatureValue ();
      }

      // KeyInfo
      //
      if (i.KeyInfo ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"KeyInfo",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.KeyInfo ();
      }

      // Object
      //
      for (SignatureType::Object_const_iterator
           b (i.Object ().begin ()), n (i.Object ().end ());
           b != n; ++b)
      {
        const SignatureType::Object_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Object",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignatureValueType& i)
    {
      e << static_cast< const ::xml_schema::base64_binary& > (i);

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignedInfoType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CanonicalizationMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CanonicalizationMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CanonicalizationMethod ();
      }

      // SignatureMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SignatureMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.SignatureMethod ();
      }

      // Reference
      //
      for (SignedInfoType::Reference_const_iterator
           b (i.Reference ().begin ()), n (i.Reference ().end ());
           b != n; ++b)
      {
        const SignedInfoType::Reference_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Reference",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CanonicalizationMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Algorithm
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Algorithm",
            e));

        a << i.Algorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignatureMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // HMACOutputLength
      //
      if (i.HMACOutputLength ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"HMACOutputLength",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.HMACOutputLength ();
      }

      // Algorithm
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Algorithm",
            e));

        a << i.Algorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Transforms
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transforms",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transforms ();
      }

      // DigestMethod
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DigestMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DigestMethod ();
      }

      // DigestValue
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DigestValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.DigestValue ();
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }

      // URI
      //
      if (i.URI ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"URI",
            e));

        a << *i.URI ();
      }

      // Type
      //
      if (i.Type ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Type",
            e));

        a << *i.Type ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DsTransformsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Transform
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Transform ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DsTransformType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XPath
      //
      for (DsTransformType::XPath_const_iterator
           b (i.XPath ().begin ()), n (i.XPath ().end ());
           b != n; ++b)
      {
        const DsTransformType::XPath_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"XPath",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // Algorithm
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Algorithm",
            e));

        a << i.Algorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DigestMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Algorithm
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Algorithm",
            e));

        a << i.Algorithm ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const DigestValueType& i)
    {
      e << static_cast< const ::xml_schema::base64_binary& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const DigestValueType& i)
    {
      a << static_cast< const ::xml_schema::base64_binary& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DigestValueType& i)
    {
      l << static_cast< const ::xml_schema::base64_binary& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const KeyInfoType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // KeyName
      //
      for (KeyInfoType::KeyName_const_iterator
           b (i.KeyName ().begin ()), n (i.KeyName ().end ());
           b != n; ++b)
      {
        const KeyInfoType::KeyName_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"KeyName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // KeyValue
      //
      for (KeyInfoType::KeyValue_const_iterator
           b (i.KeyValue ().begin ()), n (i.KeyValue ().end ());
           b != n; ++b)
      {
        const KeyInfoType::KeyValue_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"KeyValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // RetrievalMethod
      //
      for (KeyInfoType::RetrievalMethod_const_iterator
           b (i.RetrievalMethod ().begin ()), n (i.RetrievalMethod ().end ());
           b != n; ++b)
      {
        const KeyInfoType::RetrievalMethod_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RetrievalMethod",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // X509Data
      //
      for (KeyInfoType::X509Data_const_iterator
           b (i.X509Data ().begin ()), n (i.X509Data ().end ());
           b != n; ++b)
      {
        const KeyInfoType::X509Data_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X509Data",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // PGPData
      //
      for (KeyInfoType::PGPData_const_iterator
           b (i.PGPData ().begin ()), n (i.PGPData ().end ());
           b != n; ++b)
      {
        const KeyInfoType::PGPData_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PGPData",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // SPKIData
      //
      for (KeyInfoType::SPKIData_const_iterator
           b (i.SPKIData ().begin ()), n (i.SPKIData ().end ());
           b != n; ++b)
      {
        const KeyInfoType::SPKIData_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SPKIData",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // MgmtData
      //
      for (KeyInfoType::MgmtData_const_iterator
           b (i.MgmtData ().begin ()), n (i.MgmtData ().end ());
           b != n; ++b)
      {
        const KeyInfoType::MgmtData_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MgmtData",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const KeyValueType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DSAKeyValue
      //
      if (i.DSAKeyValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"DSAKeyValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.DSAKeyValue ();
      }

      // RSAKeyValue
      //
      if (i.RSAKeyValue ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"RSAKeyValue",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.RSAKeyValue ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RetrievalMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Transforms
      //
      if (i.Transforms ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transforms",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transforms ();
      }

      // URI
      //
      if (i.URI ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"URI",
            e));

        a << *i.URI ();
      }

      // Type
      //
      if (i.Type ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Type",
            e));

        a << *i.Type ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const X509DataType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // X509IssuerSerial
      //
      for (X509DataType::X509IssuerSerial_const_iterator
           b (i.X509IssuerSerial ().begin ()), n (i.X509IssuerSerial ().end ());
           b != n; ++b)
      {
        const X509DataType::X509IssuerSerial_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X509IssuerSerial",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // X509SKI
      //
      for (X509DataType::X509SKI_const_iterator
           b (i.X509SKI ().begin ()), n (i.X509SKI ().end ());
           b != n; ++b)
      {
        const X509DataType::X509SKI_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X509SKI",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // X509SubjectName
      //
      for (X509DataType::X509SubjectName_const_iterator
           b (i.X509SubjectName ().begin ()), n (i.X509SubjectName ().end ());
           b != n; ++b)
      {
        const X509DataType::X509SubjectName_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X509SubjectName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // X509Certificate
      //
      for (X509DataType::X509Certificate_const_iterator
           b (i.X509Certificate ().begin ()), n (i.X509Certificate ().end ());
           b != n; ++b)
      {
        const X509DataType::X509Certificate_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X509Certificate",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // X509CRL
      //
      for (X509DataType::X509CRL_const_iterator
           b (i.X509CRL ().begin ()), n (i.X509CRL ().end ());
           b != n; ++b)
      {
        const X509DataType::X509CRL_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X509CRL",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const X509IssuerSerialType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // X509IssuerName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X509IssuerName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.X509IssuerName ();
      }

      // X509SerialNumber
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"X509SerialNumber",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.X509SerialNumber ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PGPDataType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PGPKeyID
      //
      if (i.PGPKeyID ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PGPKeyID",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PGPKeyID ();
      }

      // PGPKeyPacket
      //
      if (i.PGPKeyPacket ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PGPKeyPacket",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PGPKeyPacket ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SPKIDataType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SPKISexp
      //
      for (SPKIDataType::SPKISexp_const_iterator
           b (i.SPKISexp ().begin ()), n (i.SPKISexp ().end ());
           b != n; ++b)
      {
        const SPKIDataType::SPKISexp_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SPKISexp",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ObjectType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }

      // MimeType
      //
      if (i.MimeType ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"MimeType",
            e));

        a << *i.MimeType ();
      }

      // Encoding
      //
      if (i.Encoding ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Encoding",
            e));

        a << *i.Encoding ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ManifestType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Reference
      //
      for (ManifestType::Reference_const_iterator
           b (i.Reference ().begin ()), n (i.Reference ().end ());
           b != n; ++b)
      {
        const ManifestType::Reference_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Reference",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignaturePropertiesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SignatureProperty
      //
      for (SignaturePropertiesType::SignatureProperty_const_iterator
           b (i.SignatureProperty ().begin ()), n (i.SignatureProperty ().end ());
           b != n; ++b)
      {
        const SignaturePropertiesType::SignatureProperty_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SignatureProperty",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SignaturePropertyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Target
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Target",
            e));

        a << i.Target ();
      }

      // Id
      //
      if (i.Id ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const HMACOutputLengthType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const HMACOutputLengthType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const HMACOutputLengthType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const DSAKeyValueType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // P
      //
      if (i.P ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"P",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.P ();
      }

      // Q
      //
      if (i.Q ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Q",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Q ();
      }

      // G
      //
      if (i.G ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"G",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.G ();
      }

      // Y
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Y",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Y ();
      }

      // J
      //
      if (i.J ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"J",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.J ();
      }

      // Seed
      //
      if (i.Seed ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Seed",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Seed ();
      }

      // PgenCounter
      //
      if (i.PgenCounter ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PgenCounter",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PgenCounter ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const RSAKeyValueType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Modulus
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Modulus",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Modulus ();
      }

      // Exponent
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Exponent",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Exponent ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

