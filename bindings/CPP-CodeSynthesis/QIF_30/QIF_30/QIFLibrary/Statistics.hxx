// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_STATISTICS_HXX
#define CXX___QIFLIBRARY_STATISTICS_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class LimitingNumberType;
    class CriterionDecimalType;
    class CriterionLinearType;
    class CriterionAngularType;
    class CriterionAreaType;
    class CriterionForceType;
    class CriterionMassType;
    class CriterionPressureType;
    class CriterionSpeedType;
    class CriterionTemperatureType;
    class CriterionTimeType;
    class CriterionUserDefinedUnitType;
    class CriterionIntegerType;
    class CriterionOutOfType;
    class SamplingMethodType;
    class SamplingIntervalEnumType;
    class SamplingIntervalType;
    class ExclusionEnumType;
    class ExclusionReasonType;
    class ExclusionIdType;
    class ExclusionIndexType;
    class ExclusionsIdType;
    class ExclusionsIndexType;
    class StatsArrayIdType;
    class StatsValuesType;
    class StatsEvalStatusEnumType;
    class StatsEvalStatusType;
    class StudyIssuesType;
    class OneSidedCapabilityCalculationEnumType;
    class PositionCapabilityCalculationEnumType;
    class DistributionTransformationEnumType;
    class DistributionTransformationType;
    class SubgroupType;
    class SubgroupsType;
    class SubgroupValuesType;
    class CharacteristicStatsEvalBaseType;
    class StatsBaseType;
    class StatsNumericalBaseType;
    class StatsWithTolNumericalBaseType;
    class StatsWithTolLinearType;
    class StatsWithTolAngularType;
    class StatsWithTolAreaType;
    class StatsWithTolForceType;
    class StatsWithTolMassType;
    class StatsWithTolPressureType;
    class StatsWithTolSpeedType;
    class StatsWithTolTemperatureType;
    class StatsWithTolTimeType;
    class StatsWithTolUserDefinedUnitType;
    class StatsLinearType;
    class StatsAngularType;
    class StatsAreaType;
    class StatsForceType;
    class StatsMassType;
    class StatsPressureType;
    class StatsSpeedType;
    class StatsTemperatureType;
    class StatsTimeType;
    class StatsUserDefinedUnitType;
    class StatsPassFailType;
    class GeometricCharacteristicStatsEvalType;
    class CompositeSegmentStatsEvalBaseType;
    class CompositeSegmentPositionStatsEvalType;
    class CompositeSegmentsPositionStatsEvalType;
    class CompositeSegmentProfileStatsEvalType;
    class CompositeSegmentsProfileStatsEvalType;
    class CompositeSegmentSymmetryStatsEvalType;
    class CompositeSegmentsSymmetryStatsEvalType;
    class LinearCharacteristicStatsEvalType;
    class AngularCharacteristicStatsEvalType;
    class UserDefinedAttributeCharacteristicStatsEvalType;
    class UserDefinedLinearCharacteristicStatsEvalType;
    class UserDefinedAngularCharacteristicStatsEvalType;
    class UserDefinedAreaCharacteristicStatsEvalType;
    class UserDefinedForceCharacteristicStatsEvalType;
    class UserDefinedMassCharacteristicStatsEvalType;
    class UserDefinedPressureCharacteristicStatsEvalType;
    class UserDefinedSpeedCharacteristicStatsEvalType;
    class UserDefinedTemperatureCharacteristicStatsEvalType;
    class UserDefinedTimeCharacteristicStatsEvalType;
    class UserDefinedUnitCharacteristicStatsEvalType;
    class SurfaceTextureCharacteristicStatsEvalType;
    class OrientationCharacteristicStatsEvalType;
    class AngularityCharacteristicStatsEvalType;
    class PerpendicularityCharacteristicStatsEvalType;
    class ParallelismCharacteristicStatsEvalType;
    class FormCharacteristicStatsEvalBaseType;
    class CircularityCharacteristicStatsEvalType;
    class ConicityCharacteristicStatsEvalType;
    class CylindricityCharacteristicStatsEvalType;
    class EllipticityCharacteristicStatsEvalType;
    class FlatnessCharacteristicStatsEvalType;
    class SphericityCharacteristicStatsEvalType;
    class StraightnessCharacteristicStatsEvalType;
    class ToroidicityCharacteristicStatsEvalType;
    class OtherFormCharacteristicStatsEvalType;
    class LocationCharacteristicStatsEvalType;
    class PositionCharacteristicStatsEvalType;
    class AngularCoordinateCharacteristicStatsEvalType;
    class AngleCharacteristicStatsEvalType;
    class AngleFromCharacteristicStatsEvalType;
    class AngleBetweenCharacteristicStatsEvalType;
    class LinearCoordinateCharacteristicStatsEvalType;
    class CurveLengthCharacteristicStatsEvalType;
    class DiameterCharacteristicStatsEvalType;
    class SphericalDiameterCharacteristicStatsEvalType;
    class LengthCharacteristicStatsEvalType;
    class WidthCharacteristicStatsEvalType;
    class HeightCharacteristicStatsEvalType;
    class DepthCharacteristicStatsEvalType;
    class ThicknessCharacteristicStatsEvalType;
    class SquareCharacteristicStatsEvalType;
    class DistanceFromCharacteristicStatsEvalType;
    class DistanceBetweenCharacteristicStatsEvalType;
    class RadiusCharacteristicStatsEvalType;
    class SphericalRadiusCharacteristicStatsEvalType;
    class ChordCharacteristicStatsEvalType;
    class ConicalTaperCharacteristicStatsEvalType;
    class FlatTaperCharacteristicStatsEvalType;
    class RunoutCharacteristicStatsEvalBaseType;
    class CircularRunoutCharacteristicStatsEvalType;
    class TotalRunoutCharacteristicStatsEvalType;
    class CoaxialityCharacteristicStatsEvalType;
    class ConcentricityCharacteristicStatsEvalType;
    class SymmetryCharacteristicStatsEvalType;
    class PointDeviationStatsEvalType;
    class PointDeviationsStatsEvalType;
    class ProfileCharacteristicStatsEvalBaseType;
    class LineProfileCharacteristicStatsEvalType;
    class PointProfileCharacteristicStatsEvalType;
    class SurfaceProfileCharacteristicStatsEvalType;
    class SurfaceProfileNonUniformCharacteristicStatsEvalType;
    class ThreadCharacteristicStatsEvalType;
    class WeldCharacteristicStatsEvalBaseType;
    class WeldFilletCharacteristicStatsEvalType;
    class WeldPlugCharacteristicStatsEvalType;
    class WeldSlotCharacteristicStatsEvalType;
    class WeldSpotCharacteristicStatsEvalType;
    class WeldStudCharacteristicStatsEvalType;
    class WeldSeamCharacteristicStatsEvalType;
    class WeldSurfacingCharacteristicStatsEvalType;
    class WeldEdgeCharacteristicStatsEvalType;
    class WeldSquareCharacteristicStatsEvalType;
    class WeldBevelCharacteristicStatsEvalType;
    class WeldVCharacteristicStatsEvalType;
    class WeldUCharacteristicStatsEvalType;
    class WeldJCharacteristicStatsEvalType;
    class WeldFlareVCharacteristicStatsEvalType;
    class WeldFlareBevelCharacteristicStatsEvalType;
    class WeldScarfCharacteristicStatsEvalType;
    class WeldCompoundCharacteristicStatsEvalType;
    class CharacteristicsStatsType;
    class AverageFeatureType;
    class AverageFeaturesType;
    class SummaryStatisticsType;
    class SummariesStatisticsType;
    class SummaryStatisticsLinearType;
    class SummariesStatisticsLinearType;
    class SummaryStatisticsAngularType;
    class SummariesStatisticsAngularType;
    class SummaryStatisticsAreaType;
    class SummariesStatisticsAreaType;
    class SummaryStatisticsForceType;
    class SummariesStatisticsForceType;
    class SummaryStatisticsMassType;
    class SummariesStatisticsMassType;
    class SummaryStatisticsPressureType;
    class SummariesStatisticsPressureType;
    class SummaryStatisticsSpeedType;
    class SummariesStatisticsSpeedType;
    class SummaryStatisticsTemperatureType;
    class SummariesStatisticsTemperatureType;
    class SummaryStatisticsTimeType;
    class SummariesStatisticsTimeType;
    class SummaryStatisticsUserDefinedUnitType;
    class SummariesStatisticsUserDefinedUnitType;
    class AssignableCauseEnumType;
    class AssignableCauseType;
    class AssignableCausesType;
    class ActionToTakeEnumType;
    class CorrectiveActionType;
    class CorrectiveActionsType;
    class StudyIssueType;
    class ControlIssueEnumType;
    class ControlIssueType;
    class ControlIssueDetailsType;
    class ControlIssueDetailsListType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/Features.hxx"

#include "../QIFLibrary/Traceability.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL LimitingNumberType: public ::xml_schema::type
    {
      public:
      // Count
      //
      typedef ::xml_schema::non_negative_integer Count_type;
      typedef ::xsd::cxx::tree::optional< Count_type > Count_optional;
      typedef ::xsd::cxx::tree::traits< Count_type, wchar_t > Count_traits;

      const Count_optional&
      Count () const;

      Count_optional&
      Count ();

      void
      Count (const Count_type& x);

      void
      Count (const Count_optional& x);

      // Fraction
      //
      typedef ::xml_schema::decimal Fraction_type;
      typedef ::xsd::cxx::tree::optional< Fraction_type > Fraction_optional;
      typedef ::xsd::cxx::tree::traits< Fraction_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > Fraction_traits;

      const Fraction_optional&
      Fraction () const;

      Fraction_optional&
      Fraction ();

      void
      Fraction (const Fraction_type& x);

      void
      Fraction (const Fraction_optional& x);

      // Constructors.
      //
      LimitingNumberType ();

      LimitingNumberType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      LimitingNumberType (const LimitingNumberType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual LimitingNumberType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LimitingNumberType&
      operator= (const LimitingNumberType& x);

      virtual 
      ~LimitingNumberType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Count_optional Count_;
      Fraction_optional Fraction_;
    };

    class QIF30_SYMBOL_DECL CriterionDecimalType: public ::xml_schema::type
    {
      public:
      // Limit
      //
      typedef ::xml_schema::decimal Limit_type;
      typedef ::xsd::cxx::tree::traits< Limit_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > Limit_traits;

      const Limit_type&
      Limit () const;

      Limit_type&
      Limit ();

      void
      Limit (const Limit_type& x);

      // NumberAllowedExceptions
      //
      typedef ::xsd::qif30::LimitingNumberType NumberAllowedExceptions_type;
      typedef ::xsd::cxx::tree::optional< NumberAllowedExceptions_type > NumberAllowedExceptions_optional;
      typedef ::xsd::cxx::tree::traits< NumberAllowedExceptions_type, wchar_t > NumberAllowedExceptions_traits;

      const NumberAllowedExceptions_optional&
      NumberAllowedExceptions () const;

      NumberAllowedExceptions_optional&
      NumberAllowedExceptions ();

      void
      NumberAllowedExceptions (const NumberAllowedExceptions_type& x);

      void
      NumberAllowedExceptions (const NumberAllowedExceptions_optional& x);

      void
      NumberAllowedExceptions (::std::unique_ptr< NumberAllowedExceptions_type > p);

      // ExtremeLimit
      //
      typedef ::xml_schema::decimal ExtremeLimit_type;
      typedef ::xsd::cxx::tree::optional< ExtremeLimit_type > ExtremeLimit_optional;
      typedef ::xsd::cxx::tree::traits< ExtremeLimit_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > ExtremeLimit_traits;

      const ExtremeLimit_optional&
      ExtremeLimit () const;

      ExtremeLimit_optional&
      ExtremeLimit ();

      void
      ExtremeLimit (const ExtremeLimit_type& x);

      void
      ExtremeLimit (const ExtremeLimit_optional& x);

      // Constructors.
      //
      CriterionDecimalType ();

      CriterionDecimalType (const Limit_type&);

      CriterionDecimalType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CriterionDecimalType (const CriterionDecimalType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CriterionDecimalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionDecimalType&
      operator= (const CriterionDecimalType& x);

      virtual 
      ~CriterionDecimalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Limit_type > Limit_;
      NumberAllowedExceptions_optional NumberAllowedExceptions_;
      ExtremeLimit_optional ExtremeLimit_;
    };

    class QIF30_SYMBOL_DECL CriterionLinearType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // Constructors.
      //
      CriterionLinearType ();

      CriterionLinearType (const Limit_type&);

      CriterionLinearType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CriterionLinearType (const CriterionLinearType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CriterionLinearType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionLinearType&
      operator= (const CriterionLinearType& x);

      virtual 
      ~CriterionLinearType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionAngularType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, wchar_t > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::unique_ptr< angularUnit_type > p);

      // Constructors.
      //
      CriterionAngularType ();

      CriterionAngularType (const Limit_type&);

      CriterionAngularType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CriterionAngularType (const CriterionAngularType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CriterionAngularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionAngularType&
      operator= (const CriterionAngularType& x);

      virtual 
      ~CriterionAngularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionAreaType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // areaUnit
      //
      typedef ::xml_schema::token areaUnit_type;
      typedef ::xsd::cxx::tree::optional< areaUnit_type > areaUnit_optional;
      typedef ::xsd::cxx::tree::traits< areaUnit_type, wchar_t > areaUnit_traits;

      const areaUnit_optional&
      areaUnit () const;

      areaUnit_optional&
      areaUnit ();

      void
      areaUnit (const areaUnit_type& x);

      void
      areaUnit (const areaUnit_optional& x);

      void
      areaUnit (::std::unique_ptr< areaUnit_type > p);

      // Constructors.
      //
      CriterionAreaType ();

      CriterionAreaType (const Limit_type&);

      CriterionAreaType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CriterionAreaType (const CriterionAreaType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CriterionAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionAreaType&
      operator= (const CriterionAreaType& x);

      virtual 
      ~CriterionAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      areaUnit_optional areaUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionForceType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // forceUnit
      //
      typedef ::xml_schema::token forceUnit_type;
      typedef ::xsd::cxx::tree::optional< forceUnit_type > forceUnit_optional;
      typedef ::xsd::cxx::tree::traits< forceUnit_type, wchar_t > forceUnit_traits;

      const forceUnit_optional&
      forceUnit () const;

      forceUnit_optional&
      forceUnit ();

      void
      forceUnit (const forceUnit_type& x);

      void
      forceUnit (const forceUnit_optional& x);

      void
      forceUnit (::std::unique_ptr< forceUnit_type > p);

      // Constructors.
      //
      CriterionForceType ();

      CriterionForceType (const Limit_type&);

      CriterionForceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CriterionForceType (const CriterionForceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual CriterionForceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionForceType&
      operator= (const CriterionForceType& x);

      virtual 
      ~CriterionForceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      forceUnit_optional forceUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionMassType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // massUnit
      //
      typedef ::xml_schema::token massUnit_type;
      typedef ::xsd::cxx::tree::optional< massUnit_type > massUnit_optional;
      typedef ::xsd::cxx::tree::traits< massUnit_type, wchar_t > massUnit_traits;

      const massUnit_optional&
      massUnit () const;

      massUnit_optional&
      massUnit ();

      void
      massUnit (const massUnit_type& x);

      void
      massUnit (const massUnit_optional& x);

      void
      massUnit (::std::unique_ptr< massUnit_type > p);

      // Constructors.
      //
      CriterionMassType ();

      CriterionMassType (const Limit_type&);

      CriterionMassType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CriterionMassType (const CriterionMassType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CriterionMassType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionMassType&
      operator= (const CriterionMassType& x);

      virtual 
      ~CriterionMassType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      massUnit_optional massUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionPressureType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // pressureUnit
      //
      typedef ::xml_schema::token pressureUnit_type;
      typedef ::xsd::cxx::tree::optional< pressureUnit_type > pressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< pressureUnit_type, wchar_t > pressureUnit_traits;

      const pressureUnit_optional&
      pressureUnit () const;

      pressureUnit_optional&
      pressureUnit ();

      void
      pressureUnit (const pressureUnit_type& x);

      void
      pressureUnit (const pressureUnit_optional& x);

      void
      pressureUnit (::std::unique_ptr< pressureUnit_type > p);

      // Constructors.
      //
      CriterionPressureType ();

      CriterionPressureType (const Limit_type&);

      CriterionPressureType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CriterionPressureType (const CriterionPressureType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CriterionPressureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionPressureType&
      operator= (const CriterionPressureType& x);

      virtual 
      ~CriterionPressureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      pressureUnit_optional pressureUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionSpeedType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // speedUnit
      //
      typedef ::xml_schema::token speedUnit_type;
      typedef ::xsd::cxx::tree::optional< speedUnit_type > speedUnit_optional;
      typedef ::xsd::cxx::tree::traits< speedUnit_type, wchar_t > speedUnit_traits;

      const speedUnit_optional&
      speedUnit () const;

      speedUnit_optional&
      speedUnit ();

      void
      speedUnit (const speedUnit_type& x);

      void
      speedUnit (const speedUnit_optional& x);

      void
      speedUnit (::std::unique_ptr< speedUnit_type > p);

      // Constructors.
      //
      CriterionSpeedType ();

      CriterionSpeedType (const Limit_type&);

      CriterionSpeedType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CriterionSpeedType (const CriterionSpeedType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual CriterionSpeedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionSpeedType&
      operator= (const CriterionSpeedType& x);

      virtual 
      ~CriterionSpeedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      speedUnit_optional speedUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionTemperatureType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // temperatureUnit
      //
      typedef ::xml_schema::token temperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< temperatureUnit_type > temperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< temperatureUnit_type, wchar_t > temperatureUnit_traits;

      const temperatureUnit_optional&
      temperatureUnit () const;

      temperatureUnit_optional&
      temperatureUnit ();

      void
      temperatureUnit (const temperatureUnit_type& x);

      void
      temperatureUnit (const temperatureUnit_optional& x);

      void
      temperatureUnit (::std::unique_ptr< temperatureUnit_type > p);

      // Constructors.
      //
      CriterionTemperatureType ();

      CriterionTemperatureType (const Limit_type&);

      CriterionTemperatureType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CriterionTemperatureType (const CriterionTemperatureType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CriterionTemperatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionTemperatureType&
      operator= (const CriterionTemperatureType& x);

      virtual 
      ~CriterionTemperatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      temperatureUnit_optional temperatureUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionTimeType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // timeUnit
      //
      typedef ::xml_schema::token timeUnit_type;
      typedef ::xsd::cxx::tree::optional< timeUnit_type > timeUnit_optional;
      typedef ::xsd::cxx::tree::traits< timeUnit_type, wchar_t > timeUnit_traits;

      const timeUnit_optional&
      timeUnit () const;

      timeUnit_optional&
      timeUnit ();

      void
      timeUnit (const timeUnit_type& x);

      void
      timeUnit (const timeUnit_optional& x);

      void
      timeUnit (::std::unique_ptr< timeUnit_type > p);

      // Constructors.
      //
      CriterionTimeType ();

      CriterionTimeType (const Limit_type&);

      CriterionTimeType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CriterionTimeType (const CriterionTimeType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CriterionTimeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionTimeType&
      operator= (const CriterionTimeType& x);

      virtual 
      ~CriterionTimeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      timeUnit_optional timeUnit_;
    };

    class QIF30_SYMBOL_DECL CriterionUserDefinedUnitType: public ::xsd::qif30::CriterionDecimalType
    {
      public:
      // unitName
      //
      typedef ::xml_schema::token unitName_type;
      typedef ::xsd::cxx::tree::traits< unitName_type, wchar_t > unitName_traits;

      const unitName_type&
      unitName () const;

      unitName_type&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (::std::unique_ptr< unitName_type > p);

      // Constructors.
      //
      CriterionUserDefinedUnitType ();

      CriterionUserDefinedUnitType (const Limit_type&,
                                    const unitName_type&);

      CriterionUserDefinedUnitType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      CriterionUserDefinedUnitType (const CriterionUserDefinedUnitType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual CriterionUserDefinedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionUserDefinedUnitType&
      operator= (const CriterionUserDefinedUnitType& x);

      virtual 
      ~CriterionUserDefinedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unitName_type > unitName_;
    };

    class QIF30_SYMBOL_DECL CriterionIntegerType: public ::xml_schema::type
    {
      public:
      // Limit
      //
      typedef ::xml_schema::positive_integer Limit_type;
      typedef ::xsd::cxx::tree::traits< Limit_type, wchar_t > Limit_traits;

      const Limit_type&
      Limit () const;

      Limit_type&
      Limit ();

      void
      Limit (const Limit_type& x);

      // NumberAllowedExceptions
      //
      typedef ::xsd::qif30::LimitingNumberType NumberAllowedExceptions_type;
      typedef ::xsd::cxx::tree::optional< NumberAllowedExceptions_type > NumberAllowedExceptions_optional;
      typedef ::xsd::cxx::tree::traits< NumberAllowedExceptions_type, wchar_t > NumberAllowedExceptions_traits;

      const NumberAllowedExceptions_optional&
      NumberAllowedExceptions () const;

      NumberAllowedExceptions_optional&
      NumberAllowedExceptions ();

      void
      NumberAllowedExceptions (const NumberAllowedExceptions_type& x);

      void
      NumberAllowedExceptions (const NumberAllowedExceptions_optional& x);

      void
      NumberAllowedExceptions (::std::unique_ptr< NumberAllowedExceptions_type > p);

      // ExtremeLimit
      //
      typedef ::xml_schema::positive_integer ExtremeLimit_type;
      typedef ::xsd::cxx::tree::optional< ExtremeLimit_type > ExtremeLimit_optional;
      typedef ::xsd::cxx::tree::traits< ExtremeLimit_type, wchar_t > ExtremeLimit_traits;

      const ExtremeLimit_optional&
      ExtremeLimit () const;

      ExtremeLimit_optional&
      ExtremeLimit ();

      void
      ExtremeLimit (const ExtremeLimit_type& x);

      void
      ExtremeLimit (const ExtremeLimit_optional& x);

      // Constructors.
      //
      CriterionIntegerType ();

      CriterionIntegerType (const Limit_type&);

      CriterionIntegerType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CriterionIntegerType (const CriterionIntegerType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CriterionIntegerType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionIntegerType&
      operator= (const CriterionIntegerType& x);

      virtual 
      ~CriterionIntegerType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Limit_type > Limit_;
      NumberAllowedExceptions_optional NumberAllowedExceptions_;
      ExtremeLimit_optional ExtremeLimit_;
    };

    class QIF30_SYMBOL_DECL CriterionOutOfType: public ::xml_schema::type
    {
      public:
      // Numerator
      //
      typedef ::xml_schema::positive_integer Numerator_type;
      typedef ::xsd::cxx::tree::traits< Numerator_type, wchar_t > Numerator_traits;

      const Numerator_type&
      Numerator () const;

      Numerator_type&
      Numerator ();

      void
      Numerator (const Numerator_type& x);

      // Denominator
      //
      typedef ::xml_schema::positive_integer Denominator_type;
      typedef ::xsd::cxx::tree::traits< Denominator_type, wchar_t > Denominator_traits;

      const Denominator_type&
      Denominator () const;

      Denominator_type&
      Denominator ();

      void
      Denominator (const Denominator_type& x);

      // NumberAllowedExceptions
      //
      typedef ::xsd::qif30::LimitingNumberType NumberAllowedExceptions_type;
      typedef ::xsd::cxx::tree::optional< NumberAllowedExceptions_type > NumberAllowedExceptions_optional;
      typedef ::xsd::cxx::tree::traits< NumberAllowedExceptions_type, wchar_t > NumberAllowedExceptions_traits;

      const NumberAllowedExceptions_optional&
      NumberAllowedExceptions () const;

      NumberAllowedExceptions_optional&
      NumberAllowedExceptions ();

      void
      NumberAllowedExceptions (const NumberAllowedExceptions_type& x);

      void
      NumberAllowedExceptions (const NumberAllowedExceptions_optional& x);

      void
      NumberAllowedExceptions (::std::unique_ptr< NumberAllowedExceptions_type > p);

      // Constructors.
      //
      CriterionOutOfType ();

      CriterionOutOfType (const Numerator_type&,
                          const Denominator_type&);

      CriterionOutOfType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      CriterionOutOfType (const CriterionOutOfType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual CriterionOutOfType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CriterionOutOfType&
      operator= (const CriterionOutOfType& x);

      virtual 
      ~CriterionOutOfType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Numerator_type > Numerator_;
      ::xsd::cxx::tree::one< Denominator_type > Denominator_;
      NumberAllowedExceptions_optional NumberAllowedExceptions_;
    };

    class QIF30_SYMBOL_DECL SamplingMethodType: public ::xml_schema::type
    {
      public:
      // SampleSize
      //
      typedef ::xml_schema::positive_integer SampleSize_type;
      typedef ::xsd::cxx::tree::traits< SampleSize_type, wchar_t > SampleSize_traits;

      const SampleSize_type&
      SampleSize () const;

      SampleSize_type&
      SampleSize ();

      void
      SampleSize (const SampleSize_type& x);

      // SamplingPeriod
      //
      typedef ::xml_schema::positive_integer SamplingPeriod_type;
      typedef ::xsd::cxx::tree::optional< SamplingPeriod_type > SamplingPeriod_optional;
      typedef ::xsd::cxx::tree::traits< SamplingPeriod_type, wchar_t > SamplingPeriod_traits;

      const SamplingPeriod_optional&
      SamplingPeriod () const;

      SamplingPeriod_optional&
      SamplingPeriod ();

      void
      SamplingPeriod (const SamplingPeriod_type& x);

      void
      SamplingPeriod (const SamplingPeriod_optional& x);

      // SamplingFrequency
      //
      typedef ::xml_schema::positive_integer SamplingFrequency_type;
      typedef ::xsd::cxx::tree::optional< SamplingFrequency_type > SamplingFrequency_optional;
      typedef ::xsd::cxx::tree::traits< SamplingFrequency_type, wchar_t > SamplingFrequency_traits;

      const SamplingFrequency_optional&
      SamplingFrequency () const;

      SamplingFrequency_optional&
      SamplingFrequency ();

      void
      SamplingFrequency (const SamplingFrequency_type& x);

      void
      SamplingFrequency (const SamplingFrequency_optional& x);

      // SamplingInterval
      //
      typedef ::xsd::qif30::SamplingIntervalType SamplingInterval_type;
      typedef ::xsd::cxx::tree::optional< SamplingInterval_type > SamplingInterval_optional;
      typedef ::xsd::cxx::tree::traits< SamplingInterval_type, wchar_t > SamplingInterval_traits;

      const SamplingInterval_optional&
      SamplingInterval () const;

      SamplingInterval_optional&
      SamplingInterval ();

      void
      SamplingInterval (const SamplingInterval_type& x);

      void
      SamplingInterval (const SamplingInterval_optional& x);

      void
      SamplingInterval (::std::unique_ptr< SamplingInterval_type > p);

      // Constructors.
      //
      SamplingMethodType ();

      SamplingMethodType (const SampleSize_type&);

      SamplingMethodType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SamplingMethodType (const SamplingMethodType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SamplingMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SamplingMethodType&
      operator= (const SamplingMethodType& x);

      virtual 
      ~SamplingMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SampleSize_type > SampleSize_;
      SamplingPeriod_optional SamplingPeriod_;
      SamplingFrequency_optional SamplingFrequency_;
      SamplingInterval_optional SamplingInterval_;
    };

    class QIF30_SYMBOL_DECL SamplingIntervalEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        SHIFT,
        DAY,
        HOUR,
        WEEK,
        MONTH,
        BATCH,
        LOT
      };

      SamplingIntervalEnumType ();

      SamplingIntervalEnumType (value v);

      SamplingIntervalEnumType (const wchar_t* v);

      SamplingIntervalEnumType (const ::std::wstring& v);

      SamplingIntervalEnumType (const ::xml_schema::nmtoken& v);

      SamplingIntervalEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SamplingIntervalEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SamplingIntervalEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SamplingIntervalEnumType (const SamplingIntervalEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SamplingIntervalEnumType&
      operator= (const SamplingIntervalEnumType&) = default;
#endif

      virtual SamplingIntervalEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SamplingIntervalEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SamplingIntervalEnumType_convert ();
      }

      protected:
      value
      _xsd_SamplingIntervalEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_SamplingIntervalEnumType_literals_[7];
      static const value _xsd_SamplingIntervalEnumType_indexes_[7];
    };

    class QIF30_SYMBOL_DECL SamplingIntervalType: public ::xml_schema::type
    {
      public:
      // SamplingIntervalEnum
      //
      typedef ::xsd::qif30::SamplingIntervalEnumType SamplingIntervalEnum_type;
      typedef ::xsd::cxx::tree::optional< SamplingIntervalEnum_type > SamplingIntervalEnum_optional;
      typedef ::xsd::cxx::tree::traits< SamplingIntervalEnum_type, wchar_t > SamplingIntervalEnum_traits;

      const SamplingIntervalEnum_optional&
      SamplingIntervalEnum () const;

      SamplingIntervalEnum_optional&
      SamplingIntervalEnum ();

      void
      SamplingIntervalEnum (const SamplingIntervalEnum_type& x);

      void
      SamplingIntervalEnum (const SamplingIntervalEnum_optional& x);

      void
      SamplingIntervalEnum (::std::unique_ptr< SamplingIntervalEnum_type > p);

      // OtherSamplingInterval
      //
      typedef ::xml_schema::string OtherSamplingInterval_type;
      typedef ::xsd::cxx::tree::optional< OtherSamplingInterval_type > OtherSamplingInterval_optional;
      typedef ::xsd::cxx::tree::traits< OtherSamplingInterval_type, wchar_t > OtherSamplingInterval_traits;

      const OtherSamplingInterval_optional&
      OtherSamplingInterval () const;

      OtherSamplingInterval_optional&
      OtherSamplingInterval ();

      void
      OtherSamplingInterval (const OtherSamplingInterval_type& x);

      void
      OtherSamplingInterval (const OtherSamplingInterval_optional& x);

      void
      OtherSamplingInterval (::std::unique_ptr< OtherSamplingInterval_type > p);

      // Constructors.
      //
      SamplingIntervalType ();

      SamplingIntervalType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      SamplingIntervalType (const SamplingIntervalType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual SamplingIntervalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SamplingIntervalType&
      operator= (const SamplingIntervalType& x);

      virtual 
      ~SamplingIntervalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SamplingIntervalEnum_optional SamplingIntervalEnum_;
      OtherSamplingInterval_optional OtherSamplingInterval_;
    };

    class QIF30_SYMBOL_DECL ExclusionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        FLIER,
        EQUIPERROR,
        REWORK,
        KNOWNCAUSE
      };

      ExclusionEnumType ();

      ExclusionEnumType (value v);

      ExclusionEnumType (const wchar_t* v);

      ExclusionEnumType (const ::std::wstring& v);

      ExclusionEnumType (const ::xml_schema::nmtoken& v);

      ExclusionEnumType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ExclusionEnumType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ExclusionEnumType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ExclusionEnumType (const ExclusionEnumType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ExclusionEnumType&
      operator= (const ExclusionEnumType&) = default;
#endif

      virtual ExclusionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExclusionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ExclusionEnumType_convert ();
      }

      protected:
      value
      _xsd_ExclusionEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ExclusionEnumType_literals_[4];
      static const value _xsd_ExclusionEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL ExclusionReasonType: public ::xml_schema::type
    {
      public:
      // ExclusionReasonEnum
      //
      typedef ::xsd::qif30::ExclusionEnumType ExclusionReasonEnum_type;
      typedef ::xsd::cxx::tree::optional< ExclusionReasonEnum_type > ExclusionReasonEnum_optional;
      typedef ::xsd::cxx::tree::traits< ExclusionReasonEnum_type, wchar_t > ExclusionReasonEnum_traits;

      const ExclusionReasonEnum_optional&
      ExclusionReasonEnum () const;

      ExclusionReasonEnum_optional&
      ExclusionReasonEnum ();

      void
      ExclusionReasonEnum (const ExclusionReasonEnum_type& x);

      void
      ExclusionReasonEnum (const ExclusionReasonEnum_optional& x);

      void
      ExclusionReasonEnum (::std::unique_ptr< ExclusionReasonEnum_type > p);

      // OtherExclusionReason
      //
      typedef ::xml_schema::string OtherExclusionReason_type;
      typedef ::xsd::cxx::tree::optional< OtherExclusionReason_type > OtherExclusionReason_optional;
      typedef ::xsd::cxx::tree::traits< OtherExclusionReason_type, wchar_t > OtherExclusionReason_traits;

      const OtherExclusionReason_optional&
      OtherExclusionReason () const;

      OtherExclusionReason_optional&
      OtherExclusionReason ();

      void
      OtherExclusionReason (const OtherExclusionReason_type& x);

      void
      OtherExclusionReason (const OtherExclusionReason_optional& x);

      void
      OtherExclusionReason (::std::unique_ptr< OtherExclusionReason_type > p);

      // Constructors.
      //
      ExclusionReasonType ();

      ExclusionReasonType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ExclusionReasonType (const ExclusionReasonType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ExclusionReasonType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExclusionReasonType&
      operator= (const ExclusionReasonType& x);

      virtual 
      ~ExclusionReasonType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ExclusionReasonEnum_optional ExclusionReasonEnum_;
      OtherExclusionReason_optional OtherExclusionReason_;
    };

    class QIF30_SYMBOL_DECL ExclusionIdType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif30::QIFReferenceType Id_type;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_type&
      Id () const;

      Id_type&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Reason
      //
      typedef ::xsd::qif30::ExclusionReasonType Reason_type;
      typedef ::xsd::cxx::tree::traits< Reason_type, wchar_t > Reason_traits;

      const Reason_type&
      Reason () const;

      Reason_type&
      Reason ();

      void
      Reason (const Reason_type& x);

      void
      Reason (::std::unique_ptr< Reason_type > p);

      // Constructors.
      //
      ExclusionIdType ();

      ExclusionIdType (const Id_type&,
                       const Reason_type&);

      ExclusionIdType (::std::unique_ptr< Id_type >,
                       ::std::unique_ptr< Reason_type >);

      ExclusionIdType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ExclusionIdType (const ExclusionIdType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ExclusionIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExclusionIdType&
      operator= (const ExclusionIdType& x);

      virtual 
      ~ExclusionIdType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Id_type > Id_;
      ::xsd::cxx::tree::one< Reason_type > Reason_;
    };

    class QIF30_SYMBOL_DECL ExclusionIndexType: public ::xml_schema::type
    {
      public:
      // Index
      //
      typedef ::xml_schema::positive_integer Index_type;
      typedef ::xsd::cxx::tree::traits< Index_type, wchar_t > Index_traits;

      const Index_type&
      Index () const;

      Index_type&
      Index ();

      void
      Index (const Index_type& x);

      // Reason
      //
      typedef ::xsd::qif30::ExclusionReasonType Reason_type;
      typedef ::xsd::cxx::tree::traits< Reason_type, wchar_t > Reason_traits;

      const Reason_type&
      Reason () const;

      Reason_type&
      Reason ();

      void
      Reason (const Reason_type& x);

      void
      Reason (::std::unique_ptr< Reason_type > p);

      // Constructors.
      //
      ExclusionIndexType ();

      ExclusionIndexType (const Index_type&,
                          const Reason_type&);

      ExclusionIndexType (const Index_type&,
                          ::std::unique_ptr< Reason_type >);

      ExclusionIndexType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ExclusionIndexType (const ExclusionIndexType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ExclusionIndexType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExclusionIndexType&
      operator= (const ExclusionIndexType& x);

      virtual 
      ~ExclusionIndexType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Index_type > Index_;
      ::xsd::cxx::tree::one< Reason_type > Reason_;
    };

    class QIF30_SYMBOL_DECL ExclusionsIdType: public ::xml_schema::type
    {
      public:
      // Exclusion
      //
      typedef ::xsd::qif30::ExclusionIdType Exclusion_type;
      typedef ::xsd::cxx::tree::sequence< Exclusion_type > Exclusion_sequence;
      typedef xsd::cxx::tree::sequence< Exclusion_type >::iterator Exclusion_iterator;
      typedef xsd::cxx::tree::sequence< Exclusion_type >::const_iterator Exclusion_const_iterator;
      typedef ::xsd::cxx::tree::traits< Exclusion_type, wchar_t > Exclusion_traits;

      const Exclusion_sequence&
      Exclusion () const;

      Exclusion_sequence&
      Exclusion ();

      void
      Exclusion (const Exclusion_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ExclusionsIdType ();

      ExclusionsIdType (const n_type&);

      ExclusionsIdType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ExclusionsIdType (const ExclusionsIdType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ExclusionsIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExclusionsIdType&
      operator= (const ExclusionsIdType& x);

      virtual 
      ~ExclusionsIdType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Exclusion_sequence Exclusion_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ExclusionsIndexType: public ::xml_schema::type
    {
      public:
      // Exclusion
      //
      typedef ::xsd::qif30::ExclusionIndexType Exclusion_type;
      typedef ::xsd::cxx::tree::sequence< Exclusion_type > Exclusion_sequence;
      typedef xsd::cxx::tree::sequence< Exclusion_type >::iterator Exclusion_iterator;
      typedef xsd::cxx::tree::sequence< Exclusion_type >::const_iterator Exclusion_const_iterator;
      typedef ::xsd::cxx::tree::traits< Exclusion_type, wchar_t > Exclusion_traits;

      const Exclusion_sequence&
      Exclusion () const;

      Exclusion_sequence&
      Exclusion ();

      void
      Exclusion (const Exclusion_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ExclusionsIndexType ();

      ExclusionsIndexType (const n_type&);

      ExclusionsIndexType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ExclusionsIndexType (const ExclusionsIndexType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ExclusionsIndexType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExclusionsIndexType&
      operator= (const ExclusionsIndexType& x);

      virtual 
      ~ExclusionsIndexType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Exclusion_sequence Exclusion_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL StatsArrayIdType: public ::xml_schema::type
    {
      public:
      // Ids
      //
      typedef ::xsd::qif30::ArrayReferenceType Ids_type;
      typedef ::xsd::cxx::tree::traits< Ids_type, wchar_t > Ids_traits;

      const Ids_type&
      Ids () const;

      Ids_type&
      Ids ();

      void
      Ids (const Ids_type& x);

      void
      Ids (::std::unique_ptr< Ids_type > p);

      // Exclusions
      //
      typedef ::xsd::qif30::ExclusionsIdType Exclusions_type;
      typedef ::xsd::cxx::tree::optional< Exclusions_type > Exclusions_optional;
      typedef ::xsd::cxx::tree::traits< Exclusions_type, wchar_t > Exclusions_traits;

      const Exclusions_optional&
      Exclusions () const;

      Exclusions_optional&
      Exclusions ();

      void
      Exclusions (const Exclusions_type& x);

      void
      Exclusions (const Exclusions_optional& x);

      void
      Exclusions (::std::unique_ptr< Exclusions_type > p);

      // Constructors.
      //
      StatsArrayIdType ();

      StatsArrayIdType (const Ids_type&);

      StatsArrayIdType (::std::unique_ptr< Ids_type >);

      StatsArrayIdType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      StatsArrayIdType (const StatsArrayIdType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual StatsArrayIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsArrayIdType&
      operator= (const StatsArrayIdType& x);

      virtual 
      ~StatsArrayIdType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Ids_type > Ids_;
      Exclusions_optional Exclusions_;
    };

    class QIF30_SYMBOL_DECL StatsValuesType: public ::xml_schema::type
    {
      public:
      // Values
      //
      typedef ::xsd::qif30::ListTokenType Values_type;
      typedef ::xsd::cxx::tree::traits< Values_type, wchar_t > Values_traits;

      const Values_type&
      Values () const;

      Values_type&
      Values ();

      void
      Values (const Values_type& x);

      void
      Values (::std::unique_ptr< Values_type > p);

      // Exclusions
      //
      typedef ::xsd::qif30::ExclusionsIndexType Exclusions_type;
      typedef ::xsd::cxx::tree::optional< Exclusions_type > Exclusions_optional;
      typedef ::xsd::cxx::tree::traits< Exclusions_type, wchar_t > Exclusions_traits;

      const Exclusions_optional&
      Exclusions () const;

      Exclusions_optional&
      Exclusions ();

      void
      Exclusions (const Exclusions_type& x);

      void
      Exclusions (const Exclusions_optional& x);

      void
      Exclusions (::std::unique_ptr< Exclusions_type > p);

      // Constructors.
      //
      StatsValuesType ();

      StatsValuesType (const Values_type&);

      StatsValuesType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      StatsValuesType (const StatsValuesType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual StatsValuesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsValuesType&
      operator= (const StatsValuesType& x);

      virtual 
      ~StatsValuesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Values_type > Values_;
      Exclusions_optional Exclusions_;
    };

    class QIF30_SYMBOL_DECL StatsEvalStatusEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PASS,
        FAIL,
        INFORMATIONAL,
        UNDEFINED
      };

      StatsEvalStatusEnumType ();

      StatsEvalStatusEnumType (value v);

      StatsEvalStatusEnumType (const wchar_t* v);

      StatsEvalStatusEnumType (const ::std::wstring& v);

      StatsEvalStatusEnumType (const ::xml_schema::nmtoken& v);

      StatsEvalStatusEnumType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      StatsEvalStatusEnumType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      StatsEvalStatusEnumType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      StatsEvalStatusEnumType (const StatsEvalStatusEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      StatsEvalStatusEnumType&
      operator= (const StatsEvalStatusEnumType&) = default;
#endif

      virtual StatsEvalStatusEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsEvalStatusEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_StatsEvalStatusEnumType_convert ();
      }

      protected:
      value
      _xsd_StatsEvalStatusEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_StatsEvalStatusEnumType_literals_[4];
      static const value _xsd_StatsEvalStatusEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL StatsEvalStatusType: public ::xml_schema::type
    {
      public:
      // StatsEvalStatusEnum
      //
      typedef ::xsd::qif30::StatsEvalStatusEnumType StatsEvalStatusEnum_type;
      typedef ::xsd::cxx::tree::optional< StatsEvalStatusEnum_type > StatsEvalStatusEnum_optional;
      typedef ::xsd::cxx::tree::traits< StatsEvalStatusEnum_type, wchar_t > StatsEvalStatusEnum_traits;

      const StatsEvalStatusEnum_optional&
      StatsEvalStatusEnum () const;

      StatsEvalStatusEnum_optional&
      StatsEvalStatusEnum ();

      void
      StatsEvalStatusEnum (const StatsEvalStatusEnum_type& x);

      void
      StatsEvalStatusEnum (const StatsEvalStatusEnum_optional& x);

      void
      StatsEvalStatusEnum (::std::unique_ptr< StatsEvalStatusEnum_type > p);

      // OtherStatsEvalStatus
      //
      typedef ::xml_schema::string OtherStatsEvalStatus_type;
      typedef ::xsd::cxx::tree::optional< OtherStatsEvalStatus_type > OtherStatsEvalStatus_optional;
      typedef ::xsd::cxx::tree::traits< OtherStatsEvalStatus_type, wchar_t > OtherStatsEvalStatus_traits;

      const OtherStatsEvalStatus_optional&
      OtherStatsEvalStatus () const;

      OtherStatsEvalStatus_optional&
      OtherStatsEvalStatus ();

      void
      OtherStatsEvalStatus (const OtherStatsEvalStatus_type& x);

      void
      OtherStatsEvalStatus (const OtherStatsEvalStatus_optional& x);

      void
      OtherStatsEvalStatus (::std::unique_ptr< OtherStatsEvalStatus_type > p);

      // Constructors.
      //
      StatsEvalStatusType ();

      StatsEvalStatusType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      StatsEvalStatusType (const StatsEvalStatusType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual StatsEvalStatusType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsEvalStatusType&
      operator= (const StatsEvalStatusType& x);

      virtual 
      ~StatsEvalStatusType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StatsEvalStatusEnum_optional StatsEvalStatusEnum_;
      OtherStatsEvalStatus_optional OtherStatsEvalStatus_;
    };

    class QIF30_SYMBOL_DECL StudyIssuesType: public ::xml_schema::type
    {
      public:
      // StudyIssue
      //
      typedef ::xsd::qif30::StudyIssueType StudyIssue_type;
      typedef ::xsd::cxx::tree::sequence< StudyIssue_type > StudyIssue_sequence;
      typedef xsd::cxx::tree::sequence< StudyIssue_type >::iterator StudyIssue_iterator;
      typedef xsd::cxx::tree::sequence< StudyIssue_type >::const_iterator StudyIssue_const_iterator;
      typedef ::xsd::cxx::tree::traits< StudyIssue_type, wchar_t > StudyIssue_traits;

      const StudyIssue_sequence&
      StudyIssue () const;

      StudyIssue_sequence&
      StudyIssue ();

      void
      StudyIssue (const StudyIssue_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      StudyIssuesType ();

      StudyIssuesType (const n_type&);

      StudyIssuesType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      StudyIssuesType (const StudyIssuesType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual StudyIssuesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StudyIssuesType&
      operator= (const StudyIssuesType& x);

      virtual 
      ~StudyIssuesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StudyIssue_sequence StudyIssue_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL OneSidedCapabilityCalculationEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        THREE_SIGMA,
        SIX_SIGMA
      };

      OneSidedCapabilityCalculationEnumType ();

      OneSidedCapabilityCalculationEnumType (value v);

      OneSidedCapabilityCalculationEnumType (const wchar_t* v);

      OneSidedCapabilityCalculationEnumType (const ::std::wstring& v);

      OneSidedCapabilityCalculationEnumType (const ::xml_schema::nmtoken& v);

      OneSidedCapabilityCalculationEnumType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OneSidedCapabilityCalculationEnumType (const xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OneSidedCapabilityCalculationEnumType (const ::std::wstring& s,
                                             const xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      OneSidedCapabilityCalculationEnumType (const OneSidedCapabilityCalculationEnumType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      OneSidedCapabilityCalculationEnumType&
      operator= (const OneSidedCapabilityCalculationEnumType&) = default;
#endif

      virtual OneSidedCapabilityCalculationEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OneSidedCapabilityCalculationEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_OneSidedCapabilityCalculationEnumType_convert ();
      }

      protected:
      value
      _xsd_OneSidedCapabilityCalculationEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_OneSidedCapabilityCalculationEnumType_literals_[2];
      static const value _xsd_OneSidedCapabilityCalculationEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL PositionCapabilityCalculationEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        THREE_SIGMA,
        SIX_SIGMA,
        BIVARIATE,
        TRIVARIATE
      };

      PositionCapabilityCalculationEnumType ();

      PositionCapabilityCalculationEnumType (value v);

      PositionCapabilityCalculationEnumType (const wchar_t* v);

      PositionCapabilityCalculationEnumType (const ::std::wstring& v);

      PositionCapabilityCalculationEnumType (const ::xml_schema::nmtoken& v);

      PositionCapabilityCalculationEnumType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      PositionCapabilityCalculationEnumType (const xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      PositionCapabilityCalculationEnumType (const ::std::wstring& s,
                                             const xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      PositionCapabilityCalculationEnumType (const PositionCapabilityCalculationEnumType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      PositionCapabilityCalculationEnumType&
      operator= (const PositionCapabilityCalculationEnumType&) = default;
#endif

      virtual PositionCapabilityCalculationEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionCapabilityCalculationEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PositionCapabilityCalculationEnumType_convert ();
      }

      protected:
      value
      _xsd_PositionCapabilityCalculationEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_PositionCapabilityCalculationEnumType_literals_[4];
      static const value _xsd_PositionCapabilityCalculationEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL DistributionTransformationEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        LOGNORMAL,
        BOUNDED,
        UNBOUNDED
      };

      DistributionTransformationEnumType ();

      DistributionTransformationEnumType (value v);

      DistributionTransformationEnumType (const wchar_t* v);

      DistributionTransformationEnumType (const ::std::wstring& v);

      DistributionTransformationEnumType (const ::xml_schema::nmtoken& v);

      DistributionTransformationEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      DistributionTransformationEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      DistributionTransformationEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      DistributionTransformationEnumType (const DistributionTransformationEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DistributionTransformationEnumType&
      operator= (const DistributionTransformationEnumType&) = default;
#endif

      virtual DistributionTransformationEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DistributionTransformationEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DistributionTransformationEnumType_convert ();
      }

      protected:
      value
      _xsd_DistributionTransformationEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DistributionTransformationEnumType_literals_[3];
      static const value _xsd_DistributionTransformationEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL DistributionTransformationType: public ::xml_schema::type
    {
      public:
      // DistributionTransformationEnum
      //
      typedef ::xsd::qif30::DistributionTransformationEnumType DistributionTransformationEnum_type;
      typedef ::xsd::cxx::tree::optional< DistributionTransformationEnum_type > DistributionTransformationEnum_optional;
      typedef ::xsd::cxx::tree::traits< DistributionTransformationEnum_type, wchar_t > DistributionTransformationEnum_traits;

      const DistributionTransformationEnum_optional&
      DistributionTransformationEnum () const;

      DistributionTransformationEnum_optional&
      DistributionTransformationEnum ();

      void
      DistributionTransformationEnum (const DistributionTransformationEnum_type& x);

      void
      DistributionTransformationEnum (const DistributionTransformationEnum_optional& x);

      void
      DistributionTransformationEnum (::std::unique_ptr< DistributionTransformationEnum_type > p);

      // BoxCoxTransformation
      //
      typedef ::xml_schema::decimal BoxCoxTransformation_type;
      typedef ::xsd::cxx::tree::optional< BoxCoxTransformation_type > BoxCoxTransformation_optional;
      typedef ::xsd::cxx::tree::traits< BoxCoxTransformation_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > BoxCoxTransformation_traits;

      const BoxCoxTransformation_optional&
      BoxCoxTransformation () const;

      BoxCoxTransformation_optional&
      BoxCoxTransformation ();

      void
      BoxCoxTransformation (const BoxCoxTransformation_type& x);

      void
      BoxCoxTransformation (const BoxCoxTransformation_optional& x);

      // OtherDistributionTransformation
      //
      typedef ::xml_schema::string OtherDistributionTransformation_type;
      typedef ::xsd::cxx::tree::optional< OtherDistributionTransformation_type > OtherDistributionTransformation_optional;
      typedef ::xsd::cxx::tree::traits< OtherDistributionTransformation_type, wchar_t > OtherDistributionTransformation_traits;

      const OtherDistributionTransformation_optional&
      OtherDistributionTransformation () const;

      OtherDistributionTransformation_optional&
      OtherDistributionTransformation ();

      void
      OtherDistributionTransformation (const OtherDistributionTransformation_type& x);

      void
      OtherDistributionTransformation (const OtherDistributionTransformation_optional& x);

      void
      OtherDistributionTransformation (::std::unique_ptr< OtherDistributionTransformation_type > p);

      // Constructors.
      //
      DistributionTransformationType ();

      DistributionTransformationType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      DistributionTransformationType (const DistributionTransformationType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual DistributionTransformationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DistributionTransformationType&
      operator= (const DistributionTransformationType& x);

      virtual 
      ~DistributionTransformationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DistributionTransformationEnum_optional DistributionTransformationEnum_;
      BoxCoxTransformation_optional BoxCoxTransformation_;
      OtherDistributionTransformation_optional OtherDistributionTransformation_;
    };

    class QIF30_SYMBOL_DECL SubgroupType: public ::xml_schema::type
    {
      public:
      // MeasuredIds
      //
      typedef ::xsd::qif30::StatsArrayIdType MeasuredIds_type;
      typedef ::xsd::cxx::tree::traits< MeasuredIds_type, wchar_t > MeasuredIds_traits;

      const MeasuredIds_type&
      MeasuredIds () const;

      MeasuredIds_type&
      MeasuredIds ();

      void
      MeasuredIds (const MeasuredIds_type& x);

      void
      MeasuredIds (::std::unique_ptr< MeasuredIds_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      SubgroupType ();

      SubgroupType (const MeasuredIds_type&,
                    const id_type&);

      SubgroupType (::std::unique_ptr< MeasuredIds_type >,
                    const id_type&);

      SubgroupType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      SubgroupType (const SubgroupType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual SubgroupType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SubgroupType&
      operator= (const SubgroupType& x);

      virtual 
      ~SubgroupType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MeasuredIds_type > MeasuredIds_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL SubgroupsType: public ::xml_schema::type
    {
      public:
      // Subgroup
      //
      typedef ::xsd::qif30::SubgroupType Subgroup_type;
      typedef ::xsd::cxx::tree::sequence< Subgroup_type > Subgroup_sequence;
      typedef xsd::cxx::tree::sequence< Subgroup_type >::iterator Subgroup_iterator;
      typedef xsd::cxx::tree::sequence< Subgroup_type >::const_iterator Subgroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< Subgroup_type, wchar_t > Subgroup_traits;

      const Subgroup_sequence&
      Subgroup () const;

      Subgroup_sequence&
      Subgroup ();

      void
      Subgroup (const Subgroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SubgroupsType ();

      SubgroupsType (const n_type&);

      SubgroupsType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      SubgroupsType (const SubgroupsType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual SubgroupsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SubgroupsType&
      operator= (const SubgroupsType& x);

      virtual 
      ~SubgroupsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Subgroup_sequence Subgroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SubgroupValuesType: public ::xml_schema::type
    {
      public:
      // Subgroup
      //
      typedef ::xsd::qif30::StatsValuesType Subgroup_type;
      typedef ::xsd::cxx::tree::sequence< Subgroup_type > Subgroup_sequence;
      typedef xsd::cxx::tree::sequence< Subgroup_type >::iterator Subgroup_iterator;
      typedef xsd::cxx::tree::sequence< Subgroup_type >::const_iterator Subgroup_const_iterator;
      typedef ::xsd::cxx::tree::traits< Subgroup_type, wchar_t > Subgroup_traits;

      const Subgroup_sequence&
      Subgroup () const;

      Subgroup_sequence&
      Subgroup ();

      void
      Subgroup (const Subgroup_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SubgroupValuesType ();

      SubgroupValuesType (const n_type&);

      SubgroupValuesType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SubgroupValuesType (const SubgroupValuesType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SubgroupValuesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SubgroupValuesType&
      operator= (const SubgroupValuesType& x);

      virtual 
      ~SubgroupValuesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Subgroup_sequence Subgroup_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CharacteristicStatsEvalBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // SoftwareId
      //
      typedef ::xsd::qif30::QIFReferenceType SoftwareId_type;
      typedef ::xsd::cxx::tree::optional< SoftwareId_type > SoftwareId_optional;
      typedef ::xsd::cxx::tree::traits< SoftwareId_type, wchar_t > SoftwareId_traits;

      const SoftwareId_optional&
      SoftwareId () const;

      SoftwareId_optional&
      SoftwareId ();

      void
      SoftwareId (const SoftwareId_type& x);

      void
      SoftwareId (const SoftwareId_optional& x);

      void
      SoftwareId (::std::unique_ptr< SoftwareId_type > p);

      // StandardId
      //
      typedef ::xsd::qif30::QIFReferenceType StandardId_type;
      typedef ::xsd::cxx::tree::optional< StandardId_type > StandardId_optional;
      typedef ::xsd::cxx::tree::traits< StandardId_type, wchar_t > StandardId_traits;

      const StandardId_optional&
      StandardId () const;

      StandardId_optional&
      StandardId ();

      void
      StandardId (const StandardId_type& x);

      void
      StandardId (const StandardId_optional& x);

      void
      StandardId (::std::unique_ptr< StandardId_type > p);

      // AlgorithmId
      //
      typedef ::xsd::qif30::QIFReferenceType AlgorithmId_type;
      typedef ::xsd::cxx::tree::optional< AlgorithmId_type > AlgorithmId_optional;
      typedef ::xsd::cxx::tree::traits< AlgorithmId_type, wchar_t > AlgorithmId_traits;

      const AlgorithmId_optional&
      AlgorithmId () const;

      AlgorithmId_optional&
      AlgorithmId ();

      void
      AlgorithmId (const AlgorithmId_type& x);

      void
      AlgorithmId (const AlgorithmId_optional& x);

      void
      AlgorithmId (::std::unique_ptr< AlgorithmId_type > p);

      // MeasuredIds
      //
      typedef ::xsd::qif30::StatsArrayIdType MeasuredIds_type;
      typedef ::xsd::cxx::tree::optional< MeasuredIds_type > MeasuredIds_optional;
      typedef ::xsd::cxx::tree::traits< MeasuredIds_type, wchar_t > MeasuredIds_traits;

      const MeasuredIds_optional&
      MeasuredIds () const;

      MeasuredIds_optional&
      MeasuredIds ();

      void
      MeasuredIds (const MeasuredIds_type& x);

      void
      MeasuredIds (const MeasuredIds_optional& x);

      void
      MeasuredIds (::std::unique_ptr< MeasuredIds_type > p);

      // Subgroups
      //
      typedef ::xsd::qif30::SubgroupsType Subgroups_type;
      typedef ::xsd::cxx::tree::optional< Subgroups_type > Subgroups_optional;
      typedef ::xsd::cxx::tree::traits< Subgroups_type, wchar_t > Subgroups_traits;

      const Subgroups_optional&
      Subgroups () const;

      Subgroups_optional&
      Subgroups ();

      void
      Subgroups (const Subgroups_type& x);

      void
      Subgroups (const Subgroups_optional& x);

      void
      Subgroups (::std::unique_ptr< Subgroups_type > p);

      // MeasuredValues
      //
      typedef ::xsd::qif30::StatsValuesType MeasuredValues_type;
      typedef ::xsd::cxx::tree::optional< MeasuredValues_type > MeasuredValues_optional;
      typedef ::xsd::cxx::tree::traits< MeasuredValues_type, wchar_t > MeasuredValues_traits;

      const MeasuredValues_optional&
      MeasuredValues () const;

      MeasuredValues_optional&
      MeasuredValues ();

      void
      MeasuredValues (const MeasuredValues_type& x);

      void
      MeasuredValues (const MeasuredValues_optional& x);

      void
      MeasuredValues (::std::unique_ptr< MeasuredValues_type > p);

      // SubgroupValues
      //
      typedef ::xsd::qif30::SubgroupValuesType SubgroupValues_type;
      typedef ::xsd::cxx::tree::optional< SubgroupValues_type > SubgroupValues_optional;
      typedef ::xsd::cxx::tree::traits< SubgroupValues_type, wchar_t > SubgroupValues_traits;

      const SubgroupValues_optional&
      SubgroupValues () const;

      SubgroupValues_optional&
      SubgroupValues ();

      void
      SubgroupValues (const SubgroupValues_type& x);

      void
      SubgroupValues (const SubgroupValues_optional& x);

      void
      SubgroupValues (::std::unique_ptr< SubgroupValues_type > p);

      // Status
      //
      typedef ::xsd::qif30::StatsEvalStatusType Status_type;
      typedef ::xsd::cxx::tree::traits< Status_type, wchar_t > Status_traits;

      const Status_type&
      Status () const;

      Status_type&
      Status ();

      void
      Status (const Status_type& x);

      void
      Status (::std::unique_ptr< Status_type > p);

      // StudyIssues
      //
      typedef ::xsd::qif30::StudyIssuesType StudyIssues_type;
      typedef ::xsd::cxx::tree::optional< StudyIssues_type > StudyIssues_optional;
      typedef ::xsd::cxx::tree::traits< StudyIssues_type, wchar_t > StudyIssues_traits;

      const StudyIssues_optional&
      StudyIssues () const;

      StudyIssues_optional&
      StudyIssues ();

      void
      StudyIssues (const StudyIssues_type& x);

      void
      StudyIssues (const StudyIssues_optional& x);

      void
      StudyIssues (::std::unique_ptr< StudyIssues_type > p);

      // DistributionTransformation
      //
      typedef ::xsd::qif30::DistributionTransformationType DistributionTransformation_type;
      typedef ::xsd::cxx::tree::optional< DistributionTransformation_type > DistributionTransformation_optional;
      typedef ::xsd::cxx::tree::traits< DistributionTransformation_type, wchar_t > DistributionTransformation_traits;

      const DistributionTransformation_optional&
      DistributionTransformation () const;

      DistributionTransformation_optional&
      DistributionTransformation ();

      void
      DistributionTransformation (const DistributionTransformation_type& x);

      void
      DistributionTransformation (const DistributionTransformation_optional& x);

      void
      DistributionTransformation (::std::unique_ptr< DistributionTransformation_type > p);

      // Constructors.
      //
      CharacteristicStatsEvalBaseType ();

      CharacteristicStatsEvalBaseType (const Status_type&);

      CharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type >);

      CharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CharacteristicStatsEvalBaseType (const CharacteristicStatsEvalBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CharacteristicStatsEvalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CharacteristicStatsEvalBaseType&
      operator= (const CharacteristicStatsEvalBaseType& x);

      virtual 
      ~CharacteristicStatsEvalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      SoftwareId_optional SoftwareId_;
      StandardId_optional StandardId_;
      AlgorithmId_optional AlgorithmId_;
      MeasuredIds_optional MeasuredIds_;
      Subgroups_optional Subgroups_;
      MeasuredValues_optional MeasuredValues_;
      SubgroupValues_optional SubgroupValues_;
      ::xsd::cxx::tree::one< Status_type > Status_;
      StudyIssues_optional StudyIssues_;
      DistributionTransformation_optional DistributionTransformation_;
    };

    class QIF30_SYMBOL_DECL StatsBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // CommonStatsValue
      //
      typedef ::xsd::qif30::StatsWithReferenceBaseType CommonStatsValue_type;
      typedef ::xsd::cxx::tree::sequence< CommonStatsValue_type > CommonStatsValue_sequence;
      typedef xsd::cxx::tree::sequence< CommonStatsValue_type >::iterator CommonStatsValue_iterator;
      typedef xsd::cxx::tree::sequence< CommonStatsValue_type >::const_iterator CommonStatsValue_const_iterator;
      typedef ::xsd::cxx::tree::traits< CommonStatsValue_type, wchar_t > CommonStatsValue_traits;

      const CommonStatsValue_sequence&
      CommonStatsValue () const;

      CommonStatsValue_sequence&
      CommonStatsValue ();

      void
      CommonStatsValue (const CommonStatsValue_sequence& s);

      // Constructors.
      //
      StatsBaseType ();

      StatsBaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      StatsBaseType (const StatsBaseType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual StatsBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      StatsBaseType&
      operator= (const StatsBaseType& x);

      virtual 
      ~StatsBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      CommonStatsValue_sequence CommonStatsValue_;
    };

    class QIF30_SYMBOL_DECL StatsNumericalBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // NumericCharacteristicStatsValue
      //
      typedef ::xsd::qif30::StatsWithReferenceBaseType NumericCharacteristicStatsValue_type;
      typedef ::xsd::cxx::tree::sequence< NumericCharacteristicStatsValue_type > NumericCharacteristicStatsValue_sequence;
      typedef xsd::cxx::tree::sequence< NumericCharacteristicStatsValue_type >::iterator NumericCharacteristicStatsValue_iterator;
      typedef xsd::cxx::tree::sequence< NumericCharacteristicStatsValue_type >::const_iterator NumericCharacteristicStatsValue_const_iterator;
      typedef ::xsd::cxx::tree::traits< NumericCharacteristicStatsValue_type, wchar_t > NumericCharacteristicStatsValue_traits;

      const NumericCharacteristicStatsValue_sequence&
      NumericCharacteristicStatsValue () const;

      NumericCharacteristicStatsValue_sequence&
      NumericCharacteristicStatsValue ();

      void
      NumericCharacteristicStatsValue (const NumericCharacteristicStatsValue_sequence& s);

      // Constructors.
      //
      StatsNumericalBaseType ();

      StatsNumericalBaseType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      StatsNumericalBaseType (const StatsNumericalBaseType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual StatsNumericalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      StatsNumericalBaseType&
      operator= (const StatsNumericalBaseType& x);

      virtual 
      ~StatsNumericalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      NumericCharacteristicStatsValue_sequence NumericCharacteristicStatsValue_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolNumericalBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // NumericCharacteristicWithTolStatsValue
      //
      typedef ::xsd::qif30::StatsWithReferenceBaseType NumericCharacteristicWithTolStatsValue_type;
      typedef ::xsd::cxx::tree::sequence< NumericCharacteristicWithTolStatsValue_type > NumericCharacteristicWithTolStatsValue_sequence;
      typedef xsd::cxx::tree::sequence< NumericCharacteristicWithTolStatsValue_type >::iterator NumericCharacteristicWithTolStatsValue_iterator;
      typedef xsd::cxx::tree::sequence< NumericCharacteristicWithTolStatsValue_type >::const_iterator NumericCharacteristicWithTolStatsValue_const_iterator;
      typedef ::xsd::cxx::tree::traits< NumericCharacteristicWithTolStatsValue_type, wchar_t > NumericCharacteristicWithTolStatsValue_traits;

      const NumericCharacteristicWithTolStatsValue_sequence&
      NumericCharacteristicWithTolStatsValue () const;

      NumericCharacteristicWithTolStatsValue_sequence&
      NumericCharacteristicWithTolStatsValue ();

      void
      NumericCharacteristicWithTolStatsValue (const NumericCharacteristicWithTolStatsValue_sequence& s);

      // Constructors.
      //
      StatsWithTolNumericalBaseType ();

      StatsWithTolNumericalBaseType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      StatsWithTolNumericalBaseType (const StatsWithTolNumericalBaseType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual StatsWithTolNumericalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      StatsWithTolNumericalBaseType&
      operator= (const StatsWithTolNumericalBaseType& x);

      virtual 
      ~StatsWithTolNumericalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      NumericCharacteristicWithTolStatsValue_sequence NumericCharacteristicWithTolStatsValue_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolLinearType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // Constructors.
      //
      StatsWithTolLinearType ();

      StatsWithTolLinearType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      StatsWithTolLinearType (const StatsWithTolLinearType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual StatsWithTolLinearType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolLinearType&
      operator= (const StatsWithTolLinearType& x);

      virtual 
      ~StatsWithTolLinearType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolAngularType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, wchar_t > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::unique_ptr< angularUnit_type > p);

      // Constructors.
      //
      StatsWithTolAngularType ();

      StatsWithTolAngularType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      StatsWithTolAngularType (const StatsWithTolAngularType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual StatsWithTolAngularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolAngularType&
      operator= (const StatsWithTolAngularType& x);

      virtual 
      ~StatsWithTolAngularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolAreaType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // areaUnit
      //
      typedef ::xml_schema::token areaUnit_type;
      typedef ::xsd::cxx::tree::optional< areaUnit_type > areaUnit_optional;
      typedef ::xsd::cxx::tree::traits< areaUnit_type, wchar_t > areaUnit_traits;

      const areaUnit_optional&
      areaUnit () const;

      areaUnit_optional&
      areaUnit ();

      void
      areaUnit (const areaUnit_type& x);

      void
      areaUnit (const areaUnit_optional& x);

      void
      areaUnit (::std::unique_ptr< areaUnit_type > p);

      // Constructors.
      //
      StatsWithTolAreaType ();

      StatsWithTolAreaType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      StatsWithTolAreaType (const StatsWithTolAreaType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual StatsWithTolAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolAreaType&
      operator= (const StatsWithTolAreaType& x);

      virtual 
      ~StatsWithTolAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      areaUnit_optional areaUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolForceType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // forceUnit
      //
      typedef ::xml_schema::token forceUnit_type;
      typedef ::xsd::cxx::tree::optional< forceUnit_type > forceUnit_optional;
      typedef ::xsd::cxx::tree::traits< forceUnit_type, wchar_t > forceUnit_traits;

      const forceUnit_optional&
      forceUnit () const;

      forceUnit_optional&
      forceUnit ();

      void
      forceUnit (const forceUnit_type& x);

      void
      forceUnit (const forceUnit_optional& x);

      void
      forceUnit (::std::unique_ptr< forceUnit_type > p);

      // Constructors.
      //
      StatsWithTolForceType ();

      StatsWithTolForceType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      StatsWithTolForceType (const StatsWithTolForceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual StatsWithTolForceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolForceType&
      operator= (const StatsWithTolForceType& x);

      virtual 
      ~StatsWithTolForceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      forceUnit_optional forceUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolMassType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // massUnit
      //
      typedef ::xml_schema::token massUnit_type;
      typedef ::xsd::cxx::tree::optional< massUnit_type > massUnit_optional;
      typedef ::xsd::cxx::tree::traits< massUnit_type, wchar_t > massUnit_traits;

      const massUnit_optional&
      massUnit () const;

      massUnit_optional&
      massUnit ();

      void
      massUnit (const massUnit_type& x);

      void
      massUnit (const massUnit_optional& x);

      void
      massUnit (::std::unique_ptr< massUnit_type > p);

      // Constructors.
      //
      StatsWithTolMassType ();

      StatsWithTolMassType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      StatsWithTolMassType (const StatsWithTolMassType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual StatsWithTolMassType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolMassType&
      operator= (const StatsWithTolMassType& x);

      virtual 
      ~StatsWithTolMassType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      massUnit_optional massUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolPressureType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // pressureUnit
      //
      typedef ::xml_schema::token pressureUnit_type;
      typedef ::xsd::cxx::tree::optional< pressureUnit_type > pressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< pressureUnit_type, wchar_t > pressureUnit_traits;

      const pressureUnit_optional&
      pressureUnit () const;

      pressureUnit_optional&
      pressureUnit ();

      void
      pressureUnit (const pressureUnit_type& x);

      void
      pressureUnit (const pressureUnit_optional& x);

      void
      pressureUnit (::std::unique_ptr< pressureUnit_type > p);

      // Constructors.
      //
      StatsWithTolPressureType ();

      StatsWithTolPressureType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      StatsWithTolPressureType (const StatsWithTolPressureType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual StatsWithTolPressureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolPressureType&
      operator= (const StatsWithTolPressureType& x);

      virtual 
      ~StatsWithTolPressureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      pressureUnit_optional pressureUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolSpeedType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // speedUnit
      //
      typedef ::xml_schema::token speedUnit_type;
      typedef ::xsd::cxx::tree::optional< speedUnit_type > speedUnit_optional;
      typedef ::xsd::cxx::tree::traits< speedUnit_type, wchar_t > speedUnit_traits;

      const speedUnit_optional&
      speedUnit () const;

      speedUnit_optional&
      speedUnit ();

      void
      speedUnit (const speedUnit_type& x);

      void
      speedUnit (const speedUnit_optional& x);

      void
      speedUnit (::std::unique_ptr< speedUnit_type > p);

      // Constructors.
      //
      StatsWithTolSpeedType ();

      StatsWithTolSpeedType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      StatsWithTolSpeedType (const StatsWithTolSpeedType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual StatsWithTolSpeedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolSpeedType&
      operator= (const StatsWithTolSpeedType& x);

      virtual 
      ~StatsWithTolSpeedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      speedUnit_optional speedUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolTemperatureType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // temperatureUnit
      //
      typedef ::xml_schema::token temperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< temperatureUnit_type > temperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< temperatureUnit_type, wchar_t > temperatureUnit_traits;

      const temperatureUnit_optional&
      temperatureUnit () const;

      temperatureUnit_optional&
      temperatureUnit ();

      void
      temperatureUnit (const temperatureUnit_type& x);

      void
      temperatureUnit (const temperatureUnit_optional& x);

      void
      temperatureUnit (::std::unique_ptr< temperatureUnit_type > p);

      // Constructors.
      //
      StatsWithTolTemperatureType ();

      StatsWithTolTemperatureType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      StatsWithTolTemperatureType (const StatsWithTolTemperatureType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual StatsWithTolTemperatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolTemperatureType&
      operator= (const StatsWithTolTemperatureType& x);

      virtual 
      ~StatsWithTolTemperatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      temperatureUnit_optional temperatureUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolTimeType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // timeUnit
      //
      typedef ::xml_schema::token timeUnit_type;
      typedef ::xsd::cxx::tree::optional< timeUnit_type > timeUnit_optional;
      typedef ::xsd::cxx::tree::traits< timeUnit_type, wchar_t > timeUnit_traits;

      const timeUnit_optional&
      timeUnit () const;

      timeUnit_optional&
      timeUnit ();

      void
      timeUnit (const timeUnit_type& x);

      void
      timeUnit (const timeUnit_optional& x);

      void
      timeUnit (::std::unique_ptr< timeUnit_type > p);

      // Constructors.
      //
      StatsWithTolTimeType ();

      StatsWithTolTimeType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      StatsWithTolTimeType (const StatsWithTolTimeType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual StatsWithTolTimeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolTimeType&
      operator= (const StatsWithTolTimeType& x);

      virtual 
      ~StatsWithTolTimeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      timeUnit_optional timeUnit_;
    };

    class QIF30_SYMBOL_DECL StatsWithTolUserDefinedUnitType: public ::xsd::qif30::StatsWithTolNumericalBaseType
    {
      public:
      // unitName
      //
      typedef ::xml_schema::token unitName_type;
      typedef ::xsd::cxx::tree::traits< unitName_type, wchar_t > unitName_traits;

      const unitName_type&
      unitName () const;

      unitName_type&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (::std::unique_ptr< unitName_type > p);

      // Constructors.
      //
      StatsWithTolUserDefinedUnitType ();

      StatsWithTolUserDefinedUnitType (const unitName_type&);

      StatsWithTolUserDefinedUnitType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      StatsWithTolUserDefinedUnitType (const StatsWithTolUserDefinedUnitType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual StatsWithTolUserDefinedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsWithTolUserDefinedUnitType&
      operator= (const StatsWithTolUserDefinedUnitType& x);

      virtual 
      ~StatsWithTolUserDefinedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unitName_type > unitName_;
    };

    class QIF30_SYMBOL_DECL StatsLinearType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // Constructors.
      //
      StatsLinearType ();

      StatsLinearType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      StatsLinearType (const StatsLinearType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual StatsLinearType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsLinearType&
      operator= (const StatsLinearType& x);

      virtual 
      ~StatsLinearType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
    };

    class QIF30_SYMBOL_DECL StatsAngularType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, wchar_t > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::unique_ptr< angularUnit_type > p);

      // Constructors.
      //
      StatsAngularType ();

      StatsAngularType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      StatsAngularType (const StatsAngularType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual StatsAngularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsAngularType&
      operator= (const StatsAngularType& x);

      virtual 
      ~StatsAngularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class QIF30_SYMBOL_DECL StatsAreaType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // areaUnit
      //
      typedef ::xml_schema::token areaUnit_type;
      typedef ::xsd::cxx::tree::optional< areaUnit_type > areaUnit_optional;
      typedef ::xsd::cxx::tree::traits< areaUnit_type, wchar_t > areaUnit_traits;

      const areaUnit_optional&
      areaUnit () const;

      areaUnit_optional&
      areaUnit ();

      void
      areaUnit (const areaUnit_type& x);

      void
      areaUnit (const areaUnit_optional& x);

      void
      areaUnit (::std::unique_ptr< areaUnit_type > p);

      // Constructors.
      //
      StatsAreaType ();

      StatsAreaType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      StatsAreaType (const StatsAreaType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual StatsAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsAreaType&
      operator= (const StatsAreaType& x);

      virtual 
      ~StatsAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      areaUnit_optional areaUnit_;
    };

    class QIF30_SYMBOL_DECL StatsForceType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // forceUnit
      //
      typedef ::xml_schema::token forceUnit_type;
      typedef ::xsd::cxx::tree::optional< forceUnit_type > forceUnit_optional;
      typedef ::xsd::cxx::tree::traits< forceUnit_type, wchar_t > forceUnit_traits;

      const forceUnit_optional&
      forceUnit () const;

      forceUnit_optional&
      forceUnit ();

      void
      forceUnit (const forceUnit_type& x);

      void
      forceUnit (const forceUnit_optional& x);

      void
      forceUnit (::std::unique_ptr< forceUnit_type > p);

      // Constructors.
      //
      StatsForceType ();

      StatsForceType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      StatsForceType (const StatsForceType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual StatsForceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsForceType&
      operator= (const StatsForceType& x);

      virtual 
      ~StatsForceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      forceUnit_optional forceUnit_;
    };

    class QIF30_SYMBOL_DECL StatsMassType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // massUnit
      //
      typedef ::xml_schema::token massUnit_type;
      typedef ::xsd::cxx::tree::optional< massUnit_type > massUnit_optional;
      typedef ::xsd::cxx::tree::traits< massUnit_type, wchar_t > massUnit_traits;

      const massUnit_optional&
      massUnit () const;

      massUnit_optional&
      massUnit ();

      void
      massUnit (const massUnit_type& x);

      void
      massUnit (const massUnit_optional& x);

      void
      massUnit (::std::unique_ptr< massUnit_type > p);

      // Constructors.
      //
      StatsMassType ();

      StatsMassType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      StatsMassType (const StatsMassType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual StatsMassType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsMassType&
      operator= (const StatsMassType& x);

      virtual 
      ~StatsMassType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      massUnit_optional massUnit_;
    };

    class QIF30_SYMBOL_DECL StatsPressureType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // pressureUnit
      //
      typedef ::xml_schema::token pressureUnit_type;
      typedef ::xsd::cxx::tree::optional< pressureUnit_type > pressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< pressureUnit_type, wchar_t > pressureUnit_traits;

      const pressureUnit_optional&
      pressureUnit () const;

      pressureUnit_optional&
      pressureUnit ();

      void
      pressureUnit (const pressureUnit_type& x);

      void
      pressureUnit (const pressureUnit_optional& x);

      void
      pressureUnit (::std::unique_ptr< pressureUnit_type > p);

      // Constructors.
      //
      StatsPressureType ();

      StatsPressureType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      StatsPressureType (const StatsPressureType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual StatsPressureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsPressureType&
      operator= (const StatsPressureType& x);

      virtual 
      ~StatsPressureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      pressureUnit_optional pressureUnit_;
    };

    class QIF30_SYMBOL_DECL StatsSpeedType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // speedUnit
      //
      typedef ::xml_schema::token speedUnit_type;
      typedef ::xsd::cxx::tree::optional< speedUnit_type > speedUnit_optional;
      typedef ::xsd::cxx::tree::traits< speedUnit_type, wchar_t > speedUnit_traits;

      const speedUnit_optional&
      speedUnit () const;

      speedUnit_optional&
      speedUnit ();

      void
      speedUnit (const speedUnit_type& x);

      void
      speedUnit (const speedUnit_optional& x);

      void
      speedUnit (::std::unique_ptr< speedUnit_type > p);

      // Constructors.
      //
      StatsSpeedType ();

      StatsSpeedType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      StatsSpeedType (const StatsSpeedType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual StatsSpeedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsSpeedType&
      operator= (const StatsSpeedType& x);

      virtual 
      ~StatsSpeedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      speedUnit_optional speedUnit_;
    };

    class QIF30_SYMBOL_DECL StatsTemperatureType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // temperatureUnit
      //
      typedef ::xml_schema::token temperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< temperatureUnit_type > temperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< temperatureUnit_type, wchar_t > temperatureUnit_traits;

      const temperatureUnit_optional&
      temperatureUnit () const;

      temperatureUnit_optional&
      temperatureUnit ();

      void
      temperatureUnit (const temperatureUnit_type& x);

      void
      temperatureUnit (const temperatureUnit_optional& x);

      void
      temperatureUnit (::std::unique_ptr< temperatureUnit_type > p);

      // Constructors.
      //
      StatsTemperatureType ();

      StatsTemperatureType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      StatsTemperatureType (const StatsTemperatureType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual StatsTemperatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsTemperatureType&
      operator= (const StatsTemperatureType& x);

      virtual 
      ~StatsTemperatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      temperatureUnit_optional temperatureUnit_;
    };

    class QIF30_SYMBOL_DECL StatsTimeType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // timeUnit
      //
      typedef ::xml_schema::token timeUnit_type;
      typedef ::xsd::cxx::tree::optional< timeUnit_type > timeUnit_optional;
      typedef ::xsd::cxx::tree::traits< timeUnit_type, wchar_t > timeUnit_traits;

      const timeUnit_optional&
      timeUnit () const;

      timeUnit_optional&
      timeUnit ();

      void
      timeUnit (const timeUnit_type& x);

      void
      timeUnit (const timeUnit_optional& x);

      void
      timeUnit (::std::unique_ptr< timeUnit_type > p);

      // Constructors.
      //
      StatsTimeType ();

      StatsTimeType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      StatsTimeType (const StatsTimeType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual StatsTimeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsTimeType&
      operator= (const StatsTimeType& x);

      virtual 
      ~StatsTimeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      timeUnit_optional timeUnit_;
    };

    class QIF30_SYMBOL_DECL StatsUserDefinedUnitType: public ::xsd::qif30::StatsNumericalBaseType
    {
      public:
      // unitName
      //
      typedef ::xml_schema::token unitName_type;
      typedef ::xsd::cxx::tree::traits< unitName_type, wchar_t > unitName_traits;

      const unitName_type&
      unitName () const;

      unitName_type&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (::std::unique_ptr< unitName_type > p);

      // Constructors.
      //
      StatsUserDefinedUnitType ();

      StatsUserDefinedUnitType (const unitName_type&);

      StatsUserDefinedUnitType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      StatsUserDefinedUnitType (const StatsUserDefinedUnitType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual StatsUserDefinedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsUserDefinedUnitType&
      operator= (const StatsUserDefinedUnitType& x);

      virtual 
      ~StatsUserDefinedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unitName_type > unitName_;
    };

    class QIF30_SYMBOL_DECL StatsPassFailType: public ::xsd::qif30::StatsBaseType
    {
      public:
      // PassFailStatsValue
      //
      typedef ::xsd::qif30::StatsWithReferenceBaseType PassFailStatsValue_type;
      typedef ::xsd::cxx::tree::sequence< PassFailStatsValue_type > PassFailStatsValue_sequence;
      typedef xsd::cxx::tree::sequence< PassFailStatsValue_type >::iterator PassFailStatsValue_iterator;
      typedef xsd::cxx::tree::sequence< PassFailStatsValue_type >::const_iterator PassFailStatsValue_const_iterator;
      typedef ::xsd::cxx::tree::traits< PassFailStatsValue_type, wchar_t > PassFailStatsValue_traits;

      const PassFailStatsValue_sequence&
      PassFailStatsValue () const;

      PassFailStatsValue_sequence&
      PassFailStatsValue ();

      void
      PassFailStatsValue (const PassFailStatsValue_sequence& s);

      // Constructors.
      //
      StatsPassFailType ();

      StatsPassFailType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      StatsPassFailType (const StatsPassFailType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual StatsPassFailType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StatsPassFailType&
      operator= (const StatsPassFailType& x);

      virtual 
      ~StatsPassFailType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PassFailStatsValue_sequence PassFailStatsValue_;
    };

    class QIF30_SYMBOL_DECL GeometricCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolLinearType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsLinearType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // Constructors.
      //
      GeometricCharacteristicStatsEvalType ();

      GeometricCharacteristicStatsEvalType (const Status_type&);

      GeometricCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      GeometricCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      GeometricCharacteristicStatsEvalType (const GeometricCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual GeometricCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GeometricCharacteristicStatsEvalType&
      operator= (const GeometricCharacteristicStatsEvalType& x);

      virtual 
      ~GeometricCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
    };

    class QIF30_SYMBOL_DECL CompositeSegmentStatsEvalBaseType: public ::xml_schema::type
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolLinearType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsLinearType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // Constructors.
      //
      CompositeSegmentStatsEvalBaseType ();

      CompositeSegmentStatsEvalBaseType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CompositeSegmentStatsEvalBaseType (const CompositeSegmentStatsEvalBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CompositeSegmentStatsEvalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CompositeSegmentStatsEvalBaseType&
      operator= (const CompositeSegmentStatsEvalBaseType& x);

      virtual 
      ~CompositeSegmentStatsEvalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
    };

    class QIF30_SYMBOL_DECL CompositeSegmentPositionStatsEvalType: public ::xsd::qif30::CompositeSegmentStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      CompositeSegmentPositionStatsEvalType ();

      CompositeSegmentPositionStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CompositeSegmentPositionStatsEvalType (const CompositeSegmentPositionStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual CompositeSegmentPositionStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CompositeSegmentPositionStatsEvalType&
      operator= (const CompositeSegmentPositionStatsEvalType&) = default;
#endif

      virtual 
      ~CompositeSegmentPositionStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL CompositeSegmentsPositionStatsEvalType: public ::xml_schema::type
    {
      public:
      // SecondCompositeSegmentPositionStats
      //
      typedef ::xsd::qif30::CompositeSegmentPositionStatsEvalType SecondCompositeSegmentPositionStats_type;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentPositionStats_type, wchar_t > SecondCompositeSegmentPositionStats_traits;

      const SecondCompositeSegmentPositionStats_type&
      SecondCompositeSegmentPositionStats () const;

      SecondCompositeSegmentPositionStats_type&
      SecondCompositeSegmentPositionStats ();

      void
      SecondCompositeSegmentPositionStats (const SecondCompositeSegmentPositionStats_type& x);

      void
      SecondCompositeSegmentPositionStats (::std::unique_ptr< SecondCompositeSegmentPositionStats_type > p);

      // ThirdCompositeSegmentPositionStats
      //
      typedef ::xsd::qif30::CompositeSegmentPositionStatsEvalType ThirdCompositeSegmentPositionStats_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentPositionStats_type > ThirdCompositeSegmentPositionStats_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentPositionStats_type, wchar_t > ThirdCompositeSegmentPositionStats_traits;

      const ThirdCompositeSegmentPositionStats_optional&
      ThirdCompositeSegmentPositionStats () const;

      ThirdCompositeSegmentPositionStats_optional&
      ThirdCompositeSegmentPositionStats ();

      void
      ThirdCompositeSegmentPositionStats (const ThirdCompositeSegmentPositionStats_type& x);

      void
      ThirdCompositeSegmentPositionStats (const ThirdCompositeSegmentPositionStats_optional& x);

      void
      ThirdCompositeSegmentPositionStats (::std::unique_ptr< ThirdCompositeSegmentPositionStats_type > p);

      // FourthCompositeSegmentPositionStats
      //
      typedef ::xsd::qif30::CompositeSegmentPositionStatsEvalType FourthCompositeSegmentPositionStats_type;
      typedef ::xsd::cxx::tree::optional< FourthCompositeSegmentPositionStats_type > FourthCompositeSegmentPositionStats_optional;
      typedef ::xsd::cxx::tree::traits< FourthCompositeSegmentPositionStats_type, wchar_t > FourthCompositeSegmentPositionStats_traits;

      const FourthCompositeSegmentPositionStats_optional&
      FourthCompositeSegmentPositionStats () const;

      FourthCompositeSegmentPositionStats_optional&
      FourthCompositeSegmentPositionStats ();

      void
      FourthCompositeSegmentPositionStats (const FourthCompositeSegmentPositionStats_type& x);

      void
      FourthCompositeSegmentPositionStats (const FourthCompositeSegmentPositionStats_optional& x);

      void
      FourthCompositeSegmentPositionStats (::std::unique_ptr< FourthCompositeSegmentPositionStats_type > p);

      // Constructors.
      //
      CompositeSegmentsPositionStatsEvalType ();

      CompositeSegmentsPositionStatsEvalType (const SecondCompositeSegmentPositionStats_type&);

      CompositeSegmentsPositionStatsEvalType (::std::unique_ptr< SecondCompositeSegmentPositionStats_type >);

      CompositeSegmentsPositionStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      CompositeSegmentsPositionStatsEvalType (const CompositeSegmentsPositionStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual CompositeSegmentsPositionStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompositeSegmentsPositionStatsEvalType&
      operator= (const CompositeSegmentsPositionStatsEvalType& x);

      virtual 
      ~CompositeSegmentsPositionStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SecondCompositeSegmentPositionStats_type > SecondCompositeSegmentPositionStats_;
      ThirdCompositeSegmentPositionStats_optional ThirdCompositeSegmentPositionStats_;
      FourthCompositeSegmentPositionStats_optional FourthCompositeSegmentPositionStats_;
    };

    class QIF30_SYMBOL_DECL CompositeSegmentProfileStatsEvalType: public ::xsd::qif30::CompositeSegmentStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      CompositeSegmentProfileStatsEvalType ();

      CompositeSegmentProfileStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CompositeSegmentProfileStatsEvalType (const CompositeSegmentProfileStatsEvalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CompositeSegmentProfileStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CompositeSegmentProfileStatsEvalType&
      operator= (const CompositeSegmentProfileStatsEvalType&) = default;
#endif

      virtual 
      ~CompositeSegmentProfileStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL CompositeSegmentsProfileStatsEvalType: public ::xml_schema::type
    {
      public:
      // SecondCompositeSegmentProfileStats
      //
      typedef ::xsd::qif30::CompositeSegmentProfileStatsEvalType SecondCompositeSegmentProfileStats_type;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentProfileStats_type, wchar_t > SecondCompositeSegmentProfileStats_traits;

      const SecondCompositeSegmentProfileStats_type&
      SecondCompositeSegmentProfileStats () const;

      SecondCompositeSegmentProfileStats_type&
      SecondCompositeSegmentProfileStats ();

      void
      SecondCompositeSegmentProfileStats (const SecondCompositeSegmentProfileStats_type& x);

      void
      SecondCompositeSegmentProfileStats (::std::unique_ptr< SecondCompositeSegmentProfileStats_type > p);

      // ThirdCompositeSegmentProfileStats
      //
      typedef ::xsd::qif30::CompositeSegmentProfileStatsEvalType ThirdCompositeSegmentProfileStats_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentProfileStats_type > ThirdCompositeSegmentProfileStats_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentProfileStats_type, wchar_t > ThirdCompositeSegmentProfileStats_traits;

      const ThirdCompositeSegmentProfileStats_optional&
      ThirdCompositeSegmentProfileStats () const;

      ThirdCompositeSegmentProfileStats_optional&
      ThirdCompositeSegmentProfileStats ();

      void
      ThirdCompositeSegmentProfileStats (const ThirdCompositeSegmentProfileStats_type& x);

      void
      ThirdCompositeSegmentProfileStats (const ThirdCompositeSegmentProfileStats_optional& x);

      void
      ThirdCompositeSegmentProfileStats (::std::unique_ptr< ThirdCompositeSegmentProfileStats_type > p);

      // FourthCompositeSegmentProfileStats
      //
      typedef ::xsd::qif30::CompositeSegmentProfileStatsEvalType FourthCompositeSegmentProfileStats_type;
      typedef ::xsd::cxx::tree::optional< FourthCompositeSegmentProfileStats_type > FourthCompositeSegmentProfileStats_optional;
      typedef ::xsd::cxx::tree::traits< FourthCompositeSegmentProfileStats_type, wchar_t > FourthCompositeSegmentProfileStats_traits;

      const FourthCompositeSegmentProfileStats_optional&
      FourthCompositeSegmentProfileStats () const;

      FourthCompositeSegmentProfileStats_optional&
      FourthCompositeSegmentProfileStats ();

      void
      FourthCompositeSegmentProfileStats (const FourthCompositeSegmentProfileStats_type& x);

      void
      FourthCompositeSegmentProfileStats (const FourthCompositeSegmentProfileStats_optional& x);

      void
      FourthCompositeSegmentProfileStats (::std::unique_ptr< FourthCompositeSegmentProfileStats_type > p);

      // Constructors.
      //
      CompositeSegmentsProfileStatsEvalType ();

      CompositeSegmentsProfileStatsEvalType (const SecondCompositeSegmentProfileStats_type&);

      CompositeSegmentsProfileStatsEvalType (::std::unique_ptr< SecondCompositeSegmentProfileStats_type >);

      CompositeSegmentsProfileStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CompositeSegmentsProfileStatsEvalType (const CompositeSegmentsProfileStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual CompositeSegmentsProfileStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompositeSegmentsProfileStatsEvalType&
      operator= (const CompositeSegmentsProfileStatsEvalType& x);

      virtual 
      ~CompositeSegmentsProfileStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SecondCompositeSegmentProfileStats_type > SecondCompositeSegmentProfileStats_;
      ThirdCompositeSegmentProfileStats_optional ThirdCompositeSegmentProfileStats_;
      FourthCompositeSegmentProfileStats_optional FourthCompositeSegmentProfileStats_;
    };

    class QIF30_SYMBOL_DECL CompositeSegmentSymmetryStatsEvalType: public ::xsd::qif30::CompositeSegmentStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      CompositeSegmentSymmetryStatsEvalType ();

      CompositeSegmentSymmetryStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CompositeSegmentSymmetryStatsEvalType (const CompositeSegmentSymmetryStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual CompositeSegmentSymmetryStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CompositeSegmentSymmetryStatsEvalType&
      operator= (const CompositeSegmentSymmetryStatsEvalType&) = default;
#endif

      virtual 
      ~CompositeSegmentSymmetryStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL CompositeSegmentsSymmetryStatsEvalType: public ::xml_schema::type
    {
      public:
      // SecondCompositeSegmentSymmetryStats
      //
      typedef ::xsd::qif30::CompositeSegmentSymmetryStatsEvalType SecondCompositeSegmentSymmetryStats_type;
      typedef ::xsd::cxx::tree::traits< SecondCompositeSegmentSymmetryStats_type, wchar_t > SecondCompositeSegmentSymmetryStats_traits;

      const SecondCompositeSegmentSymmetryStats_type&
      SecondCompositeSegmentSymmetryStats () const;

      SecondCompositeSegmentSymmetryStats_type&
      SecondCompositeSegmentSymmetryStats ();

      void
      SecondCompositeSegmentSymmetryStats (const SecondCompositeSegmentSymmetryStats_type& x);

      void
      SecondCompositeSegmentSymmetryStats (::std::unique_ptr< SecondCompositeSegmentSymmetryStats_type > p);

      // ThirdCompositeSegmentSymmetryStats
      //
      typedef ::xsd::qif30::CompositeSegmentSymmetryStatsEvalType ThirdCompositeSegmentSymmetryStats_type;
      typedef ::xsd::cxx::tree::optional< ThirdCompositeSegmentSymmetryStats_type > ThirdCompositeSegmentSymmetryStats_optional;
      typedef ::xsd::cxx::tree::traits< ThirdCompositeSegmentSymmetryStats_type, wchar_t > ThirdCompositeSegmentSymmetryStats_traits;

      const ThirdCompositeSegmentSymmetryStats_optional&
      ThirdCompositeSegmentSymmetryStats () const;

      ThirdCompositeSegmentSymmetryStats_optional&
      ThirdCompositeSegmentSymmetryStats ();

      void
      ThirdCompositeSegmentSymmetryStats (const ThirdCompositeSegmentSymmetryStats_type& x);

      void
      ThirdCompositeSegmentSymmetryStats (const ThirdCompositeSegmentSymmetryStats_optional& x);

      void
      ThirdCompositeSegmentSymmetryStats (::std::unique_ptr< ThirdCompositeSegmentSymmetryStats_type > p);

      // Constructors.
      //
      CompositeSegmentsSymmetryStatsEvalType ();

      CompositeSegmentsSymmetryStatsEvalType (const SecondCompositeSegmentSymmetryStats_type&);

      CompositeSegmentsSymmetryStatsEvalType (::std::unique_ptr< SecondCompositeSegmentSymmetryStats_type >);

      CompositeSegmentsSymmetryStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      CompositeSegmentsSymmetryStatsEvalType (const CompositeSegmentsSymmetryStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual CompositeSegmentsSymmetryStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompositeSegmentsSymmetryStatsEvalType&
      operator= (const CompositeSegmentsSymmetryStatsEvalType& x);

      virtual 
      ~CompositeSegmentsSymmetryStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SecondCompositeSegmentSymmetryStats_type > SecondCompositeSegmentSymmetryStats_;
      ThirdCompositeSegmentSymmetryStats_optional ThirdCompositeSegmentSymmetryStats_;
    };

    class QIF30_SYMBOL_DECL LinearCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolLinearType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsLinearType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolLinearType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsLinearType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      LinearCharacteristicStatsEvalType ();

      LinearCharacteristicStatsEvalType (const Status_type&);

      LinearCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      LinearCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LinearCharacteristicStatsEvalType (const LinearCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual LinearCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearCharacteristicStatsEvalType&
      operator= (const LinearCharacteristicStatsEvalType& x);

      virtual 
      ~LinearCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL AngularCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolAngularType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsAngularType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsAngularType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolAngularType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsAngularType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsAngularType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      AngularCharacteristicStatsEvalType ();

      AngularCharacteristicStatsEvalType (const Status_type&);

      AngularCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      AngularCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngularCharacteristicStatsEvalType (const AngularCharacteristicStatsEvalType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual AngularCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularCharacteristicStatsEvalType&
      operator= (const AngularCharacteristicStatsEvalType& x);

      virtual 
      ~AngularCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAttributeCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // AttributeStats
      //
      typedef ::xsd::qif30::StatsPassFailType AttributeStats_type;
      typedef ::xsd::cxx::tree::optional< AttributeStats_type > AttributeStats_optional;
      typedef ::xsd::cxx::tree::traits< AttributeStats_type, wchar_t > AttributeStats_traits;

      const AttributeStats_optional&
      AttributeStats () const;

      AttributeStats_optional&
      AttributeStats ();

      void
      AttributeStats (const AttributeStats_type& x);

      void
      AttributeStats (const AttributeStats_optional& x);

      void
      AttributeStats (::std::unique_ptr< AttributeStats_type > p);

      // Constructors.
      //
      UserDefinedAttributeCharacteristicStatsEvalType ();

      UserDefinedAttributeCharacteristicStatsEvalType (const Status_type&);

      UserDefinedAttributeCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedAttributeCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      UserDefinedAttributeCharacteristicStatsEvalType (const UserDefinedAttributeCharacteristicStatsEvalType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual UserDefinedAttributeCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAttributeCharacteristicStatsEvalType&
      operator= (const UserDefinedAttributeCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedAttributeCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AttributeStats_optional AttributeStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedLinearCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolLinearType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsLinearType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolLinearType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsLinearType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedLinearCharacteristicStatsEvalType ();

      UserDefinedLinearCharacteristicStatsEvalType (const Status_type&);

      UserDefinedLinearCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedLinearCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      UserDefinedLinearCharacteristicStatsEvalType (const UserDefinedLinearCharacteristicStatsEvalType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual UserDefinedLinearCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedLinearCharacteristicStatsEvalType&
      operator= (const UserDefinedLinearCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedLinearCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAngularCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolAngularType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsAngularType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsAngularType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolAngularType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsAngularType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsAngularType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedAngularCharacteristicStatsEvalType ();

      UserDefinedAngularCharacteristicStatsEvalType (const Status_type&);

      UserDefinedAngularCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedAngularCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      UserDefinedAngularCharacteristicStatsEvalType (const UserDefinedAngularCharacteristicStatsEvalType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual UserDefinedAngularCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAngularCharacteristicStatsEvalType&
      operator= (const UserDefinedAngularCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedAngularCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedAreaCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolAreaType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsAreaType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsAreaType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolAreaType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsAreaType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsAreaType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedAreaCharacteristicStatsEvalType ();

      UserDefinedAreaCharacteristicStatsEvalType (const Status_type&);

      UserDefinedAreaCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedAreaCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      UserDefinedAreaCharacteristicStatsEvalType (const UserDefinedAreaCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual UserDefinedAreaCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedAreaCharacteristicStatsEvalType&
      operator= (const UserDefinedAreaCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedAreaCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedForceCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolForceType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsForceType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsForceType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolForceType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsForceType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsForceType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedForceCharacteristicStatsEvalType ();

      UserDefinedForceCharacteristicStatsEvalType (const Status_type&);

      UserDefinedForceCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedForceCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      UserDefinedForceCharacteristicStatsEvalType (const UserDefinedForceCharacteristicStatsEvalType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual UserDefinedForceCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedForceCharacteristicStatsEvalType&
      operator= (const UserDefinedForceCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedForceCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedMassCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolMassType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsMassType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsMassType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolMassType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsMassType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsMassType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedMassCharacteristicStatsEvalType ();

      UserDefinedMassCharacteristicStatsEvalType (const Status_type&);

      UserDefinedMassCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedMassCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      UserDefinedMassCharacteristicStatsEvalType (const UserDefinedMassCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual UserDefinedMassCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedMassCharacteristicStatsEvalType&
      operator= (const UserDefinedMassCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedMassCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedPressureCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolPressureType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsPressureType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsPressureType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolPressureType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsPressureType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsPressureType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedPressureCharacteristicStatsEvalType ();

      UserDefinedPressureCharacteristicStatsEvalType (const Status_type&);

      UserDefinedPressureCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedPressureCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      UserDefinedPressureCharacteristicStatsEvalType (const UserDefinedPressureCharacteristicStatsEvalType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual UserDefinedPressureCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedPressureCharacteristicStatsEvalType&
      operator= (const UserDefinedPressureCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedPressureCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedSpeedCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolSpeedType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsSpeedType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsSpeedType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolSpeedType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsSpeedType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsSpeedType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedSpeedCharacteristicStatsEvalType ();

      UserDefinedSpeedCharacteristicStatsEvalType (const Status_type&);

      UserDefinedSpeedCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedSpeedCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      UserDefinedSpeedCharacteristicStatsEvalType (const UserDefinedSpeedCharacteristicStatsEvalType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual UserDefinedSpeedCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedSpeedCharacteristicStatsEvalType&
      operator= (const UserDefinedSpeedCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedSpeedCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedTemperatureCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolTemperatureType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsTemperatureType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsTemperatureType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolTemperatureType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsTemperatureType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsTemperatureType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedTemperatureCharacteristicStatsEvalType ();

      UserDefinedTemperatureCharacteristicStatsEvalType (const Status_type&);

      UserDefinedTemperatureCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedTemperatureCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      UserDefinedTemperatureCharacteristicStatsEvalType (const UserDefinedTemperatureCharacteristicStatsEvalType& x,
                                                         ::xml_schema::flags f = 0,
                                                         ::xml_schema::container* c = 0);

      virtual UserDefinedTemperatureCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedTemperatureCharacteristicStatsEvalType&
      operator= (const UserDefinedTemperatureCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedTemperatureCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedTimeCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolTimeType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsTimeType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsTimeType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolTimeType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsTimeType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsTimeType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedTimeCharacteristicStatsEvalType ();

      UserDefinedTimeCharacteristicStatsEvalType (const Status_type&);

      UserDefinedTimeCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedTimeCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      UserDefinedTimeCharacteristicStatsEvalType (const UserDefinedTimeCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual UserDefinedTimeCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedTimeCharacteristicStatsEvalType&
      operator= (const UserDefinedTimeCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedTimeCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL UserDefinedUnitCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ValueStats
      //
      typedef ::xsd::qif30::StatsWithTolUserDefinedUnitType ValueStats_type;
      typedef ::xsd::cxx::tree::optional< ValueStats_type > ValueStats_optional;
      typedef ::xsd::cxx::tree::traits< ValueStats_type, wchar_t > ValueStats_traits;

      const ValueStats_optional&
      ValueStats () const;

      ValueStats_optional&
      ValueStats ();

      void
      ValueStats (const ValueStats_type& x);

      void
      ValueStats (const ValueStats_optional& x);

      void
      ValueStats (::std::unique_ptr< ValueStats_type > p);

      // MaxValueStats
      //
      typedef ::xsd::qif30::StatsUserDefinedUnitType MaxValueStats_type;
      typedef ::xsd::cxx::tree::optional< MaxValueStats_type > MaxValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxValueStats_type, wchar_t > MaxValueStats_traits;

      const MaxValueStats_optional&
      MaxValueStats () const;

      MaxValueStats_optional&
      MaxValueStats ();

      void
      MaxValueStats (const MaxValueStats_type& x);

      void
      MaxValueStats (const MaxValueStats_optional& x);

      void
      MaxValueStats (::std::unique_ptr< MaxValueStats_type > p);

      // MinValueStats
      //
      typedef ::xsd::qif30::StatsUserDefinedUnitType MinValueStats_type;
      typedef ::xsd::cxx::tree::optional< MinValueStats_type > MinValueStats_optional;
      typedef ::xsd::cxx::tree::traits< MinValueStats_type, wchar_t > MinValueStats_traits;

      const MinValueStats_optional&
      MinValueStats () const;

      MinValueStats_optional&
      MinValueStats ();

      void
      MinValueStats (const MinValueStats_type& x);

      void
      MinValueStats (const MinValueStats_optional& x);

      void
      MinValueStats (::std::unique_ptr< MinValueStats_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsWithTolUserDefinedUnitType DeviationStats_type;
      typedef ::xsd::cxx::tree::optional< DeviationStats_type > DeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_optional&
      DeviationStats () const;

      DeviationStats_optional&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (const DeviationStats_optional& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // MaxDeviationStats
      //
      typedef ::xsd::qif30::StatsUserDefinedUnitType MaxDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MaxDeviationStats_type > MaxDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxDeviationStats_type, wchar_t > MaxDeviationStats_traits;

      const MaxDeviationStats_optional&
      MaxDeviationStats () const;

      MaxDeviationStats_optional&
      MaxDeviationStats ();

      void
      MaxDeviationStats (const MaxDeviationStats_type& x);

      void
      MaxDeviationStats (const MaxDeviationStats_optional& x);

      void
      MaxDeviationStats (::std::unique_ptr< MaxDeviationStats_type > p);

      // MinDeviationStats
      //
      typedef ::xsd::qif30::StatsUserDefinedUnitType MinDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< MinDeviationStats_type > MinDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< MinDeviationStats_type, wchar_t > MinDeviationStats_traits;

      const MinDeviationStats_optional&
      MinDeviationStats () const;

      MinDeviationStats_optional&
      MinDeviationStats ();

      void
      MinDeviationStats (const MinDeviationStats_type& x);

      void
      MinDeviationStats (const MinDeviationStats_optional& x);

      void
      MinDeviationStats (::std::unique_ptr< MinDeviationStats_type > p);

      // Constructors.
      //
      UserDefinedUnitCharacteristicStatsEvalType ();

      UserDefinedUnitCharacteristicStatsEvalType (const Status_type&);

      UserDefinedUnitCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      UserDefinedUnitCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      UserDefinedUnitCharacteristicStatsEvalType (const UserDefinedUnitCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual UserDefinedUnitCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UserDefinedUnitCharacteristicStatsEvalType&
      operator= (const UserDefinedUnitCharacteristicStatsEvalType& x);

      virtual 
      ~UserDefinedUnitCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ValueStats_optional ValueStats_;
      MaxValueStats_optional MaxValueStats_;
      MinValueStats_optional MinValueStats_;
      DeviationStats_optional DeviationStats_;
      MaxDeviationStats_optional MaxDeviationStats_;
      MinDeviationStats_optional MinDeviationStats_;
    };

    class QIF30_SYMBOL_DECL SurfaceTextureCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // RoughnessAverageValueStats
      //
      typedef ::xsd::qif30::StatsWithTolLinearType RoughnessAverageValueStats_type;
      typedef ::xsd::cxx::tree::optional< RoughnessAverageValueStats_type > RoughnessAverageValueStats_optional;
      typedef ::xsd::cxx::tree::traits< RoughnessAverageValueStats_type, wchar_t > RoughnessAverageValueStats_traits;

      const RoughnessAverageValueStats_optional&
      RoughnessAverageValueStats () const;

      RoughnessAverageValueStats_optional&
      RoughnessAverageValueStats ();

      void
      RoughnessAverageValueStats (const RoughnessAverageValueStats_type& x);

      void
      RoughnessAverageValueStats (const RoughnessAverageValueStats_optional& x);

      void
      RoughnessAverageValueStats (::std::unique_ptr< RoughnessAverageValueStats_type > p);

      // Constructors.
      //
      SurfaceTextureCharacteristicStatsEvalType ();

      SurfaceTextureCharacteristicStatsEvalType (const Status_type&);

      SurfaceTextureCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      SurfaceTextureCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SurfaceTextureCharacteristicStatsEvalType (const SurfaceTextureCharacteristicStatsEvalType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual SurfaceTextureCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceTextureCharacteristicStatsEvalType&
      operator= (const SurfaceTextureCharacteristicStatsEvalType& x);

      virtual 
      ~SurfaceTextureCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      RoughnessAverageValueStats_optional RoughnessAverageValueStats_;
    };

    class QIF30_SYMBOL_DECL OrientationCharacteristicStatsEvalType: public ::xsd::qif30::GeometricCharacteristicStatsEvalType
    {
      public:
      // CapabilityCalculationMethod
      //
      typedef ::xsd::qif30::OneSidedCapabilityCalculationEnumType CapabilityCalculationMethod_type;
      typedef ::xsd::cxx::tree::optional< CapabilityCalculationMethod_type > CapabilityCalculationMethod_optional;
      typedef ::xsd::cxx::tree::traits< CapabilityCalculationMethod_type, wchar_t > CapabilityCalculationMethod_traits;

      const CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod () const;

      CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod ();

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x);

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x);

      void
      CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > p);

      // DatumsOkStats
      //
      typedef ::xsd::qif30::StatsPassFailType DatumsOkStats_type;
      typedef ::xsd::cxx::tree::optional< DatumsOkStats_type > DatumsOkStats_optional;
      typedef ::xsd::cxx::tree::traits< DatumsOkStats_type, wchar_t > DatumsOkStats_traits;

      const DatumsOkStats_optional&
      DatumsOkStats () const;

      DatumsOkStats_optional&
      DatumsOkStats ();

      void
      DatumsOkStats (const DatumsOkStats_type& x);

      void
      DatumsOkStats (const DatumsOkStats_optional& x);

      void
      DatumsOkStats (::std::unique_ptr< DatumsOkStats_type > p);

      // BonusStats
      //
      typedef ::xsd::qif30::StatsLinearType BonusStats_type;
      typedef ::xsd::cxx::tree::optional< BonusStats_type > BonusStats_optional;
      typedef ::xsd::cxx::tree::traits< BonusStats_type, wchar_t > BonusStats_traits;

      const BonusStats_optional&
      BonusStats () const;

      BonusStats_optional&
      BonusStats ();

      void
      BonusStats (const BonusStats_type& x);

      void
      BonusStats (const BonusStats_optional& x);

      void
      BonusStats (::std::unique_ptr< BonusStats_type > p);

      // ReferenceLengthStats
      //
      typedef ::xsd::qif30::StatsLinearType ReferenceLengthStats_type;
      typedef ::xsd::cxx::tree::optional< ReferenceLengthStats_type > ReferenceLengthStats_optional;
      typedef ::xsd::cxx::tree::traits< ReferenceLengthStats_type, wchar_t > ReferenceLengthStats_traits;

      const ReferenceLengthStats_optional&
      ReferenceLengthStats () const;

      ReferenceLengthStats_optional&
      ReferenceLengthStats ();

      void
      ReferenceLengthStats (const ReferenceLengthStats_type& x);

      void
      ReferenceLengthStats (const ReferenceLengthStats_optional& x);

      void
      ReferenceLengthStats (::std::unique_ptr< ReferenceLengthStats_type > p);

      // Constructors.
      //
      OrientationCharacteristicStatsEvalType ();

      OrientationCharacteristicStatsEvalType (const Status_type&);

      OrientationCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      OrientationCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OrientationCharacteristicStatsEvalType (const OrientationCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual OrientationCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrientationCharacteristicStatsEvalType&
      operator= (const OrientationCharacteristicStatsEvalType& x);

      virtual 
      ~OrientationCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CapabilityCalculationMethod_optional CapabilityCalculationMethod_;
      DatumsOkStats_optional DatumsOkStats_;
      BonusStats_optional BonusStats_;
      ReferenceLengthStats_optional ReferenceLengthStats_;
    };

    class QIF30_SYMBOL_DECL AngularityCharacteristicStatsEvalType: public ::xsd::qif30::OrientationCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      AngularityCharacteristicStatsEvalType ();

      AngularityCharacteristicStatsEvalType (const Status_type&);

      AngularityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      AngularityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      AngularityCharacteristicStatsEvalType (const AngularityCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual AngularityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngularityCharacteristicStatsEvalType&
      operator= (const AngularityCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~AngularityCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL PerpendicularityCharacteristicStatsEvalType: public ::xsd::qif30::OrientationCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      PerpendicularityCharacteristicStatsEvalType ();

      PerpendicularityCharacteristicStatsEvalType (const Status_type&);

      PerpendicularityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      PerpendicularityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      PerpendicularityCharacteristicStatsEvalType (const PerpendicularityCharacteristicStatsEvalType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual PerpendicularityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PerpendicularityCharacteristicStatsEvalType&
      operator= (const PerpendicularityCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~PerpendicularityCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL ParallelismCharacteristicStatsEvalType: public ::xsd::qif30::OrientationCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      ParallelismCharacteristicStatsEvalType ();

      ParallelismCharacteristicStatsEvalType (const Status_type&);

      ParallelismCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      ParallelismCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ParallelismCharacteristicStatsEvalType (const ParallelismCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ParallelismCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ParallelismCharacteristicStatsEvalType&
      operator= (const ParallelismCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~ParallelismCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL FormCharacteristicStatsEvalBaseType: public ::xsd::qif30::GeometricCharacteristicStatsEvalType
    {
      public:
      // CapabilityCalculationMethod
      //
      typedef ::xsd::qif30::OneSidedCapabilityCalculationEnumType CapabilityCalculationMethod_type;
      typedef ::xsd::cxx::tree::optional< CapabilityCalculationMethod_type > CapabilityCalculationMethod_optional;
      typedef ::xsd::cxx::tree::traits< CapabilityCalculationMethod_type, wchar_t > CapabilityCalculationMethod_traits;

      const CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod () const;

      CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod ();

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x);

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x);

      void
      CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > p);

      // Constructors.
      //
      FormCharacteristicStatsEvalBaseType ();

      FormCharacteristicStatsEvalBaseType (const Status_type&);

      FormCharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type >);

      FormCharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      FormCharacteristicStatsEvalBaseType (const FormCharacteristicStatsEvalBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual FormCharacteristicStatsEvalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      FormCharacteristicStatsEvalBaseType&
      operator= (const FormCharacteristicStatsEvalBaseType& x);

      virtual 
      ~FormCharacteristicStatsEvalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CapabilityCalculationMethod_optional CapabilityCalculationMethod_;
    };

    class QIF30_SYMBOL_DECL CircularityCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // MaxCircularityStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxCircularityStats_type;
      typedef ::xsd::cxx::tree::optional< MaxCircularityStats_type > MaxCircularityStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxCircularityStats_type, wchar_t > MaxCircularityStats_traits;

      const MaxCircularityStats_optional&
      MaxCircularityStats () const;

      MaxCircularityStats_optional&
      MaxCircularityStats ();

      void
      MaxCircularityStats (const MaxCircularityStats_type& x);

      void
      MaxCircularityStats (const MaxCircularityStats_optional& x);

      void
      MaxCircularityStats (::std::unique_ptr< MaxCircularityStats_type > p);

      // Constructors.
      //
      CircularityCharacteristicStatsEvalType ();

      CircularityCharacteristicStatsEvalType (const Status_type&);

      CircularityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      CircularityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      CircularityCharacteristicStatsEvalType (const CircularityCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual CircularityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CircularityCharacteristicStatsEvalType&
      operator= (const CircularityCharacteristicStatsEvalType& x);

      virtual 
      ~CircularityCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxCircularityStats_optional MaxCircularityStats_;
    };

    class QIF30_SYMBOL_DECL ConicityCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      ConicityCharacteristicStatsEvalType ();

      ConicityCharacteristicStatsEvalType (const Status_type&);

      ConicityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      ConicityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ConicityCharacteristicStatsEvalType (const ConicityCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ConicityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConicityCharacteristicStatsEvalType&
      operator= (const ConicityCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~ConicityCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL CylindricityCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // MaxCylindricityStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxCylindricityStats_type;
      typedef ::xsd::cxx::tree::optional< MaxCylindricityStats_type > MaxCylindricityStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxCylindricityStats_type, wchar_t > MaxCylindricityStats_traits;

      const MaxCylindricityStats_optional&
      MaxCylindricityStats () const;

      MaxCylindricityStats_optional&
      MaxCylindricityStats ();

      void
      MaxCylindricityStats (const MaxCylindricityStats_type& x);

      void
      MaxCylindricityStats (const MaxCylindricityStats_optional& x);

      void
      MaxCylindricityStats (::std::unique_ptr< MaxCylindricityStats_type > p);

      // Constructors.
      //
      CylindricityCharacteristicStatsEvalType ();

      CylindricityCharacteristicStatsEvalType (const Status_type&);

      CylindricityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      CylindricityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CylindricityCharacteristicStatsEvalType (const CylindricityCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CylindricityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricityCharacteristicStatsEvalType&
      operator= (const CylindricityCharacteristicStatsEvalType& x);

      virtual 
      ~CylindricityCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxCylindricityStats_optional MaxCylindricityStats_;
    };

    class QIF30_SYMBOL_DECL EllipticityCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      EllipticityCharacteristicStatsEvalType ();

      EllipticityCharacteristicStatsEvalType (const Status_type&);

      EllipticityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      EllipticityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      EllipticityCharacteristicStatsEvalType (const EllipticityCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual EllipticityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      EllipticityCharacteristicStatsEvalType&
      operator= (const EllipticityCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~EllipticityCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL FlatnessCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // BonusStats
      //
      typedef ::xsd::qif30::StatsLinearType BonusStats_type;
      typedef ::xsd::cxx::tree::optional< BonusStats_type > BonusStats_optional;
      typedef ::xsd::cxx::tree::traits< BonusStats_type, wchar_t > BonusStats_traits;

      const BonusStats_optional&
      BonusStats () const;

      BonusStats_optional&
      BonusStats ();

      void
      BonusStats (const BonusStats_type& x);

      void
      BonusStats (const BonusStats_optional& x);

      void
      BonusStats (::std::unique_ptr< BonusStats_type > p);

      // MaxFlatnessStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxFlatnessStats_type;
      typedef ::xsd::cxx::tree::optional< MaxFlatnessStats_type > MaxFlatnessStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxFlatnessStats_type, wchar_t > MaxFlatnessStats_traits;

      const MaxFlatnessStats_optional&
      MaxFlatnessStats () const;

      MaxFlatnessStats_optional&
      MaxFlatnessStats ();

      void
      MaxFlatnessStats (const MaxFlatnessStats_type& x);

      void
      MaxFlatnessStats (const MaxFlatnessStats_optional& x);

      void
      MaxFlatnessStats (::std::unique_ptr< MaxFlatnessStats_type > p);

      // Constructors.
      //
      FlatnessCharacteristicStatsEvalType ();

      FlatnessCharacteristicStatsEvalType (const Status_type&);

      FlatnessCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      FlatnessCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      FlatnessCharacteristicStatsEvalType (const FlatnessCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual FlatnessCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FlatnessCharacteristicStatsEvalType&
      operator= (const FlatnessCharacteristicStatsEvalType& x);

      virtual 
      ~FlatnessCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BonusStats_optional BonusStats_;
      MaxFlatnessStats_optional MaxFlatnessStats_;
    };

    class QIF30_SYMBOL_DECL SphericityCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      SphericityCharacteristicStatsEvalType ();

      SphericityCharacteristicStatsEvalType (const Status_type&);

      SphericityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      SphericityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      SphericityCharacteristicStatsEvalType (const SphericityCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual SphericityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericityCharacteristicStatsEvalType&
      operator= (const SphericityCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~SphericityCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL StraightnessCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // BonusStats
      //
      typedef ::xsd::qif30::StatsLinearType BonusStats_type;
      typedef ::xsd::cxx::tree::optional< BonusStats_type > BonusStats_optional;
      typedef ::xsd::cxx::tree::traits< BonusStats_type, wchar_t > BonusStats_traits;

      const BonusStats_optional&
      BonusStats () const;

      BonusStats_optional&
      BonusStats ();

      void
      BonusStats (const BonusStats_type& x);

      void
      BonusStats (const BonusStats_optional& x);

      void
      BonusStats (::std::unique_ptr< BonusStats_type > p);

      // MaxStraightnessStats
      //
      typedef ::xsd::qif30::StatsLinearType MaxStraightnessStats_type;
      typedef ::xsd::cxx::tree::optional< MaxStraightnessStats_type > MaxStraightnessStats_optional;
      typedef ::xsd::cxx::tree::traits< MaxStraightnessStats_type, wchar_t > MaxStraightnessStats_traits;

      const MaxStraightnessStats_optional&
      MaxStraightnessStats () const;

      MaxStraightnessStats_optional&
      MaxStraightnessStats ();

      void
      MaxStraightnessStats (const MaxStraightnessStats_type& x);

      void
      MaxStraightnessStats (const MaxStraightnessStats_optional& x);

      void
      MaxStraightnessStats (::std::unique_ptr< MaxStraightnessStats_type > p);

      // Constructors.
      //
      StraightnessCharacteristicStatsEvalType ();

      StraightnessCharacteristicStatsEvalType (const Status_type&);

      StraightnessCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      StraightnessCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      StraightnessCharacteristicStatsEvalType (const StraightnessCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual StraightnessCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StraightnessCharacteristicStatsEvalType&
      operator= (const StraightnessCharacteristicStatsEvalType& x);

      virtual 
      ~StraightnessCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BonusStats_optional BonusStats_;
      MaxStraightnessStats_optional MaxStraightnessStats_;
    };

    class QIF30_SYMBOL_DECL ToroidicityCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      ToroidicityCharacteristicStatsEvalType ();

      ToroidicityCharacteristicStatsEvalType (const Status_type&);

      ToroidicityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      ToroidicityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ToroidicityCharacteristicStatsEvalType (const ToroidicityCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ToroidicityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ToroidicityCharacteristicStatsEvalType&
      operator= (const ToroidicityCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~ToroidicityCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL OtherFormCharacteristicStatsEvalType: public ::xsd::qif30::FormCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      OtherFormCharacteristicStatsEvalType ();

      OtherFormCharacteristicStatsEvalType (const Status_type&);

      OtherFormCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      OtherFormCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      OtherFormCharacteristicStatsEvalType (const OtherFormCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual OtherFormCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      OtherFormCharacteristicStatsEvalType&
      operator= (const OtherFormCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~OtherFormCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL LocationCharacteristicStatsEvalType: public ::xsd::qif30::GeometricCharacteristicStatsEvalType
    {
      public:
      // DatumsOkStats
      //
      typedef ::xsd::qif30::StatsPassFailType DatumsOkStats_type;
      typedef ::xsd::cxx::tree::optional< DatumsOkStats_type > DatumsOkStats_optional;
      typedef ::xsd::cxx::tree::traits< DatumsOkStats_type, wchar_t > DatumsOkStats_traits;

      const DatumsOkStats_optional&
      DatumsOkStats () const;

      DatumsOkStats_optional&
      DatumsOkStats ();

      void
      DatumsOkStats (const DatumsOkStats_type& x);

      void
      DatumsOkStats (const DatumsOkStats_optional& x);

      void
      DatumsOkStats (::std::unique_ptr< DatumsOkStats_type > p);

      // Constructors.
      //
      LocationCharacteristicStatsEvalType ();

      LocationCharacteristicStatsEvalType (const Status_type&);

      LocationCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      LocationCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      LocationCharacteristicStatsEvalType (const LocationCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual LocationCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocationCharacteristicStatsEvalType&
      operator= (const LocationCharacteristicStatsEvalType& x);

      virtual 
      ~LocationCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DatumsOkStats_optional DatumsOkStats_;
    };

    class QIF30_SYMBOL_DECL PositionCharacteristicStatsEvalType: public ::xsd::qif30::LocationCharacteristicStatsEvalType
    {
      public:
      // BonusStats
      //
      typedef ::xsd::qif30::StatsLinearType BonusStats_type;
      typedef ::xsd::cxx::tree::optional< BonusStats_type > BonusStats_optional;
      typedef ::xsd::cxx::tree::traits< BonusStats_type, wchar_t > BonusStats_traits;

      const BonusStats_optional&
      BonusStats () const;

      BonusStats_optional&
      BonusStats ();

      void
      BonusStats (const BonusStats_type& x);

      void
      BonusStats (const BonusStats_optional& x);

      void
      BonusStats (::std::unique_ptr< BonusStats_type > p);

      // CapabilityCalculationMethod
      //
      typedef ::xsd::qif30::PositionCapabilityCalculationEnumType CapabilityCalculationMethod_type;
      typedef ::xsd::cxx::tree::optional< CapabilityCalculationMethod_type > CapabilityCalculationMethod_optional;
      typedef ::xsd::cxx::tree::traits< CapabilityCalculationMethod_type, wchar_t > CapabilityCalculationMethod_traits;

      const CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod () const;

      CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod ();

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x);

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x);

      void
      CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > p);

      // CompositeSegmentsStats
      //
      typedef ::xsd::qif30::CompositeSegmentsPositionStatsEvalType CompositeSegmentsStats_type;
      typedef ::xsd::cxx::tree::optional< CompositeSegmentsStats_type > CompositeSegmentsStats_optional;
      typedef ::xsd::cxx::tree::traits< CompositeSegmentsStats_type, wchar_t > CompositeSegmentsStats_traits;

      const CompositeSegmentsStats_optional&
      CompositeSegmentsStats () const;

      CompositeSegmentsStats_optional&
      CompositeSegmentsStats ();

      void
      CompositeSegmentsStats (const CompositeSegmentsStats_type& x);

      void
      CompositeSegmentsStats (const CompositeSegmentsStats_optional& x);

      void
      CompositeSegmentsStats (::std::unique_ptr< CompositeSegmentsStats_type > p);

      // Constructors.
      //
      PositionCharacteristicStatsEvalType ();

      PositionCharacteristicStatsEvalType (const Status_type&);

      PositionCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      PositionCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      PositionCharacteristicStatsEvalType (const PositionCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual PositionCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PositionCharacteristicStatsEvalType&
      operator= (const PositionCharacteristicStatsEvalType& x);

      virtual 
      ~PositionCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      BonusStats_optional BonusStats_;
      CapabilityCalculationMethod_optional CapabilityCalculationMethod_;
      CompositeSegmentsStats_optional CompositeSegmentsStats_;
    };

    class QIF30_SYMBOL_DECL AngularCoordinateCharacteristicStatsEvalType: public ::xsd::qif30::AngularCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      AngularCoordinateCharacteristicStatsEvalType ();

      AngularCoordinateCharacteristicStatsEvalType (const Status_type&);

      AngularCoordinateCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      AngularCoordinateCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      AngularCoordinateCharacteristicStatsEvalType (const AngularCoordinateCharacteristicStatsEvalType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual AngularCoordinateCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngularCoordinateCharacteristicStatsEvalType&
      operator= (const AngularCoordinateCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~AngularCoordinateCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL AngleCharacteristicStatsEvalType: public ::xsd::qif30::AngularCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      AngleCharacteristicStatsEvalType ();

      AngleCharacteristicStatsEvalType (const Status_type&);

      AngleCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      AngleCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      AngleCharacteristicStatsEvalType (const AngleCharacteristicStatsEvalType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual AngleCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleCharacteristicStatsEvalType&
      operator= (const AngleCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~AngleCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL AngleFromCharacteristicStatsEvalType: public ::xsd::qif30::AngularCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      AngleFromCharacteristicStatsEvalType ();

      AngleFromCharacteristicStatsEvalType (const Status_type&);

      AngleFromCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      AngleFromCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      AngleFromCharacteristicStatsEvalType (const AngleFromCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual AngleFromCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleFromCharacteristicStatsEvalType&
      operator= (const AngleFromCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~AngleFromCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL AngleBetweenCharacteristicStatsEvalType: public ::xsd::qif30::AngularCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      AngleBetweenCharacteristicStatsEvalType ();

      AngleBetweenCharacteristicStatsEvalType (const Status_type&);

      AngleBetweenCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      AngleBetweenCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      AngleBetweenCharacteristicStatsEvalType (const AngleBetweenCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual AngleBetweenCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      AngleBetweenCharacteristicStatsEvalType&
      operator= (const AngleBetweenCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~AngleBetweenCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL LinearCoordinateCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      LinearCoordinateCharacteristicStatsEvalType ();

      LinearCoordinateCharacteristicStatsEvalType (const Status_type&);

      LinearCoordinateCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      LinearCoordinateCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      LinearCoordinateCharacteristicStatsEvalType (const LinearCoordinateCharacteristicStatsEvalType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual LinearCoordinateCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LinearCoordinateCharacteristicStatsEvalType&
      operator= (const LinearCoordinateCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~LinearCoordinateCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL CurveLengthCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      CurveLengthCharacteristicStatsEvalType ();

      CurveLengthCharacteristicStatsEvalType (const Status_type&);

      CurveLengthCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      CurveLengthCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      CurveLengthCharacteristicStatsEvalType (const CurveLengthCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual CurveLengthCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CurveLengthCharacteristicStatsEvalType&
      operator= (const CurveLengthCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~CurveLengthCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL DiameterCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      DiameterCharacteristicStatsEvalType ();

      DiameterCharacteristicStatsEvalType (const Status_type&);

      DiameterCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      DiameterCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      DiameterCharacteristicStatsEvalType (const DiameterCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual DiameterCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DiameterCharacteristicStatsEvalType&
      operator= (const DiameterCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~DiameterCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL SphericalDiameterCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      SphericalDiameterCharacteristicStatsEvalType ();

      SphericalDiameterCharacteristicStatsEvalType (const Status_type&);

      SphericalDiameterCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      SphericalDiameterCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      SphericalDiameterCharacteristicStatsEvalType (const SphericalDiameterCharacteristicStatsEvalType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual SphericalDiameterCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalDiameterCharacteristicStatsEvalType&
      operator= (const SphericalDiameterCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~SphericalDiameterCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL LengthCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      LengthCharacteristicStatsEvalType ();

      LengthCharacteristicStatsEvalType (const Status_type&);

      LengthCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      LengthCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LengthCharacteristicStatsEvalType (const LengthCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual LengthCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LengthCharacteristicStatsEvalType&
      operator= (const LengthCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~LengthCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WidthCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      WidthCharacteristicStatsEvalType ();

      WidthCharacteristicStatsEvalType (const Status_type&);

      WidthCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WidthCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      WidthCharacteristicStatsEvalType (const WidthCharacteristicStatsEvalType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual WidthCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WidthCharacteristicStatsEvalType&
      operator= (const WidthCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WidthCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL HeightCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      HeightCharacteristicStatsEvalType ();

      HeightCharacteristicStatsEvalType (const Status_type&);

      HeightCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      HeightCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      HeightCharacteristicStatsEvalType (const HeightCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual HeightCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      HeightCharacteristicStatsEvalType&
      operator= (const HeightCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~HeightCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL DepthCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      DepthCharacteristicStatsEvalType ();

      DepthCharacteristicStatsEvalType (const Status_type&);

      DepthCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      DepthCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      DepthCharacteristicStatsEvalType (const DepthCharacteristicStatsEvalType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual DepthCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DepthCharacteristicStatsEvalType&
      operator= (const DepthCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~DepthCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL ThicknessCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      ThicknessCharacteristicStatsEvalType ();

      ThicknessCharacteristicStatsEvalType (const Status_type&);

      ThicknessCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      ThicknessCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      ThicknessCharacteristicStatsEvalType (const ThicknessCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual ThicknessCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ThicknessCharacteristicStatsEvalType&
      operator= (const ThicknessCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~ThicknessCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL SquareCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      SquareCharacteristicStatsEvalType ();

      SquareCharacteristicStatsEvalType (const Status_type&);

      SquareCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      SquareCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      SquareCharacteristicStatsEvalType (const SquareCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual SquareCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SquareCharacteristicStatsEvalType&
      operator= (const SquareCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~SquareCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL DistanceFromCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      DistanceFromCharacteristicStatsEvalType ();

      DistanceFromCharacteristicStatsEvalType (const Status_type&);

      DistanceFromCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      DistanceFromCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      DistanceFromCharacteristicStatsEvalType (const DistanceFromCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual DistanceFromCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DistanceFromCharacteristicStatsEvalType&
      operator= (const DistanceFromCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~DistanceFromCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL DistanceBetweenCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      DistanceBetweenCharacteristicStatsEvalType ();

      DistanceBetweenCharacteristicStatsEvalType (const Status_type&);

      DistanceBetweenCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      DistanceBetweenCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      DistanceBetweenCharacteristicStatsEvalType (const DistanceBetweenCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual DistanceBetweenCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DistanceBetweenCharacteristicStatsEvalType&
      operator= (const DistanceBetweenCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~DistanceBetweenCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL RadiusCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      RadiusCharacteristicStatsEvalType ();

      RadiusCharacteristicStatsEvalType (const Status_type&);

      RadiusCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      RadiusCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      RadiusCharacteristicStatsEvalType (const RadiusCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual RadiusCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      RadiusCharacteristicStatsEvalType&
      operator= (const RadiusCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~RadiusCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL SphericalRadiusCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      SphericalRadiusCharacteristicStatsEvalType ();

      SphericalRadiusCharacteristicStatsEvalType (const Status_type&);

      SphericalRadiusCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      SphericalRadiusCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      SphericalRadiusCharacteristicStatsEvalType (const SphericalRadiusCharacteristicStatsEvalType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual SphericalRadiusCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SphericalRadiusCharacteristicStatsEvalType&
      operator= (const SphericalRadiusCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~SphericalRadiusCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL ChordCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      ChordCharacteristicStatsEvalType ();

      ChordCharacteristicStatsEvalType (const Status_type&);

      ChordCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      ChordCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      ChordCharacteristicStatsEvalType (const ChordCharacteristicStatsEvalType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual ChordCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ChordCharacteristicStatsEvalType&
      operator= (const ChordCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~ChordCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL ConicalTaperCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      ConicalTaperCharacteristicStatsEvalType ();

      ConicalTaperCharacteristicStatsEvalType (const Status_type&);

      ConicalTaperCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      ConicalTaperCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      ConicalTaperCharacteristicStatsEvalType (const ConicalTaperCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual ConicalTaperCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      ConicalTaperCharacteristicStatsEvalType&
      operator= (const ConicalTaperCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~ConicalTaperCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL FlatTaperCharacteristicStatsEvalType: public ::xsd::qif30::LinearCharacteristicStatsEvalType
    {
      public:
      // Constructors.
      //
      FlatTaperCharacteristicStatsEvalType ();

      FlatTaperCharacteristicStatsEvalType (const Status_type&);

      FlatTaperCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      FlatTaperCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      FlatTaperCharacteristicStatsEvalType (const FlatTaperCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual FlatTaperCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      FlatTaperCharacteristicStatsEvalType&
      operator= (const FlatTaperCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~FlatTaperCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL RunoutCharacteristicStatsEvalBaseType: public ::xsd::qif30::GeometricCharacteristicStatsEvalType
    {
      public:
      // CapabilityCalculationMethod
      //
      typedef ::xsd::qif30::OneSidedCapabilityCalculationEnumType CapabilityCalculationMethod_type;
      typedef ::xsd::cxx::tree::optional< CapabilityCalculationMethod_type > CapabilityCalculationMethod_optional;
      typedef ::xsd::cxx::tree::traits< CapabilityCalculationMethod_type, wchar_t > CapabilityCalculationMethod_traits;

      const CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod () const;

      CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod ();

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x);

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x);

      void
      CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > p);

      // DatumsOkStats
      //
      typedef ::xsd::qif30::StatsPassFailType DatumsOkStats_type;
      typedef ::xsd::cxx::tree::optional< DatumsOkStats_type > DatumsOkStats_optional;
      typedef ::xsd::cxx::tree::traits< DatumsOkStats_type, wchar_t > DatumsOkStats_traits;

      const DatumsOkStats_optional&
      DatumsOkStats () const;

      DatumsOkStats_optional&
      DatumsOkStats ();

      void
      DatumsOkStats (const DatumsOkStats_type& x);

      void
      DatumsOkStats (const DatumsOkStats_optional& x);

      void
      DatumsOkStats (::std::unique_ptr< DatumsOkStats_type > p);

      // Constructors.
      //
      RunoutCharacteristicStatsEvalBaseType ();

      RunoutCharacteristicStatsEvalBaseType (const Status_type&);

      RunoutCharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type >);

      RunoutCharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      RunoutCharacteristicStatsEvalBaseType (const RunoutCharacteristicStatsEvalBaseType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual RunoutCharacteristicStatsEvalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      RunoutCharacteristicStatsEvalBaseType&
      operator= (const RunoutCharacteristicStatsEvalBaseType& x);

      virtual 
      ~RunoutCharacteristicStatsEvalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CapabilityCalculationMethod_optional CapabilityCalculationMethod_;
      DatumsOkStats_optional DatumsOkStats_;
    };

    class QIF30_SYMBOL_DECL CircularRunoutCharacteristicStatsEvalType: public ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      CircularRunoutCharacteristicStatsEvalType ();

      CircularRunoutCharacteristicStatsEvalType (const Status_type&);

      CircularRunoutCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      CircularRunoutCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      CircularRunoutCharacteristicStatsEvalType (const CircularRunoutCharacteristicStatsEvalType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual CircularRunoutCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CircularRunoutCharacteristicStatsEvalType&
      operator= (const CircularRunoutCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~CircularRunoutCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL TotalRunoutCharacteristicStatsEvalType: public ::xsd::qif30::RunoutCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      TotalRunoutCharacteristicStatsEvalType ();

      TotalRunoutCharacteristicStatsEvalType (const Status_type&);

      TotalRunoutCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      TotalRunoutCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      TotalRunoutCharacteristicStatsEvalType (const TotalRunoutCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual TotalRunoutCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      TotalRunoutCharacteristicStatsEvalType&
      operator= (const TotalRunoutCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~TotalRunoutCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL CoaxialityCharacteristicStatsEvalType: public ::xsd::qif30::LocationCharacteristicStatsEvalType
    {
      public:
      // CapabilityCalculationMethod
      //
      typedef ::xsd::qif30::OneSidedCapabilityCalculationEnumType CapabilityCalculationMethod_type;
      typedef ::xsd::cxx::tree::optional< CapabilityCalculationMethod_type > CapabilityCalculationMethod_optional;
      typedef ::xsd::cxx::tree::traits< CapabilityCalculationMethod_type, wchar_t > CapabilityCalculationMethod_traits;

      const CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod () const;

      CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod ();

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x);

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x);

      void
      CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > p);

      // Constructors.
      //
      CoaxialityCharacteristicStatsEvalType ();

      CoaxialityCharacteristicStatsEvalType (const Status_type&);

      CoaxialityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      CoaxialityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      CoaxialityCharacteristicStatsEvalType (const CoaxialityCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual CoaxialityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoaxialityCharacteristicStatsEvalType&
      operator= (const CoaxialityCharacteristicStatsEvalType& x);

      virtual 
      ~CoaxialityCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CapabilityCalculationMethod_optional CapabilityCalculationMethod_;
    };

    class QIF30_SYMBOL_DECL ConcentricityCharacteristicStatsEvalType: public ::xsd::qif30::LocationCharacteristicStatsEvalType
    {
      public:
      // CapabilityCalculationMethod
      //
      typedef ::xsd::qif30::OneSidedCapabilityCalculationEnumType CapabilityCalculationMethod_type;
      typedef ::xsd::cxx::tree::optional< CapabilityCalculationMethod_type > CapabilityCalculationMethod_optional;
      typedef ::xsd::cxx::tree::traits< CapabilityCalculationMethod_type, wchar_t > CapabilityCalculationMethod_traits;

      const CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod () const;

      CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod ();

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x);

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x);

      void
      CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > p);

      // Constructors.
      //
      ConcentricityCharacteristicStatsEvalType ();

      ConcentricityCharacteristicStatsEvalType (const Status_type&);

      ConcentricityCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      ConcentricityCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ConcentricityCharacteristicStatsEvalType (const ConcentricityCharacteristicStatsEvalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ConcentricityCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConcentricityCharacteristicStatsEvalType&
      operator= (const ConcentricityCharacteristicStatsEvalType& x);

      virtual 
      ~ConcentricityCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CapabilityCalculationMethod_optional CapabilityCalculationMethod_;
    };

    class QIF30_SYMBOL_DECL SymmetryCharacteristicStatsEvalType: public ::xsd::qif30::LocationCharacteristicStatsEvalType
    {
      public:
      // CapabilityCalculationMethod
      //
      typedef ::xsd::qif30::OneSidedCapabilityCalculationEnumType CapabilityCalculationMethod_type;
      typedef ::xsd::cxx::tree::optional< CapabilityCalculationMethod_type > CapabilityCalculationMethod_optional;
      typedef ::xsd::cxx::tree::traits< CapabilityCalculationMethod_type, wchar_t > CapabilityCalculationMethod_traits;

      const CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod () const;

      CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod ();

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x);

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x);

      void
      CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > p);

      // CompositeSegmentsStats
      //
      typedef ::xsd::qif30::CompositeSegmentsSymmetryStatsEvalType CompositeSegmentsStats_type;
      typedef ::xsd::cxx::tree::optional< CompositeSegmentsStats_type > CompositeSegmentsStats_optional;
      typedef ::xsd::cxx::tree::traits< CompositeSegmentsStats_type, wchar_t > CompositeSegmentsStats_traits;

      const CompositeSegmentsStats_optional&
      CompositeSegmentsStats () const;

      CompositeSegmentsStats_optional&
      CompositeSegmentsStats ();

      void
      CompositeSegmentsStats (const CompositeSegmentsStats_type& x);

      void
      CompositeSegmentsStats (const CompositeSegmentsStats_optional& x);

      void
      CompositeSegmentsStats (::std::unique_ptr< CompositeSegmentsStats_type > p);

      // Constructors.
      //
      SymmetryCharacteristicStatsEvalType ();

      SymmetryCharacteristicStatsEvalType (const Status_type&);

      SymmetryCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      SymmetryCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      SymmetryCharacteristicStatsEvalType (const SymmetryCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual SymmetryCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SymmetryCharacteristicStatsEvalType&
      operator= (const SymmetryCharacteristicStatsEvalType& x);

      virtual 
      ~SymmetryCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CapabilityCalculationMethod_optional CapabilityCalculationMethod_;
      CompositeSegmentsStats_optional CompositeSegmentsStats_;
    };

    class QIF30_SYMBOL_DECL PointDeviationStatsEvalType: public ::xml_schema::type
    {
      public:
      // MeasuredPointIds
      //
      typedef ::xsd::qif30::StatsArrayIdType MeasuredPointIds_type;
      typedef ::xsd::cxx::tree::traits< MeasuredPointIds_type, wchar_t > MeasuredPointIds_traits;

      const MeasuredPointIds_type&
      MeasuredPointIds () const;

      MeasuredPointIds_type&
      MeasuredPointIds ();

      void
      MeasuredPointIds (const MeasuredPointIds_type& x);

      void
      MeasuredPointIds (::std::unique_ptr< MeasuredPointIds_type > p);

      // DeviationStats
      //
      typedef ::xsd::qif30::StatsLinearType DeviationStats_type;
      typedef ::xsd::cxx::tree::traits< DeviationStats_type, wchar_t > DeviationStats_traits;

      const DeviationStats_type&
      DeviationStats () const;

      DeviationStats_type&
      DeviationStats ();

      void
      DeviationStats (const DeviationStats_type& x);

      void
      DeviationStats (::std::unique_ptr< DeviationStats_type > p);

      // Constructors.
      //
      PointDeviationStatsEvalType ();

      PointDeviationStatsEvalType (const MeasuredPointIds_type&,
                                   const DeviationStats_type&);

      PointDeviationStatsEvalType (::std::unique_ptr< MeasuredPointIds_type >,
                                   ::std::unique_ptr< DeviationStats_type >);

      PointDeviationStatsEvalType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PointDeviationStatsEvalType (const PointDeviationStatsEvalType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PointDeviationStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDeviationStatsEvalType&
      operator= (const PointDeviationStatsEvalType& x);

      virtual 
      ~PointDeviationStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MeasuredPointIds_type > MeasuredPointIds_;
      ::xsd::cxx::tree::one< DeviationStats_type > DeviationStats_;
    };

    class QIF30_SYMBOL_DECL PointDeviationsStatsEvalType: public ::xml_schema::type
    {
      public:
      // PointDeviationStats
      //
      typedef ::xsd::qif30::PointDeviationStatsEvalType PointDeviationStats_type;
      typedef ::xsd::cxx::tree::sequence< PointDeviationStats_type > PointDeviationStats_sequence;
      typedef xsd::cxx::tree::sequence< PointDeviationStats_type >::iterator PointDeviationStats_iterator;
      typedef xsd::cxx::tree::sequence< PointDeviationStats_type >::const_iterator PointDeviationStats_const_iterator;
      typedef ::xsd::cxx::tree::traits< PointDeviationStats_type, wchar_t > PointDeviationStats_traits;

      const PointDeviationStats_sequence&
      PointDeviationStats () const;

      PointDeviationStats_sequence&
      PointDeviationStats ();

      void
      PointDeviationStats (const PointDeviationStats_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PointDeviationsStatsEvalType ();

      PointDeviationsStatsEvalType (const n_type&);

      PointDeviationsStatsEvalType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      PointDeviationsStatsEvalType (const PointDeviationsStatsEvalType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual PointDeviationsStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDeviationsStatsEvalType&
      operator= (const PointDeviationsStatsEvalType& x);

      virtual 
      ~PointDeviationsStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointDeviationStats_sequence PointDeviationStats_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ProfileCharacteristicStatsEvalBaseType: public ::xsd::qif30::GeometricCharacteristicStatsEvalType
    {
      public:
      // CapabilityCalculationMethod
      //
      typedef ::xsd::qif30::OneSidedCapabilityCalculationEnumType CapabilityCalculationMethod_type;
      typedef ::xsd::cxx::tree::optional< CapabilityCalculationMethod_type > CapabilityCalculationMethod_optional;
      typedef ::xsd::cxx::tree::traits< CapabilityCalculationMethod_type, wchar_t > CapabilityCalculationMethod_traits;

      const CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod () const;

      CapabilityCalculationMethod_optional&
      CapabilityCalculationMethod ();

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_type& x);

      void
      CapabilityCalculationMethod (const CapabilityCalculationMethod_optional& x);

      void
      CapabilityCalculationMethod (::std::unique_ptr< CapabilityCalculationMethod_type > p);

      // WorstPositiveDeviationStats
      //
      typedef ::xsd::qif30::StatsLinearType WorstPositiveDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< WorstPositiveDeviationStats_type > WorstPositiveDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< WorstPositiveDeviationStats_type, wchar_t > WorstPositiveDeviationStats_traits;

      const WorstPositiveDeviationStats_optional&
      WorstPositiveDeviationStats () const;

      WorstPositiveDeviationStats_optional&
      WorstPositiveDeviationStats ();

      void
      WorstPositiveDeviationStats (const WorstPositiveDeviationStats_type& x);

      void
      WorstPositiveDeviationStats (const WorstPositiveDeviationStats_optional& x);

      void
      WorstPositiveDeviationStats (::std::unique_ptr< WorstPositiveDeviationStats_type > p);

      // WorstNegativeDeviationStats
      //
      typedef ::xsd::qif30::StatsLinearType WorstNegativeDeviationStats_type;
      typedef ::xsd::cxx::tree::optional< WorstNegativeDeviationStats_type > WorstNegativeDeviationStats_optional;
      typedef ::xsd::cxx::tree::traits< WorstNegativeDeviationStats_type, wchar_t > WorstNegativeDeviationStats_traits;

      const WorstNegativeDeviationStats_optional&
      WorstNegativeDeviationStats () const;

      WorstNegativeDeviationStats_optional&
      WorstNegativeDeviationStats ();

      void
      WorstNegativeDeviationStats (const WorstNegativeDeviationStats_type& x);

      void
      WorstNegativeDeviationStats (const WorstNegativeDeviationStats_optional& x);

      void
      WorstNegativeDeviationStats (::std::unique_ptr< WorstNegativeDeviationStats_type > p);

      // PointDeviationsStats
      //
      typedef ::xsd::qif30::PointDeviationsStatsEvalType PointDeviationsStats_type;
      typedef ::xsd::cxx::tree::optional< PointDeviationsStats_type > PointDeviationsStats_optional;
      typedef ::xsd::cxx::tree::traits< PointDeviationsStats_type, wchar_t > PointDeviationsStats_traits;

      const PointDeviationsStats_optional&
      PointDeviationsStats () const;

      PointDeviationsStats_optional&
      PointDeviationsStats ();

      void
      PointDeviationsStats (const PointDeviationsStats_type& x);

      void
      PointDeviationsStats (const PointDeviationsStats_optional& x);

      void
      PointDeviationsStats (::std::unique_ptr< PointDeviationsStats_type > p);

      // DatumsOkStats
      //
      typedef ::xsd::qif30::StatsPassFailType DatumsOkStats_type;
      typedef ::xsd::cxx::tree::optional< DatumsOkStats_type > DatumsOkStats_optional;
      typedef ::xsd::cxx::tree::traits< DatumsOkStats_type, wchar_t > DatumsOkStats_traits;

      const DatumsOkStats_optional&
      DatumsOkStats () const;

      DatumsOkStats_optional&
      DatumsOkStats ();

      void
      DatumsOkStats (const DatumsOkStats_type& x);

      void
      DatumsOkStats (const DatumsOkStats_optional& x);

      void
      DatumsOkStats (::std::unique_ptr< DatumsOkStats_type > p);

      // CompositeSegmentsStats
      //
      typedef ::xsd::qif30::CompositeSegmentsProfileStatsEvalType CompositeSegmentsStats_type;
      typedef ::xsd::cxx::tree::optional< CompositeSegmentsStats_type > CompositeSegmentsStats_optional;
      typedef ::xsd::cxx::tree::traits< CompositeSegmentsStats_type, wchar_t > CompositeSegmentsStats_traits;

      const CompositeSegmentsStats_optional&
      CompositeSegmentsStats () const;

      CompositeSegmentsStats_optional&
      CompositeSegmentsStats ();

      void
      CompositeSegmentsStats (const CompositeSegmentsStats_type& x);

      void
      CompositeSegmentsStats (const CompositeSegmentsStats_optional& x);

      void
      CompositeSegmentsStats (::std::unique_ptr< CompositeSegmentsStats_type > p);

      // Constructors.
      //
      ProfileCharacteristicStatsEvalBaseType ();

      ProfileCharacteristicStatsEvalBaseType (const Status_type&);

      ProfileCharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type >);

      ProfileCharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      ProfileCharacteristicStatsEvalBaseType (const ProfileCharacteristicStatsEvalBaseType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual ProfileCharacteristicStatsEvalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ProfileCharacteristicStatsEvalBaseType&
      operator= (const ProfileCharacteristicStatsEvalBaseType& x);

      virtual 
      ~ProfileCharacteristicStatsEvalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CapabilityCalculationMethod_optional CapabilityCalculationMethod_;
      WorstPositiveDeviationStats_optional WorstPositiveDeviationStats_;
      WorstNegativeDeviationStats_optional WorstNegativeDeviationStats_;
      PointDeviationsStats_optional PointDeviationsStats_;
      DatumsOkStats_optional DatumsOkStats_;
      CompositeSegmentsStats_optional CompositeSegmentsStats_;
    };

    class QIF30_SYMBOL_DECL LineProfileCharacteristicStatsEvalType: public ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      LineProfileCharacteristicStatsEvalType ();

      LineProfileCharacteristicStatsEvalType (const Status_type&);

      LineProfileCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      LineProfileCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      LineProfileCharacteristicStatsEvalType (const LineProfileCharacteristicStatsEvalType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual LineProfileCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      LineProfileCharacteristicStatsEvalType&
      operator= (const LineProfileCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~LineProfileCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL PointProfileCharacteristicStatsEvalType: public ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      PointProfileCharacteristicStatsEvalType ();

      PointProfileCharacteristicStatsEvalType (const Status_type&);

      PointProfileCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      PointProfileCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      PointProfileCharacteristicStatsEvalType (const PointProfileCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual PointProfileCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointProfileCharacteristicStatsEvalType&
      operator= (const PointProfileCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~PointProfileCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL SurfaceProfileCharacteristicStatsEvalType: public ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      SurfaceProfileCharacteristicStatsEvalType ();

      SurfaceProfileCharacteristicStatsEvalType (const Status_type&);

      SurfaceProfileCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      SurfaceProfileCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SurfaceProfileCharacteristicStatsEvalType (const SurfaceProfileCharacteristicStatsEvalType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual SurfaceProfileCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceProfileCharacteristicStatsEvalType&
      operator= (const SurfaceProfileCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~SurfaceProfileCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL SurfaceProfileNonUniformCharacteristicStatsEvalType: public ::xsd::qif30::ProfileCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      SurfaceProfileNonUniformCharacteristicStatsEvalType ();

      SurfaceProfileNonUniformCharacteristicStatsEvalType (const Status_type&);

      SurfaceProfileNonUniformCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      SurfaceProfileNonUniformCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

      SurfaceProfileNonUniformCharacteristicStatsEvalType (const SurfaceProfileNonUniformCharacteristicStatsEvalType& x,
                                                           ::xml_schema::flags f = 0,
                                                           ::xml_schema::container* c = 0);

      virtual SurfaceProfileNonUniformCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      SurfaceProfileNonUniformCharacteristicStatsEvalType&
      operator= (const SurfaceProfileNonUniformCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~SurfaceProfileNonUniformCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL ThreadCharacteristicStatsEvalType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // ThreadStats
      //
      typedef ::xsd::qif30::StatsPassFailType ThreadStats_type;
      typedef ::xsd::cxx::tree::optional< ThreadStats_type > ThreadStats_optional;
      typedef ::xsd::cxx::tree::traits< ThreadStats_type, wchar_t > ThreadStats_traits;

      const ThreadStats_optional&
      ThreadStats () const;

      ThreadStats_optional&
      ThreadStats ();

      void
      ThreadStats (const ThreadStats_type& x);

      void
      ThreadStats (const ThreadStats_optional& x);

      void
      ThreadStats (::std::unique_ptr< ThreadStats_type > p);

      // PitchDiameterStats
      //
      typedef ::xsd::qif30::StatsLinearType PitchDiameterStats_type;
      typedef ::xsd::cxx::tree::optional< PitchDiameterStats_type > PitchDiameterStats_optional;
      typedef ::xsd::cxx::tree::traits< PitchDiameterStats_type, wchar_t > PitchDiameterStats_traits;

      const PitchDiameterStats_optional&
      PitchDiameterStats () const;

      PitchDiameterStats_optional&
      PitchDiameterStats ();

      void
      PitchDiameterStats (const PitchDiameterStats_type& x);

      void
      PitchDiameterStats (const PitchDiameterStats_optional& x);

      void
      PitchDiameterStats (::std::unique_ptr< PitchDiameterStats_type > p);

      // FunctionalSizeStats
      //
      typedef ::xsd::qif30::StatsLinearType FunctionalSizeStats_type;
      typedef ::xsd::cxx::tree::optional< FunctionalSizeStats_type > FunctionalSizeStats_optional;
      typedef ::xsd::cxx::tree::traits< FunctionalSizeStats_type, wchar_t > FunctionalSizeStats_traits;

      const FunctionalSizeStats_optional&
      FunctionalSizeStats () const;

      FunctionalSizeStats_optional&
      FunctionalSizeStats ();

      void
      FunctionalSizeStats (const FunctionalSizeStats_type& x);

      void
      FunctionalSizeStats (const FunctionalSizeStats_optional& x);

      void
      FunctionalSizeStats (::std::unique_ptr< FunctionalSizeStats_type > p);

      // Constructors.
      //
      ThreadCharacteristicStatsEvalType ();

      ThreadCharacteristicStatsEvalType (const Status_type&);

      ThreadCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      ThreadCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ThreadCharacteristicStatsEvalType (const ThreadCharacteristicStatsEvalType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ThreadCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadCharacteristicStatsEvalType&
      operator= (const ThreadCharacteristicStatsEvalType& x);

      virtual 
      ~ThreadCharacteristicStatsEvalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThreadStats_optional ThreadStats_;
      PitchDiameterStats_optional PitchDiameterStats_;
      FunctionalSizeStats_optional FunctionalSizeStats_;
    };

    class QIF30_SYMBOL_DECL WeldCharacteristicStatsEvalBaseType: public ::xsd::qif30::CharacteristicStatsEvalBaseType
    {
      public:
      // WeldStats
      //
      typedef ::xsd::qif30::StatsPassFailType WeldStats_type;
      typedef ::xsd::cxx::tree::optional< WeldStats_type > WeldStats_optional;
      typedef ::xsd::cxx::tree::traits< WeldStats_type, wchar_t > WeldStats_traits;

      const WeldStats_optional&
      WeldStats () const;

      WeldStats_optional&
      WeldStats ();

      void
      WeldStats (const WeldStats_type& x);

      void
      WeldStats (const WeldStats_optional& x);

      void
      WeldStats (::std::unique_ptr< WeldStats_type > p);

      // Constructors.
      //
      WeldCharacteristicStatsEvalBaseType ();

      WeldCharacteristicStatsEvalBaseType (const Status_type&);

      WeldCharacteristicStatsEvalBaseType (::std::unique_ptr< Status_type >);

      WeldCharacteristicStatsEvalBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldCharacteristicStatsEvalBaseType (const WeldCharacteristicStatsEvalBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldCharacteristicStatsEvalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      WeldCharacteristicStatsEvalBaseType&
      operator= (const WeldCharacteristicStatsEvalBaseType& x);

      virtual 
      ~WeldCharacteristicStatsEvalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      WeldStats_optional WeldStats_;
    };

    class QIF30_SYMBOL_DECL WeldFilletCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldFilletCharacteristicStatsEvalType ();

      WeldFilletCharacteristicStatsEvalType (const Status_type&);

      WeldFilletCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldFilletCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldFilletCharacteristicStatsEvalType (const WeldFilletCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldFilletCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFilletCharacteristicStatsEvalType&
      operator= (const WeldFilletCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldFilletCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldPlugCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldPlugCharacteristicStatsEvalType ();

      WeldPlugCharacteristicStatsEvalType (const Status_type&);

      WeldPlugCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldPlugCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldPlugCharacteristicStatsEvalType (const WeldPlugCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldPlugCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldPlugCharacteristicStatsEvalType&
      operator= (const WeldPlugCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldPlugCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldSlotCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldSlotCharacteristicStatsEvalType ();

      WeldSlotCharacteristicStatsEvalType (const Status_type&);

      WeldSlotCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldSlotCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldSlotCharacteristicStatsEvalType (const WeldSlotCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldSlotCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSlotCharacteristicStatsEvalType&
      operator= (const WeldSlotCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldSlotCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldSpotCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldSpotCharacteristicStatsEvalType ();

      WeldSpotCharacteristicStatsEvalType (const Status_type&);

      WeldSpotCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldSpotCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldSpotCharacteristicStatsEvalType (const WeldSpotCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldSpotCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSpotCharacteristicStatsEvalType&
      operator= (const WeldSpotCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldSpotCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldStudCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldStudCharacteristicStatsEvalType ();

      WeldStudCharacteristicStatsEvalType (const Status_type&);

      WeldStudCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldStudCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldStudCharacteristicStatsEvalType (const WeldStudCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldStudCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldStudCharacteristicStatsEvalType&
      operator= (const WeldStudCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldStudCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldSeamCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldSeamCharacteristicStatsEvalType ();

      WeldSeamCharacteristicStatsEvalType (const Status_type&);

      WeldSeamCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldSeamCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldSeamCharacteristicStatsEvalType (const WeldSeamCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldSeamCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSeamCharacteristicStatsEvalType&
      operator= (const WeldSeamCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldSeamCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldSurfacingCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldSurfacingCharacteristicStatsEvalType ();

      WeldSurfacingCharacteristicStatsEvalType (const Status_type&);

      WeldSurfacingCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldSurfacingCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      WeldSurfacingCharacteristicStatsEvalType (const WeldSurfacingCharacteristicStatsEvalType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual WeldSurfacingCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSurfacingCharacteristicStatsEvalType&
      operator= (const WeldSurfacingCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldSurfacingCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldEdgeCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldEdgeCharacteristicStatsEvalType ();

      WeldEdgeCharacteristicStatsEvalType (const Status_type&);

      WeldEdgeCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldEdgeCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      WeldEdgeCharacteristicStatsEvalType (const WeldEdgeCharacteristicStatsEvalType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual WeldEdgeCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldEdgeCharacteristicStatsEvalType&
      operator= (const WeldEdgeCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldEdgeCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldSquareCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldSquareCharacteristicStatsEvalType ();

      WeldSquareCharacteristicStatsEvalType (const Status_type&);

      WeldSquareCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldSquareCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldSquareCharacteristicStatsEvalType (const WeldSquareCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldSquareCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldSquareCharacteristicStatsEvalType&
      operator= (const WeldSquareCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldSquareCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldBevelCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldBevelCharacteristicStatsEvalType ();

      WeldBevelCharacteristicStatsEvalType (const Status_type&);

      WeldBevelCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldBevelCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldBevelCharacteristicStatsEvalType (const WeldBevelCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldBevelCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldBevelCharacteristicStatsEvalType&
      operator= (const WeldBevelCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldBevelCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldVCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldVCharacteristicStatsEvalType ();

      WeldVCharacteristicStatsEvalType (const Status_type&);

      WeldVCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldVCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      WeldVCharacteristicStatsEvalType (const WeldVCharacteristicStatsEvalType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual WeldVCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldVCharacteristicStatsEvalType&
      operator= (const WeldVCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldVCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldUCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldUCharacteristicStatsEvalType ();

      WeldUCharacteristicStatsEvalType (const Status_type&);

      WeldUCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldUCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      WeldUCharacteristicStatsEvalType (const WeldUCharacteristicStatsEvalType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual WeldUCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldUCharacteristicStatsEvalType&
      operator= (const WeldUCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldUCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldJCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldJCharacteristicStatsEvalType ();

      WeldJCharacteristicStatsEvalType (const Status_type&);

      WeldJCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldJCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      WeldJCharacteristicStatsEvalType (const WeldJCharacteristicStatsEvalType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual WeldJCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldJCharacteristicStatsEvalType&
      operator= (const WeldJCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldJCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareVCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldFlareVCharacteristicStatsEvalType ();

      WeldFlareVCharacteristicStatsEvalType (const Status_type&);

      WeldFlareVCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldFlareVCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      WeldFlareVCharacteristicStatsEvalType (const WeldFlareVCharacteristicStatsEvalType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual WeldFlareVCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareVCharacteristicStatsEvalType&
      operator= (const WeldFlareVCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldFlareVCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldFlareBevelCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldFlareBevelCharacteristicStatsEvalType ();

      WeldFlareBevelCharacteristicStatsEvalType (const Status_type&);

      WeldFlareBevelCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldFlareBevelCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      WeldFlareBevelCharacteristicStatsEvalType (const WeldFlareBevelCharacteristicStatsEvalType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual WeldFlareBevelCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldFlareBevelCharacteristicStatsEvalType&
      operator= (const WeldFlareBevelCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldFlareBevelCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldScarfCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldScarfCharacteristicStatsEvalType ();

      WeldScarfCharacteristicStatsEvalType (const Status_type&);

      WeldScarfCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldScarfCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      WeldScarfCharacteristicStatsEvalType (const WeldScarfCharacteristicStatsEvalType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual WeldScarfCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldScarfCharacteristicStatsEvalType&
      operator= (const WeldScarfCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldScarfCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL WeldCompoundCharacteristicStatsEvalType: public ::xsd::qif30::WeldCharacteristicStatsEvalBaseType
    {
      public:
      // Constructors.
      //
      WeldCompoundCharacteristicStatsEvalType ();

      WeldCompoundCharacteristicStatsEvalType (const Status_type&);

      WeldCompoundCharacteristicStatsEvalType (::std::unique_ptr< Status_type >);

      WeldCompoundCharacteristicStatsEvalType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      WeldCompoundCharacteristicStatsEvalType (const WeldCompoundCharacteristicStatsEvalType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual WeldCompoundCharacteristicStatsEvalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      WeldCompoundCharacteristicStatsEvalType&
      operator= (const WeldCompoundCharacteristicStatsEvalType&) = default;
#endif

      virtual 
      ~WeldCompoundCharacteristicStatsEvalType ();
    };

    class QIF30_SYMBOL_DECL CharacteristicsStatsType: public ::xml_schema::type
    {
      public:
      // CharacteristicStats
      //
      typedef ::xsd::qif30::CharacteristicStatsEvalBaseType CharacteristicStats_type;
      typedef ::xsd::cxx::tree::sequence< CharacteristicStats_type > CharacteristicStats_sequence;
      typedef xsd::cxx::tree::sequence< CharacteristicStats_type >::iterator CharacteristicStats_iterator;
      typedef xsd::cxx::tree::sequence< CharacteristicStats_type >::const_iterator CharacteristicStats_const_iterator;
      typedef ::xsd::cxx::tree::traits< CharacteristicStats_type, wchar_t > CharacteristicStats_traits;

      const CharacteristicStats_sequence&
      CharacteristicStats () const;

      CharacteristicStats_sequence&
      CharacteristicStats ();

      void
      CharacteristicStats (const CharacteristicStats_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CharacteristicsStatsType ();

      CharacteristicsStatsType (const n_type&);

      CharacteristicsStatsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CharacteristicsStatsType (const CharacteristicsStatsType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CharacteristicsStatsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CharacteristicsStatsType&
      operator= (const CharacteristicsStatsType& x);

      virtual 
      ~CharacteristicsStatsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CharacteristicStats_sequence CharacteristicStats_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AverageFeatureType: public ::xml_schema::type
    {
      public:
      // FeatureMeasurement
      //
      typedef ::xsd::qif30::FeatureMeasurementBaseType FeatureMeasurement_type;
      typedef ::xsd::cxx::tree::traits< FeatureMeasurement_type, wchar_t > FeatureMeasurement_traits;

      const FeatureMeasurement_type&
      FeatureMeasurement () const;

      FeatureMeasurement_type&
      FeatureMeasurement ();

      void
      FeatureMeasurement (const FeatureMeasurement_type& x);

      void
      FeatureMeasurement (::std::unique_ptr< FeatureMeasurement_type > p);

      // MeasuredIds
      //
      typedef ::xsd::qif30::StatsArrayIdType MeasuredIds_type;
      typedef ::xsd::cxx::tree::traits< MeasuredIds_type, wchar_t > MeasuredIds_traits;

      const MeasuredIds_type&
      MeasuredIds () const;

      MeasuredIds_type&
      MeasuredIds ();

      void
      MeasuredIds (const MeasuredIds_type& x);

      void
      MeasuredIds (::std::unique_ptr< MeasuredIds_type > p);

      // Constructors.
      //
      AverageFeatureType ();

      AverageFeatureType (const FeatureMeasurement_type&,
                          const MeasuredIds_type&);

      AverageFeatureType (::std::unique_ptr< FeatureMeasurement_type >,
                          ::std::unique_ptr< MeasuredIds_type >);

      AverageFeatureType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      AverageFeatureType (const AverageFeatureType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual AverageFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AverageFeatureType&
      operator= (const AverageFeatureType& x);

      virtual 
      ~AverageFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureMeasurement_type > FeatureMeasurement_;
      ::xsd::cxx::tree::one< MeasuredIds_type > MeasuredIds_;
    };

    class QIF30_SYMBOL_DECL AverageFeaturesType: public ::xml_schema::type
    {
      public:
      // AverageFeature
      //
      typedef ::xsd::qif30::AverageFeatureType AverageFeature_type;
      typedef ::xsd::cxx::tree::sequence< AverageFeature_type > AverageFeature_sequence;
      typedef xsd::cxx::tree::sequence< AverageFeature_type >::iterator AverageFeature_iterator;
      typedef xsd::cxx::tree::sequence< AverageFeature_type >::const_iterator AverageFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< AverageFeature_type, wchar_t > AverageFeature_traits;

      const AverageFeature_sequence&
      AverageFeature () const;

      AverageFeature_sequence&
      AverageFeature ();

      void
      AverageFeature (const AverageFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AverageFeaturesType ();

      AverageFeaturesType (const n_type&);

      AverageFeaturesType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      AverageFeaturesType (const AverageFeaturesType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual AverageFeaturesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AverageFeaturesType&
      operator= (const AverageFeaturesType& x);

      virtual 
      ~AverageFeaturesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AverageFeature_sequence AverageFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // TypeOfSummary
      //
      typedef ::xsd::qif30::StatsValuesEnumType TypeOfSummary_type;
      typedef ::xsd::cxx::tree::traits< TypeOfSummary_type, wchar_t > TypeOfSummary_traits;

      const TypeOfSummary_type&
      TypeOfSummary () const;

      TypeOfSummary_type&
      TypeOfSummary ();

      void
      TypeOfSummary (const TypeOfSummary_type& x);

      void
      TypeOfSummary (::std::unique_ptr< TypeOfSummary_type > p);

      // SummaryStatsValue
      //
      typedef ::xsd::qif30::StatsWithReferenceBaseType SummaryStatsValue_type;
      typedef ::xsd::cxx::tree::sequence< SummaryStatsValue_type > SummaryStatsValue_sequence;
      typedef xsd::cxx::tree::sequence< SummaryStatsValue_type >::iterator SummaryStatsValue_iterator;
      typedef xsd::cxx::tree::sequence< SummaryStatsValue_type >::const_iterator SummaryStatsValue_const_iterator;
      typedef ::xsd::cxx::tree::traits< SummaryStatsValue_type, wchar_t > SummaryStatsValue_traits;

      const SummaryStatsValue_sequence&
      SummaryStatsValue () const;

      SummaryStatsValue_sequence&
      SummaryStatsValue ();

      void
      SummaryStatsValue (const SummaryStatsValue_sequence& s);

      // Constructors.
      //
      SummaryStatisticsType ();

      SummaryStatisticsType (const TypeOfSummary_type&);

      SummaryStatisticsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      SummaryStatisticsType (const SummaryStatisticsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual SummaryStatisticsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsType&
      operator= (const SummaryStatisticsType& x);

      virtual 
      ~SummaryStatisticsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< TypeOfSummary_type > TypeOfSummary_;
      SummaryStatsValue_sequence SummaryStatsValue_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsType: public ::xml_schema::type
    {
      public:
      // StatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsType StatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< StatsSummary_type > StatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< StatsSummary_type >::iterator StatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< StatsSummary_type >::const_iterator StatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< StatsSummary_type, wchar_t > StatsSummary_traits;

      const StatsSummary_sequence&
      StatsSummary () const;

      StatsSummary_sequence&
      StatsSummary ();

      void
      StatsSummary (const StatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsType ();

      SummariesStatisticsType (const n_type&);

      SummariesStatisticsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SummariesStatisticsType (const SummariesStatisticsType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual SummariesStatisticsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsType&
      operator= (const SummariesStatisticsType& x);

      virtual 
      ~SummariesStatisticsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StatsSummary_sequence StatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsLinearType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, wchar_t > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::unique_ptr< linearUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsLinearType ();

      SummaryStatisticsLinearType (const TypeOfSummary_type&);

      SummaryStatisticsLinearType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SummaryStatisticsLinearType (const SummaryStatisticsLinearType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SummaryStatisticsLinearType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsLinearType&
      operator= (const SummaryStatisticsLinearType& x);

      virtual 
      ~SummaryStatisticsLinearType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsLinearType: public ::xml_schema::type
    {
      public:
      // LinearStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsLinearType LinearStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< LinearStatsSummary_type > LinearStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< LinearStatsSummary_type >::iterator LinearStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< LinearStatsSummary_type >::const_iterator LinearStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< LinearStatsSummary_type, wchar_t > LinearStatsSummary_traits;

      const LinearStatsSummary_sequence&
      LinearStatsSummary () const;

      LinearStatsSummary_sequence&
      LinearStatsSummary ();

      void
      LinearStatsSummary (const LinearStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsLinearType ();

      SummariesStatisticsLinearType (const n_type&);

      SummariesStatisticsLinearType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      SummariesStatisticsLinearType (const SummariesStatisticsLinearType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual SummariesStatisticsLinearType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsLinearType&
      operator= (const SummariesStatisticsLinearType& x);

      virtual 
      ~SummariesStatisticsLinearType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearStatsSummary_sequence LinearStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsAngularType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, wchar_t > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::unique_ptr< angularUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsAngularType ();

      SummaryStatisticsAngularType (const TypeOfSummary_type&);

      SummaryStatisticsAngularType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SummaryStatisticsAngularType (const SummaryStatisticsAngularType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SummaryStatisticsAngularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsAngularType&
      operator= (const SummaryStatisticsAngularType& x);

      virtual 
      ~SummaryStatisticsAngularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsAngularType: public ::xml_schema::type
    {
      public:
      // AngularStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsAngularType AngularStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< AngularStatsSummary_type > AngularStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< AngularStatsSummary_type >::iterator AngularStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< AngularStatsSummary_type >::const_iterator AngularStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< AngularStatsSummary_type, wchar_t > AngularStatsSummary_traits;

      const AngularStatsSummary_sequence&
      AngularStatsSummary () const;

      AngularStatsSummary_sequence&
      AngularStatsSummary ();

      void
      AngularStatsSummary (const AngularStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsAngularType ();

      SummariesStatisticsAngularType (const n_type&);

      SummariesStatisticsAngularType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      SummariesStatisticsAngularType (const SummariesStatisticsAngularType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual SummariesStatisticsAngularType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsAngularType&
      operator= (const SummariesStatisticsAngularType& x);

      virtual 
      ~SummariesStatisticsAngularType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AngularStatsSummary_sequence AngularStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsAreaType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // areaUnit
      //
      typedef ::xml_schema::token areaUnit_type;
      typedef ::xsd::cxx::tree::optional< areaUnit_type > areaUnit_optional;
      typedef ::xsd::cxx::tree::traits< areaUnit_type, wchar_t > areaUnit_traits;

      const areaUnit_optional&
      areaUnit () const;

      areaUnit_optional&
      areaUnit ();

      void
      areaUnit (const areaUnit_type& x);

      void
      areaUnit (const areaUnit_optional& x);

      void
      areaUnit (::std::unique_ptr< areaUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsAreaType ();

      SummaryStatisticsAreaType (const TypeOfSummary_type&);

      SummaryStatisticsAreaType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      SummaryStatisticsAreaType (const SummaryStatisticsAreaType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual SummaryStatisticsAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsAreaType&
      operator= (const SummaryStatisticsAreaType& x);

      virtual 
      ~SummaryStatisticsAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      areaUnit_optional areaUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsAreaType: public ::xml_schema::type
    {
      public:
      // AreaStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsAreaType AreaStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< AreaStatsSummary_type > AreaStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< AreaStatsSummary_type >::iterator AreaStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< AreaStatsSummary_type >::const_iterator AreaStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< AreaStatsSummary_type, wchar_t > AreaStatsSummary_traits;

      const AreaStatsSummary_sequence&
      AreaStatsSummary () const;

      AreaStatsSummary_sequence&
      AreaStatsSummary ();

      void
      AreaStatsSummary (const AreaStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsAreaType ();

      SummariesStatisticsAreaType (const n_type&);

      SummariesStatisticsAreaType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SummariesStatisticsAreaType (const SummariesStatisticsAreaType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SummariesStatisticsAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsAreaType&
      operator= (const SummariesStatisticsAreaType& x);

      virtual 
      ~SummariesStatisticsAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AreaStatsSummary_sequence AreaStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsForceType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // forceUnit
      //
      typedef ::xml_schema::token forceUnit_type;
      typedef ::xsd::cxx::tree::optional< forceUnit_type > forceUnit_optional;
      typedef ::xsd::cxx::tree::traits< forceUnit_type, wchar_t > forceUnit_traits;

      const forceUnit_optional&
      forceUnit () const;

      forceUnit_optional&
      forceUnit ();

      void
      forceUnit (const forceUnit_type& x);

      void
      forceUnit (const forceUnit_optional& x);

      void
      forceUnit (::std::unique_ptr< forceUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsForceType ();

      SummaryStatisticsForceType (const TypeOfSummary_type&);

      SummaryStatisticsForceType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      SummaryStatisticsForceType (const SummaryStatisticsForceType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual SummaryStatisticsForceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsForceType&
      operator= (const SummaryStatisticsForceType& x);

      virtual 
      ~SummaryStatisticsForceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      forceUnit_optional forceUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsForceType: public ::xml_schema::type
    {
      public:
      // ForceStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsForceType ForceStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< ForceStatsSummary_type > ForceStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< ForceStatsSummary_type >::iterator ForceStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< ForceStatsSummary_type >::const_iterator ForceStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< ForceStatsSummary_type, wchar_t > ForceStatsSummary_traits;

      const ForceStatsSummary_sequence&
      ForceStatsSummary () const;

      ForceStatsSummary_sequence&
      ForceStatsSummary ();

      void
      ForceStatsSummary (const ForceStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsForceType ();

      SummariesStatisticsForceType (const n_type&);

      SummariesStatisticsForceType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SummariesStatisticsForceType (const SummariesStatisticsForceType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SummariesStatisticsForceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsForceType&
      operator= (const SummariesStatisticsForceType& x);

      virtual 
      ~SummariesStatisticsForceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ForceStatsSummary_sequence ForceStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsMassType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // massUnit
      //
      typedef ::xml_schema::token massUnit_type;
      typedef ::xsd::cxx::tree::optional< massUnit_type > massUnit_optional;
      typedef ::xsd::cxx::tree::traits< massUnit_type, wchar_t > massUnit_traits;

      const massUnit_optional&
      massUnit () const;

      massUnit_optional&
      massUnit ();

      void
      massUnit (const massUnit_type& x);

      void
      massUnit (const massUnit_optional& x);

      void
      massUnit (::std::unique_ptr< massUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsMassType ();

      SummaryStatisticsMassType (const TypeOfSummary_type&);

      SummaryStatisticsMassType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      SummaryStatisticsMassType (const SummaryStatisticsMassType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual SummaryStatisticsMassType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsMassType&
      operator= (const SummaryStatisticsMassType& x);

      virtual 
      ~SummaryStatisticsMassType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      massUnit_optional massUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsMassType: public ::xml_schema::type
    {
      public:
      // MassStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsMassType MassStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< MassStatsSummary_type > MassStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< MassStatsSummary_type >::iterator MassStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< MassStatsSummary_type >::const_iterator MassStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< MassStatsSummary_type, wchar_t > MassStatsSummary_traits;

      const MassStatsSummary_sequence&
      MassStatsSummary () const;

      MassStatsSummary_sequence&
      MassStatsSummary ();

      void
      MassStatsSummary (const MassStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsMassType ();

      SummariesStatisticsMassType (const n_type&);

      SummariesStatisticsMassType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SummariesStatisticsMassType (const SummariesStatisticsMassType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SummariesStatisticsMassType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsMassType&
      operator= (const SummariesStatisticsMassType& x);

      virtual 
      ~SummariesStatisticsMassType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MassStatsSummary_sequence MassStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsPressureType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // pressureUnit
      //
      typedef ::xml_schema::token pressureUnit_type;
      typedef ::xsd::cxx::tree::optional< pressureUnit_type > pressureUnit_optional;
      typedef ::xsd::cxx::tree::traits< pressureUnit_type, wchar_t > pressureUnit_traits;

      const pressureUnit_optional&
      pressureUnit () const;

      pressureUnit_optional&
      pressureUnit ();

      void
      pressureUnit (const pressureUnit_type& x);

      void
      pressureUnit (const pressureUnit_optional& x);

      void
      pressureUnit (::std::unique_ptr< pressureUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsPressureType ();

      SummaryStatisticsPressureType (const TypeOfSummary_type&);

      SummaryStatisticsPressureType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      SummaryStatisticsPressureType (const SummaryStatisticsPressureType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual SummaryStatisticsPressureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsPressureType&
      operator= (const SummaryStatisticsPressureType& x);

      virtual 
      ~SummaryStatisticsPressureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      pressureUnit_optional pressureUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsPressureType: public ::xml_schema::type
    {
      public:
      // PressureStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsPressureType PressureStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< PressureStatsSummary_type > PressureStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< PressureStatsSummary_type >::iterator PressureStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< PressureStatsSummary_type >::const_iterator PressureStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< PressureStatsSummary_type, wchar_t > PressureStatsSummary_traits;

      const PressureStatsSummary_sequence&
      PressureStatsSummary () const;

      PressureStatsSummary_sequence&
      PressureStatsSummary ();

      void
      PressureStatsSummary (const PressureStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsPressureType ();

      SummariesStatisticsPressureType (const n_type&);

      SummariesStatisticsPressureType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SummariesStatisticsPressureType (const SummariesStatisticsPressureType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SummariesStatisticsPressureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsPressureType&
      operator= (const SummariesStatisticsPressureType& x);

      virtual 
      ~SummariesStatisticsPressureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PressureStatsSummary_sequence PressureStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsSpeedType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // speedUnit
      //
      typedef ::xml_schema::token speedUnit_type;
      typedef ::xsd::cxx::tree::optional< speedUnit_type > speedUnit_optional;
      typedef ::xsd::cxx::tree::traits< speedUnit_type, wchar_t > speedUnit_traits;

      const speedUnit_optional&
      speedUnit () const;

      speedUnit_optional&
      speedUnit ();

      void
      speedUnit (const speedUnit_type& x);

      void
      speedUnit (const speedUnit_optional& x);

      void
      speedUnit (::std::unique_ptr< speedUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsSpeedType ();

      SummaryStatisticsSpeedType (const TypeOfSummary_type&);

      SummaryStatisticsSpeedType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      SummaryStatisticsSpeedType (const SummaryStatisticsSpeedType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual SummaryStatisticsSpeedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsSpeedType&
      operator= (const SummaryStatisticsSpeedType& x);

      virtual 
      ~SummaryStatisticsSpeedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      speedUnit_optional speedUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsSpeedType: public ::xml_schema::type
    {
      public:
      // SpeedStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsSpeedType SpeedStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< SpeedStatsSummary_type > SpeedStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< SpeedStatsSummary_type >::iterator SpeedStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< SpeedStatsSummary_type >::const_iterator SpeedStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< SpeedStatsSummary_type, wchar_t > SpeedStatsSummary_traits;

      const SpeedStatsSummary_sequence&
      SpeedStatsSummary () const;

      SpeedStatsSummary_sequence&
      SpeedStatsSummary ();

      void
      SpeedStatsSummary (const SpeedStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsSpeedType ();

      SummariesStatisticsSpeedType (const n_type&);

      SummariesStatisticsSpeedType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SummariesStatisticsSpeedType (const SummariesStatisticsSpeedType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual SummariesStatisticsSpeedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsSpeedType&
      operator= (const SummariesStatisticsSpeedType& x);

      virtual 
      ~SummariesStatisticsSpeedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SpeedStatsSummary_sequence SpeedStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsTemperatureType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // temperatureUnit
      //
      typedef ::xml_schema::token temperatureUnit_type;
      typedef ::xsd::cxx::tree::optional< temperatureUnit_type > temperatureUnit_optional;
      typedef ::xsd::cxx::tree::traits< temperatureUnit_type, wchar_t > temperatureUnit_traits;

      const temperatureUnit_optional&
      temperatureUnit () const;

      temperatureUnit_optional&
      temperatureUnit ();

      void
      temperatureUnit (const temperatureUnit_type& x);

      void
      temperatureUnit (const temperatureUnit_optional& x);

      void
      temperatureUnit (::std::unique_ptr< temperatureUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsTemperatureType ();

      SummaryStatisticsTemperatureType (const TypeOfSummary_type&);

      SummaryStatisticsTemperatureType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      SummaryStatisticsTemperatureType (const SummaryStatisticsTemperatureType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual SummaryStatisticsTemperatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsTemperatureType&
      operator= (const SummaryStatisticsTemperatureType& x);

      virtual 
      ~SummaryStatisticsTemperatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      temperatureUnit_optional temperatureUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsTemperatureType: public ::xml_schema::type
    {
      public:
      // TemperatureStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsTemperatureType TemperatureStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< TemperatureStatsSummary_type > TemperatureStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< TemperatureStatsSummary_type >::iterator TemperatureStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< TemperatureStatsSummary_type >::const_iterator TemperatureStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< TemperatureStatsSummary_type, wchar_t > TemperatureStatsSummary_traits;

      const TemperatureStatsSummary_sequence&
      TemperatureStatsSummary () const;

      TemperatureStatsSummary_sequence&
      TemperatureStatsSummary ();

      void
      TemperatureStatsSummary (const TemperatureStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsTemperatureType ();

      SummariesStatisticsTemperatureType (const n_type&);

      SummariesStatisticsTemperatureType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SummariesStatisticsTemperatureType (const SummariesStatisticsTemperatureType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SummariesStatisticsTemperatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsTemperatureType&
      operator= (const SummariesStatisticsTemperatureType& x);

      virtual 
      ~SummariesStatisticsTemperatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TemperatureStatsSummary_sequence TemperatureStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsTimeType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // timeUnit
      //
      typedef ::xml_schema::token timeUnit_type;
      typedef ::xsd::cxx::tree::optional< timeUnit_type > timeUnit_optional;
      typedef ::xsd::cxx::tree::traits< timeUnit_type, wchar_t > timeUnit_traits;

      const timeUnit_optional&
      timeUnit () const;

      timeUnit_optional&
      timeUnit ();

      void
      timeUnit (const timeUnit_type& x);

      void
      timeUnit (const timeUnit_optional& x);

      void
      timeUnit (::std::unique_ptr< timeUnit_type > p);

      // Constructors.
      //
      SummaryStatisticsTimeType ();

      SummaryStatisticsTimeType (const TypeOfSummary_type&);

      SummaryStatisticsTimeType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      SummaryStatisticsTimeType (const SummaryStatisticsTimeType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual SummaryStatisticsTimeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsTimeType&
      operator= (const SummaryStatisticsTimeType& x);

      virtual 
      ~SummaryStatisticsTimeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      timeUnit_optional timeUnit_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsTimeType: public ::xml_schema::type
    {
      public:
      // TimeStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsTimeType TimeStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< TimeStatsSummary_type > TimeStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< TimeStatsSummary_type >::iterator TimeStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< TimeStatsSummary_type >::const_iterator TimeStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< TimeStatsSummary_type, wchar_t > TimeStatsSummary_traits;

      const TimeStatsSummary_sequence&
      TimeStatsSummary () const;

      TimeStatsSummary_sequence&
      TimeStatsSummary ();

      void
      TimeStatsSummary (const TimeStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsTimeType ();

      SummariesStatisticsTimeType (const n_type&);

      SummariesStatisticsTimeType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      SummariesStatisticsTimeType (const SummariesStatisticsTimeType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual SummariesStatisticsTimeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsTimeType&
      operator= (const SummariesStatisticsTimeType& x);

      virtual 
      ~SummariesStatisticsTimeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TimeStatsSummary_sequence TimeStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SummaryStatisticsUserDefinedUnitType: public ::xsd::qif30::SummaryStatisticsType
    {
      public:
      // unitName
      //
      typedef ::xml_schema::token unitName_type;
      typedef ::xsd::cxx::tree::traits< unitName_type, wchar_t > unitName_traits;

      const unitName_type&
      unitName () const;

      unitName_type&
      unitName ();

      void
      unitName (const unitName_type& x);

      void
      unitName (::std::unique_ptr< unitName_type > p);

      // Constructors.
      //
      SummaryStatisticsUserDefinedUnitType ();

      SummaryStatisticsUserDefinedUnitType (const TypeOfSummary_type&,
                                            const unitName_type&);

      SummaryStatisticsUserDefinedUnitType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      SummaryStatisticsUserDefinedUnitType (const SummaryStatisticsUserDefinedUnitType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual SummaryStatisticsUserDefinedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummaryStatisticsUserDefinedUnitType&
      operator= (const SummaryStatisticsUserDefinedUnitType& x);

      virtual 
      ~SummaryStatisticsUserDefinedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unitName_type > unitName_;
    };

    class QIF30_SYMBOL_DECL SummariesStatisticsUserDefinedUnitType: public ::xml_schema::type
    {
      public:
      // UserDefinedUnitStatsSummary
      //
      typedef ::xsd::qif30::SummaryStatisticsUserDefinedUnitType UserDefinedUnitStatsSummary_type;
      typedef ::xsd::cxx::tree::sequence< UserDefinedUnitStatsSummary_type > UserDefinedUnitStatsSummary_sequence;
      typedef xsd::cxx::tree::sequence< UserDefinedUnitStatsSummary_type >::iterator UserDefinedUnitStatsSummary_iterator;
      typedef xsd::cxx::tree::sequence< UserDefinedUnitStatsSummary_type >::const_iterator UserDefinedUnitStatsSummary_const_iterator;
      typedef ::xsd::cxx::tree::traits< UserDefinedUnitStatsSummary_type, wchar_t > UserDefinedUnitStatsSummary_traits;

      const UserDefinedUnitStatsSummary_sequence&
      UserDefinedUnitStatsSummary () const;

      UserDefinedUnitStatsSummary_sequence&
      UserDefinedUnitStatsSummary ();

      void
      UserDefinedUnitStatsSummary (const UserDefinedUnitStatsSummary_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SummariesStatisticsUserDefinedUnitType ();

      SummariesStatisticsUserDefinedUnitType (const n_type&);

      SummariesStatisticsUserDefinedUnitType (const xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      SummariesStatisticsUserDefinedUnitType (const SummariesStatisticsUserDefinedUnitType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual SummariesStatisticsUserDefinedUnitType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SummariesStatisticsUserDefinedUnitType&
      operator= (const SummariesStatisticsUserDefinedUnitType& x);

      virtual 
      ~SummariesStatisticsUserDefinedUnitType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      UserDefinedUnitStatsSummary_sequence UserDefinedUnitStatsSummary_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AssignableCauseEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        POWER_FAILURE,
        BROKEN_TOOL,
        COMPUTER_CRASH,
        WEATHER_EVENT,
        OTHER
      };

      AssignableCauseEnumType ();

      AssignableCauseEnumType (value v);

      AssignableCauseEnumType (const wchar_t* v);

      AssignableCauseEnumType (const ::std::wstring& v);

      AssignableCauseEnumType (const ::xml_schema::nmtoken& v);

      AssignableCauseEnumType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      AssignableCauseEnumType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      AssignableCauseEnumType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      AssignableCauseEnumType (const AssignableCauseEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      AssignableCauseEnumType&
      operator= (const AssignableCauseEnumType&) = default;
#endif

      virtual AssignableCauseEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AssignableCauseEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AssignableCauseEnumType_convert ();
      }

      protected:
      value
      _xsd_AssignableCauseEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_AssignableCauseEnumType_literals_[5];
      static const value _xsd_AssignableCauseEnumType_indexes_[5];
    };

    class QIF30_SYMBOL_DECL AssignableCauseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // AssignableCauseEnum
      //
      typedef ::xsd::qif30::AssignableCauseEnumType AssignableCauseEnum_type;
      typedef ::xsd::cxx::tree::optional< AssignableCauseEnum_type > AssignableCauseEnum_optional;
      typedef ::xsd::cxx::tree::traits< AssignableCauseEnum_type, wchar_t > AssignableCauseEnum_traits;

      const AssignableCauseEnum_optional&
      AssignableCauseEnum () const;

      AssignableCauseEnum_optional&
      AssignableCauseEnum ();

      void
      AssignableCauseEnum (const AssignableCauseEnum_type& x);

      void
      AssignableCauseEnum (const AssignableCauseEnum_optional& x);

      void
      AssignableCauseEnum (::std::unique_ptr< AssignableCauseEnum_type > p);

      // CorrectiveActionIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CorrectiveActionIds_type;
      typedef ::xsd::cxx::tree::optional< CorrectiveActionIds_type > CorrectiveActionIds_optional;
      typedef ::xsd::cxx::tree::traits< CorrectiveActionIds_type, wchar_t > CorrectiveActionIds_traits;

      const CorrectiveActionIds_optional&
      CorrectiveActionIds () const;

      CorrectiveActionIds_optional&
      CorrectiveActionIds ();

      void
      CorrectiveActionIds (const CorrectiveActionIds_type& x);

      void
      CorrectiveActionIds (const CorrectiveActionIds_optional& x);

      void
      CorrectiveActionIds (::std::unique_ptr< CorrectiveActionIds_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      AssignableCauseType ();

      AssignableCauseType (const id_type&);

      AssignableCauseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      AssignableCauseType (const AssignableCauseType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual AssignableCauseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AssignableCauseType&
      operator= (const AssignableCauseType& x);

      virtual 
      ~AssignableCauseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Description_optional Description_;
      AssignableCauseEnum_optional AssignableCauseEnum_;
      CorrectiveActionIds_optional CorrectiveActionIds_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL AssignableCausesType: public ::xml_schema::type
    {
      public:
      // AssignableCause
      //
      typedef ::xsd::qif30::AssignableCauseType AssignableCause_type;
      typedef ::xsd::cxx::tree::sequence< AssignableCause_type > AssignableCause_sequence;
      typedef xsd::cxx::tree::sequence< AssignableCause_type >::iterator AssignableCause_iterator;
      typedef xsd::cxx::tree::sequence< AssignableCause_type >::const_iterator AssignableCause_const_iterator;
      typedef ::xsd::cxx::tree::traits< AssignableCause_type, wchar_t > AssignableCause_traits;

      const AssignableCause_sequence&
      AssignableCause () const;

      AssignableCause_sequence&
      AssignableCause ();

      void
      AssignableCause (const AssignableCause_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AssignableCausesType ();

      AssignableCausesType (const n_type&);

      AssignableCausesType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      AssignableCausesType (const AssignableCausesType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual AssignableCausesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AssignableCausesType&
      operator= (const AssignableCausesType& x);

      virtual 
      ~AssignableCausesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AssignableCause_sequence AssignableCause_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ActionToTakeEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        HALT_PRODUCTION,
        CONTAINMENT,
        NEW_MATERIAL_BATCH,
        NEW_TOOLING,
        INSPECT_100PC,
        REBOOT,
        RECALIBRATE,
        OTHER
      };

      ActionToTakeEnumType ();

      ActionToTakeEnumType (value v);

      ActionToTakeEnumType (const wchar_t* v);

      ActionToTakeEnumType (const ::std::wstring& v);

      ActionToTakeEnumType (const ::xml_schema::nmtoken& v);

      ActionToTakeEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ActionToTakeEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ActionToTakeEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ActionToTakeEnumType (const ActionToTakeEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ActionToTakeEnumType&
      operator= (const ActionToTakeEnumType&) = default;
#endif

      virtual ActionToTakeEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActionToTakeEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ActionToTakeEnumType_convert ();
      }

      protected:
      value
      _xsd_ActionToTakeEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ActionToTakeEnumType_literals_[8];
      static const value _xsd_ActionToTakeEnumType_indexes_[8];
    };

    class QIF30_SYMBOL_DECL CorrectiveActionType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // ActionToTake
      //
      typedef ::xml_schema::string ActionToTake_type;
      typedef ::xsd::cxx::tree::optional< ActionToTake_type > ActionToTake_optional;
      typedef ::xsd::cxx::tree::traits< ActionToTake_type, wchar_t > ActionToTake_traits;

      const ActionToTake_optional&
      ActionToTake () const;

      ActionToTake_optional&
      ActionToTake ();

      void
      ActionToTake (const ActionToTake_type& x);

      void
      ActionToTake (const ActionToTake_optional& x);

      void
      ActionToTake (::std::unique_ptr< ActionToTake_type > p);

      // ActionToTakeEnum
      //
      typedef ::xsd::qif30::ActionToTakeEnumType ActionToTakeEnum_type;
      typedef ::xsd::cxx::tree::optional< ActionToTakeEnum_type > ActionToTakeEnum_optional;
      typedef ::xsd::cxx::tree::traits< ActionToTakeEnum_type, wchar_t > ActionToTakeEnum_traits;

      const ActionToTakeEnum_optional&
      ActionToTakeEnum () const;

      ActionToTakeEnum_optional&
      ActionToTakeEnum ();

      void
      ActionToTakeEnum (const ActionToTakeEnum_type& x);

      void
      ActionToTakeEnum (const ActionToTakeEnum_optional& x);

      void
      ActionToTakeEnum (::std::unique_ptr< ActionToTakeEnum_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      CorrectiveActionType ();

      CorrectiveActionType (const id_type&);

      CorrectiveActionType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CorrectiveActionType (const CorrectiveActionType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CorrectiveActionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CorrectiveActionType&
      operator= (const CorrectiveActionType& x);

      virtual 
      ~CorrectiveActionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ActionToTake_optional ActionToTake_;
      ActionToTakeEnum_optional ActionToTakeEnum_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL CorrectiveActionsType: public ::xml_schema::type
    {
      public:
      // CorrectiveAction
      //
      typedef ::xsd::qif30::CorrectiveActionType CorrectiveAction_type;
      typedef ::xsd::cxx::tree::sequence< CorrectiveAction_type > CorrectiveAction_sequence;
      typedef xsd::cxx::tree::sequence< CorrectiveAction_type >::iterator CorrectiveAction_iterator;
      typedef xsd::cxx::tree::sequence< CorrectiveAction_type >::const_iterator CorrectiveAction_const_iterator;
      typedef ::xsd::cxx::tree::traits< CorrectiveAction_type, wchar_t > CorrectiveAction_traits;

      const CorrectiveAction_sequence&
      CorrectiveAction () const;

      CorrectiveAction_sequence&
      CorrectiveAction ();

      void
      CorrectiveAction (const CorrectiveAction_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CorrectiveActionsType ();

      CorrectiveActionsType (const n_type&);

      CorrectiveActionsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CorrectiveActionsType (const CorrectiveActionsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CorrectiveActionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CorrectiveActionsType&
      operator= (const CorrectiveActionsType& x);

      virtual 
      ~CorrectiveActionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CorrectiveAction_sequence CorrectiveAction_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL StudyIssueType: public ::xml_schema::type
    {
      public:
      // Traceability
      //
      typedef ::xsd::qif30::InspectionTraceabilityType Traceability_type;
      typedef ::xsd::cxx::tree::optional< Traceability_type > Traceability_optional;
      typedef ::xsd::cxx::tree::traits< Traceability_type, wchar_t > Traceability_traits;

      const Traceability_optional&
      Traceability () const;

      Traceability_optional&
      Traceability ();

      void
      Traceability (const Traceability_type& x);

      void
      Traceability (const Traceability_optional& x);

      void
      Traceability (::std::unique_ptr< Traceability_type > p);

      // AssignableCauseIds
      //
      typedef ::xsd::qif30::ArrayReferenceType AssignableCauseIds_type;
      typedef ::xsd::cxx::tree::optional< AssignableCauseIds_type > AssignableCauseIds_optional;
      typedef ::xsd::cxx::tree::traits< AssignableCauseIds_type, wchar_t > AssignableCauseIds_traits;

      const AssignableCauseIds_optional&
      AssignableCauseIds () const;

      AssignableCauseIds_optional&
      AssignableCauseIds ();

      void
      AssignableCauseIds (const AssignableCauseIds_type& x);

      void
      AssignableCauseIds (const AssignableCauseIds_optional& x);

      void
      AssignableCauseIds (::std::unique_ptr< AssignableCauseIds_type > p);

      // CorrectiveActionIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CorrectiveActionIds_type;
      typedef ::xsd::cxx::tree::optional< CorrectiveActionIds_type > CorrectiveActionIds_optional;
      typedef ::xsd::cxx::tree::traits< CorrectiveActionIds_type, wchar_t > CorrectiveActionIds_traits;

      const CorrectiveActionIds_optional&
      CorrectiveActionIds () const;

      CorrectiveActionIds_optional&
      CorrectiveActionIds ();

      void
      CorrectiveActionIds (const CorrectiveActionIds_type& x);

      void
      CorrectiveActionIds (const CorrectiveActionIds_optional& x);

      void
      CorrectiveActionIds (::std::unique_ptr< CorrectiveActionIds_type > p);

      // Resolution
      //
      typedef ::xml_schema::string Resolution_type;
      typedef ::xsd::cxx::tree::optional< Resolution_type > Resolution_optional;
      typedef ::xsd::cxx::tree::traits< Resolution_type, wchar_t > Resolution_traits;

      const Resolution_optional&
      Resolution () const;

      Resolution_optional&
      Resolution ();

      void
      Resolution (const Resolution_type& x);

      void
      Resolution (const Resolution_optional& x);

      void
      Resolution (::std::unique_ptr< Resolution_type > p);

      // CharacteristicMeasurementIds
      //
      typedef ::xsd::qif30::ArrayReferenceType CharacteristicMeasurementIds_type;
      typedef ::xsd::cxx::tree::optional< CharacteristicMeasurementIds_type > CharacteristicMeasurementIds_optional;
      typedef ::xsd::cxx::tree::traits< CharacteristicMeasurementIds_type, wchar_t > CharacteristicMeasurementIds_traits;

      const CharacteristicMeasurementIds_optional&
      CharacteristicMeasurementIds () const;

      CharacteristicMeasurementIds_optional&
      CharacteristicMeasurementIds ();

      void
      CharacteristicMeasurementIds (const CharacteristicMeasurementIds_type& x);

      void
      CharacteristicMeasurementIds (const CharacteristicMeasurementIds_optional& x);

      void
      CharacteristicMeasurementIds (::std::unique_ptr< CharacteristicMeasurementIds_type > p);

      // SubgroupIds
      //
      typedef ::xsd::qif30::ArrayReferenceType SubgroupIds_type;
      typedef ::xsd::cxx::tree::optional< SubgroupIds_type > SubgroupIds_optional;
      typedef ::xsd::cxx::tree::traits< SubgroupIds_type, wchar_t > SubgroupIds_traits;

      const SubgroupIds_optional&
      SubgroupIds () const;

      SubgroupIds_optional&
      SubgroupIds ();

      void
      SubgroupIds (const SubgroupIds_type& x);

      void
      SubgroupIds (const SubgroupIds_optional& x);

      void
      SubgroupIds (::std::unique_ptr< SubgroupIds_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      StudyIssueType ();

      StudyIssueType (const id_type&);

      StudyIssueType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      StudyIssueType (const StudyIssueType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual StudyIssueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StudyIssueType&
      operator= (const StudyIssueType& x);

      virtual 
      ~StudyIssueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Traceability_optional Traceability_;
      AssignableCauseIds_optional AssignableCauseIds_;
      CorrectiveActionIds_optional CorrectiveActionIds_;
      Resolution_optional Resolution_;
      CharacteristicMeasurementIds_optional CharacteristicMeasurementIds_;
      SubgroupIds_optional SubgroupIds_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL ControlIssueEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        OOT,
        CP,
        CPK,
        PP,
        PPK,
        OOC,
        TRENDING,
        SKEWED,
        ONETHIRDGROUPED,
        TWOTHIRDGROUPED,
        OSCILLATING,
        STRATIFIED,
        OOCRNG,
        UNDEFINED
      };

      ControlIssueEnumType ();

      ControlIssueEnumType (value v);

      ControlIssueEnumType (const wchar_t* v);

      ControlIssueEnumType (const ::std::wstring& v);

      ControlIssueEnumType (const ::xml_schema::nmtoken& v);

      ControlIssueEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ControlIssueEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ControlIssueEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ControlIssueEnumType (const ControlIssueEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ControlIssueEnumType&
      operator= (const ControlIssueEnumType&) = default;
#endif

      virtual ControlIssueEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ControlIssueEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ControlIssueEnumType_convert ();
      }

      protected:
      value
      _xsd_ControlIssueEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ControlIssueEnumType_literals_[14];
      static const value _xsd_ControlIssueEnumType_indexes_[14];
    };

    class QIF30_SYMBOL_DECL ControlIssueType: public ::xml_schema::type
    {
      public:
      // ControlIssueEnum
      //
      typedef ::xsd::qif30::ControlIssueEnumType ControlIssueEnum_type;
      typedef ::xsd::cxx::tree::optional< ControlIssueEnum_type > ControlIssueEnum_optional;
      typedef ::xsd::cxx::tree::traits< ControlIssueEnum_type, wchar_t > ControlIssueEnum_traits;

      const ControlIssueEnum_optional&
      ControlIssueEnum () const;

      ControlIssueEnum_optional&
      ControlIssueEnum ();

      void
      ControlIssueEnum (const ControlIssueEnum_type& x);

      void
      ControlIssueEnum (const ControlIssueEnum_optional& x);

      void
      ControlIssueEnum (::std::unique_ptr< ControlIssueEnum_type > p);

      // OtherControlIssue
      //
      typedef ::xml_schema::string OtherControlIssue_type;
      typedef ::xsd::cxx::tree::optional< OtherControlIssue_type > OtherControlIssue_optional;
      typedef ::xsd::cxx::tree::traits< OtherControlIssue_type, wchar_t > OtherControlIssue_traits;

      const OtherControlIssue_optional&
      OtherControlIssue () const;

      OtherControlIssue_optional&
      OtherControlIssue ();

      void
      OtherControlIssue (const OtherControlIssue_type& x);

      void
      OtherControlIssue (const OtherControlIssue_optional& x);

      void
      OtherControlIssue (::std::unique_ptr< OtherControlIssue_type > p);

      // Constructors.
      //
      ControlIssueType ();

      ControlIssueType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ControlIssueType (const ControlIssueType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ControlIssueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ControlIssueType&
      operator= (const ControlIssueType& x);

      virtual 
      ~ControlIssueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ControlIssueEnum_optional ControlIssueEnum_;
      OtherControlIssue_optional OtherControlIssue_;
    };

    class QIF30_SYMBOL_DECL ControlIssueDetailsType: public ::xml_schema::type
    {
      public:
      // ControlIssue
      //
      typedef ::xsd::qif30::ControlIssueType ControlIssue_type;
      typedef ::xsd::cxx::tree::traits< ControlIssue_type, wchar_t > ControlIssue_traits;

      const ControlIssue_type&
      ControlIssue () const;

      ControlIssue_type&
      ControlIssue ();

      void
      ControlIssue (const ControlIssue_type& x);

      void
      ControlIssue (::std::unique_ptr< ControlIssue_type > p);

      // ControlMethodId
      //
      typedef ::xsd::qif30::QIFReferenceType ControlMethodId_type;
      typedef ::xsd::cxx::tree::optional< ControlMethodId_type > ControlMethodId_optional;
      typedef ::xsd::cxx::tree::traits< ControlMethodId_type, wchar_t > ControlMethodId_traits;

      const ControlMethodId_optional&
      ControlMethodId () const;

      ControlMethodId_optional&
      ControlMethodId ();

      void
      ControlMethodId (const ControlMethodId_type& x);

      void
      ControlMethodId (const ControlMethodId_optional& x);

      void
      ControlMethodId (::std::unique_ptr< ControlMethodId_type > p);

      // StudyIssueId
      //
      typedef ::xsd::qif30::QIFReferenceType StudyIssueId_type;
      typedef ::xsd::cxx::tree::optional< StudyIssueId_type > StudyIssueId_optional;
      typedef ::xsd::cxx::tree::traits< StudyIssueId_type, wchar_t > StudyIssueId_traits;

      const StudyIssueId_optional&
      StudyIssueId () const;

      StudyIssueId_optional&
      StudyIssueId ();

      void
      StudyIssueId (const StudyIssueId_type& x);

      void
      StudyIssueId (const StudyIssueId_optional& x);

      void
      StudyIssueId (::std::unique_ptr< StudyIssueId_type > p);

      // Constructors.
      //
      ControlIssueDetailsType ();

      ControlIssueDetailsType (const ControlIssue_type&);

      ControlIssueDetailsType (::std::unique_ptr< ControlIssue_type >);

      ControlIssueDetailsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ControlIssueDetailsType (const ControlIssueDetailsType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ControlIssueDetailsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ControlIssueDetailsType&
      operator= (const ControlIssueDetailsType& x);

      virtual 
      ~ControlIssueDetailsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ControlIssue_type > ControlIssue_;
      ControlMethodId_optional ControlMethodId_;
      StudyIssueId_optional StudyIssueId_;
    };

    class QIF30_SYMBOL_DECL ControlIssueDetailsListType: public ::xml_schema::type
    {
      public:
      // ControlIssueDetails
      //
      typedef ::xsd::qif30::ControlIssueDetailsType ControlIssueDetails_type;
      typedef ::xsd::cxx::tree::sequence< ControlIssueDetails_type > ControlIssueDetails_sequence;
      typedef xsd::cxx::tree::sequence< ControlIssueDetails_type >::iterator ControlIssueDetails_iterator;
      typedef xsd::cxx::tree::sequence< ControlIssueDetails_type >::const_iterator ControlIssueDetails_const_iterator;
      typedef ::xsd::cxx::tree::traits< ControlIssueDetails_type, wchar_t > ControlIssueDetails_traits;

      const ControlIssueDetails_sequence&
      ControlIssueDetails () const;

      ControlIssueDetails_sequence&
      ControlIssueDetails ();

      void
      ControlIssueDetails (const ControlIssueDetails_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ControlIssueDetailsListType ();

      ControlIssueDetailsListType (const n_type&);

      ControlIssueDetailsListType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ControlIssueDetailsListType (const ControlIssueDetailsListType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ControlIssueDetailsListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ControlIssueDetailsListType&
      operator= (const ControlIssueDetailsListType& x);

      virtual 
      ~ControlIssueDetailsListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ControlIssueDetails_sequence ControlIssueDetails_;
      ::xsd::cxx::tree::one< n_type > n_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LimitingNumberType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionDecimalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionLinearType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionAngularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionForceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionMassType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionPressureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionSpeedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionTemperatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionUserDefinedUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionIntegerType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CriterionOutOfType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SamplingMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SamplingIntervalEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SamplingIntervalEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SamplingIntervalEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SamplingIntervalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExclusionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ExclusionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ExclusionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExclusionReasonType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExclusionIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExclusionIndexType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExclusionsIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExclusionsIndexType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsArrayIdType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsValuesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsEvalStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const StatsEvalStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const StatsEvalStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsEvalStatusType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StudyIssuesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OneSidedCapabilityCalculationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const OneSidedCapabilityCalculationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const OneSidedCapabilityCalculationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionCapabilityCalculationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PositionCapabilityCalculationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PositionCapabilityCalculationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistributionTransformationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DistributionTransformationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DistributionTransformationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistributionTransformationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SubgroupType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SubgroupsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SubgroupValuesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicStatsEvalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsNumericalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolNumericalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolLinearType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolAngularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolForceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolMassType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolPressureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolSpeedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolTemperatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsWithTolUserDefinedUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsLinearType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsAngularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsForceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsMassType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsPressureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsSpeedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsTemperatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsUserDefinedUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StatsPassFailType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GeometricCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentStatsEvalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentPositionStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentsPositionStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentProfileStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentsProfileStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentSymmetryStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompositeSegmentsSymmetryStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAttributeCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedLinearCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAngularCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedAreaCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedForceCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedMassCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedPressureCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedSpeedCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTemperatureCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedTimeCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const UserDefinedUnitCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceTextureCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PerpendicularityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ParallelismCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FormCharacteristicStatsEvalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CylindricityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EllipticityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatnessCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StraightnessCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToroidicityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OtherFormCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PositionCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCoordinateCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleFromCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleBetweenCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCoordinateCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveLengthCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DiameterCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalDiameterCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LengthCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WidthCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HeightCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DepthCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThicknessCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SquareCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceFromCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceBetweenCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RadiusCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SphericalRadiusCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ChordCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConicalTaperCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FlatTaperCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RunoutCharacteristicStatsEvalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CircularRunoutCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TotalRunoutCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoaxialityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ConcentricityCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SymmetryCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDeviationStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointDeviationsStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ProfileCharacteristicStatsEvalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LineProfileCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointProfileCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceProfileNonUniformCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCharacteristicStatsEvalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFilletCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldPlugCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSlotCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSpotCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldStudCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSeamCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSurfacingCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldEdgeCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldSquareCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldBevelCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldVCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldUCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldJCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareVCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldFlareBevelCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldScarfCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const WeldCompoundCharacteristicStatsEvalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CharacteristicsStatsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AverageFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AverageFeaturesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsLinearType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsLinearType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsAngularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsAngularType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsForceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsForceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsMassType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsMassType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsPressureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsPressureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsSpeedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsSpeedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsTemperatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsTemperatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsTimeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummaryStatisticsUserDefinedUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SummariesStatisticsUserDefinedUnitType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AssignableCauseEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const AssignableCauseEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const AssignableCauseEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AssignableCauseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AssignableCausesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ActionToTakeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ActionToTakeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ActionToTakeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CorrectiveActionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CorrectiveActionsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StudyIssueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ControlIssueEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ControlIssueEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ControlIssueEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ControlIssueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ControlIssueDetailsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ControlIssueDetailsListType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_STATISTICS_HXX
