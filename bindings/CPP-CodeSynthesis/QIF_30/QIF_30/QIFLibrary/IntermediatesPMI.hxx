// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_INTERMEDIATES_PMI_HXX
#define CXX___QIFLIBRARY_INTERMEDIATES_PMI_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class SequencedDatumType;
    class CompoundDatumType;
    class DatumWithPrecedenceType;
    class DatumType;
    class DatumTranslationType;
    class DatumFeatureBaseType;
    class MeasuredDatumFeatureType;
    class NominalDatumFeatureType;
    class DatumFeatureSimulatorModifierType;
    class DatumsType;
    class DatumReferenceFrameType;
    class DegreeOfFreedomEnumType;
    class ISODegreeOfFreedomEnumType;
    class IntersectionPlaneEnumType;
    class IntersectionPlaneType;
    class ModifyingPlaneEnumType;
    class DirectionFeatureType;
    class CollectionPlaneType;
    class OrientationPlaneType;
    class ReducedDatumEnumType;
    class DegreesOfFreedomType;
    class DiameterModifierEnumType;
    class SectionModifierEnumType;
    class PointWithNormalBaseType;
    class MeasuredPointWithNormalBaseType;
    class MeasurePointNominalType;
    class MovableDatumTargetDirectionType;
    class DefiningPointNominalType;
    class DefiningPointMeasurementType;
    class TransformListType;
    class TransformInstanceType;
    class LinearCoordinateDirectionEnumType;
    class AngularCoordinateDirectionEnumType;
    class SubstituteFeatureAlgorithmEnumType;
    class SubstituteFeatureAlgorithmType;
    class MaterialModifierEnumType;
    class PrecedenceEnumType;
    class PrecedenceType;
    class ReferencedComponentEnumType;
    class RetrievalMethodEnumType;
    class MeasurementDirectiveEnumType;
    class MeasurementDirectiveType;
    class DistanceBetweenAnalysisModeEnumType;
    class AngleBetweenAnalysisModeEnumType;
    class BaseFeatureType;
    class SequencedBaseFeatureType;
    class DirectionalOffsetType;
    class AlignmentFeatureType;
    class AlignmentOperationBaseType;
    class PrimaryAlignmentOperationType;
    class SecondaryAlignmentOperationType;
    class MeasurementOriginOffsetType;
    class MeasurementOffsetAlignmentOperationType;
    class NominalOffsetAlignmentOperationType;
    class NominalRotationAlignmentOperationType;
    class DatumPrecedenceAlignmentOperationType;
    class BestFitAlignmentOperationType;
    class MachineCoordinateSystemOperationType;
    class AlignmentOperationsType;
    class MachineCoordinateSystemType;
    class CoordinateSystemListType;
    class CoordinateSystemsType;
    class CoordinateSystemType;
    class CoordinateSystemActualTransformAssociationType;
    class CoordinateSystemActualTransformAssociationsType;
    class ThreadSpecificationDetailedBaseType;
    class SingleLeadThreadSpecificationType;
    class MultiLeadThreadSpecificationType;
    class ThreadSpecificationType;
    class TextThreadSpecificationType;
    class ThreadSpecificationsType;
    class ToleranceZonePerUnitAreaType;
    class ToleranceZonePerUnitLengthType;
    class ToleranceZonePerUnitAngleType;
    class ToleranceZonePerUnitPolarAreaType;
    class DatumReferenceFramesType;
    class EventBaseType;
    class NotableEventType;
    class NotableEventsType;
    class NotedEventType;
    class NotedEventsType;
    class InspectionStatusEnumType;
    class InspectionStatusType;
    class EntityExternalType;
    class EntitiesExternalType;
    class ZoneDataType;
    class ZoneDataSetType;
    class LinearToleranceType;
    class LinearToleranceDefinitionType;
    class AngularToleranceType;
    class AngularToleranceDefinitionType;
    class TemperatureToleranceType;
    class AreaToleranceType;
    class ForceToleranceType;
    class MassToleranceType;
    class PressureToleranceType;
    class SpeedToleranceType;
    class TimeToleranceType;
    class DimensionModifierEnumType;
    class DimensionDeterminationEnumType;
    class SignificantDimensionEnumType;
    class DimensionModifiersType;
    class NonToleranceEnumType;
    class LimitsAndFitsZoneVarianceType;
    class LimitsAndFitsSpecificationType;
    class CommonFileSpecEnumType;
    class FileSpecType;
    class ExternalFileReferenceType;
    class ExternalFileReferencesType;
    class DatumTargetDefinitionsType;
    class DatumDefinitionType;
    class DatumDefinitionsType;
    class DatumTargetType;
    class EmployeeType;
    class FileType;
    class SoftwareType;
    class StandardsOrganizationEnumType;
    class StandardsOrganizationType;
    class StandardType;
    class StandardsType;
    class SoftwaresType;
    class AlgorithmType;
    class AlgorithmsType;
    class OrganizationType;
    class PhysicalAddressType;
    class AddressDescriptionEnumType;
    class AddressDescriptionType;
    class LocationType;
    class CustomerOrganizationType;
    class VersionHistoryType;
    class VersionBaseType;
    class VersionType;
    class VersionReferenceType;
    class SignOffsType;
    class MaterialClassEnumType;
    class MaterialType;
    class MaterialsType;
    class VirtualMeasurementType;
    class PointSetReferenceBaseType;
    class PointSetReferenceWholeType;
    class PointSetReferenceRangeType;
    class PointSetReferenceSingleType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/PrimitivesPMI.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL SequencedDatumType: public ::xml_schema::type
    {
      public:
      // SimpleDatum
      //
      typedef ::xsd::qif30::DatumType SimpleDatum_type;
      typedef ::xsd::cxx::tree::optional< SimpleDatum_type > SimpleDatum_optional;
      typedef ::xsd::cxx::tree::traits< SimpleDatum_type, wchar_t > SimpleDatum_traits;

      const SimpleDatum_optional&
      SimpleDatum () const;

      SimpleDatum_optional&
      SimpleDatum ();

      void
      SimpleDatum (const SimpleDatum_type& x);

      void
      SimpleDatum (const SimpleDatum_optional& x);

      void
      SimpleDatum (::std::unique_ptr< SimpleDatum_type > p);

      // CompoundDatum
      //
      typedef ::xsd::qif30::CompoundDatumType CompoundDatum_type;
      typedef ::xsd::cxx::tree::optional< CompoundDatum_type > CompoundDatum_optional;
      typedef ::xsd::cxx::tree::traits< CompoundDatum_type, wchar_t > CompoundDatum_traits;

      const CompoundDatum_optional&
      CompoundDatum () const;

      CompoundDatum_optional&
      CompoundDatum ();

      void
      CompoundDatum (const CompoundDatum_type& x);

      void
      CompoundDatum (const CompoundDatum_optional& x);

      void
      CompoundDatum (::std::unique_ptr< CompoundDatum_type > p);

      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // Constructors.
      //
      SequencedDatumType ();

      SequencedDatumType (const SequenceNumber_type&);

      SequencedDatumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SequencedDatumType (const SequencedDatumType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SequencedDatumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SequencedDatumType&
      operator= (const SequencedDatumType& x);

      virtual 
      ~SequencedDatumType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SimpleDatum_optional SimpleDatum_;
      CompoundDatum_optional CompoundDatum_;
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class QIF30_SYMBOL_DECL CompoundDatumType: public ::xml_schema::type
    {
      public:
      // Datum
      //
      typedef ::xsd::qif30::SequencedDatumType Datum_type;
      typedef ::xsd::cxx::tree::sequence< Datum_type > Datum_sequence;
      typedef xsd::cxx::tree::sequence< Datum_type >::iterator Datum_iterator;
      typedef xsd::cxx::tree::sequence< Datum_type >::const_iterator Datum_const_iterator;
      typedef ::xsd::cxx::tree::traits< Datum_type, wchar_t > Datum_traits;

      const Datum_sequence&
      Datum () const;

      Datum_sequence&
      Datum ();

      void
      Datum (const Datum_sequence& s);

      // ReducedDatum
      //
      typedef ::xsd::qif30::ReducedDatumEnumType ReducedDatum_type;
      typedef ::xsd::cxx::tree::optional< ReducedDatum_type > ReducedDatum_optional;
      typedef ::xsd::cxx::tree::traits< ReducedDatum_type, wchar_t > ReducedDatum_traits;

      const ReducedDatum_optional&
      ReducedDatum () const;

      ReducedDatum_optional&
      ReducedDatum ();

      void
      ReducedDatum (const ReducedDatum_type& x);

      void
      ReducedDatum (const ReducedDatum_optional& x);

      void
      ReducedDatum (::std::unique_ptr< ReducedDatum_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CompoundDatumType ();

      CompoundDatumType (const n_type&);

      CompoundDatumType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CompoundDatumType (const CompoundDatumType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CompoundDatumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompoundDatumType&
      operator= (const CompoundDatumType& x);

      virtual 
      ~CompoundDatumType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Datum_sequence Datum_;
      ReducedDatum_optional ReducedDatum_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DatumWithPrecedenceType: public ::xml_schema::type
    {
      public:
      // SimpleDatum
      //
      typedef ::xsd::qif30::DatumType SimpleDatum_type;
      typedef ::xsd::cxx::tree::optional< SimpleDatum_type > SimpleDatum_optional;
      typedef ::xsd::cxx::tree::traits< SimpleDatum_type, wchar_t > SimpleDatum_traits;

      const SimpleDatum_optional&
      SimpleDatum () const;

      SimpleDatum_optional&
      SimpleDatum ();

      void
      SimpleDatum (const SimpleDatum_type& x);

      void
      SimpleDatum (const SimpleDatum_optional& x);

      void
      SimpleDatum (::std::unique_ptr< SimpleDatum_type > p);

      // NominalDatumFeature
      //
      typedef ::xsd::qif30::NominalDatumFeatureType NominalDatumFeature_type;
      typedef ::xsd::cxx::tree::optional< NominalDatumFeature_type > NominalDatumFeature_optional;
      typedef ::xsd::cxx::tree::traits< NominalDatumFeature_type, wchar_t > NominalDatumFeature_traits;

      const NominalDatumFeature_optional&
      NominalDatumFeature () const;

      NominalDatumFeature_optional&
      NominalDatumFeature ();

      void
      NominalDatumFeature (const NominalDatumFeature_type& x);

      void
      NominalDatumFeature (const NominalDatumFeature_optional& x);

      void
      NominalDatumFeature (::std::unique_ptr< NominalDatumFeature_type > p);

      // MeasuredDatumFeature
      //
      typedef ::xsd::qif30::MeasuredDatumFeatureType MeasuredDatumFeature_type;
      typedef ::xsd::cxx::tree::optional< MeasuredDatumFeature_type > MeasuredDatumFeature_optional;
      typedef ::xsd::cxx::tree::traits< MeasuredDatumFeature_type, wchar_t > MeasuredDatumFeature_traits;

      const MeasuredDatumFeature_optional&
      MeasuredDatumFeature () const;

      MeasuredDatumFeature_optional&
      MeasuredDatumFeature ();

      void
      MeasuredDatumFeature (const MeasuredDatumFeature_type& x);

      void
      MeasuredDatumFeature (const MeasuredDatumFeature_optional& x);

      void
      MeasuredDatumFeature (::std::unique_ptr< MeasuredDatumFeature_type > p);

      // CompoundDatum
      //
      typedef ::xsd::qif30::CompoundDatumType CompoundDatum_type;
      typedef ::xsd::cxx::tree::optional< CompoundDatum_type > CompoundDatum_optional;
      typedef ::xsd::cxx::tree::traits< CompoundDatum_type, wchar_t > CompoundDatum_traits;

      const CompoundDatum_optional&
      CompoundDatum () const;

      CompoundDatum_optional&
      CompoundDatum ();

      void
      CompoundDatum (const CompoundDatum_type& x);

      void
      CompoundDatum (const CompoundDatum_optional& x);

      void
      CompoundDatum (::std::unique_ptr< CompoundDatum_type > p);

      // Precedence
      //
      typedef ::xsd::qif30::PrecedenceType Precedence_type;
      typedef ::xsd::cxx::tree::traits< Precedence_type, wchar_t > Precedence_traits;

      const Precedence_type&
      Precedence () const;

      Precedence_type&
      Precedence ();

      void
      Precedence (const Precedence_type& x);

      void
      Precedence (::std::unique_ptr< Precedence_type > p);

      // Constructors.
      //
      DatumWithPrecedenceType ();

      DatumWithPrecedenceType (const Precedence_type&);

      DatumWithPrecedenceType (::std::unique_ptr< Precedence_type >);

      DatumWithPrecedenceType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DatumWithPrecedenceType (const DatumWithPrecedenceType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual DatumWithPrecedenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumWithPrecedenceType&
      operator= (const DatumWithPrecedenceType& x);

      virtual 
      ~DatumWithPrecedenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SimpleDatum_optional SimpleDatum_;
      NominalDatumFeature_optional NominalDatumFeature_;
      MeasuredDatumFeature_optional MeasuredDatumFeature_;
      CompoundDatum_optional CompoundDatum_;
      ::xsd::cxx::tree::one< Precedence_type > Precedence_;
    };

    class QIF30_SYMBOL_DECL DatumType: public ::xml_schema::type
    {
      public:
      // DatumDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, wchar_t > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > p);

      // MaterialModifier
      //
      typedef ::xsd::qif30::MaterialModifierEnumType MaterialModifier_type;
      typedef ::xsd::cxx::tree::traits< MaterialModifier_type, wchar_t > MaterialModifier_traits;

      const MaterialModifier_type&
      MaterialModifier () const;

      MaterialModifier_type&
      MaterialModifier ();

      void
      MaterialModifier (const MaterialModifier_type& x);

      void
      MaterialModifier (::std::unique_ptr< MaterialModifier_type > p);

      // SizeCharacteristicDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceType SizeCharacteristicDefinitionId_type;
      typedef ::xsd::cxx::tree::optional< SizeCharacteristicDefinitionId_type > SizeCharacteristicDefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< SizeCharacteristicDefinitionId_type, wchar_t > SizeCharacteristicDefinitionId_traits;

      const SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId () const;

      SizeCharacteristicDefinitionId_optional&
      SizeCharacteristicDefinitionId ();

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_type& x);

      void
      SizeCharacteristicDefinitionId (const SizeCharacteristicDefinitionId_optional& x);

      void
      SizeCharacteristicDefinitionId (::std::unique_ptr< SizeCharacteristicDefinitionId_type > p);

      // ReferencedComponent
      //
      typedef ::xsd::qif30::ReferencedComponentEnumType ReferencedComponent_type;
      typedef ::xsd::cxx::tree::traits< ReferencedComponent_type, wchar_t > ReferencedComponent_traits;

      const ReferencedComponent_type&
      ReferencedComponent () const;

      ReferencedComponent_type&
      ReferencedComponent ();

      void
      ReferencedComponent (const ReferencedComponent_type& x);

      void
      ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > p);

      // SubstituteFeatureAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType SubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithm_type > SubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithm_type, wchar_t > SubstituteFeatureAlgorithm_traits;

      const SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm () const;

      SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm ();

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x);

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x);

      void
      SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > p);

      // DatumFeatureSimulatorModifier
      //
      typedef ::xsd::qif30::DatumFeatureSimulatorModifierType DatumFeatureSimulatorModifier_type;
      typedef ::xsd::cxx::tree::optional< DatumFeatureSimulatorModifier_type > DatumFeatureSimulatorModifier_optional;
      typedef ::xsd::cxx::tree::traits< DatumFeatureSimulatorModifier_type, wchar_t > DatumFeatureSimulatorModifier_traits;

      const DatumFeatureSimulatorModifier_optional&
      DatumFeatureSimulatorModifier () const;

      DatumFeatureSimulatorModifier_optional&
      DatumFeatureSimulatorModifier ();

      void
      DatumFeatureSimulatorModifier (const DatumFeatureSimulatorModifier_type& x);

      void
      DatumFeatureSimulatorModifier (const DatumFeatureSimulatorModifier_optional& x);

      void
      DatumFeatureSimulatorModifier (::std::unique_ptr< DatumFeatureSimulatorModifier_type > p);

      // DatumTranslation
      //
      typedef ::xsd::qif30::DatumTranslationType DatumTranslation_type;
      typedef ::xsd::cxx::tree::optional< DatumTranslation_type > DatumTranslation_optional;
      typedef ::xsd::cxx::tree::traits< DatumTranslation_type, wchar_t > DatumTranslation_traits;

      const DatumTranslation_optional&
      DatumTranslation () const;

      DatumTranslation_optional&
      DatumTranslation ();

      void
      DatumTranslation (const DatumTranslation_type& x);

      void
      DatumTranslation (const DatumTranslation_optional& x);

      void
      DatumTranslation (::std::unique_ptr< DatumTranslation_type > p);

      // DegreesOfFreedom
      //
      typedef ::xsd::qif30::DegreesOfFreedomType DegreesOfFreedom_type;
      typedef ::xsd::cxx::tree::optional< DegreesOfFreedom_type > DegreesOfFreedom_optional;
      typedef ::xsd::cxx::tree::traits< DegreesOfFreedom_type, wchar_t > DegreesOfFreedom_traits;

      const DegreesOfFreedom_optional&
      DegreesOfFreedom () const;

      DegreesOfFreedom_optional&
      DegreesOfFreedom ();

      void
      DegreesOfFreedom (const DegreesOfFreedom_type& x);

      void
      DegreesOfFreedom (const DegreesOfFreedom_optional& x);

      void
      DegreesOfFreedom (::std::unique_ptr< DegreesOfFreedom_type > p);

      // ProjectedDatum
      //
      typedef ::xsd::qif30::LinearValueType ProjectedDatum_type;
      typedef ::xsd::cxx::tree::optional< ProjectedDatum_type > ProjectedDatum_optional;
      typedef ::xsd::cxx::tree::traits< ProjectedDatum_type, wchar_t > ProjectedDatum_traits;

      const ProjectedDatum_optional&
      ProjectedDatum () const;

      ProjectedDatum_optional&
      ProjectedDatum ();

      void
      ProjectedDatum (const ProjectedDatum_type& x);

      void
      ProjectedDatum (const ProjectedDatum_optional& x);

      void
      ProjectedDatum (::std::unique_ptr< ProjectedDatum_type > p);

      // DiameterModifier
      //
      typedef ::xsd::qif30::DiameterModifierEnumType DiameterModifier_type;
      typedef ::xsd::cxx::tree::optional< DiameterModifier_type > DiameterModifier_optional;
      typedef ::xsd::cxx::tree::traits< DiameterModifier_type, wchar_t > DiameterModifier_traits;

      const DiameterModifier_optional&
      DiameterModifier () const;

      DiameterModifier_optional&
      DiameterModifier ();

      void
      DiameterModifier (const DiameterModifier_type& x);

      void
      DiameterModifier (const DiameterModifier_optional& x);

      void
      DiameterModifier (::std::unique_ptr< DiameterModifier_type > p);

      // SectionModifier
      //
      typedef ::xsd::qif30::SectionModifierEnumType SectionModifier_type;
      typedef ::xsd::cxx::tree::optional< SectionModifier_type > SectionModifier_optional;
      typedef ::xsd::cxx::tree::traits< SectionModifier_type, wchar_t > SectionModifier_traits;

      const SectionModifier_optional&
      SectionModifier () const;

      SectionModifier_optional&
      SectionModifier ();

      void
      SectionModifier (const SectionModifier_type& x);

      void
      SectionModifier (const SectionModifier_optional& x);

      void
      SectionModifier (::std::unique_ptr< SectionModifier_type > p);

      // ContactingFeature
      //
      typedef ::xml_schema::boolean ContactingFeature_type;
      typedef ::xsd::cxx::tree::optional< ContactingFeature_type > ContactingFeature_optional;
      typedef ::xsd::cxx::tree::traits< ContactingFeature_type, wchar_t > ContactingFeature_traits;

      const ContactingFeature_optional&
      ContactingFeature () const;

      ContactingFeature_optional&
      ContactingFeature ();

      void
      ContactingFeature (const ContactingFeature_type& x);

      void
      ContactingFeature (const ContactingFeature_optional& x);

      // DistanceVariable
      //
      typedef ::xml_schema::boolean DistanceVariable_type;
      typedef ::xsd::cxx::tree::optional< DistanceVariable_type > DistanceVariable_optional;
      typedef ::xsd::cxx::tree::traits< DistanceVariable_type, wchar_t > DistanceVariable_traits;

      const DistanceVariable_optional&
      DistanceVariable () const;

      DistanceVariable_optional&
      DistanceVariable ();

      void
      DistanceVariable (const DistanceVariable_type& x);

      void
      DistanceVariable (const DistanceVariable_optional& x);

      // DatumFixed
      //
      typedef ::xml_schema::boolean DatumFixed_type;
      typedef ::xsd::cxx::tree::optional< DatumFixed_type > DatumFixed_optional;
      typedef ::xsd::cxx::tree::traits< DatumFixed_type, wchar_t > DatumFixed_traits;

      const DatumFixed_optional&
      DatumFixed () const;

      DatumFixed_optional&
      DatumFixed ();

      void
      DatumFixed (const DatumFixed_type& x);

      void
      DatumFixed (const DatumFixed_optional& x);

      // ReducedDatum
      //
      typedef ::xsd::qif30::ReducedDatumEnumType ReducedDatum_type;
      typedef ::xsd::cxx::tree::optional< ReducedDatum_type > ReducedDatum_optional;
      typedef ::xsd::cxx::tree::traits< ReducedDatum_type, wchar_t > ReducedDatum_traits;

      const ReducedDatum_optional&
      ReducedDatum () const;

      ReducedDatum_optional&
      ReducedDatum ();

      void
      ReducedDatum (const ReducedDatum_type& x);

      void
      ReducedDatum (const ReducedDatum_optional& x);

      void
      ReducedDatum (::std::unique_ptr< ReducedDatum_type > p);

      // ConstrainOrientation
      //
      typedef ::xml_schema::boolean ConstrainOrientation_type;
      typedef ::xsd::cxx::tree::optional< ConstrainOrientation_type > ConstrainOrientation_optional;
      typedef ::xsd::cxx::tree::traits< ConstrainOrientation_type, wchar_t > ConstrainOrientation_traits;

      const ConstrainOrientation_optional&
      ConstrainOrientation () const;

      ConstrainOrientation_optional&
      ConstrainOrientation ();

      void
      ConstrainOrientation (const ConstrainOrientation_type& x);

      void
      ConstrainOrientation (const ConstrainOrientation_optional& x);

      // ConstrainSubsequent
      //
      typedef ::xml_schema::boolean ConstrainSubsequent_type;
      typedef ::xsd::cxx::tree::optional< ConstrainSubsequent_type > ConstrainSubsequent_optional;
      typedef ::xsd::cxx::tree::traits< ConstrainSubsequent_type, wchar_t > ConstrainSubsequent_traits;

      const ConstrainSubsequent_optional&
      ConstrainSubsequent () const;

      ConstrainSubsequent_optional&
      ConstrainSubsequent ();

      void
      ConstrainSubsequent (const ConstrainSubsequent_type& x);

      void
      ConstrainSubsequent (const ConstrainSubsequent_optional& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      DatumType ();

      DatumType (const DatumDefinitionId_type&,
                 const MaterialModifier_type&,
                 const ReferencedComponent_type&);

      DatumType (::std::unique_ptr< DatumDefinitionId_type >,
                 const MaterialModifier_type&,
                 const ReferencedComponent_type&);

      DatumType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      DatumType (const DatumType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual DatumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumType&
      operator= (const DatumType& x);

      virtual 
      ~DatumType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
      ::xsd::cxx::tree::one< MaterialModifier_type > MaterialModifier_;
      SizeCharacteristicDefinitionId_optional SizeCharacteristicDefinitionId_;
      ::xsd::cxx::tree::one< ReferencedComponent_type > ReferencedComponent_;
      SubstituteFeatureAlgorithm_optional SubstituteFeatureAlgorithm_;
      DatumFeatureSimulatorModifier_optional DatumFeatureSimulatorModifier_;
      DatumTranslation_optional DatumTranslation_;
      DegreesOfFreedom_optional DegreesOfFreedom_;
      ProjectedDatum_optional ProjectedDatum_;
      DiameterModifier_optional DiameterModifier_;
      SectionModifier_optional SectionModifier_;
      ContactingFeature_optional ContactingFeature_;
      DistanceVariable_optional DistanceVariable_;
      DatumFixed_optional DatumFixed_;
      ReducedDatum_optional ReducedDatum_;
      ConstrainOrientation_optional ConstrainOrientation_;
      ConstrainSubsequent_optional ConstrainSubsequent_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL DatumTranslationType: public ::xml_schema::type
    {
      public:
      // DatumTranslationAllowed
      //
      typedef ::xml_schema::boolean DatumTranslationAllowed_type;
      typedef ::xsd::cxx::tree::traits< DatumTranslationAllowed_type, wchar_t > DatumTranslationAllowed_traits;

      const DatumTranslationAllowed_type&
      DatumTranslationAllowed () const;

      DatumTranslationAllowed_type&
      DatumTranslationAllowed ();

      void
      DatumTranslationAllowed (const DatumTranslationAllowed_type& x);

      // Constructors.
      //
      DatumTranslationType ();

      DatumTranslationType (const DatumTranslationAllowed_type&);

      DatumTranslationType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DatumTranslationType (const DatumTranslationType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DatumTranslationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTranslationType&
      operator= (const DatumTranslationType& x);

      virtual 
      ~DatumTranslationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumTranslationAllowed_type > DatumTranslationAllowed_;
    };

    class QIF30_SYMBOL_DECL DatumFeatureBaseType: public ::xml_schema::type
    {
      public:
      // FeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType FeatureNominalId_type;
      typedef ::xsd::cxx::tree::traits< FeatureNominalId_type, wchar_t > FeatureNominalId_traits;

      const FeatureNominalId_type&
      FeatureNominalId () const;

      FeatureNominalId_type&
      FeatureNominalId ();

      void
      FeatureNominalId (const FeatureNominalId_type& x);

      void
      FeatureNominalId (::std::unique_ptr< FeatureNominalId_type > p);

      // Constructors.
      //
      DatumFeatureBaseType ();

      DatumFeatureBaseType (const FeatureNominalId_type&);

      DatumFeatureBaseType (::std::unique_ptr< FeatureNominalId_type >);

      DatumFeatureBaseType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DatumFeatureBaseType (const DatumFeatureBaseType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DatumFeatureBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      DatumFeatureBaseType&
      operator= (const DatumFeatureBaseType& x);

      virtual 
      ~DatumFeatureBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureNominalId_type > FeatureNominalId_;
    };

    class QIF30_SYMBOL_DECL MeasuredDatumFeatureType: public ::xsd::qif30::DatumFeatureBaseType
    {
      public:
      // MaterialModifier
      //
      typedef ::xsd::qif30::MaterialModifierEnumType MaterialModifier_type;
      typedef ::xsd::cxx::tree::traits< MaterialModifier_type, wchar_t > MaterialModifier_traits;

      const MaterialModifier_type&
      MaterialModifier () const;

      MaterialModifier_type&
      MaterialModifier ();

      void
      MaterialModifier (const MaterialModifier_type& x);

      void
      MaterialModifier (::std::unique_ptr< MaterialModifier_type > p);

      // SubstituteFeatureAlgorithm
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmType SubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithm_type > SubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithm_type, wchar_t > SubstituteFeatureAlgorithm_traits;

      const SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm () const;

      SubstituteFeatureAlgorithm_optional&
      SubstituteFeatureAlgorithm ();

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x);

      void
      SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x);

      void
      SubstituteFeatureAlgorithm (::std::unique_ptr< SubstituteFeatureAlgorithm_type > p);

      // Constructors.
      //
      MeasuredDatumFeatureType ();

      MeasuredDatumFeatureType (const FeatureNominalId_type&,
                                const MaterialModifier_type&);

      MeasuredDatumFeatureType (::std::unique_ptr< FeatureNominalId_type >,
                                const MaterialModifier_type&);

      MeasuredDatumFeatureType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MeasuredDatumFeatureType (const MeasuredDatumFeatureType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual MeasuredDatumFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasuredDatumFeatureType&
      operator= (const MeasuredDatumFeatureType& x);

      virtual 
      ~MeasuredDatumFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MaterialModifier_type > MaterialModifier_;
      SubstituteFeatureAlgorithm_optional SubstituteFeatureAlgorithm_;
    };

    class QIF30_SYMBOL_DECL NominalDatumFeatureType: public ::xsd::qif30::DatumFeatureBaseType
    {
      public:
      // Constructors.
      //
      NominalDatumFeatureType ();

      NominalDatumFeatureType (const FeatureNominalId_type&);

      NominalDatumFeatureType (::std::unique_ptr< FeatureNominalId_type >);

      NominalDatumFeatureType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      NominalDatumFeatureType (const NominalDatumFeatureType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual NominalDatumFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      NominalDatumFeatureType&
      operator= (const NominalDatumFeatureType&) = default;
#endif

      virtual 
      ~NominalDatumFeatureType ();
    };

    class QIF30_SYMBOL_DECL DatumFeatureSimulatorModifierType: public ::xml_schema::type
    {
      public:
      // LinearSize
      //
      typedef ::xsd::qif30::LinearValueType LinearSize_type;
      typedef ::xsd::cxx::tree::optional< LinearSize_type > LinearSize_optional;
      typedef ::xsd::cxx::tree::traits< LinearSize_type, wchar_t > LinearSize_traits;

      const LinearSize_optional&
      LinearSize () const;

      LinearSize_optional&
      LinearSize ();

      void
      LinearSize (const LinearSize_type& x);

      void
      LinearSize (const LinearSize_optional& x);

      void
      LinearSize (::std::unique_ptr< LinearSize_type > p);

      // DiametricalSize
      //
      typedef ::xsd::qif30::LinearValueType DiametricalSize_type;
      typedef ::xsd::cxx::tree::optional< DiametricalSize_type > DiametricalSize_optional;
      typedef ::xsd::cxx::tree::traits< DiametricalSize_type, wchar_t > DiametricalSize_traits;

      const DiametricalSize_optional&
      DiametricalSize () const;

      DiametricalSize_optional&
      DiametricalSize ();

      void
      DiametricalSize (const DiametricalSize_type& x);

      void
      DiametricalSize (const DiametricalSize_optional& x);

      void
      DiametricalSize (::std::unique_ptr< DiametricalSize_type > p);

      // BasicSize
      //
      typedef ::xml_schema::token BasicSize_type;
      typedef ::xsd::cxx::tree::optional< BasicSize_type > BasicSize_optional;
      typedef ::xsd::cxx::tree::traits< BasicSize_type, wchar_t > BasicSize_traits;

      const BasicSize_optional&
      BasicSize () const;

      BasicSize_optional&
      BasicSize ();

      void
      BasicSize (const BasicSize_type& x);

      void
      BasicSize (const BasicSize_optional& x);

      void
      BasicSize (::std::unique_ptr< BasicSize_type > p);

      static const BasicSize_type&
      BasicSize_default_value ();

      // Constructors.
      //
      DatumFeatureSimulatorModifierType ();

      DatumFeatureSimulatorModifierType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      DatumFeatureSimulatorModifierType (const DatumFeatureSimulatorModifierType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual DatumFeatureSimulatorModifierType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumFeatureSimulatorModifierType&
      operator= (const DatumFeatureSimulatorModifierType& x);

      virtual 
      ~DatumFeatureSimulatorModifierType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      LinearSize_optional LinearSize_;
      DiametricalSize_optional DiametricalSize_;
      BasicSize_optional BasicSize_;
      static const BasicSize_type BasicSize_default_value_;
    };

    class QIF30_SYMBOL_DECL DatumsType: public ::xml_schema::type
    {
      public:
      // Datum
      //
      typedef ::xsd::qif30::DatumWithPrecedenceType Datum_type;
      typedef ::xsd::cxx::tree::sequence< Datum_type > Datum_sequence;
      typedef xsd::cxx::tree::sequence< Datum_type >::iterator Datum_iterator;
      typedef xsd::cxx::tree::sequence< Datum_type >::const_iterator Datum_const_iterator;
      typedef ::xsd::cxx::tree::traits< Datum_type, wchar_t > Datum_traits;

      const Datum_sequence&
      Datum () const;

      Datum_sequence&
      Datum ();

      void
      Datum (const Datum_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DatumsType ();

      DatumsType (const n_type&);

      DatumsType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      DatumsType (const DatumsType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual DatumsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumsType&
      operator= (const DatumsType& x);

      virtual 
      ~DatumsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Datum_sequence Datum_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DatumReferenceFrameType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Datums
      //
      typedef ::xsd::qif30::DatumsType Datums_type;
      typedef ::xsd::cxx::tree::optional< Datums_type > Datums_optional;
      typedef ::xsd::cxx::tree::traits< Datums_type, wchar_t > Datums_traits;

      const Datums_optional&
      Datums () const;

      Datums_optional&
      Datums ();

      void
      Datums (const Datums_type& x);

      void
      Datums (const Datums_optional& x);

      void
      Datums (::std::unique_ptr< Datums_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      DatumReferenceFrameType ();

      DatumReferenceFrameType (const id_type&);

      DatumReferenceFrameType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DatumReferenceFrameType (const DatumReferenceFrameType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual DatumReferenceFrameType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumReferenceFrameType&
      operator= (const DatumReferenceFrameType& x);

      virtual 
      ~DatumReferenceFrameType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Datums_optional Datums_;
      Name_optional Name_;
      Description_optional Description_;
      CoordinateSystemId_optional CoordinateSystemId_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL DegreeOfFreedomEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        U,
        V,
        W,
        X,
        Y,
        Z
      };

      DegreeOfFreedomEnumType ();

      DegreeOfFreedomEnumType (value v);

      DegreeOfFreedomEnumType (const wchar_t* v);

      DegreeOfFreedomEnumType (const ::std::wstring& v);

      DegreeOfFreedomEnumType (const ::xml_schema::nmtoken& v);

      DegreeOfFreedomEnumType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DegreeOfFreedomEnumType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DegreeOfFreedomEnumType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DegreeOfFreedomEnumType (const DegreeOfFreedomEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DegreeOfFreedomEnumType&
      operator= (const DegreeOfFreedomEnumType&) = default;
#endif

      virtual DegreeOfFreedomEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DegreeOfFreedomEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DegreeOfFreedomEnumType_convert ();
      }

      protected:
      value
      _xsd_DegreeOfFreedomEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DegreeOfFreedomEnumType_literals_[6];
      static const value _xsd_DegreeOfFreedomEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL ISODegreeOfFreedomEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        Rx,
        Ry,
        Rz,
        Tx,
        Ty,
        Tz
      };

      ISODegreeOfFreedomEnumType ();

      ISODegreeOfFreedomEnumType (value v);

      ISODegreeOfFreedomEnumType (const wchar_t* v);

      ISODegreeOfFreedomEnumType (const ::std::wstring& v);

      ISODegreeOfFreedomEnumType (const ::xml_schema::nmtoken& v);

      ISODegreeOfFreedomEnumType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ISODegreeOfFreedomEnumType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ISODegreeOfFreedomEnumType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ISODegreeOfFreedomEnumType (const ISODegreeOfFreedomEnumType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ISODegreeOfFreedomEnumType&
      operator= (const ISODegreeOfFreedomEnumType&) = default;
#endif

      virtual ISODegreeOfFreedomEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ISODegreeOfFreedomEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ISODegreeOfFreedomEnumType_convert ();
      }

      protected:
      value
      _xsd_ISODegreeOfFreedomEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ISODegreeOfFreedomEnumType_literals_[6];
      static const value _xsd_ISODegreeOfFreedomEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL IntersectionPlaneEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PARALLEL,
        PERPENDICULAR,
        INCLUDING
      };

      IntersectionPlaneEnumType ();

      IntersectionPlaneEnumType (value v);

      IntersectionPlaneEnumType (const wchar_t* v);

      IntersectionPlaneEnumType (const ::std::wstring& v);

      IntersectionPlaneEnumType (const ::xml_schema::nmtoken& v);

      IntersectionPlaneEnumType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      IntersectionPlaneEnumType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      IntersectionPlaneEnumType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      IntersectionPlaneEnumType (const IntersectionPlaneEnumType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      IntersectionPlaneEnumType&
      operator= (const IntersectionPlaneEnumType&) = default;
#endif

      virtual IntersectionPlaneEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IntersectionPlaneEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_IntersectionPlaneEnumType_convert ();
      }

      protected:
      value
      _xsd_IntersectionPlaneEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_IntersectionPlaneEnumType_literals_[3];
      static const value _xsd_IntersectionPlaneEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL IntersectionPlaneType: public ::xml_schema::type
    {
      public:
      // IntersectionPlaneEnum
      //
      typedef ::xsd::qif30::IntersectionPlaneEnumType IntersectionPlaneEnum_type;
      typedef ::xsd::cxx::tree::traits< IntersectionPlaneEnum_type, wchar_t > IntersectionPlaneEnum_traits;

      const IntersectionPlaneEnum_type&
      IntersectionPlaneEnum () const;

      IntersectionPlaneEnum_type&
      IntersectionPlaneEnum ();

      void
      IntersectionPlaneEnum (const IntersectionPlaneEnum_type& x);

      void
      IntersectionPlaneEnum (::std::unique_ptr< IntersectionPlaneEnum_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, wchar_t > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      IntersectionPlaneType ();

      IntersectionPlaneType (const IntersectionPlaneEnum_type&,
                             const DatumDefinitionId_type&);

      IntersectionPlaneType (const IntersectionPlaneEnum_type&,
                             ::std::unique_ptr< DatumDefinitionId_type >);

      IntersectionPlaneType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      IntersectionPlaneType (const IntersectionPlaneType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual IntersectionPlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IntersectionPlaneType&
      operator= (const IntersectionPlaneType& x);

      virtual 
      ~IntersectionPlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< IntersectionPlaneEnum_type > IntersectionPlaneEnum_;
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
    };

    class QIF30_SYMBOL_DECL ModifyingPlaneEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PARALLEL,
        PERPENDICULAR,
        INCLINED
      };

      ModifyingPlaneEnumType ();

      ModifyingPlaneEnumType (value v);

      ModifyingPlaneEnumType (const wchar_t* v);

      ModifyingPlaneEnumType (const ::std::wstring& v);

      ModifyingPlaneEnumType (const ::xml_schema::nmtoken& v);

      ModifyingPlaneEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ModifyingPlaneEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ModifyingPlaneEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ModifyingPlaneEnumType (const ModifyingPlaneEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ModifyingPlaneEnumType&
      operator= (const ModifyingPlaneEnumType&) = default;
#endif

      virtual ModifyingPlaneEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ModifyingPlaneEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ModifyingPlaneEnumType_convert ();
      }

      protected:
      value
      _xsd_ModifyingPlaneEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ModifyingPlaneEnumType_literals_[3];
      static const value _xsd_ModifyingPlaneEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL DirectionFeatureType: public ::xml_schema::type
    {
      public:
      // DirectionFeatureEnum
      //
      typedef ::xsd::qif30::ModifyingPlaneEnumType DirectionFeatureEnum_type;
      typedef ::xsd::cxx::tree::traits< DirectionFeatureEnum_type, wchar_t > DirectionFeatureEnum_traits;

      const DirectionFeatureEnum_type&
      DirectionFeatureEnum () const;

      DirectionFeatureEnum_type&
      DirectionFeatureEnum ();

      void
      DirectionFeatureEnum (const DirectionFeatureEnum_type& x);

      void
      DirectionFeatureEnum (::std::unique_ptr< DirectionFeatureEnum_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, wchar_t > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      DirectionFeatureType ();

      DirectionFeatureType (const DirectionFeatureEnum_type&,
                            const DatumDefinitionId_type&);

      DirectionFeatureType (const DirectionFeatureEnum_type&,
                            ::std::unique_ptr< DatumDefinitionId_type >);

      DirectionFeatureType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DirectionFeatureType (const DirectionFeatureType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DirectionFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DirectionFeatureType&
      operator= (const DirectionFeatureType& x);

      virtual 
      ~DirectionFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DirectionFeatureEnum_type > DirectionFeatureEnum_;
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
    };

    class QIF30_SYMBOL_DECL CollectionPlaneType: public ::xml_schema::type
    {
      public:
      // CollectionPlaneEnum
      //
      typedef ::xsd::qif30::ModifyingPlaneEnumType CollectionPlaneEnum_type;
      typedef ::xsd::cxx::tree::traits< CollectionPlaneEnum_type, wchar_t > CollectionPlaneEnum_traits;

      const CollectionPlaneEnum_type&
      CollectionPlaneEnum () const;

      CollectionPlaneEnum_type&
      CollectionPlaneEnum ();

      void
      CollectionPlaneEnum (const CollectionPlaneEnum_type& x);

      void
      CollectionPlaneEnum (::std::unique_ptr< CollectionPlaneEnum_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, wchar_t > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      CollectionPlaneType ();

      CollectionPlaneType (const CollectionPlaneEnum_type&,
                           const DatumDefinitionId_type&);

      CollectionPlaneType (const CollectionPlaneEnum_type&,
                           ::std::unique_ptr< DatumDefinitionId_type >);

      CollectionPlaneType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CollectionPlaneType (const CollectionPlaneType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CollectionPlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CollectionPlaneType&
      operator= (const CollectionPlaneType& x);

      virtual 
      ~CollectionPlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CollectionPlaneEnum_type > CollectionPlaneEnum_;
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
    };

    class QIF30_SYMBOL_DECL OrientationPlaneType: public ::xml_schema::type
    {
      public:
      // OrientationPlaneEnum
      //
      typedef ::xsd::qif30::ModifyingPlaneEnumType OrientationPlaneEnum_type;
      typedef ::xsd::cxx::tree::traits< OrientationPlaneEnum_type, wchar_t > OrientationPlaneEnum_traits;

      const OrientationPlaneEnum_type&
      OrientationPlaneEnum () const;

      OrientationPlaneEnum_type&
      OrientationPlaneEnum ();

      void
      OrientationPlaneEnum (const OrientationPlaneEnum_type& x);

      void
      OrientationPlaneEnum (::std::unique_ptr< OrientationPlaneEnum_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, wchar_t > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      OrientationPlaneType ();

      OrientationPlaneType (const OrientationPlaneEnum_type&,
                            const DatumDefinitionId_type&);

      OrientationPlaneType (const OrientationPlaneEnum_type&,
                            ::std::unique_ptr< DatumDefinitionId_type >);

      OrientationPlaneType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      OrientationPlaneType (const OrientationPlaneType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual OrientationPlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrientationPlaneType&
      operator= (const OrientationPlaneType& x);

      virtual 
      ~OrientationPlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< OrientationPlaneEnum_type > OrientationPlaneEnum_;
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
    };

    class QIF30_SYMBOL_DECL ReducedDatumEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PT,
        SL,
        PL
      };

      ReducedDatumEnumType ();

      ReducedDatumEnumType (value v);

      ReducedDatumEnumType (const wchar_t* v);

      ReducedDatumEnumType (const ::std::wstring& v);

      ReducedDatumEnumType (const ::xml_schema::nmtoken& v);

      ReducedDatumEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ReducedDatumEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ReducedDatumEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ReducedDatumEnumType (const ReducedDatumEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ReducedDatumEnumType&
      operator= (const ReducedDatumEnumType&) = default;
#endif

      virtual ReducedDatumEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReducedDatumEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ReducedDatumEnumType_convert ();
      }

      protected:
      value
      _xsd_ReducedDatumEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ReducedDatumEnumType_literals_[3];
      static const value _xsd_ReducedDatumEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL DegreesOfFreedomType: public ::xml_schema::type
    {
      public:
      // DegreeOfFreedom
      //
      typedef ::xsd::qif30::DegreeOfFreedomEnumType DegreeOfFreedom_type;
      typedef ::xsd::cxx::tree::sequence< DegreeOfFreedom_type > DegreeOfFreedom_sequence;
      typedef xsd::cxx::tree::sequence< DegreeOfFreedom_type >::iterator DegreeOfFreedom_iterator;
      typedef xsd::cxx::tree::sequence< DegreeOfFreedom_type >::const_iterator DegreeOfFreedom_const_iterator;
      typedef ::xsd::cxx::tree::traits< DegreeOfFreedom_type, wchar_t > DegreeOfFreedom_traits;

      const DegreeOfFreedom_sequence&
      DegreeOfFreedom () const;

      DegreeOfFreedom_sequence&
      DegreeOfFreedom ();

      void
      DegreeOfFreedom (const DegreeOfFreedom_sequence& s);

      // ISODegreeOfFreedom
      //
      typedef ::xsd::qif30::ISODegreeOfFreedomEnumType ISODegreeOfFreedom_type;
      typedef ::xsd::cxx::tree::sequence< ISODegreeOfFreedom_type > ISODegreeOfFreedom_sequence;
      typedef xsd::cxx::tree::sequence< ISODegreeOfFreedom_type >::iterator ISODegreeOfFreedom_iterator;
      typedef xsd::cxx::tree::sequence< ISODegreeOfFreedom_type >::const_iterator ISODegreeOfFreedom_const_iterator;
      typedef ::xsd::cxx::tree::traits< ISODegreeOfFreedom_type, wchar_t > ISODegreeOfFreedom_traits;

      const ISODegreeOfFreedom_sequence&
      ISODegreeOfFreedom () const;

      ISODegreeOfFreedom_sequence&
      ISODegreeOfFreedom ();

      void
      ISODegreeOfFreedom (const ISODegreeOfFreedom_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DegreesOfFreedomType ();

      DegreesOfFreedomType (const n_type&);

      DegreesOfFreedomType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DegreesOfFreedomType (const DegreesOfFreedomType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DegreesOfFreedomType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DegreesOfFreedomType&
      operator= (const DegreesOfFreedomType& x);

      virtual 
      ~DegreesOfFreedomType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DegreeOfFreedom_sequence DegreeOfFreedom_;
      ISODegreeOfFreedom_sequence ISODegreeOfFreedom_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DiameterModifierEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PD,
        MD,
        LD
      };

      DiameterModifierEnumType ();

      DiameterModifierEnumType (value v);

      DiameterModifierEnumType (const wchar_t* v);

      DiameterModifierEnumType (const ::std::wstring& v);

      DiameterModifierEnumType (const ::xml_schema::nmtoken& v);

      DiameterModifierEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DiameterModifierEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DiameterModifierEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DiameterModifierEnumType (const DiameterModifierEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DiameterModifierEnumType&
      operator= (const DiameterModifierEnumType&) = default;
#endif

      virtual DiameterModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DiameterModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DiameterModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_DiameterModifierEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DiameterModifierEnumType_literals_[3];
      static const value _xsd_DiameterModifierEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL SectionModifierEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ACS,
        ALS,
        SCS
      };

      SectionModifierEnumType ();

      SectionModifierEnumType (value v);

      SectionModifierEnumType (const wchar_t* v);

      SectionModifierEnumType (const ::std::wstring& v);

      SectionModifierEnumType (const ::xml_schema::nmtoken& v);

      SectionModifierEnumType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SectionModifierEnumType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SectionModifierEnumType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SectionModifierEnumType (const SectionModifierEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SectionModifierEnumType&
      operator= (const SectionModifierEnumType&) = default;
#endif

      virtual SectionModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SectionModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_SectionModifierEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_SectionModifierEnumType_literals_[3];
      static const value _xsd_SectionModifierEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL PointWithNormalBaseType: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::PointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::unique_ptr< Point_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      PointWithNormalBaseType ();

      PointWithNormalBaseType (const Point_type&,
                               const id_type&);

      PointWithNormalBaseType (::std::unique_ptr< Point_type >,
                               const id_type&);

      PointWithNormalBaseType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PointWithNormalBaseType (const PointWithNormalBaseType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PointWithNormalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      PointWithNormalBaseType&
      operator= (const PointWithNormalBaseType& x);

      virtual 
      ~PointWithNormalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
      Normal_optional Normal_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL MeasuredPointWithNormalBaseType: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::MeasuredPointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::unique_ptr< Point_type > p);

      // Normal
      //
      typedef ::xsd::qif30::MeasuredUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      MeasuredPointWithNormalBaseType ();

      MeasuredPointWithNormalBaseType (const Point_type&,
                                       const id_type&);

      MeasuredPointWithNormalBaseType (::std::unique_ptr< Point_type >,
                                       const id_type&);

      MeasuredPointWithNormalBaseType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      MeasuredPointWithNormalBaseType (const MeasuredPointWithNormalBaseType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual MeasuredPointWithNormalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      MeasuredPointWithNormalBaseType&
      operator= (const MeasuredPointWithNormalBaseType& x);

      virtual 
      ~MeasuredPointWithNormalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
      Normal_optional Normal_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL MeasurePointNominalType: public ::xsd::qif30::PointWithNormalBaseType
    {
      public:
      // MeasurementDeviceId
      //
      typedef ::xsd::qif30::QIFReferenceType MeasurementDeviceId_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceId_type > MeasurementDeviceId_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceId_type, wchar_t > MeasurementDeviceId_traits;

      const MeasurementDeviceId_optional&
      MeasurementDeviceId () const;

      MeasurementDeviceId_optional&
      MeasurementDeviceId ();

      void
      MeasurementDeviceId (const MeasurementDeviceId_type& x);

      void
      MeasurementDeviceId (const MeasurementDeviceId_optional& x);

      void
      MeasurementDeviceId (::std::unique_ptr< MeasurementDeviceId_type > p);

      // SensorId
      //
      typedef ::xsd::qif30::QIFReferenceType SensorId_type;
      typedef ::xsd::cxx::tree::optional< SensorId_type > SensorId_optional;
      typedef ::xsd::cxx::tree::traits< SensorId_type, wchar_t > SensorId_traits;

      const SensorId_optional&
      SensorId () const;

      SensorId_optional&
      SensorId ();

      void
      SensorId (const SensorId_type& x);

      void
      SensorId (const SensorId_optional& x);

      void
      SensorId (::std::unique_ptr< SensorId_type > p);

      // TipId
      //
      typedef ::xsd::qif30::QIFReferenceType TipId_type;
      typedef ::xsd::cxx::tree::optional< TipId_type > TipId_optional;
      typedef ::xsd::cxx::tree::traits< TipId_type, wchar_t > TipId_traits;

      const TipId_optional&
      TipId () const;

      TipId_optional&
      TipId ();

      void
      TipId (const TipId_type& x);

      void
      TipId (const TipId_optional& x);

      void
      TipId (::std::unique_ptr< TipId_type > p);

      // Constructors.
      //
      MeasurePointNominalType ();

      MeasurePointNominalType (const Point_type&,
                               const id_type&);

      MeasurePointNominalType (::std::unique_ptr< Point_type >,
                               const id_type&);

      MeasurePointNominalType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      MeasurePointNominalType (const MeasurePointNominalType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual MeasurePointNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurePointNominalType&
      operator= (const MeasurePointNominalType& x);

      virtual 
      ~MeasurePointNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementDeviceId_optional MeasurementDeviceId_;
      SensorId_optional SensorId_;
      TipId_optional TipId_;
    };

    class QIF30_SYMBOL_DECL MovableDatumTargetDirectionType: public ::xml_schema::type
    {
      public:
      // DatumTargetTranslationDirection
      //
      typedef ::xsd::qif30::UnitVectorType DatumTargetTranslationDirection_type;
      typedef ::xsd::cxx::tree::traits< DatumTargetTranslationDirection_type, wchar_t > DatumTargetTranslationDirection_traits;

      const DatumTargetTranslationDirection_type&
      DatumTargetTranslationDirection () const;

      DatumTargetTranslationDirection_type&
      DatumTargetTranslationDirection ();

      void
      DatumTargetTranslationDirection (const DatumTargetTranslationDirection_type& x);

      void
      DatumTargetTranslationDirection (::std::unique_ptr< DatumTargetTranslationDirection_type > p);

      // Constructors.
      //
      MovableDatumTargetDirectionType ();

      MovableDatumTargetDirectionType (const DatumTargetTranslationDirection_type&);

      MovableDatumTargetDirectionType (::std::unique_ptr< DatumTargetTranslationDirection_type >);

      MovableDatumTargetDirectionType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      MovableDatumTargetDirectionType (const MovableDatumTargetDirectionType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual MovableDatumTargetDirectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MovableDatumTargetDirectionType&
      operator= (const MovableDatumTargetDirectionType& x);

      virtual 
      ~MovableDatumTargetDirectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumTargetTranslationDirection_type > DatumTargetTranslationDirection_;
    };

    class QIF30_SYMBOL_DECL DefiningPointNominalType: public ::xsd::qif30::PointWithNormalBaseType
    {
      public:
      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // Constructors.
      //
      DefiningPointNominalType ();

      DefiningPointNominalType (const Point_type&,
                                const id_type&,
                                const SequenceNumber_type&);

      DefiningPointNominalType (::std::unique_ptr< Point_type >,
                                const id_type&,
                                const SequenceNumber_type&);

      DefiningPointNominalType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DefiningPointNominalType (const DefiningPointNominalType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual DefiningPointNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DefiningPointNominalType&
      operator= (const DefiningPointNominalType& x);

      virtual 
      ~DefiningPointNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class QIF30_SYMBOL_DECL DefiningPointMeasurementType: public ::xsd::qif30::MeasuredPointWithNormalBaseType
    {
      public:
      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // Constructors.
      //
      DefiningPointMeasurementType ();

      DefiningPointMeasurementType (const Point_type&,
                                    const id_type&,
                                    const SequenceNumber_type&);

      DefiningPointMeasurementType (::std::unique_ptr< Point_type >,
                                    const id_type&,
                                    const SequenceNumber_type&);

      DefiningPointMeasurementType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      DefiningPointMeasurementType (const DefiningPointMeasurementType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual DefiningPointMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DefiningPointMeasurementType&
      operator= (const DefiningPointMeasurementType& x);

      virtual 
      ~DefiningPointMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class QIF30_SYMBOL_DECL TransformListType: public ::xml_schema::type
    {
      public:
      // Transform
      //
      typedef ::xsd::qif30::TransformInstanceType Transform_type;
      typedef ::xsd::cxx::tree::sequence< Transform_type > Transform_sequence;
      typedef xsd::cxx::tree::sequence< Transform_type >::iterator Transform_iterator;
      typedef xsd::cxx::tree::sequence< Transform_type >::const_iterator Transform_const_iterator;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_sequence&
      Transform () const;

      Transform_sequence&
      Transform ();

      void
      Transform (const Transform_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      TransformListType ();

      TransformListType (const n_type&);

      TransformListType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      TransformListType (const TransformListType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual TransformListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformListType&
      operator= (const TransformListType& x);

      virtual 
      ~TransformListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Transform_sequence Transform_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL TransformInstanceType: public ::xsd::qif30::TransformMatrixType
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      TransformInstanceType ();

      TransformInstanceType (const id_type&);

      TransformInstanceType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      TransformInstanceType (const TransformInstanceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual TransformInstanceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformInstanceType&
      operator= (const TransformInstanceType& x);

      virtual 
      ~TransformInstanceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Name_optional Name_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL LinearCoordinateDirectionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        XAXIS,
        YAXIS,
        ZAXIS,
        RADIAL
      };

      LinearCoordinateDirectionEnumType ();

      LinearCoordinateDirectionEnumType (value v);

      LinearCoordinateDirectionEnumType (const wchar_t* v);

      LinearCoordinateDirectionEnumType (const ::std::wstring& v);

      LinearCoordinateDirectionEnumType (const ::xml_schema::nmtoken& v);

      LinearCoordinateDirectionEnumType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LinearCoordinateDirectionEnumType (const xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LinearCoordinateDirectionEnumType (const ::std::wstring& s,
                                         const xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LinearCoordinateDirectionEnumType (const LinearCoordinateDirectionEnumType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LinearCoordinateDirectionEnumType&
      operator= (const LinearCoordinateDirectionEnumType&) = default;
#endif

      virtual LinearCoordinateDirectionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearCoordinateDirectionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LinearCoordinateDirectionEnumType_convert ();
      }

      protected:
      value
      _xsd_LinearCoordinateDirectionEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_LinearCoordinateDirectionEnumType_literals_[4];
      static const value _xsd_LinearCoordinateDirectionEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL AngularCoordinateDirectionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ANGULAR,
        AZIMUTH,
        POLAR
      };

      AngularCoordinateDirectionEnumType ();

      AngularCoordinateDirectionEnumType (value v);

      AngularCoordinateDirectionEnumType (const wchar_t* v);

      AngularCoordinateDirectionEnumType (const ::std::wstring& v);

      AngularCoordinateDirectionEnumType (const ::xml_schema::nmtoken& v);

      AngularCoordinateDirectionEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngularCoordinateDirectionEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngularCoordinateDirectionEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngularCoordinateDirectionEnumType (const AngularCoordinateDirectionEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      AngularCoordinateDirectionEnumType&
      operator= (const AngularCoordinateDirectionEnumType&) = default;
#endif

      virtual AngularCoordinateDirectionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularCoordinateDirectionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AngularCoordinateDirectionEnumType_convert ();
      }

      protected:
      value
      _xsd_AngularCoordinateDirectionEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_AngularCoordinateDirectionEnumType_literals_[3];
      static const value _xsd_AngularCoordinateDirectionEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL SubstituteFeatureAlgorithmEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        BEZIER,
        BSPLINE,
        DEFAULT,
        LEASTSQUARES,
        MAXINSCRIBED,
        MAXINNERLOCALSIZE,
        MAXOUTERLOCALSIZE,
        MINCIRCUMSCRIBED,
        MININNERLOCALSIZE,
        MINOUTERLOCALSIZE,
        MINMAX,
        NURBS,
        ONESIDED,
        UNDEFINED
      };

      SubstituteFeatureAlgorithmEnumType ();

      SubstituteFeatureAlgorithmEnumType (value v);

      SubstituteFeatureAlgorithmEnumType (const wchar_t* v);

      SubstituteFeatureAlgorithmEnumType (const ::std::wstring& v);

      SubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v);

      SubstituteFeatureAlgorithmEnumType (const xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SubstituteFeatureAlgorithmEnumType (const xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SubstituteFeatureAlgorithmEnumType (const ::std::wstring& s,
                                          const xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SubstituteFeatureAlgorithmEnumType (const SubstituteFeatureAlgorithmEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SubstituteFeatureAlgorithmEnumType&
      operator= (const SubstituteFeatureAlgorithmEnumType&) = default;
#endif

      virtual SubstituteFeatureAlgorithmEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SubstituteFeatureAlgorithmEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SubstituteFeatureAlgorithmEnumType_convert ();
      }

      protected:
      value
      _xsd_SubstituteFeatureAlgorithmEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_SubstituteFeatureAlgorithmEnumType_literals_[14];
      static const value _xsd_SubstituteFeatureAlgorithmEnumType_indexes_[14];
    };

    class QIF30_SYMBOL_DECL SubstituteFeatureAlgorithmType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // SubstituteFeatureAlgorithmEnum
      //
      typedef ::xsd::qif30::SubstituteFeatureAlgorithmEnumType SubstituteFeatureAlgorithmEnum_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithmEnum_type > SubstituteFeatureAlgorithmEnum_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithmEnum_type, wchar_t > SubstituteFeatureAlgorithmEnum_traits;

      const SubstituteFeatureAlgorithmEnum_optional&
      SubstituteFeatureAlgorithmEnum () const;

      SubstituteFeatureAlgorithmEnum_optional&
      SubstituteFeatureAlgorithmEnum ();

      void
      SubstituteFeatureAlgorithmEnum (const SubstituteFeatureAlgorithmEnum_type& x);

      void
      SubstituteFeatureAlgorithmEnum (const SubstituteFeatureAlgorithmEnum_optional& x);

      void
      SubstituteFeatureAlgorithmEnum (::std::unique_ptr< SubstituteFeatureAlgorithmEnum_type > p);

      // SubstituteFeatureAlgorithmId
      //
      typedef ::xsd::qif30::QIFReferenceType SubstituteFeatureAlgorithmId_type;
      typedef ::xsd::cxx::tree::optional< SubstituteFeatureAlgorithmId_type > SubstituteFeatureAlgorithmId_optional;
      typedef ::xsd::cxx::tree::traits< SubstituteFeatureAlgorithmId_type, wchar_t > SubstituteFeatureAlgorithmId_traits;

      const SubstituteFeatureAlgorithmId_optional&
      SubstituteFeatureAlgorithmId () const;

      SubstituteFeatureAlgorithmId_optional&
      SubstituteFeatureAlgorithmId ();

      void
      SubstituteFeatureAlgorithmId (const SubstituteFeatureAlgorithmId_type& x);

      void
      SubstituteFeatureAlgorithmId (const SubstituteFeatureAlgorithmId_optional& x);

      void
      SubstituteFeatureAlgorithmId (::std::unique_ptr< SubstituteFeatureAlgorithmId_type > p);

      // OtherSubstituteFeatureAlgorithm
      //
      typedef ::xml_schema::string OtherSubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< OtherSubstituteFeatureAlgorithm_type > OtherSubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< OtherSubstituteFeatureAlgorithm_type, wchar_t > OtherSubstituteFeatureAlgorithm_traits;

      const OtherSubstituteFeatureAlgorithm_optional&
      OtherSubstituteFeatureAlgorithm () const;

      OtherSubstituteFeatureAlgorithm_optional&
      OtherSubstituteFeatureAlgorithm ();

      void
      OtherSubstituteFeatureAlgorithm (const OtherSubstituteFeatureAlgorithm_type& x);

      void
      OtherSubstituteFeatureAlgorithm (const OtherSubstituteFeatureAlgorithm_optional& x);

      void
      OtherSubstituteFeatureAlgorithm (::std::unique_ptr< OtherSubstituteFeatureAlgorithm_type > p);

      // Constructors.
      //
      SubstituteFeatureAlgorithmType ();

      SubstituteFeatureAlgorithmType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      SubstituteFeatureAlgorithmType (const SubstituteFeatureAlgorithmType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual SubstituteFeatureAlgorithmType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SubstituteFeatureAlgorithmType&
      operator= (const SubstituteFeatureAlgorithmType& x);

      virtual 
      ~SubstituteFeatureAlgorithmType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      SubstituteFeatureAlgorithmEnum_optional SubstituteFeatureAlgorithmEnum_;
      SubstituteFeatureAlgorithmId_optional SubstituteFeatureAlgorithmId_;
      OtherSubstituteFeatureAlgorithm_optional OtherSubstituteFeatureAlgorithm_;
    };

    class QIF30_SYMBOL_DECL MaterialModifierEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        REGARDLESS,
        LEAST,
        MAXIMUM,
        LEAST_RPR,
        MAXIMUM_RPR,
        NONE
      };

      MaterialModifierEnumType ();

      MaterialModifierEnumType (value v);

      MaterialModifierEnumType (const wchar_t* v);

      MaterialModifierEnumType (const ::std::wstring& v);

      MaterialModifierEnumType (const ::xml_schema::nmtoken& v);

      MaterialModifierEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MaterialModifierEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MaterialModifierEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MaterialModifierEnumType (const MaterialModifierEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      MaterialModifierEnumType&
      operator= (const MaterialModifierEnumType&) = default;
#endif

      virtual MaterialModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MaterialModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MaterialModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_MaterialModifierEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_MaterialModifierEnumType_literals_[6];
      static const value _xsd_MaterialModifierEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL PrecedenceEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PRIMARY,
        SECONDARY,
        TERTIARY,
        QUATERNARY,
        QUINARY,
        SENARY
      };

      PrecedenceEnumType ();

      PrecedenceEnumType (value v);

      PrecedenceEnumType (const wchar_t* v);

      PrecedenceEnumType (const ::std::wstring& v);

      PrecedenceEnumType (const ::xml_schema::nmtoken& v);

      PrecedenceEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PrecedenceEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PrecedenceEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PrecedenceEnumType (const PrecedenceEnumType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      PrecedenceEnumType&
      operator= (const PrecedenceEnumType&) = default;
#endif

      virtual PrecedenceEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrecedenceEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PrecedenceEnumType_convert ();
      }

      protected:
      value
      _xsd_PrecedenceEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_PrecedenceEnumType_literals_[6];
      static const value _xsd_PrecedenceEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL PrecedenceType: public ::xml_schema::type
    {
      public:
      // PrecedenceEnum
      //
      typedef ::xsd::qif30::PrecedenceEnumType PrecedenceEnum_type;
      typedef ::xsd::cxx::tree::optional< PrecedenceEnum_type > PrecedenceEnum_optional;
      typedef ::xsd::cxx::tree::traits< PrecedenceEnum_type, wchar_t > PrecedenceEnum_traits;

      const PrecedenceEnum_optional&
      PrecedenceEnum () const;

      PrecedenceEnum_optional&
      PrecedenceEnum ();

      void
      PrecedenceEnum (const PrecedenceEnum_type& x);

      void
      PrecedenceEnum (const PrecedenceEnum_optional& x);

      void
      PrecedenceEnum (::std::unique_ptr< PrecedenceEnum_type > p);

      // OtherPrecedence
      //
      typedef ::xml_schema::string OtherPrecedence_type;
      typedef ::xsd::cxx::tree::optional< OtherPrecedence_type > OtherPrecedence_optional;
      typedef ::xsd::cxx::tree::traits< OtherPrecedence_type, wchar_t > OtherPrecedence_traits;

      const OtherPrecedence_optional&
      OtherPrecedence () const;

      OtherPrecedence_optional&
      OtherPrecedence ();

      void
      OtherPrecedence (const OtherPrecedence_type& x);

      void
      OtherPrecedence (const OtherPrecedence_optional& x);

      void
      OtherPrecedence (::std::unique_ptr< OtherPrecedence_type > p);

      // Constructors.
      //
      PrecedenceType ();

      PrecedenceType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      PrecedenceType (const PrecedenceType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual PrecedenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrecedenceType&
      operator= (const PrecedenceType& x);

      virtual 
      ~PrecedenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PrecedenceEnum_optional PrecedenceEnum_;
      OtherPrecedence_optional OtherPrecedence_;
    };

    class QIF30_SYMBOL_DECL ReferencedComponentEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        NOMINAL,
        ACTUAL
      };

      ReferencedComponentEnumType ();

      ReferencedComponentEnumType (value v);

      ReferencedComponentEnumType (const wchar_t* v);

      ReferencedComponentEnumType (const ::std::wstring& v);

      ReferencedComponentEnumType (const ::xml_schema::nmtoken& v);

      ReferencedComponentEnumType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ReferencedComponentEnumType (const xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ReferencedComponentEnumType (const ::std::wstring& s,
                                   const xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ReferencedComponentEnumType (const ReferencedComponentEnumType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ReferencedComponentEnumType&
      operator= (const ReferencedComponentEnumType&) = default;
#endif

      virtual ReferencedComponentEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferencedComponentEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ReferencedComponentEnumType_convert ();
      }

      protected:
      value
      _xsd_ReferencedComponentEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ReferencedComponentEnumType_literals_[2];
      static const value _xsd_ReferencedComponentEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL RetrievalMethodEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        AVERAGE,
        MAXEXTREME,
        MINEXTREME,
        CLOSEST1D,
        CLOSEST2D,
        CLOSEST3D
      };

      RetrievalMethodEnumType ();

      RetrievalMethodEnumType (value v);

      RetrievalMethodEnumType (const wchar_t* v);

      RetrievalMethodEnumType (const ::std::wstring& v);

      RetrievalMethodEnumType (const ::xml_schema::nmtoken& v);

      RetrievalMethodEnumType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RetrievalMethodEnumType (const xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RetrievalMethodEnumType (const ::std::wstring& s,
                               const xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RetrievalMethodEnumType (const RetrievalMethodEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      RetrievalMethodEnumType&
      operator= (const RetrievalMethodEnumType&) = default;
#endif

      virtual RetrievalMethodEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RetrievalMethodEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_RetrievalMethodEnumType_convert ();
      }

      protected:
      value
      _xsd_RetrievalMethodEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_RetrievalMethodEnumType_literals_[6];
      static const value _xsd_RetrievalMethodEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL MeasurementDirectiveEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        MINIMUM,
        MAXIMUM,
        AVERAGE,
        UNDEFINED
      };

      MeasurementDirectiveEnumType ();

      MeasurementDirectiveEnumType (value v);

      MeasurementDirectiveEnumType (const wchar_t* v);

      MeasurementDirectiveEnumType (const ::std::wstring& v);

      MeasurementDirectiveEnumType (const ::xml_schema::nmtoken& v);

      MeasurementDirectiveEnumType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasurementDirectiveEnumType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasurementDirectiveEnumType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasurementDirectiveEnumType (const MeasurementDirectiveEnumType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      MeasurementDirectiveEnumType&
      operator= (const MeasurementDirectiveEnumType&) = default;
#endif

      virtual MeasurementDirectiveEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDirectiveEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MeasurementDirectiveEnumType_convert ();
      }

      protected:
      value
      _xsd_MeasurementDirectiveEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_MeasurementDirectiveEnumType_literals_[4];
      static const value _xsd_MeasurementDirectiveEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL MeasurementDirectiveType: public ::xml_schema::type
    {
      public:
      // MeasurementDirectiveEnum
      //
      typedef ::xsd::qif30::MeasurementDirectiveEnumType MeasurementDirectiveEnum_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDirectiveEnum_type > MeasurementDirectiveEnum_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDirectiveEnum_type, wchar_t > MeasurementDirectiveEnum_traits;

      const MeasurementDirectiveEnum_optional&
      MeasurementDirectiveEnum () const;

      MeasurementDirectiveEnum_optional&
      MeasurementDirectiveEnum ();

      void
      MeasurementDirectiveEnum (const MeasurementDirectiveEnum_type& x);

      void
      MeasurementDirectiveEnum (const MeasurementDirectiveEnum_optional& x);

      void
      MeasurementDirectiveEnum (::std::unique_ptr< MeasurementDirectiveEnum_type > p);

      // OtherMeasurementDirective
      //
      typedef ::xml_schema::string OtherMeasurementDirective_type;
      typedef ::xsd::cxx::tree::optional< OtherMeasurementDirective_type > OtherMeasurementDirective_optional;
      typedef ::xsd::cxx::tree::traits< OtherMeasurementDirective_type, wchar_t > OtherMeasurementDirective_traits;

      const OtherMeasurementDirective_optional&
      OtherMeasurementDirective () const;

      OtherMeasurementDirective_optional&
      OtherMeasurementDirective ();

      void
      OtherMeasurementDirective (const OtherMeasurementDirective_type& x);

      void
      OtherMeasurementDirective (const OtherMeasurementDirective_optional& x);

      void
      OtherMeasurementDirective (::std::unique_ptr< OtherMeasurementDirective_type > p);

      // Constructors.
      //
      MeasurementDirectiveType ();

      MeasurementDirectiveType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MeasurementDirectiveType (const MeasurementDirectiveType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual MeasurementDirectiveType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDirectiveType&
      operator= (const MeasurementDirectiveType& x);

      virtual 
      ~MeasurementDirectiveType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeasurementDirectiveEnum_optional MeasurementDirectiveEnum_;
      OtherMeasurementDirective_optional OtherMeasurementDirective_;
    };

    class QIF30_SYMBOL_DECL DistanceBetweenAnalysisModeEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ONEDIMENSIONAL,
        TWODIMENSIONAL,
        THREEDIMENSIONAL
      };

      DistanceBetweenAnalysisModeEnumType ();

      DistanceBetweenAnalysisModeEnumType (value v);

      DistanceBetweenAnalysisModeEnumType (const wchar_t* v);

      DistanceBetweenAnalysisModeEnumType (const ::std::wstring& v);

      DistanceBetweenAnalysisModeEnumType (const ::xml_schema::nmtoken& v);

      DistanceBetweenAnalysisModeEnumType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      DistanceBetweenAnalysisModeEnumType (const xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      DistanceBetweenAnalysisModeEnumType (const ::std::wstring& s,
                                           const xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      DistanceBetweenAnalysisModeEnumType (const DistanceBetweenAnalysisModeEnumType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DistanceBetweenAnalysisModeEnumType&
      operator= (const DistanceBetweenAnalysisModeEnumType&) = default;
#endif

      virtual DistanceBetweenAnalysisModeEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DistanceBetweenAnalysisModeEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DistanceBetweenAnalysisModeEnumType_convert ();
      }

      protected:
      value
      _xsd_DistanceBetweenAnalysisModeEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DistanceBetweenAnalysisModeEnumType_literals_[3];
      static const value _xsd_DistanceBetweenAnalysisModeEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL AngleBetweenAnalysisModeEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        TWODIMENSIONAL,
        THREEDIMENSIONAL
      };

      AngleBetweenAnalysisModeEnumType ();

      AngleBetweenAnalysisModeEnumType (value v);

      AngleBetweenAnalysisModeEnumType (const wchar_t* v);

      AngleBetweenAnalysisModeEnumType (const ::std::wstring& v);

      AngleBetweenAnalysisModeEnumType (const ::xml_schema::nmtoken& v);

      AngleBetweenAnalysisModeEnumType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      AngleBetweenAnalysisModeEnumType (const xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      AngleBetweenAnalysisModeEnumType (const ::std::wstring& s,
                                        const xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      AngleBetweenAnalysisModeEnumType (const AngleBetweenAnalysisModeEnumType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      AngleBetweenAnalysisModeEnumType&
      operator= (const AngleBetweenAnalysisModeEnumType&) = default;
#endif

      virtual AngleBetweenAnalysisModeEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleBetweenAnalysisModeEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AngleBetweenAnalysisModeEnumType_convert ();
      }

      protected:
      value
      _xsd_AngleBetweenAnalysisModeEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_AngleBetweenAnalysisModeEnumType_literals_[2];
      static const value _xsd_AngleBetweenAnalysisModeEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL BaseFeatureType: public ::xml_schema::type
    {
      public:
      // ReferencedComponent
      //
      typedef ::xsd::qif30::ReferencedComponentEnumType ReferencedComponent_type;
      typedef ::xsd::cxx::tree::traits< ReferencedComponent_type, wchar_t > ReferencedComponent_traits;

      const ReferencedComponent_type&
      ReferencedComponent () const;

      ReferencedComponent_type&
      ReferencedComponent ();

      void
      ReferencedComponent (const ReferencedComponent_type& x);

      void
      ReferencedComponent (::std::unique_ptr< ReferencedComponent_type > p);

      // FeatureId
      //
      typedef ::xsd::qif30::QIFReferenceFullType FeatureId_type;
      typedef ::xsd::cxx::tree::traits< FeatureId_type, wchar_t > FeatureId_traits;

      const FeatureId_type&
      FeatureId () const;

      FeatureId_type&
      FeatureId ();

      void
      FeatureId (const FeatureId_type& x);

      void
      FeatureId (::std::unique_ptr< FeatureId_type > p);

      // Constructors.
      //
      BaseFeatureType ();

      BaseFeatureType (const ReferencedComponent_type&,
                       const FeatureId_type&);

      BaseFeatureType (const ReferencedComponent_type&,
                       ::std::unique_ptr< FeatureId_type >);

      BaseFeatureType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      BaseFeatureType (const BaseFeatureType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual BaseFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BaseFeatureType&
      operator= (const BaseFeatureType& x);

      virtual 
      ~BaseFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ReferencedComponent_type > ReferencedComponent_;
      ::xsd::cxx::tree::one< FeatureId_type > FeatureId_;
    };

    class QIF30_SYMBOL_DECL SequencedBaseFeatureType: public ::xsd::qif30::BaseFeatureType
    {
      public:
      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // Constructors.
      //
      SequencedBaseFeatureType ();

      SequencedBaseFeatureType (const ReferencedComponent_type&,
                                const FeatureId_type&,
                                const SequenceNumber_type&);

      SequencedBaseFeatureType (const ReferencedComponent_type&,
                                ::std::unique_ptr< FeatureId_type >,
                                const SequenceNumber_type&);

      SequencedBaseFeatureType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SequencedBaseFeatureType (const SequencedBaseFeatureType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual SequencedBaseFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SequencedBaseFeatureType&
      operator= (const SequencedBaseFeatureType& x);

      virtual 
      ~SequencedBaseFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class QIF30_SYMBOL_DECL DirectionalOffsetType: public ::xml_schema::type
    {
      public:
      // Offset
      //
      typedef ::xsd::qif30::LinearValueType Offset_type;
      typedef ::xsd::cxx::tree::traits< Offset_type, wchar_t > Offset_traits;

      const Offset_type&
      Offset () const;

      Offset_type&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (::std::unique_ptr< Offset_type > p);

      // NominalDirection
      //
      typedef ::xsd::qif30::UnitVectorType NominalDirection_type;
      typedef ::xsd::cxx::tree::optional< NominalDirection_type > NominalDirection_optional;
      typedef ::xsd::cxx::tree::traits< NominalDirection_type, wchar_t > NominalDirection_traits;

      const NominalDirection_optional&
      NominalDirection () const;

      NominalDirection_optional&
      NominalDirection ();

      void
      NominalDirection (const NominalDirection_type& x);

      void
      NominalDirection (const NominalDirection_optional& x);

      void
      NominalDirection (::std::unique_ptr< NominalDirection_type > p);

      // FeatureDirection
      //
      typedef ::xsd::qif30::BaseFeatureType FeatureDirection_type;
      typedef ::xsd::cxx::tree::optional< FeatureDirection_type > FeatureDirection_optional;
      typedef ::xsd::cxx::tree::traits< FeatureDirection_type, wchar_t > FeatureDirection_traits;

      const FeatureDirection_optional&
      FeatureDirection () const;

      FeatureDirection_optional&
      FeatureDirection ();

      void
      FeatureDirection (const FeatureDirection_type& x);

      void
      FeatureDirection (const FeatureDirection_optional& x);

      void
      FeatureDirection (::std::unique_ptr< FeatureDirection_type > p);

      // Constructors.
      //
      DirectionalOffsetType ();

      DirectionalOffsetType (const Offset_type&);

      DirectionalOffsetType (::std::unique_ptr< Offset_type >);

      DirectionalOffsetType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      DirectionalOffsetType (const DirectionalOffsetType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual DirectionalOffsetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DirectionalOffsetType&
      operator= (const DirectionalOffsetType& x);

      virtual 
      ~DirectionalOffsetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Offset_type > Offset_;
      NominalDirection_optional NominalDirection_;
      FeatureDirection_optional FeatureDirection_;
    };

    class QIF30_SYMBOL_DECL AlignmentFeatureType: public ::xml_schema::type
    {
      public:
      // DatumDefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::optional< DatumDefinitionId_type > DatumDefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, wchar_t > DatumDefinitionId_traits;

      const DatumDefinitionId_optional&
      DatumDefinitionId () const;

      DatumDefinitionId_optional&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (const DatumDefinitionId_optional& x);

      void
      DatumDefinitionId (::std::unique_ptr< DatumDefinitionId_type > p);

      // BaseFeature
      //
      typedef ::xsd::qif30::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::optional< BaseFeature_type > BaseFeature_optional;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_optional&
      BaseFeature () const;

      BaseFeature_optional&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (const BaseFeature_optional& x);

      void
      BaseFeature (::std::unique_ptr< BaseFeature_type > p);

      // Constructors.
      //
      AlignmentFeatureType ();

      AlignmentFeatureType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      AlignmentFeatureType (const AlignmentFeatureType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual AlignmentFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AlignmentFeatureType&
      operator= (const AlignmentFeatureType& x);

      virtual 
      ~AlignmentFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DatumDefinitionId_optional DatumDefinitionId_;
      BaseFeature_optional BaseFeature_;
    };

    class QIF30_SYMBOL_DECL AlignmentOperationBaseType: public ::xml_schema::type
    {
      public:
      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      AlignmentOperationBaseType ();

      AlignmentOperationBaseType (const SequenceNumber_type&);

      AlignmentOperationBaseType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      AlignmentOperationBaseType (const AlignmentOperationBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual AlignmentOperationBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      AlignmentOperationBaseType&
      operator= (const AlignmentOperationBaseType& x);

      virtual 
      ~AlignmentOperationBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL PrimaryAlignmentOperationType: public ::xsd::qif30::AlignmentOperationBaseType
    {
      public:
      // PrimaryEntity
      //
      typedef ::xsd::qif30::AlignmentFeatureType PrimaryEntity_type;
      typedef ::xsd::cxx::tree::traits< PrimaryEntity_type, wchar_t > PrimaryEntity_traits;

      const PrimaryEntity_type&
      PrimaryEntity () const;

      PrimaryEntity_type&
      PrimaryEntity ();

      void
      PrimaryEntity (const PrimaryEntity_type& x);

      void
      PrimaryEntity (::std::unique_ptr< PrimaryEntity_type > p);

      // PrimaryAxis
      //
      typedef ::xsd::qif30::UnitVectorType PrimaryAxis_type;
      typedef ::xsd::cxx::tree::traits< PrimaryAxis_type, wchar_t > PrimaryAxis_traits;

      const PrimaryAxis_type&
      PrimaryAxis () const;

      PrimaryAxis_type&
      PrimaryAxis ();

      void
      PrimaryAxis (const PrimaryAxis_type& x);

      void
      PrimaryAxis (::std::unique_ptr< PrimaryAxis_type > p);

      // Constructors.
      //
      PrimaryAlignmentOperationType ();

      PrimaryAlignmentOperationType (const SequenceNumber_type&,
                                     const PrimaryEntity_type&,
                                     const PrimaryAxis_type&);

      PrimaryAlignmentOperationType (const SequenceNumber_type&,
                                     ::std::unique_ptr< PrimaryEntity_type >,
                                     ::std::unique_ptr< PrimaryAxis_type >);

      PrimaryAlignmentOperationType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      PrimaryAlignmentOperationType (const PrimaryAlignmentOperationType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual PrimaryAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrimaryAlignmentOperationType&
      operator= (const PrimaryAlignmentOperationType& x);

      virtual 
      ~PrimaryAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PrimaryEntity_type > PrimaryEntity_;
      ::xsd::cxx::tree::one< PrimaryAxis_type > PrimaryAxis_;
    };

    class QIF30_SYMBOL_DECL SecondaryAlignmentOperationType: public ::xsd::qif30::AlignmentOperationBaseType
    {
      public:
      // SecondaryEntity
      //
      typedef ::xsd::qif30::AlignmentFeatureType SecondaryEntity_type;
      typedef ::xsd::cxx::tree::traits< SecondaryEntity_type, wchar_t > SecondaryEntity_traits;

      const SecondaryEntity_type&
      SecondaryEntity () const;

      SecondaryEntity_type&
      SecondaryEntity ();

      void
      SecondaryEntity (const SecondaryEntity_type& x);

      void
      SecondaryEntity (::std::unique_ptr< SecondaryEntity_type > p);

      // SecondaryAxis
      //
      typedef ::xsd::qif30::UnitVectorType SecondaryAxis_type;
      typedef ::xsd::cxx::tree::traits< SecondaryAxis_type, wchar_t > SecondaryAxis_traits;

      const SecondaryAxis_type&
      SecondaryAxis () const;

      SecondaryAxis_type&
      SecondaryAxis ();

      void
      SecondaryAxis (const SecondaryAxis_type& x);

      void
      SecondaryAxis (::std::unique_ptr< SecondaryAxis_type > p);

      // RotationAxis
      //
      typedef ::xsd::qif30::UnitVectorType RotationAxis_type;
      typedef ::xsd::cxx::tree::optional< RotationAxis_type > RotationAxis_optional;
      typedef ::xsd::cxx::tree::traits< RotationAxis_type, wchar_t > RotationAxis_traits;

      const RotationAxis_optional&
      RotationAxis () const;

      RotationAxis_optional&
      RotationAxis ();

      void
      RotationAxis (const RotationAxis_type& x);

      void
      RotationAxis (const RotationAxis_optional& x);

      void
      RotationAxis (::std::unique_ptr< RotationAxis_type > p);

      // Constructors.
      //
      SecondaryAlignmentOperationType ();

      SecondaryAlignmentOperationType (const SequenceNumber_type&,
                                       const SecondaryEntity_type&,
                                       const SecondaryAxis_type&);

      SecondaryAlignmentOperationType (const SequenceNumber_type&,
                                       ::std::unique_ptr< SecondaryEntity_type >,
                                       ::std::unique_ptr< SecondaryAxis_type >);

      SecondaryAlignmentOperationType (const xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SecondaryAlignmentOperationType (const SecondaryAlignmentOperationType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SecondaryAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SecondaryAlignmentOperationType&
      operator= (const SecondaryAlignmentOperationType& x);

      virtual 
      ~SecondaryAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SecondaryEntity_type > SecondaryEntity_;
      ::xsd::cxx::tree::one< SecondaryAxis_type > SecondaryAxis_;
      RotationAxis_optional RotationAxis_;
    };

    class QIF30_SYMBOL_DECL MeasurementOriginOffsetType: public ::xml_schema::type
    {
      public:
      // OriginEntity
      //
      typedef ::xsd::qif30::AlignmentFeatureType OriginEntity_type;
      typedef ::xsd::cxx::tree::traits< OriginEntity_type, wchar_t > OriginEntity_traits;

      const OriginEntity_type&
      OriginEntity () const;

      OriginEntity_type&
      OriginEntity ();

      void
      OriginEntity (const OriginEntity_type& x);

      void
      OriginEntity (::std::unique_ptr< OriginEntity_type > p);

      // OriginDirection
      //
      typedef ::xsd::qif30::UnitVectorType OriginDirection_type;
      typedef ::xsd::cxx::tree::traits< OriginDirection_type, wchar_t > OriginDirection_traits;

      const OriginDirection_type&
      OriginDirection () const;

      OriginDirection_type&
      OriginDirection ();

      void
      OriginDirection (const OriginDirection_type& x);

      void
      OriginDirection (::std::unique_ptr< OriginDirection_type > p);

      // Constructors.
      //
      MeasurementOriginOffsetType ();

      MeasurementOriginOffsetType (const OriginEntity_type&,
                                   const OriginDirection_type&);

      MeasurementOriginOffsetType (::std::unique_ptr< OriginEntity_type >,
                                   ::std::unique_ptr< OriginDirection_type >);

      MeasurementOriginOffsetType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      MeasurementOriginOffsetType (const MeasurementOriginOffsetType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual MeasurementOriginOffsetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementOriginOffsetType&
      operator= (const MeasurementOriginOffsetType& x);

      virtual 
      ~MeasurementOriginOffsetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< OriginEntity_type > OriginEntity_;
      ::xsd::cxx::tree::one< OriginDirection_type > OriginDirection_;
    };

    class QIF30_SYMBOL_DECL MeasurementOffsetAlignmentOperationType: public ::xsd::qif30::AlignmentOperationBaseType
    {
      public:
      // Origin
      //
      typedef ::xsd::qif30::MeasurementOriginOffsetType Origin_type;
      typedef ::xsd::cxx::tree::sequence< Origin_type > Origin_sequence;
      typedef xsd::cxx::tree::sequence< Origin_type >::iterator Origin_iterator;
      typedef xsd::cxx::tree::sequence< Origin_type >::const_iterator Origin_const_iterator;
      typedef ::xsd::cxx::tree::traits< Origin_type, wchar_t > Origin_traits;

      const Origin_sequence&
      Origin () const;

      Origin_sequence&
      Origin ();

      void
      Origin (const Origin_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      MeasurementOffsetAlignmentOperationType ();

      MeasurementOffsetAlignmentOperationType (const SequenceNumber_type&,
                                               const n_type&);

      MeasurementOffsetAlignmentOperationType (const xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      MeasurementOffsetAlignmentOperationType (const MeasurementOffsetAlignmentOperationType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual MeasurementOffsetAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementOffsetAlignmentOperationType&
      operator= (const MeasurementOffsetAlignmentOperationType& x);

      virtual 
      ~MeasurementOffsetAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Origin_sequence Origin_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL NominalOffsetAlignmentOperationType: public ::xsd::qif30::AlignmentOperationBaseType
    {
      public:
      // Offset
      //
      typedef ::xsd::qif30::VectorType Offset_type;
      typedef ::xsd::cxx::tree::traits< Offset_type, wchar_t > Offset_traits;

      const Offset_type&
      Offset () const;

      Offset_type&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (::std::unique_ptr< Offset_type > p);

      // Constructors.
      //
      NominalOffsetAlignmentOperationType ();

      NominalOffsetAlignmentOperationType (const SequenceNumber_type&,
                                           const Offset_type&);

      NominalOffsetAlignmentOperationType (const SequenceNumber_type&,
                                           ::std::unique_ptr< Offset_type >);

      NominalOffsetAlignmentOperationType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      NominalOffsetAlignmentOperationType (const NominalOffsetAlignmentOperationType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual NominalOffsetAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NominalOffsetAlignmentOperationType&
      operator= (const NominalOffsetAlignmentOperationType& x);

      virtual 
      ~NominalOffsetAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Offset_type > Offset_;
    };

    class QIF30_SYMBOL_DECL NominalRotationAlignmentOperationType: public ::xsd::qif30::AlignmentOperationBaseType
    {
      public:
      // RotationAxis
      //
      typedef ::xsd::qif30::UnitVectorType RotationAxis_type;
      typedef ::xsd::cxx::tree::traits< RotationAxis_type, wchar_t > RotationAxis_traits;

      const RotationAxis_type&
      RotationAxis () const;

      RotationAxis_type&
      RotationAxis ();

      void
      RotationAxis (const RotationAxis_type& x);

      void
      RotationAxis (::std::unique_ptr< RotationAxis_type > p);

      // Angle
      //
      typedef ::xsd::qif30::AngularValueType Angle_type;
      typedef ::xsd::cxx::tree::traits< Angle_type, wchar_t > Angle_traits;

      const Angle_type&
      Angle () const;

      Angle_type&
      Angle ();

      void
      Angle (const Angle_type& x);

      void
      Angle (::std::unique_ptr< Angle_type > p);

      // Constructors.
      //
      NominalRotationAlignmentOperationType ();

      NominalRotationAlignmentOperationType (const SequenceNumber_type&,
                                             const RotationAxis_type&,
                                             const Angle_type&);

      NominalRotationAlignmentOperationType (const SequenceNumber_type&,
                                             ::std::unique_ptr< RotationAxis_type >,
                                             ::std::unique_ptr< Angle_type >);

      NominalRotationAlignmentOperationType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      NominalRotationAlignmentOperationType (const NominalRotationAlignmentOperationType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual NominalRotationAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NominalRotationAlignmentOperationType&
      operator= (const NominalRotationAlignmentOperationType& x);

      virtual 
      ~NominalRotationAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< RotationAxis_type > RotationAxis_;
      ::xsd::cxx::tree::one< Angle_type > Angle_;
    };

    class QIF30_SYMBOL_DECL DatumPrecedenceAlignmentOperationType: public ::xsd::qif30::AlignmentOperationBaseType
    {
      public:
      // DatumReferenceFrameId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DatumReferenceFrameId_type;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameId_type, wchar_t > DatumReferenceFrameId_traits;

      const DatumReferenceFrameId_type&
      DatumReferenceFrameId () const;

      DatumReferenceFrameId_type&
      DatumReferenceFrameId ();

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_type& x);

      void
      DatumReferenceFrameId (::std::unique_ptr< DatumReferenceFrameId_type > p);

      // PrimaryAxis
      //
      typedef ::xsd::qif30::UnitVectorType PrimaryAxis_type;
      typedef ::xsd::cxx::tree::traits< PrimaryAxis_type, wchar_t > PrimaryAxis_traits;

      const PrimaryAxis_type&
      PrimaryAxis () const;

      PrimaryAxis_type&
      PrimaryAxis ();

      void
      PrimaryAxis (const PrimaryAxis_type& x);

      void
      PrimaryAxis (::std::unique_ptr< PrimaryAxis_type > p);

      // SecondaryAxis
      //
      typedef ::xsd::qif30::UnitVectorType SecondaryAxis_type;
      typedef ::xsd::cxx::tree::optional< SecondaryAxis_type > SecondaryAxis_optional;
      typedef ::xsd::cxx::tree::traits< SecondaryAxis_type, wchar_t > SecondaryAxis_traits;

      const SecondaryAxis_optional&
      SecondaryAxis () const;

      SecondaryAxis_optional&
      SecondaryAxis ();

      void
      SecondaryAxis (const SecondaryAxis_type& x);

      void
      SecondaryAxis (const SecondaryAxis_optional& x);

      void
      SecondaryAxis (::std::unique_ptr< SecondaryAxis_type > p);

      // Constructors.
      //
      DatumPrecedenceAlignmentOperationType ();

      DatumPrecedenceAlignmentOperationType (const SequenceNumber_type&,
                                             const DatumReferenceFrameId_type&,
                                             const PrimaryAxis_type&);

      DatumPrecedenceAlignmentOperationType (const SequenceNumber_type&,
                                             ::std::unique_ptr< DatumReferenceFrameId_type >,
                                             ::std::unique_ptr< PrimaryAxis_type >);

      DatumPrecedenceAlignmentOperationType (const xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      DatumPrecedenceAlignmentOperationType (const DatumPrecedenceAlignmentOperationType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual DatumPrecedenceAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumPrecedenceAlignmentOperationType&
      operator= (const DatumPrecedenceAlignmentOperationType& x);

      virtual 
      ~DatumPrecedenceAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumReferenceFrameId_type > DatumReferenceFrameId_;
      ::xsd::cxx::tree::one< PrimaryAxis_type > PrimaryAxis_;
      SecondaryAxis_optional SecondaryAxis_;
    };

    class QIF30_SYMBOL_DECL BestFitAlignmentOperationType: public ::xsd::qif30::AlignmentOperationBaseType
    {
      public:
      // DegreesOfFreedom
      //
      typedef ::xsd::qif30::DegreesOfFreedomType DegreesOfFreedom_type;
      typedef ::xsd::cxx::tree::traits< DegreesOfFreedom_type, wchar_t > DegreesOfFreedom_traits;

      const DegreesOfFreedom_type&
      DegreesOfFreedom () const;

      DegreesOfFreedom_type&
      DegreesOfFreedom ();

      void
      DegreesOfFreedom (const DegreesOfFreedom_type& x);

      void
      DegreesOfFreedom (::std::unique_ptr< DegreesOfFreedom_type > p);

      // BaseFeature
      //
      typedef ::xsd::qif30::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::iterator BaseFeature_iterator;
      typedef xsd::cxx::tree::sequence< BaseFeature_type >::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, wchar_t > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      BestFitAlignmentOperationType ();

      BestFitAlignmentOperationType (const SequenceNumber_type&,
                                     const DegreesOfFreedom_type&,
                                     const n_type&);

      BestFitAlignmentOperationType (const SequenceNumber_type&,
                                     ::std::unique_ptr< DegreesOfFreedom_type >,
                                     const n_type&);

      BestFitAlignmentOperationType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      BestFitAlignmentOperationType (const BestFitAlignmentOperationType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual BestFitAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BestFitAlignmentOperationType&
      operator= (const BestFitAlignmentOperationType& x);

      virtual 
      ~BestFitAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DegreesOfFreedom_type > DegreesOfFreedom_;
      BaseFeature_sequence BaseFeature_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MachineCoordinateSystemOperationType: public ::xsd::qif30::AlignmentOperationBaseType
    {
      public:
      // Constructors.
      //
      MachineCoordinateSystemOperationType ();

      MachineCoordinateSystemOperationType (const SequenceNumber_type&);

      MachineCoordinateSystemOperationType (const xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      MachineCoordinateSystemOperationType (const MachineCoordinateSystemOperationType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual MachineCoordinateSystemOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      MachineCoordinateSystemOperationType&
      operator= (const MachineCoordinateSystemOperationType&) = default;
#endif

      virtual 
      ~MachineCoordinateSystemOperationType ();
    };

    class QIF30_SYMBOL_DECL AlignmentOperationsType: public ::xml_schema::type
    {
      public:
      // AlignmentOperation
      //
      typedef ::xsd::qif30::AlignmentOperationBaseType AlignmentOperation_type;
      typedef ::xsd::cxx::tree::sequence< AlignmentOperation_type > AlignmentOperation_sequence;
      typedef xsd::cxx::tree::sequence< AlignmentOperation_type >::iterator AlignmentOperation_iterator;
      typedef xsd::cxx::tree::sequence< AlignmentOperation_type >::const_iterator AlignmentOperation_const_iterator;
      typedef ::xsd::cxx::tree::traits< AlignmentOperation_type, wchar_t > AlignmentOperation_traits;

      const AlignmentOperation_sequence&
      AlignmentOperation () const;

      AlignmentOperation_sequence&
      AlignmentOperation ();

      void
      AlignmentOperation (const AlignmentOperation_sequence& s);

      // BaseCoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType BaseCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< BaseCoordinateSystemId_type > BaseCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< BaseCoordinateSystemId_type, wchar_t > BaseCoordinateSystemId_traits;

      const BaseCoordinateSystemId_optional&
      BaseCoordinateSystemId () const;

      BaseCoordinateSystemId_optional&
      BaseCoordinateSystemId ();

      void
      BaseCoordinateSystemId (const BaseCoordinateSystemId_type& x);

      void
      BaseCoordinateSystemId (const BaseCoordinateSystemId_optional& x);

      void
      BaseCoordinateSystemId (::std::unique_ptr< BaseCoordinateSystemId_type > p);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AlignmentOperationsType ();

      AlignmentOperationsType (const n_type&);

      AlignmentOperationsType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      AlignmentOperationsType (const AlignmentOperationsType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual AlignmentOperationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AlignmentOperationsType&
      operator= (const AlignmentOperationsType& x);

      virtual 
      ~AlignmentOperationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AlignmentOperation_sequence AlignmentOperation_;
      BaseCoordinateSystemId_optional BaseCoordinateSystemId_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MachineCoordinateSystemType: public ::xml_schema::type
    {
      public:
      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_type&
      CoordinateSystemId () const;

      CoordinateSystemId_type&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // MeasurementDeviceId
      //
      typedef ::xsd::qif30::QIFReferenceType MeasurementDeviceId_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceId_type > MeasurementDeviceId_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceId_type, wchar_t > MeasurementDeviceId_traits;

      const MeasurementDeviceId_optional&
      MeasurementDeviceId () const;

      MeasurementDeviceId_optional&
      MeasurementDeviceId ();

      void
      MeasurementDeviceId (const MeasurementDeviceId_type& x);

      void
      MeasurementDeviceId (const MeasurementDeviceId_optional& x);

      void
      MeasurementDeviceId (::std::unique_ptr< MeasurementDeviceId_type > p);

      // Constructors.
      //
      MachineCoordinateSystemType ();

      MachineCoordinateSystemType (const CoordinateSystemId_type&);

      MachineCoordinateSystemType (::std::unique_ptr< CoordinateSystemId_type >);

      MachineCoordinateSystemType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      MachineCoordinateSystemType (const MachineCoordinateSystemType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual MachineCoordinateSystemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MachineCoordinateSystemType&
      operator= (const MachineCoordinateSystemType& x);

      virtual 
      ~MachineCoordinateSystemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CoordinateSystemId_type > CoordinateSystemId_;
      MeasurementDeviceId_optional MeasurementDeviceId_;
    };

    class QIF30_SYMBOL_DECL CoordinateSystemListType: public ::xml_schema::type
    {
      public:
      // CoordinateSystem
      //
      typedef ::xsd::qif30::CoordinateSystemType CoordinateSystem_type;
      typedef ::xsd::cxx::tree::sequence< CoordinateSystem_type > CoordinateSystem_sequence;
      typedef xsd::cxx::tree::sequence< CoordinateSystem_type >::iterator CoordinateSystem_iterator;
      typedef xsd::cxx::tree::sequence< CoordinateSystem_type >::const_iterator CoordinateSystem_const_iterator;
      typedef ::xsd::cxx::tree::traits< CoordinateSystem_type, wchar_t > CoordinateSystem_traits;

      const CoordinateSystem_sequence&
      CoordinateSystem () const;

      CoordinateSystem_sequence&
      CoordinateSystem ();

      void
      CoordinateSystem (const CoordinateSystem_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CoordinateSystemListType ();

      CoordinateSystemListType (const n_type&);

      CoordinateSystemListType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CoordinateSystemListType (const CoordinateSystemListType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CoordinateSystemListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemListType&
      operator= (const CoordinateSystemListType& x);

      virtual 
      ~CoordinateSystemListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CoordinateSystem_sequence CoordinateSystem_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL CoordinateSystemsType: public ::xml_schema::type
    {
      public:
      // CoordinateSystemDefinitions
      //
      typedef ::xsd::qif30::CoordinateSystemListType CoordinateSystemDefinitions_type;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemDefinitions_type, wchar_t > CoordinateSystemDefinitions_traits;

      const CoordinateSystemDefinitions_type&
      CoordinateSystemDefinitions () const;

      CoordinateSystemDefinitions_type&
      CoordinateSystemDefinitions ();

      void
      CoordinateSystemDefinitions (const CoordinateSystemDefinitions_type& x);

      void
      CoordinateSystemDefinitions (::std::unique_ptr< CoordinateSystemDefinitions_type > p);

      // CommonCoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CommonCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CommonCoordinateSystemId_type > CommonCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CommonCoordinateSystemId_type, wchar_t > CommonCoordinateSystemId_traits;

      const CommonCoordinateSystemId_optional&
      CommonCoordinateSystemId () const;

      CommonCoordinateSystemId_optional&
      CommonCoordinateSystemId ();

      void
      CommonCoordinateSystemId (const CommonCoordinateSystemId_type& x);

      void
      CommonCoordinateSystemId (const CommonCoordinateSystemId_optional& x);

      void
      CommonCoordinateSystemId (::std::unique_ptr< CommonCoordinateSystemId_type > p);

      // MachineCoordinateSystem
      //
      typedef ::xsd::qif30::MachineCoordinateSystemType MachineCoordinateSystem_type;
      typedef ::xsd::cxx::tree::sequence< MachineCoordinateSystem_type > MachineCoordinateSystem_sequence;
      typedef xsd::cxx::tree::sequence< MachineCoordinateSystem_type >::iterator MachineCoordinateSystem_iterator;
      typedef xsd::cxx::tree::sequence< MachineCoordinateSystem_type >::const_iterator MachineCoordinateSystem_const_iterator;
      typedef ::xsd::cxx::tree::traits< MachineCoordinateSystem_type, wchar_t > MachineCoordinateSystem_traits;

      const MachineCoordinateSystem_sequence&
      MachineCoordinateSystem () const;

      MachineCoordinateSystem_sequence&
      MachineCoordinateSystem ();

      void
      MachineCoordinateSystem (const MachineCoordinateSystem_sequence& s);

      // Constructors.
      //
      CoordinateSystemsType ();

      CoordinateSystemsType (const CoordinateSystemDefinitions_type&);

      CoordinateSystemsType (::std::unique_ptr< CoordinateSystemDefinitions_type >);

      CoordinateSystemsType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CoordinateSystemsType (const CoordinateSystemsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CoordinateSystemsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemsType&
      operator= (const CoordinateSystemsType& x);

      virtual 
      ~CoordinateSystemsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CoordinateSystemDefinitions_type > CoordinateSystemDefinitions_;
      CommonCoordinateSystemId_optional CommonCoordinateSystemId_;
      MachineCoordinateSystem_sequence MachineCoordinateSystem_;
    };

    class QIF30_SYMBOL_DECL CoordinateSystemType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // NominalTransform
      //
      typedef ::xsd::qif30::TransformMatrixType NominalTransform_type;
      typedef ::xsd::cxx::tree::optional< NominalTransform_type > NominalTransform_optional;
      typedef ::xsd::cxx::tree::traits< NominalTransform_type, wchar_t > NominalTransform_traits;

      const NominalTransform_optional&
      NominalTransform () const;

      NominalTransform_optional&
      NominalTransform ();

      void
      NominalTransform (const NominalTransform_type& x);

      void
      NominalTransform (const NominalTransform_optional& x);

      void
      NominalTransform (::std::unique_ptr< NominalTransform_type > p);

      // InternalCADCoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType InternalCADCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< InternalCADCoordinateSystemId_type > InternalCADCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< InternalCADCoordinateSystemId_type, wchar_t > InternalCADCoordinateSystemId_traits;

      const InternalCADCoordinateSystemId_optional&
      InternalCADCoordinateSystemId () const;

      InternalCADCoordinateSystemId_optional&
      InternalCADCoordinateSystemId ();

      void
      InternalCADCoordinateSystemId (const InternalCADCoordinateSystemId_type& x);

      void
      InternalCADCoordinateSystemId (const InternalCADCoordinateSystemId_optional& x);

      void
      InternalCADCoordinateSystemId (::std::unique_ptr< InternalCADCoordinateSystemId_type > p);

      // ExternalCADCoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType ExternalCADCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< ExternalCADCoordinateSystemId_type > ExternalCADCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< ExternalCADCoordinateSystemId_type, wchar_t > ExternalCADCoordinateSystemId_traits;

      const ExternalCADCoordinateSystemId_optional&
      ExternalCADCoordinateSystemId () const;

      ExternalCADCoordinateSystemId_optional&
      ExternalCADCoordinateSystemId ();

      void
      ExternalCADCoordinateSystemId (const ExternalCADCoordinateSystemId_type& x);

      void
      ExternalCADCoordinateSystemId (const ExternalCADCoordinateSystemId_optional& x);

      void
      ExternalCADCoordinateSystemId (::std::unique_ptr< ExternalCADCoordinateSystemId_type > p);

      // AlignmentOperations
      //
      typedef ::xsd::qif30::AlignmentOperationsType AlignmentOperations_type;
      typedef ::xsd::cxx::tree::optional< AlignmentOperations_type > AlignmentOperations_optional;
      typedef ::xsd::cxx::tree::traits< AlignmentOperations_type, wchar_t > AlignmentOperations_traits;

      const AlignmentOperations_optional&
      AlignmentOperations () const;

      AlignmentOperations_optional&
      AlignmentOperations ();

      void
      AlignmentOperations (const AlignmentOperations_type& x);

      void
      AlignmentOperations (const AlignmentOperations_optional& x);

      void
      AlignmentOperations (::std::unique_ptr< AlignmentOperations_type > p);

      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::optional< SequenceNumber_type > SequenceNumber_optional;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_optional&
      SequenceNumber () const;

      SequenceNumber_optional&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (const SequenceNumber_optional& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      CoordinateSystemType ();

      CoordinateSystemType (const id_type&);

      CoordinateSystemType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CoordinateSystemType (const CoordinateSystemType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CoordinateSystemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemType&
      operator= (const CoordinateSystemType& x);

      virtual 
      ~CoordinateSystemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Name_optional Name_;
      NominalTransform_optional NominalTransform_;
      InternalCADCoordinateSystemId_optional InternalCADCoordinateSystemId_;
      ExternalCADCoordinateSystemId_optional ExternalCADCoordinateSystemId_;
      AlignmentOperations_optional AlignmentOperations_;
      SequenceNumber_optional SequenceNumber_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL CoordinateSystemActualTransformAssociationType: public ::xml_schema::type
    {
      public:
      // ActualTransformId
      //
      typedef ::xsd::qif30::QIFReferenceType ActualTransformId_type;
      typedef ::xsd::cxx::tree::traits< ActualTransformId_type, wchar_t > ActualTransformId_traits;

      const ActualTransformId_type&
      ActualTransformId () const;

      ActualTransformId_type&
      ActualTransformId ();

      void
      ActualTransformId (const ActualTransformId_type& x);

      void
      ActualTransformId (::std::unique_ptr< ActualTransformId_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif30::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, wchar_t > CoordinateSystemId_traits;

      const CoordinateSystemId_type&
      CoordinateSystemId () const;

      CoordinateSystemId_type&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (::std::unique_ptr< CoordinateSystemId_type > p);

      // Constructors.
      //
      CoordinateSystemActualTransformAssociationType ();

      CoordinateSystemActualTransformAssociationType (const ActualTransformId_type&,
                                                      const CoordinateSystemId_type&);

      CoordinateSystemActualTransformAssociationType (::std::unique_ptr< ActualTransformId_type >,
                                                      ::std::unique_ptr< CoordinateSystemId_type >);

      CoordinateSystemActualTransformAssociationType (const xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      CoordinateSystemActualTransformAssociationType (const CoordinateSystemActualTransformAssociationType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual CoordinateSystemActualTransformAssociationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemActualTransformAssociationType&
      operator= (const CoordinateSystemActualTransformAssociationType& x);

      virtual 
      ~CoordinateSystemActualTransformAssociationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ActualTransformId_type > ActualTransformId_;
      ::xsd::cxx::tree::one< CoordinateSystemId_type > CoordinateSystemId_;
    };

    class QIF30_SYMBOL_DECL CoordinateSystemActualTransformAssociationsType: public ::xml_schema::type
    {
      public:
      // CoordinateSystemActualTransformAssociation
      //
      typedef ::xsd::qif30::CoordinateSystemActualTransformAssociationType CoordinateSystemActualTransformAssociation_type;
      typedef ::xsd::cxx::tree::sequence< CoordinateSystemActualTransformAssociation_type > CoordinateSystemActualTransformAssociation_sequence;
      typedef xsd::cxx::tree::sequence< CoordinateSystemActualTransformAssociation_type >::iterator CoordinateSystemActualTransformAssociation_iterator;
      typedef xsd::cxx::tree::sequence< CoordinateSystemActualTransformAssociation_type >::const_iterator CoordinateSystemActualTransformAssociation_const_iterator;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemActualTransformAssociation_type, wchar_t > CoordinateSystemActualTransformAssociation_traits;

      const CoordinateSystemActualTransformAssociation_sequence&
      CoordinateSystemActualTransformAssociation () const;

      CoordinateSystemActualTransformAssociation_sequence&
      CoordinateSystemActualTransformAssociation ();

      void
      CoordinateSystemActualTransformAssociation (const CoordinateSystemActualTransformAssociation_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CoordinateSystemActualTransformAssociationsType ();

      CoordinateSystemActualTransformAssociationsType (const n_type&);

      CoordinateSystemActualTransformAssociationsType (const xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      CoordinateSystemActualTransformAssociationsType (const CoordinateSystemActualTransformAssociationsType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual CoordinateSystemActualTransformAssociationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemActualTransformAssociationsType&
      operator= (const CoordinateSystemActualTransformAssociationsType& x);

      virtual 
      ~CoordinateSystemActualTransformAssociationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CoordinateSystemActualTransformAssociation_sequence CoordinateSystemActualTransformAssociation_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ThreadSpecificationDetailedBaseType: public ::xml_schema::type
    {
      public:
      // Diameter
      //
      typedef ::xsd::qif30::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::unique_ptr< Diameter_type > p);

      // ThreadSeries
      //
      typedef ::xsd::qif30::ThreadSeriesType ThreadSeries_type;
      typedef ::xsd::cxx::tree::traits< ThreadSeries_type, wchar_t > ThreadSeries_traits;

      const ThreadSeries_type&
      ThreadSeries () const;

      ThreadSeries_type&
      ThreadSeries ();

      void
      ThreadSeries (const ThreadSeries_type& x);

      void
      ThreadSeries (::std::unique_ptr< ThreadSeries_type > p);

      // ThreadToleranceClass
      //
      typedef ::xsd::qif30::ThreadClassType ThreadToleranceClass_type;
      typedef ::xsd::cxx::tree::traits< ThreadToleranceClass_type, wchar_t > ThreadToleranceClass_traits;

      const ThreadToleranceClass_type&
      ThreadToleranceClass () const;

      ThreadToleranceClass_type&
      ThreadToleranceClass ();

      void
      ThreadToleranceClass (const ThreadToleranceClass_type& x);

      void
      ThreadToleranceClass (::std::unique_ptr< ThreadToleranceClass_type > p);

      // CrestDiameterToleranceClass
      //
      typedef ::xsd::qif30::ThreadClassType CrestDiameterToleranceClass_type;
      typedef ::xsd::cxx::tree::optional< CrestDiameterToleranceClass_type > CrestDiameterToleranceClass_optional;
      typedef ::xsd::cxx::tree::traits< CrestDiameterToleranceClass_type, wchar_t > CrestDiameterToleranceClass_traits;

      const CrestDiameterToleranceClass_optional&
      CrestDiameterToleranceClass () const;

      CrestDiameterToleranceClass_optional&
      CrestDiameterToleranceClass ();

      void
      CrestDiameterToleranceClass (const CrestDiameterToleranceClass_type& x);

      void
      CrestDiameterToleranceClass (const CrestDiameterToleranceClass_optional& x);

      void
      CrestDiameterToleranceClass (::std::unique_ptr< CrestDiameterToleranceClass_type > p);

      // LeftHanded
      //
      typedef ::xml_schema::boolean LeftHanded_type;
      typedef ::xsd::cxx::tree::optional< LeftHanded_type > LeftHanded_optional;
      typedef ::xsd::cxx::tree::traits< LeftHanded_type, wchar_t > LeftHanded_traits;

      const LeftHanded_optional&
      LeftHanded () const;

      LeftHanded_optional&
      LeftHanded ();

      void
      LeftHanded (const LeftHanded_type& x);

      void
      LeftHanded (const LeftHanded_optional& x);

      // ModifiedThread
      //
      typedef ::xml_schema::boolean ModifiedThread_type;
      typedef ::xsd::cxx::tree::optional< ModifiedThread_type > ModifiedThread_optional;
      typedef ::xsd::cxx::tree::traits< ModifiedThread_type, wchar_t > ModifiedThread_traits;

      const ModifiedThread_optional&
      ModifiedThread () const;

      ModifiedThread_optional&
      ModifiedThread ();

      void
      ModifiedThread (const ModifiedThread_type& x);

      void
      ModifiedThread (const ModifiedThread_optional& x);

      // ThreadLengthEngagement
      //
      typedef ::xsd::qif30::LinearValueType ThreadLengthEngagement_type;
      typedef ::xsd::cxx::tree::optional< ThreadLengthEngagement_type > ThreadLengthEngagement_optional;
      typedef ::xsd::cxx::tree::traits< ThreadLengthEngagement_type, wchar_t > ThreadLengthEngagement_traits;

      const ThreadLengthEngagement_optional&
      ThreadLengthEngagement () const;

      ThreadLengthEngagement_optional&
      ThreadLengthEngagement ();

      void
      ThreadLengthEngagement (const ThreadLengthEngagement_type& x);

      void
      ThreadLengthEngagement (const ThreadLengthEngagement_optional& x);

      void
      ThreadLengthEngagement (::std::unique_ptr< ThreadLengthEngagement_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      ThreadSpecificationDetailedBaseType ();

      ThreadSpecificationDetailedBaseType (const Diameter_type&,
                                           const ThreadSeries_type&,
                                           const ThreadToleranceClass_type&,
                                           const id_type&);

      ThreadSpecificationDetailedBaseType (::std::unique_ptr< Diameter_type >,
                                           ::std::unique_ptr< ThreadSeries_type >,
                                           ::std::unique_ptr< ThreadToleranceClass_type >,
                                           const id_type&);

      ThreadSpecificationDetailedBaseType (const xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ThreadSpecificationDetailedBaseType (const ThreadSpecificationDetailedBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ThreadSpecificationDetailedBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      ThreadSpecificationDetailedBaseType&
      operator= (const ThreadSpecificationDetailedBaseType& x);

      virtual 
      ~ThreadSpecificationDetailedBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      ::xsd::cxx::tree::one< ThreadSeries_type > ThreadSeries_;
      ::xsd::cxx::tree::one< ThreadToleranceClass_type > ThreadToleranceClass_;
      CrestDiameterToleranceClass_optional CrestDiameterToleranceClass_;
      LeftHanded_optional LeftHanded_;
      ModifiedThread_optional ModifiedThread_;
      ThreadLengthEngagement_optional ThreadLengthEngagement_;
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL SingleLeadThreadSpecificationType: public ::xsd::qif30::ThreadSpecificationDetailedBaseType
    {
      public:
      // ThreadDensity
      //
      typedef ::xsd::qif30::SpecifiedDecimalType ThreadDensity_type;
      typedef ::xsd::cxx::tree::traits< ThreadDensity_type, wchar_t > ThreadDensity_traits;

      const ThreadDensity_type&
      ThreadDensity () const;

      ThreadDensity_type&
      ThreadDensity ();

      void
      ThreadDensity (const ThreadDensity_type& x);

      void
      ThreadDensity (::std::unique_ptr< ThreadDensity_type > p);

      // Constructors.
      //
      SingleLeadThreadSpecificationType ();

      SingleLeadThreadSpecificationType (const Diameter_type&,
                                         const ThreadSeries_type&,
                                         const ThreadToleranceClass_type&,
                                         const id_type&,
                                         const ThreadDensity_type&);

      SingleLeadThreadSpecificationType (::std::unique_ptr< Diameter_type >,
                                         ::std::unique_ptr< ThreadSeries_type >,
                                         ::std::unique_ptr< ThreadToleranceClass_type >,
                                         const id_type&,
                                         ::std::unique_ptr< ThreadDensity_type >);

      SingleLeadThreadSpecificationType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      SingleLeadThreadSpecificationType (const SingleLeadThreadSpecificationType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual SingleLeadThreadSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SingleLeadThreadSpecificationType&
      operator= (const SingleLeadThreadSpecificationType& x);

      virtual 
      ~SingleLeadThreadSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ThreadDensity_type > ThreadDensity_;
    };

    class QIF30_SYMBOL_DECL MultiLeadThreadSpecificationType: public ::xsd::qif30::ThreadSpecificationDetailedBaseType
    {
      public:
      // ThreadPitch
      //
      typedef ::xsd::qif30::LinearValueType ThreadPitch_type;
      typedef ::xsd::cxx::tree::traits< ThreadPitch_type, wchar_t > ThreadPitch_traits;

      const ThreadPitch_type&
      ThreadPitch () const;

      ThreadPitch_type&
      ThreadPitch ();

      void
      ThreadPitch (const ThreadPitch_type& x);

      void
      ThreadPitch (::std::unique_ptr< ThreadPitch_type > p);

      // ThreadLeadDistance
      //
      typedef ::xsd::qif30::LinearValueType ThreadLeadDistance_type;
      typedef ::xsd::cxx::tree::traits< ThreadLeadDistance_type, wchar_t > ThreadLeadDistance_traits;

      const ThreadLeadDistance_type&
      ThreadLeadDistance () const;

      ThreadLeadDistance_type&
      ThreadLeadDistance ();

      void
      ThreadLeadDistance (const ThreadLeadDistance_type& x);

      void
      ThreadLeadDistance (::std::unique_ptr< ThreadLeadDistance_type > p);

      // ThreadLeadStarts
      //
      typedef ::xsd::qif30::NaturalType ThreadLeadStarts_type;
      typedef ::xsd::cxx::tree::traits< ThreadLeadStarts_type, wchar_t > ThreadLeadStarts_traits;

      const ThreadLeadStarts_type&
      ThreadLeadStarts () const;

      ThreadLeadStarts_type&
      ThreadLeadStarts ();

      void
      ThreadLeadStarts (const ThreadLeadStarts_type& x);

      void
      ThreadLeadStarts (::std::unique_ptr< ThreadLeadStarts_type > p);

      // Constructors.
      //
      MultiLeadThreadSpecificationType ();

      MultiLeadThreadSpecificationType (const Diameter_type&,
                                        const ThreadSeries_type&,
                                        const ThreadToleranceClass_type&,
                                        const id_type&,
                                        const ThreadPitch_type&,
                                        const ThreadLeadDistance_type&,
                                        const ThreadLeadStarts_type&);

      MultiLeadThreadSpecificationType (::std::unique_ptr< Diameter_type >,
                                        ::std::unique_ptr< ThreadSeries_type >,
                                        ::std::unique_ptr< ThreadToleranceClass_type >,
                                        const id_type&,
                                        ::std::unique_ptr< ThreadPitch_type >,
                                        ::std::unique_ptr< ThreadLeadDistance_type >,
                                        const ThreadLeadStarts_type&);

      MultiLeadThreadSpecificationType (const xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      MultiLeadThreadSpecificationType (const MultiLeadThreadSpecificationType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual MultiLeadThreadSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MultiLeadThreadSpecificationType&
      operator= (const MultiLeadThreadSpecificationType& x);

      virtual 
      ~MultiLeadThreadSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ThreadPitch_type > ThreadPitch_;
      ::xsd::cxx::tree::one< ThreadLeadDistance_type > ThreadLeadDistance_;
      ::xsd::cxx::tree::one< ThreadLeadStarts_type > ThreadLeadStarts_;
    };

    class QIF30_SYMBOL_DECL ThreadSpecificationType: public ::xml_schema::type
    {
      public:
      // SingleLeadSpecification
      //
      typedef ::xsd::qif30::SingleLeadThreadSpecificationType SingleLeadSpecification_type;
      typedef ::xsd::cxx::tree::optional< SingleLeadSpecification_type > SingleLeadSpecification_optional;
      typedef ::xsd::cxx::tree::traits< SingleLeadSpecification_type, wchar_t > SingleLeadSpecification_traits;

      const SingleLeadSpecification_optional&
      SingleLeadSpecification () const;

      SingleLeadSpecification_optional&
      SingleLeadSpecification ();

      void
      SingleLeadSpecification (const SingleLeadSpecification_type& x);

      void
      SingleLeadSpecification (const SingleLeadSpecification_optional& x);

      void
      SingleLeadSpecification (::std::unique_ptr< SingleLeadSpecification_type > p);

      // MultiLeadSpecification
      //
      typedef ::xsd::qif30::MultiLeadThreadSpecificationType MultiLeadSpecification_type;
      typedef ::xsd::cxx::tree::optional< MultiLeadSpecification_type > MultiLeadSpecification_optional;
      typedef ::xsd::cxx::tree::traits< MultiLeadSpecification_type, wchar_t > MultiLeadSpecification_traits;

      const MultiLeadSpecification_optional&
      MultiLeadSpecification () const;

      MultiLeadSpecification_optional&
      MultiLeadSpecification ();

      void
      MultiLeadSpecification (const MultiLeadSpecification_type& x);

      void
      MultiLeadSpecification (const MultiLeadSpecification_optional& x);

      void
      MultiLeadSpecification (::std::unique_ptr< MultiLeadSpecification_type > p);

      // TextThreadSpecification
      //
      typedef ::xsd::qif30::TextThreadSpecificationType TextThreadSpecification_type;
      typedef ::xsd::cxx::tree::optional< TextThreadSpecification_type > TextThreadSpecification_optional;
      typedef ::xsd::cxx::tree::traits< TextThreadSpecification_type, wchar_t > TextThreadSpecification_traits;

      const TextThreadSpecification_optional&
      TextThreadSpecification () const;

      TextThreadSpecification_optional&
      TextThreadSpecification ();

      void
      TextThreadSpecification (const TextThreadSpecification_type& x);

      void
      TextThreadSpecification (const TextThreadSpecification_optional& x);

      void
      TextThreadSpecification (::std::unique_ptr< TextThreadSpecification_type > p);

      // Constructors.
      //
      ThreadSpecificationType ();

      ThreadSpecificationType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ThreadSpecificationType (const ThreadSpecificationType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ThreadSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadSpecificationType&
      operator= (const ThreadSpecificationType& x);

      virtual 
      ~ThreadSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SingleLeadSpecification_optional SingleLeadSpecification_;
      MultiLeadSpecification_optional MultiLeadSpecification_;
      TextThreadSpecification_optional TextThreadSpecification_;
    };

    class QIF30_SYMBOL_DECL TextThreadSpecificationType: public ::xml_schema::type
    {
      public:
      // TextSpecification
      //
      typedef ::xml_schema::string TextSpecification_type;
      typedef ::xsd::cxx::tree::traits< TextSpecification_type, wchar_t > TextSpecification_traits;

      const TextSpecification_type&
      TextSpecification () const;

      TextSpecification_type&
      TextSpecification ();

      void
      TextSpecification (const TextSpecification_type& x);

      void
      TextSpecification (::std::unique_ptr< TextSpecification_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      TextThreadSpecificationType ();

      TextThreadSpecificationType (const TextSpecification_type&,
                                   const id_type&);

      TextThreadSpecificationType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      TextThreadSpecificationType (const TextThreadSpecificationType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual TextThreadSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TextThreadSpecificationType&
      operator= (const TextThreadSpecificationType& x);

      virtual 
      ~TextThreadSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TextSpecification_type > TextSpecification_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL ThreadSpecificationsType: public ::xml_schema::type
    {
      public:
      // ThreadSpecification
      //
      typedef ::xsd::qif30::ThreadSpecificationType ThreadSpecification_type;
      typedef ::xsd::cxx::tree::sequence< ThreadSpecification_type > ThreadSpecification_sequence;
      typedef xsd::cxx::tree::sequence< ThreadSpecification_type >::iterator ThreadSpecification_iterator;
      typedef xsd::cxx::tree::sequence< ThreadSpecification_type >::const_iterator ThreadSpecification_const_iterator;
      typedef ::xsd::cxx::tree::traits< ThreadSpecification_type, wchar_t > ThreadSpecification_traits;

      const ThreadSpecification_sequence&
      ThreadSpecification () const;

      ThreadSpecification_sequence&
      ThreadSpecification ();

      void
      ThreadSpecification (const ThreadSpecification_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ThreadSpecificationsType ();

      ThreadSpecificationsType (const n_type&);

      ThreadSpecificationsType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ThreadSpecificationsType (const ThreadSpecificationsType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ThreadSpecificationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadSpecificationsType&
      operator= (const ThreadSpecificationsType& x);

      virtual 
      ~ThreadSpecificationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThreadSpecification_sequence ThreadSpecification_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ToleranceZonePerUnitAreaType: public ::xml_schema::type
    {
      public:
      // ToleranceValuePerUnit
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValuePerUnit_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValuePerUnit_type, wchar_t > ToleranceValuePerUnit_traits;

      const ToleranceValuePerUnit_type&
      ToleranceValuePerUnit () const;

      ToleranceValuePerUnit_type&
      ToleranceValuePerUnit ();

      void
      ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x);

      void
      ToleranceValuePerUnit (::std::unique_ptr< ToleranceValuePerUnit_type > p);

      // RectangularUnitArea
      //
      typedef ::xsd::qif30::RectangularUnitAreaType RectangularUnitArea_type;
      typedef ::xsd::cxx::tree::optional< RectangularUnitArea_type > RectangularUnitArea_optional;
      typedef ::xsd::cxx::tree::traits< RectangularUnitArea_type, wchar_t > RectangularUnitArea_traits;

      const RectangularUnitArea_optional&
      RectangularUnitArea () const;

      RectangularUnitArea_optional&
      RectangularUnitArea ();

      void
      RectangularUnitArea (const RectangularUnitArea_type& x);

      void
      RectangularUnitArea (const RectangularUnitArea_optional& x);

      void
      RectangularUnitArea (::std::unique_ptr< RectangularUnitArea_type > p);

      // CircularUnitArea
      //
      typedef ::xsd::qif30::CircularUnitAreaType CircularUnitArea_type;
      typedef ::xsd::cxx::tree::optional< CircularUnitArea_type > CircularUnitArea_optional;
      typedef ::xsd::cxx::tree::traits< CircularUnitArea_type, wchar_t > CircularUnitArea_traits;

      const CircularUnitArea_optional&
      CircularUnitArea () const;

      CircularUnitArea_optional&
      CircularUnitArea ();

      void
      CircularUnitArea (const CircularUnitArea_type& x);

      void
      CircularUnitArea (const CircularUnitArea_optional& x);

      void
      CircularUnitArea (::std::unique_ptr< CircularUnitArea_type > p);

      // Constructors.
      //
      ToleranceZonePerUnitAreaType ();

      ToleranceZonePerUnitAreaType (const ToleranceValuePerUnit_type&);

      ToleranceZonePerUnitAreaType (::std::unique_ptr< ToleranceValuePerUnit_type >);

      ToleranceZonePerUnitAreaType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ToleranceZonePerUnitAreaType (const ToleranceZonePerUnitAreaType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ToleranceZonePerUnitAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceZonePerUnitAreaType&
      operator= (const ToleranceZonePerUnitAreaType& x);

      virtual 
      ~ToleranceZonePerUnitAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValuePerUnit_type > ToleranceValuePerUnit_;
      RectangularUnitArea_optional RectangularUnitArea_;
      CircularUnitArea_optional CircularUnitArea_;
    };

    class QIF30_SYMBOL_DECL ToleranceZonePerUnitLengthType: public ::xml_schema::type
    {
      public:
      // ToleranceValuePerUnit
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValuePerUnit_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValuePerUnit_type, wchar_t > ToleranceValuePerUnit_traits;

      const ToleranceValuePerUnit_type&
      ToleranceValuePerUnit () const;

      ToleranceValuePerUnit_type&
      ToleranceValuePerUnit ();

      void
      ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x);

      void
      ToleranceValuePerUnit (::std::unique_ptr< ToleranceValuePerUnit_type > p);

      // UnitLength
      //
      typedef ::xsd::qif30::LinearValueType UnitLength_type;
      typedef ::xsd::cxx::tree::traits< UnitLength_type, wchar_t > UnitLength_traits;

      const UnitLength_type&
      UnitLength () const;

      UnitLength_type&
      UnitLength ();

      void
      UnitLength (const UnitLength_type& x);

      void
      UnitLength (::std::unique_ptr< UnitLength_type > p);

      // Constructors.
      //
      ToleranceZonePerUnitLengthType ();

      ToleranceZonePerUnitLengthType (const ToleranceValuePerUnit_type&,
                                      const UnitLength_type&);

      ToleranceZonePerUnitLengthType (::std::unique_ptr< ToleranceValuePerUnit_type >,
                                      ::std::unique_ptr< UnitLength_type >);

      ToleranceZonePerUnitLengthType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ToleranceZonePerUnitLengthType (const ToleranceZonePerUnitLengthType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ToleranceZonePerUnitLengthType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceZonePerUnitLengthType&
      operator= (const ToleranceZonePerUnitLengthType& x);

      virtual 
      ~ToleranceZonePerUnitLengthType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValuePerUnit_type > ToleranceValuePerUnit_;
      ::xsd::cxx::tree::one< UnitLength_type > UnitLength_;
    };

    class QIF30_SYMBOL_DECL ToleranceZonePerUnitAngleType: public ::xml_schema::type
    {
      public:
      // ToleranceValuePerUnit
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValuePerUnit_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValuePerUnit_type, wchar_t > ToleranceValuePerUnit_traits;

      const ToleranceValuePerUnit_type&
      ToleranceValuePerUnit () const;

      ToleranceValuePerUnit_type&
      ToleranceValuePerUnit ();

      void
      ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x);

      void
      ToleranceValuePerUnit (::std::unique_ptr< ToleranceValuePerUnit_type > p);

      // UnitAngle
      //
      typedef ::xsd::qif30::AngularValueType UnitAngle_type;
      typedef ::xsd::cxx::tree::traits< UnitAngle_type, wchar_t > UnitAngle_traits;

      const UnitAngle_type&
      UnitAngle () const;

      UnitAngle_type&
      UnitAngle ();

      void
      UnitAngle (const UnitAngle_type& x);

      void
      UnitAngle (::std::unique_ptr< UnitAngle_type > p);

      // Constructors.
      //
      ToleranceZonePerUnitAngleType ();

      ToleranceZonePerUnitAngleType (const ToleranceValuePerUnit_type&,
                                     const UnitAngle_type&);

      ToleranceZonePerUnitAngleType (::std::unique_ptr< ToleranceValuePerUnit_type >,
                                     ::std::unique_ptr< UnitAngle_type >);

      ToleranceZonePerUnitAngleType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ToleranceZonePerUnitAngleType (const ToleranceZonePerUnitAngleType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ToleranceZonePerUnitAngleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceZonePerUnitAngleType&
      operator= (const ToleranceZonePerUnitAngleType& x);

      virtual 
      ~ToleranceZonePerUnitAngleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValuePerUnit_type > ToleranceValuePerUnit_;
      ::xsd::cxx::tree::one< UnitAngle_type > UnitAngle_;
    };

    class QIF30_SYMBOL_DECL ToleranceZonePerUnitPolarAreaType: public ::xml_schema::type
    {
      public:
      // ToleranceValuePerUnit
      //
      typedef ::xsd::qif30::LinearValueType ToleranceValuePerUnit_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValuePerUnit_type, wchar_t > ToleranceValuePerUnit_traits;

      const ToleranceValuePerUnit_type&
      ToleranceValuePerUnit () const;

      ToleranceValuePerUnit_type&
      ToleranceValuePerUnit ();

      void
      ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x);

      void
      ToleranceValuePerUnit (::std::unique_ptr< ToleranceValuePerUnit_type > p);

      // UnitAngle
      //
      typedef ::xsd::qif30::AngularValueType UnitAngle_type;
      typedef ::xsd::cxx::tree::traits< UnitAngle_type, wchar_t > UnitAngle_traits;

      const UnitAngle_type&
      UnitAngle () const;

      UnitAngle_type&
      UnitAngle ();

      void
      UnitAngle (const UnitAngle_type& x);

      void
      UnitAngle (::std::unique_ptr< UnitAngle_type > p);

      // UnitLength
      //
      typedef ::xsd::qif30::LinearValueType UnitLength_type;
      typedef ::xsd::cxx::tree::traits< UnitLength_type, wchar_t > UnitLength_traits;

      const UnitLength_type&
      UnitLength () const;

      UnitLength_type&
      UnitLength ();

      void
      UnitLength (const UnitLength_type& x);

      void
      UnitLength (::std::unique_ptr< UnitLength_type > p);

      // Constructors.
      //
      ToleranceZonePerUnitPolarAreaType ();

      ToleranceZonePerUnitPolarAreaType (const ToleranceValuePerUnit_type&,
                                         const UnitAngle_type&,
                                         const UnitLength_type&);

      ToleranceZonePerUnitPolarAreaType (::std::unique_ptr< ToleranceValuePerUnit_type >,
                                         ::std::unique_ptr< UnitAngle_type >,
                                         ::std::unique_ptr< UnitLength_type >);

      ToleranceZonePerUnitPolarAreaType (const xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ToleranceZonePerUnitPolarAreaType (const ToleranceZonePerUnitPolarAreaType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ToleranceZonePerUnitPolarAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceZonePerUnitPolarAreaType&
      operator= (const ToleranceZonePerUnitPolarAreaType& x);

      virtual 
      ~ToleranceZonePerUnitPolarAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValuePerUnit_type > ToleranceValuePerUnit_;
      ::xsd::cxx::tree::one< UnitAngle_type > UnitAngle_;
      ::xsd::cxx::tree::one< UnitLength_type > UnitLength_;
    };

    class QIF30_SYMBOL_DECL DatumReferenceFramesType: public ::xml_schema::type
    {
      public:
      // DatumReferenceFrame
      //
      typedef ::xsd::qif30::DatumReferenceFrameType DatumReferenceFrame_type;
      typedef ::xsd::cxx::tree::sequence< DatumReferenceFrame_type > DatumReferenceFrame_sequence;
      typedef xsd::cxx::tree::sequence< DatumReferenceFrame_type >::iterator DatumReferenceFrame_iterator;
      typedef xsd::cxx::tree::sequence< DatumReferenceFrame_type >::const_iterator DatumReferenceFrame_const_iterator;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrame_type, wchar_t > DatumReferenceFrame_traits;

      const DatumReferenceFrame_sequence&
      DatumReferenceFrame () const;

      DatumReferenceFrame_sequence&
      DatumReferenceFrame ();

      void
      DatumReferenceFrame (const DatumReferenceFrame_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DatumReferenceFramesType ();

      DatumReferenceFramesType (const n_type&);

      DatumReferenceFramesType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DatumReferenceFramesType (const DatumReferenceFramesType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual DatumReferenceFramesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumReferenceFramesType&
      operator= (const DatumReferenceFramesType& x);

      virtual 
      ~DatumReferenceFramesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DatumReferenceFrame_sequence DatumReferenceFrame_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL EventBaseType: public ::xml_schema::type
    {
      public:
      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_type&
      Description () const;

      Description_type&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      EventBaseType ();

      EventBaseType (const Description_type&,
                     const id_type&);

      EventBaseType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      EventBaseType (const EventBaseType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual EventBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      EventBaseType&
      operator= (const EventBaseType& x);

      virtual 
      ~EventBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Description_type > Description_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL NotableEventType: public ::xsd::qif30::EventBaseType
    {
      public:
      // Active
      //
      typedef ::xml_schema::boolean Active_type;
      typedef ::xsd::cxx::tree::traits< Active_type, wchar_t > Active_traits;

      const Active_type&
      Active () const;

      Active_type&
      Active ();

      void
      Active (const Active_type& x);

      // Constructors.
      //
      NotableEventType ();

      NotableEventType (const Description_type&,
                        const id_type&,
                        const Active_type&);

      NotableEventType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      NotableEventType (const NotableEventType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual NotableEventType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NotableEventType&
      operator= (const NotableEventType& x);

      virtual 
      ~NotableEventType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Active_type > Active_;
    };

    class QIF30_SYMBOL_DECL NotableEventsType: public ::xml_schema::type
    {
      public:
      // NotableEvent
      //
      typedef ::xsd::qif30::NotableEventType NotableEvent_type;
      typedef ::xsd::cxx::tree::sequence< NotableEvent_type > NotableEvent_sequence;
      typedef xsd::cxx::tree::sequence< NotableEvent_type >::iterator NotableEvent_iterator;
      typedef xsd::cxx::tree::sequence< NotableEvent_type >::const_iterator NotableEvent_const_iterator;
      typedef ::xsd::cxx::tree::traits< NotableEvent_type, wchar_t > NotableEvent_traits;

      const NotableEvent_sequence&
      NotableEvent () const;

      NotableEvent_sequence&
      NotableEvent ();

      void
      NotableEvent (const NotableEvent_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      NotableEventsType ();

      NotableEventsType (const n_type&);

      NotableEventsType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      NotableEventsType (const NotableEventsType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual NotableEventsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NotableEventsType&
      operator= (const NotableEventsType& x);

      virtual 
      ~NotableEventsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NotableEvent_sequence NotableEvent_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL NotedEventType: public ::xsd::qif30::EventBaseType
    {
      public:
      // SequenceNumber
      //
      typedef ::xsd::qif30::NaturalType SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, wchar_t > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (::std::unique_ptr< SequenceNumber_type > p);

      // TimeOccurred
      //
      typedef ::xml_schema::date_time TimeOccurred_type;
      typedef ::xsd::cxx::tree::optional< TimeOccurred_type > TimeOccurred_optional;
      typedef ::xsd::cxx::tree::traits< TimeOccurred_type, wchar_t > TimeOccurred_traits;

      const TimeOccurred_optional&
      TimeOccurred () const;

      TimeOccurred_optional&
      TimeOccurred ();

      void
      TimeOccurred (const TimeOccurred_type& x);

      void
      TimeOccurred (const TimeOccurred_optional& x);

      void
      TimeOccurred (::std::unique_ptr< TimeOccurred_type > p);

      // NotableEventId
      //
      typedef ::xsd::qif30::QIFReferenceType NotableEventId_type;
      typedef ::xsd::cxx::tree::optional< NotableEventId_type > NotableEventId_optional;
      typedef ::xsd::cxx::tree::traits< NotableEventId_type, wchar_t > NotableEventId_traits;

      const NotableEventId_optional&
      NotableEventId () const;

      NotableEventId_optional&
      NotableEventId ();

      void
      NotableEventId (const NotableEventId_type& x);

      void
      NotableEventId (const NotableEventId_optional& x);

      void
      NotableEventId (::std::unique_ptr< NotableEventId_type > p);

      // Constructors.
      //
      NotedEventType ();

      NotedEventType (const Description_type&,
                      const id_type&,
                      const SequenceNumber_type&);

      NotedEventType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      NotedEventType (const NotedEventType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual NotedEventType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NotedEventType&
      operator= (const NotedEventType& x);

      virtual 
      ~NotedEventType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
      TimeOccurred_optional TimeOccurred_;
      NotableEventId_optional NotableEventId_;
    };

    class QIF30_SYMBOL_DECL NotedEventsType: public ::xml_schema::type
    {
      public:
      // NotedEvent
      //
      typedef ::xsd::qif30::NotedEventType NotedEvent_type;
      typedef ::xsd::cxx::tree::sequence< NotedEvent_type > NotedEvent_sequence;
      typedef xsd::cxx::tree::sequence< NotedEvent_type >::iterator NotedEvent_iterator;
      typedef xsd::cxx::tree::sequence< NotedEvent_type >::const_iterator NotedEvent_const_iterator;
      typedef ::xsd::cxx::tree::traits< NotedEvent_type, wchar_t > NotedEvent_traits;

      const NotedEvent_sequence&
      NotedEvent () const;

      NotedEvent_sequence&
      NotedEvent ();

      void
      NotedEvent (const NotedEvent_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      NotedEventsType ();

      NotedEventsType (const n_type&);

      NotedEventsType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      NotedEventsType (const NotedEventsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual NotedEventsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NotedEventsType&
      operator= (const NotedEventsType& x);

      virtual 
      ~NotedEventsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NotedEvent_sequence NotedEvent_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL InspectionStatusEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PASS,
        FAIL,
        REWORK,
        SYSERROR,
        UNKNOWN,
        NOT_CALCULATED,
        NOT_MEASURED,
        UNDEFINED
      };

      InspectionStatusEnumType ();

      InspectionStatusEnumType (value v);

      InspectionStatusEnumType (const wchar_t* v);

      InspectionStatusEnumType (const ::std::wstring& v);

      InspectionStatusEnumType (const ::xml_schema::nmtoken& v);

      InspectionStatusEnumType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      InspectionStatusEnumType (const xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      InspectionStatusEnumType (const ::std::wstring& s,
                                const xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      InspectionStatusEnumType (const InspectionStatusEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      InspectionStatusEnumType&
      operator= (const InspectionStatusEnumType&) = default;
#endif

      virtual InspectionStatusEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InspectionStatusEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_InspectionStatusEnumType_convert ();
      }

      protected:
      value
      _xsd_InspectionStatusEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_InspectionStatusEnumType_literals_[8];
      static const value _xsd_InspectionStatusEnumType_indexes_[8];
    };

    class QIF30_SYMBOL_DECL InspectionStatusType: public ::xml_schema::type
    {
      public:
      // InspectionStatusEnum
      //
      typedef ::xsd::qif30::InspectionStatusEnumType InspectionStatusEnum_type;
      typedef ::xsd::cxx::tree::optional< InspectionStatusEnum_type > InspectionStatusEnum_optional;
      typedef ::xsd::cxx::tree::traits< InspectionStatusEnum_type, wchar_t > InspectionStatusEnum_traits;

      const InspectionStatusEnum_optional&
      InspectionStatusEnum () const;

      InspectionStatusEnum_optional&
      InspectionStatusEnum ();

      void
      InspectionStatusEnum (const InspectionStatusEnum_type& x);

      void
      InspectionStatusEnum (const InspectionStatusEnum_optional& x);

      void
      InspectionStatusEnum (::std::unique_ptr< InspectionStatusEnum_type > p);

      // OtherInspectionStatus
      //
      typedef ::xml_schema::string OtherInspectionStatus_type;
      typedef ::xsd::cxx::tree::optional< OtherInspectionStatus_type > OtherInspectionStatus_optional;
      typedef ::xsd::cxx::tree::traits< OtherInspectionStatus_type, wchar_t > OtherInspectionStatus_traits;

      const OtherInspectionStatus_optional&
      OtherInspectionStatus () const;

      OtherInspectionStatus_optional&
      OtherInspectionStatus ();

      void
      OtherInspectionStatus (const OtherInspectionStatus_type& x);

      void
      OtherInspectionStatus (const OtherInspectionStatus_optional& x);

      void
      OtherInspectionStatus (::std::unique_ptr< OtherInspectionStatus_type > p);

      // Constructors.
      //
      InspectionStatusType ();

      InspectionStatusType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      InspectionStatusType (const InspectionStatusType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual InspectionStatusType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InspectionStatusType&
      operator= (const InspectionStatusType& x);

      virtual 
      ~InspectionStatusType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      InspectionStatusEnum_optional InspectionStatusEnum_;
      OtherInspectionStatus_optional OtherInspectionStatus_;
    };

    class QIF30_SYMBOL_DECL EntityExternalType: public ::xml_schema::type
    {
      public:
      // EntityId
      //
      typedef ::xml_schema::token EntityId_type;
      typedef ::xsd::cxx::tree::traits< EntityId_type, wchar_t > EntityId_traits;

      const EntityId_type&
      EntityId () const;

      EntityId_type&
      EntityId ();

      void
      EntityId (const EntityId_type& x);

      void
      EntityId (::std::unique_ptr< EntityId_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      EntityExternalType ();

      EntityExternalType (const EntityId_type&,
                          const id_type&);

      EntityExternalType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      EntityExternalType (const EntityExternalType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual EntityExternalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EntityExternalType&
      operator= (const EntityExternalType& x);

      virtual 
      ~EntityExternalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< EntityId_type > EntityId_;
      Name_optional Name_;
      Description_optional Description_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL EntitiesExternalType: public ::xml_schema::type
    {
      public:
      // Entity
      //
      typedef ::xsd::qif30::EntityExternalType Entity_type;
      typedef ::xsd::cxx::tree::sequence< Entity_type > Entity_sequence;
      typedef xsd::cxx::tree::sequence< Entity_type >::iterator Entity_iterator;
      typedef xsd::cxx::tree::sequence< Entity_type >::const_iterator Entity_const_iterator;
      typedef ::xsd::cxx::tree::traits< Entity_type, wchar_t > Entity_traits;

      const Entity_sequence&
      Entity () const;

      Entity_sequence&
      Entity ();

      void
      Entity (const Entity_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      EntitiesExternalType ();

      EntitiesExternalType (const n_type&);

      EntitiesExternalType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      EntitiesExternalType (const EntitiesExternalType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual EntitiesExternalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EntitiesExternalType&
      operator= (const EntitiesExternalType& x);

      virtual 
      ~EntitiesExternalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Entity_sequence Entity_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL ZoneDataType: public ::xml_schema::type
    {
      public:
      // FeatureItemId
      //
      typedef ::xsd::qif30::QIFReferenceType FeatureItemId_type;
      typedef ::xsd::cxx::tree::traits< FeatureItemId_type, wchar_t > FeatureItemId_traits;

      const FeatureItemId_type&
      FeatureItemId () const;

      FeatureItemId_type&
      FeatureItemId ();

      void
      FeatureItemId (const FeatureItemId_type& x);

      void
      FeatureItemId (::std::unique_ptr< FeatureItemId_type > p);

      // Bonus
      //
      typedef ::xsd::qif30::LinearValueType Bonus_type;
      typedef ::xsd::cxx::tree::traits< Bonus_type, wchar_t > Bonus_traits;

      const Bonus_type&
      Bonus () const;

      Bonus_type&
      Bonus ();

      void
      Bonus (const Bonus_type& x);

      void
      Bonus (::std::unique_ptr< Bonus_type > p);

      // ReferenceLength
      //
      typedef ::xsd::qif30::LinearValueType ReferenceLength_type;
      typedef ::xsd::cxx::tree::traits< ReferenceLength_type, wchar_t > ReferenceLength_traits;

      const ReferenceLength_type&
      ReferenceLength () const;

      ReferenceLength_type&
      ReferenceLength ();

      void
      ReferenceLength (const ReferenceLength_type& x);

      void
      ReferenceLength (::std::unique_ptr< ReferenceLength_type > p);

      // Constructors.
      //
      ZoneDataType ();

      ZoneDataType (const FeatureItemId_type&,
                    const Bonus_type&,
                    const ReferenceLength_type&);

      ZoneDataType (::std::unique_ptr< FeatureItemId_type >,
                    ::std::unique_ptr< Bonus_type >,
                    ::std::unique_ptr< ReferenceLength_type >);

      ZoneDataType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ZoneDataType (const ZoneDataType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ZoneDataType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ZoneDataType&
      operator= (const ZoneDataType& x);

      virtual 
      ~ZoneDataType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureItemId_type > FeatureItemId_;
      ::xsd::cxx::tree::one< Bonus_type > Bonus_;
      ::xsd::cxx::tree::one< ReferenceLength_type > ReferenceLength_;
    };

    class QIF30_SYMBOL_DECL ZoneDataSetType: public ::xml_schema::type
    {
      public:
      // ZoneData
      //
      typedef ::xsd::qif30::ZoneDataType ZoneData_type;
      typedef ::xsd::cxx::tree::sequence< ZoneData_type > ZoneData_sequence;
      typedef xsd::cxx::tree::sequence< ZoneData_type >::iterator ZoneData_iterator;
      typedef xsd::cxx::tree::sequence< ZoneData_type >::const_iterator ZoneData_const_iterator;
      typedef ::xsd::cxx::tree::traits< ZoneData_type, wchar_t > ZoneData_traits;

      const ZoneData_sequence&
      ZoneData () const;

      ZoneData_sequence&
      ZoneData ();

      void
      ZoneData (const ZoneData_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ZoneDataSetType ();

      ZoneDataSetType (const n_type&);

      ZoneDataSetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ZoneDataSetType (const ZoneDataSetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ZoneDataSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ZoneDataSetType&
      operator= (const ZoneDataSetType& x);

      virtual 
      ~ZoneDataSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ZoneData_sequence ZoneData_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL LinearToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::LinearValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MaxDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType MaxDualValue_type;
      typedef ::xsd::cxx::tree::optional< MaxDualValue_type > MaxDualValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxDualValue_type, wchar_t > MaxDualValue_traits;

      const MaxDualValue_optional&
      MaxDualValue () const;

      MaxDualValue_optional&
      MaxDualValue ();

      void
      MaxDualValue (const MaxDualValue_type& x);

      void
      MaxDualValue (const MaxDualValue_optional& x);

      void
      MaxDualValue (::std::unique_ptr< MaxDualValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::LinearValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // MinDualValue
      //
      typedef ::xsd::qif30::LinearDualValueType MinDualValue_type;
      typedef ::xsd::cxx::tree::optional< MinDualValue_type > MinDualValue_optional;
      typedef ::xsd::cxx::tree::traits< MinDualValue_type, wchar_t > MinDualValue_traits;

      const MinDualValue_optional&
      MinDualValue () const;

      MinDualValue_optional&
      MinDualValue ();

      void
      MinDualValue (const MinDualValue_type& x);

      void
      MinDualValue (const MinDualValue_optional& x);

      void
      MinDualValue (::std::unique_ptr< MinDualValue_type > p);

      // DefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DefinitionId_type;
      typedef ::xsd::cxx::tree::optional< DefinitionId_type > DefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< DefinitionId_type, wchar_t > DefinitionId_traits;

      const DefinitionId_optional&
      DefinitionId () const;

      DefinitionId_optional&
      DefinitionId ();

      void
      DefinitionId (const DefinitionId_type& x);

      void
      DefinitionId (const DefinitionId_optional& x);

      void
      DefinitionId (::std::unique_ptr< DefinitionId_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      LinearToleranceType ();

      LinearToleranceType (const DefinedAsLimit_type&);

      LinearToleranceType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      LinearToleranceType (const LinearToleranceType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual LinearToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearToleranceType&
      operator= (const LinearToleranceType& x);

      virtual 
      ~LinearToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MaxDualValue_optional MaxDualValue_;
      MinValue_optional MinValue_;
      MinDualValue_optional MinDualValue_;
      DefinitionId_optional DefinitionId_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL LinearToleranceDefinitionType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::LinearValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::LinearValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      LinearToleranceDefinitionType ();

      LinearToleranceDefinitionType (const id_type&);

      LinearToleranceDefinitionType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      LinearToleranceDefinitionType (const LinearToleranceDefinitionType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual LinearToleranceDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearToleranceDefinitionType&
      operator= (const LinearToleranceDefinitionType& x);

      virtual 
      ~LinearToleranceDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL AngularToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::AngularValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::AngularValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinitionId
      //
      typedef ::xsd::qif30::QIFReferenceFullType DefinitionId_type;
      typedef ::xsd::cxx::tree::optional< DefinitionId_type > DefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< DefinitionId_type, wchar_t > DefinitionId_traits;

      const DefinitionId_optional&
      DefinitionId () const;

      DefinitionId_optional&
      DefinitionId ();

      void
      DefinitionId (const DefinitionId_type& x);

      void
      DefinitionId (const DefinitionId_optional& x);

      void
      DefinitionId (::std::unique_ptr< DefinitionId_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      AngularToleranceType ();

      AngularToleranceType (const DefinedAsLimit_type&);

      AngularToleranceType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      AngularToleranceType (const AngularToleranceType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual AngularToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularToleranceType&
      operator= (const AngularToleranceType& x);

      virtual 
      ~AngularToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      DefinitionId_optional DefinitionId_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL AngularToleranceDefinitionType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // MaxValue
      //
      typedef ::xsd::qif30::AngularValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::AngularValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      AngularToleranceDefinitionType ();

      AngularToleranceDefinitionType (const id_type&);

      AngularToleranceDefinitionType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      AngularToleranceDefinitionType (const AngularToleranceDefinitionType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual AngularToleranceDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularToleranceDefinitionType&
      operator= (const AngularToleranceDefinitionType& x);

      virtual 
      ~AngularToleranceDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL TemperatureToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::TemperatureValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::TemperatureValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      TemperatureToleranceType ();

      TemperatureToleranceType (const DefinedAsLimit_type&);

      TemperatureToleranceType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      TemperatureToleranceType (const TemperatureToleranceType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual TemperatureToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureToleranceType&
      operator= (const TemperatureToleranceType& x);

      virtual 
      ~TemperatureToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL AreaToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::AreaValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::AreaValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      AreaToleranceType ();

      AreaToleranceType (const DefinedAsLimit_type&);

      AreaToleranceType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AreaToleranceType (const AreaToleranceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AreaToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AreaToleranceType&
      operator= (const AreaToleranceType& x);

      virtual 
      ~AreaToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL ForceToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::ForceValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::ForceValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      ForceToleranceType ();

      ForceToleranceType (const DefinedAsLimit_type&);

      ForceToleranceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ForceToleranceType (const ForceToleranceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ForceToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ForceToleranceType&
      operator= (const ForceToleranceType& x);

      virtual 
      ~ForceToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL MassToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::MassValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::MassValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      MassToleranceType ();

      MassToleranceType (const DefinedAsLimit_type&);

      MassToleranceType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      MassToleranceType (const MassToleranceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual MassToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MassToleranceType&
      operator= (const MassToleranceType& x);

      virtual 
      ~MassToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL PressureToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::PressureValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::PressureValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      PressureToleranceType ();

      PressureToleranceType (const DefinedAsLimit_type&);

      PressureToleranceType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      PressureToleranceType (const PressureToleranceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual PressureToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PressureToleranceType&
      operator= (const PressureToleranceType& x);

      virtual 
      ~PressureToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL SpeedToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::SpeedValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::SpeedValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      SpeedToleranceType ();

      SpeedToleranceType (const DefinedAsLimit_type&);

      SpeedToleranceType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SpeedToleranceType (const SpeedToleranceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SpeedToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpeedToleranceType&
      operator= (const SpeedToleranceType& x);

      virtual 
      ~SpeedToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL TimeToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif30::TimeValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, wchar_t > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::unique_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif30::TimeValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, wchar_t > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::unique_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, wchar_t > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      TimeToleranceType ();

      TimeToleranceType (const DefinedAsLimit_type&);

      TimeToleranceType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      TimeToleranceType (const TimeToleranceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual TimeToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TimeToleranceType&
      operator= (const TimeToleranceType& x);

      virtual 
      ~TimeToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL DimensionModifierEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        BASIC_OR_TED,
        SET,
        REFERENCE_OR_AUXILIARY
      };

      DimensionModifierEnumType ();

      DimensionModifierEnumType (value v);

      DimensionModifierEnumType (const wchar_t* v);

      DimensionModifierEnumType (const ::std::wstring& v);

      DimensionModifierEnumType (const ::xml_schema::nmtoken& v);

      DimensionModifierEnumType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      DimensionModifierEnumType (const xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      DimensionModifierEnumType (const ::std::wstring& s,
                                 const xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      DimensionModifierEnumType (const DimensionModifierEnumType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DimensionModifierEnumType&
      operator= (const DimensionModifierEnumType&) = default;
#endif

      virtual DimensionModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DimensionModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DimensionModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_DimensionModifierEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DimensionModifierEnumType_literals_[3];
      static const value _xsd_DimensionModifierEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL DimensionDeterminationEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        LP,
        LS,
        GG,
        GX,
        GN,
        GC,
        CC,
        CA,
        CV
      };

      DimensionDeterminationEnumType ();

      DimensionDeterminationEnumType (value v);

      DimensionDeterminationEnumType (const wchar_t* v);

      DimensionDeterminationEnumType (const ::std::wstring& v);

      DimensionDeterminationEnumType (const ::xml_schema::nmtoken& v);

      DimensionDeterminationEnumType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      DimensionDeterminationEnumType (const xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      DimensionDeterminationEnumType (const ::std::wstring& s,
                                      const xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      DimensionDeterminationEnumType (const DimensionDeterminationEnumType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      DimensionDeterminationEnumType&
      operator= (const DimensionDeterminationEnumType&) = default;
#endif

      virtual DimensionDeterminationEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DimensionDeterminationEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DimensionDeterminationEnumType_convert ();
      }

      protected:
      value
      _xsd_DimensionDeterminationEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_DimensionDeterminationEnumType_literals_[9];
      static const value _xsd_DimensionDeterminationEnumType_indexes_[9];
    };

    class QIF30_SYMBOL_DECL SignificantDimensionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        SX,
        SN,
        SA,
        SM,
        SD,
        SR,
        SQ
      };

      SignificantDimensionEnumType ();

      SignificantDimensionEnumType (value v);

      SignificantDimensionEnumType (const wchar_t* v);

      SignificantDimensionEnumType (const ::std::wstring& v);

      SignificantDimensionEnumType (const ::xml_schema::nmtoken& v);

      SignificantDimensionEnumType (const xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SignificantDimensionEnumType (const xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SignificantDimensionEnumType (const ::std::wstring& s,
                                    const xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      SignificantDimensionEnumType (const SignificantDimensionEnumType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      SignificantDimensionEnumType&
      operator= (const SignificantDimensionEnumType&) = default;
#endif

      virtual SignificantDimensionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignificantDimensionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SignificantDimensionEnumType_convert ();
      }

      protected:
      value
      _xsd_SignificantDimensionEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_SignificantDimensionEnumType_literals_[7];
      static const value _xsd_SignificantDimensionEnumType_indexes_[7];
    };

    class QIF30_SYMBOL_DECL DimensionModifiersType: public ::xml_schema::type
    {
      public:
      // DeterminationModifier
      //
      typedef ::xsd::qif30::DimensionDeterminationEnumType DeterminationModifier_type;
      typedef ::xsd::cxx::tree::optional< DeterminationModifier_type > DeterminationModifier_optional;
      typedef ::xsd::cxx::tree::traits< DeterminationModifier_type, wchar_t > DeterminationModifier_traits;

      const DeterminationModifier_optional&
      DeterminationModifier () const;

      DeterminationModifier_optional&
      DeterminationModifier ();

      void
      DeterminationModifier (const DeterminationModifier_type& x);

      void
      DeterminationModifier (const DeterminationModifier_optional& x);

      void
      DeterminationModifier (::std::unique_ptr< DeterminationModifier_type > p);

      // SignificanceModifier
      //
      typedef ::xsd::qif30::SignificantDimensionEnumType SignificanceModifier_type;
      typedef ::xsd::cxx::tree::optional< SignificanceModifier_type > SignificanceModifier_optional;
      typedef ::xsd::cxx::tree::traits< SignificanceModifier_type, wchar_t > SignificanceModifier_traits;

      const SignificanceModifier_optional&
      SignificanceModifier () const;

      SignificanceModifier_optional&
      SignificanceModifier ();

      void
      SignificanceModifier (const SignificanceModifier_type& x);

      void
      SignificanceModifier (const SignificanceModifier_optional& x);

      void
      SignificanceModifier (::std::unique_ptr< SignificanceModifier_type > p);

      // SectionModifier
      //
      typedef ::xsd::qif30::SectionModifierEnumType SectionModifier_type;
      typedef ::xsd::cxx::tree::optional< SectionModifier_type > SectionModifier_optional;
      typedef ::xsd::cxx::tree::traits< SectionModifier_type, wchar_t > SectionModifier_traits;

      const SectionModifier_optional&
      SectionModifier () const;

      SectionModifier_optional&
      SectionModifier ();

      void
      SectionModifier (const SectionModifier_type& x);

      void
      SectionModifier (const SectionModifier_optional& x);

      void
      SectionModifier (::std::unique_ptr< SectionModifier_type > p);

      // Constructors.
      //
      DimensionModifiersType ();

      DimensionModifiersType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      DimensionModifiersType (const DimensionModifiersType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual DimensionModifiersType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DimensionModifiersType&
      operator= (const DimensionModifiersType& x);

      virtual 
      ~DimensionModifiersType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DeterminationModifier_optional DeterminationModifier_;
      SignificanceModifier_optional SignificanceModifier_;
      SectionModifier_optional SectionModifier_;
    };

    class QIF30_SYMBOL_DECL NonToleranceEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        MEASURED,
        SET
      };

      NonToleranceEnumType ();

      NonToleranceEnumType (value v);

      NonToleranceEnumType (const wchar_t* v);

      NonToleranceEnumType (const ::std::wstring& v);

      NonToleranceEnumType (const ::xml_schema::nmtoken& v);

      NonToleranceEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonToleranceEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonToleranceEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonToleranceEnumType (const NonToleranceEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      NonToleranceEnumType&
      operator= (const NonToleranceEnumType&) = default;
#endif

      virtual NonToleranceEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NonToleranceEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_NonToleranceEnumType_convert ();
      }

      protected:
      value
      _xsd_NonToleranceEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_NonToleranceEnumType_literals_[2];
      static const value _xsd_NonToleranceEnumType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL LimitsAndFitsZoneVarianceType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        HOLE,
        SHAFT
      };

      LimitsAndFitsZoneVarianceType ();

      LimitsAndFitsZoneVarianceType (value v);

      LimitsAndFitsZoneVarianceType (const wchar_t* v);

      LimitsAndFitsZoneVarianceType (const ::std::wstring& v);

      LimitsAndFitsZoneVarianceType (const ::xml_schema::nmtoken& v);

      LimitsAndFitsZoneVarianceType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      LimitsAndFitsZoneVarianceType (const xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      LimitsAndFitsZoneVarianceType (const ::std::wstring& s,
                                     const xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      LimitsAndFitsZoneVarianceType (const LimitsAndFitsZoneVarianceType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      LimitsAndFitsZoneVarianceType&
      operator= (const LimitsAndFitsZoneVarianceType&) = default;
#endif

      virtual LimitsAndFitsZoneVarianceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LimitsAndFitsZoneVarianceType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LimitsAndFitsZoneVarianceType_convert ();
      }

      protected:
      value
      _xsd_LimitsAndFitsZoneVarianceType_convert () const;

      public:
      static const wchar_t* const _xsd_LimitsAndFitsZoneVarianceType_literals_[2];
      static const value _xsd_LimitsAndFitsZoneVarianceType_indexes_[2];
    };

    class QIF30_SYMBOL_DECL LimitsAndFitsSpecificationType: public ::xml_schema::type
    {
      public:
      // FormVariance
      //
      typedef ::xml_schema::token FormVariance_type;
      typedef ::xsd::cxx::tree::traits< FormVariance_type, wchar_t > FormVariance_traits;

      const FormVariance_type&
      FormVariance () const;

      FormVariance_type&
      FormVariance ();

      void
      FormVariance (const FormVariance_type& x);

      void
      FormVariance (::std::unique_ptr< FormVariance_type > p);

      // Grade
      //
      typedef ::xml_schema::token Grade_type;
      typedef ::xsd::cxx::tree::traits< Grade_type, wchar_t > Grade_traits;

      const Grade_type&
      Grade () const;

      Grade_type&
      Grade ();

      void
      Grade (const Grade_type& x);

      void
      Grade (::std::unique_ptr< Grade_type > p);

      // zoneVariance
      //
      typedef ::xsd::qif30::LimitsAndFitsZoneVarianceType zoneVariance_type;
      typedef ::xsd::cxx::tree::traits< zoneVariance_type, wchar_t > zoneVariance_traits;

      const zoneVariance_type&
      zoneVariance () const;

      zoneVariance_type&
      zoneVariance ();

      void
      zoneVariance (const zoneVariance_type& x);

      void
      zoneVariance (::std::unique_ptr< zoneVariance_type > p);

      // Constructors.
      //
      LimitsAndFitsSpecificationType ();

      LimitsAndFitsSpecificationType (const FormVariance_type&,
                                      const Grade_type&,
                                      const zoneVariance_type&);

      LimitsAndFitsSpecificationType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      LimitsAndFitsSpecificationType (const LimitsAndFitsSpecificationType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual LimitsAndFitsSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LimitsAndFitsSpecificationType&
      operator= (const LimitsAndFitsSpecificationType& x);

      virtual 
      ~LimitsAndFitsSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FormVariance_type > FormVariance_;
      ::xsd::cxx::tree::one< Grade_type > Grade_;
      ::xsd::cxx::tree::one< zoneVariance_type > zoneVariance_;
    };

    class QIF30_SYMBOL_DECL CommonFileSpecEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        AVI,
        BMP,
        DOC,
        DOCX,
        DXF,
        DTD,
        GIF,
        GZIP,
        HTML,
        IGES,
        JPEG,
        JPG,
        MOV,
        MPEG,
        MPG,
        PDF,
        PNG,
        PPM,
        PPT,
        PRT,
        RAR,
        RTF,
        STL,
        STEP,
        STP,
        TAR,
        TIF,
        TIFF,
        TXT,
        WMV,
        XLS,
        XLSX,
        XML,
        XSD,
        X_T,
        ZIP
      };

      CommonFileSpecEnumType ();

      CommonFileSpecEnumType (value v);

      CommonFileSpecEnumType (const wchar_t* v);

      CommonFileSpecEnumType (const ::std::wstring& v);

      CommonFileSpecEnumType (const ::xml_schema::nmtoken& v);

      CommonFileSpecEnumType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CommonFileSpecEnumType (const xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CommonFileSpecEnumType (const ::std::wstring& s,
                              const xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CommonFileSpecEnumType (const CommonFileSpecEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      CommonFileSpecEnumType&
      operator= (const CommonFileSpecEnumType&) = default;
#endif

      virtual CommonFileSpecEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CommonFileSpecEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CommonFileSpecEnumType_convert ();
      }

      protected:
      value
      _xsd_CommonFileSpecEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_CommonFileSpecEnumType_literals_[36];
      static const value _xsd_CommonFileSpecEnumType_indexes_[36];
    };

    class QIF30_SYMBOL_DECL FileSpecType: public ::xml_schema::type
    {
      public:
      // CommonFileSpecEnum
      //
      typedef ::xsd::qif30::CommonFileSpecEnumType CommonFileSpecEnum_type;
      typedef ::xsd::cxx::tree::optional< CommonFileSpecEnum_type > CommonFileSpecEnum_optional;
      typedef ::xsd::cxx::tree::traits< CommonFileSpecEnum_type, wchar_t > CommonFileSpecEnum_traits;

      const CommonFileSpecEnum_optional&
      CommonFileSpecEnum () const;

      CommonFileSpecEnum_optional&
      CommonFileSpecEnum ();

      void
      CommonFileSpecEnum (const CommonFileSpecEnum_type& x);

      void
      CommonFileSpecEnum (const CommonFileSpecEnum_optional& x);

      void
      CommonFileSpecEnum (::std::unique_ptr< CommonFileSpecEnum_type > p);

      // OtherFileSpec
      //
      typedef ::xml_schema::string OtherFileSpec_type;
      typedef ::xsd::cxx::tree::optional< OtherFileSpec_type > OtherFileSpec_optional;
      typedef ::xsd::cxx::tree::traits< OtherFileSpec_type, wchar_t > OtherFileSpec_traits;

      const OtherFileSpec_optional&
      OtherFileSpec () const;

      OtherFileSpec_optional&
      OtherFileSpec ();

      void
      OtherFileSpec (const OtherFileSpec_type& x);

      void
      OtherFileSpec (const OtherFileSpec_optional& x);

      void
      OtherFileSpec (::std::unique_ptr< OtherFileSpec_type > p);

      // Constructors.
      //
      FileSpecType ();

      FileSpecType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      FileSpecType (const FileSpecType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual FileSpecType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileSpecType&
      operator= (const FileSpecType& x);

      virtual 
      ~FileSpecType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      CommonFileSpecEnum_optional CommonFileSpecEnum_;
      OtherFileSpec_optional OtherFileSpec_;
    };

    class QIF30_SYMBOL_DECL ExternalFileReferenceType: public ::xml_schema::type
    {
      public:
      // URI
      //
      typedef ::xml_schema::uri URI_type;
      typedef ::xsd::cxx::tree::traits< URI_type, wchar_t > URI_traits;

      const URI_type&
      URI () const;

      URI_type&
      URI ();

      void
      URI (const URI_type& x);

      void
      URI (::std::unique_ptr< URI_type > p);

      // FileSpec
      //
      typedef ::xsd::qif30::FileSpecType FileSpec_type;
      typedef ::xsd::cxx::tree::traits< FileSpec_type, wchar_t > FileSpec_traits;

      const FileSpec_type&
      FileSpec () const;

      FileSpec_type&
      FileSpec ();

      void
      FileSpec (const FileSpec_type& x);

      void
      FileSpec (::std::unique_ptr< FileSpec_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_type&
      Description () const;

      Description_type&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // Constructors.
      //
      ExternalFileReferenceType ();

      ExternalFileReferenceType (const URI_type&,
                                 const FileSpec_type&,
                                 const Description_type&);

      ExternalFileReferenceType (const URI_type&,
                                 ::std::unique_ptr< FileSpec_type >,
                                 const Description_type&);

      ExternalFileReferenceType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ExternalFileReferenceType (const ExternalFileReferenceType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ExternalFileReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExternalFileReferenceType&
      operator= (const ExternalFileReferenceType& x);

      virtual 
      ~ExternalFileReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< URI_type > URI_;
      ::xsd::cxx::tree::one< FileSpec_type > FileSpec_;
      ::xsd::cxx::tree::one< Description_type > Description_;
    };

    class QIF30_SYMBOL_DECL ExternalFileReferencesType: public ::xml_schema::type
    {
      public:
      // ExternalFileReference
      //
      typedef ::xsd::qif30::ExternalFileReferenceType ExternalFileReference_type;
      typedef ::xsd::cxx::tree::sequence< ExternalFileReference_type > ExternalFileReference_sequence;
      typedef xsd::cxx::tree::sequence< ExternalFileReference_type >::iterator ExternalFileReference_iterator;
      typedef xsd::cxx::tree::sequence< ExternalFileReference_type >::const_iterator ExternalFileReference_const_iterator;
      typedef ::xsd::cxx::tree::traits< ExternalFileReference_type, wchar_t > ExternalFileReference_traits;

      const ExternalFileReference_sequence&
      ExternalFileReference () const;

      ExternalFileReference_sequence&
      ExternalFileReference ();

      void
      ExternalFileReference (const ExternalFileReference_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ExternalFileReferencesType ();

      ExternalFileReferencesType (const n_type&);

      ExternalFileReferencesType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ExternalFileReferencesType (const ExternalFileReferencesType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ExternalFileReferencesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExternalFileReferencesType&
      operator= (const ExternalFileReferencesType& x);

      virtual 
      ~ExternalFileReferencesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ExternalFileReference_sequence ExternalFileReference_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DatumTargetDefinitionsType: public ::xml_schema::type
    {
      public:
      // DatumTarget
      //
      typedef ::xsd::qif30::DatumTargetType DatumTarget_type;
      typedef ::xsd::cxx::tree::sequence< DatumTarget_type > DatumTarget_sequence;
      typedef xsd::cxx::tree::sequence< DatumTarget_type >::iterator DatumTarget_iterator;
      typedef xsd::cxx::tree::sequence< DatumTarget_type >::const_iterator DatumTarget_const_iterator;
      typedef ::xsd::cxx::tree::traits< DatumTarget_type, wchar_t > DatumTarget_traits;

      const DatumTarget_sequence&
      DatumTarget () const;

      DatumTarget_sequence&
      DatumTarget ();

      void
      DatumTarget (const DatumTarget_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DatumTargetDefinitionsType ();

      DatumTargetDefinitionsType (const n_type&);

      DatumTargetDefinitionsType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      DatumTargetDefinitionsType (const DatumTargetDefinitionsType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual DatumTargetDefinitionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetDefinitionsType&
      operator= (const DatumTargetDefinitionsType& x);

      virtual 
      ~DatumTargetDefinitionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DatumTarget_sequence DatumTarget_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DatumDefinitionType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // DatumLabel
      //
      typedef ::xml_schema::nmtoken DatumLabel_type;
      typedef ::xsd::cxx::tree::traits< DatumLabel_type, wchar_t > DatumLabel_traits;

      const DatumLabel_type&
      DatumLabel () const;

      DatumLabel_type&
      DatumLabel ();

      void
      DatumLabel (const DatumLabel_type& x);

      void
      DatumLabel (::std::unique_ptr< DatumLabel_type > p);

      // DatumTargetIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType DatumTargetIds_type;
      typedef ::xsd::cxx::tree::optional< DatumTargetIds_type > DatumTargetIds_optional;
      typedef ::xsd::cxx::tree::traits< DatumTargetIds_type, wchar_t > DatumTargetIds_traits;

      const DatumTargetIds_optional&
      DatumTargetIds () const;

      DatumTargetIds_optional&
      DatumTargetIds ();

      void
      DatumTargetIds (const DatumTargetIds_type& x);

      void
      DatumTargetIds (const DatumTargetIds_optional& x);

      void
      DatumTargetIds (::std::unique_ptr< DatumTargetIds_type > p);

      // FeatureNominalIds
      //
      typedef ::xsd::qif30::ArrayReferenceFullType FeatureNominalIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalIds_type > FeatureNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalIds_type, wchar_t > FeatureNominalIds_traits;

      const FeatureNominalIds_optional&
      FeatureNominalIds () const;

      FeatureNominalIds_optional&
      FeatureNominalIds ();

      void
      FeatureNominalIds (const FeatureNominalIds_type& x);

      void
      FeatureNominalIds (const FeatureNominalIds_optional& x);

      void
      FeatureNominalIds (::std::unique_ptr< FeatureNominalIds_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      DatumDefinitionType ();

      DatumDefinitionType (const DatumLabel_type&,
                           const id_type&);

      DatumDefinitionType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      DatumDefinitionType (const DatumDefinitionType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual DatumDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumDefinitionType&
      operator= (const DatumDefinitionType& x);

      virtual 
      ~DatumDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< DatumLabel_type > DatumLabel_;
      DatumTargetIds_optional DatumTargetIds_;
      FeatureNominalIds_optional FeatureNominalIds_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL DatumDefinitionsType: public ::xml_schema::type
    {
      public:
      // DatumDefinition
      //
      typedef ::xsd::qif30::DatumDefinitionType DatumDefinition_type;
      typedef ::xsd::cxx::tree::sequence< DatumDefinition_type > DatumDefinition_sequence;
      typedef xsd::cxx::tree::sequence< DatumDefinition_type >::iterator DatumDefinition_iterator;
      typedef xsd::cxx::tree::sequence< DatumDefinition_type >::const_iterator DatumDefinition_const_iterator;
      typedef ::xsd::cxx::tree::traits< DatumDefinition_type, wchar_t > DatumDefinition_traits;

      const DatumDefinition_sequence&
      DatumDefinition () const;

      DatumDefinition_sequence&
      DatumDefinition ();

      void
      DatumDefinition (const DatumDefinition_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      DatumDefinitionsType ();

      DatumDefinitionsType (const n_type&);

      DatumDefinitionsType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DatumDefinitionsType (const DatumDefinitionsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DatumDefinitionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumDefinitionsType&
      operator= (const DatumDefinitionsType& x);

      virtual 
      ~DatumDefinitionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DatumDefinition_sequence DatumDefinition_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL DatumTargetType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // DatumTargetLabel
      //
      typedef ::xml_schema::token DatumTargetLabel_type;
      typedef ::xsd::cxx::tree::traits< DatumTargetLabel_type, wchar_t > DatumTargetLabel_traits;

      const DatumTargetLabel_type&
      DatumTargetLabel () const;

      DatumTargetLabel_type&
      DatumTargetLabel ();

      void
      DatumTargetLabel (const DatumTargetLabel_type& x);

      void
      DatumTargetLabel (::std::unique_ptr< DatumTargetLabel_type > p);

      // FeatureNominalId
      //
      typedef ::xsd::qif30::QIFReferenceFullType FeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalId_type > FeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalId_type, wchar_t > FeatureNominalId_traits;

      const FeatureNominalId_optional&
      FeatureNominalId () const;

      FeatureNominalId_optional&
      FeatureNominalId ();

      void
      FeatureNominalId (const FeatureNominalId_type& x);

      void
      FeatureNominalId (const FeatureNominalId_optional& x);

      void
      FeatureNominalId (::std::unique_ptr< FeatureNominalId_type > p);

      // TargetZoneId
      //
      typedef ::xsd::qif30::QIFReferenceFullType TargetZoneId_type;
      typedef ::xsd::cxx::tree::optional< TargetZoneId_type > TargetZoneId_optional;
      typedef ::xsd::cxx::tree::traits< TargetZoneId_type, wchar_t > TargetZoneId_traits;

      const TargetZoneId_optional&
      TargetZoneId () const;

      TargetZoneId_optional&
      TargetZoneId ();

      void
      TargetZoneId (const TargetZoneId_type& x);

      void
      TargetZoneId (const TargetZoneId_optional& x);

      void
      TargetZoneId (::std::unique_ptr< TargetZoneId_type > p);

      // MovableDatumTarget
      //
      typedef ::xsd::qif30::MovableDatumTargetDirectionType MovableDatumTarget_type;
      typedef ::xsd::cxx::tree::optional< MovableDatumTarget_type > MovableDatumTarget_optional;
      typedef ::xsd::cxx::tree::traits< MovableDatumTarget_type, wchar_t > MovableDatumTarget_traits;

      const MovableDatumTarget_optional&
      MovableDatumTarget () const;

      MovableDatumTarget_optional&
      MovableDatumTarget ();

      void
      MovableDatumTarget (const MovableDatumTarget_type& x);

      void
      MovableDatumTarget (const MovableDatumTarget_optional& x);

      void
      MovableDatumTarget (::std::unique_ptr< MovableDatumTarget_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      DatumTargetType ();

      DatumTargetType (const DatumTargetLabel_type&,
                       const id_type&);

      DatumTargetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      DatumTargetType (const DatumTargetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual DatumTargetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetType&
      operator= (const DatumTargetType& x);

      virtual 
      ~DatumTargetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< DatumTargetLabel_type > DatumTargetLabel_;
      FeatureNominalId_optional FeatureNominalId_;
      TargetZoneId_optional TargetZoneId_;
      MovableDatumTarget_optional MovableDatumTarget_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL EmployeeType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // EmployeeId
      //
      typedef ::xml_schema::token EmployeeId_type;
      typedef ::xsd::cxx::tree::optional< EmployeeId_type > EmployeeId_optional;
      typedef ::xsd::cxx::tree::traits< EmployeeId_type, wchar_t > EmployeeId_traits;

      const EmployeeId_optional&
      EmployeeId () const;

      EmployeeId_optional&
      EmployeeId ();

      void
      EmployeeId (const EmployeeId_type& x);

      void
      EmployeeId (const EmployeeId_optional& x);

      void
      EmployeeId (::std::unique_ptr< EmployeeId_type > p);

      // Shift
      //
      typedef ::xml_schema::token Shift_type;
      typedef ::xsd::cxx::tree::optional< Shift_type > Shift_optional;
      typedef ::xsd::cxx::tree::traits< Shift_type, wchar_t > Shift_traits;

      const Shift_optional&
      Shift () const;

      Shift_optional&
      Shift ();

      void
      Shift (const Shift_type& x);

      void
      Shift (const Shift_optional& x);

      void
      Shift (::std::unique_ptr< Shift_type > p);

      // Constructors.
      //
      EmployeeType ();

      EmployeeType (const Name_type&);

      EmployeeType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      EmployeeType (const EmployeeType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual EmployeeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EmployeeType&
      operator= (const EmployeeType& x);

      virtual 
      ~EmployeeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      EmployeeId_optional EmployeeId_;
      Shift_optional Shift_;
    };

    class QIF30_SYMBOL_DECL FileType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Version
      //
      typedef ::xml_schema::token Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // Format
      //
      typedef ::xsd::qif30::DigitalModelFormatType Format_type;
      typedef ::xsd::cxx::tree::optional< Format_type > Format_optional;
      typedef ::xsd::cxx::tree::traits< Format_type, wchar_t > Format_traits;

      const Format_optional&
      Format () const;

      Format_optional&
      Format ();

      void
      Format (const Format_type& x);

      void
      Format (const Format_optional& x);

      void
      Format (::std::unique_ptr< Format_type > p);

      // Constructors.
      //
      FileType ();

      FileType (const Name_type&);

      FileType (const xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      FileType (const FileType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual FileType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileType&
      operator= (const FileType& x);

      virtual 
      ~FileType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Version_optional Version_;
      Format_optional Format_;
    };

    class QIF30_SYMBOL_DECL SoftwareType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // VendorName
      //
      typedef ::xml_schema::token VendorName_type;
      typedef ::xsd::cxx::tree::traits< VendorName_type, wchar_t > VendorName_traits;

      const VendorName_type&
      VendorName () const;

      VendorName_type&
      VendorName ();

      void
      VendorName (const VendorName_type& x);

      void
      VendorName (::std::unique_ptr< VendorName_type > p);

      // ApplicationName
      //
      typedef ::xml_schema::token ApplicationName_type;
      typedef ::xsd::cxx::tree::traits< ApplicationName_type, wchar_t > ApplicationName_traits;

      const ApplicationName_type&
      ApplicationName () const;

      ApplicationName_type&
      ApplicationName ();

      void
      ApplicationName (const ApplicationName_type& x);

      void
      ApplicationName (::std::unique_ptr< ApplicationName_type > p);

      // Version
      //
      typedef ::xml_schema::token Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, wchar_t > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::unique_ptr< Version_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // URI
      //
      typedef ::xml_schema::uri URI_type;
      typedef ::xsd::cxx::tree::optional< URI_type > URI_optional;
      typedef ::xsd::cxx::tree::traits< URI_type, wchar_t > URI_traits;

      const URI_optional&
      URI () const;

      URI_optional&
      URI ();

      void
      URI (const URI_type& x);

      void
      URI (const URI_optional& x);

      void
      URI (::std::unique_ptr< URI_type > p);

      // ReferencedStandardIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ReferencedStandardIds_type;
      typedef ::xsd::cxx::tree::optional< ReferencedStandardIds_type > ReferencedStandardIds_optional;
      typedef ::xsd::cxx::tree::traits< ReferencedStandardIds_type, wchar_t > ReferencedStandardIds_traits;

      const ReferencedStandardIds_optional&
      ReferencedStandardIds () const;

      ReferencedStandardIds_optional&
      ReferencedStandardIds ();

      void
      ReferencedStandardIds (const ReferencedStandardIds_type& x);

      void
      ReferencedStandardIds (const ReferencedStandardIds_optional& x);

      void
      ReferencedStandardIds (::std::unique_ptr< ReferencedStandardIds_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      SoftwareType ();

      SoftwareType (const VendorName_type&,
                    const ApplicationName_type&,
                    const id_type&);

      SoftwareType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      SoftwareType (const SoftwareType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual SoftwareType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SoftwareType&
      operator= (const SoftwareType& x);

      virtual 
      ~SoftwareType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< VendorName_type > VendorName_;
      ::xsd::cxx::tree::one< ApplicationName_type > ApplicationName_;
      Version_optional Version_;
      Description_optional Description_;
      URI_optional URI_;
      ReferencedStandardIds_optional ReferencedStandardIds_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL StandardsOrganizationEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        AIAG,
        ANSI,
        ASAM,
        ASME,
        AWS,
        BSI,
        DIN,
        DOD,
        EASC,
        GOST,
        GOST_R,
        IEC,
        IEEE,
        ISO,
        JEITA,
        JIS,
        UL,
        VDA,
        W3C
      };

      StandardsOrganizationEnumType ();

      StandardsOrganizationEnumType (value v);

      StandardsOrganizationEnumType (const wchar_t* v);

      StandardsOrganizationEnumType (const ::std::wstring& v);

      StandardsOrganizationEnumType (const ::xml_schema::nmtoken& v);

      StandardsOrganizationEnumType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      StandardsOrganizationEnumType (const xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      StandardsOrganizationEnumType (const ::std::wstring& s,
                                     const xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      StandardsOrganizationEnumType (const StandardsOrganizationEnumType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      StandardsOrganizationEnumType&
      operator= (const StandardsOrganizationEnumType&) = default;
#endif

      virtual StandardsOrganizationEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StandardsOrganizationEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_StandardsOrganizationEnumType_convert ();
      }

      protected:
      value
      _xsd_StandardsOrganizationEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_StandardsOrganizationEnumType_literals_[19];
      static const value _xsd_StandardsOrganizationEnumType_indexes_[19];
    };

    class QIF30_SYMBOL_DECL StandardsOrganizationType: public ::xml_schema::type
    {
      public:
      // StandardsOrganizationEnum
      //
      typedef ::xsd::qif30::StandardsOrganizationEnumType StandardsOrganizationEnum_type;
      typedef ::xsd::cxx::tree::optional< StandardsOrganizationEnum_type > StandardsOrganizationEnum_optional;
      typedef ::xsd::cxx::tree::traits< StandardsOrganizationEnum_type, wchar_t > StandardsOrganizationEnum_traits;

      const StandardsOrganizationEnum_optional&
      StandardsOrganizationEnum () const;

      StandardsOrganizationEnum_optional&
      StandardsOrganizationEnum ();

      void
      StandardsOrganizationEnum (const StandardsOrganizationEnum_type& x);

      void
      StandardsOrganizationEnum (const StandardsOrganizationEnum_optional& x);

      void
      StandardsOrganizationEnum (::std::unique_ptr< StandardsOrganizationEnum_type > p);

      // OtherStandardsOrganization
      //
      typedef ::xml_schema::string OtherStandardsOrganization_type;
      typedef ::xsd::cxx::tree::optional< OtherStandardsOrganization_type > OtherStandardsOrganization_optional;
      typedef ::xsd::cxx::tree::traits< OtherStandardsOrganization_type, wchar_t > OtherStandardsOrganization_traits;

      const OtherStandardsOrganization_optional&
      OtherStandardsOrganization () const;

      OtherStandardsOrganization_optional&
      OtherStandardsOrganization ();

      void
      OtherStandardsOrganization (const OtherStandardsOrganization_type& x);

      void
      OtherStandardsOrganization (const OtherStandardsOrganization_optional& x);

      void
      OtherStandardsOrganization (::std::unique_ptr< OtherStandardsOrganization_type > p);

      // Constructors.
      //
      StandardsOrganizationType ();

      StandardsOrganizationType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      StandardsOrganizationType (const StandardsOrganizationType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual StandardsOrganizationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StandardsOrganizationType&
      operator= (const StandardsOrganizationType& x);

      virtual 
      ~StandardsOrganizationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      StandardsOrganizationEnum_optional StandardsOrganizationEnum_;
      OtherStandardsOrganization_optional OtherStandardsOrganization_;
    };

    class QIF30_SYMBOL_DECL StandardType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Organization
      //
      typedef ::xsd::qif30::StandardsOrganizationType Organization_type;
      typedef ::xsd::cxx::tree::traits< Organization_type, wchar_t > Organization_traits;

      const Organization_type&
      Organization () const;

      Organization_type&
      Organization ();

      void
      Organization (const Organization_type& x);

      void
      Organization (::std::unique_ptr< Organization_type > p);

      // Designator
      //
      typedef ::xml_schema::token Designator_type;
      typedef ::xsd::cxx::tree::traits< Designator_type, wchar_t > Designator_traits;

      const Designator_type&
      Designator () const;

      Designator_type&
      Designator ();

      void
      Designator (const Designator_type& x);

      void
      Designator (::std::unique_ptr< Designator_type > p);

      // Year
      //
      typedef ::xml_schema::string Year_type;
      typedef ::xsd::cxx::tree::optional< Year_type > Year_optional;
      typedef ::xsd::cxx::tree::traits< Year_type, wchar_t > Year_traits;

      const Year_optional&
      Year () const;

      Year_optional&
      Year ();

      void
      Year (const Year_type& x);

      void
      Year (const Year_optional& x);

      void
      Year (::std::unique_ptr< Year_type > p);

      // Title
      //
      typedef ::xml_schema::string Title_type;
      typedef ::xsd::cxx::tree::optional< Title_type > Title_optional;
      typedef ::xsd::cxx::tree::traits< Title_type, wchar_t > Title_traits;

      const Title_optional&
      Title () const;

      Title_optional&
      Title ();

      void
      Title (const Title_type& x);

      void
      Title (const Title_optional& x);

      void
      Title (::std::unique_ptr< Title_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // URI
      //
      typedef ::xml_schema::uri URI_type;
      typedef ::xsd::cxx::tree::optional< URI_type > URI_optional;
      typedef ::xsd::cxx::tree::traits< URI_type, wchar_t > URI_traits;

      const URI_optional&
      URI () const;

      URI_optional&
      URI ();

      void
      URI (const URI_type& x);

      void
      URI (const URI_optional& x);

      void
      URI (::std::unique_ptr< URI_type > p);

      // ISBN
      //
      typedef ::xml_schema::nmtoken ISBN_type;
      typedef ::xsd::cxx::tree::optional< ISBN_type > ISBN_optional;
      typedef ::xsd::cxx::tree::traits< ISBN_type, wchar_t > ISBN_traits;

      const ISBN_optional&
      ISBN () const;

      ISBN_optional&
      ISBN ();

      void
      ISBN (const ISBN_type& x);

      void
      ISBN (const ISBN_optional& x);

      void
      ISBN (::std::unique_ptr< ISBN_type > p);

      // ReferencedStandardIds
      //
      typedef ::xsd::qif30::ArrayReferenceType ReferencedStandardIds_type;
      typedef ::xsd::cxx::tree::optional< ReferencedStandardIds_type > ReferencedStandardIds_optional;
      typedef ::xsd::cxx::tree::traits< ReferencedStandardIds_type, wchar_t > ReferencedStandardIds_traits;

      const ReferencedStandardIds_optional&
      ReferencedStandardIds () const;

      ReferencedStandardIds_optional&
      ReferencedStandardIds ();

      void
      ReferencedStandardIds (const ReferencedStandardIds_type& x);

      void
      ReferencedStandardIds (const ReferencedStandardIds_optional& x);

      void
      ReferencedStandardIds (::std::unique_ptr< ReferencedStandardIds_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      StandardType ();

      StandardType (const Organization_type&,
                    const Designator_type&,
                    const id_type&);

      StandardType (::std::unique_ptr< Organization_type >,
                    const Designator_type&,
                    const id_type&);

      StandardType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      StandardType (const StandardType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual StandardType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StandardType&
      operator= (const StandardType& x);

      virtual 
      ~StandardType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< Organization_type > Organization_;
      ::xsd::cxx::tree::one< Designator_type > Designator_;
      Year_optional Year_;
      Title_optional Title_;
      Description_optional Description_;
      URI_optional URI_;
      ISBN_optional ISBN_;
      ReferencedStandardIds_optional ReferencedStandardIds_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL StandardsType: public ::xml_schema::type
    {
      public:
      // Standard
      //
      typedef ::xsd::qif30::StandardType Standard_type;
      typedef ::xsd::cxx::tree::sequence< Standard_type > Standard_sequence;
      typedef xsd::cxx::tree::sequence< Standard_type >::iterator Standard_iterator;
      typedef xsd::cxx::tree::sequence< Standard_type >::const_iterator Standard_const_iterator;
      typedef ::xsd::cxx::tree::traits< Standard_type, wchar_t > Standard_traits;

      const Standard_sequence&
      Standard () const;

      Standard_sequence&
      Standard ();

      void
      Standard (const Standard_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      StandardsType ();

      StandardsType (const n_type&);

      StandardsType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      StandardsType (const StandardsType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual StandardsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StandardsType&
      operator= (const StandardsType& x);

      virtual 
      ~StandardsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Standard_sequence Standard_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SoftwaresType: public ::xml_schema::type
    {
      public:
      // Software
      //
      typedef ::xsd::qif30::SoftwareType Software_type;
      typedef ::xsd::cxx::tree::sequence< Software_type > Software_sequence;
      typedef xsd::cxx::tree::sequence< Software_type >::iterator Software_iterator;
      typedef xsd::cxx::tree::sequence< Software_type >::const_iterator Software_const_iterator;
      typedef ::xsd::cxx::tree::traits< Software_type, wchar_t > Software_traits;

      const Software_sequence&
      Software () const;

      Software_sequence&
      Software ();

      void
      Software (const Software_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SoftwaresType ();

      SoftwaresType (const n_type&);

      SoftwaresType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      SoftwaresType (const SoftwaresType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual SoftwaresType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SoftwaresType&
      operator= (const SoftwaresType& x);

      virtual 
      ~SoftwaresType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Software_sequence Software_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL AlgorithmType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // SoftwareId
      //
      typedef ::xsd::qif30::QIFReferenceType SoftwareId_type;
      typedef ::xsd::cxx::tree::optional< SoftwareId_type > SoftwareId_optional;
      typedef ::xsd::cxx::tree::traits< SoftwareId_type, wchar_t > SoftwareId_traits;

      const SoftwareId_optional&
      SoftwareId () const;

      SoftwareId_optional&
      SoftwareId ();

      void
      SoftwareId (const SoftwareId_type& x);

      void
      SoftwareId (const SoftwareId_optional& x);

      void
      SoftwareId (::std::unique_ptr< SoftwareId_type > p);

      // Parameters
      //
      typedef ::xml_schema::string Parameters_type;
      typedef ::xsd::cxx::tree::optional< Parameters_type > Parameters_optional;
      typedef ::xsd::cxx::tree::traits< Parameters_type, wchar_t > Parameters_traits;

      const Parameters_optional&
      Parameters () const;

      Parameters_optional&
      Parameters ();

      void
      Parameters (const Parameters_type& x);

      void
      Parameters (const Parameters_optional& x);

      void
      Parameters (::std::unique_ptr< Parameters_type > p);

      // StandardId
      //
      typedef ::xsd::qif30::QIFReferenceType StandardId_type;
      typedef ::xsd::cxx::tree::optional< StandardId_type > StandardId_optional;
      typedef ::xsd::cxx::tree::traits< StandardId_type, wchar_t > StandardId_traits;

      const StandardId_optional&
      StandardId () const;

      StandardId_optional&
      StandardId ();

      void
      StandardId (const StandardId_type& x);

      void
      StandardId (const StandardId_optional& x);

      void
      StandardId (::std::unique_ptr< StandardId_type > p);

      // Section
      //
      typedef ::xml_schema::string Section_type;
      typedef ::xsd::cxx::tree::optional< Section_type > Section_optional;
      typedef ::xsd::cxx::tree::traits< Section_type, wchar_t > Section_traits;

      const Section_optional&
      Section () const;

      Section_optional&
      Section ();

      void
      Section (const Section_type& x);

      void
      Section (const Section_optional& x);

      void
      Section (::std::unique_ptr< Section_type > p);

      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      AlgorithmType ();

      AlgorithmType (const Name_type&,
                     const id_type&);

      AlgorithmType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      AlgorithmType (const AlgorithmType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual AlgorithmType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AlgorithmType&
      operator= (const AlgorithmType& x);

      virtual 
      ~AlgorithmType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      SoftwareId_optional SoftwareId_;
      Parameters_optional Parameters_;
      StandardId_optional StandardId_;
      Section_optional Section_;
      ::xsd::cxx::tree::one< Name_type > Name_;
      Description_optional Description_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL AlgorithmsType: public ::xml_schema::type
    {
      public:
      // Algorithm
      //
      typedef ::xsd::qif30::AlgorithmType Algorithm_type;
      typedef ::xsd::cxx::tree::sequence< Algorithm_type > Algorithm_sequence;
      typedef xsd::cxx::tree::sequence< Algorithm_type >::iterator Algorithm_iterator;
      typedef xsd::cxx::tree::sequence< Algorithm_type >::const_iterator Algorithm_const_iterator;
      typedef ::xsd::cxx::tree::traits< Algorithm_type, wchar_t > Algorithm_traits;

      const Algorithm_sequence&
      Algorithm () const;

      Algorithm_sequence&
      Algorithm ();

      void
      Algorithm (const Algorithm_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      AlgorithmsType ();

      AlgorithmsType (const n_type&);

      AlgorithmsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      AlgorithmsType (const AlgorithmsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual AlgorithmsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AlgorithmsType&
      operator= (const AlgorithmsType& x);

      virtual 
      ~AlgorithmsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Algorithm_sequence Algorithm_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL OrganizationType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, wchar_t > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::unique_ptr< Name_type > p);

      // Address
      //
      typedef ::xsd::qif30::PhysicalAddressType Address_type;
      typedef ::xsd::cxx::tree::optional< Address_type > Address_optional;
      typedef ::xsd::cxx::tree::traits< Address_type, wchar_t > Address_traits;

      const Address_optional&
      Address () const;

      Address_optional&
      Address ();

      void
      Address (const Address_type& x);

      void
      Address (const Address_optional& x);

      void
      Address (::std::unique_ptr< Address_type > p);

      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // Constructors.
      //
      OrganizationType ();

      OrganizationType (const Name_type&);

      OrganizationType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      OrganizationType (const OrganizationType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual OrganizationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrganizationType&
      operator= (const OrganizationType& x);

      virtual 
      ~OrganizationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Address_optional Address_;
      Attributes_optional Attributes_;
    };

    class QIF30_SYMBOL_DECL PhysicalAddressType: public ::xml_schema::type
    {
      public:
      // Description
      //
      typedef ::xsd::qif30::AddressDescriptionType Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // InternalLocation
      //
      typedef ::xml_schema::token InternalLocation_type;
      typedef ::xsd::cxx::tree::optional< InternalLocation_type > InternalLocation_optional;
      typedef ::xsd::cxx::tree::traits< InternalLocation_type, wchar_t > InternalLocation_traits;

      const InternalLocation_optional&
      InternalLocation () const;

      InternalLocation_optional&
      InternalLocation ();

      void
      InternalLocation (const InternalLocation_type& x);

      void
      InternalLocation (const InternalLocation_optional& x);

      void
      InternalLocation (::std::unique_ptr< InternalLocation_type > p);

      // StreetNumber
      //
      typedef ::xml_schema::token StreetNumber_type;
      typedef ::xsd::cxx::tree::optional< StreetNumber_type > StreetNumber_optional;
      typedef ::xsd::cxx::tree::traits< StreetNumber_type, wchar_t > StreetNumber_traits;

      const StreetNumber_optional&
      StreetNumber () const;

      StreetNumber_optional&
      StreetNumber ();

      void
      StreetNumber (const StreetNumber_type& x);

      void
      StreetNumber (const StreetNumber_optional& x);

      void
      StreetNumber (::std::unique_ptr< StreetNumber_type > p);

      // Street
      //
      typedef ::xml_schema::token Street_type;
      typedef ::xsd::cxx::tree::optional< Street_type > Street_optional;
      typedef ::xsd::cxx::tree::traits< Street_type, wchar_t > Street_traits;

      const Street_optional&
      Street () const;

      Street_optional&
      Street ();

      void
      Street (const Street_type& x);

      void
      Street (const Street_optional& x);

      void
      Street (::std::unique_ptr< Street_type > p);

      // PostalBox
      //
      typedef ::xml_schema::token PostalBox_type;
      typedef ::xsd::cxx::tree::optional< PostalBox_type > PostalBox_optional;
      typedef ::xsd::cxx::tree::traits< PostalBox_type, wchar_t > PostalBox_traits;

      const PostalBox_optional&
      PostalBox () const;

      PostalBox_optional&
      PostalBox ();

      void
      PostalBox (const PostalBox_type& x);

      void
      PostalBox (const PostalBox_optional& x);

      void
      PostalBox (::std::unique_ptr< PostalBox_type > p);

      // Town
      //
      typedef ::xml_schema::token Town_type;
      typedef ::xsd::cxx::tree::optional< Town_type > Town_optional;
      typedef ::xsd::cxx::tree::traits< Town_type, wchar_t > Town_traits;

      const Town_optional&
      Town () const;

      Town_optional&
      Town ();

      void
      Town (const Town_type& x);

      void
      Town (const Town_optional& x);

      void
      Town (::std::unique_ptr< Town_type > p);

      // Region
      //
      typedef ::xml_schema::token Region_type;
      typedef ::xsd::cxx::tree::optional< Region_type > Region_optional;
      typedef ::xsd::cxx::tree::traits< Region_type, wchar_t > Region_traits;

      const Region_optional&
      Region () const;

      Region_optional&
      Region ();

      void
      Region (const Region_type& x);

      void
      Region (const Region_optional& x);

      void
      Region (::std::unique_ptr< Region_type > p);

      // PostalCode
      //
      typedef ::xml_schema::token PostalCode_type;
      typedef ::xsd::cxx::tree::optional< PostalCode_type > PostalCode_optional;
      typedef ::xsd::cxx::tree::traits< PostalCode_type, wchar_t > PostalCode_traits;

      const PostalCode_optional&
      PostalCode () const;

      PostalCode_optional&
      PostalCode ();

      void
      PostalCode (const PostalCode_type& x);

      void
      PostalCode (const PostalCode_optional& x);

      void
      PostalCode (::std::unique_ptr< PostalCode_type > p);

      // Country
      //
      typedef ::xml_schema::token Country_type;
      typedef ::xsd::cxx::tree::optional< Country_type > Country_optional;
      typedef ::xsd::cxx::tree::traits< Country_type, wchar_t > Country_traits;

      const Country_optional&
      Country () const;

      Country_optional&
      Country ();

      void
      Country (const Country_type& x);

      void
      Country (const Country_optional& x);

      void
      Country (::std::unique_ptr< Country_type > p);

      // FacsimileNumber
      //
      typedef ::xml_schema::token FacsimileNumber_type;
      typedef ::xsd::cxx::tree::optional< FacsimileNumber_type > FacsimileNumber_optional;
      typedef ::xsd::cxx::tree::traits< FacsimileNumber_type, wchar_t > FacsimileNumber_traits;

      const FacsimileNumber_optional&
      FacsimileNumber () const;

      FacsimileNumber_optional&
      FacsimileNumber ();

      void
      FacsimileNumber (const FacsimileNumber_type& x);

      void
      FacsimileNumber (const FacsimileNumber_optional& x);

      void
      FacsimileNumber (::std::unique_ptr< FacsimileNumber_type > p);

      // TelephoneNumber
      //
      typedef ::xml_schema::token TelephoneNumber_type;
      typedef ::xsd::cxx::tree::optional< TelephoneNumber_type > TelephoneNumber_optional;
      typedef ::xsd::cxx::tree::traits< TelephoneNumber_type, wchar_t > TelephoneNumber_traits;

      const TelephoneNumber_optional&
      TelephoneNumber () const;

      TelephoneNumber_optional&
      TelephoneNumber ();

      void
      TelephoneNumber (const TelephoneNumber_type& x);

      void
      TelephoneNumber (const TelephoneNumber_optional& x);

      void
      TelephoneNumber (::std::unique_ptr< TelephoneNumber_type > p);

      // ElectronicMailAddress
      //
      typedef ::xml_schema::token ElectronicMailAddress_type;
      typedef ::xsd::cxx::tree::optional< ElectronicMailAddress_type > ElectronicMailAddress_optional;
      typedef ::xsd::cxx::tree::traits< ElectronicMailAddress_type, wchar_t > ElectronicMailAddress_traits;

      const ElectronicMailAddress_optional&
      ElectronicMailAddress () const;

      ElectronicMailAddress_optional&
      ElectronicMailAddress ();

      void
      ElectronicMailAddress (const ElectronicMailAddress_type& x);

      void
      ElectronicMailAddress (const ElectronicMailAddress_optional& x);

      void
      ElectronicMailAddress (::std::unique_ptr< ElectronicMailAddress_type > p);

      // TelexNumber
      //
      typedef ::xml_schema::token TelexNumber_type;
      typedef ::xsd::cxx::tree::optional< TelexNumber_type > TelexNumber_optional;
      typedef ::xsd::cxx::tree::traits< TelexNumber_type, wchar_t > TelexNumber_traits;

      const TelexNumber_optional&
      TelexNumber () const;

      TelexNumber_optional&
      TelexNumber ();

      void
      TelexNumber (const TelexNumber_type& x);

      void
      TelexNumber (const TelexNumber_optional& x);

      void
      TelexNumber (::std::unique_ptr< TelexNumber_type > p);

      // Constructors.
      //
      PhysicalAddressType ();

      PhysicalAddressType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PhysicalAddressType (const PhysicalAddressType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual PhysicalAddressType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PhysicalAddressType&
      operator= (const PhysicalAddressType& x);

      virtual 
      ~PhysicalAddressType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Description_optional Description_;
      InternalLocation_optional InternalLocation_;
      StreetNumber_optional StreetNumber_;
      Street_optional Street_;
      PostalBox_optional PostalBox_;
      Town_optional Town_;
      Region_optional Region_;
      PostalCode_optional PostalCode_;
      Country_optional Country_;
      FacsimileNumber_optional FacsimileNumber_;
      TelephoneNumber_optional TelephoneNumber_;
      ElectronicMailAddress_optional ElectronicMailAddress_;
      TelexNumber_optional TelexNumber_;
    };

    class QIF30_SYMBOL_DECL AddressDescriptionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        DELIVERY,
        POSTAL,
        VISITOR,
        NOTDEFINED
      };

      AddressDescriptionEnumType ();

      AddressDescriptionEnumType (value v);

      AddressDescriptionEnumType (const wchar_t* v);

      AddressDescriptionEnumType (const ::std::wstring& v);

      AddressDescriptionEnumType (const ::xml_schema::nmtoken& v);

      AddressDescriptionEnumType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      AddressDescriptionEnumType (const xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      AddressDescriptionEnumType (const ::std::wstring& s,
                                  const xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      AddressDescriptionEnumType (const AddressDescriptionEnumType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      AddressDescriptionEnumType&
      operator= (const AddressDescriptionEnumType&) = default;
#endif

      virtual AddressDescriptionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AddressDescriptionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AddressDescriptionEnumType_convert ();
      }

      protected:
      value
      _xsd_AddressDescriptionEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_AddressDescriptionEnumType_literals_[4];
      static const value _xsd_AddressDescriptionEnumType_indexes_[4];
    };

    class QIF30_SYMBOL_DECL AddressDescriptionType: public ::xml_schema::type
    {
      public:
      // AddressDescriptionEnum
      //
      typedef ::xsd::qif30::AddressDescriptionEnumType AddressDescriptionEnum_type;
      typedef ::xsd::cxx::tree::optional< AddressDescriptionEnum_type > AddressDescriptionEnum_optional;
      typedef ::xsd::cxx::tree::traits< AddressDescriptionEnum_type, wchar_t > AddressDescriptionEnum_traits;

      const AddressDescriptionEnum_optional&
      AddressDescriptionEnum () const;

      AddressDescriptionEnum_optional&
      AddressDescriptionEnum ();

      void
      AddressDescriptionEnum (const AddressDescriptionEnum_type& x);

      void
      AddressDescriptionEnum (const AddressDescriptionEnum_optional& x);

      void
      AddressDescriptionEnum (::std::unique_ptr< AddressDescriptionEnum_type > p);

      // OtherAddressDescription
      //
      typedef ::xml_schema::string OtherAddressDescription_type;
      typedef ::xsd::cxx::tree::optional< OtherAddressDescription_type > OtherAddressDescription_optional;
      typedef ::xsd::cxx::tree::traits< OtherAddressDescription_type, wchar_t > OtherAddressDescription_traits;

      const OtherAddressDescription_optional&
      OtherAddressDescription () const;

      OtherAddressDescription_optional&
      OtherAddressDescription ();

      void
      OtherAddressDescription (const OtherAddressDescription_type& x);

      void
      OtherAddressDescription (const OtherAddressDescription_optional& x);

      void
      OtherAddressDescription (::std::unique_ptr< OtherAddressDescription_type > p);

      // Constructors.
      //
      AddressDescriptionType ();

      AddressDescriptionType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      AddressDescriptionType (const AddressDescriptionType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual AddressDescriptionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AddressDescriptionType&
      operator= (const AddressDescriptionType& x);

      virtual 
      ~AddressDescriptionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      AddressDescriptionEnum_optional AddressDescriptionEnum_;
      OtherAddressDescription_optional OtherAddressDescription_;
    };

    class QIF30_SYMBOL_DECL LocationType: public ::xml_schema::type
    {
      public:
      // LocationDescription
      //
      typedef ::xml_schema::string LocationDescription_type;
      typedef ::xsd::cxx::tree::traits< LocationDescription_type, wchar_t > LocationDescription_traits;

      const LocationDescription_type&
      LocationDescription () const;

      LocationDescription_type&
      LocationDescription ();

      void
      LocationDescription (const LocationDescription_type& x);

      void
      LocationDescription (::std::unique_ptr< LocationDescription_type > p);

      // Address
      //
      typedef ::xsd::qif30::PhysicalAddressType Address_type;
      typedef ::xsd::cxx::tree::optional< Address_type > Address_optional;
      typedef ::xsd::cxx::tree::traits< Address_type, wchar_t > Address_traits;

      const Address_optional&
      Address () const;

      Address_optional&
      Address ();

      void
      Address (const Address_type& x);

      void
      Address (const Address_optional& x);

      void
      Address (::std::unique_ptr< Address_type > p);

      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      LocationType ();

      LocationType (const LocationDescription_type&,
                    const id_type&);

      LocationType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      LocationType (const LocationType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual LocationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocationType&
      operator= (const LocationType& x);

      virtual 
      ~LocationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationDescription_type > LocationDescription_;
      Address_optional Address_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL CustomerOrganizationType: public ::xsd::qif30::OrganizationType
    {
      public:
      // CustomerNumber
      //
      typedef ::xml_schema::token CustomerNumber_type;
      typedef ::xsd::cxx::tree::traits< CustomerNumber_type, wchar_t > CustomerNumber_traits;

      const CustomerNumber_type&
      CustomerNumber () const;

      CustomerNumber_type&
      CustomerNumber ();

      void
      CustomerNumber (const CustomerNumber_type& x);

      void
      CustomerNumber (::std::unique_ptr< CustomerNumber_type > p);

      // Constructors.
      //
      CustomerOrganizationType ();

      CustomerOrganizationType (const Name_type&,
                                const CustomerNumber_type&);

      CustomerOrganizationType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CustomerOrganizationType (const CustomerOrganizationType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CustomerOrganizationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CustomerOrganizationType&
      operator= (const CustomerOrganizationType& x);

      virtual 
      ~CustomerOrganizationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CustomerNumber_type > CustomerNumber_;
    };

    class QIF30_SYMBOL_DECL VersionHistoryType: public ::xml_schema::type
    {
      public:
      // EarlierVersion
      //
      typedef ::xsd::qif30::VersionReferenceType EarlierVersion_type;
      typedef ::xsd::cxx::tree::sequence< EarlierVersion_type > EarlierVersion_sequence;
      typedef xsd::cxx::tree::sequence< EarlierVersion_type >::iterator EarlierVersion_iterator;
      typedef xsd::cxx::tree::sequence< EarlierVersion_type >::const_iterator EarlierVersion_const_iterator;
      typedef ::xsd::cxx::tree::traits< EarlierVersion_type, wchar_t > EarlierVersion_traits;

      const EarlierVersion_sequence&
      EarlierVersion () const;

      EarlierVersion_sequence&
      EarlierVersion ();

      void
      EarlierVersion (const EarlierVersion_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      VersionHistoryType ();

      VersionHistoryType (const n_type&);

      VersionHistoryType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      VersionHistoryType (const VersionHistoryType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual VersionHistoryType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VersionHistoryType&
      operator= (const VersionHistoryType& x);

      virtual 
      ~VersionHistoryType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      EarlierVersion_sequence EarlierVersion_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL VersionBaseType: public ::xml_schema::type
    {
      public:
      // TimeCreated
      //
      typedef ::xml_schema::date_time TimeCreated_type;
      typedef ::xsd::cxx::tree::optional< TimeCreated_type > TimeCreated_optional;
      typedef ::xsd::cxx::tree::traits< TimeCreated_type, wchar_t > TimeCreated_traits;

      const TimeCreated_optional&
      TimeCreated () const;

      TimeCreated_optional&
      TimeCreated ();

      void
      TimeCreated (const TimeCreated_type& x);

      void
      TimeCreated (const TimeCreated_optional& x);

      void
      TimeCreated (::std::unique_ptr< TimeCreated_type > p);

      // SignOffs
      //
      typedef ::xsd::qif30::SignOffsType SignOffs_type;
      typedef ::xsd::cxx::tree::optional< SignOffs_type > SignOffs_optional;
      typedef ::xsd::cxx::tree::traits< SignOffs_type, wchar_t > SignOffs_traits;

      const SignOffs_optional&
      SignOffs () const;

      SignOffs_optional&
      SignOffs ();

      void
      SignOffs (const SignOffs_type& x);

      void
      SignOffs (const SignOffs_optional& x);

      void
      SignOffs (::std::unique_ptr< SignOffs_type > p);

      // Constructors.
      //
      VersionBaseType ();

      VersionBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      VersionBaseType (const VersionBaseType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual VersionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VersionBaseType&
      operator= (const VersionBaseType& x);

      virtual 
      ~VersionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      TimeCreated_optional TimeCreated_;
      SignOffs_optional SignOffs_;
    };

    class QIF30_SYMBOL_DECL VersionType: public ::xsd::qif30::VersionBaseType
    {
      public:
      // ThisInstanceQPId
      //
      typedef ::xsd::qif30::QPIdType ThisInstanceQPId_type;
      typedef ::xsd::cxx::tree::optional< ThisInstanceQPId_type > ThisInstanceQPId_optional;
      typedef ::xsd::cxx::tree::traits< ThisInstanceQPId_type, wchar_t > ThisInstanceQPId_traits;

      const ThisInstanceQPId_optional&
      ThisInstanceQPId () const;

      ThisInstanceQPId_optional&
      ThisInstanceQPId ();

      void
      ThisInstanceQPId (const ThisInstanceQPId_type& x);

      void
      ThisInstanceQPId (const ThisInstanceQPId_optional& x);

      void
      ThisInstanceQPId (::std::unique_ptr< ThisInstanceQPId_type > p);

      // Constructors.
      //
      VersionType ();

      VersionType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      VersionType (const VersionType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual VersionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VersionType&
      operator= (const VersionType& x);

      virtual 
      ~VersionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ThisInstanceQPId_optional ThisInstanceQPId_;
    };

    class QIF30_SYMBOL_DECL VersionReferenceType: public ::xsd::qif30::VersionBaseType
    {
      public:
      // QPIdReference
      //
      typedef ::xsd::qif30::QPIdReferenceType QPIdReference_type;
      typedef ::xsd::cxx::tree::optional< QPIdReference_type > QPIdReference_optional;
      typedef ::xsd::cxx::tree::traits< QPIdReference_type, wchar_t > QPIdReference_traits;

      const QPIdReference_optional&
      QPIdReference () const;

      QPIdReference_optional&
      QPIdReference ();

      void
      QPIdReference (const QPIdReference_type& x);

      void
      QPIdReference (const QPIdReference_optional& x);

      void
      QPIdReference (::std::unique_ptr< QPIdReference_type > p);

      // Constructors.
      //
      VersionReferenceType ();

      VersionReferenceType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      VersionReferenceType (const VersionReferenceType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual VersionReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VersionReferenceType&
      operator= (const VersionReferenceType& x);

      virtual 
      ~VersionReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      QPIdReference_optional QPIdReference_;
    };

    class QIF30_SYMBOL_DECL SignOffsType: public ::xml_schema::type
    {
      public:
      // Employee
      //
      typedef ::xsd::qif30::EmployeeType Employee_type;
      typedef ::xsd::cxx::tree::sequence< Employee_type > Employee_sequence;
      typedef xsd::cxx::tree::sequence< Employee_type >::iterator Employee_iterator;
      typedef xsd::cxx::tree::sequence< Employee_type >::const_iterator Employee_const_iterator;
      typedef ::xsd::cxx::tree::traits< Employee_type, wchar_t > Employee_traits;

      const Employee_sequence&
      Employee () const;

      Employee_sequence&
      Employee ();

      void
      Employee (const Employee_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SignOffsType ();

      SignOffsType (const n_type&);

      SignOffsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      SignOffsType (const SignOffsType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual SignOffsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignOffsType&
      operator= (const SignOffsType& x);

      virtual 
      ~SignOffsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Employee_sequence Employee_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MaterialClassEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PLASTIC,
        METAL,
        WOOD,
        STONE,
        RUBBER,
        COMPOSITE,
        FOAM,
        CERAMIC,
        GLASS
      };

      MaterialClassEnumType ();

      MaterialClassEnumType (value v);

      MaterialClassEnumType (const wchar_t* v);

      MaterialClassEnumType (const ::std::wstring& v);

      MaterialClassEnumType (const ::xml_schema::nmtoken& v);

      MaterialClassEnumType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MaterialClassEnumType (const xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MaterialClassEnumType (const ::std::wstring& s,
                             const xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MaterialClassEnumType (const MaterialClassEnumType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      MaterialClassEnumType&
      operator= (const MaterialClassEnumType&) = default;
#endif

      virtual MaterialClassEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MaterialClassEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MaterialClassEnumType_convert ();
      }

      protected:
      value
      _xsd_MaterialClassEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_MaterialClassEnumType_literals_[9];
      static const value _xsd_MaterialClassEnumType_indexes_[9];
    };

    class QIF30_SYMBOL_DECL MaterialType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif30::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, wchar_t > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::unique_ptr< Attributes_type > p);

      // MaterialClassEnum
      //
      typedef ::xsd::qif30::MaterialClassEnumType MaterialClassEnum_type;
      typedef ::xsd::cxx::tree::optional< MaterialClassEnum_type > MaterialClassEnum_optional;
      typedef ::xsd::cxx::tree::traits< MaterialClassEnum_type, wchar_t > MaterialClassEnum_traits;

      const MaterialClassEnum_optional&
      MaterialClassEnum () const;

      MaterialClassEnum_optional&
      MaterialClassEnum ();

      void
      MaterialClassEnum (const MaterialClassEnum_type& x);

      void
      MaterialClassEnum (const MaterialClassEnum_optional& x);

      void
      MaterialClassEnum (::std::unique_ptr< MaterialClassEnum_type > p);

      // OtherMaterialClass
      //
      typedef ::xml_schema::string OtherMaterialClass_type;
      typedef ::xsd::cxx::tree::optional< OtherMaterialClass_type > OtherMaterialClass_optional;
      typedef ::xsd::cxx::tree::traits< OtherMaterialClass_type, wchar_t > OtherMaterialClass_traits;

      const OtherMaterialClass_optional&
      OtherMaterialClass () const;

      OtherMaterialClass_optional&
      OtherMaterialClass ();

      void
      OtherMaterialClass (const OtherMaterialClass_type& x);

      void
      OtherMaterialClass (const OtherMaterialClass_optional& x);

      void
      OtherMaterialClass (::std::unique_ptr< OtherMaterialClass_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, wchar_t > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::unique_ptr< Description_type > p);

      // MassDensity
      //
      typedef ::xml_schema::double_ MassDensity_type;
      typedef ::xsd::cxx::tree::optional< MassDensity_type > MassDensity_optional;
      typedef ::xsd::cxx::tree::traits< MassDensity_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > MassDensity_traits;

      const MassDensity_optional&
      MassDensity () const;

      MassDensity_optional&
      MassDensity ();

      void
      MassDensity (const MassDensity_type& x);

      void
      MassDensity (const MassDensity_optional& x);

      // PoissonsRatio
      //
      typedef ::xml_schema::double_ PoissonsRatio_type;
      typedef ::xsd::cxx::tree::optional< PoissonsRatio_type > PoissonsRatio_optional;
      typedef ::xsd::cxx::tree::traits< PoissonsRatio_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > PoissonsRatio_traits;

      const PoissonsRatio_optional&
      PoissonsRatio () const;

      PoissonsRatio_optional&
      PoissonsRatio ();

      void
      PoissonsRatio (const PoissonsRatio_type& x);

      void
      PoissonsRatio (const PoissonsRatio_optional& x);

      // YoungsModulus
      //
      typedef ::xml_schema::double_ YoungsModulus_type;
      typedef ::xsd::cxx::tree::optional< YoungsModulus_type > YoungsModulus_optional;
      typedef ::xsd::cxx::tree::traits< YoungsModulus_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > YoungsModulus_traits;

      const YoungsModulus_optional&
      YoungsModulus () const;

      YoungsModulus_optional&
      YoungsModulus ();

      void
      YoungsModulus (const YoungsModulus_type& x);

      void
      YoungsModulus (const YoungsModulus_optional& x);

      // UltimateTensileStress
      //
      typedef ::xml_schema::double_ UltimateTensileStress_type;
      typedef ::xsd::cxx::tree::optional< UltimateTensileStress_type > UltimateTensileStress_optional;
      typedef ::xsd::cxx::tree::traits< UltimateTensileStress_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > UltimateTensileStress_traits;

      const UltimateTensileStress_optional&
      UltimateTensileStress () const;

      UltimateTensileStress_optional&
      UltimateTensileStress ();

      void
      UltimateTensileStress (const UltimateTensileStress_type& x);

      void
      UltimateTensileStress (const UltimateTensileStress_optional& x);

      // CompressiveYieldStress
      //
      typedef ::xml_schema::double_ CompressiveYieldStress_type;
      typedef ::xsd::cxx::tree::optional< CompressiveYieldStress_type > CompressiveYieldStress_optional;
      typedef ::xsd::cxx::tree::traits< CompressiveYieldStress_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > CompressiveYieldStress_traits;

      const CompressiveYieldStress_optional&
      CompressiveYieldStress () const;

      CompressiveYieldStress_optional&
      CompressiveYieldStress ();

      void
      CompressiveYieldStress (const CompressiveYieldStress_type& x);

      void
      CompressiveYieldStress (const CompressiveYieldStress_optional& x);

      // TensileYieldStress
      //
      typedef ::xml_schema::double_ TensileYieldStress_type;
      typedef ::xsd::cxx::tree::optional< TensileYieldStress_type > TensileYieldStress_optional;
      typedef ::xsd::cxx::tree::traits< TensileYieldStress_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > TensileYieldStress_traits;

      const TensileYieldStress_optional&
      TensileYieldStress () const;

      TensileYieldStress_optional&
      TensileYieldStress ();

      void
      TensileYieldStress (const TensileYieldStress_type& x);

      void
      TensileYieldStress (const TensileYieldStress_optional& x);

      // ThermalExpansion
      //
      typedef ::xml_schema::double_ ThermalExpansion_type;
      typedef ::xsd::cxx::tree::optional< ThermalExpansion_type > ThermalExpansion_optional;
      typedef ::xsd::cxx::tree::traits< ThermalExpansion_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > ThermalExpansion_traits;

      const ThermalExpansion_optional&
      ThermalExpansion () const;

      ThermalExpansion_optional&
      ThermalExpansion ();

      void
      ThermalExpansion (const ThermalExpansion_type& x);

      void
      ThermalExpansion (const ThermalExpansion_optional& x);

      // SpecificHeatCapacity
      //
      typedef ::xml_schema::double_ SpecificHeatCapacity_type;
      typedef ::xsd::cxx::tree::optional< SpecificHeatCapacity_type > SpecificHeatCapacity_optional;
      typedef ::xsd::cxx::tree::traits< SpecificHeatCapacity_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > SpecificHeatCapacity_traits;

      const SpecificHeatCapacity_optional&
      SpecificHeatCapacity () const;

      SpecificHeatCapacity_optional&
      SpecificHeatCapacity ();

      void
      SpecificHeatCapacity (const SpecificHeatCapacity_type& x);

      void
      SpecificHeatCapacity (const SpecificHeatCapacity_optional& x);

      // ThermalConductivity
      //
      typedef ::xml_schema::double_ ThermalConductivity_type;
      typedef ::xsd::cxx::tree::optional< ThermalConductivity_type > ThermalConductivity_optional;
      typedef ::xsd::cxx::tree::traits< ThermalConductivity_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > ThermalConductivity_traits;

      const ThermalConductivity_optional&
      ThermalConductivity () const;

      ThermalConductivity_optional&
      ThermalConductivity ();

      void
      ThermalConductivity (const ThermalConductivity_type& x);

      void
      ThermalConductivity (const ThermalConductivity_optional& x);

      // Index
      //
      typedef ::xsd::qif30::NaturalType Index_type;
      typedef ::xsd::cxx::tree::traits< Index_type, wchar_t > Index_traits;

      const Index_type&
      Index () const;

      Index_type&
      Index ();

      void
      Index (const Index_type& x);

      void
      Index (::std::unique_ptr< Index_type > p);

      // MaterialName
      //
      typedef ::xml_schema::token MaterialName_type;
      typedef ::xsd::cxx::tree::traits< MaterialName_type, wchar_t > MaterialName_traits;

      const MaterialName_type&
      MaterialName () const;

      MaterialName_type&
      MaterialName ();

      void
      MaterialName (const MaterialName_type& x);

      void
      MaterialName (::std::unique_ptr< MaterialName_type > p);

      // Constructors.
      //
      MaterialType ();

      MaterialType (const Index_type&,
                    const MaterialName_type&);

      MaterialType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      MaterialType (const MaterialType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual MaterialType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MaterialType&
      operator= (const MaterialType& x);

      virtual 
      ~MaterialType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      MaterialClassEnum_optional MaterialClassEnum_;
      OtherMaterialClass_optional OtherMaterialClass_;
      Description_optional Description_;
      MassDensity_optional MassDensity_;
      PoissonsRatio_optional PoissonsRatio_;
      YoungsModulus_optional YoungsModulus_;
      UltimateTensileStress_optional UltimateTensileStress_;
      CompressiveYieldStress_optional CompressiveYieldStress_;
      TensileYieldStress_optional TensileYieldStress_;
      ThermalExpansion_optional ThermalExpansion_;
      SpecificHeatCapacity_optional SpecificHeatCapacity_;
      ThermalConductivity_optional ThermalConductivity_;
      ::xsd::cxx::tree::one< Index_type > Index_;
      ::xsd::cxx::tree::one< MaterialName_type > MaterialName_;
    };

    class QIF30_SYMBOL_DECL MaterialsType: public ::xml_schema::type
    {
      public:
      // Material
      //
      typedef ::xsd::qif30::MaterialType Material_type;
      typedef ::xsd::cxx::tree::sequence< Material_type > Material_sequence;
      typedef xsd::cxx::tree::sequence< Material_type >::iterator Material_iterator;
      typedef xsd::cxx::tree::sequence< Material_type >::const_iterator Material_const_iterator;
      typedef ::xsd::cxx::tree::traits< Material_type, wchar_t > Material_traits;

      const Material_sequence&
      Material () const;

      Material_sequence&
      Material ();

      void
      Material (const Material_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      MaterialsType ();

      MaterialsType (const n_type&);

      MaterialsType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      MaterialsType (const MaterialsType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual MaterialsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MaterialsType&
      operator= (const MaterialsType& x);

      virtual 
      ~MaterialsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Material_sequence Material_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL VirtualMeasurementType: public ::xml_schema::type
    {
      public:
      // id
      //
      typedef ::xsd::qif30::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::unique_ptr< id_type > p);

      // Constructors.
      //
      VirtualMeasurementType ();

      VirtualMeasurementType (const id_type&);

      VirtualMeasurementType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      VirtualMeasurementType (const VirtualMeasurementType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual VirtualMeasurementType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VirtualMeasurementType&
      operator= (const VirtualMeasurementType& x);

      virtual 
      ~VirtualMeasurementType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class QIF30_SYMBOL_DECL PointSetReferenceBaseType: public ::xsd::qif30::QIFReferenceType
    {
      public:
      // Constructors.
      //
      PointSetReferenceBaseType ();

      PointSetReferenceBaseType (const ::xml_schema::unsigned_int&);

      PointSetReferenceBaseType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      PointSetReferenceBaseType (const PointSetReferenceBaseType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual PointSetReferenceBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      PointSetReferenceBaseType&
      operator= (const PointSetReferenceBaseType&) = default;
#endif

      virtual 
      ~PointSetReferenceBaseType ();
    };

    class QIF30_SYMBOL_DECL PointSetReferenceWholeType: public ::xsd::qif30::PointSetReferenceBaseType
    {
      public:
      // Constructors.
      //
      PointSetReferenceWholeType ();

      PointSetReferenceWholeType (const ::xml_schema::unsigned_int&);

      PointSetReferenceWholeType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      PointSetReferenceWholeType (const PointSetReferenceWholeType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual PointSetReferenceWholeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      PointSetReferenceWholeType&
      operator= (const PointSetReferenceWholeType&) = default;
#endif

      virtual 
      ~PointSetReferenceWholeType ();
    };

    class QIF30_SYMBOL_DECL PointSetReferenceRangeType: public ::xsd::qif30::PointSetReferenceBaseType
    {
      public:
      // range
      //
      typedef ::xsd::qif30::Natural2Type range_type;
      typedef ::xsd::cxx::tree::traits< range_type, wchar_t > range_traits;

      const range_type&
      range () const;

      range_type&
      range ();

      void
      range (const range_type& x);

      void
      range (::std::unique_ptr< range_type > p);

      // Constructors.
      //
      PointSetReferenceRangeType ();

      PointSetReferenceRangeType (const ::xml_schema::unsigned_int&,
                                  const range_type&);

      PointSetReferenceRangeType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      PointSetReferenceRangeType (const PointSetReferenceRangeType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual PointSetReferenceRangeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointSetReferenceRangeType&
      operator= (const PointSetReferenceRangeType& x);

      virtual 
      ~PointSetReferenceRangeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< range_type > range_;
    };

    class QIF30_SYMBOL_DECL PointSetReferenceSingleType: public ::xsd::qif30::PointSetReferenceBaseType
    {
      public:
      // index
      //
      typedef ::xsd::qif30::NaturalType index_type;
      typedef ::xsd::cxx::tree::traits< index_type, wchar_t > index_traits;

      const index_type&
      index () const;

      index_type&
      index ();

      void
      index (const index_type& x);

      void
      index (::std::unique_ptr< index_type > p);

      // Constructors.
      //
      PointSetReferenceSingleType ();

      PointSetReferenceSingleType (const ::xml_schema::unsigned_int&,
                                   const index_type&);

      PointSetReferenceSingleType (const xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      PointSetReferenceSingleType (const PointSetReferenceSingleType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual PointSetReferenceSingleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointSetReferenceSingleType&
      operator= (const PointSetReferenceSingleType& x);

      virtual 
      ~PointSetReferenceSingleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< index_type > index_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SequencedDatumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CompoundDatumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumWithPrecedenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumTranslationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumFeatureBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredDatumFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NominalDatumFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumFeatureSimulatorModifierType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumReferenceFrameType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DegreeOfFreedomEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DegreeOfFreedomEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DegreeOfFreedomEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ISODegreeOfFreedomEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ISODegreeOfFreedomEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ISODegreeOfFreedomEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IntersectionPlaneEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const IntersectionPlaneEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const IntersectionPlaneEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const IntersectionPlaneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ModifyingPlaneEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ModifyingPlaneEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ModifyingPlaneEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DirectionFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CollectionPlaneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrientationPlaneType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ReducedDatumEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ReducedDatumEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ReducedDatumEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DegreesOfFreedomType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DiameterModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DiameterModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DiameterModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SectionModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SectionModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SectionModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointWithNormalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasuredPointWithNormalBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurePointNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MovableDatumTargetDirectionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DefiningPointNominalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DefiningPointMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TransformListType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TransformInstanceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearCoordinateDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LinearCoordinateDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LinearCoordinateDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularCoordinateDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const AngularCoordinateDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const AngularCoordinateDirectionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SubstituteFeatureAlgorithmEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SubstituteFeatureAlgorithmEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SubstituteFeatureAlgorithmEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SubstituteFeatureAlgorithmType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MaterialModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const MaterialModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const MaterialModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PrecedenceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const PrecedenceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const PrecedenceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PrecedenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ReferencedComponentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ReferencedComponentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ReferencedComponentEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RetrievalMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const RetrievalMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const RetrievalMethodEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementDirectiveEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const MeasurementDirectiveEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const MeasurementDirectiveEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementDirectiveType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DistanceBetweenAnalysisModeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DistanceBetweenAnalysisModeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DistanceBetweenAnalysisModeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngleBetweenAnalysisModeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const AngleBetweenAnalysisModeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const AngleBetweenAnalysisModeEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BaseFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SequencedBaseFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DirectionalOffsetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AlignmentFeatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AlignmentOperationBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PrimaryAlignmentOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SecondaryAlignmentOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementOriginOffsetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeasurementOffsetAlignmentOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NominalOffsetAlignmentOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NominalRotationAlignmentOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumPrecedenceAlignmentOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const BestFitAlignmentOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MachineCoordinateSystemOperationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AlignmentOperationsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MachineCoordinateSystemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateSystemListType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateSystemsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateSystemType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateSystemActualTransformAssociationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CoordinateSystemActualTransformAssociationsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadSpecificationDetailedBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SingleLeadThreadSpecificationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MultiLeadThreadSpecificationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadSpecificationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TextThreadSpecificationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ThreadSpecificationsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToleranceZonePerUnitAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToleranceZonePerUnitLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToleranceZonePerUnitAngleType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ToleranceZonePerUnitPolarAreaType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumReferenceFramesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EventBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NotableEventType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NotableEventsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NotedEventType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NotedEventsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const InspectionStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const InspectionStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const InspectionStatusEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const InspectionStatusType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EntityExternalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EntitiesExternalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ZoneDataType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ZoneDataSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LinearToleranceDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AngularToleranceDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TemperatureToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AreaToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ForceToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MassToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PressureToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SpeedToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TimeToleranceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DimensionModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DimensionModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DimensionModifierEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DimensionDeterminationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DimensionDeterminationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DimensionDeterminationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SignificantDimensionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const SignificantDimensionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const SignificantDimensionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DimensionModifiersType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const NonToleranceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const NonToleranceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const NonToleranceEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LimitsAndFitsZoneVarianceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const LimitsAndFitsZoneVarianceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const LimitsAndFitsZoneVarianceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LimitsAndFitsSpecificationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CommonFileSpecEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CommonFileSpecEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CommonFileSpecEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FileSpecType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExternalFileReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ExternalFileReferencesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumTargetDefinitionsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumDefinitionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumDefinitionsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DatumTargetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const EmployeeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const FileType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SoftwareType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StandardsOrganizationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const StandardsOrganizationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const StandardsOrganizationEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StandardsOrganizationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StandardType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const StandardsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SoftwaresType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AlgorithmType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AlgorithmsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const OrganizationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PhysicalAddressType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AddressDescriptionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const AddressDescriptionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const AddressDescriptionEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const AddressDescriptionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const LocationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CustomerOrganizationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VersionHistoryType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VersionBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VersionType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VersionReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SignOffsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MaterialClassEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const MaterialClassEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const MaterialClassEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MaterialType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MaterialsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const VirtualMeasurementType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointSetReferenceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointSetReferenceWholeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointSetReferenceRangeType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointSetReferenceSingleType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_INTERMEDIATES_PMI_HXX
