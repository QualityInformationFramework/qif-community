// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Units.hxx"

namespace xsd
{
  namespace qif30
  {
    // PositiveDecimalType
    //


    // NonNegativeDecimalType
    //


    // UnitConversionType
    //

    const UnitConversionType::Factor_type& UnitConversionType::
    Factor () const
    {
      return this->Factor_.get ();
    }

    UnitConversionType::Factor_type& UnitConversionType::
    Factor ()
    {
      return this->Factor_.get ();
    }

    void UnitConversionType::
    Factor (const Factor_type& x)
    {
      this->Factor_.set (x);
    }

    void UnitConversionType::
    Factor (::std::unique_ptr< Factor_type > x)
    {
      this->Factor_.set (std::move (x));
    }

    const UnitConversionType::Offset_optional& UnitConversionType::
    Offset () const
    {
      return this->Offset_;
    }

    UnitConversionType::Offset_optional& UnitConversionType::
    Offset ()
    {
      return this->Offset_;
    }

    void UnitConversionType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void UnitConversionType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    UnitConversionType::Offset_type UnitConversionType::
    Offset_default_value ()
    {
      return Offset_type (0.0);
    }


    // SpecifiedDecimalType
    //

    const SpecifiedDecimalType::decimalPlaces_optional& SpecifiedDecimalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    SpecifiedDecimalType::decimalPlaces_optional& SpecifiedDecimalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void SpecifiedDecimalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void SpecifiedDecimalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const SpecifiedDecimalType::significantFigures_optional& SpecifiedDecimalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    SpecifiedDecimalType::significantFigures_optional& SpecifiedDecimalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void SpecifiedDecimalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void SpecifiedDecimalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }


    // MeasuredDecimalType
    //

    const MeasuredDecimalType::combinedUncertainty_optional& MeasuredDecimalType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    MeasuredDecimalType::combinedUncertainty_optional& MeasuredDecimalType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void MeasuredDecimalType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void MeasuredDecimalType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    void MeasuredDecimalType::
    combinedUncertainty (::std::unique_ptr< combinedUncertainty_type > x)
    {
      this->combinedUncertainty_.set (std::move (x));
    }

    const MeasuredDecimalType::meanError_optional& MeasuredDecimalType::
    meanError () const
    {
      return this->meanError_;
    }

    MeasuredDecimalType::meanError_optional& MeasuredDecimalType::
    meanError ()
    {
      return this->meanError_;
    }

    void MeasuredDecimalType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void MeasuredDecimalType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    void MeasuredDecimalType::
    meanError (::std::unique_ptr< meanError_type > x)
    {
      this->meanError_.set (std::move (x));
    }


    // AngularUnitType
    //

    const AngularUnitType::SIUnitName_optional& AngularUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    AngularUnitType::SIUnitName_optional& AngularUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void AngularUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void AngularUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void AngularUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const AngularUnitType::SIUnitName_type& AngularUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const AngularUnitType::UnitName_type& AngularUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    AngularUnitType::UnitName_type& AngularUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void AngularUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void AngularUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const AngularUnitType::UnitConversion_optional& AngularUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    AngularUnitType::UnitConversion_optional& AngularUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void AngularUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void AngularUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void AngularUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // AngularValueType
    //

    const AngularValueType::angularUnit_optional& AngularValueType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    AngularValueType::angularUnit_optional& AngularValueType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void AngularValueType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void AngularValueType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void AngularValueType::
    angularUnit (::std::unique_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (std::move (x));
    }


    // MeasuredAngularValueType
    //

    const MeasuredAngularValueType::angularUnit_optional& MeasuredAngularValueType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    MeasuredAngularValueType::angularUnit_optional& MeasuredAngularValueType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void MeasuredAngularValueType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void MeasuredAngularValueType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void MeasuredAngularValueType::
    angularUnit (::std::unique_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (std::move (x));
    }


    // AreaUnitType
    //

    const AreaUnitType::SIUnitName_optional& AreaUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    AreaUnitType::SIUnitName_optional& AreaUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void AreaUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void AreaUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void AreaUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const AreaUnitType::SIUnitName_type& AreaUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const AreaUnitType::UnitName_type& AreaUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    AreaUnitType::UnitName_type& AreaUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void AreaUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void AreaUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const AreaUnitType::UnitConversion_optional& AreaUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    AreaUnitType::UnitConversion_optional& AreaUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void AreaUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void AreaUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void AreaUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // AreaValueType
    //

    const AreaValueType::areaUnit_optional& AreaValueType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    AreaValueType::areaUnit_optional& AreaValueType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void AreaValueType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void AreaValueType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void AreaValueType::
    areaUnit (::std::unique_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (std::move (x));
    }


    // MeasuredAreaValueType
    //

    const MeasuredAreaValueType::areaUnit_optional& MeasuredAreaValueType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    MeasuredAreaValueType::areaUnit_optional& MeasuredAreaValueType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void MeasuredAreaValueType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void MeasuredAreaValueType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void MeasuredAreaValueType::
    areaUnit (::std::unique_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (std::move (x));
    }


    // ForceUnitType
    //

    const ForceUnitType::SIUnitName_optional& ForceUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    ForceUnitType::SIUnitName_optional& ForceUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void ForceUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void ForceUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void ForceUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const ForceUnitType::SIUnitName_type& ForceUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const ForceUnitType::UnitName_type& ForceUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    ForceUnitType::UnitName_type& ForceUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void ForceUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void ForceUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const ForceUnitType::UnitConversion_optional& ForceUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    ForceUnitType::UnitConversion_optional& ForceUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void ForceUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void ForceUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void ForceUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // ForceValueType
    //

    const ForceValueType::forceUnit_optional& ForceValueType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    ForceValueType::forceUnit_optional& ForceValueType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void ForceValueType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void ForceValueType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void ForceValueType::
    forceUnit (::std::unique_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (std::move (x));
    }


    // MeasuredForceValueType
    //

    const MeasuredForceValueType::forceUnit_optional& MeasuredForceValueType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    MeasuredForceValueType::forceUnit_optional& MeasuredForceValueType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void MeasuredForceValueType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void MeasuredForceValueType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void MeasuredForceValueType::
    forceUnit (::std::unique_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (std::move (x));
    }


    // LinearUnitType
    //

    const LinearUnitType::SIUnitName_optional& LinearUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    LinearUnitType::SIUnitName_optional& LinearUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void LinearUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void LinearUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void LinearUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const LinearUnitType::SIUnitName_type& LinearUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const LinearUnitType::UnitName_type& LinearUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    LinearUnitType::UnitName_type& LinearUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void LinearUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void LinearUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const LinearUnitType::UnitConversion_optional& LinearUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    LinearUnitType::UnitConversion_optional& LinearUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void LinearUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void LinearUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void LinearUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // LinearValueType
    //

    const LinearValueType::linearUnit_optional& LinearValueType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    LinearValueType::linearUnit_optional& LinearValueType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void LinearValueType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void LinearValueType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void LinearValueType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }


    // LinearDualValueType
    //

    const LinearDualValueType::linearUnit_type& LinearDualValueType::
    linearUnit () const
    {
      return this->linearUnit_.get ();
    }

    LinearDualValueType::linearUnit_type& LinearDualValueType::
    linearUnit ()
    {
      return this->linearUnit_.get ();
    }

    void LinearDualValueType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void LinearDualValueType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }


    // MeasuredLinearValueType
    //

    const MeasuredLinearValueType::linearUnit_optional& MeasuredLinearValueType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    MeasuredLinearValueType::linearUnit_optional& MeasuredLinearValueType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void MeasuredLinearValueType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void MeasuredLinearValueType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void MeasuredLinearValueType::
    linearUnit (::std::unique_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (std::move (x));
    }


    // MassUnitType
    //

    const MassUnitType::SIUnitName_optional& MassUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    MassUnitType::SIUnitName_optional& MassUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void MassUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void MassUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void MassUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const MassUnitType::SIUnitName_type& MassUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const MassUnitType::UnitName_type& MassUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    MassUnitType::UnitName_type& MassUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void MassUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void MassUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const MassUnitType::UnitConversion_optional& MassUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    MassUnitType::UnitConversion_optional& MassUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void MassUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void MassUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void MassUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // MassValueType
    //

    const MassValueType::massUnit_optional& MassValueType::
    massUnit () const
    {
      return this->massUnit_;
    }

    MassValueType::massUnit_optional& MassValueType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void MassValueType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void MassValueType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void MassValueType::
    massUnit (::std::unique_ptr< massUnit_type > x)
    {
      this->massUnit_.set (std::move (x));
    }


    // MeasuredMassValueType
    //

    const MeasuredMassValueType::massUnit_optional& MeasuredMassValueType::
    massUnit () const
    {
      return this->massUnit_;
    }

    MeasuredMassValueType::massUnit_optional& MeasuredMassValueType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void MeasuredMassValueType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void MeasuredMassValueType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void MeasuredMassValueType::
    massUnit (::std::unique_ptr< massUnit_type > x)
    {
      this->massUnit_.set (std::move (x));
    }


    // PressureUnitType
    //

    const PressureUnitType::SIUnitName_optional& PressureUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    PressureUnitType::SIUnitName_optional& PressureUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void PressureUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void PressureUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void PressureUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const PressureUnitType::SIUnitName_type& PressureUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const PressureUnitType::UnitName_type& PressureUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    PressureUnitType::UnitName_type& PressureUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void PressureUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void PressureUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const PressureUnitType::UnitConversion_optional& PressureUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    PressureUnitType::UnitConversion_optional& PressureUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void PressureUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void PressureUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void PressureUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // PressureValueType
    //

    const PressureValueType::pressureUnit_optional& PressureValueType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    PressureValueType::pressureUnit_optional& PressureValueType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void PressureValueType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void PressureValueType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void PressureValueType::
    pressureUnit (::std::unique_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (std::move (x));
    }


    // MeasuredPressureValueType
    //

    const MeasuredPressureValueType::pressureUnit_optional& MeasuredPressureValueType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    MeasuredPressureValueType::pressureUnit_optional& MeasuredPressureValueType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void MeasuredPressureValueType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void MeasuredPressureValueType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void MeasuredPressureValueType::
    pressureUnit (::std::unique_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (std::move (x));
    }


    // SpeedUnitType
    //

    const SpeedUnitType::SIUnitName_optional& SpeedUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    SpeedUnitType::SIUnitName_optional& SpeedUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void SpeedUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void SpeedUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void SpeedUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const SpeedUnitType::SIUnitName_type& SpeedUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const SpeedUnitType::UnitName_type& SpeedUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    SpeedUnitType::UnitName_type& SpeedUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void SpeedUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void SpeedUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const SpeedUnitType::UnitConversion_optional& SpeedUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    SpeedUnitType::UnitConversion_optional& SpeedUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void SpeedUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void SpeedUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void SpeedUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // SpeedValueType
    //

    const SpeedValueType::speedUnit_optional& SpeedValueType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    SpeedValueType::speedUnit_optional& SpeedValueType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void SpeedValueType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void SpeedValueType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void SpeedValueType::
    speedUnit (::std::unique_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (std::move (x));
    }


    // MeasuredSpeedValueType
    //

    const MeasuredSpeedValueType::speedUnit_optional& MeasuredSpeedValueType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    MeasuredSpeedValueType::speedUnit_optional& MeasuredSpeedValueType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void MeasuredSpeedValueType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void MeasuredSpeedValueType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void MeasuredSpeedValueType::
    speedUnit (::std::unique_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (std::move (x));
    }


    // TemperatureUnitType
    //

    const TemperatureUnitType::SIUnitName_optional& TemperatureUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    TemperatureUnitType::SIUnitName_optional& TemperatureUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void TemperatureUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void TemperatureUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void TemperatureUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const TemperatureUnitType::SIUnitName_type& TemperatureUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const TemperatureUnitType::UnitName_type& TemperatureUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    TemperatureUnitType::UnitName_type& TemperatureUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void TemperatureUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void TemperatureUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const TemperatureUnitType::UnitConversion_optional& TemperatureUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    TemperatureUnitType::UnitConversion_optional& TemperatureUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void TemperatureUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void TemperatureUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void TemperatureUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // TemperatureValueType
    //

    const TemperatureValueType::temperatureUnit_optional& TemperatureValueType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    TemperatureValueType::temperatureUnit_optional& TemperatureValueType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void TemperatureValueType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void TemperatureValueType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void TemperatureValueType::
    temperatureUnit (::std::unique_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (std::move (x));
    }


    // MeasuredTemperatureValueType
    //

    const MeasuredTemperatureValueType::temperatureUnit_optional& MeasuredTemperatureValueType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    MeasuredTemperatureValueType::temperatureUnit_optional& MeasuredTemperatureValueType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void MeasuredTemperatureValueType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void MeasuredTemperatureValueType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void MeasuredTemperatureValueType::
    temperatureUnit (::std::unique_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (std::move (x));
    }


    // TimeUnitType
    //

    const TimeUnitType::SIUnitName_optional& TimeUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    TimeUnitType::SIUnitName_optional& TimeUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void TimeUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void TimeUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void TimeUnitType::
    SIUnitName (::std::unique_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (std::move (x));
    }

    const TimeUnitType::SIUnitName_type& TimeUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const TimeUnitType::UnitName_type& TimeUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    TimeUnitType::UnitName_type& TimeUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void TimeUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void TimeUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const TimeUnitType::UnitConversion_optional& TimeUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    TimeUnitType::UnitConversion_optional& TimeUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void TimeUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void TimeUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void TimeUnitType::
    UnitConversion (::std::unique_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (std::move (x));
    }


    // TimeValueType
    //

    const TimeValueType::timeUnit_optional& TimeValueType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    TimeValueType::timeUnit_optional& TimeValueType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void TimeValueType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void TimeValueType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void TimeValueType::
    timeUnit (::std::unique_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (std::move (x));
    }


    // MeasuredTimeValueType
    //

    const MeasuredTimeValueType::timeUnit_optional& MeasuredTimeValueType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    MeasuredTimeValueType::timeUnit_optional& MeasuredTimeValueType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void MeasuredTimeValueType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void MeasuredTimeValueType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void MeasuredTimeValueType::
    timeUnit (::std::unique_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (std::move (x));
    }


    // PrimaryUnitsType
    //

    const PrimaryUnitsType::AreaUnit_optional& PrimaryUnitsType::
    AreaUnit () const
    {
      return this->AreaUnit_;
    }

    PrimaryUnitsType::AreaUnit_optional& PrimaryUnitsType::
    AreaUnit ()
    {
      return this->AreaUnit_;
    }

    void PrimaryUnitsType::
    AreaUnit (const AreaUnit_type& x)
    {
      this->AreaUnit_.set (x);
    }

    void PrimaryUnitsType::
    AreaUnit (const AreaUnit_optional& x)
    {
      this->AreaUnit_ = x;
    }

    void PrimaryUnitsType::
    AreaUnit (::std::unique_ptr< AreaUnit_type > x)
    {
      this->AreaUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::PMIAreaUnit_optional& PrimaryUnitsType::
    PMIAreaUnit () const
    {
      return this->PMIAreaUnit_;
    }

    PrimaryUnitsType::PMIAreaUnit_optional& PrimaryUnitsType::
    PMIAreaUnit ()
    {
      return this->PMIAreaUnit_;
    }

    void PrimaryUnitsType::
    PMIAreaUnit (const PMIAreaUnit_type& x)
    {
      this->PMIAreaUnit_.set (x);
    }

    void PrimaryUnitsType::
    PMIAreaUnit (const PMIAreaUnit_optional& x)
    {
      this->PMIAreaUnit_ = x;
    }

    void PrimaryUnitsType::
    PMIAreaUnit (::std::unique_ptr< PMIAreaUnit_type > x)
    {
      this->PMIAreaUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::AngularUnit_optional& PrimaryUnitsType::
    AngularUnit () const
    {
      return this->AngularUnit_;
    }

    PrimaryUnitsType::AngularUnit_optional& PrimaryUnitsType::
    AngularUnit ()
    {
      return this->AngularUnit_;
    }

    void PrimaryUnitsType::
    AngularUnit (const AngularUnit_type& x)
    {
      this->AngularUnit_.set (x);
    }

    void PrimaryUnitsType::
    AngularUnit (const AngularUnit_optional& x)
    {
      this->AngularUnit_ = x;
    }

    void PrimaryUnitsType::
    AngularUnit (::std::unique_ptr< AngularUnit_type > x)
    {
      this->AngularUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::PMIAngularUnit_optional& PrimaryUnitsType::
    PMIAngularUnit () const
    {
      return this->PMIAngularUnit_;
    }

    PrimaryUnitsType::PMIAngularUnit_optional& PrimaryUnitsType::
    PMIAngularUnit ()
    {
      return this->PMIAngularUnit_;
    }

    void PrimaryUnitsType::
    PMIAngularUnit (const PMIAngularUnit_type& x)
    {
      this->PMIAngularUnit_.set (x);
    }

    void PrimaryUnitsType::
    PMIAngularUnit (const PMIAngularUnit_optional& x)
    {
      this->PMIAngularUnit_ = x;
    }

    void PrimaryUnitsType::
    PMIAngularUnit (::std::unique_ptr< PMIAngularUnit_type > x)
    {
      this->PMIAngularUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::ForceUnit_optional& PrimaryUnitsType::
    ForceUnit () const
    {
      return this->ForceUnit_;
    }

    PrimaryUnitsType::ForceUnit_optional& PrimaryUnitsType::
    ForceUnit ()
    {
      return this->ForceUnit_;
    }

    void PrimaryUnitsType::
    ForceUnit (const ForceUnit_type& x)
    {
      this->ForceUnit_.set (x);
    }

    void PrimaryUnitsType::
    ForceUnit (const ForceUnit_optional& x)
    {
      this->ForceUnit_ = x;
    }

    void PrimaryUnitsType::
    ForceUnit (::std::unique_ptr< ForceUnit_type > x)
    {
      this->ForceUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::LinearUnit_optional& PrimaryUnitsType::
    LinearUnit () const
    {
      return this->LinearUnit_;
    }

    PrimaryUnitsType::LinearUnit_optional& PrimaryUnitsType::
    LinearUnit ()
    {
      return this->LinearUnit_;
    }

    void PrimaryUnitsType::
    LinearUnit (const LinearUnit_type& x)
    {
      this->LinearUnit_.set (x);
    }

    void PrimaryUnitsType::
    LinearUnit (const LinearUnit_optional& x)
    {
      this->LinearUnit_ = x;
    }

    void PrimaryUnitsType::
    LinearUnit (::std::unique_ptr< LinearUnit_type > x)
    {
      this->LinearUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::PMILinearUnit_optional& PrimaryUnitsType::
    PMILinearUnit () const
    {
      return this->PMILinearUnit_;
    }

    PrimaryUnitsType::PMILinearUnit_optional& PrimaryUnitsType::
    PMILinearUnit ()
    {
      return this->PMILinearUnit_;
    }

    void PrimaryUnitsType::
    PMILinearUnit (const PMILinearUnit_type& x)
    {
      this->PMILinearUnit_.set (x);
    }

    void PrimaryUnitsType::
    PMILinearUnit (const PMILinearUnit_optional& x)
    {
      this->PMILinearUnit_ = x;
    }

    void PrimaryUnitsType::
    PMILinearUnit (::std::unique_ptr< PMILinearUnit_type > x)
    {
      this->PMILinearUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::MassUnit_optional& PrimaryUnitsType::
    MassUnit () const
    {
      return this->MassUnit_;
    }

    PrimaryUnitsType::MassUnit_optional& PrimaryUnitsType::
    MassUnit ()
    {
      return this->MassUnit_;
    }

    void PrimaryUnitsType::
    MassUnit (const MassUnit_type& x)
    {
      this->MassUnit_.set (x);
    }

    void PrimaryUnitsType::
    MassUnit (const MassUnit_optional& x)
    {
      this->MassUnit_ = x;
    }

    void PrimaryUnitsType::
    MassUnit (::std::unique_ptr< MassUnit_type > x)
    {
      this->MassUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::PressureUnit_optional& PrimaryUnitsType::
    PressureUnit () const
    {
      return this->PressureUnit_;
    }

    PrimaryUnitsType::PressureUnit_optional& PrimaryUnitsType::
    PressureUnit ()
    {
      return this->PressureUnit_;
    }

    void PrimaryUnitsType::
    PressureUnit (const PressureUnit_type& x)
    {
      this->PressureUnit_.set (x);
    }

    void PrimaryUnitsType::
    PressureUnit (const PressureUnit_optional& x)
    {
      this->PressureUnit_ = x;
    }

    void PrimaryUnitsType::
    PressureUnit (::std::unique_ptr< PressureUnit_type > x)
    {
      this->PressureUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::SpeedUnit_optional& PrimaryUnitsType::
    SpeedUnit () const
    {
      return this->SpeedUnit_;
    }

    PrimaryUnitsType::SpeedUnit_optional& PrimaryUnitsType::
    SpeedUnit ()
    {
      return this->SpeedUnit_;
    }

    void PrimaryUnitsType::
    SpeedUnit (const SpeedUnit_type& x)
    {
      this->SpeedUnit_.set (x);
    }

    void PrimaryUnitsType::
    SpeedUnit (const SpeedUnit_optional& x)
    {
      this->SpeedUnit_ = x;
    }

    void PrimaryUnitsType::
    SpeedUnit (::std::unique_ptr< SpeedUnit_type > x)
    {
      this->SpeedUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::TemperatureUnit_optional& PrimaryUnitsType::
    TemperatureUnit () const
    {
      return this->TemperatureUnit_;
    }

    PrimaryUnitsType::TemperatureUnit_optional& PrimaryUnitsType::
    TemperatureUnit ()
    {
      return this->TemperatureUnit_;
    }

    void PrimaryUnitsType::
    TemperatureUnit (const TemperatureUnit_type& x)
    {
      this->TemperatureUnit_.set (x);
    }

    void PrimaryUnitsType::
    TemperatureUnit (const TemperatureUnit_optional& x)
    {
      this->TemperatureUnit_ = x;
    }

    void PrimaryUnitsType::
    TemperatureUnit (::std::unique_ptr< TemperatureUnit_type > x)
    {
      this->TemperatureUnit_.set (std::move (x));
    }

    const PrimaryUnitsType::TimeUnit_optional& PrimaryUnitsType::
    TimeUnit () const
    {
      return this->TimeUnit_;
    }

    PrimaryUnitsType::TimeUnit_optional& PrimaryUnitsType::
    TimeUnit ()
    {
      return this->TimeUnit_;
    }

    void PrimaryUnitsType::
    TimeUnit (const TimeUnit_type& x)
    {
      this->TimeUnit_.set (x);
    }

    void PrimaryUnitsType::
    TimeUnit (const TimeUnit_optional& x)
    {
      this->TimeUnit_ = x;
    }

    void PrimaryUnitsType::
    TimeUnit (::std::unique_ptr< TimeUnit_type > x)
    {
      this->TimeUnit_.set (std::move (x));
    }


    // OtherUnitsType
    //

    const OtherUnitsType::AreaUnit_sequence& OtherUnitsType::
    AreaUnit () const
    {
      return this->AreaUnit_;
    }

    OtherUnitsType::AreaUnit_sequence& OtherUnitsType::
    AreaUnit ()
    {
      return this->AreaUnit_;
    }

    void OtherUnitsType::
    AreaUnit (const AreaUnit_sequence& s)
    {
      this->AreaUnit_ = s;
    }

    const OtherUnitsType::AngularUnit_sequence& OtherUnitsType::
    AngularUnit () const
    {
      return this->AngularUnit_;
    }

    OtherUnitsType::AngularUnit_sequence& OtherUnitsType::
    AngularUnit ()
    {
      return this->AngularUnit_;
    }

    void OtherUnitsType::
    AngularUnit (const AngularUnit_sequence& s)
    {
      this->AngularUnit_ = s;
    }

    const OtherUnitsType::ForceUnit_sequence& OtherUnitsType::
    ForceUnit () const
    {
      return this->ForceUnit_;
    }

    OtherUnitsType::ForceUnit_sequence& OtherUnitsType::
    ForceUnit ()
    {
      return this->ForceUnit_;
    }

    void OtherUnitsType::
    ForceUnit (const ForceUnit_sequence& s)
    {
      this->ForceUnit_ = s;
    }

    const OtherUnitsType::LinearUnit_sequence& OtherUnitsType::
    LinearUnit () const
    {
      return this->LinearUnit_;
    }

    OtherUnitsType::LinearUnit_sequence& OtherUnitsType::
    LinearUnit ()
    {
      return this->LinearUnit_;
    }

    void OtherUnitsType::
    LinearUnit (const LinearUnit_sequence& s)
    {
      this->LinearUnit_ = s;
    }

    const OtherUnitsType::MassUnit_sequence& OtherUnitsType::
    MassUnit () const
    {
      return this->MassUnit_;
    }

    OtherUnitsType::MassUnit_sequence& OtherUnitsType::
    MassUnit ()
    {
      return this->MassUnit_;
    }

    void OtherUnitsType::
    MassUnit (const MassUnit_sequence& s)
    {
      this->MassUnit_ = s;
    }

    const OtherUnitsType::PressureUnit_sequence& OtherUnitsType::
    PressureUnit () const
    {
      return this->PressureUnit_;
    }

    OtherUnitsType::PressureUnit_sequence& OtherUnitsType::
    PressureUnit ()
    {
      return this->PressureUnit_;
    }

    void OtherUnitsType::
    PressureUnit (const PressureUnit_sequence& s)
    {
      this->PressureUnit_ = s;
    }

    const OtherUnitsType::SpeedUnit_sequence& OtherUnitsType::
    SpeedUnit () const
    {
      return this->SpeedUnit_;
    }

    OtherUnitsType::SpeedUnit_sequence& OtherUnitsType::
    SpeedUnit ()
    {
      return this->SpeedUnit_;
    }

    void OtherUnitsType::
    SpeedUnit (const SpeedUnit_sequence& s)
    {
      this->SpeedUnit_ = s;
    }

    const OtherUnitsType::TemperatureUnit_sequence& OtherUnitsType::
    TemperatureUnit () const
    {
      return this->TemperatureUnit_;
    }

    OtherUnitsType::TemperatureUnit_sequence& OtherUnitsType::
    TemperatureUnit ()
    {
      return this->TemperatureUnit_;
    }

    void OtherUnitsType::
    TemperatureUnit (const TemperatureUnit_sequence& s)
    {
      this->TemperatureUnit_ = s;
    }

    const OtherUnitsType::TimeUnit_sequence& OtherUnitsType::
    TimeUnit () const
    {
      return this->TimeUnit_;
    }

    OtherUnitsType::TimeUnit_sequence& OtherUnitsType::
    TimeUnit ()
    {
      return this->TimeUnit_;
    }

    void OtherUnitsType::
    TimeUnit (const TimeUnit_sequence& s)
    {
      this->TimeUnit_ = s;
    }

    const OtherUnitsType::n_type& OtherUnitsType::
    n () const
    {
      return this->n_.get ();
    }

    OtherUnitsType::n_type& OtherUnitsType::
    n ()
    {
      return this->n_.get ();
    }

    void OtherUnitsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void OtherUnitsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // UserDefinedUnitType
    //

    const UserDefinedUnitType::WhatIsMeasured_type& UserDefinedUnitType::
    WhatIsMeasured () const
    {
      return this->WhatIsMeasured_.get ();
    }

    UserDefinedUnitType::WhatIsMeasured_type& UserDefinedUnitType::
    WhatIsMeasured ()
    {
      return this->WhatIsMeasured_.get ();
    }

    void UserDefinedUnitType::
    WhatIsMeasured (const WhatIsMeasured_type& x)
    {
      this->WhatIsMeasured_.set (x);
    }

    void UserDefinedUnitType::
    WhatIsMeasured (::std::unique_ptr< WhatIsMeasured_type > x)
    {
      this->WhatIsMeasured_.set (std::move (x));
    }

    const UserDefinedUnitType::UnitName_type& UserDefinedUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    UserDefinedUnitType::UnitName_type& UserDefinedUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void UserDefinedUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void UserDefinedUnitType::
    UnitName (::std::unique_ptr< UnitName_type > x)
    {
      this->UnitName_.set (std::move (x));
    }

    const UserDefinedUnitType::StandardName_optional& UserDefinedUnitType::
    StandardName () const
    {
      return this->StandardName_;
    }

    UserDefinedUnitType::StandardName_optional& UserDefinedUnitType::
    StandardName ()
    {
      return this->StandardName_;
    }

    void UserDefinedUnitType::
    StandardName (const StandardName_type& x)
    {
      this->StandardName_.set (x);
    }

    void UserDefinedUnitType::
    StandardName (const StandardName_optional& x)
    {
      this->StandardName_ = x;
    }

    void UserDefinedUnitType::
    StandardName (::std::unique_ptr< StandardName_type > x)
    {
      this->StandardName_.set (std::move (x));
    }


    // UserDefinedUnitValueType
    //

    const UserDefinedUnitValueType::unitName_type& UserDefinedUnitValueType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    UserDefinedUnitValueType::unitName_type& UserDefinedUnitValueType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void UserDefinedUnitValueType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void UserDefinedUnitValueType::
    unitName (::std::unique_ptr< unitName_type > x)
    {
      this->unitName_.set (std::move (x));
    }


    // MeasuredUserDefinedUnitValueType
    //

    const MeasuredUserDefinedUnitValueType::unitName_type& MeasuredUserDefinedUnitValueType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    MeasuredUserDefinedUnitValueType::unitName_type& MeasuredUserDefinedUnitValueType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void MeasuredUserDefinedUnitValueType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void MeasuredUserDefinedUnitValueType::
    unitName (::std::unique_ptr< unitName_type > x)
    {
      this->unitName_.set (std::move (x));
    }


    // UserDefinedUnitsType
    //

    const UserDefinedUnitsType::UserDefinedUnit_sequence& UserDefinedUnitsType::
    UserDefinedUnit () const
    {
      return this->UserDefinedUnit_;
    }

    UserDefinedUnitsType::UserDefinedUnit_sequence& UserDefinedUnitsType::
    UserDefinedUnit ()
    {
      return this->UserDefinedUnit_;
    }

    void UserDefinedUnitsType::
    UserDefinedUnit (const UserDefinedUnit_sequence& s)
    {
      this->UserDefinedUnit_ = s;
    }

    const UserDefinedUnitsType::n_type& UserDefinedUnitsType::
    n () const
    {
      return this->n_.get ();
    }

    UserDefinedUnitsType::n_type& UserDefinedUnitsType::
    n ()
    {
      return this->n_.get ();
    }

    void UserDefinedUnitsType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void UserDefinedUnitsType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // FileUnitsType
    //

    const FileUnitsType::PrimaryUnits_type& FileUnitsType::
    PrimaryUnits () const
    {
      return this->PrimaryUnits_.get ();
    }

    FileUnitsType::PrimaryUnits_type& FileUnitsType::
    PrimaryUnits ()
    {
      return this->PrimaryUnits_.get ();
    }

    void FileUnitsType::
    PrimaryUnits (const PrimaryUnits_type& x)
    {
      this->PrimaryUnits_.set (x);
    }

    void FileUnitsType::
    PrimaryUnits (::std::unique_ptr< PrimaryUnits_type > x)
    {
      this->PrimaryUnits_.set (std::move (x));
    }

    const FileUnitsType::OtherUnits_optional& FileUnitsType::
    OtherUnits () const
    {
      return this->OtherUnits_;
    }

    FileUnitsType::OtherUnits_optional& FileUnitsType::
    OtherUnits ()
    {
      return this->OtherUnits_;
    }

    void FileUnitsType::
    OtherUnits (const OtherUnits_type& x)
    {
      this->OtherUnits_.set (x);
    }

    void FileUnitsType::
    OtherUnits (const OtherUnits_optional& x)
    {
      this->OtherUnits_ = x;
    }

    void FileUnitsType::
    OtherUnits (::std::unique_ptr< OtherUnits_type > x)
    {
      this->OtherUnits_.set (std::move (x));
    }

    const FileUnitsType::UserDefinedUnits_optional& FileUnitsType::
    UserDefinedUnits () const
    {
      return this->UserDefinedUnits_;
    }

    FileUnitsType::UserDefinedUnits_optional& FileUnitsType::
    UserDefinedUnits ()
    {
      return this->UserDefinedUnits_;
    }

    void FileUnitsType::
    UserDefinedUnits (const UserDefinedUnits_type& x)
    {
      this->UserDefinedUnits_.set (x);
    }

    void FileUnitsType::
    UserDefinedUnits (const UserDefinedUnits_optional& x)
    {
      this->UserDefinedUnits_ = x;
    }

    void FileUnitsType::
    UserDefinedUnits (::std::unique_ptr< UserDefinedUnits_type > x)
    {
      this->UserDefinedUnits_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // PositiveDecimalType
    //

    PositiveDecimalType::
    PositiveDecimalType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > ()
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const PositiveDecimalType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const ::std::wstring& s,
                         const xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
    {
    }

    PositiveDecimalType* PositiveDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PositiveDecimalType (*this, f, c);
    }

    PositiveDecimalType::
    ~PositiveDecimalType ()
    {
    }

    // NonNegativeDecimalType
    //

    NonNegativeDecimalType::
    NonNegativeDecimalType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > ()
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const NonNegativeDecimalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
    {
    }

    NonNegativeDecimalType* NonNegativeDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NonNegativeDecimalType (*this, f, c);
    }

    NonNegativeDecimalType::
    ~NonNegativeDecimalType ()
    {
    }

    // UnitConversionType
    //

    UnitConversionType::
    UnitConversionType ()
    : ::xml_schema::type (),
      Factor_ (this),
      Offset_ (this)
    {
    }

    UnitConversionType::
    UnitConversionType (const Factor_type& Factor)
    : ::xml_schema::type (),
      Factor_ (Factor, this),
      Offset_ (this)
    {
    }

    UnitConversionType::
    UnitConversionType (const UnitConversionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Factor_ (x.Factor_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    UnitConversionType::
    UnitConversionType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Factor_ (this),
      Offset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UnitConversionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Factor
        //
        if (n.name () == L"Factor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Factor_type > r (
            Factor_traits::create (i, f, this));

          if (!Factor_.present ())
          {
            this->Factor_.set (::std::move (r));
            continue;
          }
        }

        // Offset
        //
        if (n.name () == L"Offset" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Offset_)
          {
            this->Offset_.set (Offset_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Factor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Factor",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    UnitConversionType* UnitConversionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitConversionType (*this, f, c);
    }

    UnitConversionType& UnitConversionType::
    operator= (const UnitConversionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Factor_ = x.Factor_;
        this->Offset_ = x.Offset_;
      }

      return *this;
    }

    UnitConversionType::
    ~UnitConversionType ()
    {
    }

    // SpecifiedDecimalType
    //

    SpecifiedDecimalType::
    SpecifiedDecimalType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (),
      decimalPlaces_ (this),
      significantFigures_ (this)
    {
    }

    SpecifiedDecimalType::
    SpecifiedDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      decimalPlaces_ (this),
      significantFigures_ (this)
    {
    }

    SpecifiedDecimalType::
    SpecifiedDecimalType (const SpecifiedDecimalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this)
    {
    }

    SpecifiedDecimalType::
    SpecifiedDecimalType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      decimalPlaces_ (this),
      significantFigures_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SpecifiedDecimalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }
      }
    }

    SpecifiedDecimalType* SpecifiedDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpecifiedDecimalType (*this, f, c);
    }

    SpecifiedDecimalType& SpecifiedDecimalType::
    operator= (const SpecifiedDecimalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
      }

      return *this;
    }

    SpecifiedDecimalType::
    ~SpecifiedDecimalType ()
    {
    }

    // MeasuredDecimalType
    //

    MeasuredDecimalType::
    MeasuredDecimalType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      combinedUncertainty_ (this),
      meanError_ (this)
    {
    }

    MeasuredDecimalType::
    MeasuredDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      combinedUncertainty_ (this),
      meanError_ (this)
    {
    }

    MeasuredDecimalType::
    MeasuredDecimalType (const MeasuredDecimalType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this)
    {
    }

    MeasuredDecimalType::
    MeasuredDecimalType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      combinedUncertainty_ (this),
      meanError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredDecimalType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredDecimalType* MeasuredDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredDecimalType (*this, f, c);
    }

    MeasuredDecimalType& MeasuredDecimalType::
    operator= (const MeasuredDecimalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->combinedUncertainty_ = x.combinedUncertainty_;
        this->meanError_ = x.meanError_;
      }

      return *this;
    }

    MeasuredDecimalType::
    ~MeasuredDecimalType ()
    {
    }

    // AngularUnitType
    //

    const AngularUnitType::SIUnitName_type AngularUnitType::SIUnitName_default_value_ (
      L"radian");

    AngularUnitType::
    AngularUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    AngularUnitType::
    AngularUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    AngularUnitType::
    AngularUnitType (const AngularUnitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    AngularUnitType::
    AngularUnitType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AngularUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AngularUnitType* AngularUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularUnitType (*this, f, c);
    }

    AngularUnitType& AngularUnitType::
    operator= (const AngularUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    AngularUnitType::
    ~AngularUnitType ()
    {
    }

    // AngularValueType
    //

    AngularValueType::
    AngularValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      angularUnit_ (this)
    {
    }

    AngularValueType::
    AngularValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      angularUnit_ (this)
    {
    }

    AngularValueType::
    AngularValueType (const AngularValueType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    AngularValueType::
    AngularValueType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AngularValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    AngularValueType* AngularValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularValueType (*this, f, c);
    }

    AngularValueType& AngularValueType::
    operator= (const AngularValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    AngularValueType::
    ~AngularValueType ()
    {
    }

    // MeasuredAngularValueType
    //

    MeasuredAngularValueType::
    MeasuredAngularValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      angularUnit_ (this)
    {
    }

    MeasuredAngularValueType::
    MeasuredAngularValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      angularUnit_ (this)
    {
    }

    MeasuredAngularValueType::
    MeasuredAngularValueType (const MeasuredAngularValueType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    MeasuredAngularValueType::
    MeasuredAngularValueType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredAngularValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"angularUnit" && n.namespace_ ().empty ())
        {
          this->angularUnit_.set (angularUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredAngularValueType* MeasuredAngularValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredAngularValueType (*this, f, c);
    }

    MeasuredAngularValueType& MeasuredAngularValueType::
    operator= (const MeasuredAngularValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->angularUnit_ = x.angularUnit_;
      }

      return *this;
    }

    MeasuredAngularValueType::
    ~MeasuredAngularValueType ()
    {
    }

    // AreaUnitType
    //

    const AreaUnitType::SIUnitName_type AreaUnitType::SIUnitName_default_value_ (
      L"square meter");

    AreaUnitType::
    AreaUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    AreaUnitType::
    AreaUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    AreaUnitType::
    AreaUnitType (const AreaUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    AreaUnitType::
    AreaUnitType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AreaUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    AreaUnitType* AreaUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AreaUnitType (*this, f, c);
    }

    AreaUnitType& AreaUnitType::
    operator= (const AreaUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    AreaUnitType::
    ~AreaUnitType ()
    {
    }

    // AreaValueType
    //

    AreaValueType::
    AreaValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      areaUnit_ (this)
    {
    }

    AreaValueType::
    AreaValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      areaUnit_ (this)
    {
    }

    AreaValueType::
    AreaValueType (const AreaValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    AreaValueType::
    AreaValueType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AreaValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"areaUnit" && n.namespace_ ().empty ())
        {
          this->areaUnit_.set (areaUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    AreaValueType* AreaValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AreaValueType (*this, f, c);
    }

    AreaValueType& AreaValueType::
    operator= (const AreaValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->areaUnit_ = x.areaUnit_;
      }

      return *this;
    }

    AreaValueType::
    ~AreaValueType ()
    {
    }

    // MeasuredAreaValueType
    //

    MeasuredAreaValueType::
    MeasuredAreaValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      areaUnit_ (this)
    {
    }

    MeasuredAreaValueType::
    MeasuredAreaValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      areaUnit_ (this)
    {
    }

    MeasuredAreaValueType::
    MeasuredAreaValueType (const MeasuredAreaValueType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    MeasuredAreaValueType::
    MeasuredAreaValueType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredAreaValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"areaUnit" && n.namespace_ ().empty ())
        {
          this->areaUnit_.set (areaUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredAreaValueType* MeasuredAreaValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredAreaValueType (*this, f, c);
    }

    MeasuredAreaValueType& MeasuredAreaValueType::
    operator= (const MeasuredAreaValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->areaUnit_ = x.areaUnit_;
      }

      return *this;
    }

    MeasuredAreaValueType::
    ~MeasuredAreaValueType ()
    {
    }

    // ForceUnitType
    //

    const ForceUnitType::SIUnitName_type ForceUnitType::SIUnitName_default_value_ (
      L"newton");

    ForceUnitType::
    ForceUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    ForceUnitType::
    ForceUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    ForceUnitType::
    ForceUnitType (const ForceUnitType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    ForceUnitType::
    ForceUnitType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ForceUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    ForceUnitType* ForceUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ForceUnitType (*this, f, c);
    }

    ForceUnitType& ForceUnitType::
    operator= (const ForceUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    ForceUnitType::
    ~ForceUnitType ()
    {
    }

    // ForceValueType
    //

    ForceValueType::
    ForceValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      forceUnit_ (this)
    {
    }

    ForceValueType::
    ForceValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      forceUnit_ (this)
    {
    }

    ForceValueType::
    ForceValueType (const ForceValueType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    ForceValueType::
    ForceValueType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ForceValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"forceUnit" && n.namespace_ ().empty ())
        {
          this->forceUnit_.set (forceUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    ForceValueType* ForceValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ForceValueType (*this, f, c);
    }

    ForceValueType& ForceValueType::
    operator= (const ForceValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->forceUnit_ = x.forceUnit_;
      }

      return *this;
    }

    ForceValueType::
    ~ForceValueType ()
    {
    }

    // MeasuredForceValueType
    //

    MeasuredForceValueType::
    MeasuredForceValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      forceUnit_ (this)
    {
    }

    MeasuredForceValueType::
    MeasuredForceValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      forceUnit_ (this)
    {
    }

    MeasuredForceValueType::
    MeasuredForceValueType (const MeasuredForceValueType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    MeasuredForceValueType::
    MeasuredForceValueType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredForceValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"forceUnit" && n.namespace_ ().empty ())
        {
          this->forceUnit_.set (forceUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredForceValueType* MeasuredForceValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredForceValueType (*this, f, c);
    }

    MeasuredForceValueType& MeasuredForceValueType::
    operator= (const MeasuredForceValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->forceUnit_ = x.forceUnit_;
      }

      return *this;
    }

    MeasuredForceValueType::
    ~MeasuredForceValueType ()
    {
    }

    // LinearUnitType
    //

    const LinearUnitType::SIUnitName_type LinearUnitType::SIUnitName_default_value_ (
      L"meter");

    LinearUnitType::
    LinearUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    LinearUnitType::
    LinearUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    LinearUnitType::
    LinearUnitType (const LinearUnitType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    LinearUnitType::
    LinearUnitType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LinearUnitType* LinearUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearUnitType (*this, f, c);
    }

    LinearUnitType& LinearUnitType::
    operator= (const LinearUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    LinearUnitType::
    ~LinearUnitType ()
    {
    }

    // LinearValueType
    //

    LinearValueType::
    LinearValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      linearUnit_ (this)
    {
    }

    LinearValueType::
    LinearValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      linearUnit_ (this)
    {
    }

    LinearValueType::
    LinearValueType (const LinearValueType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    LinearValueType::
    LinearValueType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LinearValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    LinearValueType* LinearValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearValueType (*this, f, c);
    }

    LinearValueType& LinearValueType::
    operator= (const LinearValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    LinearValueType::
    ~LinearValueType ()
    {
    }

    // LinearDualValueType
    //

    LinearDualValueType::
    LinearDualValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      linearUnit_ (this)
    {
    }

    LinearDualValueType::
    LinearDualValueType (const ::xml_schema::decimal& _xsd_decimal_base,
                         const linearUnit_type& linearUnit)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      linearUnit_ (linearUnit, this)
    {
    }

    LinearDualValueType::
    LinearDualValueType (const LinearDualValueType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    LinearDualValueType::
    LinearDualValueType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LinearDualValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }

      if (!linearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"linearUnit",
          L"");
      }
    }

    LinearDualValueType* LinearDualValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearDualValueType (*this, f, c);
    }

    LinearDualValueType& LinearDualValueType::
    operator= (const LinearDualValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    LinearDualValueType::
    ~LinearDualValueType ()
    {
    }

    // MeasuredLinearValueType
    //

    MeasuredLinearValueType::
    MeasuredLinearValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      linearUnit_ (this)
    {
    }

    MeasuredLinearValueType::
    MeasuredLinearValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      linearUnit_ (this)
    {
    }

    MeasuredLinearValueType::
    MeasuredLinearValueType (const MeasuredLinearValueType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    MeasuredLinearValueType::
    MeasuredLinearValueType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredLinearValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredLinearValueType* MeasuredLinearValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredLinearValueType (*this, f, c);
    }

    MeasuredLinearValueType& MeasuredLinearValueType::
    operator= (const MeasuredLinearValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->linearUnit_ = x.linearUnit_;
      }

      return *this;
    }

    MeasuredLinearValueType::
    ~MeasuredLinearValueType ()
    {
    }

    // MassUnitType
    //

    const MassUnitType::SIUnitName_type MassUnitType::SIUnitName_default_value_ (
      L"kilogram");

    MassUnitType::
    MassUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    MassUnitType::
    MassUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    MassUnitType::
    MassUnitType (const MassUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    MassUnitType::
    MassUnitType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MassUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    MassUnitType* MassUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MassUnitType (*this, f, c);
    }

    MassUnitType& MassUnitType::
    operator= (const MassUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    MassUnitType::
    ~MassUnitType ()
    {
    }

    // MassValueType
    //

    MassValueType::
    MassValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      massUnit_ (this)
    {
    }

    MassValueType::
    MassValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      massUnit_ (this)
    {
    }

    MassValueType::
    MassValueType (const MassValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    MassValueType::
    MassValueType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MassValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"massUnit" && n.namespace_ ().empty ())
        {
          this->massUnit_.set (massUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MassValueType* MassValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MassValueType (*this, f, c);
    }

    MassValueType& MassValueType::
    operator= (const MassValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->massUnit_ = x.massUnit_;
      }

      return *this;
    }

    MassValueType::
    ~MassValueType ()
    {
    }

    // MeasuredMassValueType
    //

    MeasuredMassValueType::
    MeasuredMassValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      massUnit_ (this)
    {
    }

    MeasuredMassValueType::
    MeasuredMassValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      massUnit_ (this)
    {
    }

    MeasuredMassValueType::
    MeasuredMassValueType (const MeasuredMassValueType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    MeasuredMassValueType::
    MeasuredMassValueType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredMassValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"massUnit" && n.namespace_ ().empty ())
        {
          this->massUnit_.set (massUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredMassValueType* MeasuredMassValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredMassValueType (*this, f, c);
    }

    MeasuredMassValueType& MeasuredMassValueType::
    operator= (const MeasuredMassValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->massUnit_ = x.massUnit_;
      }

      return *this;
    }

    MeasuredMassValueType::
    ~MeasuredMassValueType ()
    {
    }

    // PressureUnitType
    //

    const PressureUnitType::SIUnitName_type PressureUnitType::SIUnitName_default_value_ (
      L"pascal");

    PressureUnitType::
    PressureUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    PressureUnitType::
    PressureUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    PressureUnitType::
    PressureUnitType (const PressureUnitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    PressureUnitType::
    PressureUnitType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PressureUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    PressureUnitType* PressureUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PressureUnitType (*this, f, c);
    }

    PressureUnitType& PressureUnitType::
    operator= (const PressureUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    PressureUnitType::
    ~PressureUnitType ()
    {
    }

    // PressureValueType
    //

    PressureValueType::
    PressureValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      pressureUnit_ (this)
    {
    }

    PressureValueType::
    PressureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      pressureUnit_ (this)
    {
    }

    PressureValueType::
    PressureValueType (const PressureValueType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    PressureValueType::
    PressureValueType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void PressureValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"pressureUnit" && n.namespace_ ().empty ())
        {
          this->pressureUnit_.set (pressureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    PressureValueType* PressureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PressureValueType (*this, f, c);
    }

    PressureValueType& PressureValueType::
    operator= (const PressureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->pressureUnit_ = x.pressureUnit_;
      }

      return *this;
    }

    PressureValueType::
    ~PressureValueType ()
    {
    }

    // MeasuredPressureValueType
    //

    MeasuredPressureValueType::
    MeasuredPressureValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      pressureUnit_ (this)
    {
    }

    MeasuredPressureValueType::
    MeasuredPressureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      pressureUnit_ (this)
    {
    }

    MeasuredPressureValueType::
    MeasuredPressureValueType (const MeasuredPressureValueType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    MeasuredPressureValueType::
    MeasuredPressureValueType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredPressureValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"pressureUnit" && n.namespace_ ().empty ())
        {
          this->pressureUnit_.set (pressureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredPressureValueType* MeasuredPressureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredPressureValueType (*this, f, c);
    }

    MeasuredPressureValueType& MeasuredPressureValueType::
    operator= (const MeasuredPressureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->pressureUnit_ = x.pressureUnit_;
      }

      return *this;
    }

    MeasuredPressureValueType::
    ~MeasuredPressureValueType ()
    {
    }

    // SpeedUnitType
    //

    const SpeedUnitType::SIUnitName_type SpeedUnitType::SIUnitName_default_value_ (
      L"meter per second");

    SpeedUnitType::
    SpeedUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    SpeedUnitType::
    SpeedUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    SpeedUnitType::
    SpeedUnitType (const SpeedUnitType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    SpeedUnitType::
    SpeedUnitType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SpeedUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    SpeedUnitType* SpeedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpeedUnitType (*this, f, c);
    }

    SpeedUnitType& SpeedUnitType::
    operator= (const SpeedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    SpeedUnitType::
    ~SpeedUnitType ()
    {
    }

    // SpeedValueType
    //

    SpeedValueType::
    SpeedValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      speedUnit_ (this)
    {
    }

    SpeedValueType::
    SpeedValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      speedUnit_ (this)
    {
    }

    SpeedValueType::
    SpeedValueType (const SpeedValueType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    SpeedValueType::
    SpeedValueType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SpeedValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"speedUnit" && n.namespace_ ().empty ())
        {
          this->speedUnit_.set (speedUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    SpeedValueType* SpeedValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpeedValueType (*this, f, c);
    }

    SpeedValueType& SpeedValueType::
    operator= (const SpeedValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->speedUnit_ = x.speedUnit_;
      }

      return *this;
    }

    SpeedValueType::
    ~SpeedValueType ()
    {
    }

    // MeasuredSpeedValueType
    //

    MeasuredSpeedValueType::
    MeasuredSpeedValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      speedUnit_ (this)
    {
    }

    MeasuredSpeedValueType::
    MeasuredSpeedValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      speedUnit_ (this)
    {
    }

    MeasuredSpeedValueType::
    MeasuredSpeedValueType (const MeasuredSpeedValueType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    MeasuredSpeedValueType::
    MeasuredSpeedValueType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredSpeedValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"speedUnit" && n.namespace_ ().empty ())
        {
          this->speedUnit_.set (speedUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredSpeedValueType* MeasuredSpeedValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredSpeedValueType (*this, f, c);
    }

    MeasuredSpeedValueType& MeasuredSpeedValueType::
    operator= (const MeasuredSpeedValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->speedUnit_ = x.speedUnit_;
      }

      return *this;
    }

    MeasuredSpeedValueType::
    ~MeasuredSpeedValueType ()
    {
    }

    // TemperatureUnitType
    //

    const TemperatureUnitType::SIUnitName_type TemperatureUnitType::SIUnitName_default_value_ (
      L"kelvin");

    TemperatureUnitType::
    TemperatureUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    TemperatureUnitType::
    TemperatureUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    TemperatureUnitType::
    TemperatureUnitType (const TemperatureUnitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    TemperatureUnitType::
    TemperatureUnitType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TemperatureUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TemperatureUnitType* TemperatureUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureUnitType (*this, f, c);
    }

    TemperatureUnitType& TemperatureUnitType::
    operator= (const TemperatureUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    TemperatureUnitType::
    ~TemperatureUnitType ()
    {
    }

    // TemperatureValueType
    //

    TemperatureValueType::
    TemperatureValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      temperatureUnit_ (this)
    {
    }

    TemperatureValueType::
    TemperatureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      temperatureUnit_ (this)
    {
    }

    TemperatureValueType::
    TemperatureValueType (const TemperatureValueType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    TemperatureValueType::
    TemperatureValueType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TemperatureValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"temperatureUnit" && n.namespace_ ().empty ())
        {
          this->temperatureUnit_.set (temperatureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    TemperatureValueType* TemperatureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureValueType (*this, f, c);
    }

    TemperatureValueType& TemperatureValueType::
    operator= (const TemperatureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->temperatureUnit_ = x.temperatureUnit_;
      }

      return *this;
    }

    TemperatureValueType::
    ~TemperatureValueType ()
    {
    }

    // MeasuredTemperatureValueType
    //

    MeasuredTemperatureValueType::
    MeasuredTemperatureValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      temperatureUnit_ (this)
    {
    }

    MeasuredTemperatureValueType::
    MeasuredTemperatureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      temperatureUnit_ (this)
    {
    }

    MeasuredTemperatureValueType::
    MeasuredTemperatureValueType (const MeasuredTemperatureValueType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    MeasuredTemperatureValueType::
    MeasuredTemperatureValueType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredTemperatureValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"temperatureUnit" && n.namespace_ ().empty ())
        {
          this->temperatureUnit_.set (temperatureUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredTemperatureValueType* MeasuredTemperatureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredTemperatureValueType (*this, f, c);
    }

    MeasuredTemperatureValueType& MeasuredTemperatureValueType::
    operator= (const MeasuredTemperatureValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->temperatureUnit_ = x.temperatureUnit_;
      }

      return *this;
    }

    MeasuredTemperatureValueType::
    ~MeasuredTemperatureValueType ()
    {
    }

    // TimeUnitType
    //

    const TimeUnitType::SIUnitName_type TimeUnitType::SIUnitName_default_value_ (
      L"second");

    TimeUnitType::
    TimeUnitType ()
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
    }

    TimeUnitType::
    TimeUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (this),
      UnitName_ (UnitName, this),
      UnitConversion_ (this)
    {
    }

    TimeUnitType::
    TimeUnitType (const TimeUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    TimeUnitType::
    TimeUnitType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (this),
      UnitName_ (this),
      UnitConversion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TimeUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SIUnitName
        //
        if (n.name () == L"SIUnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == L"UnitConversion" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    TimeUnitType* TimeUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimeUnitType (*this, f, c);
    }

    TimeUnitType& TimeUnitType::
    operator= (const TimeUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SIUnitName_ = x.SIUnitName_;
        this->UnitName_ = x.UnitName_;
        this->UnitConversion_ = x.UnitConversion_;
      }

      return *this;
    }

    TimeUnitType::
    ~TimeUnitType ()
    {
    }

    // TimeValueType
    //

    TimeValueType::
    TimeValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      timeUnit_ (this)
    {
    }

    TimeValueType::
    TimeValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      timeUnit_ (this)
    {
    }

    TimeValueType::
    TimeValueType (const TimeValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    TimeValueType::
    TimeValueType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TimeValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"timeUnit" && n.namespace_ ().empty ())
        {
          this->timeUnit_.set (timeUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    TimeValueType* TimeValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimeValueType (*this, f, c);
    }

    TimeValueType& TimeValueType::
    operator= (const TimeValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->timeUnit_ = x.timeUnit_;
      }

      return *this;
    }

    TimeValueType::
    ~TimeValueType ()
    {
    }

    // MeasuredTimeValueType
    //

    MeasuredTimeValueType::
    MeasuredTimeValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      timeUnit_ (this)
    {
    }

    MeasuredTimeValueType::
    MeasuredTimeValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      timeUnit_ (this)
    {
    }

    MeasuredTimeValueType::
    MeasuredTimeValueType (const MeasuredTimeValueType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    MeasuredTimeValueType::
    MeasuredTimeValueType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredTimeValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"timeUnit" && n.namespace_ ().empty ())
        {
          this->timeUnit_.set (timeUnit_traits::create (i, f, this));
          continue;
        }
      }
    }

    MeasuredTimeValueType* MeasuredTimeValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredTimeValueType (*this, f, c);
    }

    MeasuredTimeValueType& MeasuredTimeValueType::
    operator= (const MeasuredTimeValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->timeUnit_ = x.timeUnit_;
      }

      return *this;
    }

    MeasuredTimeValueType::
    ~MeasuredTimeValueType ()
    {
    }

    // PrimaryUnitsType
    //

    PrimaryUnitsType::
    PrimaryUnitsType ()
    : ::xml_schema::type (),
      AreaUnit_ (this),
      PMIAreaUnit_ (this),
      AngularUnit_ (this),
      PMIAngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      PMILinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this)
    {
    }

    PrimaryUnitsType::
    PrimaryUnitsType (const PrimaryUnitsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AreaUnit_ (x.AreaUnit_, f, this),
      PMIAreaUnit_ (x.PMIAreaUnit_, f, this),
      AngularUnit_ (x.AngularUnit_, f, this),
      PMIAngularUnit_ (x.PMIAngularUnit_, f, this),
      ForceUnit_ (x.ForceUnit_, f, this),
      LinearUnit_ (x.LinearUnit_, f, this),
      PMILinearUnit_ (x.PMILinearUnit_, f, this),
      MassUnit_ (x.MassUnit_, f, this),
      PressureUnit_ (x.PressureUnit_, f, this),
      SpeedUnit_ (x.SpeedUnit_, f, this),
      TemperatureUnit_ (x.TemperatureUnit_, f, this),
      TimeUnit_ (x.TimeUnit_, f, this)
    {
    }

    PrimaryUnitsType::
    PrimaryUnitsType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AreaUnit_ (this),
      PMIAreaUnit_ (this),
      AngularUnit_ (this),
      PMIAngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      PMILinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PrimaryUnitsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AreaUnit
        //
        if (n.name () == L"AreaUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaUnit_type > r (
            AreaUnit_traits::create (i, f, this));

          if (!this->AreaUnit_)
          {
            this->AreaUnit_.set (::std::move (r));
            continue;
          }
        }

        // PMIAreaUnit
        //
        if (n.name () == L"PMIAreaUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PMIAreaUnit_type > r (
            PMIAreaUnit_traits::create (i, f, this));

          if (!this->PMIAreaUnit_)
          {
            this->PMIAreaUnit_.set (::std::move (r));
            continue;
          }
        }

        // AngularUnit
        //
        if (n.name () == L"AngularUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularUnit_type > r (
            AngularUnit_traits::create (i, f, this));

          if (!this->AngularUnit_)
          {
            this->AngularUnit_.set (::std::move (r));
            continue;
          }
        }

        // PMIAngularUnit
        //
        if (n.name () == L"PMIAngularUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PMIAngularUnit_type > r (
            PMIAngularUnit_traits::create (i, f, this));

          if (!this->PMIAngularUnit_)
          {
            this->PMIAngularUnit_.set (::std::move (r));
            continue;
          }
        }

        // ForceUnit
        //
        if (n.name () == L"ForceUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceUnit_type > r (
            ForceUnit_traits::create (i, f, this));

          if (!this->ForceUnit_)
          {
            this->ForceUnit_.set (::std::move (r));
            continue;
          }
        }

        // LinearUnit
        //
        if (n.name () == L"LinearUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearUnit_type > r (
            LinearUnit_traits::create (i, f, this));

          if (!this->LinearUnit_)
          {
            this->LinearUnit_.set (::std::move (r));
            continue;
          }
        }

        // PMILinearUnit
        //
        if (n.name () == L"PMILinearUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PMILinearUnit_type > r (
            PMILinearUnit_traits::create (i, f, this));

          if (!this->PMILinearUnit_)
          {
            this->PMILinearUnit_.set (::std::move (r));
            continue;
          }
        }

        // MassUnit
        //
        if (n.name () == L"MassUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassUnit_type > r (
            MassUnit_traits::create (i, f, this));

          if (!this->MassUnit_)
          {
            this->MassUnit_.set (::std::move (r));
            continue;
          }
        }

        // PressureUnit
        //
        if (n.name () == L"PressureUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureUnit_type > r (
            PressureUnit_traits::create (i, f, this));

          if (!this->PressureUnit_)
          {
            this->PressureUnit_.set (::std::move (r));
            continue;
          }
        }

        // SpeedUnit
        //
        if (n.name () == L"SpeedUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedUnit_type > r (
            SpeedUnit_traits::create (i, f, this));

          if (!this->SpeedUnit_)
          {
            this->SpeedUnit_.set (::std::move (r));
            continue;
          }
        }

        // TemperatureUnit
        //
        if (n.name () == L"TemperatureUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureUnit_type > r (
            TemperatureUnit_traits::create (i, f, this));

          if (!this->TemperatureUnit_)
          {
            this->TemperatureUnit_.set (::std::move (r));
            continue;
          }
        }

        // TimeUnit
        //
        if (n.name () == L"TimeUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeUnit_type > r (
            TimeUnit_traits::create (i, f, this));

          if (!this->TimeUnit_)
          {
            this->TimeUnit_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PrimaryUnitsType* PrimaryUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrimaryUnitsType (*this, f, c);
    }

    PrimaryUnitsType& PrimaryUnitsType::
    operator= (const PrimaryUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AreaUnit_ = x.AreaUnit_;
        this->PMIAreaUnit_ = x.PMIAreaUnit_;
        this->AngularUnit_ = x.AngularUnit_;
        this->PMIAngularUnit_ = x.PMIAngularUnit_;
        this->ForceUnit_ = x.ForceUnit_;
        this->LinearUnit_ = x.LinearUnit_;
        this->PMILinearUnit_ = x.PMILinearUnit_;
        this->MassUnit_ = x.MassUnit_;
        this->PressureUnit_ = x.PressureUnit_;
        this->SpeedUnit_ = x.SpeedUnit_;
        this->TemperatureUnit_ = x.TemperatureUnit_;
        this->TimeUnit_ = x.TimeUnit_;
      }

      return *this;
    }

    PrimaryUnitsType::
    ~PrimaryUnitsType ()
    {
    }

    // OtherUnitsType
    //

    OtherUnitsType::
    OtherUnitsType ()
    : ::xml_schema::type (),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this),
      n_ (this)
    {
    }

    OtherUnitsType::
    OtherUnitsType (const n_type& n)
    : ::xml_schema::type (),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this),
      n_ (n, this)
    {
    }

    OtherUnitsType::
    OtherUnitsType (const OtherUnitsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AreaUnit_ (x.AreaUnit_, f, this),
      AngularUnit_ (x.AngularUnit_, f, this),
      ForceUnit_ (x.ForceUnit_, f, this),
      LinearUnit_ (x.LinearUnit_, f, this),
      MassUnit_ (x.MassUnit_, f, this),
      PressureUnit_ (x.PressureUnit_, f, this),
      SpeedUnit_ (x.SpeedUnit_, f, this),
      TemperatureUnit_ (x.TemperatureUnit_, f, this),
      TimeUnit_ (x.TimeUnit_, f, this),
      n_ (x.n_, f, this)
    {
    }

    OtherUnitsType::
    OtherUnitsType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AreaUnit_ (this),
      AngularUnit_ (this),
      ForceUnit_ (this),
      LinearUnit_ (this),
      MassUnit_ (this),
      PressureUnit_ (this),
      SpeedUnit_ (this),
      TemperatureUnit_ (this),
      TimeUnit_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OtherUnitsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AreaUnit
        //
        if (n.name () == L"AreaUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AreaUnit_type > r (
            AreaUnit_traits::create (i, f, this));

          this->AreaUnit_.push_back (::std::move (r));
          continue;
        }

        // AngularUnit
        //
        if (n.name () == L"AngularUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< AngularUnit_type > r (
            AngularUnit_traits::create (i, f, this));

          this->AngularUnit_.push_back (::std::move (r));
          continue;
        }

        // ForceUnit
        //
        if (n.name () == L"ForceUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ForceUnit_type > r (
            ForceUnit_traits::create (i, f, this));

          this->ForceUnit_.push_back (::std::move (r));
          continue;
        }

        // LinearUnit
        //
        if (n.name () == L"LinearUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LinearUnit_type > r (
            LinearUnit_traits::create (i, f, this));

          this->LinearUnit_.push_back (::std::move (r));
          continue;
        }

        // MassUnit
        //
        if (n.name () == L"MassUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< MassUnit_type > r (
            MassUnit_traits::create (i, f, this));

          this->MassUnit_.push_back (::std::move (r));
          continue;
        }

        // PressureUnit
        //
        if (n.name () == L"PressureUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PressureUnit_type > r (
            PressureUnit_traits::create (i, f, this));

          this->PressureUnit_.push_back (::std::move (r));
          continue;
        }

        // SpeedUnit
        //
        if (n.name () == L"SpeedUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< SpeedUnit_type > r (
            SpeedUnit_traits::create (i, f, this));

          this->SpeedUnit_.push_back (::std::move (r));
          continue;
        }

        // TemperatureUnit
        //
        if (n.name () == L"TemperatureUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TemperatureUnit_type > r (
            TemperatureUnit_traits::create (i, f, this));

          this->TemperatureUnit_.push_back (::std::move (r));
          continue;
        }

        // TimeUnit
        //
        if (n.name () == L"TimeUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TimeUnit_type > r (
            TimeUnit_traits::create (i, f, this));

          this->TimeUnit_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    OtherUnitsType* OtherUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherUnitsType (*this, f, c);
    }

    OtherUnitsType& OtherUnitsType::
    operator= (const OtherUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AreaUnit_ = x.AreaUnit_;
        this->AngularUnit_ = x.AngularUnit_;
        this->ForceUnit_ = x.ForceUnit_;
        this->LinearUnit_ = x.LinearUnit_;
        this->MassUnit_ = x.MassUnit_;
        this->PressureUnit_ = x.PressureUnit_;
        this->SpeedUnit_ = x.SpeedUnit_;
        this->TemperatureUnit_ = x.TemperatureUnit_;
        this->TimeUnit_ = x.TimeUnit_;
        this->n_ = x.n_;
      }

      return *this;
    }

    OtherUnitsType::
    ~OtherUnitsType ()
    {
    }

    // UserDefinedUnitType
    //

    UserDefinedUnitType::
    UserDefinedUnitType ()
    : ::xml_schema::type (),
      WhatIsMeasured_ (this),
      UnitName_ (this),
      StandardName_ (this)
    {
    }

    UserDefinedUnitType::
    UserDefinedUnitType (const WhatIsMeasured_type& WhatIsMeasured,
                         const UnitName_type& UnitName)
    : ::xml_schema::type (),
      WhatIsMeasured_ (WhatIsMeasured, this),
      UnitName_ (UnitName, this),
      StandardName_ (this)
    {
    }

    UserDefinedUnitType::
    UserDefinedUnitType (const UserDefinedUnitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      WhatIsMeasured_ (x.WhatIsMeasured_, f, this),
      UnitName_ (x.UnitName_, f, this),
      StandardName_ (x.StandardName_, f, this)
    {
    }

    UserDefinedUnitType::
    UserDefinedUnitType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      WhatIsMeasured_ (this),
      UnitName_ (this),
      StandardName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // WhatIsMeasured
        //
        if (n.name () == L"WhatIsMeasured" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< WhatIsMeasured_type > r (
            WhatIsMeasured_traits::create (i, f, this));

          if (!WhatIsMeasured_.present ())
          {
            this->WhatIsMeasured_.set (::std::move (r));
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == L"UnitName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (::std::move (r));
            continue;
          }
        }

        // StandardName
        //
        if (n.name () == L"StandardName" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< StandardName_type > r (
            StandardName_traits::create (i, f, this));

          if (!this->StandardName_)
          {
            this->StandardName_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!WhatIsMeasured_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"WhatIsMeasured",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"UnitName",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    UserDefinedUnitType* UserDefinedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitType (*this, f, c);
    }

    UserDefinedUnitType& UserDefinedUnitType::
    operator= (const UserDefinedUnitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->WhatIsMeasured_ = x.WhatIsMeasured_;
        this->UnitName_ = x.UnitName_;
        this->StandardName_ = x.StandardName_;
      }

      return *this;
    }

    UserDefinedUnitType::
    ~UserDefinedUnitType ()
    {
    }

    // UserDefinedUnitValueType
    //

    UserDefinedUnitValueType::
    UserDefinedUnitValueType ()
    : ::xsd::qif30::SpecifiedDecimalType (),
      unitName_ (this)
    {
    }

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const ::xml_schema::decimal& _xsd_decimal_base,
                              const unitName_type& unitName)
    : ::xsd::qif30::SpecifiedDecimalType (_xsd_decimal_base),
      unitName_ (unitName, this)
    {
    }

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const UserDefinedUnitValueType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif30::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      unitName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"unitName",
          L"");
      }
    }

    UserDefinedUnitValueType* UserDefinedUnitValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitValueType (*this, f, c);
    }

    UserDefinedUnitValueType& UserDefinedUnitValueType::
    operator= (const UserDefinedUnitValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::SpecifiedDecimalType& > (*this) = x;
        this->unitName_ = x.unitName_;
      }

      return *this;
    }

    UserDefinedUnitValueType::
    ~UserDefinedUnitValueType ()
    {
    }

    // MeasuredUserDefinedUnitValueType
    //

    MeasuredUserDefinedUnitValueType::
    MeasuredUserDefinedUnitValueType ()
    : ::xsd::qif30::MeasuredDecimalType (),
      unitName_ (this)
    {
    }

    MeasuredUserDefinedUnitValueType::
    MeasuredUserDefinedUnitValueType (const ::xml_schema::decimal& _xsd_decimal_base,
                                      const unitName_type& unitName)
    : ::xsd::qif30::MeasuredDecimalType (_xsd_decimal_base),
      unitName_ (unitName, this)
    {
    }

    MeasuredUserDefinedUnitValueType::
    MeasuredUserDefinedUnitValueType (const MeasuredUserDefinedUnitValueType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    MeasuredUserDefinedUnitValueType::
    MeasuredUserDefinedUnitValueType (const xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif30::MeasuredDecimalType (e, f | ::xml_schema::flags::base, c),
      unitName_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasuredUserDefinedUnitValueType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::MeasuredDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"unitName" && n.namespace_ ().empty ())
        {
          this->unitName_.set (unitName_traits::create (i, f, this));
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"unitName",
          L"");
      }
    }

    MeasuredUserDefinedUnitValueType* MeasuredUserDefinedUnitValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredUserDefinedUnitValueType (*this, f, c);
    }

    MeasuredUserDefinedUnitValueType& MeasuredUserDefinedUnitValueType::
    operator= (const MeasuredUserDefinedUnitValueType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::MeasuredDecimalType& > (*this) = x;
        this->unitName_ = x.unitName_;
      }

      return *this;
    }

    MeasuredUserDefinedUnitValueType::
    ~MeasuredUserDefinedUnitValueType ()
    {
    }

    // UserDefinedUnitsType
    //

    UserDefinedUnitsType::
    UserDefinedUnitsType ()
    : ::xml_schema::type (),
      UserDefinedUnit_ (this),
      n_ (this)
    {
    }

    UserDefinedUnitsType::
    UserDefinedUnitsType (const n_type& n)
    : ::xml_schema::type (),
      UserDefinedUnit_ (this),
      n_ (n, this)
    {
    }

    UserDefinedUnitsType::
    UserDefinedUnitsType (const UserDefinedUnitsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      UserDefinedUnit_ (x.UserDefinedUnit_, f, this),
      n_ (x.n_, f, this)
    {
    }

    UserDefinedUnitsType::
    UserDefinedUnitsType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      UserDefinedUnit_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // UserDefinedUnit
        //
        if (n.name () == L"UserDefinedUnit" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedUnit_type > r (
            UserDefinedUnit_traits::create (i, f, this));

          this->UserDefinedUnit_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    UserDefinedUnitsType* UserDefinedUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitsType (*this, f, c);
    }

    UserDefinedUnitsType& UserDefinedUnitsType::
    operator= (const UserDefinedUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->UserDefinedUnit_ = x.UserDefinedUnit_;
        this->n_ = x.n_;
      }

      return *this;
    }

    UserDefinedUnitsType::
    ~UserDefinedUnitsType ()
    {
    }

    // FileUnitsType
    //

    FileUnitsType::
    FileUnitsType ()
    : ::xml_schema::type (),
      PrimaryUnits_ (this),
      OtherUnits_ (this),
      UserDefinedUnits_ (this)
    {
    }

    FileUnitsType::
    FileUnitsType (const PrimaryUnits_type& PrimaryUnits)
    : ::xml_schema::type (),
      PrimaryUnits_ (PrimaryUnits, this),
      OtherUnits_ (this),
      UserDefinedUnits_ (this)
    {
    }

    FileUnitsType::
    FileUnitsType (::std::unique_ptr< PrimaryUnits_type > PrimaryUnits)
    : ::xml_schema::type (),
      PrimaryUnits_ (std::move (PrimaryUnits), this),
      OtherUnits_ (this),
      UserDefinedUnits_ (this)
    {
    }

    FileUnitsType::
    FileUnitsType (const FileUnitsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrimaryUnits_ (x.PrimaryUnits_, f, this),
      OtherUnits_ (x.OtherUnits_, f, this),
      UserDefinedUnits_ (x.UserDefinedUnits_, f, this)
    {
    }

    FileUnitsType::
    FileUnitsType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrimaryUnits_ (this),
      OtherUnits_ (this),
      UserDefinedUnits_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FileUnitsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PrimaryUnits
        //
        if (n.name () == L"PrimaryUnits" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PrimaryUnits_type > r (
            PrimaryUnits_traits::create (i, f, this));

          if (!PrimaryUnits_.present ())
          {
            this->PrimaryUnits_.set (::std::move (r));
            continue;
          }
        }

        // OtherUnits
        //
        if (n.name () == L"OtherUnits" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< OtherUnits_type > r (
            OtherUnits_traits::create (i, f, this));

          if (!this->OtherUnits_)
          {
            this->OtherUnits_.set (::std::move (r));
            continue;
          }
        }

        // UserDefinedUnits
        //
        if (n.name () == L"UserDefinedUnits" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< UserDefinedUnits_type > r (
            UserDefinedUnits_traits::create (i, f, this));

          if (!this->UserDefinedUnits_)
          {
            this->UserDefinedUnits_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!PrimaryUnits_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"PrimaryUnits",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FileUnitsType* FileUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileUnitsType (*this, f, c);
    }

    FileUnitsType& FileUnitsType::
    operator= (const FileUnitsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PrimaryUnits_ = x.PrimaryUnits_;
        this->OtherUnits_ = x.OtherUnits_;
        this->UserDefinedUnits_ = x.UserDefinedUnits_;
      }

      return *this;
    }

    FileUnitsType::
    ~FileUnitsType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const PositiveDecimalType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const PositiveDecimalType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PositiveDecimalType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const NonNegativeDecimalType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const NonNegativeDecimalType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const NonNegativeDecimalType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const UnitConversionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Factor
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Factor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Factor ();
      }

      // Offset
      //
      if (i.Offset ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Offset",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_decimal(*i.Offset ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SpecifiedDecimalType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, wchar_t, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (i);

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"significantFigures",
            e));

        a << *i.significantFigures ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredDecimalType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // combinedUncertainty
      //
      if (i.combinedUncertainty ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"combinedUncertainty",
            e));

        a << *i.combinedUncertainty ();
      }

      // meanError
      //
      if (i.meanError ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"meanError",
            e));

        a << *i.meanError ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AngularUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AngularValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredAngularValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // angularUnit
      //
      if (i.angularUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"angularUnit",
            e));

        a << *i.angularUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AreaUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const AreaValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // areaUnit
      //
      if (i.areaUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"areaUnit",
            e));

        a << *i.areaUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredAreaValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // areaUnit
      //
      if (i.areaUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"areaUnit",
            e));

        a << *i.areaUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ForceUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ForceValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // forceUnit
      //
      if (i.forceUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"forceUnit",
            e));

        a << *i.forceUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredForceValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // forceUnit
      //
      if (i.forceUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"forceUnit",
            e));

        a << *i.forceUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LinearDualValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // linearUnit
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << i.linearUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredLinearValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // linearUnit
      //
      if (i.linearUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"linearUnit",
            e));

        a << *i.linearUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MassUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MassValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // massUnit
      //
      if (i.massUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"massUnit",
            e));

        a << *i.massUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredMassValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // massUnit
      //
      if (i.massUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"massUnit",
            e));

        a << *i.massUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PressureUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PressureValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // pressureUnit
      //
      if (i.pressureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"pressureUnit",
            e));

        a << *i.pressureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredPressureValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // pressureUnit
      //
      if (i.pressureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"pressureUnit",
            e));

        a << *i.pressureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SpeedUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const SpeedValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // speedUnit
      //
      if (i.speedUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"speedUnit",
            e));

        a << *i.speedUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredSpeedValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // speedUnit
      //
      if (i.speedUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"speedUnit",
            e));

        a << *i.speedUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TemperatureUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TemperatureValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // temperatureUnit
      //
      if (i.temperatureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"temperatureUnit",
            e));

        a << *i.temperatureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredTemperatureValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // temperatureUnit
      //
      if (i.temperatureUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"temperatureUnit",
            e));

        a << *i.temperatureUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TimeUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SIUnitName
      //
      if (i.SIUnitName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SIUnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SIUnitName ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // UnitConversion
      //
      if (i.UnitConversion ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitConversion",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UnitConversion ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TimeValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // timeUnit
      //
      if (i.timeUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"timeUnit",
            e));

        a << *i.timeUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredTimeValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // timeUnit
      //
      if (i.timeUnit ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"timeUnit",
            e));

        a << *i.timeUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PrimaryUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AreaUnit
      //
      if (i.AreaUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AreaUnit ();
      }

      // PMIAreaUnit
      //
      if (i.PMIAreaUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PMIAreaUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PMIAreaUnit ();
      }

      // AngularUnit
      //
      if (i.AngularUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.AngularUnit ();
      }

      // PMIAngularUnit
      //
      if (i.PMIAngularUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PMIAngularUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PMIAngularUnit ();
      }

      // ForceUnit
      //
      if (i.ForceUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ForceUnit ();
      }

      // LinearUnit
      //
      if (i.LinearUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LinearUnit ();
      }

      // PMILinearUnit
      //
      if (i.PMILinearUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PMILinearUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PMILinearUnit ();
      }

      // MassUnit
      //
      if (i.MassUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.MassUnit ();
      }

      // PressureUnit
      //
      if (i.PressureUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PressureUnit ();
      }

      // SpeedUnit
      //
      if (i.SpeedUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.SpeedUnit ();
      }

      // TemperatureUnit
      //
      if (i.TemperatureUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TemperatureUnit ();
      }

      // TimeUnit
      //
      if (i.TimeUnit ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TimeUnit ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const OtherUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AreaUnit
      //
      for (OtherUnitsType::AreaUnit_const_iterator
           b (i.AreaUnit ().begin ()), n (i.AreaUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::AreaUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AreaUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // AngularUnit
      //
      for (OtherUnitsType::AngularUnit_const_iterator
           b (i.AngularUnit ().begin ()), n (i.AngularUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::AngularUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"AngularUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // ForceUnit
      //
      for (OtherUnitsType::ForceUnit_const_iterator
           b (i.ForceUnit ().begin ()), n (i.ForceUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::ForceUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ForceUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // LinearUnit
      //
      for (OtherUnitsType::LinearUnit_const_iterator
           b (i.LinearUnit ().begin ()), n (i.LinearUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::LinearUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LinearUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // MassUnit
      //
      for (OtherUnitsType::MassUnit_const_iterator
           b (i.MassUnit ().begin ()), n (i.MassUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::MassUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"MassUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // PressureUnit
      //
      for (OtherUnitsType::PressureUnit_const_iterator
           b (i.PressureUnit ().begin ()), n (i.PressureUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::PressureUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PressureUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // SpeedUnit
      //
      for (OtherUnitsType::SpeedUnit_const_iterator
           b (i.SpeedUnit ().begin ()), n (i.SpeedUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::SpeedUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"SpeedUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // TemperatureUnit
      //
      for (OtherUnitsType::TemperatureUnit_const_iterator
           b (i.TemperatureUnit ().begin ()), n (i.TemperatureUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::TemperatureUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TemperatureUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // TimeUnit
      //
      for (OtherUnitsType::TimeUnit_const_iterator
           b (i.TimeUnit ().begin ()), n (i.TimeUnit ().end ());
           b != n; ++b)
      {
        const OtherUnitsType::TimeUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TimeUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UserDefinedUnitType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // WhatIsMeasured
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"WhatIsMeasured",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.WhatIsMeasured ();
      }

      // UnitName
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UnitName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.UnitName ();
      }

      // StandardName
      //
      if (i.StandardName ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"StandardName",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.StandardName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UserDefinedUnitValueType& i)
    {
      e << static_cast< const ::xsd::qif30::SpecifiedDecimalType& > (i);

      // unitName
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"unitName",
            e));

        a << i.unitName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const MeasuredUserDefinedUnitValueType& i)
    {
      e << static_cast< const ::xsd::qif30::MeasuredDecimalType& > (i);

      // unitName
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"unitName",
            e));

        a << i.unitName ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const UserDefinedUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // UserDefinedUnit
      //
      for (UserDefinedUnitsType::UserDefinedUnit_const_iterator
           b (i.UserDefinedUnit ().begin ()), n (i.UserDefinedUnit ().end ());
           b != n; ++b)
      {
        const UserDefinedUnitsType::UserDefinedUnit_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedUnit",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FileUnitsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PrimaryUnits
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PrimaryUnits",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.PrimaryUnits ();
      }

      // OtherUnits
      //
      if (i.OtherUnits ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"OtherUnits",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.OtherUnits ();
      }

      // UserDefinedUnits
      //
      if (i.UserDefinedUnits ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"UserDefinedUnits",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.UserDefinedUnits ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

