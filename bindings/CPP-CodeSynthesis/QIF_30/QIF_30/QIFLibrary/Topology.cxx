// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Topology.hxx"

namespace xsd
{
  namespace qif30
  {
    // TopologySetType
    //

    const TopologySetType::VertexSet_optional& TopologySetType::
    VertexSet () const
    {
      return this->VertexSet_;
    }

    TopologySetType::VertexSet_optional& TopologySetType::
    VertexSet ()
    {
      return this->VertexSet_;
    }

    void TopologySetType::
    VertexSet (const VertexSet_type& x)
    {
      this->VertexSet_.set (x);
    }

    void TopologySetType::
    VertexSet (const VertexSet_optional& x)
    {
      this->VertexSet_ = x;
    }

    void TopologySetType::
    VertexSet (::std::unique_ptr< VertexSet_type > x)
    {
      this->VertexSet_.set (std::move (x));
    }

    const TopologySetType::EdgeSet_optional& TopologySetType::
    EdgeSet () const
    {
      return this->EdgeSet_;
    }

    TopologySetType::EdgeSet_optional& TopologySetType::
    EdgeSet ()
    {
      return this->EdgeSet_;
    }

    void TopologySetType::
    EdgeSet (const EdgeSet_type& x)
    {
      this->EdgeSet_.set (x);
    }

    void TopologySetType::
    EdgeSet (const EdgeSet_optional& x)
    {
      this->EdgeSet_ = x;
    }

    void TopologySetType::
    EdgeSet (::std::unique_ptr< EdgeSet_type > x)
    {
      this->EdgeSet_.set (std::move (x));
    }

    const TopologySetType::LoopSet_optional& TopologySetType::
    LoopSet () const
    {
      return this->LoopSet_;
    }

    TopologySetType::LoopSet_optional& TopologySetType::
    LoopSet ()
    {
      return this->LoopSet_;
    }

    void TopologySetType::
    LoopSet (const LoopSet_type& x)
    {
      this->LoopSet_.set (x);
    }

    void TopologySetType::
    LoopSet (const LoopSet_optional& x)
    {
      this->LoopSet_ = x;
    }

    void TopologySetType::
    LoopSet (::std::unique_ptr< LoopSet_type > x)
    {
      this->LoopSet_.set (std::move (x));
    }

    const TopologySetType::FaceSet_optional& TopologySetType::
    FaceSet () const
    {
      return this->FaceSet_;
    }

    TopologySetType::FaceSet_optional& TopologySetType::
    FaceSet ()
    {
      return this->FaceSet_;
    }

    void TopologySetType::
    FaceSet (const FaceSet_type& x)
    {
      this->FaceSet_.set (x);
    }

    void TopologySetType::
    FaceSet (const FaceSet_optional& x)
    {
      this->FaceSet_ = x;
    }

    void TopologySetType::
    FaceSet (::std::unique_ptr< FaceSet_type > x)
    {
      this->FaceSet_.set (std::move (x));
    }

    const TopologySetType::ShellSet_optional& TopologySetType::
    ShellSet () const
    {
      return this->ShellSet_;
    }

    TopologySetType::ShellSet_optional& TopologySetType::
    ShellSet ()
    {
      return this->ShellSet_;
    }

    void TopologySetType::
    ShellSet (const ShellSet_type& x)
    {
      this->ShellSet_.set (x);
    }

    void TopologySetType::
    ShellSet (const ShellSet_optional& x)
    {
      this->ShellSet_ = x;
    }

    void TopologySetType::
    ShellSet (::std::unique_ptr< ShellSet_type > x)
    {
      this->ShellSet_.set (std::move (x));
    }

    const TopologySetType::BodySet_optional& TopologySetType::
    BodySet () const
    {
      return this->BodySet_;
    }

    TopologySetType::BodySet_optional& TopologySetType::
    BodySet ()
    {
      return this->BodySet_;
    }

    void TopologySetType::
    BodySet (const BodySet_type& x)
    {
      this->BodySet_.set (x);
    }

    void TopologySetType::
    BodySet (const BodySet_optional& x)
    {
      this->BodySet_ = x;
    }

    void TopologySetType::
    BodySet (::std::unique_ptr< BodySet_type > x)
    {
      this->BodySet_.set (std::move (x));
    }

    const TopologySetType::PointCloudSet_optional& TopologySetType::
    PointCloudSet () const
    {
      return this->PointCloudSet_;
    }

    TopologySetType::PointCloudSet_optional& TopologySetType::
    PointCloudSet ()
    {
      return this->PointCloudSet_;
    }

    void TopologySetType::
    PointCloudSet (const PointCloudSet_type& x)
    {
      this->PointCloudSet_.set (x);
    }

    void TopologySetType::
    PointCloudSet (const PointCloudSet_optional& x)
    {
      this->PointCloudSet_ = x;
    }

    void TopologySetType::
    PointCloudSet (::std::unique_ptr< PointCloudSet_type > x)
    {
      this->PointCloudSet_.set (std::move (x));
    }


    // TopologyBaseType
    //


    // VertexSetType
    //

    const VertexSetType::Vertex_sequence& VertexSetType::
    Vertex () const
    {
      return this->Vertex_;
    }

    VertexSetType::Vertex_sequence& VertexSetType::
    Vertex ()
    {
      return this->Vertex_;
    }

    void VertexSetType::
    Vertex (const Vertex_sequence& s)
    {
      this->Vertex_ = s;
    }

    const VertexSetType::n_type& VertexSetType::
    n () const
    {
      return this->n_.get ();
    }

    VertexSetType::n_type& VertexSetType::
    n ()
    {
      return this->n_.get ();
    }

    void VertexSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void VertexSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // VertexType
    //

    const VertexType::Point_type& VertexType::
    Point () const
    {
      return this->Point_.get ();
    }

    VertexType::Point_type& VertexType::
    Point ()
    {
      return this->Point_.get ();
    }

    void VertexType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void VertexType::
    Point (::std::unique_ptr< Point_type > x)
    {
      this->Point_.set (std::move (x));
    }

    const VertexType::tolerance_optional& VertexType::
    tolerance () const
    {
      return this->tolerance_;
    }

    VertexType::tolerance_optional& VertexType::
    tolerance ()
    {
      return this->tolerance_;
    }

    void VertexType::
    tolerance (const tolerance_type& x)
    {
      this->tolerance_.set (x);
    }

    void VertexType::
    tolerance (const tolerance_optional& x)
    {
      this->tolerance_ = x;
    }


    // EdgeSetType
    //

    const EdgeSetType::Edge_sequence& EdgeSetType::
    Edge () const
    {
      return this->Edge_;
    }

    EdgeSetType::Edge_sequence& EdgeSetType::
    Edge ()
    {
      return this->Edge_;
    }

    void EdgeSetType::
    Edge (const Edge_sequence& s)
    {
      this->Edge_ = s;
    }

    const EdgeSetType::n_type& EdgeSetType::
    n () const
    {
      return this->n_.get ();
    }

    EdgeSetType::n_type& EdgeSetType::
    n ()
    {
      return this->n_.get ();
    }

    void EdgeSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void EdgeSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ValidationEdgeType
    //

    const ValidationEdgeType::Length_optional& ValidationEdgeType::
    Length () const
    {
      return this->Length_;
    }

    ValidationEdgeType::Length_optional& ValidationEdgeType::
    Length ()
    {
      return this->Length_;
    }

    void ValidationEdgeType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ValidationEdgeType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    const ValidationEdgeType::Centroid_optional& ValidationEdgeType::
    Centroid () const
    {
      return this->Centroid_;
    }

    ValidationEdgeType::Centroid_optional& ValidationEdgeType::
    Centroid ()
    {
      return this->Centroid_;
    }

    void ValidationEdgeType::
    Centroid (const Centroid_type& x)
    {
      this->Centroid_.set (x);
    }

    void ValidationEdgeType::
    Centroid (const Centroid_optional& x)
    {
      this->Centroid_ = x;
    }

    void ValidationEdgeType::
    Centroid (::std::unique_ptr< Centroid_type > x)
    {
      this->Centroid_.set (std::move (x));
    }

    const ValidationEdgeType::Box_optional& ValidationEdgeType::
    Box () const
    {
      return this->Box_;
    }

    ValidationEdgeType::Box_optional& ValidationEdgeType::
    Box ()
    {
      return this->Box_;
    }

    void ValidationEdgeType::
    Box (const Box_type& x)
    {
      this->Box_.set (x);
    }

    void ValidationEdgeType::
    Box (const Box_optional& x)
    {
      this->Box_ = x;
    }

    void ValidationEdgeType::
    Box (::std::unique_ptr< Box_type > x)
    {
      this->Box_.set (std::move (x));
    }

    const ValidationEdgeType::Points_optional& ValidationEdgeType::
    Points () const
    {
      return this->Points_;
    }

    ValidationEdgeType::Points_optional& ValidationEdgeType::
    Points ()
    {
      return this->Points_;
    }

    void ValidationEdgeType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void ValidationEdgeType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void ValidationEdgeType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }


    // EdgeType
    //

    const EdgeType::Validation_optional& EdgeType::
    Validation () const
    {
      return this->Validation_;
    }

    EdgeType::Validation_optional& EdgeType::
    Validation ()
    {
      return this->Validation_;
    }

    void EdgeType::
    Validation (const Validation_type& x)
    {
      this->Validation_.set (x);
    }

    void EdgeType::
    Validation (const Validation_optional& x)
    {
      this->Validation_ = x;
    }

    void EdgeType::
    Validation (::std::unique_ptr< Validation_type > x)
    {
      this->Validation_.set (std::move (x));
    }

    const EdgeType::Curve_type& EdgeType::
    Curve () const
    {
      return this->Curve_.get ();
    }

    EdgeType::Curve_type& EdgeType::
    Curve ()
    {
      return this->Curve_.get ();
    }

    void EdgeType::
    Curve (const Curve_type& x)
    {
      this->Curve_.set (x);
    }

    void EdgeType::
    Curve (::std::unique_ptr< Curve_type > x)
    {
      this->Curve_.set (std::move (x));
    }

    const EdgeType::VertexBeg_type& EdgeType::
    VertexBeg () const
    {
      return this->VertexBeg_.get ();
    }

    EdgeType::VertexBeg_type& EdgeType::
    VertexBeg ()
    {
      return this->VertexBeg_.get ();
    }

    void EdgeType::
    VertexBeg (const VertexBeg_type& x)
    {
      this->VertexBeg_.set (x);
    }

    void EdgeType::
    VertexBeg (::std::unique_ptr< VertexBeg_type > x)
    {
      this->VertexBeg_.set (std::move (x));
    }

    const EdgeType::VertexEnd_type& EdgeType::
    VertexEnd () const
    {
      return this->VertexEnd_.get ();
    }

    EdgeType::VertexEnd_type& EdgeType::
    VertexEnd ()
    {
      return this->VertexEnd_.get ();
    }

    void EdgeType::
    VertexEnd (const VertexEnd_type& x)
    {
      this->VertexEnd_.set (x);
    }

    void EdgeType::
    VertexEnd (::std::unique_ptr< VertexEnd_type > x)
    {
      this->VertexEnd_.set (std::move (x));
    }

    const EdgeType::tolerance_optional& EdgeType::
    tolerance () const
    {
      return this->tolerance_;
    }

    EdgeType::tolerance_optional& EdgeType::
    tolerance ()
    {
      return this->tolerance_;
    }

    void EdgeType::
    tolerance (const tolerance_type& x)
    {
      this->tolerance_.set (x);
    }

    void EdgeType::
    tolerance (const tolerance_optional& x)
    {
      this->tolerance_ = x;
    }


    // LoopSetType
    //

    const LoopSetType::LoopBase_sequence& LoopSetType::
    LoopBase () const
    {
      return this->LoopBase_;
    }

    LoopSetType::LoopBase_sequence& LoopSetType::
    LoopBase ()
    {
      return this->LoopBase_;
    }

    void LoopSetType::
    LoopBase (const LoopBase_sequence& s)
    {
      this->LoopBase_ = s;
    }

    const LoopSetType::n_type& LoopSetType::
    n () const
    {
      return this->n_.get ();
    }

    LoopSetType::n_type& LoopSetType::
    n ()
    {
      return this->n_.get ();
    }

    void LoopSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void LoopSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // LoopBaseType
    //


    // LoopFormEnumType
    //

    LoopFormEnumType::
    LoopFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (value v)
    : ::xml_schema::string (_xsd_LoopFormEnumType_literals_[v])
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const LoopFormEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    LoopFormEnumType& LoopFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_LoopFormEnumType_literals_[v]);

      return *this;
    }


    // CoEdgeType
    //

    const CoEdgeType::EdgeOriented_type& CoEdgeType::
    EdgeOriented () const
    {
      return this->EdgeOriented_.get ();
    }

    CoEdgeType::EdgeOriented_type& CoEdgeType::
    EdgeOriented ()
    {
      return this->EdgeOriented_.get ();
    }

    void CoEdgeType::
    EdgeOriented (const EdgeOriented_type& x)
    {
      this->EdgeOriented_.set (x);
    }

    void CoEdgeType::
    EdgeOriented (::std::unique_ptr< EdgeOriented_type > x)
    {
      this->EdgeOriented_.set (std::move (x));
    }

    const CoEdgeType::Curve12_optional& CoEdgeType::
    Curve12 () const
    {
      return this->Curve12_;
    }

    CoEdgeType::Curve12_optional& CoEdgeType::
    Curve12 ()
    {
      return this->Curve12_;
    }

    void CoEdgeType::
    Curve12 (const Curve12_type& x)
    {
      this->Curve12_.set (x);
    }

    void CoEdgeType::
    Curve12 (const Curve12_optional& x)
    {
      this->Curve12_ = x;
    }

    void CoEdgeType::
    Curve12 (::std::unique_ptr< Curve12_type > x)
    {
      this->Curve12_.set (std::move (x));
    }


    // CoEdgesType
    //

    const CoEdgesType::CoEdge_sequence& CoEdgesType::
    CoEdge () const
    {
      return this->CoEdge_;
    }

    CoEdgesType::CoEdge_sequence& CoEdgesType::
    CoEdge ()
    {
      return this->CoEdge_;
    }

    void CoEdgesType::
    CoEdge (const CoEdge_sequence& s)
    {
      this->CoEdge_ = s;
    }

    const CoEdgesType::n_type& CoEdgesType::
    n () const
    {
      return this->n_.get ();
    }

    CoEdgesType::n_type& CoEdgesType::
    n ()
    {
      return this->n_.get ();
    }

    void CoEdgesType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CoEdgesType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // CoEdgeMeshType
    //

    const CoEdgeMeshType::EdgeOriented_type& CoEdgeMeshType::
    EdgeOriented () const
    {
      return this->EdgeOriented_.get ();
    }

    CoEdgeMeshType::EdgeOriented_type& CoEdgeMeshType::
    EdgeOriented ()
    {
      return this->EdgeOriented_.get ();
    }

    void CoEdgeMeshType::
    EdgeOriented (const EdgeOriented_type& x)
    {
      this->EdgeOriented_.set (x);
    }

    void CoEdgeMeshType::
    EdgeOriented (::std::unique_ptr< EdgeOriented_type > x)
    {
      this->EdgeOriented_.set (std::move (x));
    }

    const CoEdgeMeshType::CurveMesh_optional& CoEdgeMeshType::
    CurveMesh () const
    {
      return this->CurveMesh_;
    }

    CoEdgeMeshType::CurveMesh_optional& CoEdgeMeshType::
    CurveMesh ()
    {
      return this->CurveMesh_;
    }

    void CoEdgeMeshType::
    CurveMesh (const CurveMesh_type& x)
    {
      this->CurveMesh_.set (x);
    }

    void CoEdgeMeshType::
    CurveMesh (const CurveMesh_optional& x)
    {
      this->CurveMesh_ = x;
    }

    void CoEdgeMeshType::
    CurveMesh (::std::unique_ptr< CurveMesh_type > x)
    {
      this->CurveMesh_.set (std::move (x));
    }


    // CoEdgesMeshType
    //

    const CoEdgesMeshType::CoEdgeMesh_sequence& CoEdgesMeshType::
    CoEdgeMesh () const
    {
      return this->CoEdgeMesh_;
    }

    CoEdgesMeshType::CoEdgeMesh_sequence& CoEdgesMeshType::
    CoEdgeMesh ()
    {
      return this->CoEdgeMesh_;
    }

    void CoEdgesMeshType::
    CoEdgeMesh (const CoEdgeMesh_sequence& s)
    {
      this->CoEdgeMesh_ = s;
    }

    const CoEdgesMeshType::n_type& CoEdgesMeshType::
    n () const
    {
      return this->n_.get ();
    }

    CoEdgesMeshType::n_type& CoEdgesMeshType::
    n ()
    {
      return this->n_.get ();
    }

    void CoEdgesMeshType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void CoEdgesMeshType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // LoopType
    //

    const LoopType::CoEdges_type& LoopType::
    CoEdges () const
    {
      return this->CoEdges_.get ();
    }

    LoopType::CoEdges_type& LoopType::
    CoEdges ()
    {
      return this->CoEdges_.get ();
    }

    void LoopType::
    CoEdges (const CoEdges_type& x)
    {
      this->CoEdges_.set (x);
    }

    void LoopType::
    CoEdges (::std::unique_ptr< CoEdges_type > x)
    {
      this->CoEdges_.set (std::move (x));
    }

    const LoopType::form_type& LoopType::
    form () const
    {
      return this->form_.get ();
    }

    LoopType::form_type& LoopType::
    form ()
    {
      return this->form_.get ();
    }

    void LoopType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void LoopType::
    form (::std::unique_ptr< form_type > x)
    {
      this->form_.set (std::move (x));
    }

    const LoopType::form_type& LoopType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // LoopMeshType
    //

    const LoopMeshType::CoEdgesMesh_type& LoopMeshType::
    CoEdgesMesh () const
    {
      return this->CoEdgesMesh_.get ();
    }

    LoopMeshType::CoEdgesMesh_type& LoopMeshType::
    CoEdgesMesh ()
    {
      return this->CoEdgesMesh_.get ();
    }

    void LoopMeshType::
    CoEdgesMesh (const CoEdgesMesh_type& x)
    {
      this->CoEdgesMesh_.set (x);
    }

    void LoopMeshType::
    CoEdgesMesh (::std::unique_ptr< CoEdgesMesh_type > x)
    {
      this->CoEdgesMesh_.set (std::move (x));
    }


    // FaceSetType
    //

    const FaceSetType::FaceBase_sequence& FaceSetType::
    FaceBase () const
    {
      return this->FaceBase_;
    }

    FaceSetType::FaceBase_sequence& FaceSetType::
    FaceBase ()
    {
      return this->FaceBase_;
    }

    void FaceSetType::
    FaceBase (const FaceBase_sequence& s)
    {
      this->FaceBase_ = s;
    }

    const FaceSetType::n_type& FaceSetType::
    n () const
    {
      return this->n_.get ();
    }

    FaceSetType::n_type& FaceSetType::
    n ()
    {
      return this->n_.get ();
    }

    void FaceSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void FaceSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ValidationFaceType
    //

    const ValidationFaceType::Area_optional& ValidationFaceType::
    Area () const
    {
      return this->Area_;
    }

    ValidationFaceType::Area_optional& ValidationFaceType::
    Area ()
    {
      return this->Area_;
    }

    void ValidationFaceType::
    Area (const Area_type& x)
    {
      this->Area_.set (x);
    }

    void ValidationFaceType::
    Area (const Area_optional& x)
    {
      this->Area_ = x;
    }

    const ValidationFaceType::Centroid_optional& ValidationFaceType::
    Centroid () const
    {
      return this->Centroid_;
    }

    ValidationFaceType::Centroid_optional& ValidationFaceType::
    Centroid ()
    {
      return this->Centroid_;
    }

    void ValidationFaceType::
    Centroid (const Centroid_type& x)
    {
      this->Centroid_.set (x);
    }

    void ValidationFaceType::
    Centroid (const Centroid_optional& x)
    {
      this->Centroid_ = x;
    }

    void ValidationFaceType::
    Centroid (::std::unique_ptr< Centroid_type > x)
    {
      this->Centroid_.set (std::move (x));
    }

    const ValidationFaceType::Box_optional& ValidationFaceType::
    Box () const
    {
      return this->Box_;
    }

    ValidationFaceType::Box_optional& ValidationFaceType::
    Box ()
    {
      return this->Box_;
    }

    void ValidationFaceType::
    Box (const Box_type& x)
    {
      this->Box_.set (x);
    }

    void ValidationFaceType::
    Box (const Box_optional& x)
    {
      this->Box_ = x;
    }

    void ValidationFaceType::
    Box (::std::unique_ptr< Box_type > x)
    {
      this->Box_.set (std::move (x));
    }

    const ValidationFaceType::Points_optional& ValidationFaceType::
    Points () const
    {
      return this->Points_;
    }

    ValidationFaceType::Points_optional& ValidationFaceType::
    Points ()
    {
      return this->Points_;
    }

    void ValidationFaceType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void ValidationFaceType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void ValidationFaceType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }


    // FaceBaseType
    //

    const FaceBaseType::Validation_optional& FaceBaseType::
    Validation () const
    {
      return this->Validation_;
    }

    FaceBaseType::Validation_optional& FaceBaseType::
    Validation ()
    {
      return this->Validation_;
    }

    void FaceBaseType::
    Validation (const Validation_type& x)
    {
      this->Validation_.set (x);
    }

    void FaceBaseType::
    Validation (const Validation_optional& x)
    {
      this->Validation_ = x;
    }

    void FaceBaseType::
    Validation (::std::unique_ptr< Validation_type > x)
    {
      this->Validation_.set (std::move (x));
    }

    const FaceBaseType::turned_type& FaceBaseType::
    turned () const
    {
      return this->turned_.get ();
    }

    FaceBaseType::turned_type& FaceBaseType::
    turned ()
    {
      return this->turned_.get ();
    }

    void FaceBaseType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    FaceBaseType::turned_type FaceBaseType::
    turned_default_value ()
    {
      return turned_type (false);
    }


    // FaceType
    //

    const FaceType::Surface_type& FaceType::
    Surface () const
    {
      return this->Surface_.get ();
    }

    FaceType::Surface_type& FaceType::
    Surface ()
    {
      return this->Surface_.get ();
    }

    void FaceType::
    Surface (const Surface_type& x)
    {
      this->Surface_.set (x);
    }

    void FaceType::
    Surface (::std::unique_ptr< Surface_type > x)
    {
      this->Surface_.set (std::move (x));
    }

    const FaceType::LoopIds_optional& FaceType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    FaceType::LoopIds_optional& FaceType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void FaceType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void FaceType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void FaceType::
    LoopIds (::std::unique_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (std::move (x));
    }

    const FaceType::hasOuter_type& FaceType::
    hasOuter () const
    {
      return this->hasOuter_.get ();
    }

    FaceType::hasOuter_type& FaceType::
    hasOuter ()
    {
      return this->hasOuter_.get ();
    }

    void FaceType::
    hasOuter (const hasOuter_type& x)
    {
      this->hasOuter_.set (x);
    }

    FaceType::hasOuter_type FaceType::
    hasOuter_default_value ()
    {
      return hasOuter_type (true);
    }


    // FaceMeshType
    //

    const FaceMeshType::Mesh_type& FaceMeshType::
    Mesh () const
    {
      return this->Mesh_.get ();
    }

    FaceMeshType::Mesh_type& FaceMeshType::
    Mesh ()
    {
      return this->Mesh_.get ();
    }

    void FaceMeshType::
    Mesh (const Mesh_type& x)
    {
      this->Mesh_.set (x);
    }

    void FaceMeshType::
    Mesh (::std::unique_ptr< Mesh_type > x)
    {
      this->Mesh_.set (std::move (x));
    }

    const FaceMeshType::LoopIds_optional& FaceMeshType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    FaceMeshType::LoopIds_optional& FaceMeshType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void FaceMeshType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void FaceMeshType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void FaceMeshType::
    LoopIds (::std::unique_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (std::move (x));
    }

    const FaceMeshType::Triangles_optional& FaceMeshType::
    Triangles () const
    {
      return this->Triangles_;
    }

    FaceMeshType::Triangles_optional& FaceMeshType::
    Triangles ()
    {
      return this->Triangles_;
    }

    void FaceMeshType::
    Triangles (const Triangles_type& x)
    {
      this->Triangles_.set (x);
    }

    void FaceMeshType::
    Triangles (const Triangles_optional& x)
    {
      this->Triangles_ = x;
    }

    void FaceMeshType::
    Triangles (::std::unique_ptr< Triangles_type > x)
    {
      this->Triangles_.set (std::move (x));
    }

    const FaceMeshType::TrianglesBinary_optional& FaceMeshType::
    TrianglesBinary () const
    {
      return this->TrianglesBinary_;
    }

    FaceMeshType::TrianglesBinary_optional& FaceMeshType::
    TrianglesBinary ()
    {
      return this->TrianglesBinary_;
    }

    void FaceMeshType::
    TrianglesBinary (const TrianglesBinary_type& x)
    {
      this->TrianglesBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesBinary (const TrianglesBinary_optional& x)
    {
      this->TrianglesBinary_ = x;
    }

    void FaceMeshType::
    TrianglesBinary (::std::unique_ptr< TrianglesBinary_type > x)
    {
      this->TrianglesBinary_.set (std::move (x));
    }

    const FaceMeshType::TrianglesVisible_optional& FaceMeshType::
    TrianglesVisible () const
    {
      return this->TrianglesVisible_;
    }

    FaceMeshType::TrianglesVisible_optional& FaceMeshType::
    TrianglesVisible ()
    {
      return this->TrianglesVisible_;
    }

    void FaceMeshType::
    TrianglesVisible (const TrianglesVisible_type& x)
    {
      this->TrianglesVisible_.set (x);
    }

    void FaceMeshType::
    TrianglesVisible (const TrianglesVisible_optional& x)
    {
      this->TrianglesVisible_ = x;
    }

    void FaceMeshType::
    TrianglesVisible (::std::unique_ptr< TrianglesVisible_type > x)
    {
      this->TrianglesVisible_.set (std::move (x));
    }

    const FaceMeshType::TrianglesVisibleBinary_optional& FaceMeshType::
    TrianglesVisibleBinary () const
    {
      return this->TrianglesVisibleBinary_;
    }

    FaceMeshType::TrianglesVisibleBinary_optional& FaceMeshType::
    TrianglesVisibleBinary ()
    {
      return this->TrianglesVisibleBinary_;
    }

    void FaceMeshType::
    TrianglesVisibleBinary (const TrianglesVisibleBinary_type& x)
    {
      this->TrianglesVisibleBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesVisibleBinary (const TrianglesVisibleBinary_optional& x)
    {
      this->TrianglesVisibleBinary_ = x;
    }

    void FaceMeshType::
    TrianglesVisibleBinary (::std::unique_ptr< TrianglesVisibleBinary_type > x)
    {
      this->TrianglesVisibleBinary_.set (std::move (x));
    }

    const FaceMeshType::TrianglesHidden_optional& FaceMeshType::
    TrianglesHidden () const
    {
      return this->TrianglesHidden_;
    }

    FaceMeshType::TrianglesHidden_optional& FaceMeshType::
    TrianglesHidden ()
    {
      return this->TrianglesHidden_;
    }

    void FaceMeshType::
    TrianglesHidden (const TrianglesHidden_type& x)
    {
      this->TrianglesHidden_.set (x);
    }

    void FaceMeshType::
    TrianglesHidden (const TrianglesHidden_optional& x)
    {
      this->TrianglesHidden_ = x;
    }

    void FaceMeshType::
    TrianglesHidden (::std::unique_ptr< TrianglesHidden_type > x)
    {
      this->TrianglesHidden_.set (std::move (x));
    }

    const FaceMeshType::TrianglesHiddenBinary_optional& FaceMeshType::
    TrianglesHiddenBinary () const
    {
      return this->TrianglesHiddenBinary_;
    }

    FaceMeshType::TrianglesHiddenBinary_optional& FaceMeshType::
    TrianglesHiddenBinary ()
    {
      return this->TrianglesHiddenBinary_;
    }

    void FaceMeshType::
    TrianglesHiddenBinary (const TrianglesHiddenBinary_type& x)
    {
      this->TrianglesHiddenBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesHiddenBinary (const TrianglesHiddenBinary_optional& x)
    {
      this->TrianglesHiddenBinary_ = x;
    }

    void FaceMeshType::
    TrianglesHiddenBinary (::std::unique_ptr< TrianglesHiddenBinary_type > x)
    {
      this->TrianglesHiddenBinary_.set (std::move (x));
    }

    const FaceMeshType::TrianglesColor_optional& FaceMeshType::
    TrianglesColor () const
    {
      return this->TrianglesColor_;
    }

    FaceMeshType::TrianglesColor_optional& FaceMeshType::
    TrianglesColor ()
    {
      return this->TrianglesColor_;
    }

    void FaceMeshType::
    TrianglesColor (const TrianglesColor_type& x)
    {
      this->TrianglesColor_.set (x);
    }

    void FaceMeshType::
    TrianglesColor (const TrianglesColor_optional& x)
    {
      this->TrianglesColor_ = x;
    }

    void FaceMeshType::
    TrianglesColor (::std::unique_ptr< TrianglesColor_type > x)
    {
      this->TrianglesColor_.set (std::move (x));
    }

    const FaceMeshType::TrianglesColorBinary_optional& FaceMeshType::
    TrianglesColorBinary () const
    {
      return this->TrianglesColorBinary_;
    }

    FaceMeshType::TrianglesColorBinary_optional& FaceMeshType::
    TrianglesColorBinary ()
    {
      return this->TrianglesColorBinary_;
    }

    void FaceMeshType::
    TrianglesColorBinary (const TrianglesColorBinary_type& x)
    {
      this->TrianglesColorBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesColorBinary (const TrianglesColorBinary_optional& x)
    {
      this->TrianglesColorBinary_ = x;
    }

    void FaceMeshType::
    TrianglesColorBinary (::std::unique_ptr< TrianglesColorBinary_type > x)
    {
      this->TrianglesColorBinary_.set (std::move (x));
    }


    // ShellSetType
    //

    const ShellSetType::Shell_sequence& ShellSetType::
    Shell () const
    {
      return this->Shell_;
    }

    ShellSetType::Shell_sequence& ShellSetType::
    Shell ()
    {
      return this->Shell_;
    }

    void ShellSetType::
    Shell (const Shell_sequence& s)
    {
      this->Shell_ = s;
    }

    const ShellSetType::n_type& ShellSetType::
    n () const
    {
      return this->n_.get ();
    }

    ShellSetType::n_type& ShellSetType::
    n ()
    {
      return this->n_.get ();
    }

    void ShellSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void ShellSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ShellFormEnumType
    //

    ShellFormEnumType::
    ShellFormEnumType ()
    : ::xml_schema::string ()
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (value v)
    : ::xml_schema::string (_xsd_ShellFormEnumType_literals_[v])
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const wchar_t* v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::std::wstring& v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ShellFormEnumType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ShellFormEnumType& ShellFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ShellFormEnumType_literals_[v]);

      return *this;
    }


    // ShellType
    //

    const ShellType::FaceIds_optional& ShellType::
    FaceIds () const
    {
      return this->FaceIds_;
    }

    ShellType::FaceIds_optional& ShellType::
    FaceIds ()
    {
      return this->FaceIds_;
    }

    void ShellType::
    FaceIds (const FaceIds_type& x)
    {
      this->FaceIds_.set (x);
    }

    void ShellType::
    FaceIds (const FaceIds_optional& x)
    {
      this->FaceIds_ = x;
    }

    void ShellType::
    FaceIds (::std::unique_ptr< FaceIds_type > x)
    {
      this->FaceIds_.set (std::move (x));
    }

    const ShellType::turned_type& ShellType::
    turned () const
    {
      return this->turned_.get ();
    }

    ShellType::turned_type& ShellType::
    turned ()
    {
      return this->turned_.get ();
    }

    void ShellType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    ShellType::turned_type ShellType::
    turned_default_value ()
    {
      return turned_type (false);
    }

    const ShellType::closed_type& ShellType::
    closed () const
    {
      return this->closed_.get ();
    }

    ShellType::closed_type& ShellType::
    closed ()
    {
      return this->closed_.get ();
    }

    void ShellType::
    closed (const closed_type& x)
    {
      this->closed_.set (x);
    }

    ShellType::closed_type ShellType::
    closed_default_value ()
    {
      return closed_type (false);
    }

    const ShellType::form_type& ShellType::
    form () const
    {
      return this->form_.get ();
    }

    ShellType::form_type& ShellType::
    form ()
    {
      return this->form_.get ();
    }

    void ShellType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void ShellType::
    form (::std::unique_ptr< form_type > x)
    {
      this->form_.set (std::move (x));
    }

    const ShellType::form_type& ShellType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // BodySetType
    //

    const BodySetType::Body_sequence& BodySetType::
    Body () const
    {
      return this->Body_;
    }

    BodySetType::Body_sequence& BodySetType::
    Body ()
    {
      return this->Body_;
    }

    void BodySetType::
    Body (const Body_sequence& s)
    {
      this->Body_ = s;
    }

    const BodySetType::n_type& BodySetType::
    n () const
    {
      return this->n_.get ();
    }

    BodySetType::n_type& BodySetType::
    n ()
    {
      return this->n_.get ();
    }

    void BodySetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void BodySetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // ValidationBodyType
    //

    const ValidationBodyType::Area_optional& ValidationBodyType::
    Area () const
    {
      return this->Area_;
    }

    ValidationBodyType::Area_optional& ValidationBodyType::
    Area ()
    {
      return this->Area_;
    }

    void ValidationBodyType::
    Area (const Area_type& x)
    {
      this->Area_.set (x);
    }

    void ValidationBodyType::
    Area (const Area_optional& x)
    {
      this->Area_ = x;
    }

    const ValidationBodyType::Centroid_optional& ValidationBodyType::
    Centroid () const
    {
      return this->Centroid_;
    }

    ValidationBodyType::Centroid_optional& ValidationBodyType::
    Centroid ()
    {
      return this->Centroid_;
    }

    void ValidationBodyType::
    Centroid (const Centroid_type& x)
    {
      this->Centroid_.set (x);
    }

    void ValidationBodyType::
    Centroid (const Centroid_optional& x)
    {
      this->Centroid_ = x;
    }

    void ValidationBodyType::
    Centroid (::std::unique_ptr< Centroid_type > x)
    {
      this->Centroid_.set (std::move (x));
    }

    const ValidationBodyType::Volume_optional& ValidationBodyType::
    Volume () const
    {
      return this->Volume_;
    }

    ValidationBodyType::Volume_optional& ValidationBodyType::
    Volume ()
    {
      return this->Volume_;
    }

    void ValidationBodyType::
    Volume (const Volume_type& x)
    {
      this->Volume_.set (x);
    }

    void ValidationBodyType::
    Volume (const Volume_optional& x)
    {
      this->Volume_ = x;
    }

    const ValidationBodyType::Box_optional& ValidationBodyType::
    Box () const
    {
      return this->Box_;
    }

    ValidationBodyType::Box_optional& ValidationBodyType::
    Box ()
    {
      return this->Box_;
    }

    void ValidationBodyType::
    Box (const Box_type& x)
    {
      this->Box_.set (x);
    }

    void ValidationBodyType::
    Box (const Box_optional& x)
    {
      this->Box_ = x;
    }

    void ValidationBodyType::
    Box (::std::unique_ptr< Box_type > x)
    {
      this->Box_.set (std::move (x));
    }

    const ValidationBodyType::FacePoints_optional& ValidationBodyType::
    FacePoints () const
    {
      return this->FacePoints_;
    }

    ValidationBodyType::FacePoints_optional& ValidationBodyType::
    FacePoints ()
    {
      return this->FacePoints_;
    }

    void ValidationBodyType::
    FacePoints (const FacePoints_type& x)
    {
      this->FacePoints_.set (x);
    }

    void ValidationBodyType::
    FacePoints (const FacePoints_optional& x)
    {
      this->FacePoints_ = x;
    }

    void ValidationBodyType::
    FacePoints (::std::unique_ptr< FacePoints_type > x)
    {
      this->FacePoints_.set (std::move (x));
    }

    const ValidationBodyType::EdgePoints_optional& ValidationBodyType::
    EdgePoints () const
    {
      return this->EdgePoints_;
    }

    ValidationBodyType::EdgePoints_optional& ValidationBodyType::
    EdgePoints ()
    {
      return this->EdgePoints_;
    }

    void ValidationBodyType::
    EdgePoints (const EdgePoints_type& x)
    {
      this->EdgePoints_.set (x);
    }

    void ValidationBodyType::
    EdgePoints (const EdgePoints_optional& x)
    {
      this->EdgePoints_ = x;
    }

    void ValidationBodyType::
    EdgePoints (::std::unique_ptr< EdgePoints_type > x)
    {
      this->EdgePoints_.set (std::move (x));
    }


    // BodyType
    //

    const BodyType::Validation_optional& BodyType::
    Validation () const
    {
      return this->Validation_;
    }

    BodyType::Validation_optional& BodyType::
    Validation ()
    {
      return this->Validation_;
    }

    void BodyType::
    Validation (const Validation_type& x)
    {
      this->Validation_.set (x);
    }

    void BodyType::
    Validation (const Validation_optional& x)
    {
      this->Validation_ = x;
    }

    void BodyType::
    Validation (::std::unique_ptr< Validation_type > x)
    {
      this->Validation_.set (std::move (x));
    }

    const BodyType::Transform_optional& BodyType::
    Transform () const
    {
      return this->Transform_;
    }

    BodyType::Transform_optional& BodyType::
    Transform ()
    {
      return this->Transform_;
    }

    void BodyType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void BodyType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void BodyType::
    Transform (::std::unique_ptr< Transform_type > x)
    {
      this->Transform_.set (std::move (x));
    }

    const BodyType::ShellIds_optional& BodyType::
    ShellIds () const
    {
      return this->ShellIds_;
    }

    BodyType::ShellIds_optional& BodyType::
    ShellIds ()
    {
      return this->ShellIds_;
    }

    void BodyType::
    ShellIds (const ShellIds_type& x)
    {
      this->ShellIds_.set (x);
    }

    void BodyType::
    ShellIds (const ShellIds_optional& x)
    {
      this->ShellIds_ = x;
    }

    void BodyType::
    ShellIds (::std::unique_ptr< ShellIds_type > x)
    {
      this->ShellIds_.set (std::move (x));
    }

    const BodyType::FaceIds_optional& BodyType::
    FaceIds () const
    {
      return this->FaceIds_;
    }

    BodyType::FaceIds_optional& BodyType::
    FaceIds ()
    {
      return this->FaceIds_;
    }

    void BodyType::
    FaceIds (const FaceIds_type& x)
    {
      this->FaceIds_.set (x);
    }

    void BodyType::
    FaceIds (const FaceIds_optional& x)
    {
      this->FaceIds_ = x;
    }

    void BodyType::
    FaceIds (::std::unique_ptr< FaceIds_type > x)
    {
      this->FaceIds_.set (std::move (x));
    }

    const BodyType::LoopIds_optional& BodyType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    BodyType::LoopIds_optional& BodyType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void BodyType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void BodyType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void BodyType::
    LoopIds (::std::unique_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (std::move (x));
    }

    const BodyType::EdgeIds_optional& BodyType::
    EdgeIds () const
    {
      return this->EdgeIds_;
    }

    BodyType::EdgeIds_optional& BodyType::
    EdgeIds ()
    {
      return this->EdgeIds_;
    }

    void BodyType::
    EdgeIds (const EdgeIds_type& x)
    {
      this->EdgeIds_.set (x);
    }

    void BodyType::
    EdgeIds (const EdgeIds_optional& x)
    {
      this->EdgeIds_ = x;
    }

    void BodyType::
    EdgeIds (::std::unique_ptr< EdgeIds_type > x)
    {
      this->EdgeIds_.set (std::move (x));
    }

    const BodyType::VertexIds_optional& BodyType::
    VertexIds () const
    {
      return this->VertexIds_;
    }

    BodyType::VertexIds_optional& BodyType::
    VertexIds ()
    {
      return this->VertexIds_;
    }

    void BodyType::
    VertexIds (const VertexIds_type& x)
    {
      this->VertexIds_.set (x);
    }

    void BodyType::
    VertexIds (const VertexIds_optional& x)
    {
      this->VertexIds_ = x;
    }

    void BodyType::
    VertexIds (::std::unique_ptr< VertexIds_type > x)
    {
      this->VertexIds_.set (std::move (x));
    }

    const BodyType::form_type& BodyType::
    form () const
    {
      return this->form_.get ();
    }

    BodyType::form_type& BodyType::
    form ()
    {
      return this->form_.get ();
    }

    void BodyType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void BodyType::
    form (::std::unique_ptr< form_type > x)
    {
      this->form_.set (std::move (x));
    }

    const BodyType::form_type& BodyType::
    form_default_value ()
    {
      return form_default_value_;
    }

    const BodyType::materialIndex_optional& BodyType::
    materialIndex () const
    {
      return this->materialIndex_;
    }

    BodyType::materialIndex_optional& BodyType::
    materialIndex ()
    {
      return this->materialIndex_;
    }

    void BodyType::
    materialIndex (const materialIndex_type& x)
    {
      this->materialIndex_.set (x);
    }

    void BodyType::
    materialIndex (const materialIndex_optional& x)
    {
      this->materialIndex_ = x;
    }

    void BodyType::
    materialIndex (::std::unique_ptr< materialIndex_type > x)
    {
      this->materialIndex_.set (std::move (x));
    }


    // BodyFormEnumType
    //

    BodyFormEnumType::
    BodyFormEnumType ()
    : ::xml_schema::nmtoken ()
    {
    }

    BodyFormEnumType::
    BodyFormEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_BodyFormEnumType_literals_[v])
    {
    }

    BodyFormEnumType::
    BodyFormEnumType (const wchar_t* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BodyFormEnumType::
    BodyFormEnumType (const ::std::wstring& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BodyFormEnumType::
    BodyFormEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BodyFormEnumType::
    BodyFormEnumType (const BodyFormEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    BodyFormEnumType& BodyFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_BodyFormEnumType_literals_[v]);

      return *this;
    }


    // PointCloudSetType
    //

    const PointCloudSetType::PointCloud_sequence& PointCloudSetType::
    PointCloud () const
    {
      return this->PointCloud_;
    }

    PointCloudSetType::PointCloud_sequence& PointCloudSetType::
    PointCloud ()
    {
      return this->PointCloud_;
    }

    void PointCloudSetType::
    PointCloud (const PointCloud_sequence& s)
    {
      this->PointCloud_ = s;
    }

    const PointCloudSetType::n_type& PointCloudSetType::
    n () const
    {
      return this->n_.get ();
    }

    PointCloudSetType::n_type& PointCloudSetType::
    n ()
    {
      return this->n_.get ();
    }

    void PointCloudSetType::
    n (const n_type& x)
    {
      this->n_.set (x);
    }

    void PointCloudSetType::
    n (::std::unique_ptr< n_type > x)
    {
      this->n_.set (std::move (x));
    }


    // PointCloudType
    //

    const PointCloudType::Points_optional& PointCloudType::
    Points () const
    {
      return this->Points_;
    }

    PointCloudType::Points_optional& PointCloudType::
    Points ()
    {
      return this->Points_;
    }

    void PointCloudType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void PointCloudType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void PointCloudType::
    Points (::std::unique_ptr< Points_type > x)
    {
      this->Points_.set (std::move (x));
    }

    const PointCloudType::PointsBinary_optional& PointCloudType::
    PointsBinary () const
    {
      return this->PointsBinary_;
    }

    PointCloudType::PointsBinary_optional& PointCloudType::
    PointsBinary ()
    {
      return this->PointsBinary_;
    }

    void PointCloudType::
    PointsBinary (const PointsBinary_type& x)
    {
      this->PointsBinary_.set (x);
    }

    void PointCloudType::
    PointsBinary (const PointsBinary_optional& x)
    {
      this->PointsBinary_ = x;
    }

    void PointCloudType::
    PointsBinary (::std::unique_ptr< PointsBinary_type > x)
    {
      this->PointsBinary_.set (std::move (x));
    }

    const PointCloudType::Normals_optional& PointCloudType::
    Normals () const
    {
      return this->Normals_;
    }

    PointCloudType::Normals_optional& PointCloudType::
    Normals ()
    {
      return this->Normals_;
    }

    void PointCloudType::
    Normals (const Normals_type& x)
    {
      this->Normals_.set (x);
    }

    void PointCloudType::
    Normals (const Normals_optional& x)
    {
      this->Normals_ = x;
    }

    void PointCloudType::
    Normals (::std::unique_ptr< Normals_type > x)
    {
      this->Normals_.set (std::move (x));
    }

    const PointCloudType::NormalsBinary_optional& PointCloudType::
    NormalsBinary () const
    {
      return this->NormalsBinary_;
    }

    PointCloudType::NormalsBinary_optional& PointCloudType::
    NormalsBinary ()
    {
      return this->NormalsBinary_;
    }

    void PointCloudType::
    NormalsBinary (const NormalsBinary_type& x)
    {
      this->NormalsBinary_.set (x);
    }

    void PointCloudType::
    NormalsBinary (const NormalsBinary_optional& x)
    {
      this->NormalsBinary_ = x;
    }

    void PointCloudType::
    NormalsBinary (::std::unique_ptr< NormalsBinary_type > x)
    {
      this->NormalsBinary_.set (std::move (x));
    }

    const PointCloudType::PointsVisible_optional& PointCloudType::
    PointsVisible () const
    {
      return this->PointsVisible_;
    }

    PointCloudType::PointsVisible_optional& PointCloudType::
    PointsVisible ()
    {
      return this->PointsVisible_;
    }

    void PointCloudType::
    PointsVisible (const PointsVisible_type& x)
    {
      this->PointsVisible_.set (x);
    }

    void PointCloudType::
    PointsVisible (const PointsVisible_optional& x)
    {
      this->PointsVisible_ = x;
    }

    void PointCloudType::
    PointsVisible (::std::unique_ptr< PointsVisible_type > x)
    {
      this->PointsVisible_.set (std::move (x));
    }

    const PointCloudType::PointsVisibleBinary_optional& PointCloudType::
    PointsVisibleBinary () const
    {
      return this->PointsVisibleBinary_;
    }

    PointCloudType::PointsVisibleBinary_optional& PointCloudType::
    PointsVisibleBinary ()
    {
      return this->PointsVisibleBinary_;
    }

    void PointCloudType::
    PointsVisibleBinary (const PointsVisibleBinary_type& x)
    {
      this->PointsVisibleBinary_.set (x);
    }

    void PointCloudType::
    PointsVisibleBinary (const PointsVisibleBinary_optional& x)
    {
      this->PointsVisibleBinary_ = x;
    }

    void PointCloudType::
    PointsVisibleBinary (::std::unique_ptr< PointsVisibleBinary_type > x)
    {
      this->PointsVisibleBinary_.set (std::move (x));
    }

    const PointCloudType::PointsHidden_optional& PointCloudType::
    PointsHidden () const
    {
      return this->PointsHidden_;
    }

    PointCloudType::PointsHidden_optional& PointCloudType::
    PointsHidden ()
    {
      return this->PointsHidden_;
    }

    void PointCloudType::
    PointsHidden (const PointsHidden_type& x)
    {
      this->PointsHidden_.set (x);
    }

    void PointCloudType::
    PointsHidden (const PointsHidden_optional& x)
    {
      this->PointsHidden_ = x;
    }

    void PointCloudType::
    PointsHidden (::std::unique_ptr< PointsHidden_type > x)
    {
      this->PointsHidden_.set (std::move (x));
    }

    const PointCloudType::PointsHiddenBinary_optional& PointCloudType::
    PointsHiddenBinary () const
    {
      return this->PointsHiddenBinary_;
    }

    PointCloudType::PointsHiddenBinary_optional& PointCloudType::
    PointsHiddenBinary ()
    {
      return this->PointsHiddenBinary_;
    }

    void PointCloudType::
    PointsHiddenBinary (const PointsHiddenBinary_type& x)
    {
      this->PointsHiddenBinary_.set (x);
    }

    void PointCloudType::
    PointsHiddenBinary (const PointsHiddenBinary_optional& x)
    {
      this->PointsHiddenBinary_ = x;
    }

    void PointCloudType::
    PointsHiddenBinary (::std::unique_ptr< PointsHiddenBinary_type > x)
    {
      this->PointsHiddenBinary_.set (std::move (x));
    }

    const PointCloudType::PointsColor_optional& PointCloudType::
    PointsColor () const
    {
      return this->PointsColor_;
    }

    PointCloudType::PointsColor_optional& PointCloudType::
    PointsColor ()
    {
      return this->PointsColor_;
    }

    void PointCloudType::
    PointsColor (const PointsColor_type& x)
    {
      this->PointsColor_.set (x);
    }

    void PointCloudType::
    PointsColor (const PointsColor_optional& x)
    {
      this->PointsColor_ = x;
    }

    void PointCloudType::
    PointsColor (::std::unique_ptr< PointsColor_type > x)
    {
      this->PointsColor_.set (std::move (x));
    }

    const PointCloudType::PointsColorBinary_optional& PointCloudType::
    PointsColorBinary () const
    {
      return this->PointsColorBinary_;
    }

    PointCloudType::PointsColorBinary_optional& PointCloudType::
    PointsColorBinary ()
    {
      return this->PointsColorBinary_;
    }

    void PointCloudType::
    PointsColorBinary (const PointsColorBinary_type& x)
    {
      this->PointsColorBinary_.set (x);
    }

    void PointCloudType::
    PointsColorBinary (const PointsColorBinary_optional& x)
    {
      this->PointsColorBinary_ = x;
    }

    void PointCloudType::
    PointsColorBinary (::std::unique_ptr< PointsColorBinary_type > x)
    {
      this->PointsColorBinary_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    // TopologySetType
    //

    TopologySetType::
    TopologySetType ()
    : ::xml_schema::type (),
      VertexSet_ (this),
      EdgeSet_ (this),
      LoopSet_ (this),
      FaceSet_ (this),
      ShellSet_ (this),
      BodySet_ (this),
      PointCloudSet_ (this)
    {
    }

    TopologySetType::
    TopologySetType (const TopologySetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      VertexSet_ (x.VertexSet_, f, this),
      EdgeSet_ (x.EdgeSet_, f, this),
      LoopSet_ (x.LoopSet_, f, this),
      FaceSet_ (x.FaceSet_, f, this),
      ShellSet_ (x.ShellSet_, f, this),
      BodySet_ (x.BodySet_, f, this),
      PointCloudSet_ (x.PointCloudSet_, f, this)
    {
    }

    TopologySetType::
    TopologySetType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      VertexSet_ (this),
      EdgeSet_ (this),
      LoopSet_ (this),
      FaceSet_ (this),
      ShellSet_ (this),
      BodySet_ (this),
      PointCloudSet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TopologySetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // VertexSet
        //
        if (n.name () == L"VertexSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VertexSet_type > r (
            VertexSet_traits::create (i, f, this));

          if (!this->VertexSet_)
          {
            this->VertexSet_.set (::std::move (r));
            continue;
          }
        }

        // EdgeSet
        //
        if (n.name () == L"EdgeSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgeSet_type > r (
            EdgeSet_traits::create (i, f, this));

          if (!this->EdgeSet_)
          {
            this->EdgeSet_.set (::std::move (r));
            continue;
          }
        }

        // LoopSet
        //
        if (n.name () == L"LoopSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LoopSet_type > r (
            LoopSet_traits::create (i, f, this));

          if (!this->LoopSet_)
          {
            this->LoopSet_.set (::std::move (r));
            continue;
          }
        }

        // FaceSet
        //
        if (n.name () == L"FaceSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FaceSet_type > r (
            FaceSet_traits::create (i, f, this));

          if (!this->FaceSet_)
          {
            this->FaceSet_.set (::std::move (r));
            continue;
          }
        }

        // ShellSet
        //
        if (n.name () == L"ShellSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShellSet_type > r (
            ShellSet_traits::create (i, f, this));

          if (!this->ShellSet_)
          {
            this->ShellSet_.set (::std::move (r));
            continue;
          }
        }

        // BodySet
        //
        if (n.name () == L"BodySet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< BodySet_type > r (
            BodySet_traits::create (i, f, this));

          if (!this->BodySet_)
          {
            this->BodySet_.set (::std::move (r));
            continue;
          }
        }

        // PointCloudSet
        //
        if (n.name () == L"PointCloudSet" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointCloudSet_type > r (
            PointCloudSet_traits::create (i, f, this));

          if (!this->PointCloudSet_)
          {
            this->PointCloudSet_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    TopologySetType* TopologySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TopologySetType (*this, f, c);
    }

    TopologySetType& TopologySetType::
    operator= (const TopologySetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->VertexSet_ = x.VertexSet_;
        this->EdgeSet_ = x.EdgeSet_;
        this->LoopSet_ = x.LoopSet_;
        this->FaceSet_ = x.FaceSet_;
        this->ShellSet_ = x.ShellSet_;
        this->BodySet_ = x.BodySet_;
        this->PointCloudSet_ = x.PointCloudSet_;
      }

      return *this;
    }

    TopologySetType::
    ~TopologySetType ()
    {
    }

    // TopologyBaseType
    //

    TopologyBaseType::
    TopologyBaseType ()
    : ::xsd::qif30::DrawableBaseType ()
    {
    }

    TopologyBaseType::
    TopologyBaseType (const id_type& id)
    : ::xsd::qif30::DrawableBaseType (id)
    {
    }

    TopologyBaseType::
    TopologyBaseType (const TopologyBaseType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (x, f, c)
    {
    }

    TopologyBaseType::
    TopologyBaseType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif30::DrawableBaseType (e, f, c)
    {
    }

    TopologyBaseType::
    ~TopologyBaseType ()
    {
    }

    // VertexSetType
    //

    VertexSetType::
    VertexSetType ()
    : ::xml_schema::type (),
      Vertex_ (this),
      n_ (this)
    {
    }

    VertexSetType::
    VertexSetType (const n_type& n)
    : ::xml_schema::type (),
      Vertex_ (this),
      n_ (n, this)
    {
    }

    VertexSetType::
    VertexSetType (const VertexSetType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Vertex_ (x.Vertex_, f, this),
      n_ (x.n_, f, this)
    {
    }

    VertexSetType::
    VertexSetType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Vertex_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VertexSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Vertex
        //
        if (n.name () == L"Vertex" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Vertex_type > r (
            Vertex_traits::create (i, f, this));

          this->Vertex_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    VertexSetType* VertexSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VertexSetType (*this, f, c);
    }

    VertexSetType& VertexSetType::
    operator= (const VertexSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Vertex_ = x.Vertex_;
        this->n_ = x.n_;
      }

      return *this;
    }

    VertexSetType::
    ~VertexSetType ()
    {
    }

    // VertexType
    //

    VertexType::
    VertexType ()
    : ::xsd::qif30::TopologyBaseType (),
      Point_ (this),
      tolerance_ (this)
    {
    }

    VertexType::
    VertexType (const id_type& id,
                const Point_type& Point)
    : ::xsd::qif30::TopologyBaseType (id),
      Point_ (Point, this),
      tolerance_ (this)
    {
    }

    VertexType::
    VertexType (const id_type& id,
                ::std::unique_ptr< Point_type > Point)
    : ::xsd::qif30::TopologyBaseType (id),
      Point_ (std::move (Point), this),
      tolerance_ (this)
    {
    }

    VertexType::
    VertexType (const VertexType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (x, f, c),
      Point_ (x.Point_, f, this),
      tolerance_ (x.tolerance_, f, this)
    {
    }

    VertexType::
    VertexType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      tolerance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VertexType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Point
        //
        if (n.name () == L"Point" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Point",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"tolerance" && n.namespace_ ().empty ())
        {
          this->tolerance_.set (tolerance_traits::create (i, f, this));
          continue;
        }
      }
    }

    VertexType* VertexType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VertexType (*this, f, c);
    }

    VertexType& VertexType::
    operator= (const VertexType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TopologyBaseType& > (*this) = x;
        this->Point_ = x.Point_;
        this->tolerance_ = x.tolerance_;
      }

      return *this;
    }

    VertexType::
    ~VertexType ()
    {
    }

    // EdgeSetType
    //

    EdgeSetType::
    EdgeSetType ()
    : ::xml_schema::type (),
      Edge_ (this),
      n_ (this)
    {
    }

    EdgeSetType::
    EdgeSetType (const n_type& n)
    : ::xml_schema::type (),
      Edge_ (this),
      n_ (n, this)
    {
    }

    EdgeSetType::
    EdgeSetType (const EdgeSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Edge_ (x.Edge_, f, this),
      n_ (x.n_, f, this)
    {
    }

    EdgeSetType::
    EdgeSetType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Edge_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgeSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Edge
        //
        if (n.name () == L"Edge" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Edge_type > r (
            Edge_traits::create (i, f, this));

          this->Edge_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    EdgeSetType* EdgeSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeSetType (*this, f, c);
    }

    EdgeSetType& EdgeSetType::
    operator= (const EdgeSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Edge_ = x.Edge_;
        this->n_ = x.n_;
      }

      return *this;
    }

    EdgeSetType::
    ~EdgeSetType ()
    {
    }

    // ValidationEdgeType
    //

    ValidationEdgeType::
    ValidationEdgeType ()
    : ::xml_schema::type (),
      Length_ (this),
      Centroid_ (this),
      Box_ (this),
      Points_ (this)
    {
    }

    ValidationEdgeType::
    ValidationEdgeType (const ValidationEdgeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Length_ (x.Length_, f, this),
      Centroid_ (x.Centroid_, f, this),
      Box_ (x.Box_, f, this),
      Points_ (x.Points_, f, this)
    {
    }

    ValidationEdgeType::
    ValidationEdgeType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Length_ (this),
      Centroid_ (this),
      Box_ (this),
      Points_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ValidationEdgeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Length
        //
        if (n.name () == L"Length" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Length_)
          {
            this->Length_.set (Length_traits::create (i, f, this));
            continue;
          }
        }

        // Centroid
        //
        if (n.name () == L"Centroid" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Centroid_type > r (
            Centroid_traits::create (i, f, this));

          if (!this->Centroid_)
          {
            this->Centroid_.set (::std::move (r));
            continue;
          }
        }

        // Box
        //
        if (n.name () == L"Box" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Box_type > r (
            Box_traits::create (i, f, this));

          if (!this->Box_)
          {
            this->Box_.set (::std::move (r));
            continue;
          }
        }

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ValidationEdgeType* ValidationEdgeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidationEdgeType (*this, f, c);
    }

    ValidationEdgeType& ValidationEdgeType::
    operator= (const ValidationEdgeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Length_ = x.Length_;
        this->Centroid_ = x.Centroid_;
        this->Box_ = x.Box_;
        this->Points_ = x.Points_;
      }

      return *this;
    }

    ValidationEdgeType::
    ~ValidationEdgeType ()
    {
    }

    // EdgeType
    //

    EdgeType::
    EdgeType ()
    : ::xsd::qif30::TopologyBaseType (),
      Validation_ (this),
      Curve_ (this),
      VertexBeg_ (this),
      VertexEnd_ (this),
      tolerance_ (this)
    {
    }

    EdgeType::
    EdgeType (const id_type& id,
              const Curve_type& Curve,
              const VertexBeg_type& VertexBeg,
              const VertexEnd_type& VertexEnd)
    : ::xsd::qif30::TopologyBaseType (id),
      Validation_ (this),
      Curve_ (Curve, this),
      VertexBeg_ (VertexBeg, this),
      VertexEnd_ (VertexEnd, this),
      tolerance_ (this)
    {
    }

    EdgeType::
    EdgeType (const id_type& id,
              ::std::unique_ptr< Curve_type > Curve,
              ::std::unique_ptr< VertexBeg_type > VertexBeg,
              ::std::unique_ptr< VertexEnd_type > VertexEnd)
    : ::xsd::qif30::TopologyBaseType (id),
      Validation_ (this),
      Curve_ (std::move (Curve), this),
      VertexBeg_ (std::move (VertexBeg), this),
      VertexEnd_ (std::move (VertexEnd), this),
      tolerance_ (this)
    {
    }

    EdgeType::
    EdgeType (const EdgeType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (x, f, c),
      Validation_ (x.Validation_, f, this),
      Curve_ (x.Curve_, f, this),
      VertexBeg_ (x.VertexBeg_, f, this),
      VertexEnd_ (x.VertexEnd_, f, this),
      tolerance_ (x.tolerance_, f, this)
    {
    }

    EdgeType::
    EdgeType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Validation_ (this),
      Curve_ (this),
      VertexBeg_ (this),
      VertexEnd_ (this),
      tolerance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Validation
        //
        if (n.name () == L"Validation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Validation_type > r (
            Validation_traits::create (i, f, this));

          if (!this->Validation_)
          {
            this->Validation_.set (::std::move (r));
            continue;
          }
        }

        // Curve
        //
        if (n.name () == L"Curve" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Curve_type > r (
            Curve_traits::create (i, f, this));

          if (!Curve_.present ())
          {
            this->Curve_.set (::std::move (r));
            continue;
          }
        }

        // VertexBeg
        //
        if (n.name () == L"VertexBeg" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VertexBeg_type > r (
            VertexBeg_traits::create (i, f, this));

          if (!VertexBeg_.present ())
          {
            this->VertexBeg_.set (::std::move (r));
            continue;
          }
        }

        // VertexEnd
        //
        if (n.name () == L"VertexEnd" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VertexEnd_type > r (
            VertexEnd_traits::create (i, f, this));

          if (!VertexEnd_.present ())
          {
            this->VertexEnd_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Curve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Curve",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!VertexBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"VertexBeg",
          L"http://qifstandards.org/xsd/qif3");
      }

      if (!VertexEnd_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"VertexEnd",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"tolerance" && n.namespace_ ().empty ())
        {
          this->tolerance_.set (tolerance_traits::create (i, f, this));
          continue;
        }
      }
    }

    EdgeType* EdgeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeType (*this, f, c);
    }

    EdgeType& EdgeType::
    operator= (const EdgeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TopologyBaseType& > (*this) = x;
        this->Validation_ = x.Validation_;
        this->Curve_ = x.Curve_;
        this->VertexBeg_ = x.VertexBeg_;
        this->VertexEnd_ = x.VertexEnd_;
        this->tolerance_ = x.tolerance_;
      }

      return *this;
    }

    EdgeType::
    ~EdgeType ()
    {
    }

    // LoopSetType
    //

    LoopSetType::
    LoopSetType ()
    : ::xml_schema::type (),
      LoopBase_ (this),
      n_ (this)
    {
    }

    LoopSetType::
    LoopSetType (const n_type& n)
    : ::xml_schema::type (),
      LoopBase_ (this),
      n_ (n, this)
    {
    }

    LoopSetType::
    LoopSetType (const LoopSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LoopBase_ (x.LoopBase_, f, this),
      n_ (x.n_, f, this)
    {
    }

    LoopSetType::
    LoopSetType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LoopBase_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LoopSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // LoopBase
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"LoopBase",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< LoopBase_type > r (
              dynamic_cast< LoopBase_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->LoopBase_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    LoopSetType* LoopSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopSetType (*this, f, c);
    }

    LoopSetType& LoopSetType::
    operator= (const LoopSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LoopBase_ = x.LoopBase_;
        this->n_ = x.n_;
      }

      return *this;
    }

    LoopSetType::
    ~LoopSetType ()
    {
    }

    // LoopBaseType
    //

    LoopBaseType::
    LoopBaseType ()
    : ::xsd::qif30::TopologyBaseType ()
    {
    }

    LoopBaseType::
    LoopBaseType (const id_type& id)
    : ::xsd::qif30::TopologyBaseType (id)
    {
    }

    LoopBaseType::
    LoopBaseType (const LoopBaseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (x, f, c)
    {
    }

    LoopBaseType::
    LoopBaseType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (e, f, c)
    {
    }

    LoopBaseType::
    ~LoopBaseType ()
    {
    }

    // LoopFormEnumType
    //

    LoopFormEnumType::
    LoopFormEnumType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType::
    LoopFormEnumType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType* LoopFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopFormEnumType (*this, f, c);
    }

    LoopFormEnumType::value LoopFormEnumType::
    _xsd_LoopFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_LoopFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LoopFormEnumType_indexes_,
                        _xsd_LoopFormEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_LoopFormEnumType_indexes_ + 5 || _xsd_LoopFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const LoopFormEnumType::
    _xsd_LoopFormEnumType_literals_[5] =
    {
      L"UNKNOWN",
      L"OUTER",
      L"INNER",
      L"SLIT",
      L"VERTEX"
    };

    const LoopFormEnumType::value LoopFormEnumType::
    _xsd_LoopFormEnumType_indexes_[5] =
    {
      ::xsd::qif30::LoopFormEnumType::INNER,
      ::xsd::qif30::LoopFormEnumType::OUTER,
      ::xsd::qif30::LoopFormEnumType::SLIT,
      ::xsd::qif30::LoopFormEnumType::UNKNOWN,
      ::xsd::qif30::LoopFormEnumType::VERTEX
    };

    // CoEdgeType
    //

    CoEdgeType::
    CoEdgeType ()
    : ::xml_schema::type (),
      EdgeOriented_ (this),
      Curve12_ (this)
    {
    }

    CoEdgeType::
    CoEdgeType (const EdgeOriented_type& EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, this),
      Curve12_ (this)
    {
    }

    CoEdgeType::
    CoEdgeType (::std::unique_ptr< EdgeOriented_type > EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (std::move (EdgeOriented), this),
      Curve12_ (this)
    {
    }

    CoEdgeType::
    CoEdgeType (const CoEdgeType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EdgeOriented_ (x.EdgeOriented_, f, this),
      Curve12_ (x.Curve12_, f, this)
    {
    }

    CoEdgeType::
    CoEdgeType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EdgeOriented_ (this),
      Curve12_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoEdgeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EdgeOriented
        //
        if (n.name () == L"EdgeOriented" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgeOriented_type > r (
            EdgeOriented_traits::create (i, f, this));

          if (!EdgeOriented_.present ())
          {
            this->EdgeOriented_.set (::std::move (r));
            continue;
          }
        }

        // Curve12
        //
        if (n.name () == L"Curve12" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Curve12_type > r (
            Curve12_traits::create (i, f, this));

          if (!this->Curve12_)
          {
            this->Curve12_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!EdgeOriented_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EdgeOriented",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CoEdgeType* CoEdgeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgeType (*this, f, c);
    }

    CoEdgeType& CoEdgeType::
    operator= (const CoEdgeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EdgeOriented_ = x.EdgeOriented_;
        this->Curve12_ = x.Curve12_;
      }

      return *this;
    }

    CoEdgeType::
    ~CoEdgeType ()
    {
    }

    // CoEdgesType
    //

    CoEdgesType::
    CoEdgesType ()
    : ::xml_schema::type (),
      CoEdge_ (this),
      n_ (this)
    {
    }

    CoEdgesType::
    CoEdgesType (const n_type& n)
    : ::xml_schema::type (),
      CoEdge_ (this),
      n_ (n, this)
    {
    }

    CoEdgesType::
    CoEdgesType (const CoEdgesType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoEdge_ (x.CoEdge_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CoEdgesType::
    CoEdgesType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoEdge_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoEdgesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoEdge
        //
        if (n.name () == L"CoEdge" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoEdge_type > r (
            CoEdge_traits::create (i, f, this));

          this->CoEdge_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CoEdgesType* CoEdgesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgesType (*this, f, c);
    }

    CoEdgesType& CoEdgesType::
    operator= (const CoEdgesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoEdge_ = x.CoEdge_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CoEdgesType::
    ~CoEdgesType ()
    {
    }

    // CoEdgeMeshType
    //

    CoEdgeMeshType::
    CoEdgeMeshType ()
    : ::xml_schema::type (),
      EdgeOriented_ (this),
      CurveMesh_ (this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (const EdgeOriented_type& EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, this),
      CurveMesh_ (this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (::std::unique_ptr< EdgeOriented_type > EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (std::move (EdgeOriented), this),
      CurveMesh_ (this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (const CoEdgeMeshType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EdgeOriented_ (x.EdgeOriented_, f, this),
      CurveMesh_ (x.CurveMesh_, f, this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EdgeOriented_ (this),
      CurveMesh_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoEdgeMeshType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EdgeOriented
        //
        if (n.name () == L"EdgeOriented" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgeOriented_type > r (
            EdgeOriented_traits::create (i, f, this));

          if (!EdgeOriented_.present ())
          {
            this->EdgeOriented_.set (::std::move (r));
            continue;
          }
        }

        // CurveMesh
        //
        if (n.name () == L"CurveMesh" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CurveMesh_type > r (
            CurveMesh_traits::create (i, f, this));

          if (!this->CurveMesh_)
          {
            this->CurveMesh_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!EdgeOriented_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EdgeOriented",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    CoEdgeMeshType* CoEdgeMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgeMeshType (*this, f, c);
    }

    CoEdgeMeshType& CoEdgeMeshType::
    operator= (const CoEdgeMeshType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EdgeOriented_ = x.EdgeOriented_;
        this->CurveMesh_ = x.CurveMesh_;
      }

      return *this;
    }

    CoEdgeMeshType::
    ~CoEdgeMeshType ()
    {
    }

    // CoEdgesMeshType
    //

    CoEdgesMeshType::
    CoEdgesMeshType ()
    : ::xml_schema::type (),
      CoEdgeMesh_ (this),
      n_ (this)
    {
    }

    CoEdgesMeshType::
    CoEdgesMeshType (const n_type& n)
    : ::xml_schema::type (),
      CoEdgeMesh_ (this),
      n_ (n, this)
    {
    }

    CoEdgesMeshType::
    CoEdgesMeshType (const CoEdgesMeshType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoEdgeMesh_ (x.CoEdgeMesh_, f, this),
      n_ (x.n_, f, this)
    {
    }

    CoEdgesMeshType::
    CoEdgesMeshType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoEdgeMesh_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoEdgesMeshType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoEdgeMesh
        //
        if (n.name () == L"CoEdgeMesh" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoEdgeMesh_type > r (
            CoEdgeMesh_traits::create (i, f, this));

          this->CoEdgeMesh_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    CoEdgesMeshType* CoEdgesMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgesMeshType (*this, f, c);
    }

    CoEdgesMeshType& CoEdgesMeshType::
    operator= (const CoEdgesMeshType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoEdgeMesh_ = x.CoEdgeMesh_;
        this->n_ = x.n_;
      }

      return *this;
    }

    CoEdgesMeshType::
    ~CoEdgesMeshType ()
    {
    }

    // LoopType
    //

    const LoopType::form_type LoopType::form_default_value_ (
      L"UNKNOWN");

    LoopType::
    LoopType ()
    : ::xsd::qif30::LoopBaseType (),
      CoEdges_ (this),
      form_ (form_default_value (), this)
    {
    }

    LoopType::
    LoopType (const id_type& id,
              const CoEdges_type& CoEdges)
    : ::xsd::qif30::LoopBaseType (id),
      CoEdges_ (CoEdges, this),
      form_ (form_default_value (), this)
    {
    }

    LoopType::
    LoopType (const id_type& id,
              ::std::unique_ptr< CoEdges_type > CoEdges)
    : ::xsd::qif30::LoopBaseType (id),
      CoEdges_ (std::move (CoEdges), this),
      form_ (form_default_value (), this)
    {
    }

    LoopType::
    LoopType (const LoopType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::LoopBaseType (x, f, c),
      CoEdges_ (x.CoEdges_, f, this),
      form_ (x.form_, f, this)
    {
    }

    LoopType::
    LoopType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::LoopBaseType (e, f | ::xml_schema::flags::base, c),
      CoEdges_ (this),
      form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LoopType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LoopBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoEdges
        //
        if (n.name () == L"CoEdges" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoEdges_type > r (
            CoEdges_traits::create (i, f, this));

          if (!CoEdges_.present ())
          {
            this->CoEdges_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CoEdges_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CoEdges",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    LoopType* LoopType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopType (*this, f, c);
    }

    LoopType& LoopType::
    operator= (const LoopType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LoopBaseType& > (*this) = x;
        this->CoEdges_ = x.CoEdges_;
        this->form_ = x.form_;
      }

      return *this;
    }

    LoopType::
    ~LoopType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LoopType >
    _xsd_LoopType_type_factory_init (
      L"LoopType",
      L"http://qifstandards.org/xsd/qif3");

    // LoopMeshType
    //

    LoopMeshType::
    LoopMeshType ()
    : ::xsd::qif30::LoopBaseType (),
      CoEdgesMesh_ (this)
    {
    }

    LoopMeshType::
    LoopMeshType (const id_type& id,
                  const CoEdgesMesh_type& CoEdgesMesh)
    : ::xsd::qif30::LoopBaseType (id),
      CoEdgesMesh_ (CoEdgesMesh, this)
    {
    }

    LoopMeshType::
    LoopMeshType (const id_type& id,
                  ::std::unique_ptr< CoEdgesMesh_type > CoEdgesMesh)
    : ::xsd::qif30::LoopBaseType (id),
      CoEdgesMesh_ (std::move (CoEdgesMesh), this)
    {
    }

    LoopMeshType::
    LoopMeshType (const LoopMeshType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::LoopBaseType (x, f, c),
      CoEdgesMesh_ (x.CoEdgesMesh_, f, this)
    {
    }

    LoopMeshType::
    LoopMeshType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::LoopBaseType (e, f | ::xml_schema::flags::base, c),
      CoEdgesMesh_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LoopMeshType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::LoopBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CoEdgesMesh
        //
        if (n.name () == L"CoEdgesMesh" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< CoEdgesMesh_type > r (
            CoEdgesMesh_traits::create (i, f, this));

          if (!CoEdgesMesh_.present ())
          {
            this->CoEdgesMesh_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!CoEdgesMesh_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CoEdgesMesh",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    LoopMeshType* LoopMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopMeshType (*this, f, c);
    }

    LoopMeshType& LoopMeshType::
    operator= (const LoopMeshType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::LoopBaseType& > (*this) = x;
        this->CoEdgesMesh_ = x.CoEdgesMesh_;
      }

      return *this;
    }

    LoopMeshType::
    ~LoopMeshType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LoopMeshType >
    _xsd_LoopMeshType_type_factory_init (
      L"LoopMeshType",
      L"http://qifstandards.org/xsd/qif3");

    // FaceSetType
    //

    FaceSetType::
    FaceSetType ()
    : ::xml_schema::type (),
      FaceBase_ (this),
      n_ (this)
    {
    }

    FaceSetType::
    FaceSetType (const n_type& n)
    : ::xml_schema::type (),
      FaceBase_ (this),
      n_ (n, this)
    {
    }

    FaceSetType::
    FaceSetType (const FaceSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FaceBase_ (x.FaceBase_, f, this),
      n_ (x.n_, f, this)
    {
    }

    FaceSetType::
    FaceSetType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FaceBase_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FaceSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FaceBase
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ().create (
              L"FaceBase",
              L"http://qifstandards.org/xsd/qif3",
              0,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FaceBase_type > r (
              dynamic_cast< FaceBase_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->FaceBase_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    FaceSetType* FaceSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceSetType (*this, f, c);
    }

    FaceSetType& FaceSetType::
    operator= (const FaceSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FaceBase_ = x.FaceBase_;
        this->n_ = x.n_;
      }

      return *this;
    }

    FaceSetType::
    ~FaceSetType ()
    {
    }

    // ValidationFaceType
    //

    ValidationFaceType::
    ValidationFaceType ()
    : ::xml_schema::type (),
      Area_ (this),
      Centroid_ (this),
      Box_ (this),
      Points_ (this)
    {
    }

    ValidationFaceType::
    ValidationFaceType (const ValidationFaceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Area_ (x.Area_, f, this),
      Centroid_ (x.Centroid_, f, this),
      Box_ (x.Box_, f, this),
      Points_ (x.Points_, f, this)
    {
    }

    ValidationFaceType::
    ValidationFaceType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Area_ (this),
      Centroid_ (this),
      Box_ (this),
      Points_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ValidationFaceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Area
        //
        if (n.name () == L"Area" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Area_)
          {
            this->Area_.set (Area_traits::create (i, f, this));
            continue;
          }
        }

        // Centroid
        //
        if (n.name () == L"Centroid" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Centroid_type > r (
            Centroid_traits::create (i, f, this));

          if (!this->Centroid_)
          {
            this->Centroid_.set (::std::move (r));
            continue;
          }
        }

        // Box
        //
        if (n.name () == L"Box" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Box_type > r (
            Box_traits::create (i, f, this));

          if (!this->Box_)
          {
            this->Box_.set (::std::move (r));
            continue;
          }
        }

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ValidationFaceType* ValidationFaceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidationFaceType (*this, f, c);
    }

    ValidationFaceType& ValidationFaceType::
    operator= (const ValidationFaceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Area_ = x.Area_;
        this->Centroid_ = x.Centroid_;
        this->Box_ = x.Box_;
        this->Points_ = x.Points_;
      }

      return *this;
    }

    ValidationFaceType::
    ~ValidationFaceType ()
    {
    }

    // FaceBaseType
    //

    FaceBaseType::
    FaceBaseType ()
    : ::xsd::qif30::TopologyBaseType (),
      Validation_ (this),
      turned_ (turned_default_value (), this)
    {
    }

    FaceBaseType::
    FaceBaseType (const id_type& id)
    : ::xsd::qif30::TopologyBaseType (id),
      Validation_ (this),
      turned_ (turned_default_value (), this)
    {
    }

    FaceBaseType::
    FaceBaseType (const FaceBaseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (x, f, c),
      Validation_ (x.Validation_, f, this),
      turned_ (x.turned_, f, this)
    {
    }

    FaceBaseType::
    FaceBaseType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Validation_ (this),
      turned_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FaceBaseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Validation
        //
        if (n.name () == L"Validation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Validation_type > r (
            Validation_traits::create (i, f, this));

          if (!this->Validation_)
          {
            this->Validation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    FaceBaseType& FaceBaseType::
    operator= (const FaceBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TopologyBaseType& > (*this) = x;
        this->Validation_ = x.Validation_;
        this->turned_ = x.turned_;
      }

      return *this;
    }

    FaceBaseType::
    ~FaceBaseType ()
    {
    }

    // FaceType
    //

    FaceType::
    FaceType ()
    : ::xsd::qif30::FaceBaseType (),
      Surface_ (this),
      LoopIds_ (this),
      hasOuter_ (hasOuter_default_value (), this)
    {
    }

    FaceType::
    FaceType (const id_type& id,
              const Surface_type& Surface)
    : ::xsd::qif30::FaceBaseType (id),
      Surface_ (Surface, this),
      LoopIds_ (this),
      hasOuter_ (hasOuter_default_value (), this)
    {
    }

    FaceType::
    FaceType (const id_type& id,
              ::std::unique_ptr< Surface_type > Surface)
    : ::xsd::qif30::FaceBaseType (id),
      Surface_ (std::move (Surface), this),
      LoopIds_ (this),
      hasOuter_ (hasOuter_default_value (), this)
    {
    }

    FaceType::
    FaceType (const FaceType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::FaceBaseType (x, f, c),
      Surface_ (x.Surface_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      hasOuter_ (x.hasOuter_, f, this)
    {
    }

    FaceType::
    FaceType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::FaceBaseType (e, f | ::xml_schema::flags::base, c),
      Surface_ (this),
      LoopIds_ (this),
      hasOuter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FaceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Surface
        //
        if (n.name () == L"Surface" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Surface_type > r (
            Surface_traits::create (i, f, this));

          if (!Surface_.present ())
          {
            this->Surface_.set (::std::move (r));
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == L"LoopIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Surface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Surface",
          L"http://qifstandards.org/xsd/qif3");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"hasOuter" && n.namespace_ ().empty ())
        {
          this->hasOuter_.set (hasOuter_traits::create (i, f, this));
          continue;
        }
      }

      if (!hasOuter_.present ())
      {
        this->hasOuter_.set (hasOuter_default_value ());
      }
    }

    FaceType* FaceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceType (*this, f, c);
    }

    FaceType& FaceType::
    operator= (const FaceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FaceBaseType& > (*this) = x;
        this->Surface_ = x.Surface_;
        this->LoopIds_ = x.LoopIds_;
        this->hasOuter_ = x.hasOuter_;
      }

      return *this;
    }

    FaceType::
    ~FaceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FaceType >
    _xsd_FaceType_type_factory_init (
      L"FaceType",
      L"http://qifstandards.org/xsd/qif3");

    // FaceMeshType
    //

    FaceMeshType::
    FaceMeshType ()
    : ::xsd::qif30::FaceBaseType (),
      Mesh_ (this),
      LoopIds_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesVisible_ (this),
      TrianglesVisibleBinary_ (this),
      TrianglesHidden_ (this),
      TrianglesHiddenBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
    }

    FaceMeshType::
    FaceMeshType (const id_type& id,
                  const Mesh_type& Mesh)
    : ::xsd::qif30::FaceBaseType (id),
      Mesh_ (Mesh, this),
      LoopIds_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesVisible_ (this),
      TrianglesVisibleBinary_ (this),
      TrianglesHidden_ (this),
      TrianglesHiddenBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
    }

    FaceMeshType::
    FaceMeshType (const id_type& id,
                  ::std::unique_ptr< Mesh_type > Mesh)
    : ::xsd::qif30::FaceBaseType (id),
      Mesh_ (std::move (Mesh), this),
      LoopIds_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesVisible_ (this),
      TrianglesVisibleBinary_ (this),
      TrianglesHidden_ (this),
      TrianglesHiddenBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
    }

    FaceMeshType::
    FaceMeshType (const FaceMeshType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::FaceBaseType (x, f, c),
      Mesh_ (x.Mesh_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      Triangles_ (x.Triangles_, f, this),
      TrianglesBinary_ (x.TrianglesBinary_, f, this),
      TrianglesVisible_ (x.TrianglesVisible_, f, this),
      TrianglesVisibleBinary_ (x.TrianglesVisibleBinary_, f, this),
      TrianglesHidden_ (x.TrianglesHidden_, f, this),
      TrianglesHiddenBinary_ (x.TrianglesHiddenBinary_, f, this),
      TrianglesColor_ (x.TrianglesColor_, f, this),
      TrianglesColorBinary_ (x.TrianglesColorBinary_, f, this)
    {
    }

    FaceMeshType::
    FaceMeshType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif30::FaceBaseType (e, f | ::xml_schema::flags::base, c),
      Mesh_ (this),
      LoopIds_ (this),
      Triangles_ (this),
      TrianglesBinary_ (this),
      TrianglesVisible_ (this),
      TrianglesVisibleBinary_ (this),
      TrianglesHidden_ (this),
      TrianglesHiddenBinary_ (this),
      TrianglesColor_ (this),
      TrianglesColorBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FaceMeshType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::FaceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Mesh
        //
        if (n.name () == L"Mesh" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Mesh_type > r (
            Mesh_traits::create (i, f, this));

          if (!Mesh_.present ())
          {
            this->Mesh_.set (::std::move (r));
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == L"LoopIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (::std::move (r));
            continue;
          }
        }

        // Triangles
        //
        if (n.name () == L"Triangles" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Triangles_type > r (
            Triangles_traits::create (i, f, this));

          if (!this->Triangles_)
          {
            this->Triangles_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesBinary
        //
        if (n.name () == L"TrianglesBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesBinary_type > r (
            TrianglesBinary_traits::create (i, f, this));

          if (!this->TrianglesBinary_)
          {
            this->TrianglesBinary_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesVisible
        //
        if (n.name () == L"TrianglesVisible" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesVisible_type > r (
            TrianglesVisible_traits::create (i, f, this));

          if (!this->TrianglesVisible_)
          {
            this->TrianglesVisible_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesVisibleBinary
        //
        if (n.name () == L"TrianglesVisibleBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesVisibleBinary_type > r (
            TrianglesVisibleBinary_traits::create (i, f, this));

          if (!this->TrianglesVisibleBinary_)
          {
            this->TrianglesVisibleBinary_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesHidden
        //
        if (n.name () == L"TrianglesHidden" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesHidden_type > r (
            TrianglesHidden_traits::create (i, f, this));

          if (!this->TrianglesHidden_)
          {
            this->TrianglesHidden_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesHiddenBinary
        //
        if (n.name () == L"TrianglesHiddenBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesHiddenBinary_type > r (
            TrianglesHiddenBinary_traits::create (i, f, this));

          if (!this->TrianglesHiddenBinary_)
          {
            this->TrianglesHiddenBinary_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesColor
        //
        if (n.name () == L"TrianglesColor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesColor_type > r (
            TrianglesColor_traits::create (i, f, this));

          if (!this->TrianglesColor_)
          {
            this->TrianglesColor_.set (::std::move (r));
            continue;
          }
        }

        // TrianglesColorBinary
        //
        if (n.name () == L"TrianglesColorBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< TrianglesColorBinary_type > r (
            TrianglesColorBinary_traits::create (i, f, this));

          if (!this->TrianglesColorBinary_)
          {
            this->TrianglesColorBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Mesh_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Mesh",
          L"http://qifstandards.org/xsd/qif3");
      }
    }

    FaceMeshType* FaceMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceMeshType (*this, f, c);
    }

    FaceMeshType& FaceMeshType::
    operator= (const FaceMeshType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::FaceBaseType& > (*this) = x;
        this->Mesh_ = x.Mesh_;
        this->LoopIds_ = x.LoopIds_;
        this->Triangles_ = x.Triangles_;
        this->TrianglesBinary_ = x.TrianglesBinary_;
        this->TrianglesVisible_ = x.TrianglesVisible_;
        this->TrianglesVisibleBinary_ = x.TrianglesVisibleBinary_;
        this->TrianglesHidden_ = x.TrianglesHidden_;
        this->TrianglesHiddenBinary_ = x.TrianglesHiddenBinary_;
        this->TrianglesColor_ = x.TrianglesColor_;
        this->TrianglesColorBinary_ = x.TrianglesColorBinary_;
      }

      return *this;
    }

    FaceMeshType::
    ~FaceMeshType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, FaceMeshType >
    _xsd_FaceMeshType_type_factory_init (
      L"FaceMeshType",
      L"http://qifstandards.org/xsd/qif3");

    // ShellSetType
    //

    ShellSetType::
    ShellSetType ()
    : ::xml_schema::type (),
      Shell_ (this),
      n_ (this)
    {
    }

    ShellSetType::
    ShellSetType (const n_type& n)
    : ::xml_schema::type (),
      Shell_ (this),
      n_ (n, this)
    {
    }

    ShellSetType::
    ShellSetType (const ShellSetType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Shell_ (x.Shell_, f, this),
      n_ (x.n_, f, this)
    {
    }

    ShellSetType::
    ShellSetType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Shell_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ShellSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Shell
        //
        if (n.name () == L"Shell" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Shell_type > r (
            Shell_traits::create (i, f, this));

          this->Shell_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    ShellSetType* ShellSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellSetType (*this, f, c);
    }

    ShellSetType& ShellSetType::
    operator= (const ShellSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Shell_ = x.Shell_;
        this->n_ = x.n_;
      }

      return *this;
    }

    ShellSetType::
    ~ShellSetType ()
    {
    }

    // ShellFormEnumType
    //

    ShellFormEnumType::
    ShellFormEnumType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType::
    ShellFormEnumType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType* ShellFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellFormEnumType (*this, f, c);
    }

    ShellFormEnumType::value ShellFormEnumType::
    _xsd_ShellFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ShellFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ShellFormEnumType_indexes_,
                        _xsd_ShellFormEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ShellFormEnumType_indexes_ + 3 || _xsd_ShellFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ShellFormEnumType::
    _xsd_ShellFormEnumType_literals_[3] =
    {
      L"UNKNOWN",
      L"OUTER",
      L"INNER"
    };

    const ShellFormEnumType::value ShellFormEnumType::
    _xsd_ShellFormEnumType_indexes_[3] =
    {
      ::xsd::qif30::ShellFormEnumType::INNER,
      ::xsd::qif30::ShellFormEnumType::OUTER,
      ::xsd::qif30::ShellFormEnumType::UNKNOWN
    };

    // ShellType
    //

    const ShellType::form_type ShellType::form_default_value_ (
      L"UNKNOWN");

    ShellType::
    ShellType ()
    : ::xsd::qif30::TopologyBaseType (),
      FaceIds_ (this),
      turned_ (turned_default_value (), this),
      closed_ (closed_default_value (), this),
      form_ (form_default_value (), this)
    {
    }

    ShellType::
    ShellType (const id_type& id)
    : ::xsd::qif30::TopologyBaseType (id),
      FaceIds_ (this),
      turned_ (turned_default_value (), this),
      closed_ (closed_default_value (), this),
      form_ (form_default_value (), this)
    {
    }

    ShellType::
    ShellType (const ShellType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (x, f, c),
      FaceIds_ (x.FaceIds_, f, this),
      turned_ (x.turned_, f, this),
      closed_ (x.closed_, f, this),
      form_ (x.form_, f, this)
    {
    }

    ShellType::
    ShellType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      FaceIds_ (this),
      turned_ (this),
      closed_ (this),
      form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ShellType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // FaceIds
        //
        if (n.name () == L"FaceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FaceIds_type > r (
            FaceIds_traits::create (i, f, this));

          if (!this->FaceIds_)
          {
            this->FaceIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"closed" && n.namespace_ ().empty ())
        {
          this->closed_.set (closed_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }

      if (!closed_.present ())
      {
        this->closed_.set (closed_default_value ());
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    ShellType* ShellType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellType (*this, f, c);
    }

    ShellType& ShellType::
    operator= (const ShellType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TopologyBaseType& > (*this) = x;
        this->FaceIds_ = x.FaceIds_;
        this->turned_ = x.turned_;
        this->closed_ = x.closed_;
        this->form_ = x.form_;
      }

      return *this;
    }

    ShellType::
    ~ShellType ()
    {
    }

    // BodySetType
    //

    BodySetType::
    BodySetType ()
    : ::xml_schema::type (),
      Body_ (this),
      n_ (this)
    {
    }

    BodySetType::
    BodySetType (const n_type& n)
    : ::xml_schema::type (),
      Body_ (this),
      n_ (n, this)
    {
    }

    BodySetType::
    BodySetType (const BodySetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Body_ (x.Body_, f, this),
      n_ (x.n_, f, this)
    {
    }

    BodySetType::
    BodySetType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Body_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BodySetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Body
        //
        if (n.name () == L"Body" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Body_type > r (
            Body_traits::create (i, f, this));

          this->Body_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    BodySetType* BodySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BodySetType (*this, f, c);
    }

    BodySetType& BodySetType::
    operator= (const BodySetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Body_ = x.Body_;
        this->n_ = x.n_;
      }

      return *this;
    }

    BodySetType::
    ~BodySetType ()
    {
    }

    // ValidationBodyType
    //

    ValidationBodyType::
    ValidationBodyType ()
    : ::xml_schema::type (),
      Area_ (this),
      Centroid_ (this),
      Volume_ (this),
      Box_ (this),
      FacePoints_ (this),
      EdgePoints_ (this)
    {
    }

    ValidationBodyType::
    ValidationBodyType (const ValidationBodyType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Area_ (x.Area_, f, this),
      Centroid_ (x.Centroid_, f, this),
      Volume_ (x.Volume_, f, this),
      Box_ (x.Box_, f, this),
      FacePoints_ (x.FacePoints_, f, this),
      EdgePoints_ (x.EdgePoints_, f, this)
    {
    }

    ValidationBodyType::
    ValidationBodyType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Area_ (this),
      Centroid_ (this),
      Volume_ (this),
      Box_ (this),
      FacePoints_ (this),
      EdgePoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ValidationBodyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Area
        //
        if (n.name () == L"Area" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Area_)
          {
            this->Area_.set (Area_traits::create (i, f, this));
            continue;
          }
        }

        // Centroid
        //
        if (n.name () == L"Centroid" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Centroid_type > r (
            Centroid_traits::create (i, f, this));

          if (!this->Centroid_)
          {
            this->Centroid_.set (::std::move (r));
            continue;
          }
        }

        // Volume
        //
        if (n.name () == L"Volume" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          if (!this->Volume_)
          {
            this->Volume_.set (Volume_traits::create (i, f, this));
            continue;
          }
        }

        // Box
        //
        if (n.name () == L"Box" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Box_type > r (
            Box_traits::create (i, f, this));

          if (!this->Box_)
          {
            this->Box_.set (::std::move (r));
            continue;
          }
        }

        // FacePoints
        //
        if (n.name () == L"FacePoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FacePoints_type > r (
            FacePoints_traits::create (i, f, this));

          if (!this->FacePoints_)
          {
            this->FacePoints_.set (::std::move (r));
            continue;
          }
        }

        // EdgePoints
        //
        if (n.name () == L"EdgePoints" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgePoints_type > r (
            EdgePoints_traits::create (i, f, this));

          if (!this->EdgePoints_)
          {
            this->EdgePoints_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ValidationBodyType* ValidationBodyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidationBodyType (*this, f, c);
    }

    ValidationBodyType& ValidationBodyType::
    operator= (const ValidationBodyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Area_ = x.Area_;
        this->Centroid_ = x.Centroid_;
        this->Volume_ = x.Volume_;
        this->Box_ = x.Box_;
        this->FacePoints_ = x.FacePoints_;
        this->EdgePoints_ = x.EdgePoints_;
      }

      return *this;
    }

    ValidationBodyType::
    ~ValidationBodyType ()
    {
    }

    // BodyType
    //

    const BodyType::form_type BodyType::form_default_value_ (
      L"UNDEFINED");

    BodyType::
    BodyType ()
    : ::xsd::qif30::TopologyBaseType (),
      Validation_ (this),
      Transform_ (this),
      ShellIds_ (this),
      FaceIds_ (this),
      LoopIds_ (this),
      EdgeIds_ (this),
      VertexIds_ (this),
      form_ (form_default_value (), this),
      materialIndex_ (this)
    {
    }

    BodyType::
    BodyType (const id_type& id)
    : ::xsd::qif30::TopologyBaseType (id),
      Validation_ (this),
      Transform_ (this),
      ShellIds_ (this),
      FaceIds_ (this),
      LoopIds_ (this),
      EdgeIds_ (this),
      VertexIds_ (this),
      form_ (form_default_value (), this),
      materialIndex_ (this)
    {
    }

    BodyType::
    BodyType (const BodyType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (x, f, c),
      Validation_ (x.Validation_, f, this),
      Transform_ (x.Transform_, f, this),
      ShellIds_ (x.ShellIds_, f, this),
      FaceIds_ (x.FaceIds_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      EdgeIds_ (x.EdgeIds_, f, this),
      VertexIds_ (x.VertexIds_, f, this),
      form_ (x.form_, f, this),
      materialIndex_ (x.materialIndex_, f, this)
    {
    }

    BodyType::
    BodyType (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Validation_ (this),
      Transform_ (this),
      ShellIds_ (this),
      FaceIds_ (this),
      LoopIds_ (this),
      EdgeIds_ (this),
      VertexIds_ (this),
      form_ (this),
      materialIndex_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BodyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Validation
        //
        if (n.name () == L"Validation" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Validation_type > r (
            Validation_traits::create (i, f, this));

          if (!this->Validation_)
          {
            this->Validation_.set (::std::move (r));
            continue;
          }
        }

        // Transform
        //
        if (n.name () == L"Transform" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (::std::move (r));
            continue;
          }
        }

        // ShellIds
        //
        if (n.name () == L"ShellIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< ShellIds_type > r (
            ShellIds_traits::create (i, f, this));

          if (!this->ShellIds_)
          {
            this->ShellIds_.set (::std::move (r));
            continue;
          }
        }

        // FaceIds
        //
        if (n.name () == L"FaceIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< FaceIds_type > r (
            FaceIds_traits::create (i, f, this));

          if (!this->FaceIds_)
          {
            this->FaceIds_.set (::std::move (r));
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == L"LoopIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (::std::move (r));
            continue;
          }
        }

        // EdgeIds
        //
        if (n.name () == L"EdgeIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< EdgeIds_type > r (
            EdgeIds_traits::create (i, f, this));

          if (!this->EdgeIds_)
          {
            this->EdgeIds_.set (::std::move (r));
            continue;
          }
        }

        // VertexIds
        //
        if (n.name () == L"VertexIds" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< VertexIds_type > r (
            VertexIds_traits::create (i, f, this));

          if (!this->VertexIds_)
          {
            this->VertexIds_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"form" && n.namespace_ ().empty ())
        {
          this->form_.set (form_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"materialIndex" && n.namespace_ ().empty ())
        {
          this->materialIndex_.set (materialIndex_traits::create (i, f, this));
          continue;
        }
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    BodyType* BodyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BodyType (*this, f, c);
    }

    BodyType& BodyType::
    operator= (const BodyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TopologyBaseType& > (*this) = x;
        this->Validation_ = x.Validation_;
        this->Transform_ = x.Transform_;
        this->ShellIds_ = x.ShellIds_;
        this->FaceIds_ = x.FaceIds_;
        this->LoopIds_ = x.LoopIds_;
        this->EdgeIds_ = x.EdgeIds_;
        this->VertexIds_ = x.VertexIds_;
        this->form_ = x.form_;
        this->materialIndex_ = x.materialIndex_;
      }

      return *this;
    }

    BodyType::
    ~BodyType ()
    {
    }

    // BodyFormEnumType
    //

    BodyFormEnumType::
    BodyFormEnumType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_BodyFormEnumType_convert ();
    }

    BodyFormEnumType::
    BodyFormEnumType (const xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_BodyFormEnumType_convert ();
    }

    BodyFormEnumType::
    BodyFormEnumType (const ::std::wstring& s,
                      const xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_BodyFormEnumType_convert ();
    }

    BodyFormEnumType* BodyFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BodyFormEnumType (*this, f, c);
    }

    BodyFormEnumType::value BodyFormEnumType::
    _xsd_BodyFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_BodyFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_BodyFormEnumType_indexes_,
                        _xsd_BodyFormEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_BodyFormEnumType_indexes_ + 6 || _xsd_BodyFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const BodyFormEnumType::
    _xsd_BodyFormEnumType_literals_[6] =
    {
      L"UNDEFINED",
      L"TRIMMED_SURFACE",
      L"WIRE",
      L"SOLID",
      L"SHEET",
      L"MIXED"
    };

    const BodyFormEnumType::value BodyFormEnumType::
    _xsd_BodyFormEnumType_indexes_[6] =
    {
      ::xsd::qif30::BodyFormEnumType::MIXED,
      ::xsd::qif30::BodyFormEnumType::SHEET,
      ::xsd::qif30::BodyFormEnumType::SOLID,
      ::xsd::qif30::BodyFormEnumType::TRIMMED_SURFACE,
      ::xsd::qif30::BodyFormEnumType::UNDEFINED,
      ::xsd::qif30::BodyFormEnumType::WIRE
    };

    // PointCloudSetType
    //

    PointCloudSetType::
    PointCloudSetType ()
    : ::xml_schema::type (),
      PointCloud_ (this),
      n_ (this)
    {
    }

    PointCloudSetType::
    PointCloudSetType (const n_type& n)
    : ::xml_schema::type (),
      PointCloud_ (this),
      n_ (n, this)
    {
    }

    PointCloudSetType::
    PointCloudSetType (const PointCloudSetType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointCloud_ (x.PointCloud_, f, this),
      n_ (x.n_, f, this)
    {
    }

    PointCloudSetType::
    PointCloudSetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointCloud_ (this),
      n_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointCloudSetType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // PointCloud
        //
        if (n.name () == L"PointCloud" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointCloud_type > r (
            PointCloud_traits::create (i, f, this));

          this->PointCloud_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"n" && n.namespace_ ().empty ())
        {
          this->n_.set (n_traits::create (i, f, this));
          continue;
        }
      }

      if (!n_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"n",
          L"");
      }
    }

    PointCloudSetType* PointCloudSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCloudSetType (*this, f, c);
    }

    PointCloudSetType& PointCloudSetType::
    operator= (const PointCloudSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointCloud_ = x.PointCloud_;
        this->n_ = x.n_;
      }

      return *this;
    }

    PointCloudSetType::
    ~PointCloudSetType ()
    {
    }

    // PointCloudType
    //

    PointCloudType::
    PointCloudType ()
    : ::xsd::qif30::TopologyBaseType (),
      Points_ (this),
      PointsBinary_ (this),
      Normals_ (this),
      NormalsBinary_ (this),
      PointsVisible_ (this),
      PointsVisibleBinary_ (this),
      PointsHidden_ (this),
      PointsHiddenBinary_ (this),
      PointsColor_ (this),
      PointsColorBinary_ (this)
    {
    }

    PointCloudType::
    PointCloudType (const id_type& id)
    : ::xsd::qif30::TopologyBaseType (id),
      Points_ (this),
      PointsBinary_ (this),
      Normals_ (this),
      NormalsBinary_ (this),
      PointsVisible_ (this),
      PointsVisibleBinary_ (this),
      PointsHidden_ (this),
      PointsHiddenBinary_ (this),
      PointsColor_ (this),
      PointsColorBinary_ (this)
    {
    }

    PointCloudType::
    PointCloudType (const PointCloudType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (x, f, c),
      Points_ (x.Points_, f, this),
      PointsBinary_ (x.PointsBinary_, f, this),
      Normals_ (x.Normals_, f, this),
      NormalsBinary_ (x.NormalsBinary_, f, this),
      PointsVisible_ (x.PointsVisible_, f, this),
      PointsVisibleBinary_ (x.PointsVisibleBinary_, f, this),
      PointsHidden_ (x.PointsHidden_, f, this),
      PointsHiddenBinary_ (x.PointsHiddenBinary_, f, this),
      PointsColor_ (x.PointsColor_, f, this),
      PointsColorBinary_ (x.PointsColorBinary_, f, this)
    {
    }

    PointCloudType::
    PointCloudType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif30::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Points_ (this),
      PointsBinary_ (this),
      Normals_ (this),
      NormalsBinary_ (this),
      PointsVisible_ (this),
      PointsVisibleBinary_ (this),
      PointsHidden_ (this),
      PointsHiddenBinary_ (this),
      PointsColor_ (this),
      PointsColorBinary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointCloudType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif30::TopologyBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Points
        //
        if (n.name () == L"Points" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (::std::move (r));
            continue;
          }
        }

        // PointsBinary
        //
        if (n.name () == L"PointsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsBinary_type > r (
            PointsBinary_traits::create (i, f, this));

          if (!this->PointsBinary_)
          {
            this->PointsBinary_.set (::std::move (r));
            continue;
          }
        }

        // Normals
        //
        if (n.name () == L"Normals" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< Normals_type > r (
            Normals_traits::create (i, f, this));

          if (!this->Normals_)
          {
            this->Normals_.set (::std::move (r));
            continue;
          }
        }

        // NormalsBinary
        //
        if (n.name () == L"NormalsBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< NormalsBinary_type > r (
            NormalsBinary_traits::create (i, f, this));

          if (!this->NormalsBinary_)
          {
            this->NormalsBinary_.set (::std::move (r));
            continue;
          }
        }

        // PointsVisible
        //
        if (n.name () == L"PointsVisible" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsVisible_type > r (
            PointsVisible_traits::create (i, f, this));

          if (!this->PointsVisible_)
          {
            this->PointsVisible_.set (::std::move (r));
            continue;
          }
        }

        // PointsVisibleBinary
        //
        if (n.name () == L"PointsVisibleBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsVisibleBinary_type > r (
            PointsVisibleBinary_traits::create (i, f, this));

          if (!this->PointsVisibleBinary_)
          {
            this->PointsVisibleBinary_.set (::std::move (r));
            continue;
          }
        }

        // PointsHidden
        //
        if (n.name () == L"PointsHidden" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsHidden_type > r (
            PointsHidden_traits::create (i, f, this));

          if (!this->PointsHidden_)
          {
            this->PointsHidden_.set (::std::move (r));
            continue;
          }
        }

        // PointsHiddenBinary
        //
        if (n.name () == L"PointsHiddenBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsHiddenBinary_type > r (
            PointsHiddenBinary_traits::create (i, f, this));

          if (!this->PointsHiddenBinary_)
          {
            this->PointsHiddenBinary_.set (::std::move (r));
            continue;
          }
        }

        // PointsColor
        //
        if (n.name () == L"PointsColor" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsColor_type > r (
            PointsColor_traits::create (i, f, this));

          if (!this->PointsColor_)
          {
            this->PointsColor_.set (::std::move (r));
            continue;
          }
        }

        // PointsColorBinary
        //
        if (n.name () == L"PointsColorBinary" && n.namespace_ () == L"http://qifstandards.org/xsd/qif3")
        {
          ::std::unique_ptr< PointsColorBinary_type > r (
            PointsColorBinary_traits::create (i, f, this));

          if (!this->PointsColorBinary_)
          {
            this->PointsColorBinary_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PointCloudType* PointCloudType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCloudType (*this, f, c);
    }

    PointCloudType& PointCloudType::
    operator= (const PointCloudType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif30::TopologyBaseType& > (*this) = x;
        this->Points_ = x.Points_;
        this->PointsBinary_ = x.PointsBinary_;
        this->Normals_ = x.Normals_;
        this->NormalsBinary_ = x.NormalsBinary_;
        this->PointsVisible_ = x.PointsVisible_;
        this->PointsVisibleBinary_ = x.PointsVisibleBinary_;
        this->PointsHidden_ = x.PointsHidden_;
        this->PointsHiddenBinary_ = x.PointsHiddenBinary_;
        this->PointsColor_ = x.PointsColor_;
        this->PointsColorBinary_ = x.PointsColorBinary_;
      }

      return *this;
    }

    PointCloudType::
    ~PointCloudType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Loop_element_factory_init (
      L"LoopBase",
      L"http://qifstandards.org/xsd/qif3",
      L"Loop",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LoopType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_LoopMesh_element_factory_init (
      L"LoopBase",
      L"http://qifstandards.org/xsd/qif3",
      L"LoopMesh",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::LoopMeshType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_Face_element_factory_init (
      L"FaceBase",
      L"http://qifstandards.org/xsd/qif3",
      L"Face",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FaceType >);


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, wchar_t >
    _xsd_FaceMesh_element_factory_init (
      L"FaceBase",
      L"http://qifstandards.org/xsd/qif3",
      L"FaceMesh",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::factory_impl< ::xsd::qif30::FaceMeshType >);
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif30
  {
    void
    operator<< (xercesc::DOMElement& e, const TopologySetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // VertexSet
      //
      if (i.VertexSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VertexSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VertexSet ();
      }

      // EdgeSet
      //
      if (i.EdgeSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgeSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EdgeSet ();
      }

      // LoopSet
      //
      if (i.LoopSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LoopSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LoopSet ();
      }

      // FaceSet
      //
      if (i.FaceSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FaceSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FaceSet ();
      }

      // ShellSet
      //
      if (i.ShellSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShellSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ShellSet ();
      }

      // BodySet
      //
      if (i.BodySet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"BodySet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.BodySet ();
      }

      // PointCloudSet
      //
      if (i.PointCloudSet ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointCloudSet",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointCloudSet ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const TopologyBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::DrawableBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const VertexSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Vertex
      //
      for (VertexSetType::Vertex_const_iterator
           b (i.Vertex ().begin ()), n (i.Vertex ().end ());
           b != n; ++b)
      {
        const VertexSetType::Vertex_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Vertex",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const VertexType& i)
    {
      e << static_cast< const ::xsd::qif30::TopologyBaseType& > (i);

      // Point
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Point",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Point ();
      }

      // tolerance
      //
      if (i.tolerance ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"tolerance",
            e));

        a << ::xml_schema::as_double(*i.tolerance ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgeSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Edge
      //
      for (EdgeSetType::Edge_const_iterator
           b (i.Edge ().begin ()), n (i.Edge ().end ());
           b != n; ++b)
      {
        const EdgeSetType::Edge_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Edge",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ValidationEdgeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Length
      //
      if (i.Length ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Length",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.Length ());
      }

      // Centroid
      //
      if (i.Centroid ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Centroid",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Centroid ();
      }

      // Box
      //
      if (i.Box ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Box",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Box ();
      }

      // Points
      //
      if (i.Points ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Points ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const EdgeType& i)
    {
      e << static_cast< const ::xsd::qif30::TopologyBaseType& > (i);

      // Validation
      //
      if (i.Validation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Validation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Validation ();
      }

      // Curve
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Curve",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Curve ();
      }

      // VertexBeg
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VertexBeg",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.VertexBeg ();
      }

      // VertexEnd
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VertexEnd",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.VertexEnd ();
      }

      // tolerance
      //
      if (i.tolerance ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"tolerance",
            e));

        a << ::xml_schema::as_double(*i.tolerance ());
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LoopSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LoopBase
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (LoopSetType::LoopBase_const_iterator
             b (i.LoopBase ().begin ()), n (i.LoopBase ().end ());
             b != n; ++b)
        {
          const LoopSetType::LoopBase_type& x (*b);

          if (typeid (LoopSetType::LoopBase_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"LoopBase",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"LoopBase",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LoopBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::TopologyBaseType& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const LoopFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const LoopFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LoopFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const CoEdgeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EdgeOriented
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgeOriented",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EdgeOriented ();
      }

      // Curve12
      //
      if (i.Curve12 ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Curve12",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Curve12 ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoEdgesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoEdge
      //
      for (CoEdgesType::CoEdge_const_iterator
           b (i.CoEdge ().begin ()), n (i.CoEdge ().end ());
           b != n; ++b)
      {
        const CoEdgesType::CoEdge_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoEdge",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoEdgeMeshType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EdgeOriented
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgeOriented",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.EdgeOriented ();
      }

      // CurveMesh
      //
      if (i.CurveMesh ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CurveMesh",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.CurveMesh ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const CoEdgesMeshType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoEdgeMesh
      //
      for (CoEdgesMeshType::CoEdgeMesh_const_iterator
           b (i.CoEdgeMesh ().begin ()), n (i.CoEdgeMesh ().end ());
           b != n; ++b)
      {
        const CoEdgesMeshType::CoEdgeMesh_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoEdgeMesh",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const LoopType& i)
    {
      e << static_cast< const ::xsd::qif30::LoopBaseType& > (i);

      // CoEdges
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoEdges",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CoEdges ();
      }

      // form
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"form",
            e));

        a << i.form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LoopType >
    _xsd_LoopType_type_serializer_init (
      L"LoopType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const LoopMeshType& i)
    {
      e << static_cast< const ::xsd::qif30::LoopBaseType& > (i);

      // CoEdgesMesh
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"CoEdgesMesh",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.CoEdgesMesh ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LoopMeshType >
    _xsd_LoopMeshType_type_serializer_init (
      L"LoopMeshType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FaceSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FaceBase
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (FaceSetType::FaceBase_const_iterator
             b (i.FaceBase ().begin ()), n (i.FaceBase ().end ());
             b != n; ++b)
        {
          const FaceSetType::FaceBase_type& x (*b);

          if (typeid (FaceSetType::FaceBase_type) == typeid (x))
          {
            xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"FaceBase",
                L"http://qifstandards.org/xsd/qif3",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"FaceBase",
              L"http://qifstandards.org/xsd/qif3",
              true, true, e, x);
        }
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ValidationFaceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Area
      //
      if (i.Area ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Area",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.Area ());
      }

      // Centroid
      //
      if (i.Centroid ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Centroid",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Centroid ();
      }

      // Box
      //
      if (i.Box ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Box",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Box ();
      }

      // Points
      //
      if (i.Points ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Points ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FaceBaseType& i)
    {
      e << static_cast< const ::xsd::qif30::TopologyBaseType& > (i);

      // Validation
      //
      if (i.Validation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Validation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Validation ();
      }

      // turned
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turned",
            e));

        a << i.turned ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const FaceType& i)
    {
      e << static_cast< const ::xsd::qif30::FaceBaseType& > (i);

      // Surface
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Surface",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Surface ();
      }

      // LoopIds
      //
      if (i.LoopIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LoopIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LoopIds ();
      }

      // hasOuter
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"hasOuter",
            e));

        a << i.hasOuter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FaceType >
    _xsd_FaceType_type_serializer_init (
      L"FaceType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const FaceMeshType& i)
    {
      e << static_cast< const ::xsd::qif30::FaceBaseType& > (i);

      // Mesh
      //
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Mesh",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << i.Mesh ();
      }

      // LoopIds
      //
      if (i.LoopIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LoopIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LoopIds ();
      }

      // Triangles
      //
      if (i.Triangles ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Triangles",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Triangles ();
      }

      // TrianglesBinary
      //
      if (i.TrianglesBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesBinary ();
      }

      // TrianglesVisible
      //
      if (i.TrianglesVisible ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesVisible",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesVisible ();
      }

      // TrianglesVisibleBinary
      //
      if (i.TrianglesVisibleBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesVisibleBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesVisibleBinary ();
      }

      // TrianglesHidden
      //
      if (i.TrianglesHidden ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesHidden",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesHidden ();
      }

      // TrianglesHiddenBinary
      //
      if (i.TrianglesHiddenBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesHiddenBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesHiddenBinary ();
      }

      // TrianglesColor
      //
      if (i.TrianglesColor ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesColor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesColor ();
      }

      // TrianglesColorBinary
      //
      if (i.TrianglesColorBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"TrianglesColorBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.TrianglesColorBinary ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, FaceMeshType >
    _xsd_FaceMeshType_type_serializer_init (
      L"FaceMeshType",
      L"http://qifstandards.org/xsd/qif3");


    void
    operator<< (xercesc::DOMElement& e, const ShellSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Shell
      //
      for (ShellSetType::Shell_const_iterator
           b (i.Shell ().begin ()), n (i.Shell ().end ());
           b != n; ++b)
      {
        const ShellSetType::Shell_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Shell",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ShellFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const ShellFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ShellFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const ShellType& i)
    {
      e << static_cast< const ::xsd::qif30::TopologyBaseType& > (i);

      // FaceIds
      //
      if (i.FaceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FaceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FaceIds ();
      }

      // turned
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"turned",
            e));

        a << i.turned ();
      }

      // closed
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"closed",
            e));

        a << i.closed ();
      }

      // form
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"form",
            e));

        a << i.form ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BodySetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Body
      //
      for (BodySetType::Body_const_iterator
           b (i.Body ().begin ()), n (i.Body ().end ());
           b != n; ++b)
      {
        const BodySetType::Body_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Body",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const ValidationBodyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Area
      //
      if (i.Area ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Area",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.Area ());
      }

      // Centroid
      //
      if (i.Centroid ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Centroid",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Centroid ();
      }

      // Volume
      //
      if (i.Volume ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Volume",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << ::xml_schema::as_double(*i.Volume ());
      }

      // Box
      //
      if (i.Box ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Box",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Box ();
      }

      // FacePoints
      //
      if (i.FacePoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FacePoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FacePoints ();
      }

      // EdgePoints
      //
      if (i.EdgePoints ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgePoints",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EdgePoints ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BodyType& i)
    {
      e << static_cast< const ::xsd::qif30::TopologyBaseType& > (i);

      // Validation
      //
      if (i.Validation ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Validation",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Validation ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Transform",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Transform ();
      }

      // ShellIds
      //
      if (i.ShellIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ShellIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.ShellIds ();
      }

      // FaceIds
      //
      if (i.FaceIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"FaceIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.FaceIds ();
      }

      // LoopIds
      //
      if (i.LoopIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"LoopIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.LoopIds ();
      }

      // EdgeIds
      //
      if (i.EdgeIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"EdgeIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.EdgeIds ();
      }

      // VertexIds
      //
      if (i.VertexIds ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"VertexIds",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.VertexIds ();
      }

      // form
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"form",
            e));

        a << i.form ();
      }

      // materialIndex
      //
      if (i.materialIndex ())
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"materialIndex",
            e));

        a << *i.materialIndex ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const BodyFormEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMAttr& a, const BodyFormEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const BodyFormEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (xercesc::DOMElement& e, const PointCloudSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointCloud
      //
      for (PointCloudSetType::PointCloud_const_iterator
           b (i.PointCloud ().begin ()), n (i.PointCloud ().end ());
           b != n; ++b)
      {
        const PointCloudSetType::PointCloud_type& x (*b);

        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointCloud",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << x;
      }

      // n
      //
      {
        xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"n",
            e));

        a << i.n ();
      }
    }

    void
    operator<< (xercesc::DOMElement& e, const PointCloudType& i)
    {
      e << static_cast< const ::xsd::qif30::TopologyBaseType& > (i);

      // Points
      //
      if (i.Points ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Points",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Points ();
      }

      // PointsBinary
      //
      if (i.PointsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsBinary ();
      }

      // Normals
      //
      if (i.Normals ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"Normals",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.Normals ();
      }

      // NormalsBinary
      //
      if (i.NormalsBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"NormalsBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.NormalsBinary ();
      }

      // PointsVisible
      //
      if (i.PointsVisible ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsVisible",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsVisible ();
      }

      // PointsVisibleBinary
      //
      if (i.PointsVisibleBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsVisibleBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsVisibleBinary ();
      }

      // PointsHidden
      //
      if (i.PointsHidden ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsHidden",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsHidden ();
      }

      // PointsHiddenBinary
      //
      if (i.PointsHiddenBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsHiddenBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsHiddenBinary ();
      }

      // PointsColor
      //
      if (i.PointsColor ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsColor",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsColor ();
      }

      // PointsColorBinary
      //
      if (i.PointsColorBinary ())
      {
        xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"PointsColorBinary",
            L"http://qifstandards.org/xsd/qif3",
            e));

        s << *i.PointsColorBinary ();
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LoopType >
    _xsd_Loop_element_serializer_init (
      L"LoopBase",
      L"http://qifstandards.org/xsd/qif3",
      L"Loop",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LoopType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::LoopMeshType >
    _xsd_LoopMesh_element_serializer_init (
      L"LoopBase",
      L"http://qifstandards.org/xsd/qif3",
      L"LoopMesh",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::LoopMeshType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FaceType >
    _xsd_Face_element_serializer_init (
      L"FaceBase",
      L"http://qifstandards.org/xsd/qif3",
      L"Face",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FaceType >);


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, wchar_t, ::xsd::qif30::FaceMeshType >
    _xsd_FaceMesh_element_serializer_init (
      L"FaceBase",
      L"http://qifstandards.org/xsd/qif3",
      L"FaceMesh",
      L"http://qifstandards.org/xsd/qif3",
      &::xsd::cxx::tree::serializer_impl< ::xsd::qif30::FaceMeshType >);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

