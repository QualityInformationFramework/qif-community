// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_GEOMETRY_HXX
#define CXX___QIFLIBRARY_GEOMETRY_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class GeometrySetType;
    class GeometryBaseType;
    class PointSetType;
    class PointEntityType;
    class Curve12SetType;
    class Curve13SetType;
    class Curve13CoreType;
    class CurveCoreBaseType;
    class Curve12BaseType;
    class Curve13BaseType;
    class Segment13CoreType;
    class Segment12CoreType;
    class Segment13Type;
    class Segment12Type;
    class ArcConicFormEnumType;
    class ArcConic13CoreType;
    class ArcConic12CoreType;
    class ArcConic12Type;
    class ArcConic13Type;
    class ArcCircular13CoreType;
    class ArcCircular12CoreType;
    class ArcCircular13Type;
    class ArcCircular12Type;
    class Nurbs12CoreType;
    class Nurbs13CoreType;
    class Nurbs12Type;
    class Nurbs13Type;
    class Spline13CoreType;
    class Spline12CoreType;
    class Spline13Type;
    class Spline12Type;
    class Curve12OrientedType;
    class ArraySubCurve12Type;
    class Aggregate12CoreType;
    class Curve13OrientedType;
    class ArraySubCurve13Type;
    class Aggregate13CoreType;
    class Aggregate12Type;
    class Aggregate13Type;
    class Polyline13CoreType;
    class Polyline12CoreType;
    class Polyline13Type;
    class Polyline12Type;
    class SurfaceBaseType;
    class SurfaceSetType;
    class SurfaceCoreType;
    class SurfaceCoreBaseType;
    class Attr23CoreEnumType;
    class Nurbs23CoreType;
    class Nurbs23Type;
    class Spline23CoreType;
    class Spline23Type;
    class Revolution23CoreType;
    class Revolution23Type;
    class Extrude23CoreType;
    class Extrude23Type;
    class Ruled23CoreType;
    class Ruled23Type;
    class Offset23CoreType;
    class Offset23Type;
    class Plane23CoreType;
    class Plane23Type;
    class Cone23CoreType;
    class Cone23Type;
    class Cylinder23CoreType;
    class Cylinder23Type;
    class Sphere23CoreType;
    class Sphere23Type;
    class Torus23CoreType;
    class Torus23Type;
    class CurveMeshSetType;
    class PathTriangulationCoreType;
    class PathTriangulationType;
    class SurfaceMeshSetType;
    class MeshTriangleCoreType;
    class TriangleVertexNormalType;
    class ArrayTriangleVertexNormalType;
    class MeshTriangleType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/PrimitivesPD.hxx"

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL GeometrySetType: public ::xml_schema::type
    {
      public:
      // PointSet
      //
      typedef ::xsd::qif30::PointSetType PointSet_type;
      typedef ::xsd::cxx::tree::optional< PointSet_type > PointSet_optional;
      typedef ::xsd::cxx::tree::traits< PointSet_type, wchar_t > PointSet_traits;

      const PointSet_optional&
      PointSet () const;

      PointSet_optional&
      PointSet ();

      void
      PointSet (const PointSet_type& x);

      void
      PointSet (const PointSet_optional& x);

      void
      PointSet (::std::unique_ptr< PointSet_type > p);

      // Curve12Set
      //
      typedef ::xsd::qif30::Curve12SetType Curve12Set_type;
      typedef ::xsd::cxx::tree::optional< Curve12Set_type > Curve12Set_optional;
      typedef ::xsd::cxx::tree::traits< Curve12Set_type, wchar_t > Curve12Set_traits;

      const Curve12Set_optional&
      Curve12Set () const;

      Curve12Set_optional&
      Curve12Set ();

      void
      Curve12Set (const Curve12Set_type& x);

      void
      Curve12Set (const Curve12Set_optional& x);

      void
      Curve12Set (::std::unique_ptr< Curve12Set_type > p);

      // Curve13Set
      //
      typedef ::xsd::qif30::Curve13SetType Curve13Set_type;
      typedef ::xsd::cxx::tree::optional< Curve13Set_type > Curve13Set_optional;
      typedef ::xsd::cxx::tree::traits< Curve13Set_type, wchar_t > Curve13Set_traits;

      const Curve13Set_optional&
      Curve13Set () const;

      Curve13Set_optional&
      Curve13Set ();

      void
      Curve13Set (const Curve13Set_type& x);

      void
      Curve13Set (const Curve13Set_optional& x);

      void
      Curve13Set (::std::unique_ptr< Curve13Set_type > p);

      // SurfaceSet
      //
      typedef ::xsd::qif30::SurfaceSetType SurfaceSet_type;
      typedef ::xsd::cxx::tree::optional< SurfaceSet_type > SurfaceSet_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceSet_type, wchar_t > SurfaceSet_traits;

      const SurfaceSet_optional&
      SurfaceSet () const;

      SurfaceSet_optional&
      SurfaceSet ();

      void
      SurfaceSet (const SurfaceSet_type& x);

      void
      SurfaceSet (const SurfaceSet_optional& x);

      void
      SurfaceSet (::std::unique_ptr< SurfaceSet_type > p);

      // CurveMeshSet
      //
      typedef ::xsd::qif30::CurveMeshSetType CurveMeshSet_type;
      typedef ::xsd::cxx::tree::optional< CurveMeshSet_type > CurveMeshSet_optional;
      typedef ::xsd::cxx::tree::traits< CurveMeshSet_type, wchar_t > CurveMeshSet_traits;

      const CurveMeshSet_optional&
      CurveMeshSet () const;

      CurveMeshSet_optional&
      CurveMeshSet ();

      void
      CurveMeshSet (const CurveMeshSet_type& x);

      void
      CurveMeshSet (const CurveMeshSet_optional& x);

      void
      CurveMeshSet (::std::unique_ptr< CurveMeshSet_type > p);

      // SurfaceMeshSet
      //
      typedef ::xsd::qif30::SurfaceMeshSetType SurfaceMeshSet_type;
      typedef ::xsd::cxx::tree::optional< SurfaceMeshSet_type > SurfaceMeshSet_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceMeshSet_type, wchar_t > SurfaceMeshSet_traits;

      const SurfaceMeshSet_optional&
      SurfaceMeshSet () const;

      SurfaceMeshSet_optional&
      SurfaceMeshSet ();

      void
      SurfaceMeshSet (const SurfaceMeshSet_type& x);

      void
      SurfaceMeshSet (const SurfaceMeshSet_optional& x);

      void
      SurfaceMeshSet (::std::unique_ptr< SurfaceMeshSet_type > p);

      // Constructors.
      //
      GeometrySetType ();

      GeometrySetType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      GeometrySetType (const GeometrySetType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual GeometrySetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GeometrySetType&
      operator= (const GeometrySetType& x);

      virtual 
      ~GeometrySetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PointSet_optional PointSet_;
      Curve12Set_optional Curve12Set_;
      Curve13Set_optional Curve13Set_;
      SurfaceSet_optional SurfaceSet_;
      CurveMeshSet_optional CurveMeshSet_;
      SurfaceMeshSet_optional SurfaceMeshSet_;
    };

    class QIF30_SYMBOL_DECL GeometryBaseType: public ::xsd::qif30::NodeWithIdBaseType
    {
      public:
      // Constructors.
      //
      GeometryBaseType ();

      GeometryBaseType (const id_type&);

      GeometryBaseType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      GeometryBaseType (const GeometryBaseType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual GeometryBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      GeometryBaseType&
      operator= (const GeometryBaseType&) = default;
#endif

      virtual 
      ~GeometryBaseType ();
    };

    class QIF30_SYMBOL_DECL PointSetType: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::xsd::qif30::PointEntityType Point_type;
      typedef ::xsd::cxx::tree::sequence< Point_type > Point_sequence;
      typedef xsd::cxx::tree::sequence< Point_type >::iterator Point_iterator;
      typedef xsd::cxx::tree::sequence< Point_type >::const_iterator Point_const_iterator;
      typedef ::xsd::cxx::tree::traits< Point_type, wchar_t > Point_traits;

      const Point_sequence&
      Point () const;

      Point_sequence&
      Point ();

      void
      Point (const Point_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      PointSetType ();

      PointSetType (const n_type&);

      PointSetType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      PointSetType (const PointSetType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual PointSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointSetType&
      operator= (const PointSetType& x);

      virtual 
      ~PointSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Point_sequence Point_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PointEntityType: public ::xsd::qif30::GeometryBaseType
    {
      public:
      // XYZ
      //
      typedef ::xsd::qif30::PointSimpleType XYZ_type;
      typedef ::xsd::cxx::tree::traits< XYZ_type, wchar_t > XYZ_traits;

      const XYZ_type&
      XYZ () const;

      XYZ_type&
      XYZ ();

      void
      XYZ (const XYZ_type& x);

      void
      XYZ (::std::unique_ptr< XYZ_type > p);

      // Constructors.
      //
      PointEntityType ();

      PointEntityType (const id_type&,
                       const XYZ_type&);

      PointEntityType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PointEntityType (const PointEntityType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual PointEntityType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointEntityType&
      operator= (const PointEntityType& x);

      virtual 
      ~PointEntityType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XYZ_type > XYZ_;
    };

    class QIF30_SYMBOL_DECL Curve12SetType: public ::xml_schema::type
    {
      public:
      // Curve12
      //
      typedef ::xsd::qif30::Curve12BaseType Curve12_type;
      typedef ::xsd::cxx::tree::sequence< Curve12_type > Curve12_sequence;
      typedef xsd::cxx::tree::sequence< Curve12_type >::iterator Curve12_iterator;
      typedef xsd::cxx::tree::sequence< Curve12_type >::const_iterator Curve12_const_iterator;
      typedef ::xsd::cxx::tree::traits< Curve12_type, wchar_t > Curve12_traits;

      const Curve12_sequence&
      Curve12 () const;

      Curve12_sequence&
      Curve12 ();

      void
      Curve12 (const Curve12_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      Curve12SetType ();

      Curve12SetType (const n_type&);

      Curve12SetType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      Curve12SetType (const Curve12SetType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual Curve12SetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Curve12SetType&
      operator= (const Curve12SetType& x);

      virtual 
      ~Curve12SetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Curve12_sequence Curve12_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL Curve13SetType: public ::xml_schema::type
    {
      public:
      // Curve13
      //
      typedef ::xsd::qif30::Curve13BaseType Curve13_type;
      typedef ::xsd::cxx::tree::sequence< Curve13_type > Curve13_sequence;
      typedef xsd::cxx::tree::sequence< Curve13_type >::iterator Curve13_iterator;
      typedef xsd::cxx::tree::sequence< Curve13_type >::const_iterator Curve13_const_iterator;
      typedef ::xsd::cxx::tree::traits< Curve13_type, wchar_t > Curve13_traits;

      const Curve13_sequence&
      Curve13 () const;

      Curve13_sequence&
      Curve13 ();

      void
      Curve13 (const Curve13_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      Curve13SetType ();

      Curve13SetType (const n_type&);

      Curve13SetType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      Curve13SetType (const Curve13SetType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual Curve13SetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Curve13SetType&
      operator= (const Curve13SetType& x);

      virtual 
      ~Curve13SetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Curve13_sequence Curve13_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL Curve13CoreType: public ::xml_schema::type
    {
      public:
      // Curve13Core
      //
      typedef ::xsd::qif30::CurveCoreBaseType Curve13Core_type;
      typedef ::xsd::cxx::tree::traits< Curve13Core_type, wchar_t > Curve13Core_traits;

      const Curve13Core_type&
      Curve13Core () const;

      Curve13Core_type&
      Curve13Core ();

      void
      Curve13Core (const Curve13Core_type& x);

      void
      Curve13Core (::std::unique_ptr< Curve13Core_type > p);

      // Constructors.
      //
      Curve13CoreType ();

      Curve13CoreType (const Curve13Core_type&);

      Curve13CoreType (::std::unique_ptr< Curve13Core_type >);

      Curve13CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Curve13CoreType (const Curve13CoreType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Curve13CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Curve13CoreType&
      operator= (const Curve13CoreType& x);

      virtual 
      ~Curve13CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Curve13Core_type > Curve13Core_;
    };

    class QIF30_SYMBOL_DECL CurveCoreBaseType: public ::xml_schema::type
    {
      public:
      // domain
      //
      typedef ::xsd::qif30::ParameterRangeType domain_type;
      typedef ::xsd::cxx::tree::traits< domain_type, wchar_t > domain_traits;

      const domain_type&
      domain () const;

      domain_type&
      domain ();

      void
      domain (const domain_type& x);

      void
      domain (::std::unique_ptr< domain_type > p);

      // Constructors.
      //
      CurveCoreBaseType ();

      CurveCoreBaseType (const domain_type&);

      CurveCoreBaseType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CurveCoreBaseType (const CurveCoreBaseType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CurveCoreBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      CurveCoreBaseType&
      operator= (const CurveCoreBaseType& x);

      virtual 
      ~CurveCoreBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< domain_type > domain_;
    };

    class QIF30_SYMBOL_DECL Curve12BaseType: public ::xsd::qif30::GeometryBaseType
    {
      public:
      // Constructors.
      //
      Curve12BaseType ();

      Curve12BaseType (const id_type&);

      Curve12BaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Curve12BaseType (const Curve12BaseType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Curve12BaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      Curve12BaseType&
      operator= (const Curve12BaseType&) = default;
#endif

      virtual 
      ~Curve12BaseType ();
    };

    class QIF30_SYMBOL_DECL Curve13BaseType: public ::xsd::qif30::GeometryBaseType
    {
      public:
      // Constructors.
      //
      Curve13BaseType ();

      Curve13BaseType (const id_type&);

      Curve13BaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Curve13BaseType (const Curve13BaseType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Curve13BaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      Curve13BaseType&
      operator= (const Curve13BaseType&) = default;
#endif

      virtual 
      ~Curve13BaseType ();
    };

    class QIF30_SYMBOL_DECL Segment13CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // StartPoint
      //
      typedef ::xsd::qif30::PointSimpleType StartPoint_type;
      typedef ::xsd::cxx::tree::traits< StartPoint_type, wchar_t > StartPoint_traits;

      const StartPoint_type&
      StartPoint () const;

      StartPoint_type&
      StartPoint ();

      void
      StartPoint (const StartPoint_type& x);

      void
      StartPoint (::std::unique_ptr< StartPoint_type > p);

      // EndPoint
      //
      typedef ::xsd::qif30::PointSimpleType EndPoint_type;
      typedef ::xsd::cxx::tree::traits< EndPoint_type, wchar_t > EndPoint_traits;

      const EndPoint_type&
      EndPoint () const;

      EndPoint_type&
      EndPoint ();

      void
      EndPoint (const EndPoint_type& x);

      void
      EndPoint (::std::unique_ptr< EndPoint_type > p);

      // Constructors.
      //
      Segment13CoreType ();

      Segment13CoreType (const domain_type&,
                         const StartPoint_type&,
                         const EndPoint_type&);

      Segment13CoreType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Segment13CoreType (const Segment13CoreType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual Segment13CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Segment13CoreType&
      operator= (const Segment13CoreType& x);

      virtual 
      ~Segment13CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< StartPoint_type > StartPoint_;
      ::xsd::cxx::tree::one< EndPoint_type > EndPoint_;
    };

    class QIF30_SYMBOL_DECL Segment12CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // StartPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType StartPoint_type;
      typedef ::xsd::cxx::tree::traits< StartPoint_type, wchar_t > StartPoint_traits;

      const StartPoint_type&
      StartPoint () const;

      StartPoint_type&
      StartPoint ();

      void
      StartPoint (const StartPoint_type& x);

      void
      StartPoint (::std::unique_ptr< StartPoint_type > p);

      // EndPoint
      //
      typedef ::xsd::qif30::Point2dSimpleType EndPoint_type;
      typedef ::xsd::cxx::tree::traits< EndPoint_type, wchar_t > EndPoint_traits;

      const EndPoint_type&
      EndPoint () const;

      EndPoint_type&
      EndPoint ();

      void
      EndPoint (const EndPoint_type& x);

      void
      EndPoint (::std::unique_ptr< EndPoint_type > p);

      // Constructors.
      //
      Segment12CoreType ();

      Segment12CoreType (const domain_type&,
                         const StartPoint_type&,
                         const EndPoint_type&);

      Segment12CoreType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Segment12CoreType (const Segment12CoreType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual Segment12CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Segment12CoreType&
      operator= (const Segment12CoreType& x);

      virtual 
      ~Segment12CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< StartPoint_type > StartPoint_;
      ::xsd::cxx::tree::one< EndPoint_type > EndPoint_;
    };

    class QIF30_SYMBOL_DECL Segment13Type: public ::xsd::qif30::Curve13BaseType
    {
      public:
      // Segment13Core
      //
      typedef ::xsd::qif30::Segment13CoreType Segment13Core_type;
      typedef ::xsd::cxx::tree::traits< Segment13Core_type, wchar_t > Segment13Core_traits;

      const Segment13Core_type&
      Segment13Core () const;

      Segment13Core_type&
      Segment13Core ();

      void
      Segment13Core (const Segment13Core_type& x);

      void
      Segment13Core (::std::unique_ptr< Segment13Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Segment13Type ();

      Segment13Type (const id_type&,
                     const Segment13Core_type&);

      Segment13Type (const id_type&,
                     ::std::unique_ptr< Segment13Core_type >);

      Segment13Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      Segment13Type (const Segment13Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual Segment13Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Segment13Type&
      operator= (const Segment13Type& x);

      virtual 
      ~Segment13Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Segment13Core_type > Segment13Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Segment12Type: public ::xsd::qif30::Curve12BaseType
    {
      public:
      // Segment12Core
      //
      typedef ::xsd::qif30::Segment12CoreType Segment12Core_type;
      typedef ::xsd::cxx::tree::traits< Segment12Core_type, wchar_t > Segment12Core_traits;

      const Segment12Core_type&
      Segment12Core () const;

      Segment12Core_type&
      Segment12Core ();

      void
      Segment12Core (const Segment12Core_type& x);

      void
      Segment12Core (::std::unique_ptr< Segment12Core_type > p);

      // Constructors.
      //
      Segment12Type ();

      Segment12Type (const id_type&,
                     const Segment12Core_type&);

      Segment12Type (const id_type&,
                     ::std::unique_ptr< Segment12Core_type >);

      Segment12Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      Segment12Type (const Segment12Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual Segment12Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Segment12Type&
      operator= (const Segment12Type& x);

      virtual 
      ~Segment12Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Segment12Core_type > Segment12Core_;
    };

    class QIF30_SYMBOL_DECL ArcConicFormEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        PARABOLA,
        ELLIPSE,
        HYPERBOLA
      };

      ArcConicFormEnumType ();

      ArcConicFormEnumType (value v);

      ArcConicFormEnumType (const wchar_t* v);

      ArcConicFormEnumType (const ::std::wstring& v);

      ArcConicFormEnumType (const ::xml_schema::string& v);

      ArcConicFormEnumType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ArcConicFormEnumType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ArcConicFormEnumType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ArcConicFormEnumType (const ArcConicFormEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      ArcConicFormEnumType&
      operator= (const ArcConicFormEnumType&) = default;
#endif

      virtual ArcConicFormEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcConicFormEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ArcConicFormEnumType_convert ();
      }

      protected:
      value
      _xsd_ArcConicFormEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_ArcConicFormEnumType_literals_[3];
      static const value _xsd_ArcConicFormEnumType_indexes_[3];
    };

    class QIF30_SYMBOL_DECL ArcConic13CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // A
      //
      typedef ::xml_schema::double_ A_type;
      typedef ::xsd::cxx::tree::traits< A_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > A_traits;

      const A_type&
      A () const;

      A_type&
      A ();

      void
      A (const A_type& x);

      // B
      //
      typedef ::xml_schema::double_ B_type;
      typedef ::xsd::cxx::tree::traits< B_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > B_traits;

      const B_type&
      B () const;

      B_type&
      B ();

      void
      B (const B_type& x);

      // Center
      //
      typedef ::xsd::qif30::PointSimpleType Center_type;
      typedef ::xsd::cxx::tree::traits< Center_type, wchar_t > Center_traits;

      const Center_type&
      Center () const;

      Center_type&
      Center ();

      void
      Center (const Center_type& x);

      void
      Center (::std::unique_ptr< Center_type > p);

      // DirBeg
      //
      typedef ::xsd::qif30::UnitVectorSimpleType DirBeg_type;
      typedef ::xsd::cxx::tree::traits< DirBeg_type, wchar_t > DirBeg_traits;

      const DirBeg_type&
      DirBeg () const;

      DirBeg_type&
      DirBeg ();

      void
      DirBeg (const DirBeg_type& x);

      void
      DirBeg (::std::unique_ptr< DirBeg_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorSimpleType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // form
      //
      typedef ::xsd::qif30::ArcConicFormEnumType form_type;
      typedef ::xsd::cxx::tree::traits< form_type, wchar_t > form_traits;

      const form_type&
      form () const;

      form_type&
      form ();

      void
      form (const form_type& x);

      void
      form (::std::unique_ptr< form_type > p);

      // Constructors.
      //
      ArcConic13CoreType ();

      ArcConic13CoreType (const domain_type&,
                          const A_type&,
                          const B_type&,
                          const Center_type&,
                          const DirBeg_type&,
                          const Normal_type&,
                          const form_type&);

      ArcConic13CoreType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ArcConic13CoreType (const ArcConic13CoreType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ArcConic13CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcConic13CoreType&
      operator= (const ArcConic13CoreType& x);

      virtual 
      ~ArcConic13CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< A_type > A_;
      ::xsd::cxx::tree::one< B_type > B_;
      ::xsd::cxx::tree::one< Center_type > Center_;
      ::xsd::cxx::tree::one< DirBeg_type > DirBeg_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
      ::xsd::cxx::tree::one< form_type > form_;
    };

    class QIF30_SYMBOL_DECL ArcConic12CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // A
      //
      typedef ::xml_schema::double_ A_type;
      typedef ::xsd::cxx::tree::traits< A_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > A_traits;

      const A_type&
      A () const;

      A_type&
      A ();

      void
      A (const A_type& x);

      // B
      //
      typedef ::xml_schema::double_ B_type;
      typedef ::xsd::cxx::tree::traits< B_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > B_traits;

      const B_type&
      B () const;

      B_type&
      B ();

      void
      B (const B_type& x);

      // Center
      //
      typedef ::xsd::qif30::Point2dSimpleType Center_type;
      typedef ::xsd::cxx::tree::traits< Center_type, wchar_t > Center_traits;

      const Center_type&
      Center () const;

      Center_type&
      Center ();

      void
      Center (const Center_type& x);

      void
      Center (::std::unique_ptr< Center_type > p);

      // DirBeg
      //
      typedef ::xsd::qif30::UnitVector2dSimpleType DirBeg_type;
      typedef ::xsd::cxx::tree::traits< DirBeg_type, wchar_t > DirBeg_traits;

      const DirBeg_type&
      DirBeg () const;

      DirBeg_type&
      DirBeg ();

      void
      DirBeg (const DirBeg_type& x);

      void
      DirBeg (::std::unique_ptr< DirBeg_type > p);

      // form
      //
      typedef ::xsd::qif30::ArcConicFormEnumType form_type;
      typedef ::xsd::cxx::tree::traits< form_type, wchar_t > form_traits;

      const form_type&
      form () const;

      form_type&
      form ();

      void
      form (const form_type& x);

      void
      form (::std::unique_ptr< form_type > p);

      // turned
      //
      typedef ::xml_schema::boolean turned_type;
      typedef ::xsd::cxx::tree::traits< turned_type, wchar_t > turned_traits;

      const turned_type&
      turned () const;

      turned_type&
      turned ();

      void
      turned (const turned_type& x);

      static turned_type
      turned_default_value ();

      // Constructors.
      //
      ArcConic12CoreType ();

      ArcConic12CoreType (const domain_type&,
                          const A_type&,
                          const B_type&,
                          const Center_type&,
                          const DirBeg_type&,
                          const form_type&);

      ArcConic12CoreType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ArcConic12CoreType (const ArcConic12CoreType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ArcConic12CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcConic12CoreType&
      operator= (const ArcConic12CoreType& x);

      virtual 
      ~ArcConic12CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< A_type > A_;
      ::xsd::cxx::tree::one< B_type > B_;
      ::xsd::cxx::tree::one< Center_type > Center_;
      ::xsd::cxx::tree::one< DirBeg_type > DirBeg_;
      ::xsd::cxx::tree::one< form_type > form_;
      ::xsd::cxx::tree::one< turned_type > turned_;
    };

    class QIF30_SYMBOL_DECL ArcConic12Type: public ::xsd::qif30::Curve12BaseType
    {
      public:
      // ArcConic12Core
      //
      typedef ::xsd::qif30::ArcConic12CoreType ArcConic12Core_type;
      typedef ::xsd::cxx::tree::traits< ArcConic12Core_type, wchar_t > ArcConic12Core_traits;

      const ArcConic12Core_type&
      ArcConic12Core () const;

      ArcConic12Core_type&
      ArcConic12Core ();

      void
      ArcConic12Core (const ArcConic12Core_type& x);

      void
      ArcConic12Core (::std::unique_ptr< ArcConic12Core_type > p);

      // Constructors.
      //
      ArcConic12Type ();

      ArcConic12Type (const id_type&,
                      const ArcConic12Core_type&);

      ArcConic12Type (const id_type&,
                      ::std::unique_ptr< ArcConic12Core_type >);

      ArcConic12Type (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ArcConic12Type (const ArcConic12Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ArcConic12Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcConic12Type&
      operator= (const ArcConic12Type& x);

      virtual 
      ~ArcConic12Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ArcConic12Core_type > ArcConic12Core_;
    };

    class QIF30_SYMBOL_DECL ArcConic13Type: public ::xsd::qif30::Curve13BaseType
    {
      public:
      // ArcConic13Core
      //
      typedef ::xsd::qif30::ArcConic13CoreType ArcConic13Core_type;
      typedef ::xsd::cxx::tree::traits< ArcConic13Core_type, wchar_t > ArcConic13Core_traits;

      const ArcConic13Core_type&
      ArcConic13Core () const;

      ArcConic13Core_type&
      ArcConic13Core ();

      void
      ArcConic13Core (const ArcConic13Core_type& x);

      void
      ArcConic13Core (::std::unique_ptr< ArcConic13Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      ArcConic13Type ();

      ArcConic13Type (const id_type&,
                      const ArcConic13Core_type&);

      ArcConic13Type (const id_type&,
                      ::std::unique_ptr< ArcConic13Core_type >);

      ArcConic13Type (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ArcConic13Type (const ArcConic13Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ArcConic13Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcConic13Type&
      operator= (const ArcConic13Type& x);

      virtual 
      ~ArcConic13Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ArcConic13Core_type > ArcConic13Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL ArcCircular13CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // Radius
      //
      typedef ::xml_schema::double_ Radius_type;
      typedef ::xsd::cxx::tree::traits< Radius_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Radius_traits;

      const Radius_type&
      Radius () const;

      Radius_type&
      Radius ();

      void
      Radius (const Radius_type& x);

      // Center
      //
      typedef ::xsd::qif30::PointSimpleType Center_type;
      typedef ::xsd::cxx::tree::traits< Center_type, wchar_t > Center_traits;

      const Center_type&
      Center () const;

      Center_type&
      Center ();

      void
      Center (const Center_type& x);

      void
      Center (::std::unique_ptr< Center_type > p);

      // DirBeg
      //
      typedef ::xsd::qif30::UnitVectorSimpleType DirBeg_type;
      typedef ::xsd::cxx::tree::traits< DirBeg_type, wchar_t > DirBeg_traits;

      const DirBeg_type&
      DirBeg () const;

      DirBeg_type&
      DirBeg ();

      void
      DirBeg (const DirBeg_type& x);

      void
      DirBeg (::std::unique_ptr< DirBeg_type > p);

      // Normal
      //
      typedef ::xsd::qif30::UnitVectorSimpleType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, wchar_t > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::unique_ptr< Normal_type > p);

      // Constructors.
      //
      ArcCircular13CoreType ();

      ArcCircular13CoreType (const domain_type&,
                             const Radius_type&,
                             const Center_type&,
                             const DirBeg_type&,
                             const Normal_type&);

      ArcCircular13CoreType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ArcCircular13CoreType (const ArcCircular13CoreType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual ArcCircular13CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcCircular13CoreType&
      operator= (const ArcCircular13CoreType& x);

      virtual 
      ~ArcCircular13CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Radius_type > Radius_;
      ::xsd::cxx::tree::one< Center_type > Center_;
      ::xsd::cxx::tree::one< DirBeg_type > DirBeg_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
    };

    class QIF30_SYMBOL_DECL ArcCircular12CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // Radius
      //
      typedef ::xml_schema::double_ Radius_type;
      typedef ::xsd::cxx::tree::traits< Radius_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Radius_traits;

      const Radius_type&
      Radius () const;

      Radius_type&
      Radius ();

      void
      Radius (const Radius_type& x);

      // Center
      //
      typedef ::xsd::qif30::Point2dSimpleType Center_type;
      typedef ::xsd::cxx::tree::traits< Center_type, wchar_t > Center_traits;

      const Center_type&
      Center () const;

      Center_type&
      Center ();

      void
      Center (const Center_type& x);

      void
      Center (::std::unique_ptr< Center_type > p);

      // DirBeg
      //
      typedef ::xsd::qif30::UnitVector2dSimpleType DirBeg_type;
      typedef ::xsd::cxx::tree::traits< DirBeg_type, wchar_t > DirBeg_traits;

      const DirBeg_type&
      DirBeg () const;

      DirBeg_type&
      DirBeg ();

      void
      DirBeg (const DirBeg_type& x);

      void
      DirBeg (::std::unique_ptr< DirBeg_type > p);

      // turned
      //
      typedef ::xml_schema::boolean turned_type;
      typedef ::xsd::cxx::tree::traits< turned_type, wchar_t > turned_traits;

      const turned_type&
      turned () const;

      turned_type&
      turned ();

      void
      turned (const turned_type& x);

      static turned_type
      turned_default_value ();

      // Constructors.
      //
      ArcCircular12CoreType ();

      ArcCircular12CoreType (const domain_type&,
                             const Radius_type&,
                             const Center_type&,
                             const DirBeg_type&);

      ArcCircular12CoreType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ArcCircular12CoreType (const ArcCircular12CoreType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual ArcCircular12CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcCircular12CoreType&
      operator= (const ArcCircular12CoreType& x);

      virtual 
      ~ArcCircular12CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Radius_type > Radius_;
      ::xsd::cxx::tree::one< Center_type > Center_;
      ::xsd::cxx::tree::one< DirBeg_type > DirBeg_;
      ::xsd::cxx::tree::one< turned_type > turned_;
    };

    class QIF30_SYMBOL_DECL ArcCircular13Type: public ::xsd::qif30::Curve13BaseType
    {
      public:
      // ArcCircular13Core
      //
      typedef ::xsd::qif30::ArcCircular13CoreType ArcCircular13Core_type;
      typedef ::xsd::cxx::tree::traits< ArcCircular13Core_type, wchar_t > ArcCircular13Core_traits;

      const ArcCircular13Core_type&
      ArcCircular13Core () const;

      ArcCircular13Core_type&
      ArcCircular13Core ();

      void
      ArcCircular13Core (const ArcCircular13Core_type& x);

      void
      ArcCircular13Core (::std::unique_ptr< ArcCircular13Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      ArcCircular13Type ();

      ArcCircular13Type (const id_type&,
                         const ArcCircular13Core_type&);

      ArcCircular13Type (const id_type&,
                         ::std::unique_ptr< ArcCircular13Core_type >);

      ArcCircular13Type (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ArcCircular13Type (const ArcCircular13Type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ArcCircular13Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcCircular13Type&
      operator= (const ArcCircular13Type& x);

      virtual 
      ~ArcCircular13Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ArcCircular13Core_type > ArcCircular13Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL ArcCircular12Type: public ::xsd::qif30::Curve12BaseType
    {
      public:
      // ArcCircular12Core
      //
      typedef ::xsd::qif30::ArcCircular12CoreType ArcCircular12Core_type;
      typedef ::xsd::cxx::tree::traits< ArcCircular12Core_type, wchar_t > ArcCircular12Core_traits;

      const ArcCircular12Core_type&
      ArcCircular12Core () const;

      ArcCircular12Core_type&
      ArcCircular12Core ();

      void
      ArcCircular12Core (const ArcCircular12Core_type& x);

      void
      ArcCircular12Core (::std::unique_ptr< ArcCircular12Core_type > p);

      // Constructors.
      //
      ArcCircular12Type ();

      ArcCircular12Type (const id_type&,
                         const ArcCircular12Core_type&);

      ArcCircular12Type (const id_type&,
                         ::std::unique_ptr< ArcCircular12Core_type >);

      ArcCircular12Type (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ArcCircular12Type (const ArcCircular12Type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ArcCircular12Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcCircular12Type&
      operator= (const ArcCircular12Type& x);

      virtual 
      ~ArcCircular12Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ArcCircular12Core_type > ArcCircular12Core_;
    };

    class QIF30_SYMBOL_DECL Nurbs12CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // Order
      //
      typedef ::xsd::qif30::NaturalType Order_type;
      typedef ::xsd::cxx::tree::traits< Order_type, wchar_t > Order_traits;

      const Order_type&
      Order () const;

      Order_type&
      Order ();

      void
      Order (const Order_type& x);

      void
      Order (::std::unique_ptr< Order_type > p);

      // Knots
      //
      typedef ::xsd::qif30::ArrayDoubleType Knots_type;
      typedef ::xsd::cxx::tree::traits< Knots_type, wchar_t > Knots_traits;

      const Knots_type&
      Knots () const;

      Knots_type&
      Knots ();

      void
      Knots (const Knots_type& x);

      void
      Knots (::std::unique_ptr< Knots_type > p);

      // CPs
      //
      typedef ::xsd::qif30::ArrayPoint2dType CPs_type;
      typedef ::xsd::cxx::tree::optional< CPs_type > CPs_optional;
      typedef ::xsd::cxx::tree::traits< CPs_type, wchar_t > CPs_traits;

      const CPs_optional&
      CPs () const;

      CPs_optional&
      CPs ();

      void
      CPs (const CPs_type& x);

      void
      CPs (const CPs_optional& x);

      void
      CPs (::std::unique_ptr< CPs_type > p);

      // CPsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType CPsBinary_type;
      typedef ::xsd::cxx::tree::optional< CPsBinary_type > CPsBinary_optional;
      typedef ::xsd::cxx::tree::traits< CPsBinary_type, wchar_t > CPsBinary_traits;

      const CPsBinary_optional&
      CPsBinary () const;

      CPsBinary_optional&
      CPsBinary ();

      void
      CPsBinary (const CPsBinary_type& x);

      void
      CPsBinary (const CPsBinary_optional& x);

      void
      CPsBinary (::std::unique_ptr< CPsBinary_type > p);

      // Weights
      //
      typedef ::xsd::qif30::ArrayDoubleType Weights_type;
      typedef ::xsd::cxx::tree::optional< Weights_type > Weights_optional;
      typedef ::xsd::cxx::tree::traits< Weights_type, wchar_t > Weights_traits;

      const Weights_optional&
      Weights () const;

      Weights_optional&
      Weights ();

      void
      Weights (const Weights_type& x);

      void
      Weights (const Weights_optional& x);

      void
      Weights (::std::unique_ptr< Weights_type > p);

      // Constructors.
      //
      Nurbs12CoreType ();

      Nurbs12CoreType (const domain_type&,
                       const Order_type&,
                       const Knots_type&);

      Nurbs12CoreType (const domain_type&,
                       const Order_type&,
                       ::std::unique_ptr< Knots_type >);

      Nurbs12CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Nurbs12CoreType (const Nurbs12CoreType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Nurbs12CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Nurbs12CoreType&
      operator= (const Nurbs12CoreType& x);

      virtual 
      ~Nurbs12CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Order_type > Order_;
      ::xsd::cxx::tree::one< Knots_type > Knots_;
      CPs_optional CPs_;
      CPsBinary_optional CPsBinary_;
      Weights_optional Weights_;
    };

    class QIF30_SYMBOL_DECL Nurbs13CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // Order
      //
      typedef ::xsd::qif30::NaturalType Order_type;
      typedef ::xsd::cxx::tree::traits< Order_type, wchar_t > Order_traits;

      const Order_type&
      Order () const;

      Order_type&
      Order ();

      void
      Order (const Order_type& x);

      void
      Order (::std::unique_ptr< Order_type > p);

      // Knots
      //
      typedef ::xsd::qif30::ArrayDoubleType Knots_type;
      typedef ::xsd::cxx::tree::traits< Knots_type, wchar_t > Knots_traits;

      const Knots_type&
      Knots () const;

      Knots_type&
      Knots ();

      void
      Knots (const Knots_type& x);

      void
      Knots (::std::unique_ptr< Knots_type > p);

      // CPs
      //
      typedef ::xsd::qif30::ArrayPointType CPs_type;
      typedef ::xsd::cxx::tree::optional< CPs_type > CPs_optional;
      typedef ::xsd::cxx::tree::traits< CPs_type, wchar_t > CPs_traits;

      const CPs_optional&
      CPs () const;

      CPs_optional&
      CPs ();

      void
      CPs (const CPs_type& x);

      void
      CPs (const CPs_optional& x);

      void
      CPs (::std::unique_ptr< CPs_type > p);

      // CPsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType CPsBinary_type;
      typedef ::xsd::cxx::tree::optional< CPsBinary_type > CPsBinary_optional;
      typedef ::xsd::cxx::tree::traits< CPsBinary_type, wchar_t > CPsBinary_traits;

      const CPsBinary_optional&
      CPsBinary () const;

      CPsBinary_optional&
      CPsBinary ();

      void
      CPsBinary (const CPsBinary_type& x);

      void
      CPsBinary (const CPsBinary_optional& x);

      void
      CPsBinary (::std::unique_ptr< CPsBinary_type > p);

      // Weights
      //
      typedef ::xsd::qif30::ArrayDoubleType Weights_type;
      typedef ::xsd::cxx::tree::optional< Weights_type > Weights_optional;
      typedef ::xsd::cxx::tree::traits< Weights_type, wchar_t > Weights_traits;

      const Weights_optional&
      Weights () const;

      Weights_optional&
      Weights ();

      void
      Weights (const Weights_type& x);

      void
      Weights (const Weights_optional& x);

      void
      Weights (::std::unique_ptr< Weights_type > p);

      // Constructors.
      //
      Nurbs13CoreType ();

      Nurbs13CoreType (const domain_type&,
                       const Order_type&,
                       const Knots_type&);

      Nurbs13CoreType (const domain_type&,
                       const Order_type&,
                       ::std::unique_ptr< Knots_type >);

      Nurbs13CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Nurbs13CoreType (const Nurbs13CoreType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Nurbs13CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Nurbs13CoreType&
      operator= (const Nurbs13CoreType& x);

      virtual 
      ~Nurbs13CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Order_type > Order_;
      ::xsd::cxx::tree::one< Knots_type > Knots_;
      CPs_optional CPs_;
      CPsBinary_optional CPsBinary_;
      Weights_optional Weights_;
    };

    class QIF30_SYMBOL_DECL Nurbs12Type: public ::xsd::qif30::Curve12BaseType
    {
      public:
      // Nurbs12Core
      //
      typedef ::xsd::qif30::Nurbs12CoreType Nurbs12Core_type;
      typedef ::xsd::cxx::tree::traits< Nurbs12Core_type, wchar_t > Nurbs12Core_traits;

      const Nurbs12Core_type&
      Nurbs12Core () const;

      Nurbs12Core_type&
      Nurbs12Core ();

      void
      Nurbs12Core (const Nurbs12Core_type& x);

      void
      Nurbs12Core (::std::unique_ptr< Nurbs12Core_type > p);

      // Constructors.
      //
      Nurbs12Type ();

      Nurbs12Type (const id_type&,
                   const Nurbs12Core_type&);

      Nurbs12Type (const id_type&,
                   ::std::unique_ptr< Nurbs12Core_type >);

      Nurbs12Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      Nurbs12Type (const Nurbs12Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual Nurbs12Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Nurbs12Type&
      operator= (const Nurbs12Type& x);

      virtual 
      ~Nurbs12Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Nurbs12Core_type > Nurbs12Core_;
    };

    class QIF30_SYMBOL_DECL Nurbs13Type: public ::xsd::qif30::Curve13BaseType
    {
      public:
      // Nurbs13Core
      //
      typedef ::xsd::qif30::Nurbs13CoreType Nurbs13Core_type;
      typedef ::xsd::cxx::tree::traits< Nurbs13Core_type, wchar_t > Nurbs13Core_traits;

      const Nurbs13Core_type&
      Nurbs13Core () const;

      Nurbs13Core_type&
      Nurbs13Core ();

      void
      Nurbs13Core (const Nurbs13Core_type& x);

      void
      Nurbs13Core (::std::unique_ptr< Nurbs13Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Nurbs13Type ();

      Nurbs13Type (const id_type&,
                   const Nurbs13Core_type&);

      Nurbs13Type (const id_type&,
                   ::std::unique_ptr< Nurbs13Core_type >);

      Nurbs13Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      Nurbs13Type (const Nurbs13Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual Nurbs13Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Nurbs13Type&
      operator= (const Nurbs13Type& x);

      virtual 
      ~Nurbs13Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Nurbs13Core_type > Nurbs13Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Spline13CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // Knots
      //
      typedef ::xsd::qif30::ArrayDoubleType Knots_type;
      typedef ::xsd::cxx::tree::traits< Knots_type, wchar_t > Knots_traits;

      const Knots_type&
      Knots () const;

      Knots_type&
      Knots ();

      void
      Knots (const Knots_type& x);

      void
      Knots (::std::unique_ptr< Knots_type > p);

      // Orders
      //
      typedef ::xsd::qif30::ArrayNaturalType Orders_type;
      typedef ::xsd::cxx::tree::traits< Orders_type, wchar_t > Orders_traits;

      const Orders_type&
      Orders () const;

      Orders_type&
      Orders ();

      void
      Orders (const Orders_type& x);

      void
      Orders (::std::unique_ptr< Orders_type > p);

      // Coefficients
      //
      typedef ::xsd::qif30::ArrayPointType Coefficients_type;
      typedef ::xsd::cxx::tree::traits< Coefficients_type, wchar_t > Coefficients_traits;

      const Coefficients_type&
      Coefficients () const;

      Coefficients_type&
      Coefficients ();

      void
      Coefficients (const Coefficients_type& x);

      void
      Coefficients (::std::unique_ptr< Coefficients_type > p);

      // normalized
      //
      typedef ::xml_schema::boolean normalized_type;
      typedef ::xsd::cxx::tree::traits< normalized_type, wchar_t > normalized_traits;

      const normalized_type&
      normalized () const;

      normalized_type&
      normalized ();

      void
      normalized (const normalized_type& x);

      static normalized_type
      normalized_default_value ();

      // Constructors.
      //
      Spline13CoreType ();

      Spline13CoreType (const domain_type&,
                        const Knots_type&,
                        const Orders_type&,
                        const Coefficients_type&);

      Spline13CoreType (const domain_type&,
                        ::std::unique_ptr< Knots_type >,
                        ::std::unique_ptr< Orders_type >,
                        ::std::unique_ptr< Coefficients_type >);

      Spline13CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      Spline13CoreType (const Spline13CoreType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual Spline13CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Spline13CoreType&
      operator= (const Spline13CoreType& x);

      virtual 
      ~Spline13CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Knots_type > Knots_;
      ::xsd::cxx::tree::one< Orders_type > Orders_;
      ::xsd::cxx::tree::one< Coefficients_type > Coefficients_;
      ::xsd::cxx::tree::one< normalized_type > normalized_;
    };

    class QIF30_SYMBOL_DECL Spline12CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // Knots
      //
      typedef ::xsd::qif30::ArrayDoubleType Knots_type;
      typedef ::xsd::cxx::tree::traits< Knots_type, wchar_t > Knots_traits;

      const Knots_type&
      Knots () const;

      Knots_type&
      Knots ();

      void
      Knots (const Knots_type& x);

      void
      Knots (::std::unique_ptr< Knots_type > p);

      // Orders
      //
      typedef ::xsd::qif30::ArrayNaturalType Orders_type;
      typedef ::xsd::cxx::tree::traits< Orders_type, wchar_t > Orders_traits;

      const Orders_type&
      Orders () const;

      Orders_type&
      Orders ();

      void
      Orders (const Orders_type& x);

      void
      Orders (::std::unique_ptr< Orders_type > p);

      // Coefficients
      //
      typedef ::xsd::qif30::ArrayPoint2dType Coefficients_type;
      typedef ::xsd::cxx::tree::traits< Coefficients_type, wchar_t > Coefficients_traits;

      const Coefficients_type&
      Coefficients () const;

      Coefficients_type&
      Coefficients ();

      void
      Coefficients (const Coefficients_type& x);

      void
      Coefficients (::std::unique_ptr< Coefficients_type > p);

      // normalized
      //
      typedef ::xml_schema::boolean normalized_type;
      typedef ::xsd::cxx::tree::traits< normalized_type, wchar_t > normalized_traits;

      const normalized_type&
      normalized () const;

      normalized_type&
      normalized ();

      void
      normalized (const normalized_type& x);

      static normalized_type
      normalized_default_value ();

      // Constructors.
      //
      Spline12CoreType ();

      Spline12CoreType (const domain_type&,
                        const Knots_type&,
                        const Orders_type&,
                        const Coefficients_type&);

      Spline12CoreType (const domain_type&,
                        ::std::unique_ptr< Knots_type >,
                        ::std::unique_ptr< Orders_type >,
                        ::std::unique_ptr< Coefficients_type >);

      Spline12CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      Spline12CoreType (const Spline12CoreType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual Spline12CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Spline12CoreType&
      operator= (const Spline12CoreType& x);

      virtual 
      ~Spline12CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Knots_type > Knots_;
      ::xsd::cxx::tree::one< Orders_type > Orders_;
      ::xsd::cxx::tree::one< Coefficients_type > Coefficients_;
      ::xsd::cxx::tree::one< normalized_type > normalized_;
    };

    class QIF30_SYMBOL_DECL Spline13Type: public ::xsd::qif30::Curve13BaseType
    {
      public:
      // Spline13Core
      //
      typedef ::xsd::qif30::Spline13CoreType Spline13Core_type;
      typedef ::xsd::cxx::tree::traits< Spline13Core_type, wchar_t > Spline13Core_traits;

      const Spline13Core_type&
      Spline13Core () const;

      Spline13Core_type&
      Spline13Core ();

      void
      Spline13Core (const Spline13Core_type& x);

      void
      Spline13Core (::std::unique_ptr< Spline13Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Spline13Type ();

      Spline13Type (const id_type&,
                    const Spline13Core_type&);

      Spline13Type (const id_type&,
                    ::std::unique_ptr< Spline13Core_type >);

      Spline13Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      Spline13Type (const Spline13Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual Spline13Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Spline13Type&
      operator= (const Spline13Type& x);

      virtual 
      ~Spline13Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Spline13Core_type > Spline13Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Spline12Type: public ::xsd::qif30::Curve12BaseType
    {
      public:
      // Spline12Core
      //
      typedef ::xsd::qif30::Spline12CoreType Spline12Core_type;
      typedef ::xsd::cxx::tree::traits< Spline12Core_type, wchar_t > Spline12Core_traits;

      const Spline12Core_type&
      Spline12Core () const;

      Spline12Core_type&
      Spline12Core ();

      void
      Spline12Core (const Spline12Core_type& x);

      void
      Spline12Core (::std::unique_ptr< Spline12Core_type > p);

      // Constructors.
      //
      Spline12Type ();

      Spline12Type (const id_type&,
                    const Spline12Core_type&);

      Spline12Type (const id_type&,
                    ::std::unique_ptr< Spline12Core_type >);

      Spline12Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      Spline12Type (const Spline12Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual Spline12Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Spline12Type&
      operator= (const Spline12Type& x);

      virtual 
      ~Spline12Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Spline12Core_type > Spline12Core_;
    };

    class QIF30_SYMBOL_DECL Curve12OrientedType: public ::xml_schema::type
    {
      public:
      // Curve12Core
      //
      typedef ::xsd::qif30::CurveCoreBaseType Curve12Core_type;
      typedef ::xsd::cxx::tree::traits< Curve12Core_type, wchar_t > Curve12Core_traits;

      const Curve12Core_type&
      Curve12Core () const;

      Curve12Core_type&
      Curve12Core ();

      void
      Curve12Core (const Curve12Core_type& x);

      void
      Curve12Core (::std::unique_ptr< Curve12Core_type > p);

      // turned
      //
      typedef ::xml_schema::boolean turned_type;
      typedef ::xsd::cxx::tree::traits< turned_type, wchar_t > turned_traits;

      const turned_type&
      turned () const;

      turned_type&
      turned ();

      void
      turned (const turned_type& x);

      static turned_type
      turned_default_value ();

      // Constructors.
      //
      Curve12OrientedType ();

      Curve12OrientedType (const Curve12Core_type&);

      Curve12OrientedType (::std::unique_ptr< Curve12Core_type >);

      Curve12OrientedType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      Curve12OrientedType (const Curve12OrientedType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual Curve12OrientedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Curve12OrientedType&
      operator= (const Curve12OrientedType& x);

      virtual 
      ~Curve12OrientedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Curve12Core_type > Curve12Core_;
      ::xsd::cxx::tree::one< turned_type > turned_;
    };

    class QIF30_SYMBOL_DECL ArraySubCurve12Type: public ::xml_schema::type
    {
      public:
      // SubCurve
      //
      typedef ::xsd::qif30::Curve12OrientedType SubCurve_type;
      typedef ::xsd::cxx::tree::sequence< SubCurve_type > SubCurve_sequence;
      typedef xsd::cxx::tree::sequence< SubCurve_type >::iterator SubCurve_iterator;
      typedef xsd::cxx::tree::sequence< SubCurve_type >::const_iterator SubCurve_const_iterator;
      typedef ::xsd::cxx::tree::traits< SubCurve_type, wchar_t > SubCurve_traits;

      const SubCurve_sequence&
      SubCurve () const;

      SubCurve_sequence&
      SubCurve ();

      void
      SubCurve (const SubCurve_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArraySubCurve12Type ();

      ArraySubCurve12Type (const n_type&);

      ArraySubCurve12Type (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ArraySubCurve12Type (const ArraySubCurve12Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ArraySubCurve12Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArraySubCurve12Type&
      operator= (const ArraySubCurve12Type& x);

      virtual 
      ~ArraySubCurve12Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SubCurve_sequence SubCurve_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL Aggregate12CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // SubCurves
      //
      typedef ::xsd::qif30::ArraySubCurve12Type SubCurves_type;
      typedef ::xsd::cxx::tree::traits< SubCurves_type, wchar_t > SubCurves_traits;

      const SubCurves_type&
      SubCurves () const;

      SubCurves_type&
      SubCurves ();

      void
      SubCurves (const SubCurves_type& x);

      void
      SubCurves (::std::unique_ptr< SubCurves_type > p);

      // Constructors.
      //
      Aggregate12CoreType ();

      Aggregate12CoreType (const domain_type&,
                           const SubCurves_type&);

      Aggregate12CoreType (const domain_type&,
                           ::std::unique_ptr< SubCurves_type >);

      Aggregate12CoreType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      Aggregate12CoreType (const Aggregate12CoreType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual Aggregate12CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Aggregate12CoreType&
      operator= (const Aggregate12CoreType& x);

      virtual 
      ~Aggregate12CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SubCurves_type > SubCurves_;
    };

    class QIF30_SYMBOL_DECL Curve13OrientedType: public ::xml_schema::type
    {
      public:
      // Curve13Core
      //
      typedef ::xsd::qif30::CurveCoreBaseType Curve13Core_type;
      typedef ::xsd::cxx::tree::traits< Curve13Core_type, wchar_t > Curve13Core_traits;

      const Curve13Core_type&
      Curve13Core () const;

      Curve13Core_type&
      Curve13Core ();

      void
      Curve13Core (const Curve13Core_type& x);

      void
      Curve13Core (::std::unique_ptr< Curve13Core_type > p);

      // turned
      //
      typedef ::xml_schema::boolean turned_type;
      typedef ::xsd::cxx::tree::traits< turned_type, wchar_t > turned_traits;

      const turned_type&
      turned () const;

      turned_type&
      turned ();

      void
      turned (const turned_type& x);

      static turned_type
      turned_default_value ();

      // Constructors.
      //
      Curve13OrientedType ();

      Curve13OrientedType (const Curve13Core_type&);

      Curve13OrientedType (::std::unique_ptr< Curve13Core_type >);

      Curve13OrientedType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      Curve13OrientedType (const Curve13OrientedType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual Curve13OrientedType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Curve13OrientedType&
      operator= (const Curve13OrientedType& x);

      virtual 
      ~Curve13OrientedType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Curve13Core_type > Curve13Core_;
      ::xsd::cxx::tree::one< turned_type > turned_;
    };

    class QIF30_SYMBOL_DECL ArraySubCurve13Type: public ::xml_schema::type
    {
      public:
      // SubCurve
      //
      typedef ::xsd::qif30::Curve13OrientedType SubCurve_type;
      typedef ::xsd::cxx::tree::sequence< SubCurve_type > SubCurve_sequence;
      typedef xsd::cxx::tree::sequence< SubCurve_type >::iterator SubCurve_iterator;
      typedef xsd::cxx::tree::sequence< SubCurve_type >::const_iterator SubCurve_const_iterator;
      typedef ::xsd::cxx::tree::traits< SubCurve_type, wchar_t > SubCurve_traits;

      const SubCurve_sequence&
      SubCurve () const;

      SubCurve_sequence&
      SubCurve ();

      void
      SubCurve (const SubCurve_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArraySubCurve13Type ();

      ArraySubCurve13Type (const n_type&);

      ArraySubCurve13Type (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ArraySubCurve13Type (const ArraySubCurve13Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ArraySubCurve13Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArraySubCurve13Type&
      operator= (const ArraySubCurve13Type& x);

      virtual 
      ~ArraySubCurve13Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SubCurve_sequence SubCurve_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL Aggregate13CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // SubCurves
      //
      typedef ::xsd::qif30::ArraySubCurve13Type SubCurves_type;
      typedef ::xsd::cxx::tree::traits< SubCurves_type, wchar_t > SubCurves_traits;

      const SubCurves_type&
      SubCurves () const;

      SubCurves_type&
      SubCurves ();

      void
      SubCurves (const SubCurves_type& x);

      void
      SubCurves (::std::unique_ptr< SubCurves_type > p);

      // Constructors.
      //
      Aggregate13CoreType ();

      Aggregate13CoreType (const domain_type&,
                           const SubCurves_type&);

      Aggregate13CoreType (const domain_type&,
                           ::std::unique_ptr< SubCurves_type >);

      Aggregate13CoreType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      Aggregate13CoreType (const Aggregate13CoreType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual Aggregate13CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Aggregate13CoreType&
      operator= (const Aggregate13CoreType& x);

      virtual 
      ~Aggregate13CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SubCurves_type > SubCurves_;
    };

    class QIF30_SYMBOL_DECL Aggregate12Type: public ::xsd::qif30::Curve12BaseType
    {
      public:
      // Aggregate12Core
      //
      typedef ::xsd::qif30::Aggregate12CoreType Aggregate12Core_type;
      typedef ::xsd::cxx::tree::traits< Aggregate12Core_type, wchar_t > Aggregate12Core_traits;

      const Aggregate12Core_type&
      Aggregate12Core () const;

      Aggregate12Core_type&
      Aggregate12Core ();

      void
      Aggregate12Core (const Aggregate12Core_type& x);

      void
      Aggregate12Core (::std::unique_ptr< Aggregate12Core_type > p);

      // Constructors.
      //
      Aggregate12Type ();

      Aggregate12Type (const id_type&,
                       const Aggregate12Core_type&);

      Aggregate12Type (const id_type&,
                       ::std::unique_ptr< Aggregate12Core_type >);

      Aggregate12Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Aggregate12Type (const Aggregate12Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Aggregate12Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Aggregate12Type&
      operator= (const Aggregate12Type& x);

      virtual 
      ~Aggregate12Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Aggregate12Core_type > Aggregate12Core_;
    };

    class QIF30_SYMBOL_DECL Aggregate13Type: public ::xsd::qif30::Curve13BaseType
    {
      public:
      // Aggregate13Core
      //
      typedef ::xsd::qif30::Aggregate13CoreType Aggregate13Core_type;
      typedef ::xsd::cxx::tree::traits< Aggregate13Core_type, wchar_t > Aggregate13Core_traits;

      const Aggregate13Core_type&
      Aggregate13Core () const;

      Aggregate13Core_type&
      Aggregate13Core ();

      void
      Aggregate13Core (const Aggregate13Core_type& x);

      void
      Aggregate13Core (::std::unique_ptr< Aggregate13Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Aggregate13Type ();

      Aggregate13Type (const id_type&,
                       const Aggregate13Core_type&);

      Aggregate13Type (const id_type&,
                       ::std::unique_ptr< Aggregate13Core_type >);

      Aggregate13Type (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Aggregate13Type (const Aggregate13Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Aggregate13Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Aggregate13Type&
      operator= (const Aggregate13Type& x);

      virtual 
      ~Aggregate13Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Aggregate13Core_type > Aggregate13Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Polyline13CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // Points
      //
      typedef ::xsd::qif30::ArrayPointType Points_type;
      typedef ::xsd::cxx::tree::optional< Points_type > Points_optional;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_optional&
      Points () const;

      Points_optional&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (const Points_optional& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // PointsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType PointsBinary_type;
      typedef ::xsd::cxx::tree::optional< PointsBinary_type > PointsBinary_optional;
      typedef ::xsd::cxx::tree::traits< PointsBinary_type, wchar_t > PointsBinary_traits;

      const PointsBinary_optional&
      PointsBinary () const;

      PointsBinary_optional&
      PointsBinary ();

      void
      PointsBinary (const PointsBinary_type& x);

      void
      PointsBinary (const PointsBinary_optional& x);

      void
      PointsBinary (::std::unique_ptr< PointsBinary_type > p);

      // Constructors.
      //
      Polyline13CoreType ();

      Polyline13CoreType (const domain_type&);

      Polyline13CoreType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      Polyline13CoreType (const Polyline13CoreType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual Polyline13CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Polyline13CoreType&
      operator= (const Polyline13CoreType& x);

      virtual 
      ~Polyline13CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Points_optional Points_;
      PointsBinary_optional PointsBinary_;
    };

    class QIF30_SYMBOL_DECL Polyline12CoreType: public ::xsd::qif30::CurveCoreBaseType
    {
      public:
      // Points
      //
      typedef ::xsd::qif30::ArrayPoint2dType Points_type;
      typedef ::xsd::cxx::tree::optional< Points_type > Points_optional;
      typedef ::xsd::cxx::tree::traits< Points_type, wchar_t > Points_traits;

      const Points_optional&
      Points () const;

      Points_optional&
      Points ();

      void
      Points (const Points_type& x);

      void
      Points (const Points_optional& x);

      void
      Points (::std::unique_ptr< Points_type > p);

      // PointsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType PointsBinary_type;
      typedef ::xsd::cxx::tree::optional< PointsBinary_type > PointsBinary_optional;
      typedef ::xsd::cxx::tree::traits< PointsBinary_type, wchar_t > PointsBinary_traits;

      const PointsBinary_optional&
      PointsBinary () const;

      PointsBinary_optional&
      PointsBinary ();

      void
      PointsBinary (const PointsBinary_type& x);

      void
      PointsBinary (const PointsBinary_optional& x);

      void
      PointsBinary (::std::unique_ptr< PointsBinary_type > p);

      // Constructors.
      //
      Polyline12CoreType ();

      Polyline12CoreType (const domain_type&);

      Polyline12CoreType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      Polyline12CoreType (const Polyline12CoreType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual Polyline12CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Polyline12CoreType&
      operator= (const Polyline12CoreType& x);

      virtual 
      ~Polyline12CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Points_optional Points_;
      PointsBinary_optional PointsBinary_;
    };

    class QIF30_SYMBOL_DECL Polyline13Type: public ::xsd::qif30::Curve13BaseType
    {
      public:
      // Polyline13Core
      //
      typedef ::xsd::qif30::Polyline13CoreType Polyline13Core_type;
      typedef ::xsd::cxx::tree::traits< Polyline13Core_type, wchar_t > Polyline13Core_traits;

      const Polyline13Core_type&
      Polyline13Core () const;

      Polyline13Core_type&
      Polyline13Core ();

      void
      Polyline13Core (const Polyline13Core_type& x);

      void
      Polyline13Core (::std::unique_ptr< Polyline13Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Polyline13Type ();

      Polyline13Type (const id_type&,
                      const Polyline13Core_type&);

      Polyline13Type (const id_type&,
                      ::std::unique_ptr< Polyline13Core_type >);

      Polyline13Type (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      Polyline13Type (const Polyline13Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual Polyline13Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Polyline13Type&
      operator= (const Polyline13Type& x);

      virtual 
      ~Polyline13Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Polyline13Core_type > Polyline13Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Polyline12Type: public ::xsd::qif30::Curve12BaseType
    {
      public:
      // Polyline12Core
      //
      typedef ::xsd::qif30::Polyline12CoreType Polyline12Core_type;
      typedef ::xsd::cxx::tree::traits< Polyline12Core_type, wchar_t > Polyline12Core_traits;

      const Polyline12Core_type&
      Polyline12Core () const;

      Polyline12Core_type&
      Polyline12Core ();

      void
      Polyline12Core (const Polyline12Core_type& x);

      void
      Polyline12Core (::std::unique_ptr< Polyline12Core_type > p);

      // Constructors.
      //
      Polyline12Type ();

      Polyline12Type (const id_type&,
                      const Polyline12Core_type&);

      Polyline12Type (const id_type&,
                      ::std::unique_ptr< Polyline12Core_type >);

      Polyline12Type (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      Polyline12Type (const Polyline12Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual Polyline12Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Polyline12Type&
      operator= (const Polyline12Type& x);

      virtual 
      ~Polyline12Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Polyline12Core_type > Polyline12Core_;
    };

    class QIF30_SYMBOL_DECL SurfaceBaseType: public ::xsd::qif30::GeometryBaseType
    {
      public:
      // Constructors.
      //
      SurfaceBaseType ();

      SurfaceBaseType (const id_type&);

      SurfaceBaseType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      SurfaceBaseType (const SurfaceBaseType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual SurfaceBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

#ifdef XSD_CXX11
      SurfaceBaseType&
      operator= (const SurfaceBaseType&) = default;
#endif

      virtual 
      ~SurfaceBaseType ();
    };

    class QIF30_SYMBOL_DECL SurfaceSetType: public ::xml_schema::type
    {
      public:
      // Surface
      //
      typedef ::xsd::qif30::SurfaceBaseType Surface_type;
      typedef ::xsd::cxx::tree::sequence< Surface_type > Surface_sequence;
      typedef xsd::cxx::tree::sequence< Surface_type >::iterator Surface_iterator;
      typedef xsd::cxx::tree::sequence< Surface_type >::const_iterator Surface_const_iterator;
      typedef ::xsd::cxx::tree::traits< Surface_type, wchar_t > Surface_traits;

      const Surface_sequence&
      Surface () const;

      Surface_sequence&
      Surface ();

      void
      Surface (const Surface_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SurfaceSetType ();

      SurfaceSetType (const n_type&);

      SurfaceSetType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SurfaceSetType (const SurfaceSetType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SurfaceSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceSetType&
      operator= (const SurfaceSetType& x);

      virtual 
      ~SurfaceSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Surface_sequence Surface_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL SurfaceCoreType: public ::xml_schema::type
    {
      public:
      // SurfaceCore
      //
      typedef ::xsd::qif30::SurfaceCoreBaseType SurfaceCore_type;
      typedef ::xsd::cxx::tree::traits< SurfaceCore_type, wchar_t > SurfaceCore_traits;

      const SurfaceCore_type&
      SurfaceCore () const;

      SurfaceCore_type&
      SurfaceCore ();

      void
      SurfaceCore (const SurfaceCore_type& x);

      void
      SurfaceCore (::std::unique_ptr< SurfaceCore_type > p);

      // Constructors.
      //
      SurfaceCoreType ();

      SurfaceCoreType (const SurfaceCore_type&);

      SurfaceCoreType (::std::unique_ptr< SurfaceCore_type >);

      SurfaceCoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      SurfaceCoreType (const SurfaceCoreType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual SurfaceCoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceCoreType&
      operator= (const SurfaceCoreType& x);

      virtual 
      ~SurfaceCoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SurfaceCore_type > SurfaceCore_;
    };

    class QIF30_SYMBOL_DECL SurfaceCoreBaseType: public ::xml_schema::type
    {
      public:
      // form
      //
      typedef ::xsd::qif30::Attr23CoreEnumType form_type;
      typedef ::xsd::cxx::tree::optional< form_type > form_optional;
      typedef ::xsd::cxx::tree::traits< form_type, wchar_t > form_traits;

      const form_optional&
      form () const;

      form_optional&
      form ();

      void
      form (const form_type& x);

      void
      form (const form_optional& x);

      void
      form (::std::unique_ptr< form_type > p);

      // Constructors.
      //
      SurfaceCoreBaseType ();

      SurfaceCoreBaseType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      SurfaceCoreBaseType (const SurfaceCoreBaseType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual SurfaceCoreBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const = 0;

      SurfaceCoreBaseType&
      operator= (const SurfaceCoreBaseType& x);

      virtual 
      ~SurfaceCoreBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      form_optional form_;
    };

    class QIF30_SYMBOL_DECL Attr23CoreEnumType: public ::xml_schema::string
    {
      public:
      enum value
      {
        FREEFORM,
        CYLINDER,
        CONE,
        TORUS,
        SPHERE,
        PLANE
      };

      Attr23CoreEnumType ();

      Attr23CoreEnumType (value v);

      Attr23CoreEnumType (const wchar_t* v);

      Attr23CoreEnumType (const ::std::wstring& v);

      Attr23CoreEnumType (const ::xml_schema::string& v);

      Attr23CoreEnumType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      Attr23CoreEnumType (const xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      Attr23CoreEnumType (const ::std::wstring& s,
                          const xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      Attr23CoreEnumType (const Attr23CoreEnumType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
      Attr23CoreEnumType&
      operator= (const Attr23CoreEnumType&) = default;
#endif

      virtual Attr23CoreEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Attr23CoreEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_Attr23CoreEnumType_convert ();
      }

      protected:
      value
      _xsd_Attr23CoreEnumType_convert () const;

      public:
      static const wchar_t* const _xsd_Attr23CoreEnumType_literals_[6];
      static const value _xsd_Attr23CoreEnumType_indexes_[6];
    };

    class QIF30_SYMBOL_DECL Nurbs23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // OrderU
      //
      typedef ::xsd::qif30::NaturalType OrderU_type;
      typedef ::xsd::cxx::tree::traits< OrderU_type, wchar_t > OrderU_traits;

      const OrderU_type&
      OrderU () const;

      OrderU_type&
      OrderU ();

      void
      OrderU (const OrderU_type& x);

      void
      OrderU (::std::unique_ptr< OrderU_type > p);

      // OrderV
      //
      typedef ::xsd::qif30::NaturalType OrderV_type;
      typedef ::xsd::cxx::tree::traits< OrderV_type, wchar_t > OrderV_traits;

      const OrderV_type&
      OrderV () const;

      OrderV_type&
      OrderV ();

      void
      OrderV (const OrderV_type& x);

      void
      OrderV (::std::unique_ptr< OrderV_type > p);

      // KnotsU
      //
      typedef ::xsd::qif30::ArrayDoubleType KnotsU_type;
      typedef ::xsd::cxx::tree::traits< KnotsU_type, wchar_t > KnotsU_traits;

      const KnotsU_type&
      KnotsU () const;

      KnotsU_type&
      KnotsU ();

      void
      KnotsU (const KnotsU_type& x);

      void
      KnotsU (::std::unique_ptr< KnotsU_type > p);

      // KnotsV
      //
      typedef ::xsd::qif30::ArrayDoubleType KnotsV_type;
      typedef ::xsd::cxx::tree::traits< KnotsV_type, wchar_t > KnotsV_traits;

      const KnotsV_type&
      KnotsV () const;

      KnotsV_type&
      KnotsV ();

      void
      KnotsV (const KnotsV_type& x);

      void
      KnotsV (::std::unique_ptr< KnotsV_type > p);

      // CPs
      //
      typedef ::xsd::qif30::ArrayPointType CPs_type;
      typedef ::xsd::cxx::tree::optional< CPs_type > CPs_optional;
      typedef ::xsd::cxx::tree::traits< CPs_type, wchar_t > CPs_traits;

      const CPs_optional&
      CPs () const;

      CPs_optional&
      CPs ();

      void
      CPs (const CPs_type& x);

      void
      CPs (const CPs_optional& x);

      void
      CPs (::std::unique_ptr< CPs_type > p);

      // CPsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType CPsBinary_type;
      typedef ::xsd::cxx::tree::optional< CPsBinary_type > CPsBinary_optional;
      typedef ::xsd::cxx::tree::traits< CPsBinary_type, wchar_t > CPsBinary_traits;

      const CPsBinary_optional&
      CPsBinary () const;

      CPsBinary_optional&
      CPsBinary ();

      void
      CPsBinary (const CPsBinary_type& x);

      void
      CPsBinary (const CPsBinary_optional& x);

      void
      CPsBinary (::std::unique_ptr< CPsBinary_type > p);

      // Weights
      //
      typedef ::xsd::qif30::ArrayDoubleType Weights_type;
      typedef ::xsd::cxx::tree::optional< Weights_type > Weights_optional;
      typedef ::xsd::cxx::tree::traits< Weights_type, wchar_t > Weights_traits;

      const Weights_optional&
      Weights () const;

      Weights_optional&
      Weights ();

      void
      Weights (const Weights_type& x);

      void
      Weights (const Weights_optional& x);

      void
      Weights (::std::unique_ptr< Weights_type > p);

      // Constructors.
      //
      Nurbs23CoreType ();

      Nurbs23CoreType (const OrderU_type&,
                       const OrderV_type&,
                       const KnotsU_type&,
                       const KnotsV_type&);

      Nurbs23CoreType (const OrderU_type&,
                       const OrderV_type&,
                       ::std::unique_ptr< KnotsU_type >,
                       ::std::unique_ptr< KnotsV_type >);

      Nurbs23CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Nurbs23CoreType (const Nurbs23CoreType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Nurbs23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Nurbs23CoreType&
      operator= (const Nurbs23CoreType& x);

      virtual 
      ~Nurbs23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< OrderU_type > OrderU_;
      ::xsd::cxx::tree::one< OrderV_type > OrderV_;
      ::xsd::cxx::tree::one< KnotsU_type > KnotsU_;
      ::xsd::cxx::tree::one< KnotsV_type > KnotsV_;
      CPs_optional CPs_;
      CPsBinary_optional CPsBinary_;
      Weights_optional Weights_;
    };

    class QIF30_SYMBOL_DECL Nurbs23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Nurbs23Core
      //
      typedef ::xsd::qif30::Nurbs23CoreType Nurbs23Core_type;
      typedef ::xsd::cxx::tree::traits< Nurbs23Core_type, wchar_t > Nurbs23Core_traits;

      const Nurbs23Core_type&
      Nurbs23Core () const;

      Nurbs23Core_type&
      Nurbs23Core ();

      void
      Nurbs23Core (const Nurbs23Core_type& x);

      void
      Nurbs23Core (::std::unique_ptr< Nurbs23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Nurbs23Type ();

      Nurbs23Type (const id_type&,
                   const Nurbs23Core_type&);

      Nurbs23Type (const id_type&,
                   ::std::unique_ptr< Nurbs23Core_type >);

      Nurbs23Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      Nurbs23Type (const Nurbs23Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual Nurbs23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Nurbs23Type&
      operator= (const Nurbs23Type& x);

      virtual 
      ~Nurbs23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Nurbs23Core_type > Nurbs23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Spline23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // KnotsU
      //
      typedef ::xsd::qif30::ArrayDoubleType KnotsU_type;
      typedef ::xsd::cxx::tree::traits< KnotsU_type, wchar_t > KnotsU_traits;

      const KnotsU_type&
      KnotsU () const;

      KnotsU_type&
      KnotsU ();

      void
      KnotsU (const KnotsU_type& x);

      void
      KnotsU (::std::unique_ptr< KnotsU_type > p);

      // KnotsV
      //
      typedef ::xsd::qif30::ArrayDoubleType KnotsV_type;
      typedef ::xsd::cxx::tree::traits< KnotsV_type, wchar_t > KnotsV_traits;

      const KnotsV_type&
      KnotsV () const;

      KnotsV_type&
      KnotsV ();

      void
      KnotsV (const KnotsV_type& x);

      void
      KnotsV (::std::unique_ptr< KnotsV_type > p);

      // OrdersU
      //
      typedef ::xsd::qif30::ArrayNaturalType OrdersU_type;
      typedef ::xsd::cxx::tree::traits< OrdersU_type, wchar_t > OrdersU_traits;

      const OrdersU_type&
      OrdersU () const;

      OrdersU_type&
      OrdersU ();

      void
      OrdersU (const OrdersU_type& x);

      void
      OrdersU (::std::unique_ptr< OrdersU_type > p);

      // OrdersV
      //
      typedef ::xsd::qif30::ArrayNaturalType OrdersV_type;
      typedef ::xsd::cxx::tree::traits< OrdersV_type, wchar_t > OrdersV_traits;

      const OrdersV_type&
      OrdersV () const;

      OrdersV_type&
      OrdersV ();

      void
      OrdersV (const OrdersV_type& x);

      void
      OrdersV (::std::unique_ptr< OrdersV_type > p);

      // Coefficients
      //
      typedef ::xsd::qif30::ArrayPointType Coefficients_type;
      typedef ::xsd::cxx::tree::traits< Coefficients_type, wchar_t > Coefficients_traits;

      const Coefficients_type&
      Coefficients () const;

      Coefficients_type&
      Coefficients ();

      void
      Coefficients (const Coefficients_type& x);

      void
      Coefficients (::std::unique_ptr< Coefficients_type > p);

      // normalized
      //
      typedef ::xml_schema::boolean normalized_type;
      typedef ::xsd::cxx::tree::traits< normalized_type, wchar_t > normalized_traits;

      const normalized_type&
      normalized () const;

      normalized_type&
      normalized ();

      void
      normalized (const normalized_type& x);

      static normalized_type
      normalized_default_value ();

      // Constructors.
      //
      Spline23CoreType ();

      Spline23CoreType (const KnotsU_type&,
                        const KnotsV_type&,
                        const OrdersU_type&,
                        const OrdersV_type&,
                        const Coefficients_type&);

      Spline23CoreType (::std::unique_ptr< KnotsU_type >,
                        ::std::unique_ptr< KnotsV_type >,
                        ::std::unique_ptr< OrdersU_type >,
                        ::std::unique_ptr< OrdersV_type >,
                        ::std::unique_ptr< Coefficients_type >);

      Spline23CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      Spline23CoreType (const Spline23CoreType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual Spline23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Spline23CoreType&
      operator= (const Spline23CoreType& x);

      virtual 
      ~Spline23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< KnotsU_type > KnotsU_;
      ::xsd::cxx::tree::one< KnotsV_type > KnotsV_;
      ::xsd::cxx::tree::one< OrdersU_type > OrdersU_;
      ::xsd::cxx::tree::one< OrdersV_type > OrdersV_;
      ::xsd::cxx::tree::one< Coefficients_type > Coefficients_;
      ::xsd::cxx::tree::one< normalized_type > normalized_;
    };

    class QIF30_SYMBOL_DECL Spline23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Spline23Core
      //
      typedef ::xsd::qif30::Spline23CoreType Spline23Core_type;
      typedef ::xsd::cxx::tree::traits< Spline23Core_type, wchar_t > Spline23Core_traits;

      const Spline23Core_type&
      Spline23Core () const;

      Spline23Core_type&
      Spline23Core ();

      void
      Spline23Core (const Spline23Core_type& x);

      void
      Spline23Core (::std::unique_ptr< Spline23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Spline23Type ();

      Spline23Type (const id_type&,
                    const Spline23Core_type&);

      Spline23Type (const id_type&,
                    ::std::unique_ptr< Spline23Core_type >);

      Spline23Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      Spline23Type (const Spline23Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual Spline23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Spline23Type&
      operator= (const Spline23Type& x);

      virtual 
      ~Spline23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Spline23Core_type > Spline23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Revolution23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Generatrix
      //
      typedef ::xsd::qif30::Curve13CoreType Generatrix_type;
      typedef ::xsd::cxx::tree::traits< Generatrix_type, wchar_t > Generatrix_traits;

      const Generatrix_type&
      Generatrix () const;

      Generatrix_type&
      Generatrix ();

      void
      Generatrix (const Generatrix_type& x);

      void
      Generatrix (::std::unique_ptr< Generatrix_type > p);

      // angle
      //
      typedef ::xsd::qif30::ParameterRangeType angle_type;
      typedef ::xsd::cxx::tree::traits< angle_type, wchar_t > angle_traits;

      const angle_type&
      angle () const;

      angle_type&
      angle ();

      void
      angle (const angle_type& x);

      void
      angle (::std::unique_ptr< angle_type > p);

      // Constructors.
      //
      Revolution23CoreType ();

      Revolution23CoreType (const Axis_type&,
                            const Generatrix_type&,
                            const angle_type&);

      Revolution23CoreType (::std::unique_ptr< Axis_type >,
                            ::std::unique_ptr< Generatrix_type >,
                            const angle_type&);

      Revolution23CoreType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      Revolution23CoreType (const Revolution23CoreType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual Revolution23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Revolution23CoreType&
      operator= (const Revolution23CoreType& x);

      virtual 
      ~Revolution23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< Generatrix_type > Generatrix_;
      ::xsd::cxx::tree::one< angle_type > angle_;
    };

    class QIF30_SYMBOL_DECL Revolution23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Revolution23Core
      //
      typedef ::xsd::qif30::Revolution23CoreType Revolution23Core_type;
      typedef ::xsd::cxx::tree::traits< Revolution23Core_type, wchar_t > Revolution23Core_traits;

      const Revolution23Core_type&
      Revolution23Core () const;

      Revolution23Core_type&
      Revolution23Core ();

      void
      Revolution23Core (const Revolution23Core_type& x);

      void
      Revolution23Core (::std::unique_ptr< Revolution23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Revolution23Type ();

      Revolution23Type (const id_type&,
                        const Revolution23Core_type&);

      Revolution23Type (const id_type&,
                        ::std::unique_ptr< Revolution23Core_type >);

      Revolution23Type (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      Revolution23Type (const Revolution23Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual Revolution23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Revolution23Type&
      operator= (const Revolution23Type& x);

      virtual 
      ~Revolution23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Revolution23Core_type > Revolution23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Extrude23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // TerminationPoint
      //
      typedef ::xsd::qif30::PointSimpleType TerminationPoint_type;
      typedef ::xsd::cxx::tree::traits< TerminationPoint_type, wchar_t > TerminationPoint_traits;

      const TerminationPoint_type&
      TerminationPoint () const;

      TerminationPoint_type&
      TerminationPoint ();

      void
      TerminationPoint (const TerminationPoint_type& x);

      void
      TerminationPoint (::std::unique_ptr< TerminationPoint_type > p);

      // Curve
      //
      typedef ::xsd::qif30::Curve13CoreType Curve_type;
      typedef ::xsd::cxx::tree::traits< Curve_type, wchar_t > Curve_traits;

      const Curve_type&
      Curve () const;

      Curve_type&
      Curve ();

      void
      Curve (const Curve_type& x);

      void
      Curve (::std::unique_ptr< Curve_type > p);

      // Constructors.
      //
      Extrude23CoreType ();

      Extrude23CoreType (const TerminationPoint_type&,
                         const Curve_type&);

      Extrude23CoreType (const TerminationPoint_type&,
                         ::std::unique_ptr< Curve_type >);

      Extrude23CoreType (const xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Extrude23CoreType (const Extrude23CoreType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual Extrude23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Extrude23CoreType&
      operator= (const Extrude23CoreType& x);

      virtual 
      ~Extrude23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TerminationPoint_type > TerminationPoint_;
      ::xsd::cxx::tree::one< Curve_type > Curve_;
    };

    class QIF30_SYMBOL_DECL Extrude23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Extrude23Core
      //
      typedef ::xsd::qif30::Extrude23CoreType Extrude23Core_type;
      typedef ::xsd::cxx::tree::traits< Extrude23Core_type, wchar_t > Extrude23Core_traits;

      const Extrude23Core_type&
      Extrude23Core () const;

      Extrude23Core_type&
      Extrude23Core ();

      void
      Extrude23Core (const Extrude23Core_type& x);

      void
      Extrude23Core (::std::unique_ptr< Extrude23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Extrude23Type ();

      Extrude23Type (const id_type&,
                     const Extrude23Core_type&);

      Extrude23Type (const id_type&,
                     ::std::unique_ptr< Extrude23Core_type >);

      Extrude23Type (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      Extrude23Type (const Extrude23Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual Extrude23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Extrude23Type&
      operator= (const Extrude23Type& x);

      virtual 
      ~Extrude23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Extrude23Core_type > Extrude23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Ruled23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // Curve
      //
      typedef ::xsd::qif30::Curve13CoreType Curve_type;
      typedef ::xsd::cxx::tree::sequence< Curve_type > Curve_sequence;
      typedef xsd::cxx::tree::sequence< Curve_type >::iterator Curve_iterator;
      typedef xsd::cxx::tree::sequence< Curve_type >::const_iterator Curve_const_iterator;
      typedef ::xsd::cxx::tree::traits< Curve_type, wchar_t > Curve_traits;

      const Curve_sequence&
      Curve () const;

      Curve_sequence&
      Curve ();

      void
      Curve (const Curve_sequence& s);

      // turnedSecondCurve
      //
      typedef ::xml_schema::boolean turnedSecondCurve_type;
      typedef ::xsd::cxx::tree::traits< turnedSecondCurve_type, wchar_t > turnedSecondCurve_traits;

      const turnedSecondCurve_type&
      turnedSecondCurve () const;

      turnedSecondCurve_type&
      turnedSecondCurve ();

      void
      turnedSecondCurve (const turnedSecondCurve_type& x);

      static turnedSecondCurve_type
      turnedSecondCurve_default_value ();

      // Constructors.
      //
      Ruled23CoreType ();

      Ruled23CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Ruled23CoreType (const Ruled23CoreType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Ruled23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Ruled23CoreType&
      operator= (const Ruled23CoreType& x);

      virtual 
      ~Ruled23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Curve_sequence Curve_;
      ::xsd::cxx::tree::one< turnedSecondCurve_type > turnedSecondCurve_;
    };

    class QIF30_SYMBOL_DECL Ruled23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Ruled23Core
      //
      typedef ::xsd::qif30::Ruled23CoreType Ruled23Core_type;
      typedef ::xsd::cxx::tree::traits< Ruled23Core_type, wchar_t > Ruled23Core_traits;

      const Ruled23Core_type&
      Ruled23Core () const;

      Ruled23Core_type&
      Ruled23Core ();

      void
      Ruled23Core (const Ruled23Core_type& x);

      void
      Ruled23Core (::std::unique_ptr< Ruled23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Ruled23Type ();

      Ruled23Type (const id_type&,
                   const Ruled23Core_type&);

      Ruled23Type (const id_type&,
                   ::std::unique_ptr< Ruled23Core_type >);

      Ruled23Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      Ruled23Type (const Ruled23Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual Ruled23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Ruled23Type&
      operator= (const Ruled23Type& x);

      virtual 
      ~Ruled23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Ruled23Core_type > Ruled23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Offset23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // Distance
      //
      typedef ::xml_schema::double_ Distance_type;
      typedef ::xsd::cxx::tree::traits< Distance_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Distance_traits;

      const Distance_type&
      Distance () const;

      Distance_type&
      Distance ();

      void
      Distance (const Distance_type& x);

      // Surface
      //
      typedef ::xsd::qif30::SurfaceCoreType Surface_type;
      typedef ::xsd::cxx::tree::traits< Surface_type, wchar_t > Surface_traits;

      const Surface_type&
      Surface () const;

      Surface_type&
      Surface ();

      void
      Surface (const Surface_type& x);

      void
      Surface (::std::unique_ptr< Surface_type > p);

      // Constructors.
      //
      Offset23CoreType ();

      Offset23CoreType (const Distance_type&,
                        const Surface_type&);

      Offset23CoreType (const Distance_type&,
                        ::std::unique_ptr< Surface_type >);

      Offset23CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      Offset23CoreType (const Offset23CoreType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual Offset23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Offset23CoreType&
      operator= (const Offset23CoreType& x);

      virtual 
      ~Offset23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Distance_type > Distance_;
      ::xsd::cxx::tree::one< Surface_type > Surface_;
    };

    class QIF30_SYMBOL_DECL Offset23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Offset23Core
      //
      typedef ::xsd::qif30::Offset23CoreType Offset23Core_type;
      typedef ::xsd::cxx::tree::traits< Offset23Core_type, wchar_t > Offset23Core_traits;

      const Offset23Core_type&
      Offset23Core () const;

      Offset23Core_type&
      Offset23Core ();

      void
      Offset23Core (const Offset23Core_type& x);

      void
      Offset23Core (::std::unique_ptr< Offset23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Offset23Type ();

      Offset23Type (const id_type&,
                    const Offset23Core_type&);

      Offset23Type (const id_type&,
                    ::std::unique_ptr< Offset23Core_type >);

      Offset23Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      Offset23Type (const Offset23Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual Offset23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Offset23Type&
      operator= (const Offset23Type& x);

      virtual 
      ~Offset23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Offset23Core_type > Offset23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Plane23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // Origin
      //
      typedef ::xsd::qif30::PointSimpleType Origin_type;
      typedef ::xsd::cxx::tree::traits< Origin_type, wchar_t > Origin_traits;

      const Origin_type&
      Origin () const;

      Origin_type&
      Origin ();

      void
      Origin (const Origin_type& x);

      void
      Origin (::std::unique_ptr< Origin_type > p);

      // DirU
      //
      typedef ::xsd::qif30::VectorSimpleType DirU_type;
      typedef ::xsd::cxx::tree::traits< DirU_type, wchar_t > DirU_traits;

      const DirU_type&
      DirU () const;

      DirU_type&
      DirU ();

      void
      DirU (const DirU_type& x);

      void
      DirU (::std::unique_ptr< DirU_type > p);

      // DirV
      //
      typedef ::xsd::qif30::VectorSimpleType DirV_type;
      typedef ::xsd::cxx::tree::traits< DirV_type, wchar_t > DirV_traits;

      const DirV_type&
      DirV () const;

      DirV_type&
      DirV ();

      void
      DirV (const DirV_type& x);

      void
      DirV (::std::unique_ptr< DirV_type > p);

      // domainU
      //
      typedef ::xsd::qif30::ParameterRangeType domainU_type;
      typedef ::xsd::cxx::tree::traits< domainU_type, wchar_t > domainU_traits;

      const domainU_type&
      domainU () const;

      domainU_type&
      domainU ();

      void
      domainU (const domainU_type& x);

      void
      domainU (::std::unique_ptr< domainU_type > p);

      // domainV
      //
      typedef ::xsd::qif30::ParameterRangeType domainV_type;
      typedef ::xsd::cxx::tree::traits< domainV_type, wchar_t > domainV_traits;

      const domainV_type&
      domainV () const;

      domainV_type&
      domainV ();

      void
      domainV (const domainV_type& x);

      void
      domainV (::std::unique_ptr< domainV_type > p);

      // Constructors.
      //
      Plane23CoreType ();

      Plane23CoreType (const Origin_type&,
                       const DirU_type&,
                       const DirV_type&,
                       const domainU_type&,
                       const domainV_type&);

      Plane23CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Plane23CoreType (const Plane23CoreType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Plane23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Plane23CoreType&
      operator= (const Plane23CoreType& x);

      virtual 
      ~Plane23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Origin_type > Origin_;
      ::xsd::cxx::tree::one< DirU_type > DirU_;
      ::xsd::cxx::tree::one< DirV_type > DirV_;
      ::xsd::cxx::tree::one< domainU_type > domainU_;
      ::xsd::cxx::tree::one< domainV_type > domainV_;
    };

    class QIF30_SYMBOL_DECL Plane23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Plane23Core
      //
      typedef ::xsd::qif30::Plane23CoreType Plane23Core_type;
      typedef ::xsd::cxx::tree::traits< Plane23Core_type, wchar_t > Plane23Core_traits;

      const Plane23Core_type&
      Plane23Core () const;

      Plane23Core_type&
      Plane23Core ();

      void
      Plane23Core (const Plane23Core_type& x);

      void
      Plane23Core (::std::unique_ptr< Plane23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Plane23Type ();

      Plane23Type (const id_type&,
                   const Plane23Core_type&);

      Plane23Type (const id_type&,
                   ::std::unique_ptr< Plane23Core_type >);

      Plane23Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      Plane23Type (const Plane23Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual Plane23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Plane23Type&
      operator= (const Plane23Type& x);

      virtual 
      ~Plane23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Plane23Core_type > Plane23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Cone23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // DiameterBottom
      //
      typedef ::xml_schema::double_ DiameterBottom_type;
      typedef ::xsd::cxx::tree::traits< DiameterBottom_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > DiameterBottom_traits;

      const DiameterBottom_type&
      DiameterBottom () const;

      DiameterBottom_type&
      DiameterBottom ();

      void
      DiameterBottom (const DiameterBottom_type& x);

      // DiameterTop
      //
      typedef ::xml_schema::double_ DiameterTop_type;
      typedef ::xsd::cxx::tree::traits< DiameterTop_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > DiameterTop_traits;

      const DiameterTop_type&
      DiameterTop () const;

      DiameterTop_type&
      DiameterTop ();

      void
      DiameterTop (const DiameterTop_type& x);

      // Length
      //
      typedef ::xml_schema::double_ Length_type;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Length_traits;

      const Length_type&
      Length () const;

      Length_type&
      Length ();

      void
      Length (const Length_type& x);

      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_type&
      Sweep () const;

      Sweep_type&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // turnedV
      //
      typedef ::xml_schema::boolean turnedV_type;
      typedef ::xsd::cxx::tree::traits< turnedV_type, wchar_t > turnedV_traits;

      const turnedV_type&
      turnedV () const;

      turnedV_type&
      turnedV ();

      void
      turnedV (const turnedV_type& x);

      static turnedV_type
      turnedV_default_value ();

      // scaleU
      //
      typedef ::xsd::qif30::DoublePositiveType scaleU_type;
      typedef ::xsd::cxx::tree::traits< scaleU_type, wchar_t > scaleU_traits;

      const scaleU_type&
      scaleU () const;

      scaleU_type&
      scaleU ();

      void
      scaleU (const scaleU_type& x);

      void
      scaleU (::std::unique_ptr< scaleU_type > p);

      static scaleU_type
      scaleU_default_value ();

      // scaleV
      //
      typedef ::xsd::qif30::DoublePositiveType scaleV_type;
      typedef ::xsd::cxx::tree::traits< scaleV_type, wchar_t > scaleV_traits;

      const scaleV_type&
      scaleV () const;

      scaleV_type&
      scaleV ();

      void
      scaleV (const scaleV_type& x);

      void
      scaleV (::std::unique_ptr< scaleV_type > p);

      static scaleV_type
      scaleV_default_value ();

      // Constructors.
      //
      Cone23CoreType ();

      Cone23CoreType (const DiameterBottom_type&,
                      const DiameterTop_type&,
                      const Length_type&,
                      const Axis_type&,
                      const Sweep_type&);

      Cone23CoreType (const DiameterBottom_type&,
                      const DiameterTop_type&,
                      const Length_type&,
                      ::std::unique_ptr< Axis_type >,
                      ::std::unique_ptr< Sweep_type >);

      Cone23CoreType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      Cone23CoreType (const Cone23CoreType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual Cone23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Cone23CoreType&
      operator= (const Cone23CoreType& x);

      virtual 
      ~Cone23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DiameterBottom_type > DiameterBottom_;
      ::xsd::cxx::tree::one< DiameterTop_type > DiameterTop_;
      ::xsd::cxx::tree::one< Length_type > Length_;
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< Sweep_type > Sweep_;
      ::xsd::cxx::tree::one< turnedV_type > turnedV_;
      ::xsd::cxx::tree::one< scaleU_type > scaleU_;
      ::xsd::cxx::tree::one< scaleV_type > scaleV_;
    };

    class QIF30_SYMBOL_DECL Cone23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Cone23Core
      //
      typedef ::xsd::qif30::Cone23CoreType Cone23Core_type;
      typedef ::xsd::cxx::tree::traits< Cone23Core_type, wchar_t > Cone23Core_traits;

      const Cone23Core_type&
      Cone23Core () const;

      Cone23Core_type&
      Cone23Core ();

      void
      Cone23Core (const Cone23Core_type& x);

      void
      Cone23Core (::std::unique_ptr< Cone23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Cone23Type ();

      Cone23Type (const id_type&,
                  const Cone23Core_type&);

      Cone23Type (const id_type&,
                  ::std::unique_ptr< Cone23Core_type >);

      Cone23Type (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      Cone23Type (const Cone23Type& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual Cone23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Cone23Type&
      operator= (const Cone23Type& x);

      virtual 
      ~Cone23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Cone23Core_type > Cone23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Cylinder23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // Diameter
      //
      typedef ::xml_schema::double_ Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      // Length
      //
      typedef ::xml_schema::double_ Length_type;
      typedef ::xsd::cxx::tree::traits< Length_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Length_traits;

      const Length_type&
      Length () const;

      Length_type&
      Length ();

      void
      Length (const Length_type& x);

      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // Sweep
      //
      typedef ::xsd::qif30::SweepType Sweep_type;
      typedef ::xsd::cxx::tree::traits< Sweep_type, wchar_t > Sweep_traits;

      const Sweep_type&
      Sweep () const;

      Sweep_type&
      Sweep ();

      void
      Sweep (const Sweep_type& x);

      void
      Sweep (::std::unique_ptr< Sweep_type > p);

      // turnedV
      //
      typedef ::xml_schema::boolean turnedV_type;
      typedef ::xsd::cxx::tree::traits< turnedV_type, wchar_t > turnedV_traits;

      const turnedV_type&
      turnedV () const;

      turnedV_type&
      turnedV ();

      void
      turnedV (const turnedV_type& x);

      static turnedV_type
      turnedV_default_value ();

      // scaleU
      //
      typedef ::xsd::qif30::DoublePositiveType scaleU_type;
      typedef ::xsd::cxx::tree::traits< scaleU_type, wchar_t > scaleU_traits;

      const scaleU_type&
      scaleU () const;

      scaleU_type&
      scaleU ();

      void
      scaleU (const scaleU_type& x);

      void
      scaleU (::std::unique_ptr< scaleU_type > p);

      static scaleU_type
      scaleU_default_value ();

      // scaleV
      //
      typedef ::xsd::qif30::DoublePositiveType scaleV_type;
      typedef ::xsd::cxx::tree::traits< scaleV_type, wchar_t > scaleV_traits;

      const scaleV_type&
      scaleV () const;

      scaleV_type&
      scaleV ();

      void
      scaleV (const scaleV_type& x);

      void
      scaleV (::std::unique_ptr< scaleV_type > p);

      static scaleV_type
      scaleV_default_value ();

      // Constructors.
      //
      Cylinder23CoreType ();

      Cylinder23CoreType (const Diameter_type&,
                          const Length_type&,
                          const Axis_type&,
                          const Sweep_type&);

      Cylinder23CoreType (const Diameter_type&,
                          const Length_type&,
                          ::std::unique_ptr< Axis_type >,
                          ::std::unique_ptr< Sweep_type >);

      Cylinder23CoreType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      Cylinder23CoreType (const Cylinder23CoreType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual Cylinder23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Cylinder23CoreType&
      operator= (const Cylinder23CoreType& x);

      virtual 
      ~Cylinder23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      ::xsd::cxx::tree::one< Length_type > Length_;
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< Sweep_type > Sweep_;
      ::xsd::cxx::tree::one< turnedV_type > turnedV_;
      ::xsd::cxx::tree::one< scaleU_type > scaleU_;
      ::xsd::cxx::tree::one< scaleV_type > scaleV_;
    };

    class QIF30_SYMBOL_DECL Cylinder23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Cylinder23Core
      //
      typedef ::xsd::qif30::Cylinder23CoreType Cylinder23Core_type;
      typedef ::xsd::cxx::tree::traits< Cylinder23Core_type, wchar_t > Cylinder23Core_traits;

      const Cylinder23Core_type&
      Cylinder23Core () const;

      Cylinder23Core_type&
      Cylinder23Core ();

      void
      Cylinder23Core (const Cylinder23Core_type& x);

      void
      Cylinder23Core (::std::unique_ptr< Cylinder23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Cylinder23Type ();

      Cylinder23Type (const id_type&,
                      const Cylinder23Core_type&);

      Cylinder23Type (const id_type&,
                      ::std::unique_ptr< Cylinder23Core_type >);

      Cylinder23Type (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      Cylinder23Type (const Cylinder23Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual Cylinder23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Cylinder23Type&
      operator= (const Cylinder23Type& x);

      virtual 
      ~Cylinder23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Cylinder23Core_type > Cylinder23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Sphere23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // Diameter
      //
      typedef ::xml_schema::double_ Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      // Location
      //
      typedef ::xsd::qif30::PointSimpleType Location_type;
      typedef ::xsd::cxx::tree::traits< Location_type, wchar_t > Location_traits;

      const Location_type&
      Location () const;

      Location_type&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (::std::unique_ptr< Location_type > p);

      // LatitudeLongitudeSweep
      //
      typedef ::xsd::qif30::OrientedLatitudeLongitudeSweepType LatitudeLongitudeSweep_type;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweep_type, wchar_t > LatitudeLongitudeSweep_traits;

      const LatitudeLongitudeSweep_type&
      LatitudeLongitudeSweep () const;

      LatitudeLongitudeSweep_type&
      LatitudeLongitudeSweep ();

      void
      LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x);

      void
      LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > p);

      // turnedV
      //
      typedef ::xml_schema::boolean turnedV_type;
      typedef ::xsd::cxx::tree::traits< turnedV_type, wchar_t > turnedV_traits;

      const turnedV_type&
      turnedV () const;

      turnedV_type&
      turnedV ();

      void
      turnedV (const turnedV_type& x);

      static turnedV_type
      turnedV_default_value ();

      // scaleU
      //
      typedef ::xsd::qif30::DoublePositiveType scaleU_type;
      typedef ::xsd::cxx::tree::traits< scaleU_type, wchar_t > scaleU_traits;

      const scaleU_type&
      scaleU () const;

      scaleU_type&
      scaleU ();

      void
      scaleU (const scaleU_type& x);

      void
      scaleU (::std::unique_ptr< scaleU_type > p);

      static scaleU_type
      scaleU_default_value ();

      // scaleV
      //
      typedef ::xsd::qif30::DoublePositiveType scaleV_type;
      typedef ::xsd::cxx::tree::traits< scaleV_type, wchar_t > scaleV_traits;

      const scaleV_type&
      scaleV () const;

      scaleV_type&
      scaleV ();

      void
      scaleV (const scaleV_type& x);

      void
      scaleV (::std::unique_ptr< scaleV_type > p);

      static scaleV_type
      scaleV_default_value ();

      // Constructors.
      //
      Sphere23CoreType ();

      Sphere23CoreType (const Diameter_type&,
                        const Location_type&,
                        const LatitudeLongitudeSweep_type&);

      Sphere23CoreType (const Diameter_type&,
                        const Location_type&,
                        ::std::unique_ptr< LatitudeLongitudeSweep_type >);

      Sphere23CoreType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      Sphere23CoreType (const Sphere23CoreType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual Sphere23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Sphere23CoreType&
      operator= (const Sphere23CoreType& x);

      virtual 
      ~Sphere23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      ::xsd::cxx::tree::one< Location_type > Location_;
      ::xsd::cxx::tree::one< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep_;
      ::xsd::cxx::tree::one< turnedV_type > turnedV_;
      ::xsd::cxx::tree::one< scaleU_type > scaleU_;
      ::xsd::cxx::tree::one< scaleV_type > scaleV_;
    };

    class QIF30_SYMBOL_DECL Sphere23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Sphere23Core
      //
      typedef ::xsd::qif30::Sphere23CoreType Sphere23Core_type;
      typedef ::xsd::cxx::tree::traits< Sphere23Core_type, wchar_t > Sphere23Core_traits;

      const Sphere23Core_type&
      Sphere23Core () const;

      Sphere23Core_type&
      Sphere23Core ();

      void
      Sphere23Core (const Sphere23Core_type& x);

      void
      Sphere23Core (::std::unique_ptr< Sphere23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Sphere23Type ();

      Sphere23Type (const id_type&,
                    const Sphere23Core_type&);

      Sphere23Type (const id_type&,
                    ::std::unique_ptr< Sphere23Core_type >);

      Sphere23Type (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      Sphere23Type (const Sphere23Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual Sphere23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Sphere23Type&
      operator= (const Sphere23Type& x);

      virtual 
      ~Sphere23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Sphere23Core_type > Sphere23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL Torus23CoreType: public ::xsd::qif30::SurfaceCoreBaseType
    {
      public:
      // DiameterMinor
      //
      typedef ::xml_schema::double_ DiameterMinor_type;
      typedef ::xsd::cxx::tree::traits< DiameterMinor_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > DiameterMinor_traits;

      const DiameterMinor_type&
      DiameterMinor () const;

      DiameterMinor_type&
      DiameterMinor ();

      void
      DiameterMinor (const DiameterMinor_type& x);

      // DiameterMajor
      //
      typedef ::xml_schema::double_ DiameterMajor_type;
      typedef ::xsd::cxx::tree::traits< DiameterMajor_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > DiameterMajor_traits;

      const DiameterMajor_type&
      DiameterMajor () const;

      DiameterMajor_type&
      DiameterMajor ();

      void
      DiameterMajor (const DiameterMajor_type& x);

      // Axis
      //
      typedef ::xsd::qif30::AxisType Axis_type;
      typedef ::xsd::cxx::tree::traits< Axis_type, wchar_t > Axis_traits;

      const Axis_type&
      Axis () const;

      Axis_type&
      Axis ();

      void
      Axis (const Axis_type& x);

      void
      Axis (::std::unique_ptr< Axis_type > p);

      // LatitudeLongitudeSweep
      //
      typedef ::xsd::qif30::LatitudeLongitudeSweepType LatitudeLongitudeSweep_type;
      typedef ::xsd::cxx::tree::traits< LatitudeLongitudeSweep_type, wchar_t > LatitudeLongitudeSweep_traits;

      const LatitudeLongitudeSweep_type&
      LatitudeLongitudeSweep () const;

      LatitudeLongitudeSweep_type&
      LatitudeLongitudeSweep ();

      void
      LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x);

      void
      LatitudeLongitudeSweep (::std::unique_ptr< LatitudeLongitudeSweep_type > p);

      // turnedV
      //
      typedef ::xml_schema::boolean turnedV_type;
      typedef ::xsd::cxx::tree::traits< turnedV_type, wchar_t > turnedV_traits;

      const turnedV_type&
      turnedV () const;

      turnedV_type&
      turnedV ();

      void
      turnedV (const turnedV_type& x);

      static turnedV_type
      turnedV_default_value ();

      // offsetV
      //
      typedef ::xml_schema::double_ offsetV_type;
      typedef ::xsd::cxx::tree::traits< offsetV_type, wchar_t, ::xsd::cxx::tree::schema_type::double_ > offsetV_traits;

      const offsetV_type&
      offsetV () const;

      offsetV_type&
      offsetV ();

      void
      offsetV (const offsetV_type& x);

      static offsetV_type
      offsetV_default_value ();

      // scaleU
      //
      typedef ::xsd::qif30::DoublePositiveType scaleU_type;
      typedef ::xsd::cxx::tree::traits< scaleU_type, wchar_t > scaleU_traits;

      const scaleU_type&
      scaleU () const;

      scaleU_type&
      scaleU ();

      void
      scaleU (const scaleU_type& x);

      void
      scaleU (::std::unique_ptr< scaleU_type > p);

      static scaleU_type
      scaleU_default_value ();

      // scaleV
      //
      typedef ::xsd::qif30::DoublePositiveType scaleV_type;
      typedef ::xsd::cxx::tree::traits< scaleV_type, wchar_t > scaleV_traits;

      const scaleV_type&
      scaleV () const;

      scaleV_type&
      scaleV ();

      void
      scaleV (const scaleV_type& x);

      void
      scaleV (::std::unique_ptr< scaleV_type > p);

      static scaleV_type
      scaleV_default_value ();

      // Constructors.
      //
      Torus23CoreType ();

      Torus23CoreType (const DiameterMinor_type&,
                       const DiameterMajor_type&,
                       const Axis_type&,
                       const LatitudeLongitudeSweep_type&);

      Torus23CoreType (const DiameterMinor_type&,
                       const DiameterMajor_type&,
                       ::std::unique_ptr< Axis_type >,
                       ::std::unique_ptr< LatitudeLongitudeSweep_type >);

      Torus23CoreType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      Torus23CoreType (const Torus23CoreType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual Torus23CoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Torus23CoreType&
      operator= (const Torus23CoreType& x);

      virtual 
      ~Torus23CoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DiameterMinor_type > DiameterMinor_;
      ::xsd::cxx::tree::one< DiameterMajor_type > DiameterMajor_;
      ::xsd::cxx::tree::one< Axis_type > Axis_;
      ::xsd::cxx::tree::one< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep_;
      ::xsd::cxx::tree::one< turnedV_type > turnedV_;
      ::xsd::cxx::tree::one< offsetV_type > offsetV_;
      ::xsd::cxx::tree::one< scaleU_type > scaleU_;
      ::xsd::cxx::tree::one< scaleV_type > scaleV_;
    };

    class QIF30_SYMBOL_DECL Torus23Type: public ::xsd::qif30::SurfaceBaseType
    {
      public:
      // Torus23Core
      //
      typedef ::xsd::qif30::Torus23CoreType Torus23Core_type;
      typedef ::xsd::cxx::tree::traits< Torus23Core_type, wchar_t > Torus23Core_traits;

      const Torus23Core_type&
      Torus23Core () const;

      Torus23Core_type&
      Torus23Core ();

      void
      Torus23Core (const Torus23Core_type& x);

      void
      Torus23Core (::std::unique_ptr< Torus23Core_type > p);

      // Transform
      //
      typedef ::xsd::qif30::ElementReferenceType Transform_type;
      typedef ::xsd::cxx::tree::optional< Transform_type > Transform_optional;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_optional&
      Transform () const;

      Transform_optional&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (const Transform_optional& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      Torus23Type ();

      Torus23Type (const id_type&,
                   const Torus23Core_type&);

      Torus23Type (const id_type&,
                   ::std::unique_ptr< Torus23Core_type >);

      Torus23Type (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      Torus23Type (const Torus23Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual Torus23Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Torus23Type&
      operator= (const Torus23Type& x);

      virtual 
      ~Torus23Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Torus23Core_type > Torus23Core_;
      Transform_optional Transform_;
    };

    class QIF30_SYMBOL_DECL CurveMeshSetType: public ::xml_schema::type
    {
      public:
      // PathTriangulation
      //
      typedef ::xsd::qif30::PathTriangulationType PathTriangulation_type;
      typedef ::xsd::cxx::tree::sequence< PathTriangulation_type > PathTriangulation_sequence;
      typedef xsd::cxx::tree::sequence< PathTriangulation_type >::iterator PathTriangulation_iterator;
      typedef xsd::cxx::tree::sequence< PathTriangulation_type >::const_iterator PathTriangulation_const_iterator;
      typedef ::xsd::cxx::tree::traits< PathTriangulation_type, wchar_t > PathTriangulation_traits;

      const PathTriangulation_sequence&
      PathTriangulation () const;

      PathTriangulation_sequence&
      PathTriangulation ();

      void
      PathTriangulation (const PathTriangulation_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      CurveMeshSetType ();

      CurveMeshSetType (const n_type&);

      CurveMeshSetType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      CurveMeshSetType (const CurveMeshSetType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual CurveMeshSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CurveMeshSetType&
      operator= (const CurveMeshSetType& x);

      virtual 
      ~CurveMeshSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PathTriangulation_sequence PathTriangulation_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL PathTriangulationCoreType: public ::xml_schema::type
    {
      public:
      // Edges
      //
      typedef ::xsd::qif30::ArrayI2Type Edges_type;
      typedef ::xsd::cxx::tree::optional< Edges_type > Edges_optional;
      typedef ::xsd::cxx::tree::traits< Edges_type, wchar_t > Edges_traits;

      const Edges_optional&
      Edges () const;

      Edges_optional&
      Edges ();

      void
      Edges (const Edges_type& x);

      void
      Edges (const Edges_optional& x);

      void
      Edges (::std::unique_ptr< Edges_type > p);

      // EdgesBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType EdgesBinary_type;
      typedef ::xsd::cxx::tree::optional< EdgesBinary_type > EdgesBinary_optional;
      typedef ::xsd::cxx::tree::traits< EdgesBinary_type, wchar_t > EdgesBinary_traits;

      const EdgesBinary_optional&
      EdgesBinary () const;

      EdgesBinary_optional&
      EdgesBinary ();

      void
      EdgesBinary (const EdgesBinary_type& x);

      void
      EdgesBinary (const EdgesBinary_optional& x);

      void
      EdgesBinary (::std::unique_ptr< EdgesBinary_type > p);

      // Constructors.
      //
      PathTriangulationCoreType ();

      PathTriangulationCoreType (const xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      PathTriangulationCoreType (const PathTriangulationCoreType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual PathTriangulationCoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PathTriangulationCoreType&
      operator= (const PathTriangulationCoreType& x);

      virtual 
      ~PathTriangulationCoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Edges_optional Edges_;
      EdgesBinary_optional EdgesBinary_;
    };

    class QIF30_SYMBOL_DECL PathTriangulationType: public ::xsd::qif30::GeometryBaseType
    {
      public:
      // PathTriangulationCore
      //
      typedef ::xsd::qif30::PathTriangulationCoreType PathTriangulationCore_type;
      typedef ::xsd::cxx::tree::traits< PathTriangulationCore_type, wchar_t > PathTriangulationCore_traits;

      const PathTriangulationCore_type&
      PathTriangulationCore () const;

      PathTriangulationCore_type&
      PathTriangulationCore ();

      void
      PathTriangulationCore (const PathTriangulationCore_type& x);

      void
      PathTriangulationCore (::std::unique_ptr< PathTriangulationCore_type > p);

      // MeshTriangle
      //
      typedef ::xsd::qif30::ElementReferenceType MeshTriangle_type;
      typedef ::xsd::cxx::tree::traits< MeshTriangle_type, wchar_t > MeshTriangle_traits;

      const MeshTriangle_type&
      MeshTriangle () const;

      MeshTriangle_type&
      MeshTriangle ();

      void
      MeshTriangle (const MeshTriangle_type& x);

      void
      MeshTriangle (::std::unique_ptr< MeshTriangle_type > p);

      // Constructors.
      //
      PathTriangulationType ();

      PathTriangulationType (const id_type&,
                             const PathTriangulationCore_type&,
                             const MeshTriangle_type&);

      PathTriangulationType (const id_type&,
                             ::std::unique_ptr< PathTriangulationCore_type >,
                             ::std::unique_ptr< MeshTriangle_type >);

      PathTriangulationType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      PathTriangulationType (const PathTriangulationType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual PathTriangulationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PathTriangulationType&
      operator= (const PathTriangulationType& x);

      virtual 
      ~PathTriangulationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PathTriangulationCore_type > PathTriangulationCore_;
      ::xsd::cxx::tree::one< MeshTriangle_type > MeshTriangle_;
    };

    class QIF30_SYMBOL_DECL SurfaceMeshSetType: public ::xml_schema::type
    {
      public:
      // MeshTriangle
      //
      typedef ::xsd::qif30::MeshTriangleType MeshTriangle_type;
      typedef ::xsd::cxx::tree::sequence< MeshTriangle_type > MeshTriangle_sequence;
      typedef xsd::cxx::tree::sequence< MeshTriangle_type >::iterator MeshTriangle_iterator;
      typedef xsd::cxx::tree::sequence< MeshTriangle_type >::const_iterator MeshTriangle_const_iterator;
      typedef ::xsd::cxx::tree::traits< MeshTriangle_type, wchar_t > MeshTriangle_traits;

      const MeshTriangle_sequence&
      MeshTriangle () const;

      MeshTriangle_sequence&
      MeshTriangle ();

      void
      MeshTriangle (const MeshTriangle_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      SurfaceMeshSetType ();

      SurfaceMeshSetType (const n_type&);

      SurfaceMeshSetType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SurfaceMeshSetType (const SurfaceMeshSetType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SurfaceMeshSetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceMeshSetType&
      operator= (const SurfaceMeshSetType& x);

      virtual 
      ~SurfaceMeshSetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      MeshTriangle_sequence MeshTriangle_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MeshTriangleCoreType: public ::xml_schema::type
    {
      public:
      // Triangles
      //
      typedef ::xsd::qif30::ArrayI3Type Triangles_type;
      typedef ::xsd::cxx::tree::optional< Triangles_type > Triangles_optional;
      typedef ::xsd::cxx::tree::traits< Triangles_type, wchar_t > Triangles_traits;

      const Triangles_optional&
      Triangles () const;

      Triangles_optional&
      Triangles ();

      void
      Triangles (const Triangles_type& x);

      void
      Triangles (const Triangles_optional& x);

      void
      Triangles (::std::unique_ptr< Triangles_type > p);

      // TrianglesBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType TrianglesBinary_type;
      typedef ::xsd::cxx::tree::optional< TrianglesBinary_type > TrianglesBinary_optional;
      typedef ::xsd::cxx::tree::traits< TrianglesBinary_type, wchar_t > TrianglesBinary_traits;

      const TrianglesBinary_optional&
      TrianglesBinary () const;

      TrianglesBinary_optional&
      TrianglesBinary ();

      void
      TrianglesBinary (const TrianglesBinary_type& x);

      void
      TrianglesBinary (const TrianglesBinary_optional& x);

      void
      TrianglesBinary (::std::unique_ptr< TrianglesBinary_type > p);

      // Neighbours
      //
      typedef ::xsd::qif30::ArrayI3Type Neighbours_type;
      typedef ::xsd::cxx::tree::optional< Neighbours_type > Neighbours_optional;
      typedef ::xsd::cxx::tree::traits< Neighbours_type, wchar_t > Neighbours_traits;

      const Neighbours_optional&
      Neighbours () const;

      Neighbours_optional&
      Neighbours ();

      void
      Neighbours (const Neighbours_type& x);

      void
      Neighbours (const Neighbours_optional& x);

      void
      Neighbours (::std::unique_ptr< Neighbours_type > p);

      // NeighboursBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType NeighboursBinary_type;
      typedef ::xsd::cxx::tree::optional< NeighboursBinary_type > NeighboursBinary_optional;
      typedef ::xsd::cxx::tree::traits< NeighboursBinary_type, wchar_t > NeighboursBinary_traits;

      const NeighboursBinary_optional&
      NeighboursBinary () const;

      NeighboursBinary_optional&
      NeighboursBinary ();

      void
      NeighboursBinary (const NeighboursBinary_type& x);

      void
      NeighboursBinary (const NeighboursBinary_optional& x);

      void
      NeighboursBinary (::std::unique_ptr< NeighboursBinary_type > p);

      // Vertices
      //
      typedef ::xsd::qif30::ArrayPointType Vertices_type;
      typedef ::xsd::cxx::tree::optional< Vertices_type > Vertices_optional;
      typedef ::xsd::cxx::tree::traits< Vertices_type, wchar_t > Vertices_traits;

      const Vertices_optional&
      Vertices () const;

      Vertices_optional&
      Vertices ();

      void
      Vertices (const Vertices_type& x);

      void
      Vertices (const Vertices_optional& x);

      void
      Vertices (::std::unique_ptr< Vertices_type > p);

      // VerticesBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType VerticesBinary_type;
      typedef ::xsd::cxx::tree::optional< VerticesBinary_type > VerticesBinary_optional;
      typedef ::xsd::cxx::tree::traits< VerticesBinary_type, wchar_t > VerticesBinary_traits;

      const VerticesBinary_optional&
      VerticesBinary () const;

      VerticesBinary_optional&
      VerticesBinary ();

      void
      VerticesBinary (const VerticesBinary_type& x);

      void
      VerticesBinary (const VerticesBinary_optional& x);

      void
      VerticesBinary (::std::unique_ptr< VerticesBinary_type > p);

      // Normals
      //
      typedef ::xsd::qif30::ArrayUnitVectorType Normals_type;
      typedef ::xsd::cxx::tree::optional< Normals_type > Normals_optional;
      typedef ::xsd::cxx::tree::traits< Normals_type, wchar_t > Normals_traits;

      const Normals_optional&
      Normals () const;

      Normals_optional&
      Normals ();

      void
      Normals (const Normals_type& x);

      void
      Normals (const Normals_optional& x);

      void
      Normals (::std::unique_ptr< Normals_type > p);

      // NormalsBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType NormalsBinary_type;
      typedef ::xsd::cxx::tree::optional< NormalsBinary_type > NormalsBinary_optional;
      typedef ::xsd::cxx::tree::traits< NormalsBinary_type, wchar_t > NormalsBinary_traits;

      const NormalsBinary_optional&
      NormalsBinary () const;

      NormalsBinary_optional&
      NormalsBinary ();

      void
      NormalsBinary (const NormalsBinary_type& x);

      void
      NormalsBinary (const NormalsBinary_optional& x);

      void
      NormalsBinary (::std::unique_ptr< NormalsBinary_type > p);

      // Constructors.
      //
      MeshTriangleCoreType ();

      MeshTriangleCoreType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      MeshTriangleCoreType (const MeshTriangleCoreType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual MeshTriangleCoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeshTriangleCoreType&
      operator= (const MeshTriangleCoreType& x);

      virtual 
      ~MeshTriangleCoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Triangles_optional Triangles_;
      TrianglesBinary_optional TrianglesBinary_;
      Neighbours_optional Neighbours_;
      NeighboursBinary_optional NeighboursBinary_;
      Vertices_optional Vertices_;
      VerticesBinary_optional VerticesBinary_;
      Normals_optional Normals_;
      NormalsBinary_optional NormalsBinary_;
    };

    class QIF30_SYMBOL_DECL TriangleVertexNormalType: public ::xsd::qif30::UnitVectorType
    {
      public:
      // vertex
      //
      typedef ::xsd::qif30::I2Type vertex_type;
      typedef ::xsd::cxx::tree::traits< vertex_type, wchar_t > vertex_traits;

      const vertex_type&
      vertex () const;

      vertex_type&
      vertex ();

      void
      vertex (const vertex_type& x);

      void
      vertex (::std::unique_ptr< vertex_type > p);

      // Constructors.
      //
      TriangleVertexNormalType ();

      TriangleVertexNormalType (const vertex_type&);

      TriangleVertexNormalType (const ::xsd::qif30::ListDoubleType&,
                                const vertex_type&);

      TriangleVertexNormalType (const xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      TriangleVertexNormalType (const TriangleVertexNormalType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual TriangleVertexNormalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TriangleVertexNormalType&
      operator= (const TriangleVertexNormalType& x);

      virtual 
      ~TriangleVertexNormalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< vertex_type > vertex_;
    };

    class QIF30_SYMBOL_DECL ArrayTriangleVertexNormalType: public ::xml_schema::type
    {
      public:
      // NormalSpecial
      //
      typedef ::xsd::qif30::TriangleVertexNormalType NormalSpecial_type;
      typedef ::xsd::cxx::tree::sequence< NormalSpecial_type > NormalSpecial_sequence;
      typedef xsd::cxx::tree::sequence< NormalSpecial_type >::iterator NormalSpecial_iterator;
      typedef xsd::cxx::tree::sequence< NormalSpecial_type >::const_iterator NormalSpecial_const_iterator;
      typedef ::xsd::cxx::tree::traits< NormalSpecial_type, wchar_t > NormalSpecial_traits;

      const NormalSpecial_sequence&
      NormalSpecial () const;

      NormalSpecial_sequence&
      NormalSpecial ();

      void
      NormalSpecial (const NormalSpecial_sequence& s);

      // n
      //
      typedef ::xsd::qif30::NaturalType n_type;
      typedef ::xsd::cxx::tree::traits< n_type, wchar_t > n_traits;

      const n_type&
      n () const;

      n_type&
      n ();

      void
      n (const n_type& x);

      void
      n (::std::unique_ptr< n_type > p);

      // Constructors.
      //
      ArrayTriangleVertexNormalType ();

      ArrayTriangleVertexNormalType (const n_type&);

      ArrayTriangleVertexNormalType (const xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ArrayTriangleVertexNormalType (const ArrayTriangleVertexNormalType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ArrayTriangleVertexNormalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayTriangleVertexNormalType&
      operator= (const ArrayTriangleVertexNormalType& x);

      virtual 
      ~ArrayTriangleVertexNormalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      NormalSpecial_sequence NormalSpecial_;
      ::xsd::cxx::tree::one< n_type > n_;
    };

    class QIF30_SYMBOL_DECL MeshTriangleType: public ::xsd::qif30::GeometryBaseType
    {
      public:
      // MeshTriangleCore
      //
      typedef ::xsd::qif30::MeshTriangleCoreType MeshTriangleCore_type;
      typedef ::xsd::cxx::tree::traits< MeshTriangleCore_type, wchar_t > MeshTriangleCore_traits;

      const MeshTriangleCore_type&
      MeshTriangleCore () const;

      MeshTriangleCore_type&
      MeshTriangleCore ();

      void
      MeshTriangleCore (const MeshTriangleCore_type& x);

      void
      MeshTriangleCore (::std::unique_ptr< MeshTriangleCore_type > p);

      // NormalsSpecial
      //
      typedef ::xsd::qif30::ArrayTriangleVertexNormalType NormalsSpecial_type;
      typedef ::xsd::cxx::tree::optional< NormalsSpecial_type > NormalsSpecial_optional;
      typedef ::xsd::cxx::tree::traits< NormalsSpecial_type, wchar_t > NormalsSpecial_traits;

      const NormalsSpecial_optional&
      NormalsSpecial () const;

      NormalsSpecial_optional&
      NormalsSpecial ();

      void
      NormalsSpecial (const NormalsSpecial_type& x);

      void
      NormalsSpecial (const NormalsSpecial_optional& x);

      void
      NormalsSpecial (::std::unique_ptr< NormalsSpecial_type > p);

      // NormalsSpecialBinary
      //
      typedef ::xsd::qif30::ArrayBinaryType NormalsSpecialBinary_type;
      typedef ::xsd::cxx::tree::optional< NormalsSpecialBinary_type > NormalsSpecialBinary_optional;
      typedef ::xsd::cxx::tree::traits< NormalsSpecialBinary_type, wchar_t > NormalsSpecialBinary_traits;

      const NormalsSpecialBinary_optional&
      NormalsSpecialBinary () const;

      NormalsSpecialBinary_optional&
      NormalsSpecialBinary ();

      void
      NormalsSpecialBinary (const NormalsSpecialBinary_type& x);

      void
      NormalsSpecialBinary (const NormalsSpecialBinary_optional& x);

      void
      NormalsSpecialBinary (::std::unique_ptr< NormalsSpecialBinary_type > p);

      // Constructors.
      //
      MeshTriangleType ();

      MeshTriangleType (const id_type&,
                        const MeshTriangleCore_type&);

      MeshTriangleType (const id_type&,
                        ::std::unique_ptr< MeshTriangleCore_type >);

      MeshTriangleType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      MeshTriangleType (const MeshTriangleType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual MeshTriangleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeshTriangleType&
      operator= (const MeshTriangleType& x);

      virtual 
      ~MeshTriangleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MeshTriangleCore_type > MeshTriangleCore_;
      NormalsSpecial_optional NormalsSpecial_;
      NormalsSpecialBinary_optional NormalsSpecialBinary_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GeometrySetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const GeometryBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PointEntityType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Curve12SetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Curve13SetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Curve13CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveCoreBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Curve12BaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Curve13BaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Segment13CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Segment12CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Segment13Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Segment12Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcConicFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const ArcConicFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const ArcConicFormEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcConic13CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcConic12CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcConic12Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcConic13Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcCircular13CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcCircular12CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcCircular13Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArcCircular12Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Nurbs12CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Nurbs13CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Nurbs12Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Nurbs13Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Spline13CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Spline12CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Spline13Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Spline12Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Curve12OrientedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArraySubCurve12Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Aggregate12CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Curve13OrientedType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArraySubCurve13Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Aggregate13CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Aggregate12Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Aggregate13Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Polyline13CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Polyline12CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Polyline13Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Polyline12Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceCoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceCoreBaseType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Attr23CoreEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const Attr23CoreEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const Attr23CoreEnumType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Nurbs23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Nurbs23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Spline23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Spline23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Revolution23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Revolution23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Extrude23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Extrude23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Ruled23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Ruled23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Offset23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Offset23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Plane23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Plane23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Cone23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Cone23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Cylinder23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Cylinder23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Sphere23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Sphere23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Torus23CoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const Torus23Type&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CurveMeshSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PathTriangulationCoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PathTriangulationType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SurfaceMeshSetType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeshTriangleCoreType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const TriangleVertexNormalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ArrayTriangleVertexNormalType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const MeshTriangleType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_GEOMETRY_HXX
