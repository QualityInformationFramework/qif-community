// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef CXX___QIFLIBRARY_XMLDSIG_CORE_SCHEMA_QIF3_NAMESPACE_HXX
#define CXX___QIFLIBRARY_XMLDSIG_CORE_SCHEMA_QIF3_NAMESPACE_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

// Begin prologue.
//
#include "..\\export.hxx"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< wchar_t, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< wchar_t > error;
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< wchar_t > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< wchar_t > not_derived;
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif30
  {
    class CryptoBinary;
    class SignatureType;
    class SignatureValueType;
    class SignedInfoType;
    class CanonicalizationMethodType;
    class SignatureMethodType;
    class ReferenceType;
    class DsTransformsType;
    class DsTransformType;
    class DigestMethodType;
    class DigestValueType;
    class KeyInfoType;
    class KeyValueType;
    class RetrievalMethodType;
    class X509DataType;
    class X509IssuerSerialType;
    class PGPDataType;
    class SPKIDataType;
    class ObjectType;
    class ManifestType;
    class SignaturePropertiesType;
    class SignaturePropertyType;
    class HMACOutputLengthType;
    class DSAKeyValueType;
    class RSAKeyValueType;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace xsd
{
  namespace qif30
  {
    class QIF30_SYMBOL_DECL CryptoBinary: public ::xml_schema::base64_binary
    {
      public:
      // Constructors.
      //
      CryptoBinary ();

      CryptoBinary (const ::xml_schema::base64_binary&);

      CryptoBinary (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      CryptoBinary (const xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      CryptoBinary (const ::std::wstring& s,
                    const xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      CryptoBinary (const CryptoBinary& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual CryptoBinary*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      CryptoBinary&
      operator= (const CryptoBinary&) = default;
#endif

      virtual 
      ~CryptoBinary ();
    };

    class QIF30_SYMBOL_DECL SignatureType: public ::xml_schema::type
    {
      public:
      // SignedInfo
      //
      typedef ::xsd::qif30::SignedInfoType SignedInfo_type;
      typedef ::xsd::cxx::tree::traits< SignedInfo_type, wchar_t > SignedInfo_traits;

      const SignedInfo_type&
      SignedInfo () const;

      SignedInfo_type&
      SignedInfo ();

      void
      SignedInfo (const SignedInfo_type& x);

      void
      SignedInfo (::std::unique_ptr< SignedInfo_type > p);

      // SignatureValue
      //
      typedef ::xsd::qif30::SignatureValueType SignatureValue_type;
      typedef ::xsd::cxx::tree::traits< SignatureValue_type, wchar_t > SignatureValue_traits;

      const SignatureValue_type&
      SignatureValue () const;

      SignatureValue_type&
      SignatureValue ();

      void
      SignatureValue (const SignatureValue_type& x);

      void
      SignatureValue (::std::unique_ptr< SignatureValue_type > p);

      // KeyInfo
      //
      typedef ::xsd::qif30::KeyInfoType KeyInfo_type;
      typedef ::xsd::cxx::tree::optional< KeyInfo_type > KeyInfo_optional;
      typedef ::xsd::cxx::tree::traits< KeyInfo_type, wchar_t > KeyInfo_traits;

      const KeyInfo_optional&
      KeyInfo () const;

      KeyInfo_optional&
      KeyInfo ();

      void
      KeyInfo (const KeyInfo_type& x);

      void
      KeyInfo (const KeyInfo_optional& x);

      void
      KeyInfo (::std::unique_ptr< KeyInfo_type > p);

      // Object
      //
      typedef ::xsd::qif30::ObjectType Object_type;
      typedef ::xsd::cxx::tree::sequence< Object_type > Object_sequence;
      typedef xsd::cxx::tree::sequence< Object_type >::iterator Object_iterator;
      typedef xsd::cxx::tree::sequence< Object_type >::const_iterator Object_const_iterator;
      typedef ::xsd::cxx::tree::traits< Object_type, wchar_t > Object_traits;

      const Object_sequence&
      Object () const;

      Object_sequence&
      Object ();

      void
      Object (const Object_sequence& s);

      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      SignatureType ();

      SignatureType (const SignedInfo_type&,
                     const SignatureValue_type&);

      SignatureType (::std::unique_ptr< SignedInfo_type >,
                     ::std::unique_ptr< SignatureValue_type >);

      SignatureType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      SignatureType (const SignatureType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual SignatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignatureType&
      operator= (const SignatureType& x);

      virtual 
      ~SignatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SignedInfo_type > SignedInfo_;
      ::xsd::cxx::tree::one< SignatureValue_type > SignatureValue_;
      KeyInfo_optional KeyInfo_;
      Object_sequence Object_;
      Id_optional Id_;
    };

    class QIF30_SYMBOL_DECL SignatureValueType: public ::xml_schema::base64_binary
    {
      public:
      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      SignatureValueType ();

      SignatureValueType (const ::xml_schema::base64_binary&);

      SignatureValueType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SignatureValueType (const SignatureValueType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SignatureValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignatureValueType&
      operator= (const SignatureValueType& x);

      virtual 
      ~SignatureValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Id_optional Id_;
    };

    class QIF30_SYMBOL_DECL SignedInfoType: public ::xml_schema::type
    {
      public:
      // CanonicalizationMethod
      //
      typedef ::xsd::qif30::CanonicalizationMethodType CanonicalizationMethod_type;
      typedef ::xsd::cxx::tree::traits< CanonicalizationMethod_type, wchar_t > CanonicalizationMethod_traits;

      const CanonicalizationMethod_type&
      CanonicalizationMethod () const;

      CanonicalizationMethod_type&
      CanonicalizationMethod ();

      void
      CanonicalizationMethod (const CanonicalizationMethod_type& x);

      void
      CanonicalizationMethod (::std::unique_ptr< CanonicalizationMethod_type > p);

      // SignatureMethod
      //
      typedef ::xsd::qif30::SignatureMethodType SignatureMethod_type;
      typedef ::xsd::cxx::tree::traits< SignatureMethod_type, wchar_t > SignatureMethod_traits;

      const SignatureMethod_type&
      SignatureMethod () const;

      SignatureMethod_type&
      SignatureMethod ();

      void
      SignatureMethod (const SignatureMethod_type& x);

      void
      SignatureMethod (::std::unique_ptr< SignatureMethod_type > p);

      // Reference
      //
      typedef ::xsd::qif30::ReferenceType Reference_type;
      typedef ::xsd::cxx::tree::sequence< Reference_type > Reference_sequence;
      typedef xsd::cxx::tree::sequence< Reference_type >::iterator Reference_iterator;
      typedef xsd::cxx::tree::sequence< Reference_type >::const_iterator Reference_const_iterator;
      typedef ::xsd::cxx::tree::traits< Reference_type, wchar_t > Reference_traits;

      const Reference_sequence&
      Reference () const;

      Reference_sequence&
      Reference ();

      void
      Reference (const Reference_sequence& s);

      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      SignedInfoType ();

      SignedInfoType (const CanonicalizationMethod_type&,
                      const SignatureMethod_type&);

      SignedInfoType (::std::unique_ptr< CanonicalizationMethod_type >,
                      ::std::unique_ptr< SignatureMethod_type >);

      SignedInfoType (const xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SignedInfoType (const SignedInfoType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SignedInfoType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignedInfoType&
      operator= (const SignedInfoType& x);

      virtual 
      ~SignedInfoType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CanonicalizationMethod_type > CanonicalizationMethod_;
      ::xsd::cxx::tree::one< SignatureMethod_type > SignatureMethod_;
      Reference_sequence Reference_;
      Id_optional Id_;
    };

    class QIF30_SYMBOL_DECL CanonicalizationMethodType: public ::xml_schema::type
    {
      public:
      // Algorithm
      //
      typedef ::xml_schema::uri Algorithm_type;
      typedef ::xsd::cxx::tree::traits< Algorithm_type, wchar_t > Algorithm_traits;

      const Algorithm_type&
      Algorithm () const;

      Algorithm_type&
      Algorithm ();

      void
      Algorithm (const Algorithm_type& x);

      void
      Algorithm (::std::unique_ptr< Algorithm_type > p);

      // Constructors.
      //
      CanonicalizationMethodType ();

      CanonicalizationMethodType (const Algorithm_type&);

      CanonicalizationMethodType (const xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      CanonicalizationMethodType (const CanonicalizationMethodType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual CanonicalizationMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CanonicalizationMethodType&
      operator= (const CanonicalizationMethodType& x);

      virtual 
      ~CanonicalizationMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Algorithm_type > Algorithm_;
    };

    class QIF30_SYMBOL_DECL SignatureMethodType: public ::xml_schema::type
    {
      public:
      // HMACOutputLength
      //
      typedef ::xsd::qif30::HMACOutputLengthType HMACOutputLength_type;
      typedef ::xsd::cxx::tree::optional< HMACOutputLength_type > HMACOutputLength_optional;
      typedef ::xsd::cxx::tree::traits< HMACOutputLength_type, wchar_t > HMACOutputLength_traits;

      const HMACOutputLength_optional&
      HMACOutputLength () const;

      HMACOutputLength_optional&
      HMACOutputLength ();

      void
      HMACOutputLength (const HMACOutputLength_type& x);

      void
      HMACOutputLength (const HMACOutputLength_optional& x);

      void
      HMACOutputLength (::std::unique_ptr< HMACOutputLength_type > p);

      // Algorithm
      //
      typedef ::xml_schema::uri Algorithm_type;
      typedef ::xsd::cxx::tree::traits< Algorithm_type, wchar_t > Algorithm_traits;

      const Algorithm_type&
      Algorithm () const;

      Algorithm_type&
      Algorithm ();

      void
      Algorithm (const Algorithm_type& x);

      void
      Algorithm (::std::unique_ptr< Algorithm_type > p);

      // Constructors.
      //
      SignatureMethodType ();

      SignatureMethodType (const Algorithm_type&);

      SignatureMethodType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      SignatureMethodType (const SignatureMethodType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual SignatureMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignatureMethodType&
      operator= (const SignatureMethodType& x);

      virtual 
      ~SignatureMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      HMACOutputLength_optional HMACOutputLength_;
      ::xsd::cxx::tree::one< Algorithm_type > Algorithm_;
    };

    class QIF30_SYMBOL_DECL ReferenceType: public ::xml_schema::type
    {
      public:
      // Transforms
      //
      typedef ::xsd::qif30::DsTransformsType Transforms_type;
      typedef ::xsd::cxx::tree::traits< Transforms_type, wchar_t > Transforms_traits;

      const Transforms_type&
      Transforms () const;

      Transforms_type&
      Transforms ();

      void
      Transforms (const Transforms_type& x);

      void
      Transforms (::std::unique_ptr< Transforms_type > p);

      // DigestMethod
      //
      typedef ::xsd::qif30::DigestMethodType DigestMethod_type;
      typedef ::xsd::cxx::tree::traits< DigestMethod_type, wchar_t > DigestMethod_traits;

      const DigestMethod_type&
      DigestMethod () const;

      DigestMethod_type&
      DigestMethod ();

      void
      DigestMethod (const DigestMethod_type& x);

      void
      DigestMethod (::std::unique_ptr< DigestMethod_type > p);

      // DigestValue
      //
      typedef ::xsd::qif30::DigestValueType DigestValue_type;
      typedef ::xsd::cxx::tree::traits< DigestValue_type, wchar_t > DigestValue_traits;

      const DigestValue_type&
      DigestValue () const;

      DigestValue_type&
      DigestValue ();

      void
      DigestValue (const DigestValue_type& x);

      void
      DigestValue (::std::unique_ptr< DigestValue_type > p);

      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // URI
      //
      typedef ::xml_schema::uri URI_type;
      typedef ::xsd::cxx::tree::optional< URI_type > URI_optional;
      typedef ::xsd::cxx::tree::traits< URI_type, wchar_t > URI_traits;

      const URI_optional&
      URI () const;

      URI_optional&
      URI ();

      void
      URI (const URI_type& x);

      void
      URI (const URI_optional& x);

      void
      URI (::std::unique_ptr< URI_type > p);

      // Type
      //
      typedef ::xml_schema::uri Type_type;
      typedef ::xsd::cxx::tree::optional< Type_type > Type_optional;
      typedef ::xsd::cxx::tree::traits< Type_type, wchar_t > Type_traits;

      const Type_optional&
      Type () const;

      Type_optional&
      Type ();

      void
      Type (const Type_type& x);

      void
      Type (const Type_optional& x);

      void
      Type (::std::unique_ptr< Type_type > p);

      // Constructors.
      //
      ReferenceType ();

      ReferenceType (const Transforms_type&,
                     const DigestMethod_type&,
                     const DigestValue_type&);

      ReferenceType (::std::unique_ptr< Transforms_type >,
                     ::std::unique_ptr< DigestMethod_type >,
                     const DigestValue_type&);

      ReferenceType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ReferenceType (const ReferenceType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual ReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferenceType&
      operator= (const ReferenceType& x);

      virtual 
      ~ReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Transforms_type > Transforms_;
      ::xsd::cxx::tree::one< DigestMethod_type > DigestMethod_;
      ::xsd::cxx::tree::one< DigestValue_type > DigestValue_;
      Id_optional Id_;
      URI_optional URI_;
      Type_optional Type_;
    };

    class QIF30_SYMBOL_DECL DsTransformsType: public ::xml_schema::type
    {
      public:
      // Transform
      //
      typedef ::xsd::qif30::DsTransformType Transform_type;
      typedef ::xsd::cxx::tree::traits< Transform_type, wchar_t > Transform_traits;

      const Transform_type&
      Transform () const;

      Transform_type&
      Transform ();

      void
      Transform (const Transform_type& x);

      void
      Transform (::std::unique_ptr< Transform_type > p);

      // Constructors.
      //
      DsTransformsType ();

      DsTransformsType (const Transform_type&);

      DsTransformsType (::std::unique_ptr< Transform_type >);

      DsTransformsType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      DsTransformsType (const DsTransformsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual DsTransformsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DsTransformsType&
      operator= (const DsTransformsType& x);

      virtual 
      ~DsTransformsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Transform_type > Transform_;
    };

    class QIF30_SYMBOL_DECL DsTransformType: public ::xml_schema::type
    {
      public:
      // XPath
      //
      typedef ::xml_schema::string XPath_type;
      typedef ::xsd::cxx::tree::sequence< XPath_type > XPath_sequence;
      typedef xsd::cxx::tree::sequence< XPath_type >::iterator XPath_iterator;
      typedef xsd::cxx::tree::sequence< XPath_type >::const_iterator XPath_const_iterator;
      typedef ::xsd::cxx::tree::traits< XPath_type, wchar_t > XPath_traits;

      const XPath_sequence&
      XPath () const;

      XPath_sequence&
      XPath ();

      void
      XPath (const XPath_sequence& s);

      // Algorithm
      //
      typedef ::xml_schema::uri Algorithm_type;
      typedef ::xsd::cxx::tree::traits< Algorithm_type, wchar_t > Algorithm_traits;

      const Algorithm_type&
      Algorithm () const;

      Algorithm_type&
      Algorithm ();

      void
      Algorithm (const Algorithm_type& x);

      void
      Algorithm (::std::unique_ptr< Algorithm_type > p);

      // Constructors.
      //
      DsTransformType ();

      DsTransformType (const Algorithm_type&);

      DsTransformType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      DsTransformType (const DsTransformType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual DsTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DsTransformType&
      operator= (const DsTransformType& x);

      virtual 
      ~DsTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      XPath_sequence XPath_;
      ::xsd::cxx::tree::one< Algorithm_type > Algorithm_;
    };

    class QIF30_SYMBOL_DECL DigestMethodType: public ::xml_schema::type
    {
      public:
      // Algorithm
      //
      typedef ::xml_schema::uri Algorithm_type;
      typedef ::xsd::cxx::tree::traits< Algorithm_type, wchar_t > Algorithm_traits;

      const Algorithm_type&
      Algorithm () const;

      Algorithm_type&
      Algorithm ();

      void
      Algorithm (const Algorithm_type& x);

      void
      Algorithm (::std::unique_ptr< Algorithm_type > p);

      // Constructors.
      //
      DigestMethodType ();

      DigestMethodType (const Algorithm_type&);

      DigestMethodType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      DigestMethodType (const DigestMethodType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual DigestMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DigestMethodType&
      operator= (const DigestMethodType& x);

      virtual 
      ~DigestMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Algorithm_type > Algorithm_;
    };

    class QIF30_SYMBOL_DECL DigestValueType: public ::xml_schema::base64_binary
    {
      public:
      // Constructors.
      //
      DigestValueType ();

      DigestValueType (const ::xml_schema::base64_binary&);

      DigestValueType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      DigestValueType (const xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      DigestValueType (const ::std::wstring& s,
                       const xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      DigestValueType (const DigestValueType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual DigestValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      DigestValueType&
      operator= (const DigestValueType&) = default;
#endif

      virtual 
      ~DigestValueType ();
    };

    class QIF30_SYMBOL_DECL KeyInfoType: public ::xml_schema::type
    {
      public:
      // KeyName
      //
      typedef ::xml_schema::string KeyName_type;
      typedef ::xsd::cxx::tree::sequence< KeyName_type > KeyName_sequence;
      typedef xsd::cxx::tree::sequence< KeyName_type >::iterator KeyName_iterator;
      typedef xsd::cxx::tree::sequence< KeyName_type >::const_iterator KeyName_const_iterator;
      typedef ::xsd::cxx::tree::traits< KeyName_type, wchar_t > KeyName_traits;

      const KeyName_sequence&
      KeyName () const;

      KeyName_sequence&
      KeyName ();

      void
      KeyName (const KeyName_sequence& s);

      // KeyValue
      //
      typedef ::xsd::qif30::KeyValueType KeyValue_type;
      typedef ::xsd::cxx::tree::sequence< KeyValue_type > KeyValue_sequence;
      typedef xsd::cxx::tree::sequence< KeyValue_type >::iterator KeyValue_iterator;
      typedef xsd::cxx::tree::sequence< KeyValue_type >::const_iterator KeyValue_const_iterator;
      typedef ::xsd::cxx::tree::traits< KeyValue_type, wchar_t > KeyValue_traits;

      const KeyValue_sequence&
      KeyValue () const;

      KeyValue_sequence&
      KeyValue ();

      void
      KeyValue (const KeyValue_sequence& s);

      // RetrievalMethod
      //
      typedef ::xsd::qif30::RetrievalMethodType RetrievalMethod_type;
      typedef ::xsd::cxx::tree::sequence< RetrievalMethod_type > RetrievalMethod_sequence;
      typedef xsd::cxx::tree::sequence< RetrievalMethod_type >::iterator RetrievalMethod_iterator;
      typedef xsd::cxx::tree::sequence< RetrievalMethod_type >::const_iterator RetrievalMethod_const_iterator;
      typedef ::xsd::cxx::tree::traits< RetrievalMethod_type, wchar_t > RetrievalMethod_traits;

      const RetrievalMethod_sequence&
      RetrievalMethod () const;

      RetrievalMethod_sequence&
      RetrievalMethod ();

      void
      RetrievalMethod (const RetrievalMethod_sequence& s);

      // X509Data
      //
      typedef ::xsd::qif30::X509DataType X509Data_type;
      typedef ::xsd::cxx::tree::sequence< X509Data_type > X509Data_sequence;
      typedef xsd::cxx::tree::sequence< X509Data_type >::iterator X509Data_iterator;
      typedef xsd::cxx::tree::sequence< X509Data_type >::const_iterator X509Data_const_iterator;
      typedef ::xsd::cxx::tree::traits< X509Data_type, wchar_t > X509Data_traits;

      const X509Data_sequence&
      X509Data () const;

      X509Data_sequence&
      X509Data ();

      void
      X509Data (const X509Data_sequence& s);

      // PGPData
      //
      typedef ::xsd::qif30::PGPDataType PGPData_type;
      typedef ::xsd::cxx::tree::sequence< PGPData_type > PGPData_sequence;
      typedef xsd::cxx::tree::sequence< PGPData_type >::iterator PGPData_iterator;
      typedef xsd::cxx::tree::sequence< PGPData_type >::const_iterator PGPData_const_iterator;
      typedef ::xsd::cxx::tree::traits< PGPData_type, wchar_t > PGPData_traits;

      const PGPData_sequence&
      PGPData () const;

      PGPData_sequence&
      PGPData ();

      void
      PGPData (const PGPData_sequence& s);

      // SPKIData
      //
      typedef ::xsd::qif30::SPKIDataType SPKIData_type;
      typedef ::xsd::cxx::tree::sequence< SPKIData_type > SPKIData_sequence;
      typedef xsd::cxx::tree::sequence< SPKIData_type >::iterator SPKIData_iterator;
      typedef xsd::cxx::tree::sequence< SPKIData_type >::const_iterator SPKIData_const_iterator;
      typedef ::xsd::cxx::tree::traits< SPKIData_type, wchar_t > SPKIData_traits;

      const SPKIData_sequence&
      SPKIData () const;

      SPKIData_sequence&
      SPKIData ();

      void
      SPKIData (const SPKIData_sequence& s);

      // MgmtData
      //
      typedef ::xml_schema::string MgmtData_type;
      typedef ::xsd::cxx::tree::sequence< MgmtData_type > MgmtData_sequence;
      typedef xsd::cxx::tree::sequence< MgmtData_type >::iterator MgmtData_iterator;
      typedef xsd::cxx::tree::sequence< MgmtData_type >::const_iterator MgmtData_const_iterator;
      typedef ::xsd::cxx::tree::traits< MgmtData_type, wchar_t > MgmtData_traits;

      const MgmtData_sequence&
      MgmtData () const;

      MgmtData_sequence&
      MgmtData ();

      void
      MgmtData (const MgmtData_sequence& s);

      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      KeyInfoType ();

      KeyInfoType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      KeyInfoType (const KeyInfoType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual KeyInfoType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      KeyInfoType&
      operator= (const KeyInfoType& x);

      virtual 
      ~KeyInfoType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      KeyName_sequence KeyName_;
      KeyValue_sequence KeyValue_;
      RetrievalMethod_sequence RetrievalMethod_;
      X509Data_sequence X509Data_;
      PGPData_sequence PGPData_;
      SPKIData_sequence SPKIData_;
      MgmtData_sequence MgmtData_;
      Id_optional Id_;
    };

    class QIF30_SYMBOL_DECL KeyValueType: public ::xml_schema::type
    {
      public:
      // DSAKeyValue
      //
      typedef ::xsd::qif30::DSAKeyValueType DSAKeyValue_type;
      typedef ::xsd::cxx::tree::optional< DSAKeyValue_type > DSAKeyValue_optional;
      typedef ::xsd::cxx::tree::traits< DSAKeyValue_type, wchar_t > DSAKeyValue_traits;

      const DSAKeyValue_optional&
      DSAKeyValue () const;

      DSAKeyValue_optional&
      DSAKeyValue ();

      void
      DSAKeyValue (const DSAKeyValue_type& x);

      void
      DSAKeyValue (const DSAKeyValue_optional& x);

      void
      DSAKeyValue (::std::unique_ptr< DSAKeyValue_type > p);

      // RSAKeyValue
      //
      typedef ::xsd::qif30::RSAKeyValueType RSAKeyValue_type;
      typedef ::xsd::cxx::tree::optional< RSAKeyValue_type > RSAKeyValue_optional;
      typedef ::xsd::cxx::tree::traits< RSAKeyValue_type, wchar_t > RSAKeyValue_traits;

      const RSAKeyValue_optional&
      RSAKeyValue () const;

      RSAKeyValue_optional&
      RSAKeyValue ();

      void
      RSAKeyValue (const RSAKeyValue_type& x);

      void
      RSAKeyValue (const RSAKeyValue_optional& x);

      void
      RSAKeyValue (::std::unique_ptr< RSAKeyValue_type > p);

      // Constructors.
      //
      KeyValueType ();

      KeyValueType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      KeyValueType (const KeyValueType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual KeyValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      KeyValueType&
      operator= (const KeyValueType& x);

      virtual 
      ~KeyValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      DSAKeyValue_optional DSAKeyValue_;
      RSAKeyValue_optional RSAKeyValue_;
    };

    class QIF30_SYMBOL_DECL RetrievalMethodType: public ::xml_schema::type
    {
      public:
      // Transforms
      //
      typedef ::xsd::qif30::DsTransformsType Transforms_type;
      typedef ::xsd::cxx::tree::optional< Transforms_type > Transforms_optional;
      typedef ::xsd::cxx::tree::traits< Transforms_type, wchar_t > Transforms_traits;

      const Transforms_optional&
      Transforms () const;

      Transforms_optional&
      Transforms ();

      void
      Transforms (const Transforms_type& x);

      void
      Transforms (const Transforms_optional& x);

      void
      Transforms (::std::unique_ptr< Transforms_type > p);

      // URI
      //
      typedef ::xml_schema::uri URI_type;
      typedef ::xsd::cxx::tree::optional< URI_type > URI_optional;
      typedef ::xsd::cxx::tree::traits< URI_type, wchar_t > URI_traits;

      const URI_optional&
      URI () const;

      URI_optional&
      URI ();

      void
      URI (const URI_type& x);

      void
      URI (const URI_optional& x);

      void
      URI (::std::unique_ptr< URI_type > p);

      // Type
      //
      typedef ::xml_schema::uri Type_type;
      typedef ::xsd::cxx::tree::optional< Type_type > Type_optional;
      typedef ::xsd::cxx::tree::traits< Type_type, wchar_t > Type_traits;

      const Type_optional&
      Type () const;

      Type_optional&
      Type ();

      void
      Type (const Type_type& x);

      void
      Type (const Type_optional& x);

      void
      Type (::std::unique_ptr< Type_type > p);

      // Constructors.
      //
      RetrievalMethodType ();

      RetrievalMethodType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      RetrievalMethodType (const RetrievalMethodType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual RetrievalMethodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RetrievalMethodType&
      operator= (const RetrievalMethodType& x);

      virtual 
      ~RetrievalMethodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Transforms_optional Transforms_;
      URI_optional URI_;
      Type_optional Type_;
    };

    class QIF30_SYMBOL_DECL X509DataType: public ::xml_schema::type
    {
      public:
      // X509IssuerSerial
      //
      typedef ::xsd::qif30::X509IssuerSerialType X509IssuerSerial_type;
      typedef ::xsd::cxx::tree::sequence< X509IssuerSerial_type > X509IssuerSerial_sequence;
      typedef xsd::cxx::tree::sequence< X509IssuerSerial_type >::iterator X509IssuerSerial_iterator;
      typedef xsd::cxx::tree::sequence< X509IssuerSerial_type >::const_iterator X509IssuerSerial_const_iterator;
      typedef ::xsd::cxx::tree::traits< X509IssuerSerial_type, wchar_t > X509IssuerSerial_traits;

      const X509IssuerSerial_sequence&
      X509IssuerSerial () const;

      X509IssuerSerial_sequence&
      X509IssuerSerial ();

      void
      X509IssuerSerial (const X509IssuerSerial_sequence& s);

      // X509SKI
      //
      typedef ::xml_schema::base64_binary X509SKI_type;
      typedef ::xsd::cxx::tree::sequence< X509SKI_type > X509SKI_sequence;
      typedef xsd::cxx::tree::sequence< X509SKI_type >::iterator X509SKI_iterator;
      typedef xsd::cxx::tree::sequence< X509SKI_type >::const_iterator X509SKI_const_iterator;
      typedef ::xsd::cxx::tree::traits< X509SKI_type, wchar_t > X509SKI_traits;

      const X509SKI_sequence&
      X509SKI () const;

      X509SKI_sequence&
      X509SKI ();

      void
      X509SKI (const X509SKI_sequence& s);

      // X509SubjectName
      //
      typedef ::xml_schema::string X509SubjectName_type;
      typedef ::xsd::cxx::tree::sequence< X509SubjectName_type > X509SubjectName_sequence;
      typedef xsd::cxx::tree::sequence< X509SubjectName_type >::iterator X509SubjectName_iterator;
      typedef xsd::cxx::tree::sequence< X509SubjectName_type >::const_iterator X509SubjectName_const_iterator;
      typedef ::xsd::cxx::tree::traits< X509SubjectName_type, wchar_t > X509SubjectName_traits;

      const X509SubjectName_sequence&
      X509SubjectName () const;

      X509SubjectName_sequence&
      X509SubjectName ();

      void
      X509SubjectName (const X509SubjectName_sequence& s);

      // X509Certificate
      //
      typedef ::xml_schema::base64_binary X509Certificate_type;
      typedef ::xsd::cxx::tree::sequence< X509Certificate_type > X509Certificate_sequence;
      typedef xsd::cxx::tree::sequence< X509Certificate_type >::iterator X509Certificate_iterator;
      typedef xsd::cxx::tree::sequence< X509Certificate_type >::const_iterator X509Certificate_const_iterator;
      typedef ::xsd::cxx::tree::traits< X509Certificate_type, wchar_t > X509Certificate_traits;

      const X509Certificate_sequence&
      X509Certificate () const;

      X509Certificate_sequence&
      X509Certificate ();

      void
      X509Certificate (const X509Certificate_sequence& s);

      // X509CRL
      //
      typedef ::xml_schema::base64_binary X509CRL_type;
      typedef ::xsd::cxx::tree::sequence< X509CRL_type > X509CRL_sequence;
      typedef xsd::cxx::tree::sequence< X509CRL_type >::iterator X509CRL_iterator;
      typedef xsd::cxx::tree::sequence< X509CRL_type >::const_iterator X509CRL_const_iterator;
      typedef ::xsd::cxx::tree::traits< X509CRL_type, wchar_t > X509CRL_traits;

      const X509CRL_sequence&
      X509CRL () const;

      X509CRL_sequence&
      X509CRL ();

      void
      X509CRL (const X509CRL_sequence& s);

      // Constructors.
      //
      X509DataType ();

      X509DataType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      X509DataType (const X509DataType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual X509DataType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      X509DataType&
      operator= (const X509DataType& x);

      virtual 
      ~X509DataType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      X509IssuerSerial_sequence X509IssuerSerial_;
      X509SKI_sequence X509SKI_;
      X509SubjectName_sequence X509SubjectName_;
      X509Certificate_sequence X509Certificate_;
      X509CRL_sequence X509CRL_;
    };

    class QIF30_SYMBOL_DECL X509IssuerSerialType: public ::xml_schema::type
    {
      public:
      // X509IssuerName
      //
      typedef ::xml_schema::string X509IssuerName_type;
      typedef ::xsd::cxx::tree::traits< X509IssuerName_type, wchar_t > X509IssuerName_traits;

      const X509IssuerName_type&
      X509IssuerName () const;

      X509IssuerName_type&
      X509IssuerName ();

      void
      X509IssuerName (const X509IssuerName_type& x);

      void
      X509IssuerName (::std::unique_ptr< X509IssuerName_type > p);

      // X509SerialNumber
      //
      typedef ::xml_schema::integer X509SerialNumber_type;
      typedef ::xsd::cxx::tree::traits< X509SerialNumber_type, wchar_t > X509SerialNumber_traits;

      const X509SerialNumber_type&
      X509SerialNumber () const;

      X509SerialNumber_type&
      X509SerialNumber ();

      void
      X509SerialNumber (const X509SerialNumber_type& x);

      // Constructors.
      //
      X509IssuerSerialType ();

      X509IssuerSerialType (const X509IssuerName_type&,
                            const X509SerialNumber_type&);

      X509IssuerSerialType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      X509IssuerSerialType (const X509IssuerSerialType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual X509IssuerSerialType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      X509IssuerSerialType&
      operator= (const X509IssuerSerialType& x);

      virtual 
      ~X509IssuerSerialType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< X509IssuerName_type > X509IssuerName_;
      ::xsd::cxx::tree::one< X509SerialNumber_type > X509SerialNumber_;
    };

    class QIF30_SYMBOL_DECL PGPDataType: public ::xml_schema::type
    {
      public:
      // PGPKeyID
      //
      typedef ::xml_schema::base64_binary PGPKeyID_type;
      typedef ::xsd::cxx::tree::optional< PGPKeyID_type > PGPKeyID_optional;
      typedef ::xsd::cxx::tree::traits< PGPKeyID_type, wchar_t > PGPKeyID_traits;

      const PGPKeyID_optional&
      PGPKeyID () const;

      PGPKeyID_optional&
      PGPKeyID ();

      void
      PGPKeyID (const PGPKeyID_type& x);

      void
      PGPKeyID (const PGPKeyID_optional& x);

      void
      PGPKeyID (::std::unique_ptr< PGPKeyID_type > p);

      // PGPKeyPacket
      //
      typedef ::xml_schema::base64_binary PGPKeyPacket_type;
      typedef ::xsd::cxx::tree::optional< PGPKeyPacket_type > PGPKeyPacket_optional;
      typedef ::xsd::cxx::tree::traits< PGPKeyPacket_type, wchar_t > PGPKeyPacket_traits;

      const PGPKeyPacket_optional&
      PGPKeyPacket () const;

      PGPKeyPacket_optional&
      PGPKeyPacket ();

      void
      PGPKeyPacket (const PGPKeyPacket_type& x);

      void
      PGPKeyPacket (const PGPKeyPacket_optional& x);

      void
      PGPKeyPacket (::std::unique_ptr< PGPKeyPacket_type > p);

      // Constructors.
      //
      PGPDataType ();

      PGPDataType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      PGPDataType (const PGPDataType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual PGPDataType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PGPDataType&
      operator= (const PGPDataType& x);

      virtual 
      ~PGPDataType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      PGPKeyID_optional PGPKeyID_;
      PGPKeyPacket_optional PGPKeyPacket_;
    };

    class QIF30_SYMBOL_DECL SPKIDataType: public ::xml_schema::type
    {
      public:
      // SPKISexp
      //
      typedef ::xml_schema::base64_binary SPKISexp_type;
      typedef ::xsd::cxx::tree::sequence< SPKISexp_type > SPKISexp_sequence;
      typedef xsd::cxx::tree::sequence< SPKISexp_type >::iterator SPKISexp_iterator;
      typedef xsd::cxx::tree::sequence< SPKISexp_type >::const_iterator SPKISexp_const_iterator;
      typedef ::xsd::cxx::tree::traits< SPKISexp_type, wchar_t > SPKISexp_traits;

      const SPKISexp_sequence&
      SPKISexp () const;

      SPKISexp_sequence&
      SPKISexp ();

      void
      SPKISexp (const SPKISexp_sequence& s);

      // Constructors.
      //
      SPKIDataType ();

      SPKIDataType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      SPKIDataType (const SPKIDataType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual SPKIDataType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SPKIDataType&
      operator= (const SPKIDataType& x);

      virtual 
      ~SPKIDataType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SPKISexp_sequence SPKISexp_;
    };

    class QIF30_SYMBOL_DECL ObjectType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // MimeType
      //
      typedef ::xml_schema::string MimeType_type;
      typedef ::xsd::cxx::tree::optional< MimeType_type > MimeType_optional;
      typedef ::xsd::cxx::tree::traits< MimeType_type, wchar_t > MimeType_traits;

      const MimeType_optional&
      MimeType () const;

      MimeType_optional&
      MimeType ();

      void
      MimeType (const MimeType_type& x);

      void
      MimeType (const MimeType_optional& x);

      void
      MimeType (::std::unique_ptr< MimeType_type > p);

      // Encoding
      //
      typedef ::xml_schema::uri Encoding_type;
      typedef ::xsd::cxx::tree::optional< Encoding_type > Encoding_optional;
      typedef ::xsd::cxx::tree::traits< Encoding_type, wchar_t > Encoding_traits;

      const Encoding_optional&
      Encoding () const;

      Encoding_optional&
      Encoding ();

      void
      Encoding (const Encoding_type& x);

      void
      Encoding (const Encoding_optional& x);

      void
      Encoding (::std::unique_ptr< Encoding_type > p);

      // Constructors.
      //
      ObjectType ();

      ObjectType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ObjectType (const ObjectType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual ObjectType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ObjectType&
      operator= (const ObjectType& x);

      virtual 
      ~ObjectType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Id_optional Id_;
      MimeType_optional MimeType_;
      Encoding_optional Encoding_;
    };

    class QIF30_SYMBOL_DECL ManifestType: public ::xml_schema::type
    {
      public:
      // Reference
      //
      typedef ::xsd::qif30::ReferenceType Reference_type;
      typedef ::xsd::cxx::tree::sequence< Reference_type > Reference_sequence;
      typedef xsd::cxx::tree::sequence< Reference_type >::iterator Reference_iterator;
      typedef xsd::cxx::tree::sequence< Reference_type >::const_iterator Reference_const_iterator;
      typedef ::xsd::cxx::tree::traits< Reference_type, wchar_t > Reference_traits;

      const Reference_sequence&
      Reference () const;

      Reference_sequence&
      Reference ();

      void
      Reference (const Reference_sequence& s);

      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      ManifestType ();

      ManifestType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ManifestType (const ManifestType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ManifestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ManifestType&
      operator= (const ManifestType& x);

      virtual 
      ~ManifestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Reference_sequence Reference_;
      Id_optional Id_;
    };

    class QIF30_SYMBOL_DECL SignaturePropertiesType: public ::xml_schema::type
    {
      public:
      // SignatureProperty
      //
      typedef ::xsd::qif30::SignaturePropertyType SignatureProperty_type;
      typedef ::xsd::cxx::tree::sequence< SignatureProperty_type > SignatureProperty_sequence;
      typedef xsd::cxx::tree::sequence< SignatureProperty_type >::iterator SignatureProperty_iterator;
      typedef xsd::cxx::tree::sequence< SignatureProperty_type >::const_iterator SignatureProperty_const_iterator;
      typedef ::xsd::cxx::tree::traits< SignatureProperty_type, wchar_t > SignatureProperty_traits;

      const SignatureProperty_sequence&
      SignatureProperty () const;

      SignatureProperty_sequence&
      SignatureProperty ();

      void
      SignatureProperty (const SignatureProperty_sequence& s);

      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      SignaturePropertiesType ();

      SignaturePropertiesType (const xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SignaturePropertiesType (const SignaturePropertiesType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual SignaturePropertiesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignaturePropertiesType&
      operator= (const SignaturePropertiesType& x);

      virtual 
      ~SignaturePropertiesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SignatureProperty_sequence SignatureProperty_;
      Id_optional Id_;
    };

    class QIF30_SYMBOL_DECL SignaturePropertyType: public ::xml_schema::type
    {
      public:
      // Target
      //
      typedef ::xml_schema::uri Target_type;
      typedef ::xsd::cxx::tree::traits< Target_type, wchar_t > Target_traits;

      const Target_type&
      Target () const;

      Target_type&
      Target ();

      void
      Target (const Target_type& x);

      void
      Target (::std::unique_ptr< Target_type > p);

      // Id
      //
      typedef ::xml_schema::id Id_type;
      typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
      typedef ::xsd::cxx::tree::traits< Id_type, wchar_t > Id_traits;

      const Id_optional&
      Id () const;

      Id_optional&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (const Id_optional& x);

      void
      Id (::std::unique_ptr< Id_type > p);

      // Constructors.
      //
      SignaturePropertyType ();

      SignaturePropertyType (const Target_type&);

      SignaturePropertyType (const xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      SignaturePropertyType (const SignaturePropertyType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual SignaturePropertyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignaturePropertyType&
      operator= (const SignaturePropertyType& x);

      virtual 
      ~SignaturePropertyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Target_type > Target_;
      Id_optional Id_;
    };

    class QIF30_SYMBOL_DECL HMACOutputLengthType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      HMACOutputLengthType ();

      HMACOutputLengthType (const ::xml_schema::integer&);

      HMACOutputLengthType (const xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      HMACOutputLengthType (const xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      HMACOutputLengthType (const ::std::wstring& s,
                            const xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      HMACOutputLengthType (const HMACOutputLengthType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual HMACOutputLengthType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

#ifdef XSD_CXX11
      HMACOutputLengthType&
      operator= (const HMACOutputLengthType&) = default;
#endif

      virtual 
      ~HMACOutputLengthType ();
    };

    class QIF30_SYMBOL_DECL DSAKeyValueType: public ::xml_schema::type
    {
      public:
      // P
      //
      typedef ::xsd::qif30::CryptoBinary P_type;
      typedef ::xsd::cxx::tree::optional< P_type > P_optional;
      typedef ::xsd::cxx::tree::traits< P_type, wchar_t > P_traits;

      const P_optional&
      P () const;

      P_optional&
      P ();

      void
      P (const P_type& x);

      void
      P (const P_optional& x);

      void
      P (::std::unique_ptr< P_type > p);

      // Q
      //
      typedef ::xsd::qif30::CryptoBinary Q_type;
      typedef ::xsd::cxx::tree::optional< Q_type > Q_optional;
      typedef ::xsd::cxx::tree::traits< Q_type, wchar_t > Q_traits;

      const Q_optional&
      Q () const;

      Q_optional&
      Q ();

      void
      Q (const Q_type& x);

      void
      Q (const Q_optional& x);

      void
      Q (::std::unique_ptr< Q_type > p);

      // G
      //
      typedef ::xsd::qif30::CryptoBinary G_type;
      typedef ::xsd::cxx::tree::optional< G_type > G_optional;
      typedef ::xsd::cxx::tree::traits< G_type, wchar_t > G_traits;

      const G_optional&
      G () const;

      G_optional&
      G ();

      void
      G (const G_type& x);

      void
      G (const G_optional& x);

      void
      G (::std::unique_ptr< G_type > p);

      // Y
      //
      typedef ::xsd::qif30::CryptoBinary Y_type;
      typedef ::xsd::cxx::tree::traits< Y_type, wchar_t > Y_traits;

      const Y_type&
      Y () const;

      Y_type&
      Y ();

      void
      Y (const Y_type& x);

      void
      Y (::std::unique_ptr< Y_type > p);

      // J
      //
      typedef ::xsd::qif30::CryptoBinary J_type;
      typedef ::xsd::cxx::tree::optional< J_type > J_optional;
      typedef ::xsd::cxx::tree::traits< J_type, wchar_t > J_traits;

      const J_optional&
      J () const;

      J_optional&
      J ();

      void
      J (const J_type& x);

      void
      J (const J_optional& x);

      void
      J (::std::unique_ptr< J_type > p);

      // Seed
      //
      typedef ::xsd::qif30::CryptoBinary Seed_type;
      typedef ::xsd::cxx::tree::optional< Seed_type > Seed_optional;
      typedef ::xsd::cxx::tree::traits< Seed_type, wchar_t > Seed_traits;

      const Seed_optional&
      Seed () const;

      Seed_optional&
      Seed ();

      void
      Seed (const Seed_type& x);

      void
      Seed (const Seed_optional& x);

      void
      Seed (::std::unique_ptr< Seed_type > p);

      // PgenCounter
      //
      typedef ::xsd::qif30::CryptoBinary PgenCounter_type;
      typedef ::xsd::cxx::tree::optional< PgenCounter_type > PgenCounter_optional;
      typedef ::xsd::cxx::tree::traits< PgenCounter_type, wchar_t > PgenCounter_traits;

      const PgenCounter_optional&
      PgenCounter () const;

      PgenCounter_optional&
      PgenCounter ();

      void
      PgenCounter (const PgenCounter_type& x);

      void
      PgenCounter (const PgenCounter_optional& x);

      void
      PgenCounter (::std::unique_ptr< PgenCounter_type > p);

      // Constructors.
      //
      DSAKeyValueType ();

      DSAKeyValueType (const Y_type&);

      DSAKeyValueType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      DSAKeyValueType (const DSAKeyValueType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual DSAKeyValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DSAKeyValueType&
      operator= (const DSAKeyValueType& x);

      virtual 
      ~DSAKeyValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      P_optional P_;
      Q_optional Q_;
      G_optional G_;
      ::xsd::cxx::tree::one< Y_type > Y_;
      J_optional J_;
      Seed_optional Seed_;
      PgenCounter_optional PgenCounter_;
    };

    class QIF30_SYMBOL_DECL RSAKeyValueType: public ::xml_schema::type
    {
      public:
      // Modulus
      //
      typedef ::xsd::qif30::CryptoBinary Modulus_type;
      typedef ::xsd::cxx::tree::traits< Modulus_type, wchar_t > Modulus_traits;

      const Modulus_type&
      Modulus () const;

      Modulus_type&
      Modulus ();

      void
      Modulus (const Modulus_type& x);

      void
      Modulus (::std::unique_ptr< Modulus_type > p);

      // Exponent
      //
      typedef ::xsd::qif30::CryptoBinary Exponent_type;
      typedef ::xsd::cxx::tree::traits< Exponent_type, wchar_t > Exponent_traits;

      const Exponent_type&
      Exponent () const;

      Exponent_type&
      Exponent ();

      void
      Exponent (const Exponent_type& x);

      void
      Exponent (::std::unique_ptr< Exponent_type > p);

      // Constructors.
      //
      RSAKeyValueType ();

      RSAKeyValueType (const Modulus_type&,
                       const Exponent_type&);

      RSAKeyValueType (const xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      RSAKeyValueType (const RSAKeyValueType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual RSAKeyValueType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RSAKeyValueType&
      operator= (const RSAKeyValueType& x);

      virtual 
      ~RSAKeyValueType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Modulus_type > Modulus_;
      ::xsd::cxx::tree::one< Exponent_type > Exponent_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif30
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif30
  {
    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CryptoBinary&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const CryptoBinary&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const CryptoBinary&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SignatureType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SignatureValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SignedInfoType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const CanonicalizationMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SignatureMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ReferenceType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DsTransformsType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DsTransformType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DigestMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DigestValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const DigestValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const DigestValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const KeyInfoType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const KeyValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RetrievalMethodType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const X509DataType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const X509IssuerSerialType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const PGPDataType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SPKIDataType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ObjectType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const ManifestType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SignaturePropertiesType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const SignaturePropertyType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const HMACOutputLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMAttr&, const HMACOutputLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (::xml_schema::list_stream&,
                const HMACOutputLengthType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const DSAKeyValueType&);

    QIF30_SYMBOL_DECL
    void
    operator<< (xercesc::DOMElement&, const RSAKeyValueType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___QIFLIBRARY_XMLDSIG_CORE_SCHEMA_QIF3_NAMESPACE_HXX
